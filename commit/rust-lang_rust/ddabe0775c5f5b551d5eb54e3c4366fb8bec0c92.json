{"sha": "ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "node_id": "C_kwDOAAsO6NoAKGRkYWJlMDc3NWM1ZjViNTUxZDVlYjU0ZTNjNDM2NmZiOGJlYzBjOTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-03T14:30:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-03T14:30:36Z"}, "message": "Auto merge of #92518 - matthiaskrgr:rollup-fl8z4e7, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #90102 (Remove `NullOp::Box`)\n - #92011 (Use field span in `rustc_macros` when emitting decode call)\n - #92402 (Suggest while let x = y when encountering while x = y)\n - #92409 (Couple of libtest cleanups)\n - #92418 (Fix spacing in pretty printed PatKind::Struct with no fields)\n - #92444 (Consolidate Result's and Option's methods into fewer impl blocks)\n\nFailed merges:\n\n - #92483 (Stabilize `result_cloned` and `result_copied`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "710c45c1ed562d6bc165be9a3664a2cfb6f8f20a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/710c45c1ed562d6bc165be9a3664a2cfb6f8f20a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "html_url": "https://github.com/rust-lang/rust/commit/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5efe5727f5db54412cf2995d14def91140a5a42", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5efe5727f5db54412cf2995d14def91140a5a42", "html_url": "https://github.com/rust-lang/rust/commit/b5efe5727f5db54412cf2995d14def91140a5a42"}, {"sha": "13e284033e34609f5f911d3df989eddec4af3f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/13e284033e34609f5f911d3df989eddec4af3f1b", "html_url": "https://github.com/rust-lang/rust/commit/13e284033e34609f5f911d3df989eddec4af3f1b"}], "stats": {"total": 1293, "additions": 628, "deletions": 665}, "files": [{"sha": "91fa4595241dc764c31d291769b0fbb4f196b659", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -2461,7 +2461,11 @@ impl<'a> State<'a> {\n                     self.print_path(path, true, 0);\n                 }\n                 self.nbsp();\n-                self.word_space(\"{\");\n+                self.word(\"{\");\n+                let empty = fields.is_empty() && !etc;\n+                if !empty {\n+                    self.space();\n+                }\n                 self.commasep_cmnt(\n                     Consistent,\n                     &fields,\n@@ -2482,7 +2486,9 @@ impl<'a> State<'a> {\n                     }\n                     self.word(\"..\");\n                 }\n-                self.space();\n+                if !empty {\n+                    self.space();\n+                }\n                 self.word(\"}\");\n             }\n             PatKind::Tuple(ref elts) => {"}, {"sha": "fe34d6e7ca9dde71dcc2c6c7d50f6a85d4dd614c", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -1394,10 +1394,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Rvalue::NullaryOp(_op, _ty) => {\n                 // nullary ops take no dynamic input; no borrowck effect.\n-                //\n-                // FIXME: is above actually true? Do we want to track\n-                // the fact that uninitialized data can be created via\n-                // `NullOp::Box`?\n             }\n \n             Rvalue::Aggregate(ref aggregate_kind, ref operands) => {"}, {"sha": "b16f5af66f249b5b80588ad452eca32ddd282cbc", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -715,30 +715,6 @@ fn codegen_stmt<'tcx>(\n                     let operand = operand.load_scalar(fx);\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n-                Rvalue::NullaryOp(NullOp::Box, content_ty) => {\n-                    let usize_type = fx.clif_type(fx.tcx.types.usize).unwrap();\n-                    let content_ty = fx.monomorphize(content_ty);\n-                    let layout = fx.layout_of(content_ty);\n-                    let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n-                    let llalign = fx.bcx.ins().iconst(usize_type, layout.align.abi.bytes() as i64);\n-                    let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n-\n-                    // Allocate space:\n-                    let def_id =\n-                        match fx.tcx.lang_items().require(rustc_hir::LangItem::ExchangeMalloc) {\n-                            Ok(id) => id,\n-                            Err(s) => {\n-                                fx.tcx\n-                                    .sess\n-                                    .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n-                            }\n-                        };\n-                    let instance = ty::Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n-                    let func_ref = fx.get_function_ref(instance);\n-                    let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n-                    let ptr = fx.bcx.inst_results(call)[0];\n-                    lval.write_cvalue(fx, CValue::by_val(ptr, box_layout));\n-                }\n                 Rvalue::NullaryOp(null_op, ty) => {\n                     assert!(\n                         lval.layout()\n@@ -749,7 +725,6 @@ fn codegen_stmt<'tcx>(\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),\n                         NullOp::AlignOf => layout.align.abi.bytes(),\n-                        NullOp::Box => unreachable!(),\n                     };\n                     let val = CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), val.into());\n                     lval.write_cvalue(fx, val);"}, {"sha": "679c45767018d2810025de4ff761e964b98c3225", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -8,7 +8,6 @@ use crate::traits::*;\n use crate::MemFlags;\n \n use rustc_apfloat::{ieee, Float, Round, Status};\n-use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n@@ -486,39 +485,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 )\n             }\n \n-            mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n-                let content_ty = self.monomorphize(content_ty);\n-                let content_layout = bx.cx().layout_of(content_ty);\n-                let llsize = bx.cx().const_usize(content_layout.size.bytes());\n-                let llalign = bx.cx().const_usize(content_layout.align.abi.bytes());\n-                let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n-                let llty_ptr = bx.cx().backend_type(box_layout);\n-\n-                // Allocate space:\n-                let def_id = match bx.tcx().lang_items().require(LangItem::ExchangeMalloc) {\n-                    Ok(id) => id,\n-                    Err(s) => {\n-                        bx.cx().sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n-                    }\n-                };\n-                let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let r = bx.cx().get_fn_addr(instance);\n-                let ty = bx.type_func(&[bx.type_isize(), bx.type_isize()], bx.type_i8p());\n-                let call = bx.call(ty, r, &[llsize, llalign], None);\n-                let val = bx.pointercast(call, llty_ptr);\n-\n-                let operand = OperandRef { val: OperandValue::Immediate(val), layout: box_layout };\n-                (bx, operand)\n-            }\n-\n             mir::Rvalue::NullaryOp(null_op, ty) => {\n                 let ty = self.monomorphize(ty);\n                 assert!(bx.cx().type_is_sized(ty));\n                 let layout = bx.cx().layout_of(ty);\n                 let val = match null_op {\n                     mir::NullOp::SizeOf => layout.size.bytes(),\n                     mir::NullOp::AlignOf => layout.align.abi.bytes(),\n-                    mir::NullOp::Box => unreachable!(),\n                 };\n                 let val = bx.cx().const_usize(val);\n                 let tcx = self.cx.tcx();"}, {"sha": "30e9cbe4403549223410a44981096cc3d875532e", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -398,13 +398,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n-    fn box_alloc(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: &PlaceTy<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        Err(ConstEvalErrKind::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n-    }\n-\n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         // The step limit has already been hit in a previous call to `before_terminator`.\n         if ecx.machine.steps_remaining == 0 {"}, {"sha": "0fc3827d16c7e848e303db1bfb094bb60cd4cf0f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -156,7 +156,7 @@ pub enum StackPopCleanup {\n     /// `ret` stores the block we jump to on a normal return, while `unwind`\n     /// stores the block used for cleanup during unwinding.\n     Goto { ret: Option<mir::BasicBlock>, unwind: StackPopUnwind },\n-    /// Just do nothing: Used by Main and for the `box_alloc` hook in miri.\n+    /// Just do nothing: Used by Main and for TLS hooks in miri.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n     /// the entire `ecx` when it is done)."}, {"sha": "23ec3875cbc1a51a38d4cbec791f9d0044389166", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -212,12 +212,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         right: &ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n \n-    /// Heap allocations via the `box` keyword.\n-    fn box_alloc(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        dest: &PlaceTy<'tcx, Self::PointerTag>,\n-    ) -> InterpResult<'tcx>;\n-\n     /// Called to read the specified `local` from the `frame`.\n     /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads."}, {"sha": "3daa1d3c2b3e87ce3985f2f2ee234f5874feee5b", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -271,10 +271,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_immediate(place.to_ref(self), &dest)?;\n             }\n \n-            NullaryOp(mir::NullOp::Box, _) => {\n-                M::box_alloc(self, &dest)?;\n-            }\n-\n             NullaryOp(null_op, ty) => {\n                 let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty)?;\n                 let layout = self.layout_of(ty)?;\n@@ -289,7 +285,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val = match null_op {\n                     mir::NullOp::SizeOf => layout.size.bytes(),\n                     mir::NullOp::AlignOf => layout.align.abi.bytes(),\n-                    mir::NullOp::Box => unreachable!(),\n                 };\n                 self.write_scalar(Scalar::from_machine_usize(val, self), &dest)?;\n             }"}, {"sha": "dd749c0393473b06b42e3f49a4f541b73b9fa61c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -632,7 +632,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             }\n \n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n-            Rvalue::NullaryOp(NullOp::Box, _) => self.check_op(ops::HeapAllocation),\n             Rvalue::ShallowInitBox(_, _) => {}\n \n             Rvalue::UnaryOp(_, ref operand) => {"}, {"sha": "55fba5d7ddf69b6f4afacb52086d3ade40081b96", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -508,7 +508,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::NullaryOp(op, _) => match op {\n-                NullOp::Box => return Err(Unpromotable),\n                 NullOp::SizeOf => {}\n                 NullOp::AlignOf => {}\n             },"}, {"sha": "c17286dfbe38eeda17f547cc49c06611e8757550", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -1874,7 +1874,11 @@ impl<'a> State<'a> {\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n                 self.print_qpath(qpath, true);\n                 self.nbsp();\n-                self.word_space(\"{\");\n+                self.word(\"{\");\n+                let empty = fields.is_empty() && !etc;\n+                if !empty {\n+                    self.space();\n+                }\n                 self.commasep_cmnt(\n                     Consistent,\n                     &fields,\n@@ -1895,7 +1899,9 @@ impl<'a> State<'a> {\n                     }\n                     self.word(\"..\");\n                 }\n-                self.space();\n+                if !empty {\n+                    self.space();\n+                }\n                 self.word(\"}\");\n             }\n             PatKind::Or(ref pats) => {"}, {"sha": "3351564299ca521421e17a32143c69b91fa2776f", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -1,6 +1,7 @@\n use proc_macro2::TokenStream;\n-use quote::quote;\n+use quote::{quote, quote_spanned};\n use syn::parse_quote;\n+use syn::spanned::Spanned;\n \n pub fn type_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     let decoder_ty = quote! { __D };\n@@ -104,27 +105,30 @@ fn decodable_body(\n }\n \n fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro2::TokenStream {\n+    let field_span = field.ident.as_ref().map_or(field.ty.span(), |ident| ident.span());\n+\n     let decode_inner_method = if let syn::Type::Reference(_) = field.ty {\n         quote! { ::rustc_middle::ty::codec::RefDecodable::decode }\n     } else {\n         quote! { ::rustc_serialize::Decodable::decode }\n     };\n     let (decode_method, opt_field_name) = if is_struct {\n         let field_name = field.ident.as_ref().map_or_else(|| index.to_string(), |i| i.to_string());\n-        (\n-            proc_macro2::Ident::new(\"read_struct_field\", proc_macro2::Span::call_site()),\n-            quote! { #field_name, },\n-        )\n+        (proc_macro2::Ident::new(\"read_struct_field\", field_span), quote! { #field_name, })\n     } else {\n-        (\n-            proc_macro2::Ident::new(\"read_enum_variant_arg\", proc_macro2::Span::call_site()),\n-            quote! {},\n-        )\n+        (proc_macro2::Ident::new(\"read_enum_variant_arg\", field_span), quote! {})\n+    };\n+\n+    let __decoder = quote! { __decoder };\n+    // Use the span of the field for the method call, so\n+    // that backtraces will point to the field.\n+    let decode_call = quote_spanned! {field_span=>\n+        ::rustc_serialize::Decoder::#decode_method(\n+                #__decoder, #opt_field_name #decode_inner_method)\n     };\n \n     quote! {\n-        match ::rustc_serialize::Decoder::#decode_method(\n-            __decoder, #opt_field_name #decode_inner_method) {\n+        match #decode_call  {\n             ::std::result::Result::Ok(__res) => __res,\n             ::std::result::Result::Err(__err) => return ::std::result::Result::Err(__err),\n         }"}, {"sha": "52ef380001cb09e388ba7d8f84e0321c8b05745c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -2336,8 +2336,6 @@ pub enum NullOp {\n     SizeOf,\n     /// Returns the minimum alignment of a type\n     AlignOf,\n-    /// Creates a new uninitialized box for a value of that type\n-    Box,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]"}, {"sha": "dc53dc8de9de95129a800945dff0240da0a42bf2", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -195,7 +195,6 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, ref operand) => operand.ty(local_decls, tcx),\n             Rvalue::Discriminant(ref place) => place.ty(local_decls, tcx).ty.discriminant_ty(tcx),\n-            Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),\n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => tcx.types.usize,\n             Rvalue::Aggregate(ref ak, ref ops) => match **ak {\n                 AggregateKind::Array(ty) => tcx.mk_array(ty, ops.len() as u64),\n@@ -215,9 +214,7 @@ impl<'tcx> Rvalue<'tcx> {\n     /// whether its only shallowly initialized (`Rvalue::Box`).\n     pub fn initialization_state(&self) -> RvalueInitializationState {\n         match *self {\n-            Rvalue::NullaryOp(NullOp::Box, _) | Rvalue::ShallowInitBox(_, _) => {\n-                RvalueInitializationState::Shallow\n-            }\n+            Rvalue::ShallowInitBox(_, _) => RvalueInitializationState::Shallow,\n             _ => RvalueInitializationState::Deep,\n         }\n     }"}, {"sha": "2e00b4f9a5e7cbb4ba1ad3a7e3d122963d9c99c1", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -343,19 +343,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | Rvalue::AddressOf(..)\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(..)\n-            | Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _)\n-            | Rvalue::NullaryOp(NullOp::Box, _) => {\n-                // This returns an rvalue with uninitialized contents. We can't\n-                // move out of it here because it is an rvalue - assignments always\n-                // completely initialize their place.\n-                //\n-                // However, this does not matter - MIR building is careful to\n-                // only emit a shallow free for the partially-initialized\n-                // temporary.\n-                //\n-                // In any case, if we want to fix this, we have to register a\n-                // special move and change the `statement_effect` functions.\n-            }\n+            | Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n         }\n     }\n "}, {"sha": "ecc8e7a6f1a390d8c03bbd57d6b0c4785cee7f5f", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -239,13 +239,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn box_alloc(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: &PlaceTy<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"can't const prop heap allocations\")\n-    }\n-\n     fn access_local(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,"}, {"sha": "b70c24b76d524cbfe78920d9f17e6368a2d8bed8", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -688,15 +688,6 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     _ => bug!(),\n                 }\n             }\n-            mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n-                let tcx = self.tcx;\n-                let exchange_malloc_fn_def_id =\n-                    tcx.require_lang_item(LangItem::ExchangeMalloc, None);\n-                let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n-                if should_codegen_locally(tcx, &instance) {\n-                    self.output.push(create_fn_mono_item(self.tcx, instance, span));\n-                }\n-            }\n             mir::Rvalue::ThreadLocalRef(def_id) => {\n                 assert!(self.tcx.is_thread_local_static(def_id));\n                 let instance = Instance::mono(self.tcx, def_id);"}, {"sha": "573050231383838bf1777915d2160216d190ae6c", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -2379,7 +2379,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ExprKind::While(ref cond, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n                     this.with_rib(ValueNS, NormalRibKind, |this| {\n+                        let old = this.diagnostic_metadata.in_if_condition.replace(cond);\n                         this.visit_expr(cond);\n+                        this.diagnostic_metadata.in_if_condition = old;\n                         this.visit_block(block);\n                     })\n                 });"}, {"sha": "0022df4f65ff7cffd1a430d7afbe7b129ba2864d", "filename": "library/core/src/option.rs", "status": "modified", "additions": 118, "deletions": 122, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -810,6 +810,45 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Returns the contained [`Some`] value or a default.\n+    ///\n+    /// Consumes the `self` argument then, if [`Some`], returns the contained\n+    /// value, otherwise if [`None`], returns the [default value] for that\n+    /// type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Converts a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). [`parse`] converts\n+    /// a string to any other type that implements [`FromStr`], returning\n+    /// [`None`] on error.\n+    ///\n+    /// ```\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n+    ///\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n+    /// ```\n+    ///\n+    /// [default value]: Default::default\n+    /// [`parse`]: str::parse\n+    /// [`FromStr`]: crate::str::FromStr\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn unwrap_or_default(self) -> T\n+    where\n+        T: ~const Default,\n+    {\n+        match self {\n+            Some(x) => x,\n+            None => Default::default(),\n+        }\n+    }\n+\n     /// Returns the contained [`Some`] value, consuming the `self` value,\n     /// without checking that the value is not [`None`].\n     ///\n@@ -1033,6 +1072,58 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n+    ///\n+    /// Leaves the original Option in-place, creating a new one with a reference\n+    /// to the original one, additionally coercing the contents via [`Deref`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n+    ///\n+    /// let x: Option<String> = None;\n+    /// assert_eq!(x.as_deref(), None);\n+    /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_deref(&self) -> Option<&T::Target>\n+    where\n+        T: ~const Deref,\n+    {\n+        match self.as_ref() {\n+            Some(t) => Some(t.deref()),\n+            None => None,\n+        }\n+    }\n+\n+    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n+    ///\n+    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n+    /// the inner type's [`Deref::Target`] type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref_mut().map(|x| {\n+    ///     x.make_ascii_uppercase();\n+    ///     x\n+    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n+    where\n+        T: ~const DerefMut,\n+    {\n+        match self.as_mut() {\n+            Some(t) => Some(t.deref_mut()),\n+            None => None,\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -1581,7 +1672,7 @@ impl<T, U> Option<(T, U)> {\n     }\n }\n \n-impl<T: Copy> Option<&T> {\n+impl<T> Option<&T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n     /// option.\n     ///\n@@ -1597,41 +1688,18 @@ impl<T: Copy> Option<&T> {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"copied\", since = \"1.35.0\")]\n     #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n-    pub const fn copied(self) -> Option<T> {\n+    pub const fn copied(self) -> Option<T>\n+    where\n+        T: Copy,\n+    {\n         // FIXME: this implementation, which sidesteps using `Option::map` since it's not const\n         // ready yet, should be reverted when possible to avoid code repetition\n         match self {\n             Some(&v) => Some(v),\n             None => None,\n         }\n     }\n-}\n \n-impl<T: Copy> Option<&mut T> {\n-    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n-    /// option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut x = 12;\n-    /// let opt_x = Some(&mut x);\n-    /// assert_eq!(opt_x, Some(&mut 12));\n-    /// let copied = opt_x.copied();\n-    /// assert_eq!(copied, Some(12));\n-    /// ```\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n-    #[stable(feature = \"copied\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn copied(self) -> Option<T> {\n-        match self {\n-            Some(&mut t) => Some(t),\n-            None => None,\n-        }\n-    }\n-}\n-\n-impl<T: Clone> Option<&T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n     /// option.\n     ///\n@@ -1658,8 +1726,8 @@ impl<T: Clone> Option<&T> {\n     }\n }\n \n-impl<T: Clone> Option<&mut T> {\n-    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n+impl<T> Option<&mut T> {\n+    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n     /// option.\n     ///\n     /// # Examples\n@@ -1668,115 +1736,43 @@ impl<T: Clone> Option<&mut T> {\n     /// let mut x = 12;\n     /// let opt_x = Some(&mut x);\n     /// assert_eq!(opt_x, Some(&mut 12));\n-    /// let cloned = opt_x.cloned();\n-    /// assert_eq!(cloned, Some(12));\n+    /// let copied = opt_x.copied();\n+    /// assert_eq!(copied, Some(12));\n     /// ```\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n-    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n-    #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n-    pub const fn cloned(self) -> Option<T>\n-    where\n-        T: ~const Clone,\n-    {\n-        match self {\n-            Some(t) => Some(t.clone()),\n-            None => None,\n-        }\n-    }\n-}\n-\n-impl<T: Default> Option<T> {\n-    /// Returns the contained [`Some`] value or a default.\n-    ///\n-    /// Consumes the `self` argument then, if [`Some`], returns the contained\n-    /// value, otherwise if [`None`], returns the [default value] for that\n-    /// type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Converts a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). [`parse`] converts\n-    /// a string to any other type that implements [`FromStr`], returning\n-    /// [`None`] on error.\n-    ///\n-    /// ```\n-    /// let good_year_from_input = \"1909\";\n-    /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n-    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n-    ///\n-    /// assert_eq!(1909, good_year);\n-    /// assert_eq!(0, bad_year);\n-    /// ```\n-    ///\n-    /// [default value]: Default::default\n-    /// [`parse`]: str::parse\n-    /// [`FromStr`]: crate::str::FromStr\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[stable(feature = \"copied\", since = \"1.35.0\")]\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn unwrap_or_default(self) -> T\n+    pub const fn copied(self) -> Option<T>\n     where\n-        T: ~const Default,\n+        T: Copy,\n     {\n         match self {\n-            Some(x) => x,\n-            None => Default::default(),\n-        }\n-    }\n-}\n-\n-impl<T: Deref> Option<T> {\n-    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n-    ///\n-    /// Leaves the original Option in-place, creating a new one with a reference\n-    /// to the original one, additionally coercing the contents via [`Deref`].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x: Option<String> = Some(\"hey\".to_owned());\n-    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n-    ///\n-    /// let x: Option<String> = None;\n-    /// assert_eq!(x.as_deref(), None);\n-    /// ```\n-    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn as_deref(&self) -> Option<&T::Target>\n-    where\n-        T: ~const Deref,\n-    {\n-        match self.as_ref() {\n-            Some(t) => Some(t.deref()),\n+            Some(&mut t) => Some(t),\n             None => None,\n         }\n     }\n-}\n \n-impl<T: DerefMut> Option<T> {\n-    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n-    ///\n-    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n-    /// the inner type's [`Deref::Target`] type.\n+    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n+    /// option.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n-    /// assert_eq!(x.as_deref_mut().map(|x| {\n-    ///     x.make_ascii_uppercase();\n-    ///     x\n-    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// let mut x = 12;\n+    /// let opt_x = Some(&mut x);\n+    /// assert_eq!(opt_x, Some(&mut 12));\n+    /// let cloned = opt_x.cloned();\n+    /// assert_eq!(cloned, Some(12));\n     /// ```\n-    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n+    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n+    #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n+    pub const fn cloned(self) -> Option<T>\n     where\n-        T: ~const DerefMut,\n+        T: ~const Clone,\n     {\n-        match self.as_mut() {\n-            Some(t) => Some(t.deref_mut()),\n+        match self {\n+            Some(t) => Some(t.clone()),\n             None => None,\n         }\n     }"}, {"sha": "f46632e7a8d2030b78f5a9b5986737d98a4a46c4", "filename": "library/core/src/result.rs", "status": "modified", "additions": 401, "deletions": 376, "changes": 777, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -901,6 +901,56 @@ impl<T, E> Result<T, E> {\n         self\n     }\n \n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n+    ///\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&str, &u32> = Ok(\"hello\");\n+    /// assert_eq!(x.as_deref(), y);\n+    ///\n+    /// let x: Result<String, u32> = Err(42);\n+    /// let y: Result<&str, &u32> = Err(&42);\n+    /// assert_eq!(x.as_deref(), y);\n+    /// ```\n+    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n+    pub fn as_deref(&self) -> Result<&T::Target, &E>\n+    where\n+        T: Deref,\n+    {\n+        self.as_ref().map(|t| t.deref())\n+    }\n+\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n+    ///\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut s = \"HELLO\".to_string();\n+    /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&mut str, &mut u32> = Ok(&mut s);\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    ///\n+    /// let mut i = 42;\n+    /// let mut x: Result<String, u32> = Err(42);\n+    /// let y: Result<&mut str, &mut u32> = Err(&mut i);\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    /// ```\n+    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n+    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E>\n+    where\n+        T: DerefMut,\n+    {\n+        self.as_mut().map(|t| t.deref_mut())\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -951,608 +1001,583 @@ impl<T, E> Result<T, E> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n \n-    ////////////////////////////////////////////////////////////////////////\n-    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+    // Extract a value\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n-    ///\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n     ///\n-    /// # Examples\n+    /// # Panics\n     ///\n-    /// Basic usage:\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n     ///\n-    /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<&str, &str> = Err(\"late error\");\n-    /// assert_eq!(x.and(y), Err(\"late error\"));\n     ///\n-    /// let x: Result<u32, &str> = Err(\"early error\");\n-    /// let y: Result<&str, &str> = Ok(\"foo\");\n-    /// assert_eq!(x.and(y), Err(\"early error\"));\n+    /// # Examples\n     ///\n-    /// let x: Result<u32, &str> = Err(\"not a 2\");\n-    /// let y: Result<&str, &str> = Err(\"late error\");\n-    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n+    /// Basic usage:\n     ///\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<&str, &str> = Ok(\"different result type\");\n-    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n     /// ```\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n+    #[track_caller]\n+    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n+    pub fn expect(self, msg: &str) -> T\n+    where\n+        E: fmt::Debug,\n+    {\n         match self {\n-            Ok(_) => res,\n-            Err(e) => Err(e),\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(msg, &e),\n         }\n     }\n \n-    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// Because this function may panic, its use is generally discouraged.\n+    /// Instead, prefer to use pattern matching and handle the [`Err`]\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n     ///\n+    /// [`unwrap_or`]: Result::unwrap_or\n+    /// [`unwrap_or_else`]: Result::unwrap_or_else\n+    /// [`unwrap_or_default`]: Result::unwrap_or_default\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Err`], with a panic message provided by the\n+    /// [`Err`]'s value.\n     ///\n-    /// This function can be used for control flow based on `Result` values.\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n-    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.unwrap(), 2);\n+    /// ```\n     ///\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n-    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n-    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n+    pub fn unwrap(self) -> T\n+    where\n+        E: fmt::Debug,\n+    {\n         match self {\n-            Ok(t) => op(t),\n-            Err(e) => Err(e),\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n         }\n     }\n \n-    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n-    ///\n-    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n-    /// result of a function call, it is recommended to use [`or_else`], which is\n-    /// lazily evaluated.\n+    /// Returns the contained [`Ok`] value or a default\n     ///\n-    /// [`or_else`]: Result::or_else\n+    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n+    /// value, otherwise if [`Err`], returns the default value for that\n+    /// type.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// Converts a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). [`parse`] converts\n+    /// a string to any other type that implements [`FromStr`], returning an\n+    /// [`Err`] on error.\n     ///\n     /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<u32, &str> = Err(\"late error\");\n-    /// assert_eq!(x.or(y), Ok(2));\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"early error\");\n-    /// let y: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(x.or(y), Ok(2));\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"not a 2\");\n-    /// let y: Result<u32, &str> = Err(\"late error\");\n-    /// assert_eq!(x.or(y), Err(\"late error\"));\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n     ///\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<u32, &str> = Ok(100);\n-    /// assert_eq!(x.or(y), Ok(2));\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n     /// ```\n+    ///\n+    /// [`parse`]: str::parse\n+    /// [`FromStr`]: crate::str::FromStr\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n+    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n+    pub fn unwrap_or_default(self) -> T\n+    where\n+        T: Default,\n+    {\n         match self {\n-            Ok(v) => Ok(v),\n-            Err(_) => res,\n+            Ok(x) => x,\n+            Err(_) => Default::default(),\n         }\n     }\n \n-    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n-    /// This function can be used for control flow based on result values.\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n     ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n-    /// ```\n-    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n-    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n-    ///\n-    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n-    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n-    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n-    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n     /// ```\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n+    #[track_caller]\n+    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n+    pub fn expect_err(self, msg: &str) -> E\n+    where\n+        T: fmt::Debug,\n+    {\n         match self {\n-            Ok(t) => Ok(t),\n-            Err(e) => op(e),\n+            Ok(t) => unwrap_failed(msg, &t),\n+            Err(e) => e,\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value or a provided default.\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n-    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n-    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n-    /// which is lazily evaluated.\n+    /// # Panics\n     ///\n-    /// [`unwrap_or_else`]: Result::unwrap_or_else\n+    /// Panics if the value is an [`Ok`], with a custom panic message provided\n+    /// by the [`Ok`]'s value.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// x.unwrap_err(); // panics with `2`\n     /// ```\n-    /// let default = 2;\n-    /// let x: Result<u32, &str> = Ok(9);\n-    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n-    /// let x: Result<u32, &str> = Err(\"error\");\n-    /// assert_eq!(x.unwrap_or(default), default);\n+    /// ```\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, default: T) -> T {\n+    pub fn unwrap_err(self) -> E\n+    where\n+        T: fmt::Debug,\n+    {\n         match self {\n-            Ok(t) => t,\n-            Err(_) => default,\n+            Ok(t) => unwrap_failed(\"called `Result::unwrap_err()` on an `Ok` value\", &t),\n+            Err(e) => e,\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value or computes it from a closure.\n+    /// Returns the contained [`Ok`] value, but never panics.\n+    ///\n+    /// Unlike [`unwrap`], this method is known to never panic on the\n+    /// result types it is implemented for. Therefore, it can be used\n+    /// instead of `unwrap` as a maintainability safeguard that will fail\n+    /// to compile if the error type of the `Result` is later changed\n+    /// to an error that can actually occur.\n     ///\n+    /// [`unwrap`]: Result::unwrap\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// fn count(x: &str) -> usize { x.len() }\n+    /// # #![feature(never_type)]\n+    /// # #![feature(unwrap_infallible)]\n     ///\n-    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n-    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n+    /// fn only_good_news() -> Result<String, !> {\n+    ///     Ok(\"this is fine\".into())\n+    /// }\n+    ///\n+    /// let s: String = only_good_news().into_ok();\n+    /// println!(\"{}\", s);\n     /// ```\n+    #[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n+    pub fn into_ok(self) -> T\n+    where\n+        E: Into<!>,\n+    {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => op(e),\n+            Ok(x) => x,\n+            Err(e) => e.into(),\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value, consuming the `self` value,\n-    /// without checking that the value is not an [`Err`].\n-    ///\n-    /// # Safety\n+    /// Returns the contained [`Err`] value, but never panics.\n     ///\n-    /// Calling this method on an [`Err`] is *[undefined behavior]*.\n+    /// Unlike [`unwrap_err`], this method is known to never panic on the\n+    /// result types it is implemented for. Therefore, it can be used\n+    /// instead of `unwrap_err` as a maintainability safeguard that will fail\n+    /// to compile if the ok type of the `Result` is later changed\n+    /// to a type that can actually occur.\n     ///\n-    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    /// [`unwrap_err`]: Result::unwrap_err\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(unsafe { x.unwrap_unchecked() }, 2);\n-    /// ```\n+    /// # #![feature(never_type)]\n+    /// # #![feature(unwrap_infallible)]\n     ///\n-    /// ```no_run\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// unsafe { x.unwrap_unchecked(); } // Undefined behavior!\n+    /// fn only_bad_news() -> Result<!, String> {\n+    ///     Err(\"Oops, it failed\".into())\n+    /// }\n+    ///\n+    /// let error: String = only_bad_news().into_err();\n+    /// println!(\"{}\", error);\n     /// ```\n+    #[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n-    pub unsafe fn unwrap_unchecked(self) -> T {\n-        debug_assert!(self.is_ok());\n+    pub fn into_err(self) -> E\n+    where\n+        T: Into<!>,\n+    {\n         match self {\n-            Ok(t) => t,\n-            // SAFETY: the safety contract must be upheld by the caller.\n-            Err(_) => unsafe { hint::unreachable_unchecked() },\n+            Ok(x) => x.into(),\n+            Err(e) => e,\n         }\n     }\n \n-    /// Returns the contained [`Err`] value, consuming the `self` value,\n-    /// without checking that the value is not an [`Ok`].\n-    ///\n-    /// # Safety\n-    ///\n-    /// Calling this method on an [`Ok`] is *[undefined behavior]*.\n+    ////////////////////////////////////////////////////////////////////////\n+    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n     ///\n-    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///\n-    /// ```no_run\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// unsafe { x.unwrap_err_unchecked() }; // Undefined behavior!\n-    /// ```\n+    /// Basic usage:\n     ///\n     /// ```\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// assert_eq!(unsafe { x.unwrap_err_unchecked() }, \"emergency failure\");\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n+    /// let y: Result<&str, &str> = Ok(\"foo\");\n+    /// assert_eq!(x.and(y), Err(\"early error\"));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Ok(\"different result type\");\n+    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n-    pub unsafe fn unwrap_err_unchecked(self) -> E {\n-        debug_assert!(self.is_err());\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n-            // SAFETY: the safety contract must be upheld by the caller.\n-            Ok(_) => unsafe { hint::unreachable_unchecked() },\n-            Err(e) => e,\n+            Ok(_) => res,\n+            Err(e) => Err(e),\n         }\n     }\n-}\n \n-impl<T: Copy, E> Result<&T, E> {\n-    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n-    /// `Ok` part.\n+    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n     ///\n-    /// # Examples\n     ///\n-    /// ```\n-    /// #![feature(result_copied)]\n-    /// let val = 12;\n-    /// let x: Result<&i32, i32> = Ok(&val);\n-    /// assert_eq!(x, Ok(&12));\n-    /// let copied = x.copied();\n-    /// assert_eq!(copied, Ok(12));\n-    /// ```\n-    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn copied(self) -> Result<T, E> {\n-        self.map(|&t| t)\n-    }\n-}\n-\n-impl<T: Copy, E> Result<&mut T, E> {\n-    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n-    /// `Ok` part.\n+    /// This function can be used for control flow based on `Result` values.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// #![feature(result_copied)]\n-    /// let mut val = 12;\n-    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n-    /// assert_eq!(x, Ok(&mut 12));\n-    /// let copied = x.copied();\n-    /// assert_eq!(copied, Ok(12));\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n+    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n+    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n-    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn copied(self) -> Result<T, E> {\n-        self.map(|&mut t| t)\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n+        match self {\n+            Ok(t) => op(t),\n+            Err(e) => Err(e),\n+        }\n     }\n-}\n \n-impl<T: Clone, E> Result<&T, E> {\n-    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n-    /// `Ok` part.\n+    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n-    /// # Examples\n+    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`or_else`], which is\n+    /// lazily evaluated.\n     ///\n-    /// ```\n-    /// #![feature(result_cloned)]\n-    /// let val = 12;\n-    /// let x: Result<&i32, i32> = Ok(&val);\n-    /// assert_eq!(x, Ok(&12));\n-    /// let cloned = x.cloned();\n-    /// assert_eq!(cloned, Ok(12));\n-    /// ```\n-    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn cloned(self) -> Result<T, E> {\n-        self.map(|t| t.clone())\n-    }\n-}\n-\n-impl<T: Clone, E> Result<&mut T, E> {\n-    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n-    /// `Ok` part.\n+    /// [`or_else`]: Result::or_else\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// #![feature(result_cloned)]\n-    /// let mut val = 12;\n-    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n-    /// assert_eq!(x, Ok(&mut 12));\n-    /// let cloned = x.cloned();\n-    /// assert_eq!(cloned, Ok(12));\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n+    /// let y: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Ok(100);\n+    /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n-    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn cloned(self) -> Result<T, E> {\n-        self.map(|t| t.clone())\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n+        match self {\n+            Ok(v) => Ok(v),\n+            Err(_) => res,\n+        }\n     }\n-}\n \n-impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Returns the contained [`Ok`] value, consuming the `self` value.\n-    ///\n-    /// # Panics\n+    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n-    /// Panics if the value is an [`Err`], with a panic message including the\n-    /// passed message, and the content of the [`Err`].\n+    /// This function can be used for control flow based on result values.\n     ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n-    /// ```should_panic\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// ```\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n+    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n+    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n+    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n-    pub fn expect(self, msg: &str) -> T {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => unwrap_failed(msg, &e),\n+            Ok(t) => Ok(t),\n+            Err(e) => op(e),\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    /// Returns the contained [`Ok`] value or a provided default.\n     ///\n-    /// Because this function may panic, its use is generally discouraged.\n-    /// Instead, prefer to use pattern matching and handle the [`Err`]\n-    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n-    /// [`unwrap_or_default`].\n+    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n+    /// which is lazily evaluated.\n     ///\n-    /// [`unwrap_or`]: Result::unwrap_or\n     /// [`unwrap_or_else`]: Result::unwrap_or_else\n-    /// [`unwrap_or_default`]: Result::unwrap_or_default\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Err`], with a panic message provided by the\n-    /// [`Err`]'s value.\n-    ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(x.unwrap(), 2);\n-    /// ```\n+    /// let default = 2;\n+    /// let x: Result<u32, &str> = Ok(9);\n+    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n-    /// ```should_panic\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.unwrap(); // panics with `emergency failure`\n+    /// let x: Result<u32, &str> = Err(\"error\");\n+    /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n-    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap(self) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n+            Err(_) => default,\n         }\n     }\n-}\n \n-impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Returns the contained [`Err`] value, consuming the `self` value.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Ok`], with a panic message including the\n-    /// passed message, and the content of the [`Ok`].\n+    /// Returns the contained [`Ok`] value or computes it from a closure.\n     ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n-    /// ```should_panic\n-    /// let x: Result<u32, &str> = Ok(10);\n-    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n+    /// ```\n+    /// fn count(x: &str) -> usize { x.len() }\n+    ///\n+    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n+    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n     /// ```\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n-    pub fn expect_err(self, msg: &str) -> E {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n-            Ok(t) => unwrap_failed(msg, &t),\n-            Err(e) => e,\n+            Ok(t) => t,\n+            Err(e) => op(e),\n         }\n     }\n \n-    /// Returns the contained [`Err`] value, consuming the `self` value.\n+    /// Returns the contained [`Ok`] value, consuming the `self` value,\n+    /// without checking that the value is not an [`Err`].\n     ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the value is an [`Ok`], with a custom panic message provided\n-    /// by the [`Ok`]'s value.\n+    /// Calling this method on an [`Err`] is *[undefined behavior]*.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///\n-    /// ```should_panic\n+    /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n-    /// x.unwrap_err(); // panics with `2`\n+    /// assert_eq!(unsafe { x.unwrap_unchecked() }, 2);\n     /// ```\n     ///\n-    /// ```\n+    /// ```no_run\n     /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n+    /// unsafe { x.unwrap_unchecked(); } // Undefined behavior!\n     /// ```\n     #[inline]\n     #[track_caller]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_err(self) -> E {\n+    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n+    pub unsafe fn unwrap_unchecked(self) -> T {\n+        debug_assert!(self.is_ok());\n         match self {\n-            Ok(t) => unwrap_failed(\"called `Result::unwrap_err()` on an `Ok` value\", &t),\n-            Err(e) => e,\n+            Ok(t) => t,\n+            // SAFETY: the safety contract must be upheld by the caller.\n+            Err(_) => unsafe { hint::unreachable_unchecked() },\n         }\n     }\n-}\n \n-impl<T: Default, E> Result<T, E> {\n-    /// Returns the contained [`Ok`] value or a default\n+    /// Returns the contained [`Err`] value, consuming the `self` value,\n+    /// without checking that the value is not an [`Ok`].\n     ///\n-    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n-    /// value, otherwise if [`Err`], returns the default value for that\n-    /// type.\n+    /// # Safety\n     ///\n-    /// # Examples\n+    /// Calling this method on an [`Ok`] is *[undefined behavior]*.\n     ///\n-    /// Converts a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). [`parse`] converts\n-    /// a string to any other type that implements [`FromStr`], returning an\n-    /// [`Err`] on error.\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n-    /// ```\n-    /// let good_year_from_input = \"1909\";\n-    /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n-    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n+    /// # Examples\n     ///\n-    /// assert_eq!(1909, good_year);\n-    /// assert_eq!(0, bad_year);\n+    /// ```no_run\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// unsafe { x.unwrap_err_unchecked() }; // Undefined behavior!\n     /// ```\n     ///\n-    /// [`parse`]: str::parse\n-    /// [`FromStr`]: crate::str::FromStr\n+    /// ```\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// assert_eq!(unsafe { x.unwrap_err_unchecked() }, \"emergency failure\");\n+    /// ```\n     #[inline]\n-    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n-    pub fn unwrap_or_default(self) -> T {\n+    #[track_caller]\n+    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n+    pub unsafe fn unwrap_err_unchecked(self) -> E {\n+        debug_assert!(self.is_err());\n         match self {\n-            Ok(x) => x,\n-            Err(_) => Default::default(),\n+            // SAFETY: the safety contract must be upheld by the caller.\n+            Ok(_) => unsafe { hint::unreachable_unchecked() },\n+            Err(e) => e,\n         }\n     }\n }\n \n-#[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n-impl<T, E: Into<!>> Result<T, E> {\n-    /// Returns the contained [`Ok`] value, but never panics.\n-    ///\n-    /// Unlike [`unwrap`], this method is known to never panic on the\n-    /// result types it is implemented for. Therefore, it can be used\n-    /// instead of `unwrap` as a maintainability safeguard that will fail\n-    /// to compile if the error type of the `Result` is later changed\n-    /// to an error that can actually occur.\n-    ///\n-    /// [`unwrap`]: Result::unwrap\n+impl<T, E> Result<&T, E> {\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n-    /// # #![feature(never_type)]\n-    /// # #![feature(unwrap_infallible)]\n-    ///\n-    /// fn only_good_news() -> Result<String, !> {\n-    ///     Ok(\"this is fine\".into())\n-    /// }\n-    ///\n-    /// let s: String = only_good_news().into_ok();\n-    /// println!(\"{}\", s);\n+    /// #![feature(result_copied)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n     /// ```\n-    #[inline]\n-    pub fn into_ok(self) -> T {\n-        match self {\n-            Ok(x) => x,\n-            Err(e) => e.into(),\n-        }\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E>\n+    where\n+        T: Copy,\n+    {\n+        self.map(|&t| t)\n     }\n-}\n \n-#[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n-impl<T: Into<!>, E> Result<T, E> {\n-    /// Returns the contained [`Err`] value, but never panics.\n-    ///\n-    /// Unlike [`unwrap_err`], this method is known to never panic on the\n-    /// result types it is implemented for. Therefore, it can be used\n-    /// instead of `unwrap_err` as a maintainability safeguard that will fail\n-    /// to compile if the ok type of the `Result` is later changed\n-    /// to a type that can actually occur.\n-    ///\n-    /// [`unwrap_err`]: Result::unwrap_err\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n-    /// # #![feature(never_type)]\n-    /// # #![feature(unwrap_infallible)]\n-    ///\n-    /// fn only_bad_news() -> Result<!, String> {\n-    ///     Err(\"Oops, it failed\".into())\n-    /// }\n-    ///\n-    /// let error: String = only_bad_news().into_err();\n-    /// println!(\"{}\", error);\n+    /// #![feature(result_cloned)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n     /// ```\n-    #[inline]\n-    pub fn into_err(self) -> E {\n-        match self {\n-            Ok(x) => x.into(),\n-            Err(e) => e,\n-        }\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E>\n+    where\n+        T: Clone,\n+    {\n+        self.map(|t| t.clone())\n     }\n }\n \n-impl<T: Deref, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n-    ///\n-    /// Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n-    /// and returns the new [`Result`].\n+impl<T, E> Result<&mut T, E> {\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n-    /// let y: Result<&str, &u32> = Ok(\"hello\");\n-    /// assert_eq!(x.as_deref(), y);\n-    ///\n-    /// let x: Result<String, u32> = Err(42);\n-    /// let y: Result<&str, &u32> = Err(&42);\n-    /// assert_eq!(x.as_deref(), y);\n+    /// #![feature(result_copied)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n     /// ```\n-    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n-    pub fn as_deref(&self) -> Result<&T::Target, &E> {\n-        self.as_ref().map(|t| t.deref())\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E>\n+    where\n+        T: Copy,\n+    {\n+        self.map(|&mut t| t)\n     }\n-}\n \n-impl<T: DerefMut, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n-    ///\n-    /// Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n-    /// and returns the new [`Result`].\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut s = \"HELLO\".to_string();\n-    /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n-    /// let y: Result<&mut str, &mut u32> = Ok(&mut s);\n-    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n-    ///\n-    /// let mut i = 42;\n-    /// let mut x: Result<String, u32> = Err(42);\n-    /// let y: Result<&mut str, &mut u32> = Err(&mut i);\n-    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    /// #![feature(result_cloned)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n     /// ```\n-    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n-    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n-        self.as_mut().map(|t| t.deref_mut())\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E>\n+    where\n+        T: Clone,\n+    {\n+        self.map(|t| t.clone())\n     }\n }\n "}, {"sha": "608e587cf34f3351a9befa9ab8a74d64b2c54d3c", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -13,20 +13,12 @@\n // running tests while providing a base that other test frameworks may\n // build off of.\n \n-// N.B., this is also specified in this crate's Cargo.toml, but librustc_ast contains logic specific to\n-// this crate, which relies on this attribute (rather than the value of `--crate-name` passed by\n-// cargo) to detect this crate.\n-\n-#![crate_name = \"test\"]\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(test(attr(deny(warnings))))]\n-#![feature(libc)]\n-#![feature(rustc_private)]\n #![feature(nll)]\n #![feature(available_parallelism)]\n #![feature(bench_black_box)]\n #![feature(internal_output_capture)]\n-#![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n #![feature(test)]\n@@ -444,8 +436,8 @@ pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAnd\n         .into_iter()\n         .map(|x| {\n             let testfn = match x.testfn {\n-                DynBenchFn(bench) => DynTestFn(Box::new(move || {\n-                    bench::run_once(|b| __rust_begin_short_backtrace(|| bench.run(b)))\n+                DynBenchFn(benchfn) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n                 })),\n                 StaticBenchFn(benchfn) => DynTestFn(Box::new(move || {\n                     bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n@@ -544,11 +536,9 @@ pub fn run_test(\n         TestRunOpts { strategy, nocapture: opts.nocapture, concurrency, time: opts.time_options };\n \n     match testfn {\n-        DynBenchFn(bencher) => {\n+        DynBenchFn(benchfn) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n-            crate::bench::benchmark(id, desc, monitor_ch, opts.nocapture, |harness| {\n-                bencher.run(harness)\n-            });\n+            crate::bench::benchmark(id, desc, monitor_ch, opts.nocapture, benchfn);\n             None\n         }\n         StaticBenchFn(benchfn) => {"}, {"sha": "40b05704b40cb830e79f6b2174c60ead573ac644", "filename": "library/test/src/stats.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Ftest%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Ftest%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fstats.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -1,5 +1,4 @@\n #![allow(missing_docs)]\n-#![allow(deprecated)] // Float\n \n use std::mem;\n "}, {"sha": "37bb38fb0df4efb64d557d31d515e83cd2a7183d", "filename": "library/test/src/types.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Ftest%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/library%2Ftest%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftypes.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -74,11 +74,6 @@ impl fmt::Display for TestName {\n     }\n }\n \n-/// Represents a benchmark function.\n-pub trait TDynBenchFn: Send {\n-    fn run(&self, harness: &mut Bencher);\n-}\n-\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function panics then the test fails. We\n // may need to come up with a more clever definition of test in order\n@@ -87,7 +82,7 @@ pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n     DynTestFn(Box<dyn FnOnce() + Send>),\n-    DynBenchFn(Box<dyn TDynBenchFn + 'static>),\n+    DynBenchFn(Box<dyn Fn(&mut Bencher) + Send>),\n }\n \n impl TestFn {"}, {"sha": "52ee1db5b157113d3a3a1ea2c83582d3ad80b3e8", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref_mut.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -5,7 +5,6 @@ LL |     let _result = &mut Some(42).as_deref_mut();\n    |                                 ^^^^^^^^^^^^ method cannot be called on `Option<{integer}>` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n-           `{integer}: DerefMut`\n            `{integer}: Deref`\n \n error: aborting due to previous error"}, {"sha": "018557881ef77edb45ee41dce7eba85273a2c6aa", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -5,7 +5,6 @@ LL |     let _result = &mut Ok(42).as_deref_mut();\n    |                               ^^^^^^^^^^^^ method cannot be called on `Result<{integer}, _>` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n-           `{integer}: DerefMut`\n            `{integer}: Deref`\n \n error: aborting due to previous error"}, {"sha": "90983f35a5ebf0595e17a0f51e8e42d7718beb88", "filename": "src/test/ui/macros/stringify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -661,9 +661,9 @@ fn test_pat() {\n     assert_eq!(stringify_pat!(ref mut _x @ _), \"ref mut _x @ _\");\n \n     // PatKind::Struct\n-    assert_eq!(stringify_pat!(Struct {}), \"Struct {  }\"); // FIXME\n-    assert_eq!(stringify_pat!(Struct::<u8> {}), \"Struct::<u8> {  }\");\n-    assert_eq!(stringify_pat!(Struct::<'static> {}), \"Struct::<'static> {  }\");\n+    assert_eq!(stringify_pat!(Struct {}), \"Struct {}\");\n+    assert_eq!(stringify_pat!(Struct::<u8> {}), \"Struct::<u8> {}\");\n+    assert_eq!(stringify_pat!(Struct::<'static> {}), \"Struct::<'static> {}\");\n     assert_eq!(stringify_pat!(Struct { x }), \"Struct { x }\");\n     assert_eq!(stringify_pat!(Struct { x: _x }), \"Struct { x: _x }\");\n     assert_eq!(stringify_pat!(Struct { .. }), \"Struct { .. }\");\n@@ -672,7 +672,7 @@ fn test_pat() {\n     #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n     assert_eq!(\n         stringify_pat!(<Struct as Trait>::Type {}),\n-        \"<Struct as Trait>::Type {  }\",\n+        \"<Struct as Trait>::Type {}\",\n     );\n \n     // PatKind::TupleStruct"}, {"sha": "6303c6e6a5db11404e1850fbf09dc214c61cfcc4", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -3,5 +3,5 @@ struct Foo;\n fn main() {\n     let a: Result<(), Foo> = Ok(());\n     a.unwrap();\n-    //~^ ERROR the method\n+    //~^ ERROR `Foo` doesn't implement `Debug`\n }"}, {"sha": "dc73bcd6e4d050aa27835b524445d3bdbd85e3dd", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -1,19 +1,17 @@\n-error[E0599]: the method `unwrap` exists for enum `Result<(), Foo>`, but its trait bounds were not satisfied\n+error[E0277]: `Foo` doesn't implement `Debug`\n   --> $DIR/method-help-unsatisfied-bound.rs:5:7\n    |\n-LL | struct Foo;\n-   | ----------- doesn't satisfy `Foo: Debug`\n-...\n LL |     a.unwrap();\n-   |       ^^^^^^ method cannot be called on `Result<(), Foo>` due to unsatisfied trait bounds\n+   |       ^^^^^^ `Foo` cannot be formatted using `{:?}`\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `Foo: Debug`\n-help: consider annotating `Foo` with `#[derive(Debug)]`\n-   |\n-LL | #[derive(Debug)]\n+   = help: the trait `Debug` is not implemented for `Foo`\n+   = note: add `#[derive(Debug)]` to `Foo` or manually `impl Debug for Foo`\n+note: required by a bound in `Result::<T, E>::unwrap`\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n+LL |         E: fmt::Debug,\n+   |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0599`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "dbbcdee3c19f67ca6f6881909fcfde7fc84ac524", "filename": "src/test/ui/suggestions/while-let-typo.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fsuggestions%2Fwhile-let-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fsuggestions%2Fwhile-let-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fwhile-let-typo.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let foo = Some(0);\n+    let bar = None;\n+    while Some(x) = foo {} //~ ERROR cannot find value `x` in this scope\n+    while Some(foo) = bar {}\n+    while 3 = foo {} //~ ERROR mismatched types\n+    while Some(3) = foo {} //~ ERROR invalid left-hand side of assignment\n+    while x = 5 {} //~ ERROR cannot find value `x` in this scope\n+}"}, {"sha": "7cc2ed3149b14602973497887c294cce688bf8e2", "filename": "src/test/ui/suggestions/while-let-typo.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fsuggestions%2Fwhile-let-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftest%2Fui%2Fsuggestions%2Fwhile-let-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fwhile-let-typo.stderr?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -0,0 +1,45 @@\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/while-let-typo.rs:4:16\n+   |\n+LL |     while Some(x) = foo {}\n+   |                ^ not found in this scope\n+   |\n+help: you might have meant to use pattern matching\n+   |\n+LL |     while let Some(x) = foo {}\n+   |           +++\n+\n+error[E0425]: cannot find value `x` in this scope\n+  --> $DIR/while-let-typo.rs:8:11\n+   |\n+LL |     while x = 5 {}\n+   |           ^ not found in this scope\n+   |\n+help: you might have meant to use pattern matching\n+   |\n+LL |     while let x = 5 {}\n+   |           +++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/while-let-typo.rs:6:11\n+   |\n+LL |     while 3 = foo {}\n+   |           ^^^^^^^ expected `bool`, found `()`\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/while-let-typo.rs:7:19\n+   |\n+LL |     while Some(3) = foo {}\n+   |                -  ^\n+   |                |\n+   |                cannot assign to this expression\n+   |\n+help: you might have meant to use pattern destructuring\n+   |\n+LL |     while let Some(3) = foo {}\n+   |           +++\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308, E0425.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "836558b07cb02b110bd500d980b43b98dc57fa4c", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=ddabe0775c5f5b551d5eb54e3c4366fb8bec0c92", "patch": "@@ -193,7 +193,6 @@ fn check_rvalue(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, rvalue: &Rv\n             }\n         },\n         Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) | Rvalue::ShallowInitBox(_, _) => Ok(()),\n-        Rvalue::NullaryOp(NullOp::Box, _) => Err((span, \"heap allocations are not allowed in const fn\".into())),\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {"}]}