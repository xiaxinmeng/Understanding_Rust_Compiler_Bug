{"sha": "6947948b4df98b82a9e8f6847db442921edfc37b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NDc5NDhiNGRmOThiODJhOWU4ZjY4NDdkYjQ0MjkyMWVkZmMzN2I=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-26T19:23:41Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-30T09:40:16Z"}, "message": "Move FufillmentContext into InferContext", "tree": {"sha": "cd062f87d59e6b098820b9a1f8390d7c9e5fafe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd062f87d59e6b098820b9a1f8390d7c9e5fafe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6947948b4df98b82a9e8f6847db442921edfc37b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6947948b4df98b82a9e8f6847db442921edfc37b", "html_url": "https://github.com/rust-lang/rust/commit/6947948b4df98b82a9e8f6847db442921edfc37b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6947948b4df98b82a9e8f6847db442921edfc37b/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6596d0052e79e6393bbee3538bb122930d89887", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6596d0052e79e6393bbee3538bb122930d89887", "html_url": "https://github.com/rust-lang/rust/commit/e6596d0052e79e6393bbee3538bb122930d89887"}], "stats": {"total": 77, "additions": 48, "deletions": 29}, "files": [{"sha": "4617d3860a3a6b0cfd5853aeba230bc99496f3bf", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -87,6 +87,8 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n \n     pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n \n+    pub fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+\n     // This is a temporary field used for toggling on normalization in the inference context,\n     // as we move towards the approach described here:\n     // https://internals.rust-lang.org/t/flattening-the-contexts-for-fun-and-profit/2293\n@@ -327,9 +329,16 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n     }\n }\n \n+/// errors_will_be_reported is required to proxy to the fulfillment context\n+/// FIXME -- a better option would be to hold back on modifying\n+/// the global cache until we know that all dependent obligations\n+/// are also satisfied. In that case, we could actually remove\n+/// this boolean flag, and we'd also avoid the problem of squelching\n+/// duplicate errors that occur across fns.\n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n                                 tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n+                                errors_will_be_reported: bool)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n@@ -339,6 +348,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(errors_will_be_reported)),\n         normalize: false,\n         err_count_on_creation: tcx.sess.err_count()\n     }\n@@ -1009,6 +1019,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         raw_ty.adjust(self.tcx,\n                       expr.span,\n                       expr.id,\n+                      raw_ty,\n                       adjustment,\n                       |method_call| self.tables\n                                         .borrow()"}, {"sha": "c5afb7dd3db25f9612a340dc321a9e82d6dbf32c", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -397,7 +397,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env), false);\n     let predicates = match fully_normalize(&infcx, &infcx.parameter_environment, cause,\n                                            &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,"}, {"sha": "32a1f74063bba285a45895e98bebbd3fb0f8915b", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -957,7 +957,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            trait_ref, trait_ref.def_id());\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n@@ -1019,7 +1019,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let mut fulfill_cx = traits::FulfillmentContext::new(false);"}, {"sha": "6ad164719cf6ff4900a135e57fe351e8459cb2e9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -324,7 +324,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n     // NOTE: @jroesch\n     // Here is of an example where we do not use a param_env but use a typer instead.\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();"}, {"sha": "6d1e9dfacf2816e55e6035e818bb03a8e58acfc8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -125,7 +125,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n     expected_vid: ty::TyVid)\n     -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n {\n-    let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n+    let fulfillment_cx = fcx.inh.infcx.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n     let expected_sig ="}, {"sha": "6375926298f3c53a47a4dfd86baab215bb9f5caa", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -43,7 +43,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -419,7 +419,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "7d911cf8b03bc3c4d217d5254e1a58e6761ae3fd", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -93,7 +93,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                          ty: named_type } =\n         tcx.lookup_item_type(self_type_did);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n \n     infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) ="}, {"sha": "76286cfe9ba04a50bfa291504aa3f947a9ac7dc1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -159,7 +159,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n \n     // Tracks trait obligations incurred during this function body.\n-    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+    // fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n \n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n@@ -295,11 +295,11 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n+            // I'm probably screwed here ... more boolean prop ... \n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), false),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n             fn_sig_map: RefCell::new(NodeMap()),\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(true)),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         -> T\n         where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n-        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+        let mut fulfillment_cx = self.infcx.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n                                              typer,\n                                              &mut *fulfillment_cx, span,\n@@ -1389,7 +1389,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let cause = traits::ObligationCause::new(span,\n                                                  self.body_id,\n                                                  traits::ObligationCauseCode::MiscObligation);\n-        self.inh.fulfillment_cx\n+        self.inh\n+            .infcx\n+            .fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n                                        self.infcx(),\n@@ -1513,7 +1515,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: traits::ObligationCause<'tcx>)\n     {\n-        self.inh.fulfillment_cx.borrow_mut()\n+        self.inh.infcx.fulfillment_cx.borrow_mut()\n             .register_builtin_bound(self.infcx(), ty, builtin_bound, cause);\n     }\n \n@@ -1522,7 +1524,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         debug!(\"register_predicate({:?})\",\n                obligation);\n-        self.inh.fulfillment_cx\n+        self.inh.infcx.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self.infcx(), obligation);\n     }\n@@ -1558,6 +1560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let raw_ty = self.infcx().shallow_resolve(raw_ty);\n         let resolve_ty = |ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n         raw_ty.adjust(self.tcx(), expr.span, expr.id, adjustment, |method_call| {\n+                                                   .method_map\n             self.inh.tables.borrow().method_map.get(&method_call)\n                                         .map(|method| resolve_ty(method.ty))\n         })\n@@ -1648,7 +1651,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       region: ty::Region,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n-        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        let mut fulfillment_cx = self.inh.infcx.fulfillment_cx.borrow_mut();\n         fulfillment_cx.register_region_obligation(ty, region, cause);\n     }\n \n@@ -1747,7 +1750,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n \n         self.select_all_obligations_and_apply_defaults();\n-        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        let mut fulfillment_cx = self.inh.infcx.fulfillment_cx.borrow_mut();\n         match fulfillment_cx.select_all_or_error(self.infcx(), self.infcx()) {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n@@ -1757,7 +1760,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Select as many obligations as we can at present.\n     fn select_obligations_where_possible(&self) {\n         match\n-            self.inh.fulfillment_cx\n+            self.inh.infcx.fulfillment_cx\n             .borrow_mut()\n             .select_where_possible(self.infcx(), self.infcx())\n         {\n@@ -1772,7 +1775,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// work.\n     fn select_new_obligations(&self) {\n         match\n-            self.inh.fulfillment_cx\n+            self.inh.infcx.fulfillment_cx\n             .borrow_mut()\n             .select_new_obligations(self.infcx(), self.infcx())\n         {"}, {"sha": "661e1856ce8cd9deebaef4c90df5e79d824f14d0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -318,9 +318,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting.\n         let region_obligations =\n-            self.fcx.inh.fulfillment_cx.borrow()\n-                                       .region_obligations(node_id)\n-                                       .to_vec();\n+            self.fcx\n+                .inh\n+                .infcx\n+                .fulfillment_cx\n+                .borrow()\n+                .region_obligations(node_id)\n+                .to_vec();\n \n         for r_o in &region_obligations {\n             debug!(\"visit_region_obligations: r_o={:?}\",\n@@ -332,7 +336,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n-                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n+                   self.fcx.inh.infcx.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed"}, {"sha": "23336c4399566c309a3c7c5b58dfe5c9d01ccc0b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), true);\n \n             let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -632,7 +632,8 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None),\n+        // XXXJAREDXXX: not sure if the bool is right here?\n+        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None, false),\n         inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n     unsafety::check(crate_context.tcx);"}, {"sha": "42c6bcbfbb999018705730889e4231c4bd908717", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n             }"}, {"sha": "c45fbb70002d1e78f02f24d169bed5da48d3e9cd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -2211,7 +2211,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                base_type,\n                base_type_free);\n \n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n         drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,"}, {"sha": "8c3ef4ae631c3ebb53551daa963915f246b0ed3e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6947948b4df98b82a9e8f6847db442921edfc37b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6947948b4df98b82a9e8f6847db442921edfc37b", "patch": "@@ -188,7 +188,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n             infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}