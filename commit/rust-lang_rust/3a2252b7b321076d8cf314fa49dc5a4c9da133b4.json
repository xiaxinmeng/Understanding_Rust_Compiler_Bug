{"sha": "3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "node_id": "C_kwDOAAsO6NoAKDNhMjI1MmI3YjMyMTA3NmQ4Y2YzMTRmYTQ5ZGM1YTRjOWRhMTMzYjQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-02T01:34:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-27T12:51:28Z"}, "message": "adjust for earlier init checking in the core engine", "tree": {"sha": "45a914e8c991b55c81223c9d9bed9ecf8888de09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45a914e8c991b55c81223c9d9bed9ecf8888de09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "html_url": "https://github.com/rust-lang/rust/commit/3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "101c4f2e38e88a181f7847c536c077272f993268", "url": "https://api.github.com/repos/rust-lang/rust/commits/101c4f2e38e88a181f7847c536c077272f993268", "html_url": "https://github.com/rust-lang/rust/commit/101c4f2e38e88a181f7847c536c077272f993268"}], "stats": {"total": 363, "additions": 163, "deletions": 200}, "files": [{"sha": "223fad40362a4ac4954d6b1e48db7ed9da888f02", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -447,7 +447,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n         atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.read_scalar_atomic(&value_place, atomic)\n@@ -458,7 +458,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &mut self,\n         op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n-        value: impl Into<ScalarMaybeUninit<Provenance>>,\n+        value: impl Into<Scalar<Provenance>>,\n         layout: TyAndLayout<'tcx>,\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n@@ -472,7 +472,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n         this.atomic_access_check(place)?;\n         // This will read from the last store in the modification order of this location. In case\n@@ -490,7 +490,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Perform an atomic write operation at the memory location.\n     fn write_scalar_atomic(\n         &mut self,\n-        val: ScalarMaybeUninit<Provenance>,\n+        val: Scalar<Provenance>,\n         dest: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n@@ -531,10 +531,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         this.validate_atomic_rmw(place, atomic)?;\n \n         this.buffered_atomic_rmw(\n-            val.to_scalar_or_uninit(),\n+            val.to_scalar(),\n             place,\n             atomic,\n-            old.to_scalar_or_uninit(),\n+            old.to_scalar(),\n         )?;\n         Ok(old)\n     }\n@@ -544,9 +544,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn atomic_exchange_scalar(\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n-        new: ScalarMaybeUninit<Provenance>,\n+        new: Scalar<Provenance>,\n         atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         this.atomic_access_check(place)?;\n \n@@ -574,7 +574,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n         this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n-        let lt = this.binary_op(mir::BinOp::Lt, &old, &rhs)?.to_scalar()?.to_bool()?;\n+        let lt = this.binary_op(mir::BinOp::Lt, &old, &rhs)?.to_scalar().to_bool()?;\n \n         let new_val = if min {\n             if lt { &old } else { &rhs }\n@@ -587,10 +587,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         this.validate_atomic_rmw(place, atomic)?;\n \n         this.buffered_atomic_rmw(\n-            new_val.to_scalar_or_uninit(),\n+            new_val.to_scalar(),\n             place,\n             atomic,\n-            old.to_scalar_or_uninit(),\n+            old.to_scalar(),\n         )?;\n \n         // Return the old value.\n@@ -607,7 +607,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         expect_old: &ImmTy<'tcx, Provenance>,\n-        new: ScalarMaybeUninit<Provenance>,\n+        new: Scalar<Provenance>,\n         success: AtomicRwOrd,\n         fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n@@ -627,14 +627,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // If the operation would succeed, but is \"weak\", fail some portion\n         // of the time, based on `success_rate`.\n         let success_rate = 1.0 - this.machine.cmpxchg_weak_failure_rate;\n-        let cmpxchg_success = eq.to_scalar()?.to_bool()?\n+        let cmpxchg_success = eq.to_scalar().to_bool()?\n             && if can_fail_spuriously {\n                 this.machine.rng.get_mut().gen_bool(success_rate)\n             } else {\n                 true\n             };\n         let res = Immediate::ScalarPair(\n-            old.to_scalar_or_uninit(),\n+            old.to_scalar(),\n             Scalar::from_bool(cmpxchg_success).into(),\n         );\n \n@@ -644,14 +644,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         if cmpxchg_success {\n             this.allow_data_races_mut(|this| this.write_scalar(new, &place.into()))?;\n             this.validate_atomic_rmw(place, success)?;\n-            this.buffered_atomic_rmw(new, place, success, old.to_scalar_or_uninit())?;\n+            this.buffered_atomic_rmw(new, place, success, old.to_scalar())?;\n         } else {\n             this.validate_atomic_load(place, fail)?;\n             // A failed compare exchange is equivalent to a load, reading from the latest store\n             // in the modification order.\n             // Since `old` is only a value and not the store element, we need to separately\n             // find it in our store buffer and perform load_impl on it.\n-            this.perform_read_on_buffered_latest(place, fail, old.to_scalar_or_uninit())?;\n+            this.perform_read_on_buffered_latest(place, fail, old.to_scalar())?;\n         }\n \n         // Return the old value."}, {"sha": "bd43e848af732af08d0ecb429fce37a6c2f71a61", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -78,7 +78,7 @@ use std::{\n };\n \n use rustc_const_eval::interpret::{\n-    alloc_range, AllocRange, InterpResult, MPlaceTy, ScalarMaybeUninit,\n+    alloc_range, AllocRange, InterpResult, MPlaceTy, Scalar,\n };\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -130,10 +130,10 @@ struct StoreElement {\n     /// The timestamp of the storing thread when it performed the store\n     timestamp: VTimestamp,\n     /// The value of this store\n-    // FIXME: this means the store is either fully initialized or fully uninitialized;\n+    // FIXME: this means the store must be fully initialized;\n     // we will have to change this if we want to support atomics on\n-    // partially initialized data.\n-    val: ScalarMaybeUninit<Provenance>,\n+    // (partially) uninitialized data.\n+    val: Scalar<Provenance>,\n \n     /// Timestamp of first loads from this store element by each thread\n     /// Behind a RefCell to keep load op take &self\n@@ -180,7 +180,7 @@ impl StoreBufferAlloc {\n     fn get_or_create_store_buffer<'tcx>(\n         &self,\n         range: AllocRange,\n-        init: ScalarMaybeUninit<Provenance>,\n+        init: Scalar<Provenance>,\n     ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n         let access_type = self.store_buffers.borrow().access_type(range);\n         let pos = match access_type {\n@@ -205,7 +205,7 @@ impl StoreBufferAlloc {\n     fn get_or_create_store_buffer_mut<'tcx>(\n         &mut self,\n         range: AllocRange,\n-        init: ScalarMaybeUninit<Provenance>,\n+        init: Scalar<Provenance>,\n     ) -> InterpResult<'tcx, &mut StoreBuffer> {\n         let buffers = self.store_buffers.get_mut();\n         let access_type = buffers.access_type(range);\n@@ -226,7 +226,7 @@ impl StoreBufferAlloc {\n }\n \n impl<'mir, 'tcx: 'mir> StoreBuffer {\n-    fn new(init: ScalarMaybeUninit<Provenance>) -> Self {\n+    fn new(init: Scalar<Provenance>) -> Self {\n         let mut buffer = VecDeque::new();\n         buffer.reserve(STORE_BUFFER_LIMIT);\n         let mut ret = Self { buffer };\n@@ -259,7 +259,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, (ScalarMaybeUninit<Provenance>, LoadRecency)> {\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, LoadRecency)> {\n         // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n         // because the race detector doesn't touch store_buffer\n \n@@ -284,7 +284,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n \n     fn buffered_write(\n         &mut self,\n-        val: ScalarMaybeUninit<Provenance>,\n+        val: Scalar<Provenance>,\n         global: &DataRaceState,\n         thread_mgr: &ThreadManager<'_, '_>,\n         is_seqcst: bool,\n@@ -375,7 +375,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n     /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n     fn store_impl(\n         &mut self,\n-        val: ScalarMaybeUninit<Provenance>,\n+        val: Scalar<Provenance>,\n         index: VectorIdx,\n         thread_clock: &VClock,\n         is_seqcst: bool,\n@@ -421,7 +421,7 @@ impl StoreElement {\n         &self,\n         index: VectorIdx,\n         clocks: &ThreadClockSet,\n-    ) -> ScalarMaybeUninit<Provenance> {\n+    ) -> Scalar<Provenance> {\n         let _ = self.loads.borrow_mut().try_insert(index, clocks.clock[index]);\n         self.val\n     }\n@@ -464,10 +464,10 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n \n     fn buffered_atomic_rmw(\n         &mut self,\n-        new_val: ScalarMaybeUninit<Provenance>,\n+        new_val: Scalar<Provenance>,\n         place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicRwOrd,\n-        init: ScalarMaybeUninit<Provenance>,\n+        init: Scalar<Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n@@ -492,9 +492,9 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n-        latest_in_mo: ScalarMaybeUninit<Provenance>,\n+        latest_in_mo: Scalar<Provenance>,\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n         if let Some(global) = &this.machine.data_race {\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n@@ -529,10 +529,10 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n \n     fn buffered_atomic_write(\n         &mut self,\n-        val: ScalarMaybeUninit<Provenance>,\n+        val: Scalar<Provenance>,\n         dest: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicWriteOrd,\n-        init: ScalarMaybeUninit<Provenance>,\n+        init: Scalar<Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n@@ -576,7 +576,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n-        init: ScalarMaybeUninit<Provenance>,\n+        init: Scalar<Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n "}, {"sha": "92139d9aa2a94d8699151c79e69405c90371bdf2", "filename": "src/helpers.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -116,8 +116,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let instance = this.resolve_path(path);\n         let cid = GlobalId { instance, promoted: None };\n         let const_val = this.eval_to_allocation(cid)?;\n-        let const_val = this.read_scalar(&const_val.into())?;\n-        const_val.check_init()\n+        this.read_scalar(&const_val.into())\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n@@ -567,7 +566,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         let errno_place = this.last_error_place()?;\n-        this.read_scalar(&errno_place.into())?.check_init()\n+        this.read_scalar(&errno_place.into())\n     }\n \n     /// This function tries to produce the most similar OS error from the `std::io::ErrorKind`\n@@ -680,22 +679,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.read_scalar(&value_place.into())\n     }\n \n+    fn write_immediate_at_offset(\n+        &mut self,\n+        op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+        value: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+        let value_place = this.deref_operand_and_offset(op, offset, value.layout)?;\n+        this.write_immediate(**value, &value_place.into())\n+    }\n+\n     fn write_scalar_at_offset(\n         &mut self,\n         op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n-        value: impl Into<ScalarMaybeUninit<Provenance>>,\n+        value: impl Into<Scalar<Provenance>>,\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, ()> {\n-        let this = self.eval_context_mut();\n-        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n-        this.write_scalar(value, &value_place.into())\n+        self.write_immediate_at_offset(op, offset, &ImmTy::from_scalar(value.into(), layout))\n     }\n \n     /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`"}, {"sha": "6bba5bcc5f0dd66b31f09fccef9244acb0419452", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -149,7 +149,7 @@ static_assert_size!(Pointer<Provenance>, 24);\n // #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n //static_assert_size!(Pointer<Option<Provenance>>, 24);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ScalarMaybeUninit<Provenance>, 32);\n+static_assert_size!(Scalar<Provenance>, 32);\n \n impl interpret::Provenance for Provenance {\n     /// We use absolute addresses in the `offset` of a `Pointer<Provenance>`.\n@@ -581,7 +581,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn force_int_for_alignment_check(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+    fn use_addr_for_alignment_check(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n         ecx.machine.check_alignment == AlignmentCheck::Int\n     }\n \n@@ -590,11 +590,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx.machine.validate\n     }\n \n-    #[inline(always)]\n-    fn enforce_number_init(_ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n-        true\n-    }\n-\n     #[inline(always)]\n     fn enforce_abi(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n         ecx.machine.enforce_abi"}, {"sha": "09e9b0cbd1540b37d4218d8156299b6671ea5670", "filename": "src/operator.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -32,16 +32,14 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 // Just compare the bits. ScalarPairs are compared lexicographically.\n                 // We thus always compare pairs and simply fill scalars up with 0.\n                 let left = match **left {\n-                    Immediate::Scalar(l) => (l.check_init()?.to_bits(size)?, 0),\n-                    Immediate::ScalarPair(l1, l2) =>\n-                        (l1.check_init()?.to_bits(size)?, l2.check_init()?.to_bits(size)?),\n-                    Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n+                    Immediate::Scalar(l) => (l.to_bits(size)?, 0),\n+                    Immediate::ScalarPair(l1, l2) => (l1.to_bits(size)?, l2.to_bits(size)?),\n+                    Immediate::Uninit => panic!(\"we should never see uninit data here\"),\n                 };\n                 let right = match **right {\n-                    Immediate::Scalar(r) => (r.check_init()?.to_bits(size)?, 0),\n-                    Immediate::ScalarPair(r1, r2) =>\n-                        (r1.check_init()?.to_bits(size)?, r2.check_init()?.to_bits(size)?),\n-                    Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n+                    Immediate::Scalar(r) => (r.to_bits(size)?, 0),\n+                    Immediate::ScalarPair(r1, r2) => (r1.to_bits(size)?, r2.to_bits(size)?),\n+                    Immediate::Uninit => panic!(\"we should never see uninit data here\"),\n                 };\n                 let res = match bin_op {\n                     Eq => left == right,\n@@ -57,8 +55,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n             Offset => {\n                 assert!(left.layout.ty.is_unsafe_ptr());\n-                let ptr = left.to_scalar()?.to_pointer(self)?;\n-                let offset = right.to_scalar()?.to_machine_isize(self)?;\n+                let ptr = left.to_scalar().to_pointer(self)?;\n+                let offset = right.to_scalar().to_machine_isize(self)?;\n \n                 let pointee_ty =\n                     left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n@@ -71,11 +69,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n             Add | Sub | BitOr | BitAnd | BitXor => {\n                 assert!(left.layout.ty.is_unsafe_ptr());\n                 assert!(right.layout.ty.is_unsafe_ptr());\n-                let ptr = left.to_scalar()?.to_pointer(self)?;\n+                let ptr = left.to_scalar().to_pointer(self)?;\n                 // We do the actual operation with usize-typed scalars.\n                 let left = ImmTy::from_uint(ptr.addr().bytes(), self.machine.layouts.usize);\n                 let right = ImmTy::from_uint(\n-                    right.to_scalar()?.to_machine_usize(self)?,\n+                    right.to_scalar().to_machine_usize(self)?,\n                     self.machine.layouts.usize,\n                 );\n                 let (result, overflowing, _ty) ="}, {"sha": "a930c4a96754976cbd5f24b2550f345672102fcb", "filename": "src/shims/intrinsics/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fmod.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -226,8 +226,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 let float_finite = |x: &ImmTy<'tcx, _>| -> InterpResult<'tcx, bool> {\n                     Ok(match x.layout.ty.kind() {\n-                        ty::Float(FloatTy::F32) => x.to_scalar()?.to_f32()?.is_finite(),\n-                        ty::Float(FloatTy::F64) => x.to_scalar()?.to_f64()?.is_finite(),\n+                        ty::Float(FloatTy::F32) => x.to_scalar().to_f32()?.is_finite(),\n+                        ty::Float(FloatTy::F64) => x.to_scalar().to_f64()?.is_finite(),\n                         _ => bug!(\n                             \"`{intrinsic_name}` called with non-float input type {ty:?}\",\n                             ty = x.layout.ty,\n@@ -345,9 +345,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 let res = match val.layout.ty.kind() {\n                     ty::Float(FloatTy::F32) =>\n-                        this.float_to_int_unchecked(val.to_scalar()?.to_f32()?, dest.layout.ty)?,\n+                        this.float_to_int_unchecked(val.to_scalar().to_f32()?, dest.layout.ty)?,\n                     ty::Float(FloatTy::F64) =>\n-                        this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?,\n+                        this.float_to_int_unchecked(val.to_scalar().to_f64()?, dest.layout.ty)?,\n                     _ =>\n                         span_bug!(\n                             this.cur_span(),"}, {"sha": "95763e1e832f3aff8b60d9bb09ab57a20327ba12", "filename": "src/shims/intrinsics/simd.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fsimd.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -60,13 +60,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n                     let dest = this.mplace_index(&dest, i)?;\n                     let val = match which {\n-                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar()?,\n+                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar(),\n                         Op::Abs => {\n                             // Works for f32 and f64.\n                             let ty::Float(float_ty) = op.layout.ty.kind() else {\n                                 span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n                             };\n-                            let op = op.to_scalar()?;\n+                            let op = op.to_scalar();\n                             match float_ty {\n                                 FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n                                 FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n@@ -79,7 +79,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             // FIXME using host floats\n                             match float_ty {\n                                 FloatTy::F32 => {\n-                                    let f = f32::from_bits(op.to_scalar()?.to_u32()?);\n+                                    let f = f32::from_bits(op.to_scalar().to_u32()?);\n                                     let res = match host_op {\n                                         HostFloatOp::Ceil => f.ceil(),\n                                         HostFloatOp::Floor => f.floor(),\n@@ -90,7 +90,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                                     Scalar::from_u32(res.to_bits())\n                                 }\n                                 FloatTy::F64 => {\n-                                    let f = f64::from_bits(op.to_scalar()?.to_u64()?);\n+                                    let f = f64::from_bits(op.to_scalar().to_u64()?);\n                                     let res = match host_op {\n                                         HostFloatOp::Ceil => f.ceil(),\n                                         HostFloatOp::Floor => f.floor(),\n@@ -182,7 +182,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                                 // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n                                 // See <https://github.com/rust-lang/rust/issues/91237>.\n                                 if overflowed {\n-                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n+                                    let r_val = right.to_scalar().to_bits(right.layout.size)?;\n                                     throw_ub_format!(\"overflowing shift by {r_val} in `simd_{intrinsic_name}` in SIMD lane {i}\");\n                                 }\n                             }\n@@ -201,8 +201,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             this.saturating_arith(mir_op, &left, &right)?\n                         }\n                         Op::WrappingOffset => {\n-                            let ptr = left.to_scalar()?.to_pointer(this)?;\n-                            let offset_count = right.to_scalar()?.to_machine_isize(this)?;\n+                            let ptr = left.to_scalar().to_pointer(this)?;\n+                            let offset_count = right.to_scalar().to_machine_isize(this)?;\n                             let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n \n                             let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -232,9 +232,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 assert_eq!(dest_len, c_len);\n \n                 for i in 0..dest_len {\n-                    let a = this.read_immediate(&this.mplace_index(&a, i)?.into())?.to_scalar()?;\n-                    let b = this.read_immediate(&this.mplace_index(&b, i)?.into())?.to_scalar()?;\n-                    let c = this.read_immediate(&this.mplace_index(&c, i)?.into())?.to_scalar()?;\n+                    let a = this.read_scalar(&this.mplace_index(&a, i)?.into())?;\n+                    let b = this.read_scalar(&this.mplace_index(&b, i)?.into())?;\n+                    let c = this.read_scalar(&this.mplace_index(&c, i)?.into())?;\n                     let dest = this.mplace_index(&dest, i)?;\n \n                     // Works for f32 and f64.\n@@ -315,7 +315,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                                 ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n                             } else {\n                                 // Just boring integers, so NaNs to worry about\n-                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar()?.to_bool()? {\n+                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar().to_bool()? {\n                                     res\n                                 } else {\n                                     op\n@@ -327,7 +327,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                                 ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n                             } else {\n                                 // Just boring integers, so NaNs to worry about\n-                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar()?.to_bool()? {\n+                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar().to_bool()? {\n                                     res\n                                 } else {\n                                     op\n@@ -398,7 +398,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 let mask: u64 = this\n                     .read_scalar(mask)?\n-                    .check_init()?\n                     .to_bits(mask.layout.size)?\n                     .try_into()\n                     .unwrap();\n@@ -450,9 +449,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             this.misc_cast(&op, dest.layout.ty)?,\n                         // Float-to-int in unchecked mode\n                         (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n-                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n+                            this.float_to_int_unchecked(op.to_scalar().to_f32()?, dest.layout.ty)?.into(),\n                         (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n-                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n+                            this.float_to_int_unchecked(op.to_scalar().to_f64()?, dest.layout.ty)?.into(),\n                         _ =>\n                             throw_unsup_format!(\n                                 \"Unsupported SIMD cast from element type {from_ty} to {to_ty}\",\n@@ -481,7 +480,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 for i in 0..dest_len {\n                     let src_index: u64 = this\n                         .read_immediate(&this.operand_index(index, i)?)?\n-                        .to_scalar()?\n+                        .to_scalar()\n                         .to_u32()?\n                         .into();\n                     let dest = this.mplace_index(&dest, i)?;\n@@ -581,7 +580,7 @@ fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Provenance> {\n }\n \n fn simd_element_to_bool(elem: ImmTy<'_, Provenance>) -> InterpResult<'_, bool> {\n-    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n+    let val = elem.to_scalar().to_int(elem.layout.size)?;\n     Ok(match val {\n         0 => false,\n         -1 => true,\n@@ -606,8 +605,8 @@ fn fmax_op<'tcx>(\n     let ty::Float(float_ty) = left.layout.ty.kind() else {\n         bug!(\"fmax operand is not a float\")\n     };\n-    let left = left.to_scalar()?;\n-    let right = right.to_scalar()?;\n+    let left = left.to_scalar();\n+    let right = right.to_scalar();\n     Ok(match float_ty {\n         FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n         FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n@@ -622,8 +621,8 @@ fn fmin_op<'tcx>(\n     let ty::Float(float_ty) = left.layout.ty.kind() else {\n         bug!(\"fmin operand is not a float\")\n     };\n-    let left = left.to_scalar()?;\n-    let right = right.to_scalar()?;\n+    let left = left.to_scalar();\n+    let right = right.to_scalar();\n     Ok(match float_ty {\n         FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n         FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),"}, {"sha": "3784dabfeac24d97c6f71f2a9a9b097653e7b1bc", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -52,7 +52,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n         let [payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-        let payload = this.read_scalar(payload)?.check_init()?;\n+        let payload = this.read_scalar(payload)?;\n         let thread = this.active_thread_mut();\n         assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n         thread.panic_payload = Some(payload);\n@@ -85,7 +85,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Get all the arguments.\n         let [try_fn, data, catch_fn] = check_arg_count(args)?;\n         let try_fn = this.read_pointer(try_fn)?;\n-        let data = this.read_scalar(data)?.check_init()?;\n+        let data = this.read_scalar(data)?;\n         let catch_fn = this.read_pointer(catch_fn)?;\n \n         // Now we make a function call, and pass `data` as first and only argument."}, {"sha": "09604e178e244d7350c14ede62cdbf1e9c6c486a", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -283,24 +283,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_key_delete\" => {\n                 let [key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n+                let key = this.read_scalar(key)?.to_bits(key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n                 let [key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n+                let key = this.read_scalar(key)?.to_bits(key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let [key, new_ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n+                let key = this.read_scalar(key)?.to_bits(key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let new_data = this.read_scalar(new_ptr)?;\n-                this.machine.tls.store_tls(key, active_thread, new_data.check_init()?, &*this.tcx)?;\n+                this.machine.tls.store_tls(key, active_thread, new_data, &*this.tcx)?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n@@ -465,7 +465,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"strerror_r\" | \"__xpg_strerror_r\" => {\n                 let [errnum, buf, buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let errnum = this.read_scalar(errnum)?.check_init()?;\n+                let errnum = this.read_scalar(errnum)?;\n                 let buf = this.read_pointer(buf)?;\n                 let buflen = this.read_scalar(buflen)?.to_machine_usize(this)?;\n "}, {"sha": "ec565aa3150e06f9a0a36f861c666df9b6c4e81a", "filename": "src/shims/unix/freebsd/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -37,7 +37,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"__error\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n-                this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n+                this.write_scalar(errno_place.to_ref(this).to_scalar(), dest)?;\n             }\n \n             _ => return Ok(EmulateByNameResult::NotSupported),"}, {"sha": "3c042740b5061ad6aee4617db83841cf05b65878", "filename": "src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -26,7 +26,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"__errno_location\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n-                this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n+                this.write_scalar(errno_place.to_ref(this).to_scalar(), dest)?;\n             }\n \n             // File related shims (but also see \"syscall\" below for statx)"}, {"sha": "a3f3a28dbc21d9bfbec4e6aecd4e86ff4e335b78", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -33,7 +33,7 @@ pub fn futex<'tcx>(\n     let val = this.read_scalar(&args[2])?.to_i32()?;\n \n     let thread = this.get_active_thread();\n-    let addr_scalar = addr.to_scalar()?;\n+    let addr_scalar = addr.to_scalar();\n     let addr_usize = addr_scalar.to_machine_usize(this)?;\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;"}, {"sha": "fa4001bab187e3fc441166d6ce9e5379c5d8482f", "filename": "src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -24,7 +24,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"__error\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n-                this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n+                this.write_scalar(errno_place.to_ref(this).to_scalar(), dest)?;\n             }\n \n             // File related shims\n@@ -153,7 +153,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let dtor = this.read_pointer(dtor)?;\n                 let dtor = this.get_ptr_fn(dtor)?.as_instance()?;\n-                let data = this.read_scalar(data)?.check_init()?;\n+                let data = this.read_scalar(data)?;\n                 let active_thread = this.get_active_thread();\n                 this.machine.tls.set_macos_thread_dtor(active_thread, dtor, data)?;\n             }\n@@ -185,7 +185,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n                 let [addr, _, _, _, _, _] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let addr = this.read_scalar(addr)?.check_init()?;\n+                let addr = this.read_scalar(addr)?;\n                 this.write_scalar(addr, dest)?;\n             }\n "}, {"sha": "88c5d2e3f81ebfe7f509e21c5136d47dcdf55cae", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 35, "deletions": 55, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -38,14 +38,14 @@ fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-    kind: impl Into<ScalarMaybeUninit<Provenance>>,\n+    kind: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(attr_op, 0, kind, layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32))\n }\n@@ -62,7 +62,7 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.read_scalar_at_offset_atomic(\n         mutex_op,\n@@ -75,7 +75,7 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-    kind: impl Into<ScalarMaybeUninit<Provenance>>,\n+    kind: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.write_scalar_at_offset_atomic(\n@@ -90,14 +90,14 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<ScalarMaybeUninit<Provenance>>,\n+    id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n         mutex_op,\n@@ -124,8 +124,7 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n                 AtomicReadOrd::Relaxed,\n                 false,\n             )?\n-            .to_scalar_pair()\n-            .expect(\"compare_exchange returns a scalar pair\");\n+            .to_scalar_pair();\n \n         Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n             // Caller of the closure needs to allocate next_id\n@@ -146,24 +145,10 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n-fn rwlock_set_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<ScalarMaybeUninit<Provenance>>,\n-) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset_atomic(\n-        rwlock_op,\n-        4,\n-        id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n-}\n-\n fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Provenance>,\n@@ -180,8 +165,7 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n                 AtomicReadOrd::Relaxed,\n                 false,\n             )?\n-            .to_scalar_pair()\n-            .expect(\"compare_exchange returns a scalar pair\");\n+            .to_scalar_pair();\n \n         Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n             // Caller of the closure needs to allocate next_id\n@@ -201,14 +185,14 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-    clock_id: impl Into<ScalarMaybeUninit<Provenance>>,\n+    clock_id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(\n         attr_op,\n@@ -230,14 +214,14 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<ScalarMaybeUninit<Provenance>>,\n+    id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n         cond_op,\n@@ -264,8 +248,7 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n                 AtomicReadOrd::Relaxed,\n                 false,\n             )?\n-            .to_scalar_pair()\n-            .expect(\"compare_exchange returns a scalar pair\");\n+            .to_scalar_pair();\n \n         Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n             // Caller of the closure needs to allocate next_id\n@@ -279,14 +262,14 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-    clock_id: impl Into<ScalarMaybeUninit<Provenance>>,\n+    clock_id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(\n         cond_op,\n@@ -366,7 +349,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let kind = this.read_scalar(kind_op)?.check_init()?;\n+        let kind = this.read_scalar(kind_op)?;\n         if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n             // In `glibc` implementation, the numeric values of\n             // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal.\n@@ -407,7 +390,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         // Destroying an uninit pthread_mutexattr is UB, so check to make sure it's not uninit.\n-        mutexattr_get_kind(this, attr_op)?.check_init()?;\n+        mutexattr_get_kind(this, attr_op)?;\n \n         // To catch double-destroys, we de-initialize the mutexattr.\n         // This is technically not right and might lead to false positives. For example, the below\n@@ -421,8 +404,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // However, the way libstd uses the pthread APIs works in our favor here, so we can get away with this.\n         // This can always be revisited to have some external state to catch double-destroys\n         // but not complain about the above code. See https://github.com/rust-lang/miri/pull/1933\n-\n-        mutexattr_set_kind(this, attr_op, ScalarMaybeUninit::Uninit)?;\n+        this.write_uninit(&this.deref_operand(attr_op)?.into())?;\n \n         Ok(0)\n     }\n@@ -438,7 +420,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let kind = if this.ptr_is_null(attr)? {\n             this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n         } else {\n-            mutexattr_get_kind(this, attr_op)?.check_init()?\n+            mutexattr_get_kind(this, attr_op)?\n         };\n \n         // Write 0 to use the same code path as the static initializers.\n@@ -452,7 +434,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_mutex_lock(&mut self, mutex_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n+        let kind = mutex_get_kind(this, mutex_op)?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n@@ -492,7 +474,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n+        let kind = mutex_get_kind(this, mutex_op)?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n@@ -528,7 +510,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n+        let kind = mutex_get_kind(this, mutex_op)?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n@@ -570,12 +552,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Destroying an uninit pthread_mutex is UB, so check to make sure it's not uninit.\n-        mutex_get_kind(this, mutex_op)?.check_init()?;\n-        mutex_get_id(this, mutex_op)?.check_init()?;\n+        mutex_get_kind(this, mutex_op)?;\n+        mutex_get_id(this, mutex_op)?;\n \n         // This might lead to false positives, see comment in pthread_mutexattr_destroy\n-        mutex_set_kind(this, mutex_op, ScalarMaybeUninit::Uninit)?;\n-        mutex_set_id(this, mutex_op, ScalarMaybeUninit::Uninit)?;\n+        this.write_uninit(&this.deref_operand(mutex_op)?.into())?;\n         // FIXME: delete interpreter state associated with this mutex.\n \n         Ok(0)\n@@ -695,10 +676,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Destroying an uninit pthread_rwlock is UB, so check to make sure it's not uninit.\n-        rwlock_get_id(this, rwlock_op)?.check_init()?;\n+        rwlock_get_id(this, rwlock_op)?;\n \n         // This might lead to false positives, see comment in pthread_mutexattr_destroy\n-        rwlock_set_id(this, rwlock_op, ScalarMaybeUninit::Uninit)?;\n+        this.write_uninit(&this.deref_operand(rwlock_op)?.into())?;\n         // FIXME: delete interpreter state associated with this rwlock.\n \n         Ok(0)\n@@ -726,7 +707,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let clock_id = this.read_scalar(clock_id_op)?.check_init()?;\n+        let clock_id = this.read_scalar(clock_id_op)?;\n         if clock_id == this.eval_libc(\"CLOCK_REALTIME\")?\n             || clock_id == this.eval_libc(\"CLOCK_MONOTONIC\")?\n         {\n@@ -759,10 +740,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         // Destroying an uninit pthread_condattr is UB, so check to make sure it's not uninit.\n-        condattr_get_clock_id(this, attr_op)?.check_init()?;\n+        condattr_get_clock_id(this, attr_op)?;\n \n         // This might lead to false positives, see comment in pthread_mutexattr_destroy\n-        condattr_set_clock_id(this, attr_op, ScalarMaybeUninit::Uninit)?;\n+        this.write_uninit(&this.deref_operand(attr_op)?.into())?;\n \n         Ok(0)\n     }\n@@ -778,7 +759,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let clock_id = if this.ptr_is_null(attr)? {\n             this.eval_libc(\"CLOCK_REALTIME\")?\n         } else {\n-            condattr_get_clock_id(this, attr_op)?.check_init()?\n+            condattr_get_clock_id(this, attr_op)?\n         };\n \n         // Write 0 to use the same code path as the static initializers.\n@@ -906,12 +887,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Destroying an uninit pthread_cond is UB, so check to make sure it's not uninit.\n-        cond_get_id(this, cond_op)?.check_init()?;\n-        cond_get_clock_id(this, cond_op)?.check_init()?;\n+        cond_get_id(this, cond_op)?;\n+        cond_get_clock_id(this, cond_op)?;\n \n         // This might lead to false positives, see comment in pthread_mutexattr_destroy\n-        cond_set_id(this, cond_op, ScalarMaybeUninit::Uninit)?;\n-        cond_set_clock_id(this, cond_op, ScalarMaybeUninit::Uninit)?;\n+        this.write_uninit(&this.deref_operand(cond_op)?.into())?;\n         // FIXME: delete interpreter state associated with this condvar.\n \n         Ok(0)"}, {"sha": "9b8f32b0ab60d71fd8ef6bdfe80e35c247f82f6f", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -104,7 +104,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"SetLastError\" => {\n                 let [error] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                let error = this.read_scalar(error)?.check_init()?;\n+                let error = this.read_scalar(error)?;\n                 this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n@@ -187,7 +187,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n-                let new_data = this.read_scalar(new_ptr)?.check_init()?;\n+                let new_data = this.read_scalar(new_ptr)?;\n                 this.machine.tls.store_tls(key, active_thread, new_data, &*this.tcx)?;\n \n                 // Return success (`1`)."}, {"sha": "e998b68a421f6dc42fda89da06283bf8e00b0444", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -19,8 +19,7 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n                 AtomicReadOrd::Relaxed,\n                 false,\n             )?\n-            .to_scalar_pair()\n-            .expect(\"compare_exchange returns a scalar pair\");\n+            .to_scalar_pair();\n \n         Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n             // Caller of the closure needs to allocate next_id"}, {"sha": "b51af24c134b22da4c57defdc33bf59b6d68286d", "filename": "tests/fail/invalid_int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Finvalid_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Finvalid_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Finvalid_int.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -3,6 +3,6 @@\n //@compile-flags: -Zmiri-disable-alignment-check -Zmiri-disable-stacked-borrows -Zmiri-disable-validation\n \n fn main() {\n-    let i = unsafe { std::mem::MaybeUninit::<i32>::uninit().assume_init() };\n-    let _x = i + 0; //~ ERROR: this operation requires initialized memory\n+    let i = unsafe { std::mem::MaybeUninit::<i32>::uninit().assume_init() }; //~ ERROR: uninitialized\n+    let _x = i + 0;\n }"}, {"sha": "471c0a7b10f816a696348e94bceaac3404535230", "filename": "tests/fail/invalid_int.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Finvalid_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Finvalid_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Finvalid_int.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/invalid_int.rs:LL:CC\n    |\n-LL |     let _x = i + 0;\n-   |              ^^^^^ using uninitialized data, but this operation requires initialized memory\n+LL |     let i = unsafe { std::mem::MaybeUninit::<i32>::uninit().assume_init() };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "a8e0bdd05b6d774498f2ebac4a50d76b644b6228", "filename": "tests/fail/transmute-pair-uninit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Ftransmute-pair-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Ftransmute-pair-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ftransmute-pair-uninit.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/transmute-pair-uninit.rs:LL:CC\n    |\n LL |     let v = unsafe { *z.offset(first_undef) };\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "432710b04f869e862be7c0d7849c96bec6d248df", "filename": "tests/fail/uninit_byte_read.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Funinit_byte_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Funinit_byte_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funinit_byte_read.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/uninit_byte_read.rs:LL:CC\n    |\n LL |     let undef = unsafe { *v.get_unchecked(5) };\n-   |                          ^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n+   |                          ^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "84a221a469a7a7061b7098264818fdf4145bcc7b", "filename": "tests/fail/validity/invalid_bool_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_bool_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_bool_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_bool_uninit.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -6,5 +6,5 @@ union MyUninit {\n }\n \n fn main() {\n-    let _b = unsafe { MyUninit { init: () }.uninit }; //~ ERROR: encountered uninitialized bytes, but expected a boolean\n+    let _b = unsafe { MyUninit { init: () }.uninit }; //~ ERROR: uninitialized\n }"}, {"sha": "3d90a45d831cff44305deec1d6192927ccc46d56", "filename": "tests/fail/validity/invalid_bool_uninit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_bool_uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_bool_uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_bool_uninit.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered uninitialized bytes, but expected a boolean\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/invalid_bool_uninit.rs:LL:CC\n    |\n LL |     let _b = unsafe { MyUninit { init: () }.uninit };\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a boolean\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "c16e26649076a1e274a7f256714a4ed30d00e3fb", "filename": "tests/fail/validity/invalid_char_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_char_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_char_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_char_uninit.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -6,5 +6,5 @@ union MyUninit {\n }\n \n fn main() {\n-    let _b = unsafe { MyUninit { init: () }.uninit }; //~ ERROR: encountered uninitialized bytes, but expected a valid unicode scalar value\n+    let _b = unsafe { MyUninit { init: () }.uninit }; //~ ERROR: uninitialized\n }"}, {"sha": "0512f90a90a47e7b2a0c287d2cea3483cfd056aa", "filename": "tests/fail/validity/invalid_char_uninit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_char_uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_char_uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_char_uninit.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered uninitialized bytes, but expected a valid unicode scalar value (in `0..=$HEX` but not in `$HEX..=$HEX`)\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/invalid_char_uninit.rs:LL:CC\n    |\n LL |     let _b = unsafe { MyUninit { init: () }.uninit };\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a valid unicode scalar value (in `0..=$HEX` but not in `$HEX..=$HEX`)\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "c857d83bde0dbb2438220fbcdcbede5cd3ee9bef", "filename": "tests/fail/validity/invalid_fnptr_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_fnptr_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_fnptr_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_fnptr_uninit.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -6,5 +6,5 @@ union MyUninit {\n }\n \n fn main() {\n-    let _b = unsafe { MyUninit { init: () }.uninit }; //~ ERROR: encountered uninitialized bytes\n+    let _b = unsafe { MyUninit { init: () }.uninit }; //~ ERROR: uninitialized\n }"}, {"sha": "f5de8101709d124ed7717db27bd3b46685f073e8", "filename": "tests/fail/validity/invalid_fnptr_uninit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_fnptr_uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Finvalid_fnptr_uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_fnptr_uninit.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered uninitialized bytes, but expected a proper pointer or integer value\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/invalid_fnptr_uninit.rs:LL:CC\n    |\n LL |     let _b = unsafe { MyUninit { init: () }.uninit };\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a proper pointer or integer value\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "fecc02d7a505fefa16ce4e2d1a1edb143e995613", "filename": "tests/fail/validity/uninit_float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Funinit_float.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -4,5 +4,5 @@\n fn main() {\n     // Deliberately using `mem::uninitialized` to make sure that despite all the mitigations, we consider this UB.\n     let _val: f32 = unsafe { std::mem::uninitialized() };\n-    //~^ ERROR: constructing invalid value at .value: encountered uninitialized bytes, but expected initialized bytes\n+    //~^ ERROR: uninitialized\n }"}, {"sha": "8a677202c8ebf30244db8bd23e86564bc10f8207", "filename": "tests/fail/validity/uninit_float.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_float.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_float.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Funinit_float.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value at .value: encountered uninitialized bytes, but expected initialized bytes\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/uninit_float.rs:LL:CC\n    |\n LL |     let _val: f32 = unsafe { std::mem::uninitialized() };\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .value: encountered uninitialized bytes, but expected initialized bytes\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "a9b200732653d55cc54a89ace22b5f65c2d9cb53", "filename": "tests/fail/validity/uninit_integer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Funinit_integer.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     let _val = unsafe { std::mem::MaybeUninit::<usize>::uninit().assume_init() };\n-    //~^ ERROR: constructing invalid value at .value: encountered uninitialized bytes, but expected initialized bytes\n+    //~^ ERROR: uninitialized\n }"}, {"sha": "60bf2c73667711e34f3b8b78e1784d74011edc6e", "filename": "tests/fail/validity/uninit_integer.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_integer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_integer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Funinit_integer.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value at .value: encountered uninitialized bytes, but expected initialized bytes\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/uninit_integer.rs:LL:CC\n    |\n LL |     let _val = unsafe { std::mem::MaybeUninit::<usize>::uninit().assume_init() };\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .value: encountered uninitialized bytes, but expected initialized bytes\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "9f99dc1a0e11cef30fe9128cf141fc6f94810ed7", "filename": "tests/fail/validity/uninit_raw_ptr.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_raw_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_raw_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Funinit_raw_ptr.rs?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let _val = unsafe { std::mem::MaybeUninit::<*const u8>::uninit().assume_init() };\n-    //~^ ERROR: constructing invalid value at .value: encountered uninitialized raw pointer\n+    //~^ ERROR: uninitialized\n }", "previous_filename": "tests/fail/uninit_raw_ptr.rs"}, {"sha": "efa444229270c4e3ab53978912c7ab758be94434", "filename": "tests/fail/validity/uninit_raw_ptr.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_raw_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2252b7b321076d8cf314fa49dc5a4c9da133b4/tests%2Ffail%2Fvalidity%2Funinit_raw_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Funinit_raw_ptr.stderr?ref=3a2252b7b321076d8cf314fa49dc5a4c9da133b4", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value at .value: encountered uninitialized raw pointer\n+error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n   --> $DIR/uninit_raw_ptr.rs:LL:CC\n    |\n LL |     let _val = unsafe { std::mem::MaybeUninit::<*const u8>::uninit().assume_init() };\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .value: encountered uninitialized raw pointer\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information", "previous_filename": "tests/fail/uninit_raw_ptr.stderr"}, {"sha": "f33806e8b4433edc70791dd42a009cd4a1d67764", "filename": "tests/pass/issues/issue-miri-2068-2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/101c4f2e38e88a181f7847c536c077272f993268/tests%2Fpass%2Fissues%2Fissue-miri-2068-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101c4f2e38e88a181f7847c536c077272f993268/tests%2Fpass%2Fissues%2Fissue-miri-2068-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fissues%2Fissue-miri-2068-2.rs?ref=101c4f2e38e88a181f7847c536c077272f993268", "patch": "@@ -1,16 +0,0 @@\n-//@compile-flags: -Zmiri-disable-validation\n-\n-use std::mem::MaybeUninit;\n-\n-fn main() {\n-    unsafe {\n-        let mut x = MaybeUninit::<i64>::uninit();\n-        // Put in a ptr.\n-        x.as_mut_ptr().cast::<&i32>().write_unaligned(&0);\n-        // Overwrite parts of that pointer with 'uninit' through a Scalar.\n-        let ptr = x.as_mut_ptr().cast::<i32>();\n-        *ptr = MaybeUninit::uninit().assume_init();\n-        // Reading this back should hence work fine.\n-        let _c = *ptr;\n-    }\n-}"}]}