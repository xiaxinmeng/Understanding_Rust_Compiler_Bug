{"sha": "43d19f63f7c6007284387e76cfe0fe8b74e98a59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZDE5ZjYzZjdjNjAwNzI4NDM4N2U3NmNmZTBmZThiNzRlOThhNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-03T10:34:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-03T10:34:22Z"}, "message": "Auto merge of #6824 - Y-Nak:refactor_loops_module, r=flip1995\n\nRefactor: organize loops file into loops module (Delegated)\n\n`@flip1995` `@nahuakang`\n\ncloses #6693\nr? `@flip1995`\n\n As we talked about in the PM of Zulip,  this PR is a delegated PR from `@nahuakang.`\n\nChanges from the last commit of #6693:\n1. Unify the name of the main entries of all modules to check, that was pointed out [here](https://github.com/rust-lang/rust-clippy/pull/6693#discussion_r582897713)\n2. Simplify ` check_for_loop_arg`, that was pointed out [here](https://github.com/rust-lang/rust-clippy/pull/6693#discussion_r582914044) and [here](https://github.com/rust-lang/rust-clippy/pull/6693#discussion_r582929910)\n3. Resolve conflicts\n\nchangelog: Refactor `loops.rs` file into `loops` module.", "tree": {"sha": "6e0579d2eec5e18021193898642534e0ec32177f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e0579d2eec5e18021193898642534e0ec32177f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43d19f63f7c6007284387e76cfe0fe8b74e98a59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43d19f63f7c6007284387e76cfe0fe8b74e98a59", "html_url": "https://github.com/rust-lang/rust/commit/43d19f63f7c6007284387e76cfe0fe8b74e98a59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43d19f63f7c6007284387e76cfe0fe8b74e98a59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ece3543c9f292c77b6a388eff6d3d5b857092f9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ece3543c9f292c77b6a388eff6d3d5b857092f9b", "html_url": "https://github.com/rust-lang/rust/commit/ece3543c9f292c77b6a388eff6d3d5b857092f9b"}, {"sha": "19c886b4076ebf264ef919b1fd78ebb9f193476c", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c886b4076ebf264ef919b1fd78ebb9f193476c", "html_url": "https://github.com/rust-lang/rust/commit/19c886b4076ebf264ef919b1fd78ebb9f193476c"}], "stats": {"total": 6559, "additions": 3386, "deletions": 3173}, "files": [{"sha": "711cd5b3b15cc64faf82bf2613bc78f98df186f1", "filename": "clippy_lints/src/loops.rs", "status": "removed", "additions": 0, "deletions": 3173, "changes": 3173, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b"}, {"sha": "67d1ac89b97afd7d4f90492ca761d6844fd93bef", "filename": "clippy_lints/src/loops/empty_loop.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fempty_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fempty_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fempty_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,17 @@\n+use super::EMPTY_LOOP;\n+use crate::utils::{is_in_panic_handler, is_no_std_crate, span_lint_and_help};\n+\n+use rustc_hir::{Block, Expr};\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+    if loop_block.stmts.is_empty() && loop_block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n+        let msg = \"empty `loop {}` wastes CPU cycles\";\n+        let help = if is_no_std_crate(cx.tcx.hir().krate()) {\n+            \"you should either use `panic!()` or add a call pausing or sleeping the thread to the loop body\"\n+        } else {\n+            \"you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\"\n+        };\n+        span_lint_and_help(cx, EMPTY_LOOP, expr.span, msg, None, help);\n+    }\n+}"}, {"sha": "8d98b940c66a95c3745c1c49dec67c2a74c9fa77", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,58 @@\n+use super::{\n+    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP,\n+};\n+use crate::utils::{get_enclosing_block, is_integer_const, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr};\n+use rustc_hir::{Expr, Pat};\n+use rustc_lint::LateContext;\n+\n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_expr(&mut increment_visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n+        for id in increment_visitor.into_results() {\n+            let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n+            walk_block(&mut initialize_visitor, block);\n+\n+            if_chain! {\n+                if let Some((name, initializer)) = initialize_visitor.get_result();\n+                if is_integer_const(cx, initializer, 0);\n+                then {\n+                    let mut applicability = Applicability::MachineApplicable;\n+\n+                    let for_span = get_span_of_entire_for_loop(expr);\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXPLICIT_COUNTER_LOOP,\n+                        for_span.with_hi(arg.span.hi()),\n+                        &format!(\"the variable `{}` is used as a loop counter\", name),\n+                        \"consider using\",\n+                        format!(\n+                            \"for ({}, {}) in {}.enumerate()\",\n+                            name,\n+                            snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n+                            make_iterator_snippet(cx, arg, &mut applicability),\n+                        ),\n+                        applicability,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "1d778205a2ad1f3d118dd5f7461933a8387989b3", "filename": "clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,27 @@\n+use super::EXPLICIT_INTO_ITER_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, args: &'hir [Expr<'hir>], arg: &Expr<'_>) {\n+    let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+    let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    if !TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n+        return;\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_INTO_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over containers instead of using explicit \\\n+            iteration methods\",\n+        \"to write this more concisely, try\",\n+        object.to_string(),\n+        applicability,\n+    );\n+}"}, {"sha": "44d08916891051939e6694c68b81384b2825e9f4", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,74 @@\n+use super::EXPLICIT_ITER_LOOP;\n+use crate::utils::{match_trait_method, snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{is_type_diagnostic_item, match_type, paths};\n+\n+pub(super) fn check(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+    let should_lint = match method_name {\n+        \"iter\" | \"iter_mut\" => is_ref_iterable_type(cx, &args[0]),\n+        \"into_iter\" if match_trait_method(cx, arg, &paths::INTO_ITERATOR) => {\n+            let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+            let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+            let ref_receiver_ty = cx.tcx.mk_ref(\n+                cx.tcx.lifetimes.re_erased,\n+                ty::TypeAndMut {\n+                    ty: receiver_ty,\n+                    mutbl: Mutability::Not,\n+                },\n+            );\n+            TyS::same_type(receiver_ty_adjusted, ref_receiver_ty)\n+        },\n+        _ => false,\n+    };\n+\n+    if !should_lint {\n+        return;\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over references to containers instead of using explicit \\\n+         iteration methods\",\n+        \"to write this more concisely, try\",\n+        format!(\"&{}{}\", muta, object),\n+        applicability,\n+    )\n+}\n+\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n+/// for `&T` and `&mut T`, such as `Vec`.\n+#[rustfmt::skip]\n+fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n+    // will allow further borrows afterwards\n+    let ty = cx.typeck_results().expr_ty(e);\n+    is_iterable_array(ty, cx) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n+    match_type(cx, ty, &paths::BTREESET)\n+}\n+\n+fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n+    match ty.kind() {\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n+        _ => false,\n+    }\n+}"}, {"sha": "eb53c3179ca4a8b28cef930567a88f7e807d1555", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,70 @@\n+use super::FOR_KV_MAP;\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{is_type_diagnostic_item, match_type, multispan_sugg, paths, snippet, span_lint_and_then, sugg};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+/// Checks for the `FOR_KV_MAP` lint.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let pat_span = pat.span;\n+\n+    if let PatKind::Tuple(ref pat, _) = pat.kind {\n+        if pat.len() == 2 {\n+            let arg_span = arg.span;\n+            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n+                ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n+                    (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\", ty, mutbl),\n+                    (_, value) if pat_is_wild(cx, value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n+                    _ => return,\n+                },\n+                _ => return,\n+            };\n+            let mutbl = match mutbl {\n+                Mutability::Not => \"\",\n+                Mutability::Mut => \"_mut\",\n+            };\n+            let arg = match arg.kind {\n+                ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) => &**expr,\n+                _ => arg,\n+            };\n+\n+            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP) {\n+                span_lint_and_then(\n+                    cx,\n+                    FOR_KV_MAP,\n+                    expr.span,\n+                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n+                    |diag| {\n+                        let map = sugg::Sugg::hir(cx, arg, \"map\");\n+                        multispan_sugg(\n+                            diag,\n+                            \"use the corresponding method\",\n+                            vec![\n+                                (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n+                                (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),\n+                            ],\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n+fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n+    match *pat {\n+        PatKind::Wild => true,\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n+            !LocalUsedVisitor::new(cx, id).check_expr(body)\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "db22d90a304bcac0bf04a121ee818ee8ea422cab", "filename": "clippy_lints/src/loops/for_loops_over_fallibles.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,45 @@\n+use super::FOR_LOOPS_OVER_FALLIBLES;\n+use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_help};\n+use rustc_hir::{Expr, Pat};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+/// Checks for `for` loops over `Option`s and `Result`s.\n+pub(super) fn check(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(arg);\n+    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+        span_lint_and_help(\n+            cx,\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n+        span_lint_and_help(\n+            cx,\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    }\n+}"}, {"sha": "cf78bbc49a3623a3f2e5b5a569fc7d19cd3da161", "filename": "clippy_lints/src/loops/iter_next_loop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,19 @@\n+use super::ITER_NEXT_LOOP;\n+use crate::utils::{match_trait_method, paths, span_lint};\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, expr: &Expr<'_>) -> bool {\n+    if match_trait_method(cx, arg, &paths::ITERATOR) {\n+        span_lint(\n+            cx,\n+            ITER_NEXT_LOOP,\n+            expr.span,\n+            \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+            probably not what you want\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "3d3ae6f3152a3b9b183403ad4bbefc49acc1cb7e", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,79 @@\n+use super::utils::make_iterator_snippet;\n+use super::MANUAL_FLATTEN;\n+use crate::utils::{is_ok_ctor, is_some_ctor, path_to_local_id, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+/// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n+/// iterator element is used.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    span: Span,\n+) {\n+    if let ExprKind::Block(ref block, _) = body.kind {\n+        // Ensure the `if let` statement is the only expression or statement in the for-loop\n+        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n+            let match_stmt = &block.stmts[0];\n+            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n+                Some(inner_expr)\n+            } else {\n+                None\n+            }\n+        } else if block.stmts.is_empty() {\n+            block.expr\n+        } else {\n+            None\n+        };\n+\n+        if_chain! {\n+            if let Some(inner_expr) = inner_expr;\n+            if let ExprKind::Match(\n+                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+            ) = inner_expr.kind;\n+            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+            if path_to_local_id(match_expr, pat_hir_id);\n+            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_some_ctor(cx, path.res);\n+            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if some_ctor || ok_ctor;\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+\n+            then {\n+                // Prepare the error message\n+                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n+\n+                // Prepare the help message\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_FLATTEN,\n+                    span,\n+                    &msg,\n+                    |diag| {\n+                        let sugg = format!(\"{}.flatten()\", arg_snippet);\n+                        diag.span_suggestion(\n+                            arg.span,\n+                            \"try\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_help(\n+                            inner_expr.span,\n+                            \"...and remove the `if let` statement in the for loop\",\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "bf0b8cc24594c315f196e528ca88a15c88c8b439", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,451 @@\n+use super::{get_span_of_entire_for_loop, IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    get_enclosing_block, higher, is_type_diagnostic_item, path_to_local, snippet, span_lint_and_sugg, sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::walk_block;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Pat, PatKind, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n+use std::iter::Iterator;\n+\n+/// Checks for for loops that sequentially copy items from one slice-like\n+/// object to another.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> bool {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        end: Some(end),\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n+            let mut starts = vec![Start {\n+                id: canonical_id,\n+                kind: StartKind::Range,\n+            }];\n+\n+            // This is one of few ways to return different iterators\n+            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+            let mut iter_a = None;\n+            let mut iter_b = None;\n+\n+            if let ExprKind::Block(block, _) = body.kind {\n+                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n+                    starts.extend(loop_counters);\n+                }\n+                iter_a = Some(get_assignments(block, &starts));\n+            } else {\n+                iter_b = Some(get_assignment(body));\n+            }\n+\n+            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n+\n+            let big_sugg = assignments\n+                // The only statements in the for loops can be indexed assignments from\n+                // indexed retrievals (except increments of loop counters).\n+                .map(|o| {\n+                    o.and_then(|(lhs, rhs)| {\n+                        let rhs = fetch_cloned_expr(rhs);\n+                        if_chain! {\n+                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n+\n+                            // Source and destination must be different\n+                            if path_to_local(base_left) != path_to_local(base_right);\n+                            then {\n+                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    })\n+                })\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n+                .collect::<Option<Vec<_>>>()\n+                .filter(|v| !v.is_empty())\n+                .map(|v| v.join(\"\\n    \"));\n+\n+            if let Some(big_sugg) = big_sugg {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_MEMCPY,\n+                    get_span_of_entire_for_loop(expr),\n+                    \"it looks like you're manually copying between slices\",\n+                    \"try replacing the loop by\",\n+                    big_sugg,\n+                    Applicability::Unspecified,\n+                );\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn build_manual_memcpy_suggestion<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    start: &Expr<'_>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    dst: &IndexExpr<'_>,\n+    src: &IndexExpr<'_>,\n+) -> String {\n+    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        if offset.as_str() == \"0\" {\n+            sugg::EMPTY.into()\n+        } else {\n+            offset\n+        }\n+    }\n+\n+    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n+        if_chain! {\n+            if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n+            if method.ident.name == sym!(len);\n+            if len_args.len() == 1;\n+            if let Some(arg) = len_args.get(0);\n+            if path_to_local(arg) == path_to_local(base);\n+            then {\n+                if sugg.as_str() == end_str {\n+                    sugg::EMPTY.into()\n+                } else {\n+                    sugg\n+                }\n+            } else {\n+                match limits {\n+                    ast::RangeLimits::Closed => {\n+                        sugg + &sugg::ONE.into()\n+                    },\n+                    ast::RangeLimits::HalfOpen => sugg,\n+                }\n+            }\n+        }\n+    };\n+\n+    let start_str = Sugg::hir(cx, start, \"\").into();\n+    let end_str: MinifyingSugg<'_> = Sugg::hir(cx, end, \"\").into();\n+\n+    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n+        StartKind::Range => (\n+            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n+            print_limit(\n+                end,\n+                end_str.as_str(),\n+                idx_expr.base,\n+                apply_offset(&end_str, &idx_expr.idx_offset),\n+            )\n+            .into_sugg(),\n+        ),\n+        StartKind::Counter { initializer } => {\n+            let counter_start = Sugg::hir(cx, initializer, \"\").into();\n+            (\n+                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n+                print_limit(\n+                    end,\n+                    end_str.as_str(),\n+                    idx_expr.base,\n+                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n+                )\n+                .into_sugg(),\n+            )\n+        },\n+    };\n+\n+    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(&src);\n+\n+    let dst_base_str = snippet(cx, dst.base.span, \"???\");\n+    let src_base_str = snippet(cx, src.base.span, \"???\");\n+\n+    let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n+        dst_base_str\n+    } else {\n+        format!(\n+            \"{}[{}..{}]\",\n+            dst_base_str,\n+            dst_offset.maybe_par(),\n+            dst_limit.maybe_par()\n+        )\n+        .into()\n+    };\n+\n+    format!(\n+        \"{}.clone_from_slice(&{}[{}..{}]);\",\n+        dst,\n+        src_base_str,\n+        src_offset.maybe_par(),\n+        src_limit.maybe_par()\n+    )\n+}\n+\n+/// a wrapper of `Sugg`. Besides what `Sugg` do, this removes unnecessary `0`;\n+/// and also, it avoids subtracting a variable from the same one by replacing it with `0`.\n+/// it exists for the convenience of the overloaded operators while normal functions can do the\n+/// same.\n+#[derive(Clone)]\n+struct MinifyingSugg<'a>(Sugg<'a>);\n+\n+impl<'a> MinifyingSugg<'a> {\n+    fn as_str(&self) -> &str {\n+        let Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) = &self.0;\n+        s.as_ref()\n+    }\n+\n+    fn into_sugg(self) -> Sugg<'a> {\n+        self.0\n+    }\n+}\n+\n+impl<'a> From<Sugg<'a>> for MinifyingSugg<'a> {\n+    fn from(sugg: Sugg<'a>) -> Self {\n+        Self(sugg)\n+    }\n+}\n+\n+impl std::ops::Add for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self.clone(),\n+            (_, _) => (&self.0 + &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self.clone(),\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (&self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self,\n+            (_, _) => (self.0 + &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self,\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n+struct Offset {\n+    value: MinifyingSugg<'static>,\n+    sign: OffsetSign,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n+}\n+\n+impl Offset {\n+    fn negative(value: Sugg<'static>) -> Self {\n+        Self {\n+            value: value.into(),\n+            sign: OffsetSign::Negative,\n+        }\n+    }\n+\n+    fn positive(value: Sugg<'static>) -> Self {\n+        Self {\n+            value: value.into(),\n+            sign: OffsetSign::Positive,\n+        }\n+    }\n+\n+    fn empty() -> Self {\n+        Self::positive(sugg::ZERO)\n+    }\n+}\n+\n+fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n+    match rhs.sign {\n+        OffsetSign::Positive => lhs + &rhs.value,\n+        OffsetSign::Negative => lhs - &rhs.value,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum StartKind<'hir> {\n+    Range,\n+    Counter { initializer: &'hir Expr<'hir> },\n+}\n+\n+struct IndexExpr<'hir> {\n+    base: &'hir Expr<'hir>,\n+    idx: StartKind<'hir>,\n+    idx_offset: Offset,\n+}\n+\n+struct Start<'hir> {\n+    id: HirId,\n+    kind: StartKind<'hir>,\n+}\n+\n+fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n+    let is_slice = match ty.kind() {\n+        ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n+        ty::Slice(..) | ty::Array(..) => true,\n+        _ => false,\n+    };\n+\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+}\n+\n+fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n+        if method.ident.name == sym::clone;\n+        if args.len() == 1;\n+        if let Some(arg) = args.get(0);\n+        then { arg } else { expr }\n+    }\n+}\n+\n+fn get_details_from_idx<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    idx: &Expr<'_>,\n+    starts: &[Start<'tcx>],\n+) -> Option<(StartKind<'tcx>, Offset)> {\n+    fn get_start<'tcx>(e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n+        let id = path_to_local(e)?;\n+        starts.iter().find(|start| start.id == id).map(|start| start.kind)\n+    }\n+\n+    fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n+        match &e.kind {\n+            ExprKind::Lit(l) => match l.node {\n+                ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n+                _ => None,\n+            },\n+            ExprKind::Path(..) if get_start(e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n+            _ => None,\n+        }\n+    }\n+\n+    match idx.kind {\n+        ExprKind::Binary(op, lhs, rhs) => match op.node {\n+            BinOpKind::Add => {\n+                let offset_opt = get_start(lhs, starts)\n+                    .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n+                    .or_else(|| get_start(rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n+\n+                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n+            },\n+            BinOpKind::Sub => {\n+                get_start(lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n+            },\n+            _ => None,\n+        },\n+        ExprKind::Path(..) => get_start(idx, starts).map(|s| (s, Offset::empty())),\n+        _ => None,\n+    }\n+}\n+\n+fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Get assignments from the given block.\n+/// The returned iterator yields `None` if no assignment expressions are there,\n+/// filtering out the increments of the given whitelisted loop counters;\n+/// because its job is to make sure there's nothing other than assignments and the increments.\n+fn get_assignments<'a, 'tcx>(\n+    Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n+    loop_counters: &'a [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'a {\n+    // As the `filter` and `map` below do different things, I think putting together\n+    // just increases complexity. (cc #3188 and #4193)\n+    stmts\n+        .iter()\n+        .filter_map(move |stmt| match stmt.kind {\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+        })\n+        .chain((*expr).into_iter())\n+        .filter(move |e| {\n+            if let ExprKind::AssignOp(_, place, _) = e.kind {\n+                path_to_local(place).map_or(false, |id| {\n+                    !loop_counters\n+                        .iter()\n+                        // skip the first item which should be `StartKind::Range`\n+                        // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n+                        .skip(1)\n+                        .any(|counter| counter.id == id)\n+                })\n+            } else {\n+                true\n+            }\n+        })\n+        .map(get_assignment)\n+}\n+\n+fn get_loop_counters<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    body: &'tcx Block<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_block(&mut increment_visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+        increment_visitor\n+            .into_results()\n+            .filter_map(move |var_id| {\n+                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n+                walk_block(&mut initialize_visitor, block);\n+\n+                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                    id: var_id,\n+                    kind: StartKind::Counter { initializer },\n+                })\n+            })\n+            .into()\n+    })\n+}"}, {"sha": "2a372c6307eabfa6417b7af4368c12708d5bb22f", "filename": "clippy_lints/src/loops/mod.rs", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,627 @@\n+mod empty_loop;\n+mod explicit_counter_loop;\n+mod explicit_into_iter_loop;\n+mod explicit_iter_loop;\n+mod for_kv_map;\n+mod for_loops_over_fallibles;\n+mod iter_next_loop;\n+mod manual_flatten;\n+mod manual_memcpy;\n+mod mut_range_bound;\n+mod needless_collect;\n+mod needless_range_loop;\n+mod never_loop;\n+mod same_item_push;\n+mod single_element_loop;\n+mod utils;\n+mod while_immutable_condition;\n+mod while_let_loop;\n+mod while_let_on_iterator;\n+\n+use crate::utils::higher;\n+use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for for-loops that manually copy items between\n+    /// slices that could be optimized by having a memcpy.\n+    ///\n+    /// **Why is this bad?** It is not as fast as a memcpy.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let src = vec![1];\n+    /// # let mut dst = vec![0; 65];\n+    /// for i in 0..src.len() {\n+    ///     dst[i + 64] = src[i];\n+    /// }\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// # let src = vec![1];\n+    /// # let mut dst = vec![0; 65];\n+    /// dst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n+    /// ```\n+    pub MANUAL_MEMCPY,\n+    perf,\n+    \"manually copying items between slices\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for looping over the range of `0..len` of some\n+    /// collection just to get the values by index.\n+    ///\n+    /// **Why is this bad?** Just iterating the collection itself makes the intent\n+    /// more clear and is probably faster.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// for i in 0..vec.len() {\n+    ///     println!(\"{}\", vec[i]);\n+    /// }\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// for i in vec {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RANGE_LOOP,\n+    style,\n+    \"for-looping over a range of indices where an iterator over items would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** False negatives. We currently only warn on some known\n+    /// types.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // with `y` a `Vec` or slice:\n+    /// # let y = vec![1];\n+    /// for x in y.iter() {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// # let y = vec![1];\n+    /// for x in &y {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub EXPLICIT_ITER_LOOP,\n+    pedantic,\n+    \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `y.into_iter()` where `y` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let y = vec![1];\n+    /// // with `y` a `Vec` or slice:\n+    /// for x in y.into_iter() {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// # let y = vec![1];\n+    /// for x in y {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub EXPLICIT_INTO_ITER_LOOP,\n+    pedantic,\n+    \"for-looping over `_.into_iter()` when `_` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.next()`.\n+    ///\n+    /// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n+    /// value, or `None` otherwise. The insidious thing is that `Option<_>`\n+    /// implements `IntoIterator`, so that possibly one value will be iterated,\n+    /// leading to some hard to find bugs. No one will want to write such code\n+    /// [except to win an Underhanded Rust\n+    /// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in y.next() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub ITER_NEXT_LOOP,\n+    correctness,\n+    \"for-looping over `_.next()` which is probably not intended\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `for` loops over `Option` or `Result` values.\n+    ///\n+    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+    /// let`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let opt = Some(1);\n+    ///\n+    /// // Bad\n+    /// for x in opt {\n+    ///     // ..\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Some(x) = opt {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    ///\n+    /// // or\n+    ///\n+    /// ```rust\n+    /// # let res: Result<i32, std::io::Error> = Ok(1);\n+    ///\n+    /// // Bad\n+    /// for x in &res {\n+    ///     // ..\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Ok(x) = res {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub FOR_LOOPS_OVER_FALLIBLES,\n+    correctness,\n+    \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects `loop + match` combinations that are easier\n+    /// written as a `while let` loop.\n+    ///\n+    /// **Why is this bad?** The `while let` loop is usually shorter and more\n+    /// readable.\n+    ///\n+    /// **Known problems:** Sometimes the wrong binding is displayed ([#383](https://github.com/rust-lang/rust-clippy/issues/383)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// # let y = Some(1);\n+    /// loop {\n+    ///     let x = match y {\n+    ///         Some(x) => x,\n+    ///         None => break,\n+    ///     };\n+    ///     // .. do something with x\n+    /// }\n+    /// // is easier written as\n+    /// while let Some(x) = y {\n+    ///     // .. do something with x\n+    /// };\n+    /// ```\n+    pub WHILE_LET_LOOP,\n+    complexity,\n+    \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions collecting an iterator when collect\n+    /// is not needed.\n+    ///\n+    /// **Why is this bad?** `collect` causes the allocation of a new data structure,\n+    /// when this allocation may not be needed.\n+    ///\n+    /// **Known problems:**\n+    /// None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let iterator = vec![1].into_iter();\n+    /// let len = iterator.clone().collect::<Vec<_>>().len();\n+    /// // should be\n+    /// let len = iterator.count();\n+    /// ```\n+    pub NEEDLESS_COLLECT,\n+    perf,\n+    \"collecting an iterator when collect is not needed\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks `for` loops over slices with an explicit counter\n+    /// and suggests the use of `.enumerate()`.\n+    ///\n+    /// **Why is it bad?** Using `.enumerate()` makes the intent more clear,\n+    /// declutters the code and may be faster in some instances.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let v = vec![1];\n+    /// # fn bar(bar: usize, baz: usize) {}\n+    /// let mut i = 0;\n+    /// for item in &v {\n+    ///     bar(i, *item);\n+    ///     i += 1;\n+    /// }\n+    /// ```\n+    /// Could be written as\n+    /// ```rust\n+    /// # let v = vec![1];\n+    /// # fn bar(bar: usize, baz: usize) {}\n+    /// for (i, item) in v.iter().enumerate() { bar(i, *item); }\n+    /// ```\n+    pub EXPLICIT_COUNTER_LOOP,\n+    complexity,\n+    \"for-looping with an explicit counter when `_.enumerate()` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for empty `loop` expressions.\n+    ///\n+    /// **Why is this bad?** These busy loops burn CPU cycles without doing\n+    /// anything. It is _almost always_ a better idea to `panic!` than to have\n+    /// a busy loop.\n+    ///\n+    /// If panicking isn't possible, think of the environment and either:\n+    ///   - block on something\n+    ///   - sleep the thread for some microseconds\n+    ///   - yield or pause the thread\n+    ///\n+    /// For `std` targets, this can be done with\n+    /// [`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n+    /// or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n+    ///\n+    /// For `no_std` targets, doing this is more complicated, especially because\n+    /// `#[panic_handler]`s can't panic. To stop/pause the thread, you will\n+    /// probably need to invoke some target-specific intrinsic. Examples include:\n+    ///   - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n+    ///   - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// loop {}\n+    /// ```\n+    pub EMPTY_LOOP,\n+    style,\n+    \"empty `loop {}`, which should block or sleep\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `while let` expressions on iterators.\n+    ///\n+    /// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n+    /// the intent better.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// while let Some(val) = iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub WHILE_LET_ON_ITERATOR,\n+    style,\n+    \"using a `while let` loop instead of a for loop on an iterator\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+    /// ignoring either the keys or values.\n+    ///\n+    /// **Why is this bad?** Readability. There are `keys` and `values` methods that\n+    /// can be used to express that don't need the values or keys.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for (k, _) in &map {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// could be replaced by\n+    ///\n+    /// ```ignore\n+    /// for k in map.keys() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub FOR_KV_MAP,\n+    style,\n+    \"looping on a map using `iter` when `keys` or `values` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops that will always `break`, `return` or\n+    /// `continue` an outer loop.\n+    ///\n+    /// **Why is this bad?** This loop never loops, all it does is obfuscating the\n+    /// code.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {\n+    ///     ..;\n+    ///     break;\n+    /// }\n+    /// ```\n+    pub NEVER_LOOP,\n+    correctness,\n+    \"any loop that will always `break` or `return`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops which have a range bound that is a mutable variable\n+    ///\n+    /// **Why is this bad?** One might think that modifying the mutable variable changes the loop bounds\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut foo = 42;\n+    /// for i in 0..foo {\n+    ///     foo -= 1;\n+    ///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n+    /// }\n+    /// ```\n+    pub MUT_RANGE_BOUND,\n+    complexity,\n+    \"for loop over a range where one of the bounds is a mutable variable\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether variables used within while loop condition\n+    /// can be (and are) mutated in the body.\n+    ///\n+    /// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n+    /// will lead to an infinite loop.\n+    ///\n+    /// **Known problems:** If the `while`-loop is in a closure, the check for mutation of the\n+    /// condition variables in the body can cause false negatives. For example when only `Upvar` `a` is\n+    /// in the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 0;\n+    /// while i > 10 {\n+    ///     println!(\"let me loop forever!\");\n+    /// }\n+    /// ```\n+    pub WHILE_IMMUTABLE_CONDITION,\n+    correctness,\n+    \"variables used within while expression are not mutated in the body\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop is being used to push a constant\n+    /// value into a Vec.\n+    ///\n+    /// **Why is this bad?** This kind of operation can be expressed more succinctly with\n+    /// `vec![item;SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\n+    /// have better performance.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = Vec::new();\n+    /// for _ in 0..20 {\n+    ///    vec.push(item1);\n+    /// }\n+    /// for _ in 0..30 {\n+    ///     vec.push(item2);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = vec![item1; 20];\n+    /// vec.resize(20 + 30, item2);\n+    /// ```\n+    pub SAME_ITEM_PUSH,\n+    style,\n+    \"the same item is pushed inside of a for loop\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop has a single element.\n+    ///\n+    /// **Why is this bad?** There is no reason to have a loop of a\n+    /// single element.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// for item in &[item1] {\n+    ///     println!(\"{}\", item);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item = &item1;\n+    /// println!(\"{}\", item);\n+    /// ```\n+    pub SINGLE_ELEMENT_LOOP,\n+    complexity,\n+    \"there is no reason to have a single element loop\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Check for unnecessary `if let` usage in a for loop\n+    /// where only the `Some` or `Ok` variant of the iterator element is used.\n+    ///\n+    /// **Why is this bad?** It is verbose and can be simplified\n+    /// by first calling the `flatten` method on the `Iterator`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = vec![Some(1), Some(2), Some(3)];\n+    /// for n in x {\n+    ///     if let Some(n) = n {\n+    ///         println!(\"{}\", n);\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = vec![Some(1), Some(2), Some(3)];\n+    /// for n in x.into_iter().flatten() {\n+    ///     println!(\"{}\", n);\n+    /// }\n+    /// ```\n+    pub MANUAL_FLATTEN,\n+    complexity,\n+    \"for loops over `Option`s or `Result`s with a single expression can be simplified\"\n+}\n+\n+declare_lint_pass!(Loops => [\n+    MANUAL_MEMCPY,\n+    MANUAL_FLATTEN,\n+    NEEDLESS_RANGE_LOOP,\n+    EXPLICIT_ITER_LOOP,\n+    EXPLICIT_INTO_ITER_LOOP,\n+    ITER_NEXT_LOOP,\n+    FOR_LOOPS_OVER_FALLIBLES,\n+    WHILE_LET_LOOP,\n+    NEEDLESS_COLLECT,\n+    EXPLICIT_COUNTER_LOOP,\n+    EMPTY_LOOP,\n+    WHILE_LET_ON_ITERATOR,\n+    FOR_KV_MAP,\n+    NEVER_LOOP,\n+    MUT_RANGE_BOUND,\n+    WHILE_IMMUTABLE_CONDITION,\n+    SAME_ITEM_PUSH,\n+    SINGLE_ELEMENT_LOOP,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Loops {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n+            // we don't want to check expanded macros\n+            // this check is not at the top of the function\n+            // since higher::for_loop expressions are marked as expansions\n+            if body.span.from_expansion() {\n+                return;\n+            }\n+            check_for_loop(cx, pat, arg, body, expr, span);\n+        }\n+\n+        // we don't want to check expanded macros\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        // check for never_loop\n+        never_loop::check(cx, expr);\n+\n+        // check for `loop { if let {} else break }` that could be `while let`\n+        // (also matches an explicit \"match\" instead of \"if let\")\n+        // (even if the \"match\" or \"if let\" is used for declaration)\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n+            // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n+            empty_loop::check(cx, expr, block);\n+            while_let_loop::check(cx, expr, block);\n+        }\n+\n+        while_let_on_iterator::check(cx, expr);\n+\n+        if let Some((cond, body)) = higher::while_loop(&expr) {\n+            while_immutable_condition::check(cx, cond, body);\n+        }\n+\n+        needless_collect::check(expr, cx);\n+    }\n+}\n+\n+fn check_for_loop<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+    span: Span,\n+) {\n+    let is_manual_memcpy_triggered = manual_memcpy::check(cx, pat, arg, body, expr);\n+    if !is_manual_memcpy_triggered {\n+        needless_range_loop::check(cx, pat, arg, body, expr);\n+        explicit_counter_loop::check(cx, pat, arg, body, expr);\n+    }\n+    check_for_loop_arg(cx, pat, arg, expr);\n+    for_kv_map::check(cx, pat, arg, body, expr);\n+    mut_range_bound::check(cx, arg, body);\n+    single_element_loop::check(cx, pat, arg, body, expr);\n+    same_item_push::check(cx, pat, arg, body, expr);\n+    manual_flatten::check(cx, pat, arg, body, span);\n+}\n+\n+fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n+    let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n+\n+    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n+        // just the receiver, no arguments\n+        if args.len() == 1 {\n+            let method_name = &*method.ident.as_str();\n+            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n+            match method_name {\n+                \"iter\" | \"iter_mut\" => explicit_iter_loop::check(cx, args, arg, method_name),\n+                \"into_iter\" => {\n+                    explicit_iter_loop::check(cx, args, arg, method_name);\n+                    explicit_into_iter_loop::check(cx, args, arg);\n+                },\n+                \"next\" => {\n+                    next_loop_linted = iter_next_loop::check(cx, arg, expr);\n+                },\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    if !next_loop_linted {\n+        for_loops_over_fallibles::check(cx, pat, arg);\n+    }\n+}"}, {"sha": "3ae592950f13b63163efd3a3a09252b77bbe8530", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,115 @@\n+use super::MUT_RANGE_BOUND;\n+use crate::utils::{higher, path_to_local, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir::{BindingAnnotation, Expr, HirId, Node, PatKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+\n+pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        end: Some(end),\n+        ..\n+    }) = higher::range(arg)\n+    {\n+        let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n+        if mut_ids[0].is_some() || mut_ids[1].is_some() {\n+            let (span_low, span_high) = check_for_mutation(cx, body, &mut_ids);\n+            mut_warn_with_span(cx, span_low);\n+            mut_warn_with_span(cx, span_high);\n+        }\n+    }\n+}\n+\n+fn mut_warn_with_span(cx: &LateContext<'_>, span: Option<Span>) {\n+    if let Some(sp) = span {\n+        span_lint(\n+            cx,\n+            MUT_RANGE_BOUND,\n+            sp,\n+            \"attempt to mutate range bound within loop; note that the range of the loop is unchanged\",\n+        );\n+    }\n+}\n+\n+fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId> {\n+    if_chain! {\n+        if let Some(hir_id) = path_to_local(bound);\n+        if let Node::Binding(pat) = cx.tcx.hir().get(hir_id);\n+        if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n+        then {\n+            return Some(hir_id);\n+        }\n+    }\n+    None\n+}\n+\n+fn check_for_mutation<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    body: &Expr<'_>,\n+    bound_ids: &[Option<HirId>],\n+) -> (Option<Span>, Option<Span>) {\n+    let mut delegate = MutatePairDelegate {\n+        cx,\n+        hir_id_low: bound_ids[0],\n+        hir_id_high: bound_ids[1],\n+        span_low: None,\n+        span_high: None,\n+    };\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            body.hir_id.owner,\n+            cx.param_env,\n+            cx.typeck_results(),\n+        )\n+        .walk_expr(body);\n+    });\n+    delegate.mutation_span()\n+}\n+\n+struct MutatePairDelegate<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    hir_id_low: Option<HirId>,\n+    hir_id_high: Option<HirId>,\n+    span_low: Option<Span>,\n+    span_high: Option<Span>,\n+}\n+\n+impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId, bk: ty::BorrowKind) {\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            if let PlaceBase::Local(id) = cmt.place.base {\n+                if Some(id) == self.hir_id_low {\n+                    self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                }\n+                if Some(id) == self.hir_id_high {\n+                    self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n+            if Some(id) == self.hir_id_low {\n+                self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id))\n+            }\n+            if Some(id) == self.hir_id_high {\n+                self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id))\n+            }\n+        }\n+    }\n+}\n+\n+impl MutatePairDelegate<'_, '_> {\n+    fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n+        (self.span_low, self.span_high)\n+    }\n+}"}, {"sha": "6f27130910550e589e1f7bc44902aee7064dc766", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,283 @@\n+use super::NEEDLESS_COLLECT;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, match_type, path_to_local_id, paths, snippet, span_lint_and_sugg,\n+    span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Expr, ExprKind, GenericArg, HirId, Local, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::{sym, Ident};\n+\n+const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n+\n+pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    check_needless_collect_direct_usage(expr, cx);\n+    check_needless_collect_indirect_usage(expr, cx);\n+}\n+fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n+        if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n+        if let Some(ref generic_args) = chain_method.args;\n+        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+        then {\n+            let ty = cx.typeck_results().node_type(ty.hir_id);\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                match_type(cx, ty, &paths::BTREEMAP) ||\n+                is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n+                if method.ident.name == sym!(len) {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        \"count()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if method.ident.name == sym!(is_empty) {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        \"next().is_none()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if method.ident.name == sym!(contains) {\n+                    let contains_arg = snippet(cx, args[1].span, \"??\");\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let (arg, pred) = contains_arg\n+                                    .strip_prefix('&')\n+                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n+                            diag.span_suggestion(\n+                                span,\n+                                \"replace with\",\n+                                format!(\n+                                    \"any(|{}| x == {})\",\n+                                    arg, pred\n+                                ),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    let mut used_count_visitor = UsedCountVisitor {\n+                        cx,\n+                        id: *pat_id,\n+                        count: 0,\n+                    };\n+                    walk_block(&mut used_count_visitor, block);\n+                    if used_count_visitor.count > 1 {\n+                        return;\n+                    }\n+\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n+                    span_lint_and_then(\n+                        cx,\n+                        super::NEEDLESS_COLLECT,\n+                        stmt.span.until(iter_call.span),\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            diag.multipart_suggestion(\n+                                iter_call.get_suggestion_text(),\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_call.span, iter_replacement)\n+                                ],\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => {\n+                let s = snippet(cx, *span, \"..\");\n+                if let Some(stripped) = s.strip_prefix('&') {\n+                    format!(\".any(|x| x == {})\", stripped)\n+                } else {\n+                    format!(\".any(|x| x == *{})\", s)\n+                }\n+            },\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => {\n+                \"use the original Iterator instead of collecting it and then producing a new one\"\n+            },\n+            IterFunctionKind::Len => {\n+                \"take the original Iterator's count instead of collecting it and finding the length\"\n+            },\n+            IterFunctionKind::IsEmpty => {\n+                \"check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n+            },\n+            IterFunctionKind::Contains(_) => {\n+                \"check if the original Iterator contains an element instead of collecting then checking\"\n+            },\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n+    seen_other: bool,\n+    target: Ident,\n+}\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        // Check function calls on our collection\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    sym::into_iter => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n+                    ),\n+                    name if name == len => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n+                    ),\n+                    name if name == is_empty => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n+                    ),\n+                    name if name == contains => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n+                    ),\n+                    _ => self.seen_other = true,\n+                }\n+                return\n+            }\n+        }\n+        // Check if the collection is used for anything else\n+        if_chain! {\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                self.seen_other = true;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct UsedCountVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    id: HirId,\n+    count: usize,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if path_to_local_id(expr, self.id) {\n+            self.count += 1;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+/// Detect the occurrences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n+        target: identifier,\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other { None } else { Some(visitor.uses) }\n+}\n+\n+fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n+    if_chain! {\n+        if let ExprKind::MethodCall(.., args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(_, span, ..) = &args[0].kind;\n+        then {\n+            return expr.span.with_lo(span.lo());\n+        }\n+    }\n+    unreachable!();\n+}"}, {"sha": "5f02e4b9d875dd907844c962459487fb500dfa65", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,391 @@\n+use super::NEEDLESS_RANGE_LOOP;\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{\n+    contains_name, has_iter_method, higher, is_integer_const, match_trait_method, multispan_sugg, path_to_local_id,\n+    paths, snippet, span_lint_and_then, sugg, SpanlessEq,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::middle::region;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Symbol};\n+use std::iter::Iterator;\n+use std::mem;\n+\n+/// Checks for looping over a range and then indexing a sequence with it.\n+/// The iteratee must be a range literal.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n+            let mut visitor = VarVisitor {\n+                cx,\n+                var: canonical_id,\n+                indexed_mut: FxHashSet::default(),\n+                indexed_indirectly: FxHashMap::default(),\n+                indexed_directly: FxHashMap::default(),\n+                referenced: FxHashSet::default(),\n+                nonindex: false,\n+                prefer_mutable: false,\n+            };\n+            walk_expr(&mut visitor, body);\n+\n+            // linting condition: we only indexed one variable, and indexed it directly\n+            if visitor.indexed_indirectly.is_empty() && visitor.indexed_directly.len() == 1 {\n+                let (indexed, (indexed_extent, indexed_ty)) = visitor\n+                    .indexed_directly\n+                    .into_iter()\n+                    .next()\n+                    .expect(\"already checked that we have exactly 1 element\");\n+\n+                // ensure that the indexed variable was declared before the loop, see #601\n+                if let Some(indexed_extent) = indexed_extent {\n+                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n+                    let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n+                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n+                    if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n+                        return;\n+                    }\n+                }\n+\n+                // don't lint if the container that is indexed does not have .iter() method\n+                let has_iter = has_iter_method(cx, indexed_ty);\n+                if has_iter.is_none() {\n+                    return;\n+                }\n+\n+                // don't lint if the container that is indexed into is also used without\n+                // indexing\n+                if visitor.referenced.contains(&indexed) {\n+                    return;\n+                }\n+\n+                let starts_at_zero = is_integer_const(cx, start, 0);\n+\n+                let skip = if starts_at_zero {\n+                    String::new()\n+                } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, start) {\n+                    return;\n+                } else {\n+                    format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n+                };\n+\n+                let mut end_is_start_plus_val = false;\n+\n+                let take = if let Some(end) = *end {\n+                    let mut take_expr = end;\n+\n+                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n+                        if let BinOpKind::Add = op.node {\n+                            let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n+                            let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n+\n+                            if start_equal_left {\n+                                take_expr = right;\n+                            } else if start_equal_right {\n+                                take_expr = left;\n+                            }\n+\n+                            end_is_start_plus_val = start_equal_left | start_equal_right;\n+                        }\n+                    }\n+\n+                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n+                        String::new()\n+                    } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, take_expr) {\n+                        return;\n+                    } else {\n+                        match limits {\n+                            ast::RangeLimits::Closed => {\n+                                let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n+                                format!(\".take({})\", take_expr + sugg::ONE)\n+                            },\n+                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n+                        }\n+                    }\n+                } else {\n+                    String::new()\n+                };\n+\n+                let (ref_mut, method) = if visitor.indexed_mut.contains(&indexed) {\n+                    (\"mut \", \"iter_mut\")\n+                } else {\n+                    (\"\", \"iter\")\n+                };\n+\n+                let take_is_empty = take.is_empty();\n+                let mut method_1 = take;\n+                let mut method_2 = skip;\n+\n+                if end_is_start_plus_val {\n+                    mem::swap(&mut method_1, &mut method_2);\n+                }\n+\n+                if visitor.nonindex {\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n+                        |diag| {\n+                            multispan_sugg(\n+                                diag,\n+                                \"consider using an iterator\",\n+                                vec![\n+                                    (pat.span, format!(\"({}, <item>)\", ident.name)),\n+                                    (\n+                                        arg.span,\n+                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                    ),\n+                                ],\n+                            );\n+                        },\n+                    );\n+                } else {\n+                    let repl = if starts_at_zero && take_is_empty {\n+                        format!(\"&{}{}\", ref_mut, indexed)\n+                    } else {\n+                        format!(\"{}.{}(){}{}\", indexed, method, method_1, method_2)\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n+                        |diag| {\n+                            multispan_sugg(\n+                                diag,\n+                                \"consider using an iterator\",\n+                                vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n+                            );\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n+        if len_args.len() == 1;\n+        if method.ident.name == sym!(len);\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n+        if path.segments.len() == 1;\n+        if path.segments[0].ident.name == var;\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn is_end_eq_array_len<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    indexed_ty: Ty<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = end.kind;\n+        if let ast::LitKind::Int(end_int, _) = lit.node;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n+        if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n+        then {\n+            return match limits {\n+                ast::RangeLimits::Closed => end_int + 1 >= arr_len.into(),\n+                ast::RangeLimits::HalfOpen => end_int >= arr_len.into(),\n+            };\n+        }\n+    }\n+\n+    false\n+}\n+\n+struct VarVisitor<'a, 'tcx> {\n+    /// context reference\n+    cx: &'a LateContext<'tcx>,\n+    /// var name to look for as index\n+    var: HirId,\n+    /// indexed variables that are used mutably\n+    indexed_mut: FxHashSet<Symbol>,\n+    /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n+    indexed_indirectly: FxHashMap<Symbol, Option<region::Scope>>,\n+    /// subset of `indexed` of vars that are indexed directly: `v[i]`\n+    /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n+    indexed_directly: FxHashMap<Symbol, (Option<region::Scope>, Ty<'tcx>)>,\n+    /// Any names that are used outside an index operation.\n+    /// Used to detect things like `&mut vec` used together with `vec[i]`\n+    referenced: FxHashSet<Symbol>,\n+    /// has the loop variable been used in expressions other than the index of\n+    /// an index op?\n+    nonindex: bool,\n+    /// Whether we are inside the `$` in `&mut $` or `$ = foo` or `$.bar`, where bar\n+    /// takes `&mut self`\n+    prefer_mutable: bool,\n+}\n+\n+impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n+    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+        if_chain! {\n+            // the indexed container is referenced by a name\n+            if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n+            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n+            if seqvar.segments.len() == 1;\n+            then {\n+                let index_used_directly = path_to_local_id(idx, self.var);\n+                let indexed_indirectly = {\n+                    let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n+                    walk_expr(&mut used_visitor, idx);\n+                    used_visitor.used\n+                };\n+\n+                if indexed_indirectly || index_used_directly {\n+                    if self.prefer_mutable {\n+                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                    }\n+                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n+                    match res {\n+                        Res::Local(hir_id) => {\n+                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                            if indexed_indirectly {\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                            }\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                                );\n+                            }\n+                            return false;  // no need to walk further *on the variable*\n+                        }\n+                        Res::Def(DefKind::Static | DefKind::Const, ..) => {\n+                            if indexed_indirectly {\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n+                            }\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                                );\n+                            }\n+                            return false;  // no need to walk further *on the variable*\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+        }\n+        true\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // a range index op\n+            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n+            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if !self.check(&args[1], &args[0], expr);\n+            then { return }\n+        }\n+\n+        if_chain! {\n+            // an index op\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n+            if !self.check(idx, seqexpr, expr);\n+            then { return }\n+        }\n+\n+        if_chain! {\n+            // directly using a variable\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind;\n+            if let Res::Local(local_id) = path.res;\n+            then {\n+                if local_id == self.var {\n+                    self.nonindex = true;\n+                } else {\n+                    // not the correct variable, but still a variable\n+                    self.referenced.insert(path.segments[0].ident.name);\n+                }\n+            }\n+        }\n+\n+        let old = self.prefer_mutable;\n+        match expr.kind {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                self.prefer_mutable = true;\n+                self.visit_expr(lhs);\n+                self.prefer_mutable = false;\n+                self.visit_expr(rhs);\n+            },\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, ref expr) => {\n+                if mutbl == Mutability::Mut {\n+                    self.prefer_mutable = true;\n+                }\n+                self.visit_expr(expr);\n+            },\n+            ExprKind::Call(ref f, args) => {\n+                self.visit_expr(f);\n+                for expr in args {\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n+                    self.prefer_mutable = false;\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n+                        if mutbl == Mutability::Mut {\n+                            self.prefer_mutable = true;\n+                        }\n+                    }\n+                    self.visit_expr(expr);\n+                }\n+            },\n+            ExprKind::MethodCall(_, _, args, _) => {\n+                let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n+                for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n+                    self.prefer_mutable = false;\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n+                        if mutbl == Mutability::Mut {\n+                            self.prefer_mutable = true;\n+                        }\n+                    }\n+                    self.visit_expr(expr);\n+                }\n+            },\n+            ExprKind::Closure(_, _, body_id, ..) => {\n+                let body = self.cx.tcx.hir().body(body_id);\n+                self.visit_expr(&body.value);\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+        self.prefer_mutable = old;\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "45e1001d755550399697dcaa064dcb0b5a5d60a8", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,172 @@\n+use super::NEVER_LOOP;\n+use crate::utils::span_lint;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use std::iter::{once, Iterator};\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n+        match never_loop_block(block, expr.hir_id) {\n+            NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n+            NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n+        }\n+    }\n+}\n+\n+enum NeverLoopResult {\n+    // A break/return always get triggered but not necessarily for the main loop.\n+    AlwaysBreak,\n+    // A continue may occur for the main loop.\n+    MayContinueMainLoop,\n+    Otherwise,\n+}\n+\n+#[must_use]\n+fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n+    match *arg {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n+        NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n+    }\n+}\n+\n+// Combine two results for parts that are called in order.\n+#[must_use]\n+fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResult {\n+    match first {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::MayContinueMainLoop => first,\n+        NeverLoopResult::Otherwise => second,\n+    }\n+}\n+\n+// Combine two results where both parts are called but not necessarily in order.\n+#[must_use]\n+fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n+    match (left, right) {\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+// Combine two results where only one of the part may have been executed.\n+#[must_use]\n+fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n+    match (b1, b2) {\n+        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+    let stmts = block.stmts.iter().map(stmt_to_expr);\n+    let expr = once(block.expr.as_deref());\n+    let mut iter = stmts.chain(expr).flatten();\n+    never_loop_expr_seq(&mut iter, main_loop_id)\n+}\n+\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::Otherwise, combine_seq)\n+}\n+\n+fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    match stmt.kind {\n+        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n+        StmtKind::Local(ref local) => local.init.as_deref(),\n+        _ => None,\n+    }\n+}\n+\n+fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+    match expr.kind {\n+        ExprKind::Box(ref e)\n+        | ExprKind::Unary(_, ref e)\n+        | ExprKind::Cast(ref e, _)\n+        | ExprKind::Type(ref e, _)\n+        | ExprKind::Field(ref e, _)\n+        | ExprKind::AddrOf(_, _, ref e)\n+        | ExprKind::Struct(_, _, Some(ref e))\n+        | ExprKind::Repeat(ref e, _)\n+        | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n+            never_loop_expr_all(&mut es.iter(), main_loop_id)\n+        },\n+        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2)\n+        | ExprKind::Assign(ref e1, ref e2, _)\n+        | ExprKind::AssignOp(_, ref e1, ref e2)\n+        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::Loop(ref b, _, _, _) => {\n+            // Break can come from the inner loop so remove them.\n+            absorb_break(&never_loop_block(b, main_loop_id))\n+        },\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n+            let e1 = never_loop_expr(e, main_loop_id);\n+            let e2 = never_loop_expr(e2, main_loop_id);\n+            let e3 = e3\n+                .as_ref()\n+                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            combine_seq(e1, combine_branches(e2, e3))\n+        },\n+        ExprKind::Match(ref e, ref arms, _) => {\n+            let e = never_loop_expr(e, main_loop_id);\n+            if arms.is_empty() {\n+                e\n+            } else {\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), main_loop_id);\n+                combine_seq(e, arms)\n+            }\n+        },\n+        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Continue(d) => {\n+            let id = d\n+                .target_id\n+                .expect(\"target ID can only be missing in the presence of compilation errors\");\n+            if id == main_loop_id {\n+                NeverLoopResult::MayContinueMainLoop\n+            } else {\n+                NeverLoopResult::AlwaysBreak\n+            }\n+        },\n+        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+        }),\n+        ExprKind::InlineAsm(ref asm) => asm\n+            .operands\n+            .iter()\n+            .map(|(o, _)| match o {\n+                InlineAsmOperand::In { expr, .. }\n+                | InlineAsmOperand::InOut { expr, .. }\n+                | InlineAsmOperand::Const { expr }\n+                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                    never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n+                },\n+            })\n+            .fold(NeverLoopResult::Otherwise, combine_both),\n+        ExprKind::Struct(_, _, None)\n+        | ExprKind::Yield(_, _)\n+        | ExprKind::Closure(_, _, _, _, _)\n+        | ExprKind::LlvmInlineAsm(_)\n+        | ExprKind::Path(_)\n+        | ExprKind::ConstBlock(_)\n+        | ExprKind::Lit(_)\n+        | ExprKind::Err => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::Otherwise, combine_both)\n+}\n+\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n+}"}, {"sha": "f3585830e4ae3189651ff15f0d11aef5c2405ee5", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,169 @@\n+use super::SAME_ITEM_PUSH;\n+use crate::utils::{implements_trait, is_type_diagnostic_item, snippet_with_macro_callsite, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::symbol::sym;\n+use std::iter::Iterator;\n+\n+/// Detects for loop pushing the same item into a Vec\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    _: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    _: &'tcx Expr<'_>,\n+) {\n+    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>) {\n+        let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+        let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+\n+        span_lint_and_help(\n+            cx,\n+            SAME_ITEM_PUSH,\n+            vec.span,\n+            \"it looks like the same item is being pushed into this Vec\",\n+            None,\n+            &format!(\n+                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                item_str, vec_str, item_str\n+            ),\n+        )\n+    }\n+\n+    if !matches!(pat.kind, PatKind::Wild) {\n+        return;\n+    }\n+\n+    // Determine whether it is safe to lint the body\n+    let mut same_item_push_visitor = SameItemPushVisitor {\n+        should_lint: true,\n+        vec_push: None,\n+        cx,\n+    };\n+    walk_expr(&mut same_item_push_visitor, body);\n+    if same_item_push_visitor.should_lint {\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n+            let vec_ty = cx.typeck_results().expr_ty(vec);\n+            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+            if cx\n+                .tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+            {\n+                // Make sure that the push does not involve possibly mutating values\n+                match pushed_item.kind {\n+                    ExprKind::Path(ref qpath) => {\n+                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n+                            // immutable bindings that are initialized with literal or constant\n+                            Res::Local(hir_id) => {\n+                                if_chain! {\n+                                    let node = cx.tcx.hir().get(hir_id);\n+                                    if let Node::Binding(pat) = node;\n+                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                    if let Some(init) = parent_let_expr.init;\n+                                    then {\n+                                        match init.kind {\n+                                            // immutable bindings that are initialized with literal\n+                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                            // immutable bindings that are initialized with constant\n+                                            ExprKind::Path(ref path) => {\n+                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n+                                                    emit_lint(cx, vec, pushed_item);\n+                                                }\n+                                            }\n+                                            _ => {},\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                            // constant\n+                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                            _ => {},\n+                        }\n+                    },\n+                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Scans the body of the for loop and determines whether lint should be given\n+struct SameItemPushVisitor<'a, 'tcx> {\n+    should_lint: bool,\n+    // this field holds the last vec push operation visited, which should be the only push seen\n+    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            // Non-determinism may occur ... don't give a lint\n+            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n+            ExprKind::Block(block, _) => self.visit_block(block),\n+            _ => {},\n+        }\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+        for stmt in b.stmts.iter() {\n+            self.visit_stmt(stmt);\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'_>) {\n+        let vec_push_option = get_vec_push(self.cx, s);\n+        if vec_push_option.is_none() {\n+            // Current statement is not a push so visit inside\n+            match &s.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                _ => {},\n+            }\n+        } else {\n+            // Current statement is a push ...check whether another\n+            // push had been previously done\n+            if self.vec_push.is_none() {\n+                self.vec_push = vec_push_option;\n+            } else {\n+                // There are multiple pushes ... don't lint\n+                self.should_lint = false;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// Given some statement, determine if that statement is a push on a Vec. If it is, return\n+// the Vec being pushed into and the item being pushed\n+fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+            // Extract method being called\n+            if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n+            // Figure out the parameters for the method call\n+            if let Some(self_expr) = args.get(0);\n+            if let Some(pushed_item) = args.get(1);\n+            // Check that the method being called is push() on a Vec\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::vec_type);\n+            if path.ident.name.as_str() == \"push\";\n+            then {\n+                return Some((self_expr, pushed_item))\n+            }\n+    }\n+    None\n+}"}, {"sha": "38400c93c9ab205d1a9f6eeb8e63b279e9792122", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,42 @@\n+use super::{get_span_of_entire_for_loop, SINGLE_ELEMENT_LOOP};\n+use crate::utils::{indent_of, single_segment_path, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Pat, PatKind};\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n+        if let PatKind::Binding(.., target, _) = pat.kind;\n+        if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n+        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n+        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n+        if let ExprKind::Block(ref block, _) = body.kind;\n+        if !block.stmts.is_empty();\n+\n+        then {\n+            let for_span = get_span_of_entire_for_loop(expr);\n+            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            block_str.remove(0);\n+            block_str.pop();\n+\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SINGLE_ELEMENT_LOOP,\n+                for_span,\n+                \"for loop over a single element\",\n+                \"try\",\n+                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n+                Applicability::MachineApplicable\n+            )\n+        }\n+    }\n+}"}, {"sha": "9e38e17719aad116846c252a97d1c9bd00bb89bc", "filename": "clippy_lints/src/loops/utils.rs", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,350 @@\n+use crate::utils::{\n+    get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, is_integer_const, path_to_local,\n+    path_to_local_id, paths, sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+use std::iter::Iterator;\n+\n+#[derive(Debug, PartialEq)]\n+enum IncrementVisitorVarState {\n+    Initial,  // Not examined yet\n+    IncrOnce, // Incremented exactly once, may be a loop counter\n+    DontWarn,\n+}\n+\n+/// Scan a for loop for variables that are incremented exactly once and not used after that.\n+pub(super) struct IncrementVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,                          // context reference\n+    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n+    depth: u32,                                         // depth of conditional expressions\n+    done: bool,\n+}\n+\n+impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n+    pub(super) fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            states: FxHashMap::default(),\n+            depth: 0,\n+            done: false,\n+        }\n+    }\n+\n+    pub(super) fn into_results(self) -> impl Iterator<Item = HirId> {\n+        self.states.into_iter().filter_map(|(id, state)| {\n+            if state == IncrementVisitorVarState::IncrOnce {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.done {\n+            return;\n+        }\n+\n+        // If node is a variable\n+        if let Some(def_id) = path_to_local(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n+                if *state == IncrementVisitorVarState::IncrOnce {\n+                    *state = IncrementVisitorVarState::DontWarn;\n+                    return;\n+                }\n+\n+                match parent.kind {\n+                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                        if lhs.hir_id == expr.hir_id {\n+                            *state = if op.node == BinOpKind::Add\n+                                && is_integer_const(self.cx, rhs, 1)\n+                                && *state == IncrementVisitorVarState::Initial\n+                                && self.depth == 0\n+                            {\n+                                IncrementVisitorVarState::IncrOnce\n+                            } else {\n+                                // Assigned some other value or assigned multiple times\n+                                IncrementVisitorVarState::DontWarn\n+                            };\n+                        }\n+                    },\n+                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n+                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n+                    _ => (),\n+                }\n+            }\n+\n+            walk_expr(self, expr);\n+        } else if is_loop(expr) || is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+        } else if let ExprKind::Continue(_) = expr.kind {\n+            self.done = true;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+enum InitializeVisitorState<'hir> {\n+    Initial,          // Not examined yet\n+    Declared(Symbol), // Declared but not (yet) initialized\n+    Initialized {\n+        name: Symbol,\n+        initializer: &'hir Expr<'hir>,\n+    },\n+    DontWarn,\n+}\n+\n+/// Checks whether a variable is initialized at the start of a loop and not modified\n+/// and used after the loop.\n+pub(super) struct InitializeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,  // context reference\n+    end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n+    var_id: HirId,\n+    state: InitializeVisitorState<'tcx>,\n+    depth: u32, // depth of conditional expressions\n+    past_loop: bool,\n+}\n+\n+impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n+    pub(super) fn new(cx: &'a LateContext<'tcx>, end_expr: &'tcx Expr<'tcx>, var_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            end_expr,\n+            var_id,\n+            state: InitializeVisitorState::Initial,\n+            depth: 0,\n+            past_loop: false,\n+        }\n+    }\n+\n+    pub(super) fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n+        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n+            Some((name, initializer))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        // Look for declarations of the variable\n+        if_chain! {\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if local.pat.hir_id == self.var_id;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            then {\n+                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n+                    InitializeVisitorState::Initialized {\n+                        initializer: init,\n+                        name: ident.name,\n+                    }\n+                })\n+            }\n+        }\n+        walk_stmt(self, stmt);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if matches!(self.state, InitializeVisitorState::DontWarn) {\n+            return;\n+        }\n+        if expr.hir_id == self.end_expr.hir_id {\n+            self.past_loop = true;\n+            return;\n+        }\n+        // No need to visit expressions before the variable is\n+        // declared\n+        if matches!(self.state, InitializeVisitorState::Initial) {\n+            return;\n+        }\n+\n+        // If node is the desired variable, see how it's used\n+        if path_to_local_id(expr, self.var_id) {\n+            if self.past_loop {\n+                self.state = InitializeVisitorState::DontWarn;\n+                return;\n+            }\n+\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n+                        self.state = InitializeVisitorState::DontWarn;\n+                    },\n+                    ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n+                        self.state = if_chain! {\n+                            if self.depth == 0;\n+                            if let InitializeVisitorState::Declared(name)\n+                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n+                            then {\n+                                InitializeVisitorState::Initialized { initializer: rhs, name }\n+                            } else {\n+                                InitializeVisitorState::DontWarn\n+                            }\n+                        }\n+                    },\n+                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n+                        self.state = InitializeVisitorState::DontWarn\n+                    },\n+                    _ => (),\n+                }\n+            }\n+\n+            walk_expr(self, expr);\n+        } else if !self.past_loop && is_loop(expr) {\n+            self.state = InitializeVisitorState::DontWarn;\n+        } else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+fn is_loop(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Loop(..))\n+}\n+\n+fn is_conditional(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::If(..) | ExprKind::Match(..))\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub(super) enum Nesting {\n+    Unknown,     // no nesting detected yet\n+    RuledOut,    // the iterator is initialized or assigned within scope\n+    LookFurther, // no nesting detected, no further walk required\n+}\n+\n+use self::Nesting::{LookFurther, RuledOut, Unknown};\n+\n+pub(super) struct LoopNestVisitor {\n+    pub(super) hir_id: HirId,\n+    pub(super) iterator: HirId,\n+    pub(super) nesting: Nesting,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        if stmt.hir_id == self.hir_id {\n+            self.nesting = LookFurther;\n+        } else if self.nesting == Unknown {\n+            walk_stmt(self, stmt);\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.nesting != Unknown {\n+            return;\n+        }\n+        if expr.hir_id == self.hir_id {\n+            self.nesting = LookFurther;\n+            return;\n+        }\n+        match expr.kind {\n+            ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n+                if path_to_local_id(path, self.iterator) {\n+                    self.nesting = RuledOut;\n+                }\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'_>) {\n+        if self.nesting != Unknown {\n+            return;\n+        }\n+        if let PatKind::Binding(_, id, ..) = pat.kind {\n+            if id == self.iterator {\n+                self.nesting = RuledOut;\n+                return;\n+            }\n+        }\n+        walk_pat(self, pat)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// this function assumes the given expression is a `for` loop.\n+pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n+    // for some reason this is the only way to get the `Span`\n+    // of the entire `for` loop\n+    if let ExprKind::Match(_, arms, _) = &expr.kind {\n+        arms[0].body.span\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n+/// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n+/// actual `Iterator` that the loop uses.\n+pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n+    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n+    });\n+    if impls_iterator {\n+        format!(\n+            \"{}\",\n+            sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n+        )\n+    } else {\n+        // (&x).into_iter() ==> x.iter()\n+        // (&mut x).into_iter() ==> x.iter_mut()\n+        match &arg.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n+            {\n+                let meth_name = match mutability {\n+                    Mutability::Mut => \"iter_mut\",\n+                    Mutability::Not => \"iter\",\n+                };\n+                format!(\n+                    \"{}.{}()\",\n+                    sugg::Sugg::hir_with_applicability(cx, &arg_inner, \"_\", applic_ref).maybe_par(),\n+                    meth_name,\n+                )\n+            }\n+            _ => format!(\n+                \"{}.into_iter()\",\n+                sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n+            ),\n+        }\n+    }\n+}"}, {"sha": "05e0a7225631c5421b602d06e63c443acf3130f4", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,139 @@\n+use super::WHILE_IMMUTABLE_CONDITION;\n+use crate::consts::constant;\n+use crate::utils::span_lint_and_then;\n+use crate::utils::usage::mutated_variables;\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id, Expr, ExprKind, HirId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use std::iter::Iterator;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n+    if constant(cx, cx.typeck_results(), cond).is_some() {\n+        // A pure constant condition (e.g., `while false`) is not linted.\n+        return;\n+    }\n+\n+    let mut var_visitor = VarCollectorVisitor {\n+        cx,\n+        ids: FxHashSet::default(),\n+        def_ids: FxHashMap::default(),\n+        skip: false,\n+    };\n+    var_visitor.visit_expr(cond);\n+    if var_visitor.skip {\n+        return;\n+    }\n+    let used_in_condition = &var_visitor.ids;\n+    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n+        used_in_condition.is_disjoint(&used_mutably)\n+    } else {\n+        return;\n+    };\n+    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+\n+    let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {\n+        has_break_or_return: false,\n+    };\n+    has_break_or_return_visitor.visit_expr(expr);\n+    let has_break_or_return = has_break_or_return_visitor.has_break_or_return;\n+\n+    if no_cond_variable_mutated && !mutable_static_in_cond {\n+        span_lint_and_then(\n+            cx,\n+            WHILE_IMMUTABLE_CONDITION,\n+            cond.span,\n+            \"variables in the condition are not mutated in the loop body\",\n+            |diag| {\n+                diag.note(\"this may lead to an infinite or to a never running loop\");\n+\n+                if has_break_or_return {\n+                    diag.note(\"this loop contains `return`s or `break`s\");\n+                    diag.help(\"rewrite it as `if cond { loop { } }`\");\n+                }\n+            },\n+        );\n+    }\n+}\n+\n+struct HasBreakOrReturnVisitor {\n+    has_break_or_return: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.has_break_or_return {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Ret(_) | ExprKind::Break(_, _) => {\n+                self.has_break_or_return = true;\n+                return;\n+            },\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Collects the set of variables in an expression\n+/// Stops analysis if a function call is found\n+/// Note: In some cases such as `self`, there are no mutable annotation,\n+/// All variables definition IDs are collected\n+struct VarCollectorVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    ids: FxHashSet<HirId>,\n+    def_ids: FxHashMap<def_id::DefId, bool>,\n+    skip: bool,\n+}\n+\n+impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n+    fn insert_def_id(&mut self, ex: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Path(ref qpath) = ex.kind;\n+            if let QPath::Resolved(None, _) = *qpath;\n+            let res = self.cx.qpath_res(qpath, ex.hir_id);\n+            then {\n+                match res {\n+                    Res::Local(hir_id) => {\n+                        self.ids.insert(hir_id);\n+                    },\n+                    Res::Def(DefKind::Static, def_id) => {\n+                        let mutable = self.cx.tcx.is_mutable_static(def_id);\n+                        self.def_ids.insert(def_id, mutable);\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+        match ex.kind {\n+            ExprKind::Path(_) => self.insert_def_id(ex),\n+            // If there is any function/method call\u2026 we just stop analysis\n+            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n+\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "65d8f2f1111a34fd39051ebfa4511a3a56deb520", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,87 @@\n+use super::WHILE_LET_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+    // extract the expression from the first statement (if any) in a block\n+    let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n+    // or extract the first expression (if any) from the block\n+    if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n+        if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n+            // ensure \"if let\" compatible match structure\n+            match *source {\n+                MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n+                    if arms.len() == 2\n+                        && arms[0].guard.is_none()\n+                        && arms[1].guard.is_none()\n+                        && is_simple_break_expr(&arms[1].body)\n+                    {\n+                        if in_external_macro(cx.sess(), expr.span) {\n+                            return;\n+                        }\n+\n+                        // NOTE: we used to build a body here instead of using\n+                        // ellipsis, this was removed because:\n+                        // 1) it was ugly with big bodies;\n+                        // 2) it was not indented properly;\n+                        // 3) it wasn\u2019t very smart (see #675).\n+                        let mut applicability = Applicability::HasPlaceholders;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            WHILE_LET_LOOP,\n+                            expr.span,\n+                            \"this loop could be written as a `while let` loop\",\n+                            \"try\",\n+                            format!(\n+                                \"while let {} = {} {{ .. }}\",\n+                                snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+/// If a block begins with a statement (possibly a `let` binding) and has an\n+/// expression, return it.\n+fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    if block.stmts.is_empty() {\n+        return None;\n+    }\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n+        local.init //.map(|expr| expr)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If a block begins with an expression (with or without semicolon), return it.\n+fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    match block.expr {\n+        Some(ref expr) if block.stmts.is_empty() => Some(expr),\n+        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns `true` if expr contains a single break expr without destination label\n+/// and\n+/// passed expression. The expression may be within a block.\n+fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n+        ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        _ => false,\n+    }\n+}"}, {"sha": "e5a47694faa4e79bbaeeba86a1d750980c2b8a69", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43d19f63f7c6007284387e76cfe0fe8b74e98a59/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=43d19f63f7c6007284387e76cfe0fe8b74e98a59", "patch": "@@ -0,0 +1,171 @@\n+use super::utils::{LoopNestVisitor, Nesting};\n+use super::WHILE_LET_ON_ITERATOR;\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{\n+    get_enclosing_block, get_trait_def_id, implements_trait, is_refutable, last_path_segment, match_trait_method,\n+    path_to_local, path_to_local_id, paths, snippet_with_applicability, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ExprKind, HirId, MatchSource, Node, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+\n+use rustc_span::symbol::sym;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n+        let pat = &arms[0].pat.kind;\n+        if let (\n+            &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n+            &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n+        ) = (pat, &match_expr.kind)\n+        {\n+            let iter_expr = &method_args[0];\n+\n+            // Don't lint when the iterator is recreated on every iteration\n+            if_chain! {\n+                if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n+                if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n+                if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n+                then {\n+                    return;\n+                }\n+            }\n+\n+            let lhs_constructor = last_path_segment(qpath);\n+            if method_path.ident.name == sym::next\n+                && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                && lhs_constructor.ident.name == sym::Some\n+                && (pat_args.is_empty()\n+                    || !is_refutable(cx, &pat_args[0])\n+                        && !is_used_inside(cx, iter_expr, &arms[0].body)\n+                        && !is_iterator_used_after_while_let(cx, iter_expr)\n+                        && !is_nested(cx, expr, &method_args[0]))\n+            {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let iterator = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n+                let loop_var = if pat_args.is_empty() {\n+                    \"_\".to_string()\n+                } else {\n+                    snippet_with_applicability(cx, pat_args[0].span, \"_\", &mut applicability).into_owned()\n+                };\n+                span_lint_and_sugg(\n+                    cx,\n+                    WHILE_LET_ON_ITERATOR,\n+                    expr.span.with_hi(match_expr.span.hi()),\n+                    \"this loop could be written as a `for` loop\",\n+                    \"try\",\n+                    format!(\"for {} in {}\", loop_var, iterator),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n+    let def_id = match path_to_local(expr) {\n+        Some(id) => id,\n+        None => return false,\n+    };\n+    if let Some(used_mutably) = mutated_variables(container, cx) {\n+        if used_mutably.contains(&def_id) {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n+    let def_id = match path_to_local(iter_expr) {\n+        Some(id) => id,\n+        None => return false,\n+    };\n+    let mut visitor = VarUsedAfterLoopVisitor {\n+        def_id,\n+        iter_expr_id: iter_expr.hir_id,\n+        past_while_let: false,\n+        var_used_after_while_let: false,\n+    };\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n+        walk_block(&mut visitor, enclosing_block);\n+    }\n+    visitor.var_used_after_while_let\n+}\n+\n+fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n+        let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n+        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(parent_node);\n+        then {\n+            return is_loop_nested(cx, loop_expr, iter_expr)\n+        }\n+    }\n+    false\n+}\n+\n+fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+    let mut id = loop_expr.hir_id;\n+    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n+        id\n+    } else {\n+        return true;\n+    };\n+    loop {\n+        let parent = cx.tcx.hir().get_parent_node(id);\n+        if parent == id {\n+            return false;\n+        }\n+        match cx.tcx.hir().find(parent) {\n+            Some(Node::Expr(expr)) => {\n+                if let ExprKind::Loop(..) = expr.kind {\n+                    return true;\n+                };\n+            },\n+            Some(Node::Block(block)) => {\n+                let mut block_visitor = LoopNestVisitor {\n+                    hir_id: id,\n+                    iterator: iter_id,\n+                    nesting: Nesting::Unknown,\n+                };\n+                walk_block(&mut block_visitor, block);\n+                if block_visitor.nesting == Nesting::RuledOut {\n+                    return false;\n+                }\n+            },\n+            Some(Node::Stmt(_)) => (),\n+            _ => {\n+                return false;\n+            },\n+        }\n+        id = parent;\n+    }\n+}\n+\n+struct VarUsedAfterLoopVisitor {\n+    def_id: HirId,\n+    iter_expr_id: HirId,\n+    past_while_let: bool,\n+    var_used_after_while_let: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.past_while_let {\n+            if path_to_local_id(expr, self.def_id) {\n+                self.var_used_after_while_let = true;\n+            }\n+        } else if self.iter_expr_id == expr.hir_id {\n+            self.past_while_let = true;\n+        }\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}]}