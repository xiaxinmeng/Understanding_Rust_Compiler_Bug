{"sha": "b4b2a259cd54f53431fb8ae6511f29fdde7bdec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YjJhMjU5Y2Q1NGY1MzQzMWZiOGFlNjUxMWYyOWZkZGU3YmRlYzM=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-01-17T05:11:31Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-02-18T22:38:25Z"}, "message": "Add compare_exchange and compare_exchange_weak to atomic types", "tree": {"sha": "406faea6e79534e2a084d460363f6d92e2e2bbad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/406faea6e79534e2a084d460363f6d92e2e2bbad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4b2a259cd54f53431fb8ae6511f29fdde7bdec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b2a259cd54f53431fb8ae6511f29fdde7bdec3", "html_url": "https://github.com/rust-lang/rust/commit/b4b2a259cd54f53431fb8ae6511f29fdde7bdec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4b2a259cd54f53431fb8ae6511f29fdde7bdec3/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ddcb33f431be554449116706eb0d6af2666a11", "url": "https://api.github.com/repos/rust-lang/rust/commits/64ddcb33f431be554449116706eb0d6af2666a11", "html_url": "https://github.com/rust-lang/rust/commit/64ddcb33f431be554449116706eb0d6af2666a11"}], "stats": {"total": 435, "additions": 426, "deletions": 9}, "files": [{"sha": "0c831bff763d0dc22ccb3ea1ecacb9a379ae9dbd", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 426, "deletions": 9, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/b4b2a259cd54f53431fb8ae6511f29fdde7bdec3/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b2a259cd54f53431fb8ae6511f29fdde7bdec3/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b4b2a259cd54f53431fb8ae6511f29fdde7bdec3", "patch": "@@ -311,10 +311,101 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// assert_eq!(some_bool.compare_exchange(true,\n+    ///                                       false,\n+    ///                                       Ordering::Acquire,\n+    ///                                       Ordering::Relaxed),\n+    ///            true);\n+    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n+    ///\n+    /// assert_eq!(some_bool.compare_exchange(true, true,\n+    ///                                       Ordering::SeqCst,\n+    ///                                       Ordering::Acquire),\n+    ///            false);\n+    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: bool,\n+                            new: bool,\n+                            success: Ordering,\n+                            failure: Ordering) -> bool {\n         let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) > 0 }\n+        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) > 0 }\n+    }\n+\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let val = AtomicBool::new(false);\n+    ///\n+    /// let new = true;\n+    /// let mut old = val.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let result = val.compare_exchange_weak(old, new,\n+    ///                                            Ordering::SeqCst,\n+    ///                                            Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: bool,\n+                                 new: bool,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (bool, bool) {\n+        let current = if current { UINT_TRUE } else { 0 };\n+        let new = if new { UINT_TRUE } else { 0 };\n+\n+        let result = unsafe {\n+            atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+        };\n+        (result.0 > 0, result.1)\n     }\n \n     /// Logical \"and\" with a boolean value.\n@@ -553,7 +644,91 @@ impl AtomicIsize {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n+    ///\n+    /// let some_isize = AtomicIsize::new(5);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(5, 10,\n+    ///                                        Ordering::Acquire,\n+    ///                                        Ordering::Relaxed),\n+    ///            5);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(6, 12,\n+    ///                                        Ordering::SeqCst,\n+    ///                                        Ordering::Acquire),\n+    ///            10);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: isize,\n+                            new: isize,\n+                            success: Ordering,\n+                            failure: Ordering) -> isize {\n+        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+    }\n+\n+    /// Stores a value into the `isize if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n+    ///\n+    /// let val = AtomicIsize::new(4);\n+    ///\n+    /// let mut old = val.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let new = old * 2;\n+    ///     let result = val.compare_exchange_weak(old, new,\n+    ///                                            Ordering::SeqCst,\n+    ///                                            Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: isize,\n+                                 new: isize,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (isize, bool) {\n+        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n     }\n \n     /// Add an isize to the current value, returning the previous value.\n@@ -746,7 +921,91 @@ impl AtomicUsize {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n+    ///\n+    /// let some_isize = AtomicUsize::new(5);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(5, 10,\n+    ///                                        Ordering::Acquire,\n+    ///                                        Ordering::Relaxed),\n+    ///            5);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(6, 12,\n+    ///                                        Ordering::SeqCst,\n+    ///                                        Ordering::Acquire),\n+    ///            10);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: usize,\n+                            new: usize,\n+                            success: Ordering,\n+                            failure: Ordering) -> usize {\n+        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+    }\n+\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n+    ///\n+    /// let val = AtomicUsize::new(4);\n+    ///\n+    /// let mut old = val.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let new = old * 2;\n+    ///     let result = val.compare_exchange_weak(old, new,\n+    ///                                            Ordering::SeqCst,\n+    ///                                            Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: usize,\n+                                 new: usize,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (usize, bool) {\n+        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n     }\n \n     /// Add to the current usize, returning the previous value.\n@@ -947,15 +1206,109 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr   = &mut 10;\n+    /// let another_ptr = &mut 10;\n+    ///\n+    /// let value = some_ptr.compare_exchange(other_ptr, another_ptr,\n+    ///                                       Ordering::SeqCst, Ordering::Relaxed);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: *mut T,\n+                            new: *mut T,\n+                            success: Ordering,\n+                            failure: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get() as *mut usize, current as usize,\n-                                    new as usize, order) as *mut T\n+            atomic_compare_exchange(self.p.get() as *mut usize, current as usize,\n+                                    new as usize, success, failure) as *mut T\n         }\n     }\n+\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let some_ptr = AtomicPtr::new(&mut 5);\n+    ///\n+    /// let new = &mut 10;\n+    /// let mut old = some_ptr.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let result = some_ptr.compare_exchange_weak(old, new,\n+    ///                                                 Ordering::SeqCst,\n+    ///                                                 Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: *mut T,\n+                                 new: *mut T,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (*mut T, bool) {\n+        let result = unsafe {\n+            atomic_compare_exchange_weak(self.p.get() as *mut usize, current as usize,\n+                                         new as usize, success, failure)\n+        };\n+        (result.0 as *mut T, result.1)\n+    }\n }\n \n #[inline]\n-unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n+fn strongest_failure_ordering(order: Ordering) -> Ordering {\n+    match order {\n+        Release => Relaxed,\n+        Relaxed => Relaxed,\n+        SeqCst  => SeqCst,\n+        Acquire => Acquire,\n+        AcqRel  => Acquire,\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n     match order {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n@@ -966,7 +1319,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n+unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n@@ -1012,8 +1365,36 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n-    match order {\n+#[cfg(not(stage0))]\n+unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n+                                     old: T,\n+                                     new: T,\n+                                     success: Ordering,\n+                                     failure: Ordering) -> T {\n+    match (success, failure) {\n+        (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n+        (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n+        (AcqRel, Acquire)  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+        (SeqCst, SeqCst)   => intrinsics::atomic_cxchg(dst, old, new),\n+        (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n+        (AcqRel, Relaxed)  => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed)  => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire)  => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+        (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+        (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n+        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    }\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n+                                     old: T,\n+                                     new: T,\n+                                     success: Ordering,\n+                                     _: Ordering) -> T {\n+    match success {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n         Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n         AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n@@ -1022,6 +1403,42 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n     }\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n+                                          old: T,\n+                                          new: T,\n+                                          success: Ordering,\n+                                          failure: Ordering) -> (T, bool) {\n+    match (success, failure) {\n+        (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n+        (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n+        (AcqRel, Acquire)  => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n+        (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n+        (SeqCst, SeqCst)   => intrinsics::atomic_cxchgweak(dst, old, new),\n+        (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n+        (AcqRel, Relaxed)  => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed)  => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire)  => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+        (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+        (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n+        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    }\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n+                                          old: T,\n+                                          new: T,\n+                                          success: Ordering,\n+                                          failure: Ordering) -> (T, bool)\n+    where T: ::cmp::Eq + ::marker::Copy\n+{\n+    let result = atomic_compare_exchange(dst, old, new, success, failure);\n+    (result, result == old)\n+}\n+\n #[inline]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {"}]}