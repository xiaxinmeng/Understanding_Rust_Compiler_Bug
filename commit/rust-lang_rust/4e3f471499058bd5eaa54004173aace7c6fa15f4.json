{"sha": "4e3f471499058bd5eaa54004173aace7c6fa15f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlM2Y0NzE0OTkwNThiZDVlYWE1NDAwNDE3M2FhY2U3YzZmYTE1ZjQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-04T22:24:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-04T22:24:29Z"}, "message": "Rollup merge of #83019 - eddyb:spirv-no-block-swap, r=nagisa\n\ncore: disable `ptr::swap_nonoverlapping_one`'s block optimization on SPIR-V.\n\nSPIR-V primarily supports what it calls the \"Logical addressing model\" (and AFAIK for graphical shaders it's the only option), and what that implies is that there is no \"memory\" to uniformly address at some byte/word level, and that you can't really talk about values having a \"raw representation\" in terms of sequences of bytes. Therefore, the \"block\"-wise swapping optimization employed by `ptr::swap_nonoverlapping_one` (where a \"block\" is 32 bytes, currently), is fundamentally incompatible with SPIR-V \"memory\".\n\nAs such, [Rust-GPU](https://github.com/EmbarkStudios/rust-gpu/)'s `rustc_codegen_spirv` backend cannot currently allow the use of `ptr::swap_nonoverlapping_one` - but that comes at a great price, since it's the building block of `mem::{swap,replace}`, and those in turn are used by e.g. `Option::take` and `Range`'s `Iterator` implementation (the latter blocking the use of `for i in 0..n` loops).\n\nThere's 4 options I can see in terms of supporting `ptr::swap_nonoverlapping_one` in `rustc_codegen_spirv`:\n* legalize the block-wise swap loop back into swapping whole values, for SPIR-V\n  * this is made borderline impossible by the fact that the size of the state \"on the stack\" is a block, and has to be expanded back to the appropriate size of the value being swapped, so in practice this would have to effectively pattern-match on the exact shape of the block-wise swapping algorithm, as a roundabout way of \"patching `core::ptr` on the fly\"\n* (**this PR**) disable the block-wise swap optimization altogether when `#[cfg(target_arch = \"spirv\")`\n  * I've tested it and it does in fact allow compiling `for i in 0..n` loops, which was my primary motivation\n  * main downside IMO is the fact that `core` now acknowledges an out-of-tree backend\n    * as a counterpoint, any attempt to compile Rust to SPIR-V would run into this problem, one way or another\n* only enable the block-wise swap optimization on targets where it's been empirically proven to be an improvement\n  * would avoid any surprises in terms of potentially-broken/inefficient codegen, in general\n  * however, it may be universally applicable (thanks to caches), even if the optimal block size could differ\n* move low-level swapping into an intrinsic, where the backend can choose any optimization approach it wants\n  * this also has an impact on MIR optimizations (cc ``@rust-lang/wg-mir-opt)`` - which currently cannot hope to make sense of e.g. `Option::take` despite it being effectively `_0 = *_1;` `*_1 = None;` `return;`\n  * long-term this is my preferred approach, and I can start working on it if that's desired, but I wanted to confirm that this swapping optimization is the final blocker for [Rust-GPU](https://github.com/EmbarkStudios/rust-gpu/) supporting e.g. range `for` loops\n\nr? ``@nagisa`` cc ``@rust-lang/libs``", "tree": {"sha": "2b36881fb31eada0bd03e6e3decef8788e2a2403", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b36881fb31eada0bd03e6e3decef8788e2a2403"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e3f471499058bd5eaa54004173aace7c6fa15f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgajydCRBK7hj4Ov3rIwAAdHIIAFdX8syXFPcHVzgXqkv0L62e\ncXQSphtFqbDmb3NMKsatVIpvtYmghGEtPsclHrPeBOfR1audEYPWbgKmpd4gZ2iC\n9rXLG+4tc75hf0QxzjdzZpW1m4KNfYAMqzY9kneWy+NqeI47XP+K8Cuuji2tPuaQ\nm2ojodWE7JS0nd2zJWUyBtKv2a8sEhG6+4WC0i1x+V2aIR3qKJeKytZ8f20KWjUm\nPZuRyAxRsNFOmKBFVMJyl5yJctHBYd1StfM3iciFedlx/OIEYFjlKulocS8l5ncg\nXxI5Z1QVWuyw19198AEsXLf+Wk8XLkjO6JbnFI4+PGd/0pppAYvBvzu8luoJwk8=\n=Zrbj\n-----END PGP SIGNATURE-----\n", "payload": "tree 2b36881fb31eada0bd03e6e3decef8788e2a2403\nparent 0d12422f2d82e4ec47d4b85660caed70b78ea44c\nparent bc6af97ed0088304a2430b74b47c182c65ce0b9f\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617575069 +0200\ncommitter GitHub <noreply@github.com> 1617575069 +0200\n\nRollup merge of #83019 - eddyb:spirv-no-block-swap, r=nagisa\n\ncore: disable `ptr::swap_nonoverlapping_one`'s block optimization on SPIR-V.\n\nSPIR-V primarily supports what it calls the \"Logical addressing model\" (and AFAIK for graphical shaders it's the only option), and what that implies is that there is no \"memory\" to uniformly address at some byte/word level, and that you can't really talk about values having a \"raw representation\" in terms of sequences of bytes. Therefore, the \"block\"-wise swapping optimization employed by `ptr::swap_nonoverlapping_one` (where a \"block\" is 32 bytes, currently), is fundamentally incompatible with SPIR-V \"memory\".\n\nAs such, [Rust-GPU](https://github.com/EmbarkStudios/rust-gpu/)'s `rustc_codegen_spirv` backend cannot currently allow the use of `ptr::swap_nonoverlapping_one` - but that comes at a great price, since it's the building block of `mem::{swap,replace}`, and those in turn are used by e.g. `Option::take` and `Range`'s `Iterator` implementation (the latter blocking the use of `for i in 0..n` loops).\n\nThere's 4 options I can see in terms of supporting `ptr::swap_nonoverlapping_one` in `rustc_codegen_spirv`:\n* legalize the block-wise swap loop back into swapping whole values, for SPIR-V\n  * this is made borderline impossible by the fact that the size of the state \"on the stack\" is a block, and has to be expanded back to the appropriate size of the value being swapped, so in practice this would have to effectively pattern-match on the exact shape of the block-wise swapping algorithm, as a roundabout way of \"patching `core::ptr` on the fly\"\n* (**this PR**) disable the block-wise swap optimization altogether when `#[cfg(target_arch = \"spirv\")`\n  * I've tested it and it does in fact allow compiling `for i in 0..n` loops, which was my primary motivation\n  * main downside IMO is the fact that `core` now acknowledges an out-of-tree backend\n    * as a counterpoint, any attempt to compile Rust to SPIR-V would run into this problem, one way or another\n* only enable the block-wise swap optimization on targets where it's been empirically proven to be an improvement\n  * would avoid any surprises in terms of potentially-broken/inefficient codegen, in general\n  * however, it may be universally applicable (thanks to caches), even if the optimal block size could differ\n* move low-level swapping into an intrinsic, where the backend can choose any optimization approach it wants\n  * this also has an impact on MIR optimizations (cc ``@rust-lang/wg-mir-opt)`` - which currently cannot hope to make sense of e.g. `Option::take` despite it being effectively `_0 = *_1;` `*_1 = None;` `return;`\n  * long-term this is my preferred approach, and I can start working on it if that's desired, but I wanted to confirm that this swapping optimization is the final blocker for [Rust-GPU](https://github.com/EmbarkStudios/rust-gpu/) supporting e.g. range `for` loops\n\nr? ``@nagisa`` cc ``@rust-lang/libs``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3f471499058bd5eaa54004173aace7c6fa15f4", "html_url": "https://github.com/rust-lang/rust/commit/4e3f471499058bd5eaa54004173aace7c6fa15f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e3f471499058bd5eaa54004173aace7c6fa15f4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d12422f2d82e4ec47d4b85660caed70b78ea44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d12422f2d82e4ec47d4b85660caed70b78ea44c", "html_url": "https://github.com/rust-lang/rust/commit/0d12422f2d82e4ec47d4b85660caed70b78ea44c"}, {"sha": "bc6af97ed0088304a2430b74b47c182c65ce0b9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc6af97ed0088304a2430b74b47c182c65ce0b9f", "html_url": "https://github.com/rust-lang/rust/commit/bc6af97ed0088304a2430b74b47c182c65ce0b9f"}], "stats": {"total": 37, "additions": 25, "deletions": 12}, "files": [{"sha": "f673a6fd178f04818fa7a5bed9caf851c60e00e7", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e3f471499058bd5eaa54004173aace7c6fa15f4/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3f471499058bd5eaa54004173aace7c6fa15f4/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=4e3f471499058bd5eaa54004173aace7c6fa15f4", "patch": "@@ -473,19 +473,32 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n #[inline]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n pub(crate) const unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n-    // For types smaller than the block optimization below,\n-    // just swap directly to avoid pessimizing codegen.\n-    if mem::size_of::<T>() < 32 {\n-        // SAFETY: the caller must guarantee that `x` and `y` are valid\n-        // for writes, properly aligned, and non-overlapping.\n-        unsafe {\n-            let z = read(x);\n-            copy_nonoverlapping(y, x, 1);\n-            write(y, z);\n+    // NOTE(eddyb) SPIR-V's Logical addressing model doesn't allow for arbitrary\n+    // reinterpretation of values as (chunkable) byte arrays, and the loop in the\n+    // block optimization in `swap_nonoverlapping_bytes` is hard to rewrite back\n+    // into the (unoptimized) direct swapping implementation, so we disable it.\n+    // FIXME(eddyb) the block optimization also prevents MIR optimizations from\n+    // understanding `mem::replace`, `Option::take`, etc. - a better overall\n+    // solution might be to make `swap_nonoverlapping` into an intrinsic, which\n+    // a backend can choose to implement using the block optimization, or not.\n+    #[cfg(not(target_arch = \"spirv\"))]\n+    {\n+        // Only apply the block optimization in `swap_nonoverlapping_bytes` for types\n+        // at least as large as the block size, to avoid pessimizing codegen.\n+        if mem::size_of::<T>() >= 32 {\n+            // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n+            unsafe { swap_nonoverlapping(x, y, 1) };\n+            return;\n         }\n-    } else {\n-        // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n-        unsafe { swap_nonoverlapping(x, y, 1) };\n+    }\n+\n+    // Direct swapping, for the cases not going through the block optimization.\n+    // SAFETY: the caller must guarantee that `x` and `y` are valid\n+    // for writes, properly aligned, and non-overlapping.\n+    unsafe {\n+        let z = read(x);\n+        copy_nonoverlapping(y, x, 1);\n+        write(y, z);\n     }\n }\n "}]}