{"sha": "537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "node_id": "C_kwDOAAsO6NoAKDUzN2NjMWVlYzViYzBmMjZkZjExMmMwY2RiNGExNmM3OTMxODlhYjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T13:57:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T13:57:14Z"}, "message": "Auto merge of #12863 - lowr:fix/missing-fields-on-destructuring-assignment, r=Veykril\n\nFix missing fields check on destructuring assignment\n\nFixes #12838\n\nWhen checking if the record literal in question is an assignee expression or not, the new fn `is_assignee_record_literal` iterates over its ancestors until it is sure. This isn't super efficient, as we don't cache anything and does the iteration for every record literal during missing fields check. Alternatively, we may want to have a field like `assignee` on `hir_def::Expr::{RecordLit, Array, Tuple, Call}` to tell if it's an assignee expression, which would be O(1) when checking later but have some memory overhead for the field.", "tree": {"sha": "463985f78478130c679d201e3a83a538e151c134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/463985f78478130c679d201e3a83a538e151c134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "html_url": "https://github.com/rust-lang/rust/commit/537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "894d6a232c1cf69f7050a33223f687c4623e4d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/894d6a232c1cf69f7050a33223f687c4623e4d16", "html_url": "https://github.com/rust-lang/rust/commit/894d6a232c1cf69f7050a33223f687c4623e4d16"}, {"sha": "805ac666ca8cb2b643026ff454951e9ce3834d94", "url": "https://api.github.com/repos/rust-lang/rust/commits/805ac666ca8cb2b643026ff454951e9ce3834d94", "html_url": "https://github.com/rust-lang/rust/commit/805ac666ca8cb2b643026ff454951e9ce3834d94"}], "stats": {"total": 106, "additions": 85, "deletions": 21}, "files": [{"sha": "66f9c24e8724a77e10d73a0f55df2367ebb1e116", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "patch": "@@ -96,6 +96,7 @@ pub(super) fn lower(\n         expander,\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n+        is_lowering_assignee_expr: false,\n     }\n     .collect(params, body)\n }\n@@ -109,6 +110,7 @@ struct ExprCollector<'a> {\n     // a poor-mans union-find?\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n+    is_lowering_assignee_expr: bool,\n }\n \n impl ExprCollector<'_> {\n@@ -283,7 +285,10 @@ impl ExprCollector<'_> {\n                 } else {\n                     Box::default()\n                 };\n-                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Call { callee, args, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.receiver());\n@@ -359,6 +364,7 @@ impl ExprCollector<'_> {\n             ast::Expr::RecordExpr(e) => {\n                 let path =\n                     e.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n+                let is_assignee_expr = self.is_lowering_assignee_expr;\n                 let record_lit = if let Some(nfl) = e.record_expr_field_list() {\n                     let fields = nfl\n                         .fields()\n@@ -378,9 +384,16 @@ impl ExprCollector<'_> {\n                         })\n                         .collect();\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));\n-                    Expr::RecordLit { path, fields, spread }\n+                    let ellipsis = nfl.dotdot_token().is_some();\n+                    Expr::RecordLit { path, fields, spread, ellipsis, is_assignee_expr }\n                 } else {\n-                    Expr::RecordLit { path, fields: Box::default(), spread: None }\n+                    Expr::RecordLit {\n+                        path,\n+                        fields: Box::default(),\n+                        spread: None,\n+                        ellipsis: false,\n+                        is_assignee_expr,\n+                    }\n                 };\n \n                 self.alloc_expr(record_lit, syntax_ptr)\n@@ -458,14 +471,21 @@ impl ExprCollector<'_> {\n                 )\n             }\n             ast::Expr::BinExpr(e) => {\n+                let op = e.op_kind();\n+                if let Some(ast::BinaryOp::Assignment { op: None }) = op {\n+                    self.is_lowering_assignee_expr = true;\n+                }\n                 let lhs = self.collect_expr_opt(e.lhs());\n+                self.is_lowering_assignee_expr = false;\n                 let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n                 let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n-                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Tuple { exprs, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::BoxExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -477,8 +497,14 @@ impl ExprCollector<'_> {\n \n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n-                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                        let elements = e.map(|expr| self.collect_expr(expr)).collect();\n+                        self.alloc_expr(\n+                            Expr::Array(Array::ElementList {\n+                                elements,\n+                                is_assignee_expr: self.is_lowering_assignee_expr,\n+                            }),\n+                            syntax_ptr,\n+                        )\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);"}, {"sha": "c1b3788acb7d36d97a53272df8228458b139270e", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "patch": "@@ -110,6 +110,7 @@ pub enum Expr {\n     Call {\n         callee: ExprId,\n         args: Box<[ExprId]>,\n+        is_assignee_expr: bool,\n     },\n     MethodCall {\n         receiver: ExprId,\n@@ -138,6 +139,8 @@ pub enum Expr {\n         path: Option<Box<Path>>,\n         fields: Box<[RecordLitField]>,\n         spread: Option<ExprId>,\n+        ellipsis: bool,\n+        is_assignee_expr: bool,\n     },\n     Field {\n         expr: ExprId,\n@@ -196,6 +199,7 @@ pub enum Expr {\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n+        is_assignee_expr: bool,\n     },\n     Unsafe {\n         body: ExprId,\n@@ -211,7 +215,7 @@ pub enum Expr {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n-    ElementList(Box<[ExprId]>),\n+    ElementList { elements: Box<[ExprId]>, is_assignee_expr: bool },\n     Repeat { initializer: ExprId, repeat: ExprId },\n }\n \n@@ -285,7 +289,7 @@ impl Expr {\n                 f(*iterable);\n                 f(*body);\n             }\n-            Expr::Call { callee, args } => {\n+            Expr::Call { callee, args, .. } => {\n                 f(*callee);\n                 args.iter().copied().for_each(f);\n             }\n@@ -339,9 +343,9 @@ impl Expr {\n             | Expr::Box { expr } => {\n                 f(*expr);\n             }\n-            Expr::Tuple { exprs } => exprs.iter().copied().for_each(f),\n+            Expr::Tuple { exprs, .. } => exprs.iter().copied().for_each(f),\n             Expr::Array(a) => match a {\n-                Array::ElementList(exprs) => exprs.iter().copied().for_each(f),\n+                Array::ElementList { elements, .. } => elements.iter().copied().for_each(f),\n                 Array::Repeat { initializer, repeat } => {\n                     f(*initializer);\n                     f(*repeat)"}, {"sha": "642e03edd230636ca3911a0e0eee44dc8989a41e", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "patch": "@@ -305,7 +305,10 @@ pub fn record_literal_missing_fields(\n     expr: &Expr,\n ) -> Option<(VariantId, Vec<LocalFieldId>, /*exhaustive*/ bool)> {\n     let (fields, exhaustive) = match expr {\n-        Expr::RecordLit { path: _, fields, spread } => (fields, spread.is_none()),\n+        Expr::RecordLit { fields, spread, ellipsis, is_assignee_expr, .. } => {\n+            let exhaustive = if *is_assignee_expr { !*ellipsis } else { spread.is_none() };\n+            (fields, exhaustive)\n+        }\n         _ => return None,\n     };\n "}, {"sha": "d164e64a8be0780a0d9b5d54008b648e46b89c18", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "patch": "@@ -276,7 +276,7 @@ impl<'a> InferenceContext<'a> {\n \n                 closure_ty\n             }\n-            Expr::Call { callee, args } => {\n+            Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n                 let mut res = None;\n@@ -421,7 +421,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 TyKind::Never.intern(Interner)\n             }\n-            Expr::RecordLit { path, fields, spread } => {\n+            Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n                 if let Some(variant) = def_id {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n@@ -693,7 +693,7 @@ impl<'a> InferenceContext<'a> {\n                     self.err_ty()\n                 }\n             }\n-            Expr::Tuple { exprs } => {\n+            Expr::Tuple { exprs, .. } => {\n                 let mut tys = match expected\n                     .only_has_type(&mut self.table)\n                     .as_ref()\n@@ -724,12 +724,12 @@ impl<'a> InferenceContext<'a> {\n \n                 let expected = Expectation::has_type(elem_ty.clone());\n                 let len = match array {\n-                    Array::ElementList(items) => {\n-                        for &expr in items.iter() {\n+                    Array::ElementList { elements, .. } => {\n+                        for &expr in elements.iter() {\n                             let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n                             coerce.coerce(self, Some(expr), &cur_elem_ty);\n                         }\n-                        consteval::usize_const(Some(items.len() as u128))\n+                        consteval::usize_const(Some(elements.len() as u128))\n                     }\n                     &Array::Repeat { initializer, repeat } => {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n@@ -850,15 +850,15 @@ impl<'a> InferenceContext<'a> {\n         let rhs_ty = self.resolve_ty_shallow(rhs_ty);\n \n         let ty = match &self.body[lhs] {\n-            Expr::Tuple { exprs } => {\n+            Expr::Tuple { exprs, .. } => {\n                 // We don't consider multiple ellipses. This is analogous to\n                 // `hir_def::body::lower::ExprCollector::collect_tuple_pat()`.\n                 let ellipsis = exprs.iter().position(|e| is_rest_expr(*e));\n                 let exprs: Vec<_> = exprs.iter().filter(|e| !is_rest_expr(**e)).copied().collect();\n \n                 self.infer_tuple_pat_like(&rhs_ty, (), ellipsis, &exprs)\n             }\n-            Expr::Call { callee, args } => {\n+            Expr::Call { callee, args, .. } => {\n                 // Tuple structs\n                 let path = match &self.body[*callee] {\n                     Expr::Path(path) => Some(path),\n@@ -872,7 +872,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.infer_tuple_struct_pat_like(path, &rhs_ty, (), lhs, ellipsis, &args)\n             }\n-            Expr::Array(Array::ElementList(elements)) => {\n+            Expr::Array(Array::ElementList { elements, .. }) => {\n                 let elem_ty = match rhs_ty.kind(Interner) {\n                     TyKind::Array(st, _) => st.clone(),\n                     _ => self.err_ty(),"}, {"sha": "edb1fc0919c242c9f83dc921a488f5b76813e3a4", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/537cc1eec5bc0f26df112c0cdb4a16c793189ab0/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=537cc1eec5bc0f26df112c0cdb4a16c793189ab0", "patch": "@@ -292,6 +292,37 @@ fn x(a: S) {\n         )\n     }\n \n+    #[test]\n+    fn missing_record_expr_in_assignee_expr() {\n+        check_diagnostics(\n+            r\"\n+struct S { s: usize, t: usize }\n+struct S2 { s: S, t: () }\n+struct T(S);\n+fn regular(a: S) {\n+    let s;\n+    S { s, .. } = a;\n+}\n+fn nested(a: S2) {\n+    let s;\n+    S2 { s: S { s, .. }, .. } = a;\n+}\n+fn in_tuple(a: (S,)) {\n+    let s;\n+    (S { s, .. },) = a;\n+}\n+fn in_array(a: [S;1]) {\n+    let s;\n+    [S { s, .. },] = a;\n+}\n+fn in_tuple_struct(a: T) {\n+    let s;\n+    T(S { s, .. }) = a;\n+}\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn range_mapping_out_of_macros() {\n         check_fix("}]}