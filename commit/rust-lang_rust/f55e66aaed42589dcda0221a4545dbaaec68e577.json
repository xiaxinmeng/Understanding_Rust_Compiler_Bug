{"sha": "f55e66aaed42589dcda0221a4545dbaaec68e577", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NWU2NmFhZWQ0MjU4OWRjZGEwMjIxYTQ1NDVkYmFhZWM2OGU1Nzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-13T17:39:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-13T17:39:14Z"}, "message": "Auto merge of #24198 - alexcrichton:windows-readlink, r=aturon\n\nThe current implementation of using GetFinalPathNameByHandle actually reads all\r\nintermediate links instead of just looking at the current link. This commit\r\nalters the behavior of the function to use a different API which correctly reads\r\nonly one level of the soft link.\r\n\r\n[breaking-change]", "tree": {"sha": "3d9a191d7c99815b6183267b31826db2d397d0d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d9a191d7c99815b6183267b31826db2d397d0d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f55e66aaed42589dcda0221a4545dbaaec68e577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f55e66aaed42589dcda0221a4545dbaaec68e577", "html_url": "https://github.com/rust-lang/rust/commit/f55e66aaed42589dcda0221a4545dbaaec68e577", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f55e66aaed42589dcda0221a4545dbaaec68e577/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "588d37c653ddac491c2c1cb8974f56781533b173", "url": "https://api.github.com/repos/rust-lang/rust/commits/588d37c653ddac491c2c1cb8974f56781533b173", "html_url": "https://github.com/rust-lang/rust/commit/588d37c653ddac491c2c1cb8974f56781533b173"}, {"sha": "f3f99fb44eea1d7037f94259aef6cbc39837ebee", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f99fb44eea1d7037f94259aef6cbc39837ebee", "html_url": "https://github.com/rust-lang/rust/commit/f3f99fb44eea1d7037f94259aef6cbc39837ebee"}], "stats": {"total": 77, "additions": 63, "deletions": 14}, "files": [{"sha": "c8f6aca7bd32eb370a43fe668b72aa56f2b95afc", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f55e66aaed42589dcda0221a4545dbaaec68e577/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55e66aaed42589dcda0221a4545dbaaec68e577/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=f55e66aaed42589dcda0221a4545dbaaec68e577", "patch": "@@ -47,6 +47,10 @@ pub const WSAESHUTDOWN: libc::c_int = 10058;\n \n pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n pub const TOKEN_READ: libc::DWORD = 0x20008;\n+pub const FILE_FLAG_OPEN_REPARSE_POINT: libc::DWORD = 0x00200000;\n+pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n+pub const FSCTL_GET_REPARSE_POINT: libc::DWORD = 0x900a8;\n+pub const IO_REPARSE_TAG_SYMLINK: libc::DWORD = 0xa000000c;\n \n // Note that these are not actually HANDLEs, just values to pass to GetStdHandle\n pub const STD_INPUT_HANDLE: libc::DWORD = -10i32 as libc::DWORD;\n@@ -214,6 +218,24 @@ pub struct FILE_END_OF_FILE_INFO {\n     pub EndOfFile: libc::LARGE_INTEGER,\n }\n \n+#[repr(C)]\n+pub struct REPARSE_DATA_BUFFER {\n+    pub ReparseTag: libc::c_uint,\n+    pub ReparseDataLength: libc::c_ushort,\n+    pub Reserved: libc::c_ushort,\n+    pub rest: (),\n+}\n+\n+#[repr(C)]\n+pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n+    pub SubstituteNameOffset: libc::c_ushort,\n+    pub SubstituteNameLength: libc::c_ushort,\n+    pub PrintNameOffset: libc::c_ushort,\n+    pub PrintNameLength: libc::c_ushort,\n+    pub Flags: libc::c_ulong,\n+    pub PathBuffer: libc::WCHAR,\n+}\n+\n #[link(name = \"ws2_32\")]\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n@@ -433,6 +455,14 @@ extern \"system\" {\n     pub fn GetCurrentProcess() -> libc::HANDLE;\n     pub fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n     pub fn ExitProcess(uExitCode: libc::c_uint) -> !;\n+    pub fn DeviceIoControl(hDevice: libc::HANDLE,\n+                           dwIoControlCode: libc::DWORD,\n+                           lpInBuffer: libc::LPVOID,\n+                           nInBufferSize: libc::DWORD,\n+                           lpOutBuffer: libc::LPVOID,\n+                           nOutBufferSize: libc::DWORD,\n+                           lpBytesReturned: libc::LPDWORD,\n+                           lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n }\n \n #[link(name = \"userenv\")]"}, {"sha": "9645c51ec0b2343f085b63c6135d9773a3828f60", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f55e66aaed42589dcda0221a4545dbaaec68e577/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55e66aaed42589dcda0221a4545dbaaec68e577/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=f55e66aaed42589dcda0221a4545dbaaec68e577", "patch": "@@ -19,6 +19,7 @@ use libc::{self, HANDLE};\n use mem;\n use path::{Path, PathBuf};\n use ptr;\n+use slice;\n use sync::Arc;\n use sys::handle::Handle;\n use sys::{c, cvt};\n@@ -364,22 +365,40 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let mut opts = OpenOptions::new();\n     opts.read(true);\n-    let file = try!(File::open(p, &opts));;\n-\n-    // Specify (sz - 1) because the documentation states that it's the size\n-    // without the null pointer\n-    //\n-    // FIXME: I have a feeling that this reads intermediate symlinks as well.\n-    let ret: OsString = try!(super::fill_utf16_buf_new(|buf, sz| unsafe {\n-        GetFinalPathNameByHandleW(file.handle.raw(),\n-                                  buf as *const u16,\n-                                  sz - 1,\n-                                  libc::VOLUME_NAME_DOS)\n-    }, |s| OsStringExt::from_wide(s)));\n-    Ok(PathBuf::from(&ret))\n+    opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT as i32);\n+    let file = try!(File::open(p, &opts));\n+\n+    let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+    let mut bytes = 0;\n+\n+    unsafe {\n+        try!(cvt({\n+            c::DeviceIoControl(file.handle.raw(),\n+                               c::FSCTL_GET_REPARSE_POINT,\n+                               0 as *mut _,\n+                               0,\n+                               space.as_mut_ptr() as *mut _,\n+                               space.len() as libc::DWORD,\n+                               &mut bytes,\n+                               0 as *mut _)\n+        }));\n+        let buf: *const c::REPARSE_DATA_BUFFER = space.as_ptr() as *const _;\n+        if (*buf).ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n+            return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n+        }\n+        let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n+                &(*buf).rest as *const _ as *const _;\n+        let path_buffer = &(*info).PathBuffer as *const _ as *const u16;\n+        let subst_off = (*info).SubstituteNameOffset / 2;\n+        let subst_ptr = path_buffer.offset(subst_off as isize);\n+        let subst_len = (*info).SubstituteNameLength / 2;\n+        let subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n+\n+        Ok(PathBuf::from(OsString::from_wide(subst)))\n+    }\n+\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {"}]}