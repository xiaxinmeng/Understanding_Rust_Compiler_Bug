{"sha": "1ea44663c562ac40fbb81f59698e3861d622695b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYTQ0NjYzYzU2MmFjNDBmYmI4MWY1OTY5OGUzODYxZDYyMjY5NWI=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-08T09:16:47Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-15T09:48:22Z"}, "message": "Elaborate on the details in some comments", "tree": {"sha": "7a4cc3b6adb15e659f9f4efa1b47738f69d955eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4cc3b6adb15e659f9f4efa1b47738f69d955eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ea44663c562ac40fbb81f59698e3861d622695b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea44663c562ac40fbb81f59698e3861d622695b", "html_url": "https://github.com/rust-lang/rust/commit/1ea44663c562ac40fbb81f59698e3861d622695b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ea44663c562ac40fbb81f59698e3861d622695b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658c27b011b88dff18fd0137559123991a05f380", "url": "https://api.github.com/repos/rust-lang/rust/commits/658c27b011b88dff18fd0137559123991a05f380", "html_url": "https://github.com/rust-lang/rust/commit/658c27b011b88dff18fd0137559123991a05f380"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "6008834a5731ca77a9c2036fe3add4a00ea9ea82", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1ea44663c562ac40fbb81f59698e3861d622695b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea44663c562ac40fbb81f59698e3861d622695b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=1ea44663c562ac40fbb81f59698e3861d622695b", "patch": "@@ -361,6 +361,9 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                 // everything as immutable. Creating a promoted with interior mutability is UB, but\n                 // there's no way we can check whether the user is using raw pointers correctly.\n                 // So all we can do is mark this as immutable here.\n+                // It is UB to mutate through a raw pointer obtained via an immutable reference.\n+                // Since all references and pointers inside a promoted must by their very definition\n+                // be created from an immutable reference, mutating though them would be UB.\n                 InternKind::Promoted => {\n                     alloc.mutability = Mutability::Not;\n                 }\n@@ -388,19 +391,27 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // dangling pointer\n             throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         } else if let Some(_) = ecx.tcx.alloc_map.lock().get(alloc_id) {\n-            // If we encounter an `AllocId` that points to a mutable `Allocation`,\n-            // (directly or via relocations in its `Allocation`), we should panic,\n-            // the static rules should prevent this.\n-            // We may hit an `AllocId` that belongs to an already interned static,\n+            // We have hit an `AllocId` that belongs to an already interned static,\n             // and are thus not interning any further.\n-            // But since we are also checking things during interning,\n-            // we should probably continue doing those checks no matter what we encounter.\n \n             // E.g. this should be unreachable for `InternKind::Promoted` except for allocations\n-            // created for string and byte string literals.\n+            // created for string and byte string literals, since these are interned immediately\n+            // at creation time.\n \n-            // FIXME: check if the allocation is ok as per the interning rules as if we interned\n-            // it right here.\n+            // FIXME(oli-obk): Since we are also checking things during interning,\n+            // we should probably continue doing those checks no matter what we encounter.\n+            // So we basically have to check if the allocation is ok as per the interning rules as\n+            // if we interned it right here.\n+            // This should be as simple as\n+            /*\n+            for &(_, ((), reloc)) in alloc.relocations().iter() {\n+                if leftover_allocations.insert(reloc) {\n+                    todo.push(reloc);\n+                }\n+            }\n+            */\n+            // But I (oli-obk) haven't thought about the ramnificatons yet. This also would cause\n+            // compile-time regressions, so we should think about caching these.\n         } else {\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }"}]}