{"sha": "df591a1e48a876653f1f48ed595d1754470d116f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNTkxYTFlNDhhODc2NjUzZjFmNDhlZDU5NWQxNzU0NDcwZDExNmY=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2019-01-01T08:09:51Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2019-01-04T04:21:47Z"}, "message": "doc parsing events", "tree": {"sha": "423a619b45a6c9aacdc09275a731b3255743531e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/423a619b45a6c9aacdc09275a731b3255743531e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df591a1e48a876653f1f48ed595d1754470d116f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df591a1e48a876653f1f48ed595d1754470d116f", "html_url": "https://github.com/rust-lang/rust/commit/df591a1e48a876653f1f48ed595d1754470d116f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df591a1e48a876653f1f48ed595d1754470d116f/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b01e707dba7810c3d28c82a84dec9064cc01d3c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01e707dba7810c3d28c82a84dec9064cc01d3c8", "html_url": "https://github.com/rust-lang/rust/commit/b01e707dba7810c3d28c82a84dec9064cc01d3c8"}], "stats": {"total": 114, "additions": 71, "deletions": 43}, "files": [{"sha": "3487aef850894b4af17721b55c5fcdb5d7051f49", "filename": "crates/ra_syntax/src/parser_api.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs?ref=df591a1e48a876653f1f48ed595d1754470d116f", "patch": "@@ -142,11 +142,13 @@ impl Marker {\n         }\n     }\n \n-    /// Finishes the syntax tree node and assigns `kind` to it.\n+    /// Finishes the syntax tree node and assigns `kind` to it,\n+    /// and mark the create a `CompletedMarker` for possible future\n+    /// operation like `.precede()` to deal with forward_parent.\n     pub(crate) fn complete(mut self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n         self.bomb.defuse();\n         p.0.complete(self.pos, kind);\n-        CompletedMarker(self.pos, kind)\n+        CompletedMarker::new(self.pos, kind)\n     }\n \n     /// Abandons the syntax tree node. All its children\n@@ -160,13 +162,22 @@ impl Marker {\n pub(crate) struct CompletedMarker(u32, SyntaxKind);\n \n impl CompletedMarker {\n-    /// This one is tricky :-)\n+    fn new(pos: u32, kind: SyntaxKind) -> Self {\n+        CompletedMarker(pos, kind)\n+    }\n+\n     /// This method allows to create a new node which starts\n     /// *before* the current one. That is, parser could start\n     /// node `A`, then complete it, and then after parsing the\n     /// whole `A`, decide that it should have started some node\n     /// `B` before starting `A`. `precede` allows to do exactly\n     /// that. See also docs about `forward_parent` in `Event::Start`.\n+    ///\n+    /// Given completed events `[START, FINISH]` and its corresponding\n+    /// `CompletedMarker(pos: 0, _)`.\n+    /// Append a new `START` events as `[START, FINISH, NEWSTART]`,\n+    /// then mark `NEWSTART` as `START`'s parent with saving its relative\n+    /// distance to `NEWSTART` into forward_parent(=2 in this case);\n     pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n         Marker::new(p.0.precede(self.0))\n     }"}, {"sha": "01a51cd8d6d24bec1c0ff064d850d054d02e1ffb", "filename": "crates/ra_syntax/src/parser_impl.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs?ref=df591a1e48a876653f1f48ed595d1754470d116f", "patch": "@@ -63,7 +63,7 @@ pub(crate) fn parse_with<S: Sink>(\n /// to a separate struct in order not to pollute\n /// the public API of the `Parser`.\n pub(crate) struct ParserImpl<'t> {\n-    inp: &'t ParserInput<'t>,\n+    parser_input: &'t ParserInput<'t>,\n     pos: InputPosition,\n     events: Vec<Event>,\n     steps: Cell<u32>,\n@@ -72,7 +72,7 @@ pub(crate) struct ParserImpl<'t> {\n impl<'t> ParserImpl<'t> {\n     pub(crate) fn new(inp: &'t ParserInput<'t>) -> ParserImpl<'t> {\n         ParserImpl {\n-            inp,\n+            parser_input: inp,\n             pos: InputPosition::new(),\n             events: Vec::new(),\n             steps: Cell::new(0),\n@@ -85,10 +85,10 @@ impl<'t> ParserImpl<'t> {\n     }\n \n     pub(super) fn next2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        let c1 = self.inp.kind(self.pos);\n-        let c2 = self.inp.kind(self.pos + 1);\n-        if self.inp.token_start_at(self.pos + 1)\n-            == self.inp.token_start_at(self.pos) + self.inp.len(self.pos)\n+        let c1 = self.parser_input.kind(self.pos);\n+        let c2 = self.parser_input.kind(self.pos + 1);\n+        if self.parser_input.token_start_at(self.pos + 1)\n+            == self.parser_input.token_start_at(self.pos) + self.parser_input.token_len(self.pos)\n         {\n             Some((c1, c2))\n         } else {\n@@ -97,43 +97,42 @@ impl<'t> ParserImpl<'t> {\n     }\n \n     pub(super) fn next3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        let c1 = self.inp.kind(self.pos);\n-        let c2 = self.inp.kind(self.pos + 1);\n-        let c3 = self.inp.kind(self.pos + 2);\n-        if self.inp.token_start_at(self.pos + 1)\n-            == self.inp.token_start_at(self.pos) + self.inp.len(self.pos)\n-            && self.inp.token_start_at(self.pos + 2)\n-                == self.inp.token_start_at(self.pos + 1) + self.inp.len(self.pos + 1)\n+        let c1 = self.parser_input.kind(self.pos);\n+        let c2 = self.parser_input.kind(self.pos + 1);\n+        let c3 = self.parser_input.kind(self.pos + 2);\n+        if self.parser_input.token_start_at(self.pos + 1)\n+            == self.parser_input.token_start_at(self.pos) + self.parser_input.token_len(self.pos)\n+            && self.parser_input.token_start_at(self.pos + 2)\n+                == self.parser_input.token_start_at(self.pos + 1)\n+                    + self.parser_input.token_len(self.pos + 1)\n         {\n             Some((c1, c2, c3))\n         } else {\n             None\n         }\n     }\n \n+    /// Get the syntax kind of the nth token.\n     pub(super) fn nth(&self, n: u32) -> SyntaxKind {\n         let steps = self.steps.get();\n-        if steps > 10_000_000 {\n-            panic!(\"the parser seems stuck\");\n-        }\n+        assert!(steps <= 10_000_000, \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        self.inp.kind(self.pos + n)\n+        self.parser_input.kind(self.pos + n)\n     }\n \n     pub(super) fn at_kw(&self, t: &str) -> bool {\n-        self.inp.text(self.pos) == t\n+        self.parser_input.token_text(self.pos) == t\n     }\n \n+    /// Start parsing right behind the last event.\n     pub(super) fn start(&mut self) -> u32 {\n         let pos = self.events.len() as u32;\n-        self.event(Event::Start {\n-            kind: TOMBSTONE,\n-            forward_parent: None,\n-        });\n+        self.push_event(Event::tombstone());\n         pos\n     }\n \n+    /// Advances the parser by one token unconditionally.\n     pub(super) fn bump(&mut self) {\n         let kind = self.nth(0);\n         if kind == EOF {\n@@ -156,15 +155,17 @@ impl<'t> ParserImpl<'t> {\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n         self.pos += u32::from(n_raw_tokens);\n-        self.event(Event::Token { kind, n_raw_tokens });\n+        self.push_event(Event::Token { kind, n_raw_tokens });\n     }\n \n+    /// Append one Error event to the back of events.\n     pub(super) fn error(&mut self, msg: String) {\n-        self.event(Event::Error {\n+        self.push_event(Event::Error {\n             msg: ParseError(msg),\n         })\n     }\n \n+    /// Complete an event with appending a `Finish` event.\n     pub(super) fn complete(&mut self, pos: u32, kind: SyntaxKind) {\n         match self.events[pos as usize] {\n             Event::Start {\n@@ -174,9 +175,10 @@ impl<'t> ParserImpl<'t> {\n             }\n             _ => unreachable!(),\n         }\n-        self.event(Event::Finish);\n+        self.push_event(Event::Finish);\n     }\n \n+    /// Ignore the dummy `Start` event.\n     pub(super) fn abandon(&mut self, pos: u32) {\n         let idx = pos as usize;\n         if idx == self.events.len() - 1 {\n@@ -190,6 +192,7 @@ impl<'t> ParserImpl<'t> {\n         }\n     }\n \n+    /// Save the relative distance of a completed event to its forward_parent.\n     pub(super) fn precede(&mut self, pos: u32) -> u32 {\n         let new_pos = self.start();\n         match self.events[pos as usize] {\n@@ -204,7 +207,7 @@ impl<'t> ParserImpl<'t> {\n         new_pos\n     }\n \n-    fn event(&mut self, event: Event) {\n+    fn push_event(&mut self, event: Event) {\n         self.events.push(event)\n     }\n }"}, {"sha": "835b2c78dc78537d872eb6d2b56c7e7dbc359de5", "filename": "crates/ra_syntax/src/parser_impl/event.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs?ref=df591a1e48a876653f1f48ed595d1754470d116f", "patch": "@@ -36,7 +36,7 @@ pub(crate) enum Event {\n     ///\n     /// For left-recursive syntactic constructs, the parser produces\n     /// a child node before it sees a parent. `forward_parent`\n-    /// exists to allow to tweak parent-child relationships.\n+    /// saves the position of current event's parent.\n     ///\n     /// Consider this path\n     ///\n@@ -84,6 +84,15 @@ pub(crate) enum Event {\n     },\n }\n \n+impl Event {\n+    pub(crate) fn tombstone() -> Self {\n+        Event::Start {\n+            kind: TOMBSTONE,\n+            forward_parent: None,\n+        }\n+    }\n+}\n+\n pub(super) struct EventProcessor<'a, S: Sink> {\n     sink: S,\n     text_pos: TextUnit,\n@@ -110,17 +119,12 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n         }\n     }\n \n+    /// Generate the syntax tree with the control of events.\n     pub(super) fn process(mut self) -> S {\n-        fn tombstone() -> Event {\n-            Event::Start {\n-                kind: TOMBSTONE,\n-                forward_parent: None,\n-            }\n-        }\n         let mut forward_parents = Vec::new();\n \n         for i in 0..self.events.len() {\n-            match mem::replace(&mut self.events[i], tombstone()) {\n+            match mem::replace(&mut self.events[i], Event::tombstone()) {\n                 Event::Start {\n                     kind: TOMBSTONE, ..\n                 } => (),\n@@ -129,12 +133,18 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                     kind,\n                     forward_parent,\n                 } => {\n+                    // For events[A, B, C], B is A's forward_parent, C is B's forward_parent,\n+                    // in the normal control flow, the parent-child relation: `A -> B -> C`,\n+                    // while with the magic forward_parent, it writes: `C <- B <- A`.\n+\n+                    // append `A` into parents.\n                     forward_parents.push(kind);\n                     let mut idx = i;\n                     let mut fp = forward_parent;\n                     while let Some(fwd) = fp {\n                         idx += fwd as usize;\n-                        fp = match mem::replace(&mut self.events[idx], tombstone()) {\n+                        // append `A`'s forward_parent `B`\n+                        fp = match mem::replace(&mut self.events[idx], Event::tombstone()) {\n                             Event::Start {\n                                 kind,\n                                 forward_parent,\n@@ -144,14 +154,16 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                             }\n                             _ => unreachable!(),\n                         };\n+                        // append `B`'s forward_parent `C` in the next stage.\n                     }\n+\n                     for kind in forward_parents.drain(..).rev() {\n                         self.start(kind);\n                     }\n                 }\n                 Event::Finish => {\n-                    let last = i == self.events.len() - 1;\n-                    self.finish(last);\n+                    let is_last = i == self.events.len() - 1;\n+                    self.finish(is_last);\n                 }\n                 Event::Token { kind, n_raw_tokens } => {\n                     self.eat_trivias();\n@@ -171,6 +183,7 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n         self.sink\n     }\n \n+    /// Add the node into syntax tree but discard the comments/whitespaces.\n     fn start(&mut self, kind: SyntaxKind) {\n         if kind == SOURCE_FILE {\n             self.sink.start_branch(kind);\n@@ -198,8 +211,8 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n         self.eat_n_trivias(n_attached_trivias);\n     }\n \n-    fn finish(&mut self, last: bool) {\n-        if last {\n+    fn finish(&mut self, is_last: bool) {\n+        if is_last {\n             self.eat_trivias()\n         }\n         self.sink.finish_branch();\n@@ -235,6 +248,7 @@ fn n_attached_trivias<'a>(\n     kind: SyntaxKind,\n     trivias: impl Iterator<Item = (SyntaxKind, &'a str)>,\n ) -> usize {\n+    // FIXME: parse attached trivias of CONST_DEF/TYPE_DEF\n     match kind {\n         STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | MODULE => {\n             let mut res = 0;"}, {"sha": "7fde5b3ab19b1734d1f60aea367827510000a00a", "filename": "crates/ra_syntax/src/parser_impl/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df591a1e48a876653f1f48ed595d1754470d116f/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs?ref=df591a1e48a876653f1f48ed595d1754470d116f", "patch": "@@ -70,7 +70,7 @@ impl<'t> ParserInput<'t> {\n         self.start_offsets[idx]\n     }\n \n-    /// Get the raw text of a toen at given input position.\n+    /// Get the raw text of a token at given input position.\n     pub fn token_text(&self, pos: InputPosition) -> &'t str {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {"}]}