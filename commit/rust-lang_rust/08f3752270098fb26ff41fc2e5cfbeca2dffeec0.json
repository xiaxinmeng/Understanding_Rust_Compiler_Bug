{"sha": "08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjM3NTIyNzAwOThmYjI2ZmY0MWZjMmU1Y2ZiZWNhMmRmZmVlYzA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-29T23:19:45Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-08T22:53:41Z"}, "message": "hygiene for `for` loops, `if let`, `while let`\n\nand some unrelated test cleanups", "tree": {"sha": "c5c2b10803e5b85668e09d9aac3054c6aa017c6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c2b10803e5b85668e09d9aac3054c6aa017c6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "html_url": "https://github.com/rust-lang/rust/commit/08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0c74868c3964abdd6898886e7d12041c8b3139d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0c74868c3964abdd6898886e7d12041c8b3139d", "html_url": "https://github.com/rust-lang/rust/commit/e0c74868c3964abdd6898886e7d12041c8b3139d"}], "stats": {"total": 142, "additions": 94, "deletions": 48}, "files": [{"sha": "bdf01f941c4b2cd6843766924bb2926035cb16d5", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -377,7 +377,7 @@ impl RegionMaps {\n         self.code_extents.borrow()[e.0 as usize]\n     }\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for child_id in (1..self.code_extents.borrow().len()) {\n+        for child_id in 1..self.code_extents.borrow().len() {\n             let child = CodeExtent(child_id as u32);\n             if let Some(parent) = self.opt_encl_scope(child) {\n                 e(&child, &parent)"}, {"sha": "9c030d8892ad5d524e398701caa8983300bfe69e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -363,12 +363,10 @@ impl EarlyLintPass for UnusedParens {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n             ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n             ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n-            },\n+            ast::ExprIfLet(_, ref cond, _, _) => (cond, \"`if let` head expression\", true),\n+            ast::ExprWhileLet(_, ref cond, _, _) => (cond, \"`while let` head expression\", true),\n+            ast::ExprForLoop(_, ref cond, _, _) => (cond, \"`for` head expression\", true),\n+            ast::ExprMatch(ref head, _, _) => (head, \"`match` head expression\", true),\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n             ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),"}, {"sha": "705b564a1ad40501c4a01a990b1e76837f9fab5d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -1810,7 +1810,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // There is a possibility that this algorithm will have to run an arbitrary number of times\n         // to terminate so we bound it by the compiler's recursion limit.\n-        for _ in (0..self.tcx().sess.recursion_limit.get()) {\n+        for _ in 0..self.tcx().sess.recursion_limit.get() {\n             // First we try to solve all obligations, it is possible that the last iteration\n             // has made it possible to make more progress.\n             self.select_obligations_where_possible();"}, {"sha": "b1b4605d5ec6573b9702479f4847174ac9dc23cd", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -82,8 +82,18 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n         ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n             let expr = fld.fold_expr(expr);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprWhileLet(pat, expr, body, opt_ident))\n+\n+            // Hygienic renaming of the body.\n+            let ((body, opt_ident), mut rewritten_pats) =\n+                rename_in_scope(vec![pat],\n+                                fld,\n+                                (body, opt_ident),\n+                                |rename_fld, fld, (body, opt_ident)| {\n+                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n+            });\n+            assert!(rewritten_pats.len() == 1);\n+\n+            fld.cx.expr(span, ast::ExprWhileLet(rewritten_pats.remove(0), expr, body, opt_ident))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n@@ -93,9 +103,37 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n+\n+            // Hygienic renaming of the for loop body (for loop binds its pattern).\n+            let ((body, opt_ident), mut rewritten_pats) =\n+                rename_in_scope(vec![pat],\n+                                fld,\n+                                (body, opt_ident),\n+                                |rename_fld, fld, (body, opt_ident)| {\n+                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n+            });\n+            assert!(rewritten_pats.len() == 1);\n+\n             let head = fld.fold_expr(head);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprForLoop(rewritten_pats.remove(0), head, body, opt_ident))\n+        }\n+\n+        ast::ExprIfLet(pat, sub_expr, body, else_opt) => {\n+            let pat = fld.fold_pat(pat);\n+\n+            // Hygienic renaming of the body.\n+            let (body, mut rewritten_pats) =\n+                rename_in_scope(vec![pat],\n+                                fld,\n+                                body,\n+                                |rename_fld, fld, body| {\n+                fld.fold_block(rename_fld.fold_block(body))\n+            });\n+            assert!(rewritten_pats.len() == 1);\n+\n+            let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n+            let sub_expr = fld.fold_expr(sub_expr);\n+            fld.cx.expr(span, ast::ExprIfLet(rewritten_pats.remove(0), sub_expr, body, else_opt))\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {\n@@ -569,18 +607,18 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     if expanded_pats.is_empty() {\n         panic!(\"encountered match arm with 0 patterns\");\n     }\n-    // all of the pats must have the same set of bindings, so use the\n-    // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&*expanded_pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n-    // apply the renaming, but only to the PatIdents:\n-    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n+\n     // apply renaming and then expansion to the guard and the body:\n-    let mut rename_fld = IdentRenamer{renames:&new_renames};\n-    let rewritten_guard =\n-        arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n-    let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n+    let ((rewritten_guard, rewritten_body), rewritten_pats) =\n+        rename_in_scope(expanded_pats,\n+                        fld,\n+                        (arm.guard, arm.body),\n+                        |rename_fld, fld, (ag, ab)|{\n+        let rewritten_guard = ag.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n+        let rewritten_body = fld.fold_expr(rename_fld.fold_expr(ab));\n+        (rewritten_guard, rewritten_body)\n+    });\n+\n     ast::Arm {\n         attrs: fold::fold_attrs(arm.attrs, fld),\n         pats: rewritten_pats,\n@@ -589,6 +627,25 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     }\n }\n \n+fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n+                         fld: &mut MacroExpander,\n+                         x: X,\n+                         f: F)\n+                         -> (X, Vec<P<ast::Pat>>)\n+    where F: Fn(&mut IdentRenamer, &mut MacroExpander, X) -> X\n+{\n+    // all of the pats must have the same set of bindings, so use the\n+    // first one to extract them and generate new names:\n+    let idents = pattern_bindings(&*pats[0]);\n+    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n+    // apply the renaming, but only to the PatIdents:\n+    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n+    let rewritten_pats = pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n+\n+    let mut rename_fld = IdentRenamer{ renames:&new_renames };\n+    (f(&mut rename_fld, fld, x), rewritten_pats)\n+}\n+\n /// A visitor that extracts the PatIdent (binding) paths\n /// from a given thingy and puts them in a mutable\n /// array"}, {"sha": "ce2315f3a38d46e859cdb66a6992097db7c537cc", "filename": "src/test/compile-fail/for-expn-2.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0c74868c3964abdd6898886e7d12041c8b3139d/src%2Ftest%2Fcompile-fail%2Ffor-expn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c74868c3964abdd6898886e7d12041c8b3139d/src%2Ftest%2Fcompile-fail%2Ffor-expn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-expn-2.rs?ref=e0c74868c3964abdd6898886e7d12041c8b3139d", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we get an expansion stack for `for` loops.\n-\n-// error-pattern:in this expansion of for loop expansion\n-\n-fn main() {\n-    for t in &foo {\n-    }\n-}"}, {"sha": "81c4db68628d45517bc966725049aefb6ac0e084", "filename": "src/test/compile-fail/for-loop-refutable-pattern-error-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-refutable-pattern-error-message.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -9,7 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    for\n-        &1 //~ ERROR refutable pattern in `for` loop binding\n-        in [1].iter() {}\n+    for &1 in [1].iter() {} //~ ERROR refutable pattern in `for` loop binding\n }"}, {"sha": "898e6be6fc85c0ce863a590dcc9a0ec8cc635041", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -16,4 +16,17 @@ fn main() -> (){\n     for n in 0..1 {\n         println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n     }\n+\n+    if let Some(n) = None {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n+\n+    if false {\n+    } else if let Some(n) = None {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n+\n+    while let Some(n) = None {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n }"}, {"sha": "ec29a84f44e4bd105019295b97c1bb15c69665c6", "filename": "src/test/compile-fail/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f3752270098fb26ff41fc2e5cfbeca2dffeec0/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs?ref=08f3752270098fb26ff41fc2e5cfbeca2dffeec0", "patch": "@@ -13,10 +13,8 @@\n fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n-    for\n-        [x,y,z]\n-//~^ ERROR refutable pattern in `for` loop binding: `[]` not covered\n-        in values.chunks(3).filter(|&xs| xs.len() == 3) {\n+    for [x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n+        //~^ ERROR refutable pattern in `for` loop binding: `[]` not covered\n         println!(\"y={}\", y);\n     }\n }"}]}