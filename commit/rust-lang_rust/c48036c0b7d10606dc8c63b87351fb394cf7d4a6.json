{"sha": "c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ODAzNmMwYjdkMTA2MDZkYzhjNjNiODczNTFmYjM5NGNmN2Q0YTY=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-12T15:57:21Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-15T22:35:27Z"}, "message": "Make spans into stacks (to store expansion backtraces).", "tree": {"sha": "3fae3a7ca3181cea1f3db955529429241c32a77e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fae3a7ca3181cea1f3db955529429241c32a77e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "html_url": "https://github.com/rust-lang/rust/commit/c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87b56b5565993eec4fb137fe53309ec60873e175", "url": "https://api.github.com/repos/rust-lang/rust/commits/87b56b5565993eec4fb137fe53309ec60873e175", "html_url": "https://github.com/rust-lang/rust/commit/87b56b5565993eec4fb137fe53309ec60873e175"}], "stats": {"total": 129, "additions": 79, "deletions": 50}, "files": [{"sha": "13ea252d9cd13987fead1b39d6e2c8dfd0c99add", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -190,7 +190,7 @@ fn require_unique_names(sess: &session::session,\n }\n \n fn span[T](item: &T) -> ast::spanned[T] {\n-    ret {node: item, span: {lo: 0u, hi: 0u}};\n+    ret {node: item, span: ast::mk_sp(0u, 0u)};\n }\n \n fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {"}, {"sha": "d2153da4c799b29486da7c11a38a39293891ead4", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -160,15 +160,15 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n          attrs: ~[],\n          id: cx.next_node_id(),\n          node: item_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     log #fmt(\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item));\n \n     ret @item;\n }\n \n fn nospan[T](t: &T) -> ast::spanned[T] {\n-    ret {node: t, span: {lo: 0u, hi: 0u}};\n+    ret {node: t, span: ast::dummy_sp()};\n }\n \n fn mk_tests(cx: &test_ctxt) -> @ast::item {\n@@ -198,7 +198,7 @@ fn mk_tests(cx: &test_ctxt) -> @ast::item {\n          attrs: ~[],\n          id: cx.next_node_id(),\n          node: item_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n     ret @item;\n }\n \n@@ -236,7 +236,7 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n \n     ret @{id: cx.next_node_id(),\n           node: ast::expr_vec(descs, ast::imm, ast::sk_unique),\n-          span: {lo: 0u, hi: 0u}};\n+          span: ast::dummy_sp()};\n }\n \n fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n@@ -249,7 +249,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let name_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: ast::expr_lit(@name_lit),\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     let name_field: ast::field =\n         nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n@@ -260,7 +260,7 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let fn_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: ast::expr_path(fn_path),\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     let fn_field: ast::field =\n         nospan({mut: ast::imm, ident: \"fn\", expr: @fn_expr});\n@@ -270,15 +270,15 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let ignore_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: ast::expr_lit(@ignore_lit),\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     let ignore_field: ast::field =\n         nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec(~[name_field, fn_field, ignore_field], option::none);\n     let desc_rec: ast::expr =\n-        {id: cx.next_node_id(), node: desc_rec_, span: {lo: 0u, hi: 0u}};\n+        {id: cx.next_node_id(), node: desc_rec_, span: ast::dummy_sp()};\n     ret @desc_rec;\n }\n \n@@ -307,7 +307,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n         {stmts: ~[],\n          expr: option::some(test_main_call_expr),\n          id: cx.next_node_id()};\n-    let body = {node: body_, span: {lo: 0u, hi: 0u}};\n+    let body = {node: body_, span: ast::dummy_sp()};\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n \n@@ -317,7 +317,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n          attrs: ~[],\n          id: cx.next_node_id(),\n          node: item_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n     ret @item;\n }\n \n@@ -332,7 +332,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let args_path_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: args_path_expr_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n     let test_path: ast::path =\n@@ -343,14 +343,14 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let test_path_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: test_path_expr_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     let test_call_expr_: ast::expr_ = ast::expr_call(@test_path_expr, ~[]);\n \n     let test_call_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: test_call_expr_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     // Call std::test::test_main\n     let test_main_path: ast::path =\n@@ -363,7 +363,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let test_main_path_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: test_main_path_expr_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     let test_main_call_expr_: ast::expr_ =\n         ast::expr_call(@test_main_path_expr,\n@@ -372,7 +372,7 @@ fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n     let test_main_call_expr: ast::expr =\n         {id: cx.next_node_id(),\n          node: test_main_call_expr_,\n-         span: {lo: 0u, hi: 0u}};\n+         span: ast::dummy_sp()};\n \n     ret @test_main_call_expr;\n }"}, {"sha": "23df29199e7f2cfeb4d8a2e16a38bb8e98d4ad94", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -263,7 +263,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n             log \"need to load it\";\n             // This is a new one so we've got to load it\n             // FIXME: Need better error reporting than just a bogus span\n-            let fake_span = {lo: 0u, hi: 0u};\n+            let fake_span = ast::dummy_sp();\n             let local_cnum = resolve_crate(e, cname, ~[], fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n         }"}, {"sha": "6d45ec64afd53ac47be6935dd49d56ceb550b3c4", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -335,7 +335,7 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n             let meta_item = meta_items.(0);\n             attrs +=\n                 ~[{node: {style: ast::attr_outer, value: *meta_item},\n-                   span: {lo: 0u, hi: 0u}}];\n+                   span: ast::dummy_sp()}];\n         }\n       }\n       option::none. { }"}, {"sha": "767941117d47a575d6cde4c40bbb6f96c63d6bc2", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -106,7 +106,7 @@ fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n-                ret respan({lo: 0u, hi: 0u},\n+                ret respan(ast::dummy_sp(),\n                            {global: false, idents: idents, types: ~[]});\n             } else { idents += ~[parse_ident_(st, sd, is_last)]; }\n           }\n@@ -152,8 +152,8 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n \n fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n    @ty::constr_general[T] {\n-    let sp = {lo: 0u, hi: 0u}; // FIXME: use a real span\n-    let args: [@sp_constr_arg[T]] = ~[];\n+    let sp = ast::dummy_sp(); // FIXME: use a real span\n+    let args: [@sp_constr_arg[T]][] = ~[];\n     let pth: path = parse_path(st, sd);\n     let ignore: char = next(st) as char;\n     assert (ignore as char == '(');"}, {"sha": "8f5a81eb72ce41081985d0be94f180c42822f1a8", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -49,7 +49,7 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n     }\n     fn field_patterns_supersede(tcx: &ty::ctxt, fas: &[field_pat],\n                                 fbs: &[field_pat]) -> bool {\n-        let wild = @{id: 0, node: pat_wild, span: {lo: 0u, hi: 0u}};\n+        let wild = @{id: 0, node: pat_wild, span: dummy_sp();\n         for fa: field_pat  in fas {\n             let pb = wild;\n             for fb: field_pat  in fbs {"}, {"sha": "bcd2dc48bbb77abe2589c2928ac5c85e2bae1ecc", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -21,6 +21,7 @@ import middle::ty;\n import middle::ty::field;\n import middle::ty::mt;\n import syntax::ast;\n+import syntax::ast::dummy_sp;\n import syntax::codemap::span;\n import syntax::util::interner;\n import util::common;\n@@ -72,8 +73,6 @@ const shape_uniq : u8 = 22u8;\n // FIXME: This is a bad API in trans_common.\n fn C_u8(n : u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n \n-fn fake_span() -> span { ret { lo: 0u, hi: 0u }; }\n-\n fn hash_res_info(ri : &res_info) -> uint {\n     let h = 5381u;\n     h *= 33u; h += (ri.did.crate as uint);\n@@ -121,7 +120,7 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n                 // when in fact it has minimum size sizeof(int).\n                 bounded = false;\n             } else {\n-                let llty = trans::type_of(ccx, fake_span(), elem_t);\n+                let llty = trans::type_of(ccx, dummy_sp(), elem_t);\n                 min_size += trans::llsize_of_real(ccx, llty);\n                 min_align += trans::llalign_of_real(ccx, llty);\n             }\n@@ -195,7 +194,7 @@ fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &[uint],\n         // We increment a \"virtual data pointer\" to compute the size.\n         let lltys = ~[];\n         for typ : ty::t in variants.(vid).args {\n-            lltys += ~[trans::type_of(ccx, fake_span(), typ)];\n+            lltys += ~[trans::type_of(ccx, dummy_sp(), typ)];\n         }\n \n         let llty = trans_common::T_struct(lltys);\n@@ -412,7 +411,7 @@ fn add_size_hint(ccx : &@crate_ctxt, s : &mutable [u8], typ : ty::t) {\n         ret;\n     }\n \n-    let llty = trans::type_of(ccx, fake_span(), typ);\n+    let llty = trans::type_of(ccx, dummy_sp(), typ);\n     add_u16(s, trans::llsize_of_real(ccx, llty) as u16);\n     s += ~[ trans::llalign_of_real(ccx, llty) as u8 ];\n }\n@@ -523,8 +522,7 @@ fn gen_resource_shapes(ccx : &@crate_ctxt) -> ValueRef {\n     let len = interner::len(ccx.shape_cx.resources);\n     while i < len {\n         let ri = interner::get(ccx.shape_cx.resources, i);\n-        dtors += ~[trans_common::get_res_dtor(ccx, fake_span(), ri.did,\n-                                              ri.t)];\n+        dtors += ~[trans_common::get_res_dtor(ccx, dummy_sp(), ri.did, ri.t)];\n         i += 1u;\n     }\n "}, {"sha": "c93256df350172f070fe84ed92b9f6fa9f2dbe41", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -14,6 +14,7 @@ import trans::new_scope_block_ctxt;\n import trans::load_if_immediate;\n import ty::pat_ty;\n import syntax::ast;\n+import syntax::ast::dummy_sp;\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import util::common::lit_eq;\n@@ -105,7 +106,7 @@ fn enter_default(m: &match, col: uint, val: ValueRef) -> match {\n \n fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n              tag_size: uint, val: ValueRef) -> match {\n-    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(ccx: &@crate_ctxt, dummy: &@ast::pat, opt: &opt, size: uint,\n          p: &@ast::pat) -> option::t[[@ast::pat]] {\n         alt p.node {\n@@ -125,7 +126,7 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n \n fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n    match {\n-    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp();\n     fn e(dummy: &@ast::pat, fields: &[ast::ident], p: &@ast::pat) ->\n        option::t[[@ast::pat]] {\n         alt p.node {\n@@ -159,7 +160,7 @@ fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n }\n \n fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n-    let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n+    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t[[@ast::pat]] {\n         alt p.node {\n           ast::pat_box(sub) { ret some(~[sub]); }\n@@ -310,7 +311,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         let rec_vals = ~[];\n         for field_name: ast::ident in rec_fields {\n             let ix: uint =\n-                ty::field_idx(ccx.sess, {lo: 0u, hi: 0u}, field_name, fields);\n+                ty::field_idx(ccx.sess, dummy_sp(), field_name, fields);\n             let r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n             rec_vals += ~[r.val];\n             bcx = r.bcx;"}, {"sha": "b997b084e87b729ac2f61cac92723f9b2b0b434f", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -9,6 +9,14 @@ import codemap::filename;\n type spanned[T] = {node: T, span: span};\n fn respan[T](sp: &span, t: &T) -> spanned[T] { ret {node: t, span: sp}; }\n \n+/* assuming that we're not in macro expansion */\n+fn mk_sp(lo: uint, hi: uint) -> span {\n+    ret {lo: lo, hi: hi, expanded_from: codemap::os_none};\n+}\n+\n+// make this a const, once the compiler supports it\n+fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n+\n type ident = str;\n // Functions may or may not have names.\n type fn_ident = option::t[ident];"}, {"sha": "e3c061a0bb8d77b39826143b82f4eda016254965", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -65,12 +65,34 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n     ret lookup_pos(map, pos, lookup);\n }\n \n-type span = {lo: uint, hi: uint};\n+tag opt_span { //hack (as opposed to option::t), to make `span` compile\n+    os_none;\n+    os_some(@span);\n+}\n+type span = {lo: uint, hi: uint, expanded_from: opt_span};\n \n fn span_to_str(sp: &span, cm: &codemap) -> str {\n-    let lo = lookup_char_pos(cm, sp.lo);\n-    let hi = lookup_char_pos(cm, sp.hi);\n-    ret #fmt(\"%s:%u:%u:%u:%u\", lo.filename, lo.line, lo.col, hi.line, hi.col);\n+    let cur = sp;\n+    let res = \"\";\n+    let prev_file = none;\n+    while(true) {\n+        let lo = lookup_char_pos(cm, cur.lo);\n+        let hi = lookup_char_pos(cm, cur.hi);\n+        res += #fmt(\"%s:%u:%u:%u:%u\",\n+                    if some(lo.filename) == prev_file { \"-\" }\n+                    else                              { lo.filename },\n+                    lo.line, lo.col, hi.line, hi.col);\n+        alt cur.expanded_from {\n+          os_none. { break; }\n+          os_some(new_sp) {\n+            cur = *new_sp;\n+            prev_file = some(lo.filename);\n+            res += \"<<\";\n+          }\n+        }\n+    }\n+\n+    ret res;\n }\n \n fn emit_diagnostic(sp: &option::t[span], msg: &str, kind: &str, color: u8,"}, {"sha": "4ceb5ba1df59d9797be9b5e40fdf2375a9ef7f6d", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -78,7 +78,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n         fn err(m: str) {\n-            codemap::emit_error(some({lo: chpos, hi: chpos}), m, cm);\n+            codemap::emit_error(some(ast::mk_sp(chpos, chpos)), m, cm);\n         }\n     }\n     let strs: [str] = ~[];"}, {"sha": "f8badc33b6f0a2a57e39346e5c3633c7ebb61925", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48036c0b7d10606dc8c63b87351fb394cf7d4a6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=c48036c0b7d10606dc8c63b87351fb394cf7d4a6", "patch": "@@ -90,7 +90,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n             if ivec::len(buffer) == 0u {\n                 let next = lexer::next_token(rdr);\n                 tok = next.tok;\n-                tok_span = {lo: next.chpos, hi: rdr.get_chpos()};\n+                tok_span = ast::mk_sp(next.chpos, rdr.get_chpos());\n             } else {\n                 let next = ivec::pop(buffer);\n                 tok = next.tok;\n@@ -100,7 +100,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         fn look_ahead(distance: uint) -> token::token {\n             while ivec::len(buffer) < distance {\n                 let next = lexer::next_token(rdr);\n-                let sp = {lo: next.chpos, hi: rdr.get_chpos()};\n+                let sp = ast::mk_sp(next.chpos, rdr.get_chpos());\n                 buffer = ~[{tok: next.tok, span: sp}] + buffer;\n             }\n             ret buffer.(distance - 1u).tok;\n@@ -135,7 +135,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n     }\n \n     let tok0 = lexer::next_token(rdr);\n-    let span0 = {lo: tok0.chpos, hi: rdr.get_chpos()};\n+    let span0 = ast::mk_sp(tok0.chpos, rdr.get_chpos());\n     ret stdio_parser(sess, cfg, ftype, tok0.tok, span0, span0, ~[],\n                      UNRESTRICTED, rdr, prec_table(), bad_expr_word_table());\n }\n@@ -202,7 +202,7 @@ fn expect(p: &parser, t: token::token) {\n }\n \n fn spanned[T](lo: uint, hi: uint, node: &T) -> spanned[T] {\n-    ret {node: node, span: {lo: lo, hi: hi}};\n+    ret {node: node, span: ast::mk_sp(lo, hi)};\n }\n \n fn parse_ident(p: &parser) -> ast::ident {\n@@ -759,13 +759,13 @@ fn parse_field(p: &parser, sep: &token::token) -> ast::field {\n }\n \n fn mk_expr(p: &parser, lo: uint, hi: uint, node: &ast::expr_) -> @ast::expr {\n-    ret @{id: p.get_id(), node: node, span: {lo: lo, hi: hi}};\n+    ret @{id: p.get_id(), node: node, span: ast::mk_sp(lo, hi)};\n }\n \n fn mk_mac_expr(p: &parser, lo: uint, hi: uint, m: &ast::mac_) -> @ast::expr {\n     ret @{id: p.get_id(),\n-          node: ast::expr_mac({node: m, span: {lo: lo, hi: hi}}),\n-          span: {lo: lo, hi: hi}};\n+          node: ast::expr_mac({node: m, span: ast::mk_sp(lo, hi)}),\n+          span: ast::mk_sp(lo, hi)};\n }\n \n fn parse_bottom_expr(p: &parser) -> @ast::expr {\n@@ -1465,7 +1465,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 subpat =\n                     @{id: p.get_id(),\n                       node: ast::pat_bind(fieldname),\n-                      span: {lo: lo, hi: hi}};\n+                      span: ast::mk_sp(lo, hi)};\n             }\n             fields += ~[{ident: fieldname, pat: subpat}];\n         }\n@@ -1524,7 +1524,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n         }\n       }\n     }\n-    ret @{id: p.get_id(), node: pat, span: {lo: lo, hi: hi}};\n+    ret @{id: p.get_id(), node: pat, span: ast::mk_sp(lo, hi)};\n }\n \n fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n@@ -1807,7 +1807,7 @@ fn mk_item(p: &parser, lo: uint, hi: uint, ident: &ast::ident,\n           attrs: attrs,\n           id: p.get_id(),\n           node: node,\n-          span: {lo: lo, hi: hi}};\n+          span: ast::mk_sp(lo, hi)};\n }\n \n fn parse_item_fn_or_iter(p: &parser, purity: ast::purity, proto: ast::proto,\n@@ -1948,7 +1948,7 @@ fn parse_item_native_type(p: &parser, attrs: &[ast::attribute]) ->\n           attrs: attrs,\n           node: ast::native_item_ty,\n           id: p.get_id(),\n-          span: {lo: t.lo, hi: hi}};\n+          span: ast::mk_sp(t.lo, hi)};\n }\n \n fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n@@ -1964,7 +1964,7 @@ fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n           attrs: attrs,\n           node: ast::native_item_fn(link_name, decl, t.tps),\n           id: p.get_id(),\n-          span: {lo: lo, hi: hi}};\n+          span: ast::mk_sp(lo, hi)};\n }\n \n fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->"}]}