{"sha": "b79dada4530378fa4cb744b9da922389131840e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OWRhZGE0NTMwMzc4ZmE0Y2I3NDRiOWRhOTIyMzg5MTMxODQwZTc=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@galois.com", "date": "2017-07-20T20:53:56Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@galois.com", "date": "2017-09-06T14:26:51Z"}, "message": "pprust: fix parenthesization of exprs", "tree": {"sha": "bf9fc8d6db5c0c7bd26e2157d2b9b20ce6c608bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf9fc8d6db5c0c7bd26e2157d2b9b20ce6c608bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b79dada4530378fa4cb744b9da922389131840e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b79dada4530378fa4cb744b9da922389131840e7", "html_url": "https://github.com/rust-lang/rust/commit/b79dada4530378fa4cb744b9da922389131840e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b79dada4530378fa4cb744b9da922389131840e7/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83d20eff734310a0381b7c71e0192988b6b0847", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83d20eff734310a0381b7c71e0192988b6b0847", "html_url": "https://github.com/rust-lang/rust/commit/f83d20eff734310a0381b7c71e0192988b6b0847"}], "stats": {"total": 518, "additions": 417, "deletions": 101}, "files": [{"sha": "91646ce9f8b963ed58d4698d6ed319c5426f16f5", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b79dada4530378fa4cb744b9da922389131840e7/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79dada4530378fa4cb744b9da922389131840e7/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b79dada4530378fa4cb744b9da922389131840e7", "patch": "@@ -22,6 +22,7 @@ use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::symbol::keywords;\n use syntax::ptr::P;\n+use syntax::util::parser;\n use syntax_pos::Span;\n \n use rustc_back::slice;\n@@ -313,47 +314,14 @@ impl UnusedParens {\n                                 msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&inner);\n+            let necessary = struct_lit_needs_parens &&\n+                            parser::contains_exterior_struct_lit(&inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS,\n                              value.span,\n                              &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n-\n-        /// Expressions that syntactically contain an \"exterior\" struct\n-        /// literal i.e. not surrounded by any parens or other\n-        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n-        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n-        /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-            match value.node {\n-                ast::ExprKind::Struct(..) => true,\n-\n-                ast::ExprKind::Assign(ref lhs, ref rhs) |\n-                ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                    // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n-                }\n-                ast::ExprKind::Unary(_, ref x) |\n-                ast::ExprKind::Cast(ref x, _) |\n-                ast::ExprKind::Type(ref x, _) |\n-                ast::ExprKind::Field(ref x, _) |\n-                ast::ExprKind::TupField(ref x, _) |\n-                ast::ExprKind::Index(ref x, _) => {\n-                    // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&x)\n-                }\n-\n-                ast::ExprKind::MethodCall(.., ref exprs) => {\n-                    // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&exprs[0])\n-                }\n-\n-                _ => false,\n-            }\n-        }\n     }\n }\n "}, {"sha": "9903dc50f36fb4480aab744724df83cff444252f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 82, "deletions": 65, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b79dada4530378fa4cb744b9da922389131840e7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79dada4530378fa4cb744b9da922389131840e7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b79dada4530378fa4cb744b9da922389131840e7", "patch": "@@ -14,7 +14,7 @@ use abi::{self, Abi};\n use ast::{self, BlockCheckMode, PatKind, RangeEnd};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n-use util::parser::AssocOp;\n+use util::parser::{self, AssocOp, Fixity};\n use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n@@ -421,16 +421,6 @@ pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n \n-fn needs_parentheses(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Assign(..) | ast::ExprKind::Binary(..) |\n-        ast::ExprKind::Closure(..) |\n-        ast::ExprKind::AssignOp(..) | ast::ExprKind::Cast(..) |\n-        ast::ExprKind::InPlace(..) | ast::ExprKind::Type(..) => true,\n-        _ => false,\n-    }\n-}\n-\n pub trait PrintState<'a> {\n     fn writer(&mut self) -> &mut pp::Printer<'a>;\n     fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n@@ -1736,7 +1726,7 @@ impl<'a> State<'a> {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n-                        self.print_expr(i)?;\n+                        self.print_expr_as_cond(i)?;\n                         self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1749,7 +1739,7 @@ impl<'a> State<'a> {\n                         self.print_pat(pat)?;\n                         self.s.space()?;\n                         self.word_space(\"=\")?;\n-                        self.print_expr(expr)?;\n+                        self.print_expr_as_cond(expr)?;\n                         self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1774,7 +1764,7 @@ impl<'a> State<'a> {\n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n                     elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if\")?;\n-        self.print_expr(test)?;\n+        self.print_expr_as_cond(test)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1786,7 +1776,7 @@ impl<'a> State<'a> {\n         self.print_pat(pat)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n-        self.print_expr(expr)?;\n+        self.print_expr_as_cond(expr)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1821,19 +1811,31 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn check_expr_bin_needs_paren(&mut self, sub_expr: &ast::Expr,\n-                                      binop: ast::BinOp) -> bool {\n-        match sub_expr.node {\n-            ast::ExprKind::Binary(ref sub_op, _, _) => {\n-                AssocOp::from_ast_binop(sub_op.node).precedence() <\n-                    AssocOp::from_ast_binop(binop.node).precedence()\n-            }\n-            _ => true\n+    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n+        let needs_par = parser::expr_precedence(expr) < prec;\n+        if needs_par {\n+            self.popen()?;\n         }\n+        self.print_expr(expr)?;\n+        if needs_par {\n+            self.pclose()?;\n+        }\n+        Ok(())\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr) -> io::Result<()> {\n-        let needs_par = needs_parentheses(expr);\n+    /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    pub fn print_expr_as_cond(&mut self, expr: &ast::Expr) -> io::Result<()> {\n+        let needs_par = match expr.node {\n+            // These cases need parens due to the parse error observed in #26461: `if return {}`\n+            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::Ret(..) |\n+            ast::ExprKind::Break(..) => true,\n+\n+            _ => parser::contains_exterior_struct_lit(expr),\n+        };\n+\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1847,10 +1849,11 @@ impl<'a> State<'a> {\n     fn print_expr_in_place(&mut self,\n                            place: &ast::Expr,\n                            expr: &ast::Expr) -> io::Result<()> {\n-        self.print_expr_maybe_paren(place)?;\n+        let prec = AssocOp::Inplace.precedence() as i8;\n+        self.print_expr_maybe_paren(place, prec + 1)?;\n         self.s.space()?;\n         self.word_space(\"<-\")?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, prec)\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n@@ -1931,15 +1934,22 @@ impl<'a> State<'a> {\n     fn print_expr_call(&mut self,\n                        func: &ast::Expr,\n                        args: &[P<ast::Expr>]) -> io::Result<()> {\n-        self.print_expr_maybe_paren(func)?;\n+        let prec =\n+            match func.node {\n+                ast::ExprKind::Field(..) |\n+                ast::ExprKind::TupField(..) => parser::PREC_FORCE_PAREN,\n+                _ => parser::PREC_POSTFIX,\n+            };\n+\n+        self.print_expr_maybe_paren(func, prec)?;\n         self.print_call_post(args)\n     }\n \n     fn print_expr_method_call(&mut self,\n                               segment: &ast::PathSegment,\n                               args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n-        self.print_expr(&args[0])?;\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_ident(segment.identifier)?;\n         if let Some(ref parameters) = segment.parameters {\n@@ -1952,33 +1962,35 @@ impl<'a> State<'a> {\n                          op: ast::BinOp,\n                          lhs: &ast::Expr,\n                          rhs: &ast::Expr) -> io::Result<()> {\n-        if self.check_expr_bin_needs_paren(lhs, op) {\n-            self.print_expr_maybe_paren(lhs)?;\n-        } else {\n-            self.print_expr(lhs)?;\n-        }\n+        let assoc_op = AssocOp::from_ast_binop(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec)?;\n         self.s.space()?;\n         self.word_space(op.node.to_string())?;\n-        if self.check_expr_bin_needs_paren(rhs, op) {\n-            self.print_expr_maybe_paren(rhs)\n-        } else {\n-            self.print_expr(rhs)\n-        }\n+        self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self,\n                         op: ast::UnOp,\n                         expr: &ast::Expr) -> io::Result<()> {\n         self.s.word(ast::UnOp::to_string(op))?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: ast::Mutability,\n                           expr: &ast::Expr) -> io::Result<()> {\n         self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n@@ -2002,7 +2014,7 @@ impl<'a> State<'a> {\n         match expr.node {\n             ast::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n             ast::ExprKind::InPlace(ref place, ref expr) => {\n                 self.print_expr_in_place(place, expr)?;\n@@ -2038,17 +2050,15 @@ impl<'a> State<'a> {\n                 self.print_literal(lit)?;\n             }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n-                if let ast::ExprKind::Cast(..) = expr.node {\n-                    self.print_expr(expr)?;\n-                } else {\n-                    self.print_expr_maybe_paren(expr)?;\n-                }\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(ty)?;\n             }\n             ast::ExprKind::Type(ref expr, ref ty) => {\n-                self.print_expr(expr)?;\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n             }\n@@ -2064,7 +2074,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n-                self.print_expr(test)?;\n+                self.print_expr_as_cond(test)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n@@ -2077,7 +2087,7 @@ impl<'a> State<'a> {\n                 self.print_pat(pat)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_as_cond(expr)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n@@ -2090,7 +2100,7 @@ impl<'a> State<'a> {\n                 self.print_pat(pat)?;\n                 self.s.space()?;\n                 self.word_space(\"in\")?;\n-                self.print_expr(iter)?;\n+                self.print_expr_as_cond(iter)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n@@ -2107,7 +2117,7 @@ impl<'a> State<'a> {\n                 self.cbox(INDENT_UNIT)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_as_cond(expr)?;\n                 self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs)?;\n@@ -2137,45 +2147,52 @@ impl<'a> State<'a> {\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.print_expr(lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(rhs)?;\n+                self.print_expr_maybe_paren(rhs, prec)?;\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                self.print_expr(lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.to_string())?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(rhs)?;\n+                self.print_expr_maybe_paren(rhs, prec)?;\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_ident(id.node)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(index)?;\n                 self.s.word(\"]\")?;\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n+                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n+                // Here we use a fake precedence value so that any child with lower precedence than\n+                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                let fake_prec = AssocOp::LOr.precedence() as i8;\n                 if let Some(ref e) = *start {\n-                    self.print_expr(e)?;\n+                    self.print_expr_maybe_paren(e, fake_prec)?;\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n                     self.s.word(\"..\")?;\n                 } else {\n                     self.s.word(\"...\")?;\n                 }\n                 if let Some(ref e) = *end {\n-                    self.print_expr(e)?;\n+                    self.print_expr_maybe_paren(e, fake_prec)?;\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n@@ -2192,7 +2209,7 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n@@ -2208,7 +2225,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"return\")?;\n                 if let Some(ref expr) = *result {\n                     self.s.word(\" \")?;\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n@@ -2286,13 +2303,13 @@ impl<'a> State<'a> {\n                 match *e {\n                     Some(ref expr) => {\n                         self.s.space()?;\n-                        self.print_expr(&expr)?;\n+                        self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     }\n                     _ => ()\n                 }\n             }\n             ast::ExprKind::Try(ref e) => {\n-                self.print_expr(e)?;\n+                self.print_expr_maybe_paren(e, parser::PREC_POSTFIX)?;\n                 self.s.word(\"?\")?\n             }\n             ast::ExprKind::Catch(ref blk) => {"}, {"sha": "af42b4be6941a42f343a1ec1c7ee587252d0d6ba", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b79dada4530378fa4cb744b9da922389131840e7/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79dada4530378fa4cb744b9da922389131840e7/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=b79dada4530378fa4cb744b9da922389131840e7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n-use ast::BinOpKind;\n+use ast::{self, BinOpKind, ExprKind};\n \n /// Associative operator with precedence.\n ///\n@@ -215,3 +215,107 @@ impl AssocOp {\n         }\n     }\n }\n+\n+pub const PREC_RESET: i8 = -100;\n+pub const PREC_CLOSURE: i8 = -40;\n+pub const PREC_JUMP: i8 = -30;\n+pub const PREC_BLOCK: i8 = -20;\n+pub const PREC_RANGE: i8 = -10;\n+// The range 2 ... 14 is reserved for AssocOp binary operator precedences.\n+pub const PREC_PREFIX: i8 = 50;\n+pub const PREC_POSTFIX: i8 = 60;\n+pub const PREC_PAREN: i8 = 99;\n+pub const PREC_FORCE_PAREN: i8 = 100;\n+\n+pub fn expr_precedence(expr: &ast::Expr) -> i8 {\n+    match expr.node {\n+        ExprKind::Closure(..) => PREC_CLOSURE,\n+\n+        ExprKind::Break(..) |\n+        ExprKind::Continue(..) |\n+        ExprKind::Ret(..) |\n+        ExprKind::Yield(..) => PREC_JUMP,\n+\n+        ExprKind::If(..) |\n+        ExprKind::IfLet(..) |\n+        ExprKind::While(..) |\n+        ExprKind::WhileLet(..) |\n+        ExprKind::ForLoop(..) |\n+        ExprKind::Loop(..) |\n+        ExprKind::Match(..) |\n+        ExprKind::Block(..) |\n+        ExprKind::Catch(..) => PREC_BLOCK,\n+\n+        // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to parse,\n+        // instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence ensures that\n+        // `pprust` will add parentheses in the right places to get the desired parse.\n+        ExprKind::Range(..) => PREC_RANGE,\n+\n+        // Binop-like expr kinds, handled by `AssocOp`.\n+        ExprKind::Binary(op, _, _) =>\n+            AssocOp::from_ast_binop(op.node).precedence() as i8,\n+\n+        ExprKind::InPlace(..) => AssocOp::Inplace.precedence() as i8,\n+        ExprKind::Cast(..) => AssocOp::As.precedence() as i8,\n+        ExprKind::Type(..) => AssocOp::Colon.precedence() as i8,\n+\n+        ExprKind::Assign(..) |\n+        ExprKind::AssignOp(..) => AssocOp::Assign.precedence() as i8,\n+\n+        // Unary, prefix\n+        ExprKind::Box(..) |\n+        ExprKind::AddrOf(..) |\n+        ExprKind::Unary(..) => PREC_PREFIX,\n+\n+        // Unary, postfix\n+        ExprKind::Call(..) |\n+        ExprKind::MethodCall(..) |\n+        ExprKind::Field(..) |\n+        ExprKind::TupField(..) |\n+        ExprKind::Index(..) |\n+        ExprKind::Try(..) |\n+        ExprKind::InlineAsm(..) |\n+        ExprKind::Mac(..) => PREC_POSTFIX,\n+\n+        // Never need parens\n+        ExprKind::Array(..) |\n+        ExprKind::Repeat(..) |\n+        ExprKind::Tup(..) |\n+        ExprKind::Lit(..) |\n+        ExprKind::Path(..) |\n+        ExprKind::Paren(..) |\n+        ExprKind::Struct(..) => PREC_PAREN,\n+    }\n+}\n+\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n+/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n+pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+    match value.node {\n+        ast::ExprKind::Struct(..) => true,\n+\n+        ast::ExprKind::Assign(ref lhs, ref rhs) |\n+        ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+        ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+            // X { y: 1 } + X { y: 2 }\n+            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+        }\n+        ast::ExprKind::Unary(_, ref x) |\n+        ast::ExprKind::Cast(ref x, _) |\n+        ast::ExprKind::Type(ref x, _) |\n+        ast::ExprKind::Field(ref x, _) |\n+        ast::ExprKind::TupField(ref x, _) |\n+        ast::ExprKind::Index(ref x, _) => {\n+            // &X { y: 1 }, X { y: 1 }.y\n+            contains_exterior_struct_lit(&x)\n+        }\n+\n+        ast::ExprKind::MethodCall(.., ref exprs) => {\n+            // X { y: 1 }.bar(...)\n+            contains_exterior_struct_lit(&exprs[0])\n+        }\n+\n+        _ => false,\n+    }\n+}"}, {"sha": "d614f452b0d59fd5e26ae7b893454d442aac1bcd", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/b79dada4530378fa4cb744b9da922389131840e7/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79dada4530378fa4cb744b9da922389131840e7/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=b79dada4530378fa4cb744b9da922389131840e7", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-cross-compile\n+\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+\n+use syntax::ast::*;\n+use syntax::codemap::{Spanned, DUMMY_SP};\n+use syntax::codemap::FilePathMapping;\n+use syntax::fold::{self, Folder};\n+use syntax::parse::{self, ParseSess};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::util::ThinVec;\n+\n+\n+fn parse_expr(ps: &ParseSess, src: &str) -> P<Expr> {\n+    let mut p = parse::new_parser_from_source_str(ps,\n+                                                  \"<expr>\".to_owned(),\n+                                                  src.to_owned());\n+    p.parse_expr().unwrap()\n+}\n+\n+\n+// Helper functions for building exprs\n+fn expr(kind: ExprKind) -> P<Expr> {\n+    P(Expr {\n+        id: DUMMY_NODE_ID,\n+        node: kind,\n+        span: DUMMY_SP,\n+        attrs: ThinVec::new(),\n+    })\n+}\n+\n+fn make_x() -> P<Expr> {\n+    let seg = PathSegment {\n+        identifier: Ident::from_str(\"x\"),\n+        span: DUMMY_SP,\n+        parameters: None,\n+    };\n+    let path = Path {\n+        span: DUMMY_SP,\n+        segments: vec![seg],\n+    };\n+    expr(ExprKind::Path(None, path))\n+}\n+\n+/// Iterate over exprs of depth up to `depth`.  The goal is to explore all \"interesting\"\n+/// combinations of expression nesting.  For example, we explore combinations using `if`, but not\n+/// `while` or `match`, since those should print and parse in much the same way as `if`.\n+fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n+    if depth == 0 {\n+        f(make_x());\n+        return;\n+    }\n+\n+    let mut g = |e| f(expr(e));\n+\n+    for kind in 0 .. 17 {\n+        match kind {\n+            0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n+            1 => {\n+                // Note that for binary expressions, we explore each side separately.  The\n+                // parenthesization decisions for the LHS and RHS should be independent, and this\n+                // way produces `O(n)` results instead of `O(n^2)`.\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::InPlace(e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::InPlace(make_x(), e)));\n+            },\n+            2 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n+            3 => {\n+                let seg = PathSegment {\n+                    identifier: Ident::from_str(\"x\"),\n+                    span: DUMMY_SP,\n+                    parameters: None,\n+                };\n+\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n+                            seg.clone(), vec![e, make_x()])));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n+                            seg.clone(), vec![make_x(), e])));\n+            },\n+            4 => {\n+                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Add };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n+            },\n+            5 => {\n+                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Mul };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n+            },\n+            6 => {\n+                let op = Spanned { span: DUMMY_SP, node: BinOpKind::Shl };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n+            },\n+            7 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Unary(UnOp::Deref, e)));\n+            },\n+            8 => {\n+                let block = P(Block {\n+                    stmts: Vec::new(),\n+                    id: DUMMY_NODE_ID,\n+                    rules: BlockCheckMode::Default,\n+                    span: DUMMY_SP,\n+                });\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n+            },\n+            9 => {\n+                let decl = P(FnDecl {\n+                    inputs: vec![],\n+                    output: FunctionRetTy::Default(DUMMY_SP),\n+                    variadic: false,\n+                });\n+                iter_exprs(depth - 1, &mut |e| g(\n+                        ExprKind::Closure(CaptureBy::Value, decl.clone(), e, DUMMY_SP)));\n+            },\n+            10 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x())));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e)));\n+            },\n+            11 => {\n+                let ident = Spanned { span: DUMMY_SP, node: Ident::from_str(\"f\") };\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, ident)));\n+            },\n+            12 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n+                            Some(e), Some(make_x()), RangeLimits::HalfOpen)));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n+                            Some(make_x()), Some(e), RangeLimits::HalfOpen)));\n+            },\n+            13 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::AddrOf(Mutability::Immutable, e)));\n+            },\n+            14 => {\n+                g(ExprKind::Ret(None));\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n+            },\n+            15 => {\n+                let seg = PathSegment {\n+                    identifier: Ident::from_str(\"S\"),\n+                    span: DUMMY_SP,\n+                    parameters: None,\n+                };\n+                let path = Path {\n+                    span: DUMMY_SP,\n+                    segments: vec![seg],\n+                };\n+                g(ExprKind::Struct(path, vec![], Some(make_x())));\n+            },\n+            16 => {\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n+            },\n+            _ => panic!(\"bad counter value in iter_exprs\"),\n+        }\n+    }\n+}\n+\n+\n+// Folders for manipulating the placement of `Paren` nodes.  See below for why this is needed.\n+\n+/// Folder that removes all `ExprKind::Paren` nodes.\n+struct RemoveParens;\n+\n+impl Folder for RemoveParens {\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        let e = match e.node {\n+            ExprKind::Paren(ref inner) => inner.clone(),\n+            _ => e.clone(),\n+        };\n+        e.map(|e| fold::noop_fold_expr(e, self))\n+    }\n+}\n+\n+\n+/// Folder that inserts `ExprKind::Paren` nodes around every `Expr`.\n+struct AddParens;\n+\n+impl Folder for AddParens {\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        let e = e.map(|e| fold::noop_fold_expr(e, self));\n+        P(Expr {\n+            id: DUMMY_NODE_ID,\n+            node: ExprKind::Paren(e),\n+            span: DUMMY_SP,\n+            attrs: ThinVec::new(),\n+        })\n+    }\n+}\n+\n+\n+fn main() {\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+\n+    iter_exprs(2, &mut |e| {\n+        // If the pretty printer is correct, then `parse(print(e))` should be identical to `e`,\n+        // modulo placement of `Paren` nodes.\n+        let printed = pprust::expr_to_string(&e);\n+        println!(\"printed: {}\", printed);\n+\n+        let parsed = parse_expr(&ps, &printed);\n+\n+        // We want to know if `parsed` is structurally identical to `e`, ignoring trivial\n+        // differences like placement of `Paren`s or the exact ranges of node spans.\n+        // Unfortunately, there is no easy way to make this comparison.  Instead, we add `Paren`s\n+        // everywhere we can, then pretty-print.  This should give an unambiguous representation of\n+        // each `Expr`, and it bypasses nearly all of the parenthesization logic, so we aren't\n+        // relying on the correctness of the very thing we're testing.\n+        let e1 = AddParens.fold_expr(RemoveParens.fold_expr(e));\n+        let text1 = pprust::expr_to_string(&e1);\n+        let e2 = AddParens.fold_expr(RemoveParens.fold_expr(parsed));\n+        let text2 = pprust::expr_to_string(&e2);\n+        assert!(text1 == text2,\n+                \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n+                text1, text2);\n+    });\n+}"}]}