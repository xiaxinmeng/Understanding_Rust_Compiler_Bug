{"sha": "270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MDg5NDY3ODc5MmZhOWEzMGFjYzZlYmMzYTEzY2FmNWZhMGI5YzY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-03T10:51:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-09T11:11:12Z"}, "message": "pass full InstanceDef to run_passes", "tree": {"sha": "6daade49d868d35f57caf4704874258965f97aee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6daade49d868d35f57caf4704874258965f97aee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "html_url": "https://github.com/rust-lang/rust/commit/270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd2169682e456f8d8cd3d505b2206d4ed07ecd07", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd2169682e456f8d8cd3d505b2206d4ed07ecd07", "html_url": "https://github.com/rust-lang/rust/commit/cd2169682e456f8d8cd3d505b2206d4ed07ecd07"}], "stats": {"total": 115, "additions": 60, "deletions": 55}, "files": [{"sha": "cc09b2ca530e1ea2bd0d9b3c7de88f5f8c98f1b6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -2428,7 +2428,7 @@ pub struct TypeckMir;\n \n impl MirPass for TypeckMir {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n-        let def_id = src.def_id;\n+        let def_id = src.def_id();\n         debug!(\"run_pass: {:?}\", def_id);\n \n         // When NLL is enabled, the borrow checker runs the typeck"}, {"sha": "7f3e4a2e1bc4f141011cc70647273842bae869d3", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -116,7 +116,7 @@ fn make_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n \n-    run_passes(tcx, &mut result, instance.def_id(), MirPhase::Const, &[\n+    run_passes(tcx, &mut result, instance, MirPhase::Const, &[\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n         &no_landing_pads::NoLandingPads,\n         &remove_noop_landing_pads::RemoveNoopLandingPads,"}, {"sha": "fd31ba0422b5709399bc8b1f08009140527e9456", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -46,7 +46,7 @@ impl MirPass for AddMovesForPackedDrops {\n                           mir: &mut Mir<'tcx>)\n     {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, mir.span);\n-        add_moves_for_packed_drops(tcx, mir, src.def_id);\n+        add_moves_for_packed_drops(tcx, mir, src.def_id());\n     }\n }\n "}, {"sha": "018f71c39e513793ea9b9c3e18e875e7415e19ad", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -30,31 +30,31 @@ pub struct ConstProp;\n impl MirPass for ConstProp {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n+                          source: MirSource<'tcx>,\n                           mir: &mut Mir<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n         }\n \n         use rustc::hir::map::blocks::FnLikeNode;\n-        let node_id = tcx.hir().as_local_node_id(source.def_id)\n+        let node_id = tcx.hir().as_local_node_id(source.def_id())\n                              .expect(\"Non-local call to local provider is_const_fn\");\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(node_id)).is_some();\n-        let is_assoc_const = match tcx.describe_def(source.def_id) {\n+        let is_assoc_const = match tcx.describe_def(source.def_id()) {\n             Some(Def::AssociatedConst(_)) => true,\n             _ => false,\n         };\n \n         // Only run const prop on functions, methods, closures and associated constants\n         if !is_fn_like && !is_assoc_const  {\n             // skip anon_const/statics/consts because they'll be evaluated by miri anyway\n-            trace!(\"ConstProp skipped for {:?}\", source.def_id);\n+            trace!(\"ConstProp skipped for {:?}\", source.def_id());\n             return\n         }\n \n-        trace!(\"ConstProp starting for {:?}\", source.def_id);\n+        trace!(\"ConstProp starting for {:?}\", source.def_id());\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n@@ -63,7 +63,7 @@ impl MirPass for ConstProp {\n         let mut optimization_finder = ConstPropagator::new(mir, tcx, source);\n         optimization_finder.visit_mir(mir);\n \n-        trace!(\"ConstProp done for {:?}\", source.def_id);\n+        trace!(\"ConstProp done for {:?}\", source.def_id());\n     }\n }\n \n@@ -74,7 +74,7 @@ struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     ecx: EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     mir: &'mir Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    source: MirSource,\n+    source: MirSource<'tcx>,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n     param_env: ParamEnv<'tcx>,\n@@ -107,10 +107,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn new(\n         mir: &'mir Mir<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        source: MirSource,\n+        source: MirSource<'tcx>,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n-        let param_env = tcx.param_env(source.def_id);\n-        let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id), param_env);\n+        let param_env = tcx.param_env(source.def_id());\n+        let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n         ConstPropagator {\n             ecx,\n             mir,\n@@ -284,13 +284,13 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 _ => None,\n             },\n             Place::Promoted(ref promoted) => {\n-                let generics = self.tcx.generics_of(self.source.def_id);\n+                let generics = self.tcx.generics_of(self.source.def_id());\n                 if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n                     return None;\n                 }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n+                let substs = Substs::identity_for_item(self.tcx, self.source.def_id());\n+                let instance = Instance::new(self.source.def_id(), substs);\n                 let cid = GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n@@ -358,10 +358,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 )))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n-                let def_id = if self.tcx.is_closure(self.source.def_id) {\n-                    self.tcx.closure_base_def_id(self.source.def_id)\n+                let def_id = if self.tcx.is_closure(self.source.def_id()) {\n+                    self.tcx.closure_base_def_id(self.source.def_id())\n                 } else {\n-                    self.source.def_id\n+                    self.source.def_id()\n                 };\n                 let generics = self.tcx.generics_of(def_id);\n                 if generics.requires_monomorphization(self.tcx) {\n@@ -398,10 +398,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n                 trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n                 let right = self.eval_operand(right, source_info)?;\n-                let def_id = if self.tcx.is_closure(self.source.def_id) {\n-                    self.tcx.closure_base_def_id(self.source.def_id)\n+                let def_id = if self.tcx.is_closure(self.source.def_id()) {\n+                    self.tcx.closure_base_def_id(self.source.def_id())\n                 } else {\n-                    self.source.def_id\n+                    self.source.def_id()\n                 };\n                 let generics = self.tcx.generics_of(def_id);\n                 if generics.requires_monomorphization(self.tcx) {\n@@ -608,7 +608,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                     let node_id = self\n                         .tcx\n                         .hir()\n-                        .as_local_node_id(self.source.def_id)\n+                        .as_local_node_id(self.source.def_id())\n                         .expect(\"some part of a failing const eval must be local\");\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     let msg = match msg {"}, {"sha": "b3f72e3a7fc4eb18832aaffc8b309fedf744ec72", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -28,8 +28,8 @@ impl MirPass for ElaborateDrops {\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n \n-        let id = tcx.hir().as_local_node_id(src.def_id).unwrap();\n-        let param_env = tcx.param_env(src.def_id).with_reveal_all();\n+        let id = tcx.hir().as_local_node_id(src.def_id()).unwrap();\n+        let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n         let move_data = match MoveData::gather_moves(mir, tcx) {\n             Ok(move_data) => move_data,\n             Err((move_data, _move_errors)) => {"}, {"sha": "ae2ba55c5083c3ba705c241bf72616d9008d4914", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -383,7 +383,7 @@ fn locals_live_across_suspend_points(\n     FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n-    let node_id = tcx.hir().as_local_node_id(source.def_id).unwrap();\n+    let node_id = tcx.hir().as_local_node_id(source.def_id()).unwrap();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n@@ -880,7 +880,7 @@ impl MirPass for StateTransform {\n \n         assert!(mir.generator_drop.is_none());\n \n-        let def_id = source.def_id;\n+        let def_id = source.def_id();\n \n         // The first argument is the generator type passed by value\n         let gen_ty = mir.local_decls.raw[1].ty;"}, {"sha": "4cb782669846635c0cd99d834c16d5ad5b73de04", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -40,7 +40,7 @@ struct CallSite<'tcx> {\n impl MirPass for Inline {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n+                          source: MirSource<'tcx>,\n                           mir: &mut Mir<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(mir);\n@@ -50,7 +50,7 @@ impl MirPass for Inline {\n \n struct Inliner<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    source: MirSource,\n+    source: MirSource<'tcx>,\n }\n \n impl<'a, 'tcx> Inliner<'a, 'tcx> {\n@@ -69,10 +69,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let mut callsites = VecDeque::new();\n \n-        let param_env = self.tcx.param_env(self.source.def_id);\n+        let param_env = self.tcx.param_env(self.source.def_id());\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().as_local_node_id(self.source.def_id).unwrap();\n+        let id = self.tcx.hir().as_local_node_id(self.source.def_id()).unwrap();\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) = self.get_valid_function_call(bb,\n@@ -274,7 +274,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         // FIXME: Give a bonus to functions with only a single caller\n \n-        let param_env = tcx.param_env(self.source.def_id);\n+        let param_env = tcx.param_env(self.source.def_id());\n \n         let mut first_block = true;\n         let mut cost = 0;"}, {"sha": "44061e689b3be336a1a8a5c535d666377549c88f", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::nll::type_check;\n use crate::build;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::{Mir, MirPhase, Promoted};\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, InstanceDef};\n use rustc::ty::query::Providers;\n use rustc::ty::steal::Steal;\n use rustc::hir;\n@@ -104,20 +104,25 @@ fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n \n /// Where a specific Mir comes from.\n #[derive(Debug, Copy, Clone)]\n-pub struct MirSource {\n-    pub def_id: DefId,\n+pub struct MirSource<'tcx> {\n+    pub instance: InstanceDef<'tcx>,\n \n     /// If `Some`, this is a promoted rvalue within the parent function.\n     pub promoted: Option<Promoted>,\n }\n \n-impl MirSource {\n+impl<'tcx> MirSource<'tcx> {\n     pub fn item(def_id: DefId) -> Self {\n         MirSource {\n-            def_id,\n+            instance: InstanceDef::Item(def_id),\n             promoted: None\n         }\n     }\n+\n+    #[inline]\n+    pub fn def_id(&self) -> DefId {\n+        self.instance.def_id()\n+    }\n }\n \n /// Generates a default name for the pass based on the name of the\n@@ -141,14 +146,14 @@ pub trait MirPass {\n \n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n+                          source: MirSource<'tcx>,\n                           mir: &mut Mir<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &mut Mir<'tcx>,\n-    def_id: DefId,\n+    instance: InstanceDef<'tcx>,\n     mir_phase: MirPhase,\n     passes: &[&dyn MirPass],\n ) {\n@@ -160,7 +165,7 @@ pub fn run_passes(\n         }\n \n         let source = MirSource {\n-            def_id,\n+            instance,\n             promoted,\n         };\n         let mut index = 0;\n@@ -198,7 +203,7 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     let _ = tcx.unsafety_check_result(def_id);\n \n     let mut mir = tcx.mir_built(def_id).steal();\n-    run_passes(tcx, &mut mir, def_id, MirPhase::Const, &[\n+    run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &type_check::TypeckMir,\n@@ -217,7 +222,7 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     }\n \n     let mut mir = tcx.mir_const(def_id).steal();\n-    run_passes(tcx, &mut mir, def_id, MirPhase::Validated, &[\n+    run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n         &qualify_consts::QualifyAndPromoteConstants,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n@@ -235,7 +240,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     }\n \n     let mut mir = tcx.mir_validated(def_id).steal();\n-    run_passes(tcx, &mut mir, def_id, MirPhase::Optimized, &[\n+    run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Optimized, &[\n         // Remove all things not needed by analysis\n         &no_landing_pads::NoLandingPads,\n         &simplify_branches::SimplifyBranches::new(\"initial\"),"}, {"sha": "9b5c4f51a91a34927bfd25920f0188a75e5f214f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -1171,7 +1171,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             return;\n         }\n \n-        let def_id = src.def_id;\n+        let def_id = src.def_id();\n         let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n         let mode = match tcx.hir().body_owner_kind(id) {"}, {"sha": "d9a5d2fe8ce0b73289f5f2b0a606428e7dab2f19", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -25,7 +25,7 @@ pub struct SanityCheck;\n impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource, mir: &mut Mir<'tcx>) {\n-        let def_id = src.def_id;\n+        let def_id = src.def_id();\n         let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         if !tcx.has_attr(def_id, \"rustc_mir\") {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.item_path_str(def_id));"}, {"sha": "f72052c6e2840aded70b6818dd9c0a7d94f38d09", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -317,7 +317,7 @@ pub fn dump_mir<'a, 'tcx, V: Idx>(\n     }\n     let node_path = item_path::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id)\n+        tcx.item_path_str(source.def_id())\n     });\n     dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, map, result);\n }\n@@ -333,7 +333,7 @@ fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_node_id(source.def_id).unwrap();\n+    let item_id = tcx.hir().as_local_node_id(source.def_id()).unwrap();\n     let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {"}, {"sha": "120055ad397640044b7dfbb6385b5d4c6ba7908a", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270894678792fa9a30acc6ebc3a13caf5fa0b9c6/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=270894678792fa9a30acc6ebc3a13caf5fa0b9c6", "patch": "@@ -80,7 +80,7 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n \n     let node_path = item_path::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id)\n+        tcx.item_path_str(source.def_id())\n     });\n     dump_matched_mir_node(\n         tcx,\n@@ -105,7 +105,7 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n     };\n     let node_path = item_path::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n-        tcx.item_path_str(source.def_id)\n+        tcx.item_path_str(source.def_id())\n     });\n     filters.split('|').any(|or_filter| {\n         or_filter.split('&').all(|and_filter| {\n@@ -150,7 +150,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n         let _: io::Result<()> = try {\n             let mut file =\n                 create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, source)?;\n-            write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n+            write_mir_fn_graphviz(tcx, source.def_id(), mir, &mut file)?;\n         };\n     }\n }\n@@ -184,7 +184,7 @@ fn dump_path(\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n \n     let item_name = tcx\n-        .def_path(source.def_id)\n+        .def_path(source.def_id())\n         .to_filename_friendly_no_crate();\n \n     let file_name = format!(\n@@ -252,7 +252,7 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n         for (i, mir) in mir.promoted.iter_enumerated() {\n             writeln!(w, \"\")?;\n             let src = MirSource {\n-                def_id,\n+                instance: ty::InstanceDef::Item(def_id),\n                 promoted: Some(i),\n             };\n             write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n@@ -575,8 +575,8 @@ fn write_mir_sig(\n ) -> io::Result<()> {\n     use rustc::hir::def::Def;\n \n-    debug!(\"write_mir_sig: {:?} {:?}\", src.def_id, tcx.hir().get_if_local(src.def_id));\n-    let descr = tcx.describe_def(src.def_id).unwrap();\n+    trace!(\"write_mir_sig: {:?} {:?}\", src, tcx.hir().get_if_local(src.def_id()));\n+    let descr = tcx.describe_def(src.def_id()).unwrap();\n     match (descr, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in\", i)?,\n         (Def::Fn(_), _) | (Def::Method(_), _) => write!(w, \"fn\")?,\n@@ -588,7 +588,7 @@ fn write_mir_sig(\n \n     item_path::with_forced_impl_filename_line(|| {\n         // see notes on #41697 elsewhere\n-        write!(w, \" {}\", tcx.item_path_str(src.def_id))\n+        write!(w, \" {}\", tcx.item_path_str(src.def_id()))\n     })?;\n \n     match (descr, src.promoted) {"}]}