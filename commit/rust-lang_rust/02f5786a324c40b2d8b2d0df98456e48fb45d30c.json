{"sha": "02f5786a324c40b2d8b2d0df98456e48fb45d30c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZjU3ODZhMzI0YzQwYjJkOGIyZDBkZjk4NDU2ZTQ4ZmI0NWQzMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-25T09:30:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-25T09:30:02Z"}, "message": "Auto merge of #61151 - Centril:rollup-5rpyhfo, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #61092 (Make sanitize_place iterate instead of recurse)\n - #61093 (Make borrow_of_local_data iterate instead of recurse)\n - #61094 (Make find_local iterate instead of recurse)\n - #61099 (Make ignore_borrow iterate instead of recurse)\n - #61103 (Make find iterate instead of recurse)\n - #61104 (Make eval_place_to_op iterate instead of recurse)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "aa4420f14847762d75dfd35a5e4aff12614168cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4420f14847762d75dfd35a5e4aff12614168cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f5786a324c40b2d8b2d0df98456e48fb45d30c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f5786a324c40b2d8b2d0df98456e48fb45d30c", "html_url": "https://github.com/rust-lang/rust/commit/02f5786a324c40b2d8b2d0df98456e48fb45d30c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f5786a324c40b2d8b2d0df98456e48fb45d30c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "315ab95a9c13cbb69ae8538fcd69b9f7b0c30f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/315ab95a9c13cbb69ae8538fcd69b9f7b0c30f89", "html_url": "https://github.com/rust-lang/rust/commit/315ab95a9c13cbb69ae8538fcd69b9f7b0c30f89"}, {"sha": "1cd3dddc9482bced830f3b9e0524ba6a251992fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd3dddc9482bced830f3b9e0524ba6a251992fd", "html_url": "https://github.com/rust-lang/rust/commit/1cd3dddc9482bced830f3b9e0524ba6a251992fd"}], "stats": {"total": 361, "additions": 188, "deletions": 173}, "files": [{"sha": "de8e75ca277ee78e54bf0056773510b617a32572", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -29,7 +29,7 @@ use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionV\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::mir::interpret::{InterpError::BoundsCheck, ConstValue};\n use rustc::mir::tcx::PlaceTy;\n-use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::visit::{PlaceContext, Visitor, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n@@ -447,92 +447,95 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         context: PlaceContext,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n-        let place_ty = match place {\n-            Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n-            Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n-                     place: &Place<'tcx>,\n-                     ty,\n-                     sty| {\n-                        if let Err(terr) = verifier.cx.eq_types(\n-                            sty,\n-                            ty,\n-                            location.to_locations(),\n-                            ConstraintCategory::Boring,\n-                        ) {\n-                            span_mirbug!(\n-                            verifier,\n-                            place,\n-                            \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            ty,\n-                            sty,\n-                            terr\n-                        );\n+\n+        place.iterate(|place_base, place_projection| {\n+            let mut place_ty = match place_base {\n+                PlaceBase::Local(index) =>\n+                    PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n+                PlaceBase::Static(box Static { kind, ty: sty }) => {\n+                    let sty = self.sanitize_type(place, sty);\n+                    let check_err =\n+                        |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                         place: &Place<'tcx>,\n+                         ty,\n+                         sty| {\n+                            if let Err(terr) = verifier.cx.eq_types(\n+                                sty,\n+                                ty,\n+                                location.to_locations(),\n+                                ConstraintCategory::Boring,\n+                            ) {\n+                                span_mirbug!(\n+                                verifier,\n+                                place,\n+                                \"bad promoted type ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                sty,\n+                                terr\n+                            );\n+                            };\n                         };\n-                    };\n-                match kind {\n-                    StaticKind::Promoted(promoted) => {\n-                        if !self.errors_reported {\n-                            let promoted_mir = &self.mir.promoted[*promoted];\n-                            self.sanitize_promoted(promoted_mir, location);\n-\n-                            let promoted_ty = promoted_mir.return_ty();\n-                            check_err(self, place, promoted_ty, sty);\n+                    match kind {\n+                        StaticKind::Promoted(promoted) => {\n+                            if !self.errors_reported {\n+                                let promoted_mir = &self.mir.promoted[*promoted];\n+                                self.sanitize_promoted(promoted_mir, location);\n+\n+                                let promoted_ty = promoted_mir.return_ty();\n+                                check_err(self, place, promoted_ty, sty);\n+                            }\n                         }\n-                    }\n-                    StaticKind::Static(def_id) => {\n-                        let ty = self.tcx().type_of(*def_id);\n-                        let ty = self.cx.normalize(ty, location);\n+                        StaticKind::Static(def_id) => {\n+                            let ty = self.tcx().type_of(*def_id);\n+                            let ty = self.cx.normalize(ty, location);\n \n-                        check_err(self, place, ty, sty);\n+                            check_err(self, place, ty, sty);\n+                        }\n                     }\n+                    PlaceTy::from_ty(sty)\n+                }\n+            };\n+\n+            // FIXME use place_projection.is_empty() when is available\n+            if let Place::Base(_) = place {\n+                if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+                    let tcx = self.tcx();\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().copy_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    };\n+\n+                    // In order to have a Copy operand, the type T of the\n+                    // value must be Copy. Note that we prove that T: Copy,\n+                    // rather than using the `is_copy_modulo_regions`\n+                    // test. This is important because\n+                    // `is_copy_modulo_regions` ignores the resulting region\n+                    // obligations and assumes they pass. This can result in\n+                    // bounds from Copy impls being unsoundly ignored (e.g.,\n+                    // #29149). Note that we decide to use Copy before knowing\n+                    // whether the bounds fully apply: in effect, the rule is\n+                    // that if a value of some type could implement Copy, then\n+                    // it must.\n+                    self.cx.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                        ConstraintCategory::CopyBound,\n+                    );\n                 }\n-                PlaceTy::from_ty(sty)\n             }\n-            Place::Projection(ref proj) => {\n-                let base_context = if context.is_mutating_use() {\n-                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                } else {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                };\n-                let base_ty = self.sanitize_place(&proj.base, location, base_context);\n-                if base_ty.variant_index.is_none() {\n-                    if base_ty.ty.references_error() {\n+\n+            for proj in place_projection {\n+                if place_ty.variant_index.is_none() {\n+                    if place_ty.ty.references_error() {\n                         assert!(self.errors_reported);\n                         return PlaceTy::from_ty(self.tcx().types.err);\n                     }\n                 }\n-                self.sanitize_projection(base_ty, &proj.elem, place, location)\n+                place_ty = self.sanitize_projection(place_ty, &proj.elem, place, location)\n             }\n-        };\n-        if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-            let tcx = self.tcx();\n-            let trait_ref = ty::TraitRef {\n-                def_id: tcx.lang_items().copy_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-            };\n \n-            // In order to have a Copy operand, the type T of the\n-            // value must be Copy. Note that we prove that T: Copy,\n-            // rather than using the `is_copy_modulo_regions`\n-            // test. This is important because\n-            // `is_copy_modulo_regions` ignores the resulting region\n-            // obligations and assumes they pass. This can result in\n-            // bounds from Copy impls being unsoundly ignored (e.g.,\n-            // #29149). Note that we decide to use Copy before knowing\n-            // whether the bounds fully apply: in effect, the rule is\n-            // that if a value of some type could implement Copy, then\n-            // it must.\n-            self.cx.prove_trait_ref(\n-                trait_ref,\n-                location.to_locations(),\n-                ConstraintCategory::CopyBound,\n-            );\n-        }\n-        place_ty\n+            place_ty\n+        })\n     }\n \n     fn sanitize_promoted(&mut self, promoted_mir: &'b Mir<'tcx>, location: Location) {"}, {"sha": "caef8d8bc5a925820b1f7b1ec86581757113d220", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -131,22 +131,20 @@ pub(super) fn is_active<'tcx>(\n /// Determines if a given borrow is borrowing local data\n /// This is called for all Yield statements on movable generators\n pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n-    match place {\n-        Place::Base(PlaceBase::Static(..)) => false,\n-        Place::Base(PlaceBase::Local(..)) => true,\n-        Place::Projection(box proj) => {\n-            match proj.elem {\n-                // Reborrow of already borrowed data is ignored\n-                // Any errors will be caught on the initial borrow\n-                ProjectionElem::Deref => false,\n+    place.iterate(|place_base, place_projection| {\n+        match place_base {\n+            PlaceBase::Static(..) => return false,\n+            PlaceBase::Local(..) => {},\n+        }\n \n-                // For interior references and downcasts, find out if the base is local\n-                ProjectionElem::Field(..)\n-                    | ProjectionElem::Index(..)\n-                    | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Downcast(..) => borrow_of_local_data(&proj.base),\n+        for proj in place_projection {\n+            // Reborrow of already borrowed data is ignored\n+            // Any errors will be caught on the initial borrow\n+            if proj.elem == ProjectionElem::Deref {\n+                return false;\n             }\n         }\n-    }\n+\n+        true\n+    })\n }"}, {"sha": "9ad0e936e1b2d7b4283bd0b0c5f8f2134106eb8e", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -25,40 +25,36 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         mir: &Mir<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        match self {\n-            // If a local variable is immutable, then we only need to track borrows to guard\n-            // against two kinds of errors:\n-            // * The variable being dropped while still borrowed (e.g., because the fn returns\n-            //   a reference to a local variable)\n-            // * The variable being moved while still borrowed\n-            //\n-            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-            // so we don't have to worry about mutation while borrowed.\n-            Place::Base(PlaceBase::Local(index)) => {\n-                match locals_state_at_exit {\n-                    LocalsStateAtExit::AllAreInvalidated => false,\n-                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                        let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                            mir.local_decls[*index].mutability == Mutability::Not;\n-                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                        ignore\n+        self.iterate(|place_base, place_projection| {\n+            let ignore = match place_base {\n+                // If a local variable is immutable, then we only need to track borrows to guard\n+                // against two kinds of errors:\n+                // * The variable being dropped while still borrowed (e.g., because the fn returns\n+                //   a reference to a local variable)\n+                // * The variable being moved while still borrowed\n+                //\n+                // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+                // so we don't have to worry about mutation while borrowed.\n+                PlaceBase::Local(index) => {\n+                    match locals_state_at_exit {\n+                        LocalsStateAtExit::AllAreInvalidated => false,\n+                        LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                            let ignore = !has_storage_dead_or_moved.contains(*index) &&\n+                                mir.local_decls[*index].mutability == Mutability::Not;\n+                            debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                            ignore\n+                        }\n                     }\n                 }\n-            }\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n-                false,\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n-                tcx.is_mutable_static(*def_id)\n-            }\n-            Place::Projection(proj) => match proj.elem {\n-                ProjectionElem::Field(..)\n-                | ProjectionElem::Downcast(..)\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Index(_) => proj.base.ignore_borrow(\n-                    tcx, mir, locals_state_at_exit),\n+                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. }) =>\n+                    false,\n+                PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. }) => {\n+                    tcx.is_mutable_static(*def_id)\n+                }\n+            };\n \n-                ProjectionElem::Deref => {\n+            for proj in place_projection {\n+                if proj.elem == ProjectionElem::Deref {\n                     let ty = proj.base.ty(mir, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n@@ -71,11 +67,13 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         // original path into a new variable and\n                         // borrowed *that* one, leaving the original\n                         // path unborrowed.\n-                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => true,\n-                        _ => proj.base.ignore_borrow(tcx, mir, locals_state_at_exit),\n+                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n+                        _ => {}\n                     }\n                 }\n-            },\n-        }\n+            }\n+\n+            ignore\n+        })\n     }\n }"}, {"sha": "65cbc83fbcb84edb7337bb89f873bb30e4d9dac6", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -91,16 +91,19 @@ struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n }\n \n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n-    match *place {\n-        Place::Base(PlaceBase::Local(l)) => Some(l),\n-        Place::Base(PlaceBase::Static(..)) => None,\n-        Place::Projection(ref proj) => {\n-            match proj.elem {\n-                ProjectionElem::Deref => None,\n-                _ => find_local(&proj.base)\n+    place.iterate(|place_base, place_projection| {\n+        for proj in place_projection {\n+            if proj.elem == ProjectionElem::Deref {\n+                return None;\n             }\n         }\n-    }\n+\n+        if let PlaceBase::Local(local) = place_base {\n+            Some(*local)\n+        } else {\n+            None\n+        }\n+    })\n }\n \n impl<'tcx, 'b, 'c> Visitor<'tcx> for BorrowedLocalsVisitor<'b, 'c> {"}, {"sha": "7aaf44a8a890ee9e33ceddf0676191b285325018", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -241,21 +241,22 @@ impl MovePathLookup {\n     // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n-        match *place {\n-            Place::Base(PlaceBase::Local(local)) => LookupResult::Exact(self.locals[local]),\n-            Place::Base(PlaceBase::Static(..)) => LookupResult::Parent(None),\n-            Place::Projection(ref proj) => {\n-                match self.find(&proj.base) {\n-                    LookupResult::Exact(base_path) => {\n-                        match self.projections.get(&(base_path, proj.elem.lift())) {\n-                            Some(&subpath) => LookupResult::Exact(subpath),\n-                            None => LookupResult::Parent(Some(base_path))\n-                        }\n-                    }\n-                    inexact => inexact\n+        place.iterate(|place_base, place_projection| {\n+            let mut result = match place_base {\n+                PlaceBase::Local(local) => self.locals[*local],\n+                PlaceBase::Static(..) => return LookupResult::Parent(None),\n+            };\n+\n+            for proj in place_projection {\n+                if let Some(&subpath) = self.projections.get(&(result, proj.elem.lift())) {\n+                    result = subpath;\n+                } else {\n+                    return LookupResult::Parent(Some(result));\n                 }\n             }\n-        }\n+\n+            LookupResult::Exact(result)\n+        })\n     }\n \n     pub fn find_local(&self, local: Local) -> MovePathIndex {"}, {"sha": "a674389a93695394f4959a1fdfc7b213056cac39", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -467,22 +467,34 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::Place::*;\n+        use rustc::mir::Place;\n         use rustc::mir::PlaceBase;\n-        let op = match *mir_place {\n-            Base(PlaceBase::Local(mir::RETURN_PLACE)) => return err!(ReadFromReturnPointer),\n-            Base(PlaceBase::Local(local)) => self.access_local(self.frame(), local, layout)?,\n \n-            Projection(ref proj) => {\n-                let op = self.eval_place_to_op(&proj.base, None)?;\n-                self.operand_projection(op, &proj.elem)?\n-            }\n+        mir_place.iterate(|place_base, place_projection| {\n+            let mut op = match place_base {\n+                PlaceBase::Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n+                PlaceBase::Local(local) => {\n+                    // FIXME use place_projection.is_empty() when is available\n+                    let layout = if let Place::Base(_) = mir_place {\n+                        layout\n+                    } else {\n+                        None\n+                    };\n+\n+                    self.access_local(self.frame(), *local, layout)?\n+                }\n+                PlaceBase::Static(place_static) => {\n+                    self.eval_static_to_mplace(place_static)?.into()\n+                }\n+            };\n \n-            _ => self.eval_place_to_mplace(mir_place)?.into(),\n-        };\n+            for proj in place_projection {\n+                op = self.operand_projection(op, &proj.elem)?\n+            }\n \n-        trace!(\"eval_place_to_op: got {:?}\", *op);\n-        Ok(op)\n+            trace!(\"eval_place_to_op: got {:?}\", *op);\n+            Ok(op)\n+        })\n     }\n \n     /// Evaluate the operand, returning a place where you can then find the data."}, {"sha": "65e5e23e384247e176aee2a5f85e7739823a7f12", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f5786a324c40b2d8b2d0df98456e48fb45d30c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=02f5786a324c40b2d8b2d0df98456e48fb45d30c", "patch": "@@ -562,23 +562,23 @@ where\n \n     /// Evaluate statics and promoteds to an `MPlace`. Used to share some code between\n     /// `eval_place` and `eval_place_to_op`.\n-    pub(super) fn eval_place_to_mplace(\n+    pub(super) fn eval_static_to_mplace(\n         &self,\n-        mir_place: &mir::Place<'tcx>\n+        place_static: &mir::Static<'tcx>\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::Place::*;\n-        use rustc::mir::PlaceBase;\n-        use rustc::mir::{Static, StaticKind};\n-        Ok(match *mir_place {\n-            Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })) => {\n+        use rustc::mir::StaticKind;\n+\n+        Ok(match place_static.kind {\n+            StaticKind::Promoted(promoted) => {\n                 let instance = self.frame().instance;\n                 self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: Some(promoted),\n                 })?\n             }\n \n-            Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), ty })) => {\n+            StaticKind::Static(def_id) => {\n+                let ty = place_static.ty;\n                 assert!(!ty.needs_subst());\n                 let layout = self.layout_of(ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, def_id);\n@@ -600,8 +600,6 @@ where\n                 let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n                 MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n             }\n-\n-            _ => bug!(\"eval_place_to_mplace called on {:?}\", mir_place),\n         })\n     }\n \n@@ -613,7 +611,7 @@ where\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n-        let place = match *mir_place {\n+        let place = match mir_place {\n             Base(PlaceBase::Local(mir::RETURN_PLACE)) => match self.frame().return_place {\n                 Some(return_place) =>\n                     // We use our layout to verify our assumption; caller will validate\n@@ -628,17 +626,19 @@ where\n                 // This works even for dead/uninitialized locals; we check further when writing\n                 place: Place::Local {\n                     frame: self.cur_frame(),\n-                    local,\n+                    local: *local,\n                 },\n-                layout: self.layout_of_local(self.frame(), local, None)?,\n+                layout: self.layout_of_local(self.frame(), *local, None)?,\n             },\n \n-            Projection(ref proj) => {\n+            Projection(proj) => {\n                 let place = self.eval_place(&proj.base)?;\n                 self.place_projection(place, &proj.elem)?\n             }\n \n-            _ => self.eval_place_to_mplace(mir_place)?.into(),\n+            Base(PlaceBase::Static(place_static)) => {\n+                self.eval_static_to_mplace(place_static)?.into()\n+            }\n         };\n \n         self.dump_place(place.place);"}]}