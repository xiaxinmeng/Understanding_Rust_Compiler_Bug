{"sha": "5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjM2QxZTVkNzZmZGM2ZDlmNDBhYjEzYTZhMzQyZTFmN2NlYjRmMTc=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-03-21T22:38:50Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-24T09:10:16Z"}, "message": "Separate variant id and variant constructor id.\n\nThis commit makes two changes - separating the `NodeId` that identifies\nan enum variant from the `NodeId` that identifies the variant's\nconstructor; and no longer creating a `NodeId` for `Struct`-style enum\nvariants and structs.\n\nSeparation of the variant id and variant constructor id will allow the\nrest of RFC 2008 to be implemented by lowering the visibility of the\nvariant's constructor without lowering the visbility of the variant\nitself.\n\nNo longer creating a `NodeId` for `Struct`-style enum variants and\nstructs mostly simplifies logic as previously this `NodeId` wasn't used.\nThere were various cases where the `NodeId` wouldn't be used unless\nthere was an unit or tuple struct or enum variant but not all uses of\nthis `NodeId` had that condition, by removing this `NodeId`, this must\nbe explicitly dealt with. This change mostly applied cleanly, but there\nwere one or two cases in name resolution and one case in type check\nwhere the existing logic required a id for `Struct`-style enum variants\nand structs.", "tree": {"sha": "c6fd03adac4567a587c34ca1037961c55fad8c7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6fd03adac4567a587c34ca1037961c55fad8c7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "html_url": "https://github.com/rust-lang/rust/commit/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb5ed488ff1a251db895c545592488a67be67112", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5ed488ff1a251db895c545592488a67be67112", "html_url": "https://github.com/rust-lang/rust/commit/fb5ed488ff1a251db895c545592488a67be67112"}], "stats": {"total": 1338, "additions": 818, "deletions": 520}, "files": [{"sha": "87a6065bb75ecf270e18f6e43e340cde3cc4f13a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -37,9 +37,13 @@ pub enum NonMacroAttrKind {\n pub enum Def {\n     // Type namespace\n     Mod(DefId),\n-    Struct(DefId), // `DefId` refers to `NodeId` of the struct itself\n+    /// `DefId` refers to `NodeId` of the struct. `Def::VariantCtor` represents the constructor of\n+    /// a struct.\n+    Struct(DefId),\n     Union(DefId),\n     Enum(DefId),\n+    /// `DefId` refers to the `NodeId` of the variant. `Def::VariantCtor` represents the\n+    /// constructor of an enum variant.\n     Variant(DefId),\n     Trait(DefId),\n     /// `existential type Foo: Bar;`\n@@ -61,8 +65,8 @@ pub enum Def {\n     Const(DefId),\n     ConstParam(DefId),\n     Static(DefId, bool /* is_mutbl */),\n-    StructCtor(DefId, CtorKind), // `DefId` refers to `NodeId` of the struct's constructor\n-    VariantCtor(DefId, CtorKind), // `DefId` refers to the enum variant\n+    /// `DefId` refers to `NodeId` of the struct or enum variant's constructor.\n+    Ctor(hir::CtorOf, DefId, CtorKind),\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Method(DefId),\n     AssociatedConst(DefId),\n@@ -265,10 +269,9 @@ impl Def {\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n-            Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) |\n+            Def::Variant(id) | Def::Ctor(_, id, ..) | Def::Enum(id) |\n             Def::TyAlias(id) | Def::TraitAlias(id) |\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::ConstParam(id) | Def::Struct(id) |\n-            Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n             Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n@@ -303,20 +306,21 @@ impl Def {\n             Def::Fn(..) => \"function\",\n             Def::Mod(..) => \"module\",\n             Def::Static(..) => \"static\",\n-            Def::Variant(..) => \"variant\",\n-            Def::VariantCtor(.., CtorKind::Fn) => \"tuple variant\",\n-            Def::VariantCtor(.., CtorKind::Const) => \"unit variant\",\n-            Def::VariantCtor(.., CtorKind::Fictive) => \"struct variant\",\n             Def::Enum(..) => \"enum\",\n+            Def::Variant(..) => \"variant\",\n+            Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Fn) => \"tuple variant\",\n+            Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Const) => \"unit variant\",\n+            Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Fictive) => \"struct variant\",\n+            Def::Struct(..) => \"struct\",\n+            Def::Ctor(hir::CtorOf::Struct, _, CtorKind::Fn) => \"tuple struct\",\n+            Def::Ctor(hir::CtorOf::Struct, _, CtorKind::Const) => \"unit struct\",\n+            Def::Ctor(hir::CtorOf::Struct, _, CtorKind::Fictive) =>\n+                bug!(\"impossible struct constructor\"),\n             Def::Existential(..) => \"existential type\",\n             Def::TyAlias(..) => \"type alias\",\n             Def::TraitAlias(..) => \"trait alias\",\n             Def::AssociatedTy(..) => \"associated type\",\n             Def::AssociatedExistential(..) => \"associated existential type\",\n-            Def::Struct(..) => \"struct\",\n-            Def::StructCtor(.., CtorKind::Fn) => \"tuple struct\",\n-            Def::StructCtor(.., CtorKind::Const) => \"unit struct\",\n-            Def::StructCtor(.., CtorKind::Fictive) => bug!(\"impossible struct constructor\"),\n             Def::SelfCtor(..) => \"self constructor\",\n             Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\","}, {"sha": "bce528189ad1e0dd011b4630bff2875c23e17f55", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -559,6 +559,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         generics: &'v Generics,\n                                         parent_item_id: HirId) {\n     visitor.visit_ident(variant.node.ident);\n+    visitor.visit_id(variant.node.id);\n     visitor.visit_variant_data(&variant.node.data,\n                                variant.node.ident.name,\n                                generics,\n@@ -923,7 +924,9 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n \n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n-    visitor.visit_id(struct_definition.hir_id());\n+    if let Some(ctor_hir_id) = struct_definition.ctor_hir_id() {\n+        visitor.visit_id(ctor_hir_id);\n+    }\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n "}, {"sha": "8db90035c8e0ccd072d109ca8ee8f78552b45ba9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1615,9 +1615,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(v.node.id);\n         Spanned {\n             node: hir::VariantKind {\n                 ident: v.node.ident,\n+                id: hir_id,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n@@ -2669,19 +2671,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n         match *vdata {\n-            VariantData::Struct(ref fields, id, recovered) => {\n-                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n-\n-                hir::VariantData::Struct(\n-                    fields\n-                        .iter()\n-                        .enumerate()\n-                        .map(|f| self.lower_struct_field(f))\n-                        .collect(),\n-                    hir_id,\n-                    recovered,\n-                )\n-            },\n+            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+                fields.iter().enumerate().map(|f| self.lower_struct_field(f)).collect(),\n+                recovered,\n+            ),\n             VariantData::Tuple(ref fields, id) => {\n                 let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n@@ -2696,7 +2689,6 @@ impl<'a> LoweringContext<'a> {\n             },\n             VariantData::Unit(id) => {\n                 let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n-\n                 hir::VariantData::Unit(hir_id)\n             },\n         }"}, {"sha": "e7cd8f113539a0ef52d30a9a8839922e641d8e7c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -360,9 +360,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.node {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.insert(i.span, struct_def.hir_id(), Node::StructCtor(struct_def));\n+                    // If this is a tuple or unit-like struct, register the constructor.\n+                    if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                        this.insert(i.span,\n+                                    ctor_hir_id,\n+                                    Node::Ctor(hir::CtorOf::Struct, struct_def));\n                     }\n                 }\n                 intravisit::walk_item(this, i);\n@@ -515,8 +517,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n-        self.insert(v.span, v.node.data.hir_id(), Node::Variant(v));\n-        self.with_parent(v.node.data.hir_id(), |this| {\n+        self.insert(v.span, v.node.id, Node::Variant(v));\n+        self.with_parent(v.node.id, |this| {\n+            // Register the constructor of this variant.\n+            if let Some(ctor_hir_id) = v.node.data.ctor_hir_id() {\n+                this.insert(v.span, ctor_hir_id, Node::Ctor(hir::CtorOf::Variant, &v.node.data));\n+            }\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }"}, {"sha": "2c92d907201d59f060a99c010c43b57b44c4408d", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -158,9 +158,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         self.with_parent(def, |this| {\n             match i.node {\n                 ItemKind::Struct(ref struct_def, _) | ItemKind::Union(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.create_def(struct_def.id(),\n+                    // If this is a unit or tuple-like struct, register the constructor.\n+                    if let Some(ctor_hir_id) = struct_def.ctor_id() {\n+                        this.create_def(ctor_hir_id,\n                                         DefPathData::StructCtor,\n                                         REGULAR_SPACE,\n                                         i.span);\n@@ -193,11 +193,19 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-        let def = self.create_def(v.node.data.id(),\n+        let def = self.create_def(v.node.id,\n                                   DefPathData::EnumVariant(v.node.ident.as_interned_str()),\n                                   REGULAR_SPACE,\n                                   v.span);\n-        self.with_parent(def, |this| visit::walk_variant(this, v, g, item_id));\n+        self.with_parent(def, |this| {\n+            if let Some(ctor_hir_id) = v.node.data.ctor_id() {\n+                this.create_def(ctor_hir_id,\n+                                DefPathData::VariantCtor,\n+                                REGULAR_SPACE,\n+                                v.span);\n+            }\n+            visit::walk_variant(this, v, g, item_id)\n+        });\n     }\n \n     fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,"}, {"sha": "dc23b55c1fcb324302f4eb17e3030ad342b007c5", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -366,8 +366,10 @@ pub enum DefPathData {\n     EnumVariant(InternedString),\n     /// A struct field\n     Field(InternedString),\n-    /// Implicit ctor for a tuple-like struct\n+    /// Implicit ctor for a unit or tuple-like struct\n     StructCtor,\n+    /// Implicit ctor for a unit or tuple-like enum variant\n+    VariantCtor,\n     /// A constant expression (see {ast,hir}::AnonConst).\n     AnonConst,\n     /// An `impl Trait` type node\n@@ -653,6 +655,7 @@ impl DefPathData {\n             Misc |\n             ClosureExpr |\n             StructCtor |\n+            VariantCtor |\n             AnonConst |\n             ImplTrait => None\n         }\n@@ -683,7 +686,8 @@ impl DefPathData {\n             Impl => \"{{impl}}\",\n             Misc => \"{{misc}}\",\n             ClosureExpr => \"{{closure}}\",\n-            StructCtor => \"{{constructor}}\",\n+            StructCtor => \"{{struct constructor}}\",\n+            VariantCtor => \"{{variant constructor}}\",\n             AnonConst => \"{{constant}}\",\n             ImplTrait => \"{{opaque}}\",\n         };"}, {"sha": "ce0246dec7182a83e49b86f377d68fae3c5c283c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -366,12 +366,15 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::Variant(variant) => {\n-                let def_id = self.local_def_id_from_hir_id(variant.node.data.hir_id());\n+                let def_id = self.local_def_id_from_hir_id(variant.node.id);\n                 Some(Def::Variant(def_id))\n             }\n-            Node::StructCtor(variant) => {\n-                let def_id = self.local_def_id_from_hir_id(variant.hir_id());\n-                Some(Def::StructCtor(def_id, def::CtorKind::from_hir(variant)))\n+            Node::Ctor(ctor_of, variant_data) => {\n+                variant_data.ctor_hir_id()\n+                    .map(|hir_id| self.local_def_id_from_hir_id(hir_id))\n+                    .map(|def_id| Def::Ctor(\n+                        ctor_of, def_id, def::CtorKind::from_hir(variant_data),\n+                    ))\n             }\n             Node::AnonConst(_) |\n             Node::Field(_) |\n@@ -516,8 +519,7 @@ impl<'hir> Map<'hir> {\n             Node::AnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            Node::Variant(&Spanned { node: VariantKind { data: VariantData::Tuple(..), .. }, .. }) |\n-            Node::StructCtor(..) |\n+            Node::Ctor(..) |\n             Node::Item(&Item { node: ItemKind::Fn(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Method(..), .. }) |\n             Node::ImplItem(&ImplItem { node: ImplItemKind::Method(..), .. }) => {\n@@ -948,8 +950,8 @@ impl<'hir> Map<'hir> {\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.hir_to_string(id))\n                 }\n             }\n-            Some(Node::StructCtor(data)) => data,\n             Some(Node::Variant(variant)) => &variant.node.data,\n+            Some(Node::Ctor(_, data)) => data,\n             _ => bug!(\"expected struct or variant, found {}\", self.hir_to_string(id))\n         }\n     }\n@@ -993,7 +995,7 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n-            Node::StructCtor(_) => self.name(self.get_parent(id)),\n+            Node::Ctor(..) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n@@ -1019,9 +1021,9 @@ impl<'hir> Map<'hir> {\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n             Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n-            // unit/tuple structs take the attributes straight from\n-            // the struct definition.\n-            Some(Node::StructCtor(_)) => return self.attrs(self.get_parent(id)),\n+            // Unit/tuple structs/variants take the attributes straight from\n+            // the struct/variant definition.\n+            Some(Node::Ctor(..)) => return self.attrs(self.get_parent(id)),\n             _ => None\n         };\n         attrs.unwrap_or(&[])\n@@ -1068,7 +1070,10 @@ impl<'hir> Map<'hir> {\n             Some(Node::Binding(pat)) => pat.span,\n             Some(Node::Pat(pat)) => pat.span,\n             Some(Node::Block(block)) => block.span,\n-            Some(Node::StructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(Node::Ctor(CtorOf::Struct, _)) =>\n+                self.expect_item(self.get_parent(id)).span,\n+            Some(Node::Ctor(CtorOf::Variant, _)) =>\n+                self.expect_variant(self.node_to_hir_id(self.get_parent_node(id))).span,\n             Some(Node::Lifetime(lifetime)) => lifetime.span,\n             Some(Node::GenericParam(param)) => param.span,\n             Some(Node::Visibility(&Spanned {\n@@ -1324,7 +1329,7 @@ impl<'a> print::State<'a> {\n             // these cases do not carry enough information in the\n             // hir_map to reconstruct their full structure for pretty\n             // printing.\n-            Node::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n+            Node::Ctor(..)        => bug!(\"cannot print isolated Ctor\"),\n             Node::Local(a)        => self.print_local_decl(&a),\n             Node::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n             Node::Crate           => bug!(\"cannot print Crate\"),\n@@ -1443,8 +1448,8 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         Some(Node::Local(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(Node::StructCtor(_)) => {\n-            format!(\"struct_ctor {}{}\", path_str(), id_str)\n+        Some(Node::Ctor(..)) => {\n+            format!(\"ctor {}{}\", path_str(), id_str)\n         }\n         Some(Node::Lifetime(_)) => {\n             format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)"}, {"sha": "6ce7c347c9971d612548c7cc525f6a6df9f1a32b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -2049,9 +2049,14 @@ pub struct EnumDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct VariantKind {\n+    /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n+    /// Attributes of the variant.\n     pub attrs: HirVec<Attribute>,\n+    /// Id of the variant (not the constructor, see `VariantData::ctor_hir_id()`).\n+    pub id: HirId,\n+    /// Fields and constructor id of the variant.\n     pub data: VariantData,\n     /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n@@ -2063,7 +2068,7 @@ pub type Variant = Spanned<VariantKind>;\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n-    // `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n+    /// `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n     Single,\n \n     /// Glob import, e.g., `use foo::*`.\n@@ -2170,52 +2175,59 @@ impl StructField {\n     }\n }\n \n-/// Fields and Ids of enum variants and structs\n-///\n-/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n-/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n-/// One shared Id can be successfully used for these two purposes.\n-/// Id of the whole enum lives in `Item`.\n-///\n-/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n-/// the variant itself\" from enum variants.\n-/// Id of the whole struct lives in `Item`.\n+/// Fields and constructor ids of enum variants and structs\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n-    Struct(HirVec<StructField>, HirId, /* recovered */ bool),\n+    /// Struct variant.\n+    ///\n+    /// e.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n+    Struct(HirVec<StructField>, /* recovered */ bool),\n+    /// Tuple variant.\n+    ///\n+    /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n     Tuple(HirVec<StructField>, HirId),\n+    /// Unit variant.\n+    ///\n+    /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n     Unit(HirId),\n }\n \n impl VariantData {\n+    /// Return the fields of this variant.\n     pub fn fields(&self) -> &[StructField] {\n         match *self {\n             VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, ..) => fields,\n             _ => &[],\n         }\n     }\n-    pub fn hir_id(&self) -> HirId {\n+\n+    /// Return the `HirId` of this variant's constructor, if it has one.\n+    pub fn ctor_hir_id(&self) -> Option<HirId> {\n         match *self {\n-            VariantData::Struct(_, hir_id, _)\n-            | VariantData::Tuple(_, hir_id)\n-            | VariantData::Unit(hir_id) => hir_id,\n+            VariantData::Struct(_, _) => None,\n+            VariantData::Tuple(_, hir_id) | VariantData::Unit(hir_id) => Some(hir_id),\n         }\n     }\n+\n+    /// Does this `VariantData` represent a `Struct`-struct/variant?\n     pub fn is_struct(&self) -> bool {\n         if let VariantData::Struct(..) = *self {\n             true\n         } else {\n             false\n         }\n     }\n+\n+    /// Does this `VariantData` represent a tuple struct/variant?\n     pub fn is_tuple(&self) -> bool {\n         if let VariantData::Tuple(..) = *self {\n             true\n         } else {\n             false\n         }\n     }\n+\n+    /// Does this `VariantData` represent a unit struct/variant?\n     pub fn is_unit(&self) -> bool {\n         if let VariantData::Unit(..) = *self {\n             true\n@@ -2574,6 +2586,15 @@ impl CodegenFnAttrs {\n     }\n }\n \n+/// Encodes if a `Node::Ctor` is the constructor of an enum variant or a struct.\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+pub enum CtorOf {\n+    /// This `Node::Ctor` is a synthesized constructor of a tuple or unit struct.\n+    Struct,\n+    /// This `Node::Ctor` is a synthesized constructor of a tuple or unit variant.\n+    Variant,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n     Item(&'hir Item),\n@@ -2594,8 +2615,9 @@ pub enum Node<'hir> {\n     Local(&'hir Local),\n     MacroDef(&'hir MacroDef),\n \n-    /// StructCtor represents a tuple struct.\n-    StructCtor(&'hir VariantData),\n+    /// `Ctor` refers to the constructor of an enum variant or struct. Only tuple or unit variants\n+    /// with synthesized constructors.\n+    Ctor(CtorOf, &'hir VariantData),\n \n     Lifetime(&'hir Lifetime),\n     GenericParam(&'hir GenericParam),"}, {"sha": "b859a0f389ed58e6d422a38b214c7a8f1736902d", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -55,7 +55,7 @@ impl hir::Pat {\n             PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                 match path.def {\n-                    Def::Variant(..) | Def::VariantCtor(..) => true,\n+                    Def::Variant(..) => true,\n                     _ => false\n                 }\n             }\n@@ -125,8 +125,8 @@ impl hir::Pat {\n                 PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n                 PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                     match path.def {\n-                        Def::Variant(id) |\n-                        Def::VariantCtor(id, ..) => variants.push(id),\n+                        Def::Variant(id) => variants.push(id),\n+                        Def::Ctor(hir::CtorOf::Variant, id, _) => variants.push(id),\n                         _ => ()\n                     }\n                 }"}, {"sha": "94f1d9c2710071ba795c108054427d90118c0cc2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -917,7 +917,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -1073,7 +1073,9 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n-        self.check_id(s.id());\n+        if let Some(ctor_hir_id) = s.ctor_id() {\n+            self.check_id(ctor_hir_id);\n+        }\n         ast_visit::walk_struct_def(self, s);\n         run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n     }"}, {"sha": "e96fe3d3b7741b1dcc5122836a51e1474cdca83a", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.node.id, &v.node.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }"}, {"sha": "786d339e876c5a60d0c57f8581e4de9ade828622", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -54,8 +54,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n-            if should_explore(self.tcx, hir_id) ||\n-               self.struct_constructors.contains_key(&hir_id) {\n+            if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n                 self.worklist.push(hir_id);\n             }\n             self.live_symbols.insert(hir_id);\n@@ -77,10 +76,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ if self.in_pat => (),\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n             Def::Local(..) | Def::Upvar(..) => {}\n-            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                if let Some(enum_id) = self.tcx.parent(variant_id) {\n-                    self.check_def_id(enum_id);\n+            Def::Ctor(hir::CtorOf::Variant, ctor_def_id, ..) => {\n+                let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n+                let enum_id = self.tcx.parent(variant_id).unwrap();\n+                self.check_def_id(enum_id);\n+                if !self.ignore_variant_stack.contains(&ctor_def_id) {\n+                    self.check_def_id(variant_id);\n                 }\n+            }\n+            Def::Variant(variant_id) => {\n+                let enum_id = self.tcx.parent(variant_id).unwrap();\n+                self.check_def_id(enum_id);\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }\n@@ -360,9 +366,16 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             self.worklist.push(item.hir_id);\n         }\n         match item.node {\n-            hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n-                self.worklist.extend(enum_def.variants.iter()\n-                                                      .map(|variant| variant.node.data.hir_id()));\n+            hir::ItemKind::Enum(ref enum_def, _) => {\n+                if allow_dead_code {\n+                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+                }\n+\n+                for variant in &enum_def.variants {\n+                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                        self.struct_constructors.insert(ctor_hir_id, variant.node.id);\n+                    }\n+                }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n@@ -392,7 +405,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n-                self.struct_constructors.insert(variant_data.hir_id(), item.hir_id);\n+                if let Some(ctor_hir_id) = variant_data.ctor_hir_id() {\n+                    self.struct_constructors.insert(ctor_hir_id, item.hir_id);\n+                }\n             }\n             _ => ()\n         }\n@@ -484,9 +499,9 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.hir_id())\n+        !self.symbol_is_live(variant.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n-                                                 variant.data.hir_id(),\n+                                                 variant.id,\n                                                  &variant.attrs)\n     }\n \n@@ -583,7 +598,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.hir_id(), variant.span, variant.node.ident.name,\n+            self.warn_dead_code(variant.node.id, variant.span, variant.node.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);"}, {"sha": "a60a145dd216109085457812b862fe21e961b1bb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -14,7 +14,7 @@ use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n use crate::middle::region;\n-use crate::ty::{self, TyCtxt, adjustment};\n+use crate::ty::{self, DefIdTree, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n@@ -902,14 +902,20 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             };\n             let def = mc.tables.qpath_def(qpath, pat.hir_id);\n             match def {\n-                Def::Variant(variant_did) |\n-                Def::VariantCtor(variant_did, ..) => {\n+                Def::Ctor(hir::CtorOf::Variant, variant_ctor_did, ..) => {\n+                    let variant_did = mc.tcx.parent(variant_ctor_did).unwrap();\n+                    let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n+\n+                    debug!(\"variantctor downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n+                    delegate.matched_pat(pat, &downcast_cmt, match_mode);\n+                }\n+                Def::Variant(variant_did) => {\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n-                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+                Def::Struct(..) | Def::Ctor(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, &cmt_pat, match_mode);"}, {"sha": "aa582d48bb6608040c49ce6747bfd1425eecbd73", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -215,7 +215,7 @@ impl<'tcx> cmt_<'tcx> {\n         };\n         let variant_def = match self.cat {\n             Categorization::Downcast(_, variant_did) => {\n-                adt_def.variant_with_id(variant_did)\n+                adt_def.variant_with_variant_id(variant_did)\n             }\n             _ => {\n                 assert_eq!(adt_def.variants.len(), 1);\n@@ -704,7 +704,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                hir_id, expr_ty, def);\n \n         match def {\n-            Def::StructCtor(..) | Def::VariantCtor(..) | Def::Const(..) | Def::ConstParam(..) |\n+            Def::Ctor(..) | Def::Const(..) | Def::ConstParam(..) |\n             Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => {\n                 Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n             }\n@@ -1274,12 +1274,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                        let enum_def = self.tcx.parent(def_id).unwrap();\n-                        (self.cat_downcast_if_needed(pat, cmt, def_id),\n-                        self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len())\n+                    Def::Ctor(hir::CtorOf::Variant, variant_ctor_did, CtorKind::Fn) => {\n+                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n+                        let enum_did = self.tcx.parent(variant_did).unwrap();\n+                        (self.cat_downcast_if_needed(pat, cmt, variant_did),\n+                         self.tcx.adt_def(enum_did)\n+                             .variant_with_ctor_id(variant_ctor_did).fields.len())\n                     }\n-                    Def::StructCtor(_, CtorKind::Fn) | Def::SelfCtor(..) => {\n+                    Def::Ctor(hir::CtorOf::Struct, _, CtorKind::Fn) | Def::SelfCtor(..) => {\n                         let ty = self.pat_ty_unadjusted(&pat)?;\n                         match ty.sty {\n                             ty::Adt(adt_def, _) => {\n@@ -1314,8 +1316,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::Variant(variant_did) |\n-                    Def::VariantCtor(variant_did, ..) => {\n+                    Def::Ctor(hir::CtorOf::Variant, variant_ctor_did, _) => {\n+                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n+                        self.cat_downcast_if_needed(pat, cmt, variant_did)\n+                    }\n+                    Def::Variant(variant_did) => {\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n                     _ => cmt,"}, {"sha": "b57f96f2d469de6a82950cdff300c7ae5f304370", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // Nothing to recurse on for these\n             Node::ForeignItem(_) |\n             Node::Variant(_) |\n-            Node::StructCtor(_) |\n+            Node::Ctor(..) |\n             Node::Field(_) |\n             Node::Ty(_) |\n             Node::MacroDef(_) => {}"}, {"sha": "772c6ab4745439891d1c47645e66fe1549f999e9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -258,8 +258,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n                 self.in_trait_impl = true;\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n-                if !sd.is_struct() {\n-                    self.annotate(sd.hir_id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n+                if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n+                    self.annotate(ctor_hir_id, &i.attrs, i.span, AnnotationKind::Required, |_| {})\n                 }\n             }\n             _ => {}\n@@ -289,8 +289,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.data.hir_id(), &var.node.attrs, var.span, AnnotationKind::Required,\n-            |v| { intravisit::walk_variant(v, var, g, item_id) })\n+        self.annotate(var.node.id, &var.node.attrs, var.span, AnnotationKind::Required,\n+            |v| {\n+                if let Some(ctor_hir_id) = var.node.data.ctor_hir_id() {\n+                    v.annotate(ctor_hir_id, &var.node.attrs, var.span, AnnotationKind::Required,\n+                               |_| {});\n+                }\n+\n+                intravisit::walk_variant(v, var, g, item_id)\n+            })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n@@ -364,7 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.data.hir_id(), var.span, \"variant\");\n+        self.check_missing_stability(var.node.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n "}, {"sha": "b54b92b798ef7b9683dc2e9a6b26b646fd96add1", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -2405,12 +2405,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Adt(adt_def, variant, substs, _user_ty, _) => {\n                         let variant_def = &adt_def.variants[variant];\n+                        let did = variant_def.variant_did_or_parent_struct_did();\n \n                         let f = &mut *fmt;\n                         ty::tls::with(|tcx| {\n                             let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n                             FmtPrinter::new(tcx, f, Namespace::ValueNS)\n-                                .print_def_path(variant_def.did, substs)?;\n+                                .print_def_path(did, substs)?;\n                             Ok(())\n                         })?;\n "}, {"sha": "ef232c06921df116b4d7d70d0a89b45c0c3311b5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1077,23 +1077,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::empty()\n                 }).collect::<Vec<ArgKind>>())\n             }\n-            Node::Variant(&hir::Variant {\n-                span,\n-                node: hir::VariantKind {\n-                    data: hir::VariantData::Tuple(ref fields, ..),\n-                    ..\n-                },\n-                ..\n-            }) => {\n-                (self.tcx.sess.source_map().def_span(span),\n-                 fields.iter().map(|field|\n-                     ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n-                 ).collect::<Vec<_>>())\n-            }\n-            Node::StructCtor(ref variant_data) => {\n-                (self.tcx.sess.source_map().def_span(\n-                    self.tcx.hir().span_by_hir_id(variant_data.hir_id())),\n-                 vec![ArgKind::empty(); variant_data.fields().len()])\n+            Node::Ctor(_, ref variant_data) => {\n+                let span = variant_data.ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span_by_hir_id(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }"}, {"sha": "84ce826c6a588b607e06399812ba3743996d11cb", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -150,8 +150,7 @@ impl<'tcx> InstanceDef<'tcx> {\n             _ => return true\n         };\n         match tcx.def_key(def_id).disambiguated_data.data {\n-            DefPathData::StructCtor |\n-            DefPathData::EnumVariant(..) |\n+            DefPathData::StructCtor | DefPathData::VariantCtor |\n             DefPathData::ClosureExpr => true,\n             _ => false\n         }"}, {"sha": "0de91af846046afa034e368b57a6c5b2c77442d9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 179, "deletions": 69, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -8,7 +8,6 @@ use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n use crate::hir::{HirId, Node};\n use crate::hir::def::{Def, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use crate::hir::map::DefPathData;\n use rustc_data_structures::svh::Svh;\n use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n@@ -1775,12 +1774,19 @@ bitflags! {\n     #[derive(HashStable)]\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n+        /// Indicates whether the ADT is an enum.\n         const IS_ENUM             = 1 << 0;\n+        /// Indicates whether the ADT is a union.\n         const IS_UNION            = 1 << 1;\n+        /// Indicates whether the ADT is a struct.\n         const IS_STRUCT           = 1 << 2;\n+        /// Indicates whether the ADT is a struct and has a constructor.\n         const HAS_CTOR            = 1 << 3;\n+        /// Indicates whether the type is a `PhantomData`.\n         const IS_PHANTOM_DATA     = 1 << 4;\n+        /// Indicates whether the type has a `#[fundamental]` attribute.\n         const IS_FUNDAMENTAL      = 1 << 5;\n+        /// Indicates whether the type is a `Box`.\n         const IS_BOX              = 1 << 6;\n         /// Indicates whether the type is an `Arc`.\n         const IS_ARC              = 1 << 7;\n@@ -1801,77 +1807,149 @@ bitflags! {\n     }\n }\n \n+/// Definition of a variant -- a struct's fields or a enum variant.\n #[derive(Debug)]\n pub struct VariantDef {\n-    /// The variant's `DefId`. If this is a tuple-like struct,\n-    /// this is the `DefId` of the struct's ctor.\n-    pub did: DefId,\n-    pub ident: Ident, // struct's name if this is a struct\n+    /// `DefId` that identifies this enum variant. If this `VariantDef` is part of a struct or\n+    /// union then this is `None`.\n+    variant_did: Option<DefId>,\n+    /// `DefId` that identifies this enum variant or struct's constructor. If this is a\n+    /// `Struct`-variant then this is `None`.\n+    ctor_did: Option<DefId>,\n+    /// Variant or struct name.\n+    pub ident: Ident,\n+    /// Discriminant of this variant.\n     pub discr: VariantDiscr,\n+    /// Fields of this variant.\n     pub fields: Vec<FieldDef>,\n+    /// Type of constructor of variant.\n     pub ctor_kind: CtorKind,\n+    /// `DefId` of the parent `AdtDef` representing the struct or enum. This is required as there\n+    /// is a valid scenario where this type represents a `Struct`-struct and both `ctor_did` and\n+    /// `variant_did` would be `None` and we would still want a way to get back to the original\n+    /// `AdtDef`.\n+    parent_did: DefId,\n+    /// Flags of the variant (e.g. is field list non-exhaustive)?\n     flags: VariantFlags,\n+    /// Recovered?\n     pub recovered: bool,\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Creates a new `VariantDef`.\n     ///\n-    /// - `did` is the `DefId` used for the variant.\n-    /// This is the constructor `DefId` for tuple stucts, and the variant `DefId` for everything\n-    /// else.\n-    /// - `attribute_def_id` is the DefId that has the variant's attributes.\n-    /// This is the struct `DefId` for structs, and the variant `DefId` for variants.\n+    /// `variant_did` is the `DefId` that identifies the enum variant (if this `VariantDef`\n+    /// represents an enum variant).\n     ///\n-    /// Note that we *could* use the constructor `DefId`, because the constructor attributes\n-    /// redirect to the base attributes, but compiling a small crate requires\n-    /// loading the `AdtDef`s for all the structs in the universe (e.g., coherence for any\n+    /// `ctor_did` is the `DefId` that identifies the constructor of unit or\n+    /// tuple-variants/structs. If this is a `struct`-variant then this should be `None`.\n+    ///\n+    /// `parent_did` is the `DefId` of the `AdtDef` representing the enum or struct that\n+    /// owns this variant. It is used for checking if a struct has `#[non_exhaustive]` w/out having\n+    /// to go through the redirect of checking the ctor's attributes - but compiling a small crate\n+    /// requires loading the `AdtDef`s for all the structs in the universe (e.g., coherence for any\n     /// built-in trait), and we do not want to load attributes twice.\n     ///\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n     /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        did: DefId,\n         ident: Ident,\n+        variant_did: Option<DefId>,\n+        ctor_did: Option<DefId>,\n         discr: VariantDiscr,\n         fields: Vec<FieldDef>,\n-        adt_kind: AdtKind,\n         ctor_kind: CtorKind,\n-        attribute_def_id: DefId,\n+        adt_kind: AdtKind,\n+        parent_did: DefId,\n         recovered: bool,\n     ) -> Self {\n-        debug!(\"VariantDef::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?})\", did, ident, discr,\n-               fields, adt_kind, ctor_kind, attribute_def_id);\n+        debug!(\n+            \"VariantDef::new(ident = {:?}, variant_did = {:?}, ctor_did = {:?}, discr = {:?},\n+             fields = {:?}, ctor_kind = {:?}, adt_kind = {:?}, parent_did = {:?})\",\n+             ident, variant_did, ctor_did, discr, fields, ctor_kind, adt_kind, parent_did,\n+        );\n+\n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n-        if adt_kind == AdtKind::Struct && tcx.has_attr(attribute_def_id, \"non_exhaustive\") {\n-            debug!(\"found non-exhaustive field list for {:?}\", did);\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n             flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n         }\n+\n         VariantDef {\n-            did,\n+            variant_did,\n+            ctor_did,\n             ident,\n             discr,\n             fields,\n             ctor_kind,\n             flags,\n+            parent_did,\n             recovered,\n         }\n     }\n \n+    /// Is this field list non-exhaustive?\n     #[inline]\n     pub fn is_field_list_non_exhaustive(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n     }\n+\n+    /// Returns `true` if this `VariantDef` represents a enum's variant.\n+    #[inline]\n+    pub fn is_enum_variant(&self) -> bool {\n+        self.variant_did.is_some()\n+    }\n+\n+    /// Returns `true` if this `VariantDef` represents a struct.\n+    #[inline]\n+    pub fn is_struct(&self) -> bool {\n+        !self.is_enum_variant()\n+    }\n+\n+    /// Returns the `DefId` of this variant if this `VariantDef` represents an enum's variant, or\n+    /// returns the `DefId` of the parent struct.\n+    #[inline]\n+    pub fn variant_did_or_parent_struct_did(&self) -> DefId {\n+        self.variant_did.unwrap_or(self.parent_did)\n+    }\n+\n+    /// Returns `true` if the variant is defined in the local crate.\n+    #[inline]\n+    pub fn is_local(&self) -> bool {\n+        self.variant_did_or_parent_struct_did().krate == LOCAL_CRATE\n+    }\n+\n+    /// Returns the `DefId` of this variant if this `VariantDef` represents an enum's variant or\n+    /// panics.\n+    #[inline]\n+    pub fn variant_did(&self) -> DefId {\n+        self.variant_did.expect(\"enum variant without a variant id\")\n+    }\n+\n+    /// Returns the `DefId` of this variant's constructor if this is a unit or\n+    /// tuple-variant/struct.\n+    #[inline]\n+    pub fn ctor_did(&self) -> Option<DefId> {\n+        self.ctor_did\n+    }\n+\n+    /// Returns the `AdtDef` representing the struct or enum associated with this `VariantDef`.\n+    #[inline]\n+    pub fn adt_def(&self, tcx: TyCtxt<'a, 'tcx, 'gcx>) -> &'tcx AdtDef {\n+        tcx.adt_def(self.parent_did)\n+    }\n }\n \n impl_stable_hash_for!(struct VariantDef {\n-    did,\n+    variant_did,\n+    ctor_did,\n     ident -> (ident.name),\n     discr,\n     fields,\n     ctor_kind,\n     flags,\n+    parent_did,\n     recovered\n });\n \n@@ -1898,12 +1976,15 @@ pub struct FieldDef {\n \n /// The definition of an abstract data type -- a struct or enum.\n ///\n-/// These are all interned (by `intern_adt_def`) into the `adt_defs`\n-/// table.\n+/// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n pub struct AdtDef {\n+    /// `DefId` of the struct, enum or union item.\n     pub did: DefId,\n+    /// Variants of the ADT. If this is a struct or enum, then there will be a single variant.\n     pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n+    /// Flags of the ADT (e.g. is this a struct? is this non-exhaustive?)\n     flags: AdtFlags,\n+    /// Repr options provided by the user.\n     pub repr: ReprOptions,\n }\n \n@@ -2102,11 +2183,14 @@ impl ReprOptions {\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n-    fn new(tcx: TyCtxt<'_, '_, '_>,\n-           did: DefId,\n-           kind: AdtKind,\n-           variants: IndexVec<VariantIdx, VariantDef>,\n-           repr: ReprOptions) -> Self {\n+    /// Creates a new `AdtDef`.\n+    fn new(\n+        tcx: TyCtxt<'_, '_, '_>,\n+        did: DefId,\n+        kind: AdtKind,\n+        variants: IndexVec<VariantIdx, VariantDef>,\n+        repr: ReprOptions\n+    ) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n \n@@ -2120,13 +2204,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             AdtKind::Struct => AdtFlags::IS_STRUCT,\n         };\n \n-        if let AdtKind::Struct = kind {\n-            let variant_def = &variants[VariantIdx::new(0)];\n-            let def_key = tcx.def_key(variant_def.did);\n-            match def_key.disambiguated_data.data {\n-                DefPathData::StructCtor => flags |= AdtFlags::HAS_CTOR,\n-                _ => (),\n-            }\n+        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_did.is_some() {\n+            flags |= AdtFlags::HAS_CTOR;\n         }\n \n         let attrs = tcx.get_attrs(did);\n@@ -2154,21 +2233,25 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Returns `true` if this is a struct.\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_STRUCT)\n     }\n \n+    /// Returns `true` if this is a union.\n     #[inline]\n     pub fn is_union(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n+    /// Returns `true` if this is a enum.\n     #[inline]\n     pub fn is_enum(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_ENUM)\n     }\n \n+    /// Returns `true` if the variant list of this ADT is `#[non_exhaustive]`.\n     #[inline]\n     pub fn is_variant_list_non_exhaustive(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n@@ -2186,6 +2269,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Returns a description of this abstract data type.\n     pub fn descr(&self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\",\n@@ -2194,6 +2278,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Returns a description of a variant of this abstract data type.\n     #[inline]\n     pub fn variant_descr(&self) -> &'static str {\n         match self.adt_kind() {\n@@ -2266,25 +2351,53 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n+    pub fn variant_with_variant_id(&self, vid: DefId) -> &VariantDef {\n         self.variants\n             .iter()\n-            .find(|v| v.did == vid)\n-            .expect(\"variant_with_id: unknown variant\")\n+            .find(|v| v.variant_did.map(|did| did == vid).unwrap_or(false))\n+            .expect(\"variant_with_variant_id: unknown variant\")\n+    }\n+\n+    pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n+        self.variants\n+            .iter()\n+            .find(|v| v.ctor_did.map(|did| did == cid).unwrap_or(false))\n+            .expect(\"variant_with_ctor_id: unknown variant\")\n+    }\n+\n+    pub fn variant_index_with_variant_id(&self, vid: DefId) -> VariantIdx {\n+        self.variants\n+            .iter_enumerated()\n+            .find(|(_, v)| v.variant_did.map(|did| did == vid).unwrap_or(false))\n+            .expect(\"variant_index_with_variant_id: unknown variant\")\n+            .0\n+    }\n+\n+    pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n+        self.variants\n+            .iter_enumerated()\n+            .find(|(_, v)| v.ctor_did.map(|did| did == cid).unwrap_or(false))\n+            .expect(\"variant_index_with_ctor_id: unknown variant\")\n+            .0\n     }\n \n-    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n+    pub fn variant_index_with_ctor_or_variant_id(&self, id: DefId) -> VariantIdx {\n         self.variants\n             .iter_enumerated()\n-            .find(|(_, v)| v.did == vid)\n-            .expect(\"variant_index_with_id: unknown variant\")\n+            .find(|(_, v)| {\n+                let ctor = v.ctor_did.map(|did| did == id);\n+                let variant = v.variant_did.map(|did| did == id);\n+                ctor.or(variant).unwrap_or(false)\n+            })\n+            .expect(\"variant_index_with_ctor_or_variant_id: unknown variant\")\n             .0\n     }\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n-            Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+            Def::Variant(vid) => self.variant_with_variant_id(vid),\n+            Def::Ctor(hir::CtorOf::Variant, cid, ..) => self.variant_with_ctor_id(cid),\n+            Def::Struct(..) | Def::Ctor(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) |\n             Def::SelfCtor(..) => self.non_enum_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n@@ -2820,7 +2933,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            self.adjust_ident(ident, variant.did, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n+            let did = variant.variant_did.unwrap_or(variant.parent_did);\n+            self.adjust_ident(ident, did, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n         })\n     }\n \n@@ -2895,50 +3009,46 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n-            Def::Variant(did) | Def::VariantCtor(did, ..) => {\n+            Def::Variant(did) => {\n                 let enum_did = self.parent(did).unwrap();\n-                self.adt_def(enum_did).variant_with_id(did)\n+                self.adt_def(enum_did).variant_with_variant_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n                 self.adt_def(did).non_enum_variant()\n             }\n-            Def::StructCtor(ctor_did, ..) => {\n-                let did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n-                self.adt_def(did).non_enum_variant()\n+            Def::Ctor(hir::CtorOf::Variant, variant_ctor_did, ..) => {\n+                let variant_did = self.parent(variant_ctor_did).unwrap();\n+                let enum_did = self.parent(variant_did).unwrap();\n+                self.adt_def(enum_did).variant_with_ctor_id(variant_ctor_did)\n+            }\n+            Def::Ctor(hir::CtorOf::Struct, ctor_did, ..) => {\n+                let struct_did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n+                self.adt_def(struct_did).non_enum_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n         }\n     }\n \n     /// Given a `VariantDef`, returns the def-id of the `AdtDef` of which it is a part.\n     pub fn adt_def_id_of_variant(self, variant_def: &'tcx VariantDef) -> DefId {\n-        let def_key = self.def_key(variant_def.did);\n-        match def_key.disambiguated_data.data {\n-            // for enum variants and tuple structs, the def-id of the ADT itself\n-            // is the *parent* of the variant\n-            DefPathData::EnumVariant(..) | DefPathData::StructCtor =>\n-                DefId { krate: variant_def.did.krate, index: def_key.parent.unwrap() },\n-\n-            // otherwise, for structs and unions, they share a def-id\n-            _ => variant_def.did,\n-        }\n+        variant_def.parent_did\n     }\n \n     pub fn item_name(self, id: DefId) -> InternedString {\n         if id.index == CRATE_DEF_INDEX {\n             self.original_crate_name(id.krate).as_interned_str()\n         } else {\n             let def_key = self.def_key(id);\n-            // The name of a StructCtor is that of its struct parent.\n-            if let hir_map::DefPathData::StructCtor = def_key.disambiguated_data.data {\n-                self.item_name(DefId {\n-                    krate: id.krate,\n-                    index: def_key.parent.unwrap()\n-                })\n-            } else {\n-                def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n+            match def_key.disambiguated_data.data {\n+                // The name of a `StructCtor` or `VariantCtor` is that of its parent.\n+                hir_map::DefPathData::StructCtor | hir_map::DefPathData::VariantCtor =>\n+                    self.item_name(DefId {\n+                        krate: id.krate,\n+                        index: def_key.parent.unwrap()\n+                    }),\n+                _ => def_key.disambiguated_data.data.get_opt_name().unwrap_or_else(|| {\n                     bug!(\"item_name: no name for {:?}\", self.def_path(id));\n-                })\n+                }),\n             }\n         }\n     }"}, {"sha": "3d6a2cf9224bea8778cf7f4862f98131f2c92d72", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -286,13 +286,17 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n         // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n-        if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n-            let parent = DefId {\n-                krate: def_id.krate,\n-                index: cur_def_key.parent.expect(\"DefPathData::StructCtor missing a parent\"),\n-            };\n+        match cur_def_key.disambiguated_data.data {\n+            DefPathData::StructCtor | DefPathData::VariantCtor => {\n+                let parent = DefId {\n+                    krate: def_id.krate,\n+                    index: cur_def_key.parent\n+                        .expect(\"DefPathData::StructCtor/VariantData missing a parent\"),\n+                };\n \n-            cur_def_key = self.tcx().def_key(parent);\n+                cur_def_key = self.tcx().def_key(parent);\n+            },\n+            _ => {},\n         }\n \n         let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n@@ -860,6 +864,7 @@ impl TyCtxt<'_, '_, '_> {\n             DefPathData::AnonConst |\n             DefPathData::ConstParam(..) |\n             DefPathData::ClosureExpr |\n+            DefPathData::VariantCtor |\n             DefPathData::StructCtor => Namespace::ValueNS,\n \n             DefPathData::MacroDef(..) => Namespace::MacroNS,\n@@ -1024,7 +1029,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n \n         // Skip `::{{constructor}}` on tuple/unit structs.\n         match disambiguated_data.data {\n-            DefPathData::StructCtor => return Ok(self),\n+            DefPathData::StructCtor | DefPathData::VariantCtor => return Ok(self),\n             _ => {}\n         }\n "}, {"sha": "7e38ce6377c89c34b55908e0cdae936cf2e8bb88", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -85,8 +85,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n \n     match tcx.hir().get_by_hir_id(owner_id) {\n-        Node::StructCtor(_) |\n-        Node::Variant(_) => {\n+        Node::Ctor(_, _) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body"}, {"sha": "6d694dcfac7be380474231a51f32714959a9d9ed", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.data.hir_id()),\n+                                      Some(v.node.id),\n                                       &v.node.attrs,\n                                       v.span,\n                                       \"a variant\");"}, {"sha": "995532a00cd6e98c91e8a06b8602658bbe27607b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -407,6 +407,14 @@ impl cstore::CStore {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n+    pub fn ctor_kind_untracked(&self, def: DefId) -> def::CtorKind {\n+        self.get_crate_data(def.krate).get_ctor_kind(def.index)\n+    }\n+\n+    pub fn item_attrs_untracked(&self, def: DefId, sess: &Session) -> Lrc<[ast::Attribute]> {\n+        self.get_crate_data(def.krate).get_item_attrs(def.index, sess)\n+    }\n+\n     pub fn item_children_untracked(&self, def_id: DefId, sess: &Session) -> Vec<def::Export> {\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)"}, {"sha": "c6f7b46d38339b46fefd9efb05a733503b0e62bd", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -544,27 +544,33 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn get_variant(&self,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   item: &Entry<'_>,\n-                   index: DefIndex,\n-                   adt_kind: ty::AdtKind)\n-                   -> ty::VariantDef\n-    {\n+    fn get_variant(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        item: &Entry<'_>,\n+        index: DefIndex,\n+        parent_did: DefId,\n+        adt_kind: ty::AdtKind\n+    ) -> ty::VariantDef {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        let def_id = self.local_def_id(data.struct_ctor.unwrap_or(index));\n-        let attribute_def_id = self.local_def_id(index);\n+        let variant_did = if adt_kind == ty::AdtKind::Enum {\n+            Some(self.local_def_id(index))\n+        } else {\n+            None\n+        };\n+        let ctor_did = data.ctor.map(|index| self.local_def_id(index));\n \n         ty::VariantDef::new(\n             tcx,\n-            def_id,\n             Ident::from_interned_str(self.item_name(index)),\n+            variant_did,\n+            ctor_did,\n             data.discr,\n             item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n@@ -574,9 +580,9 @@ impl<'a, 'tcx> CrateMetadata {\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            adt_kind,\n             data.ctor_kind,\n-            attribute_def_id,\n+            adt_kind,\n+            parent_did,\n             false,\n         )\n     }\n@@ -599,11 +605,11 @@ impl<'a, 'tcx> CrateMetadata {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(tcx, &self.entry(index), index, kind)\n+                    self.get_variant(tcx, &self.entry(index), index, did, kind)\n                 })\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &item, item_id, kind)).collect()\n+            std::iter::once(self.get_variant(tcx, &item, item_id, did, kind)).collect()\n         };\n \n         tcx.alloc_adt_def(did, kind, variants, repr)\n@@ -808,23 +814,22 @@ impl<'a, 'tcx> CrateMetadata {\n                     // Re-export lists automatically contain constructors when necessary.\n                     match def {\n                         Def::Struct(..) => {\n-                            if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n+                            if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n-                                let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n-                                callback(def::Export {\n-                                    def: ctor_def,\n-                                    vis: self.get_visibility(ctor_def_id.index),\n-                                    ident, span,\n-                                });\n+                                let ctor_def = Def::Ctor(\n+                                    hir::CtorOf::Struct, ctor_def_id, ctor_kind);\n+                                let vis = self.get_visibility(ctor_def_id.index);\n+                                callback(def::Export { def: ctor_def, vis, ident, span });\n                             }\n                         }\n-                        Def::Variant(def_id) => {\n-                            // Braced variants, unlike structs, generate unusable names in\n-                            // value namespace, they are reserved for possible future use.\n-                            let ctor_kind = self.get_ctor_kind(child_index);\n-                            let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-                            let vis = self.get_visibility(child_index);\n-                            callback(def::Export { def: ctor_def, ident, vis, span });\n+                        Def::Variant(..) => {\n+                            if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n+                                let ctor_kind = self.get_ctor_kind(child_index);\n+                                let ctor_def = Def::Ctor(\n+                                    hir::CtorOf::Variant, ctor_def_id, ctor_kind);\n+                                let vis = self.get_visibility(ctor_def_id.index);\n+                                callback(def::Export { def: ctor_def, ident, vis, span });\n+                            }\n                         }\n                         _ => {}\n                     }\n@@ -925,10 +930,13 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n+    pub fn get_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.entry(node_id).kind {\n             EntryKind::Struct(data, _) => {\n-                data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n+                data.decode(self).ctor.map(|index| self.local_def_id(index))\n+            }\n+            EntryKind::Variant(data) => {\n+                data.decode(self).ctor.map(|index| self.local_def_id(index))\n             }\n             _ => None,\n         }"}, {"sha": "1af59f314bc2bafcc17e4f058505e661d1d27953", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -572,24 +572,21 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     /// will have to lookup the adt-def by its id, and that gives us\n     /// the right to access any information in the adt-def (including,\n     /// e.g., the length of the various vectors).\n-    fn encode_enum_variant_info(&mut self,\n-                                (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>))\n-                                -> Entry<'tcx> {\n+    fn encode_enum_variant_info(\n+        &mut self,\n+        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n-        let def_id = variant.did;\n+        let def_id = variant.variant_did();\n         debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            struct_ctor: None,\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(&tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n+            ctor: variant.ctor_did().map(|did| did.index),\n+            ctor_sig: None,\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n@@ -622,6 +619,57 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n+    /// Encode the constructor for the given variant of the given ADT. See\n+    /// `encode_enum_variant_info` for an explanation about why the index is untracked.\n+    fn encode_enum_variant_ctor(\n+        &mut self,\n+        (enum_did, Untracked(index)): (DefId, Untracked<VariantIdx>),\n+    ) -> Entry<'tcx> {\n+        let tcx = self.tcx;\n+        let def = tcx.adt_def(enum_did);\n+        let variant = &def.variants[index];\n+        let def_id = variant.ctor_did().unwrap();\n+        debug!(\"IsolatedEncoder::encode_enum_variant_ctor({:?})\", def_id);\n+\n+        let data = VariantData {\n+            ctor_kind: variant.ctor_kind,\n+            discr: variant.discr,\n+            ctor: Some(def_id.index),\n+            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n+                Some(self.lazy(&tcx.fn_sig(def_id)))\n+            } else {\n+                None\n+            }\n+        };\n+\n+        // Variant constructors have the same visibility as the parent enums.\n+        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+\n+        Entry {\n+            kind: EntryKind::Variant(self.lazy(&data)),\n+            visibility: self.lazy(&ty::Visibility::from_hir(enum_vis, enum_id, tcx)),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+            predicates_defined_on: None,\n+\n+            mir: self.encode_optimized_mir(def_id),\n+        }\n+    }\n+\n     fn encode_info_for_mod(&mut self,\n                            FromId(id, (md, attrs, vis)): FromId<(&hir::Mod,\n                                                                  &[ast::Attribute],\n@@ -678,7 +726,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let def_id = field.did;\n         debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().as_local_hir_id(variant.did).unwrap();\n+        let variant_id = tcx.hir()\n+            .as_local_hir_id(variant.variant_did_or_parent_struct_did())\n+            .unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         Entry {\n@@ -710,7 +760,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            struct_ctor: Some(def_id.index),\n+            ctor: Some(def_id.index),\n             ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n                 Some(self.lazy(&tcx.fn_sig(def_id)))\n             } else {\n@@ -1072,18 +1122,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let struct_ctor = if !struct_def.is_struct() {\n-                    Some(tcx.hir().local_def_id_from_hir_id(struct_def.hir_id()).index)\n-                } else {\n-                    None\n-                };\n+                let ctor = struct_def.ctor_hir_id()\n+                    .map(|ctor_hir_id| tcx.hir().local_def_id_from_hir_id(ctor_hir_id).index);\n \n                 let repr_options = get_repr_options(&tcx, def_id);\n \n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    struct_ctor,\n+                    ctor,\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n@@ -1094,7 +1141,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    struct_ctor: None,\n+                    ctor: None,\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n@@ -1171,8 +1218,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.variants.iter().map(|v| {\n-                        assert!(v.did.is_local());\n-                        v.did.index\n+                        let did = v.variant_did();\n+                        assert!(did.is_local());\n+                        did.index\n                     }))\n                 }\n                 hir::ItemKind::Struct(..) |\n@@ -1765,17 +1813,23 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    self.record(variant.did,\n+                    self.record(variant.variant_did(),\n                                 IsolatedEncoder::encode_enum_variant_info,\n                                 (def_id, Untracked(i)));\n+\n+                    if let Some(ctor_hir_did) = variant.ctor_did() {\n+                        self.record(ctor_hir_did,\n+                                    IsolatedEncoder::encode_enum_variant_ctor,\n+                                    (def_id, Untracked(i)));\n+                    }\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 self.encode_fields(def_id);\n \n                 // If the struct has a constructor, encode it.\n-                if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(struct_def.hir_id());\n+                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                    let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(ctor_hir_id);\n                     self.record(ctor_def_id,\n                                 IsolatedEncoder::encode_struct_ctor,\n                                 (def_id, ctor_def_id));"}, {"sha": "5b6166ebeaf59cc693321247827e826ece79715e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -445,11 +445,8 @@ impl_stable_hash_for!(struct FnData<'tcx> { constness, arg_names, sig });\n pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n-\n-    /// If this is a struct's only variant, this\n-    /// is the index of the \"struct ctor\" item.\n-    pub struct_ctor: Option<DefIndex>,\n-\n+    /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n+    pub ctor: Option<DefIndex>,\n     /// If this is a tuple struct or variant\n     /// ctor, this is its \"function\" signature.\n     pub ctor_sig: Option<Lazy<ty::PolyFnSig<'tcx>>>,\n@@ -458,7 +455,7 @@ pub struct VariantData<'tcx> {\n impl_stable_hash_for!(struct VariantData<'tcx> {\n     ctor_kind,\n     discr,\n-    struct_ctor,\n+    ctor,\n     ctor_sig\n });\n "}, {"sha": "0283352066cb85a3154e23fa5241a54e56021dc7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -31,10 +31,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get_by_hir_id(id) {\n-        Node::Variant(variant) =>\n-            return create_constructor_shim(tcx, id, &variant.node.data),\n-        Node::StructCtor(ctor) =>\n-            return create_constructor_shim(tcx, id, ctor),\n+        Node::Ctor(_, ctor) => return create_constructor_shim(tcx, id, ctor),\n \n         Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n         | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })"}, {"sha": "eb50bd727db1541f7813a49b95cee76b69f51181", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -261,10 +261,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n-                            Def::VariantCtor(variant_id, CtorKind::Fn) => {\n-                                Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n+                            Def::Ctor(hir::CtorOf::Variant, variant_ctor_id, CtorKind::Fn) => {\n+                                Some((adt_def, adt_def.variant_index_with_ctor_id(variant_ctor_id)))\n                             }\n-                            Def::StructCtor(_, CtorKind::Fn) |\n+                            Def::Ctor(hir::CtorOf::Struct, _, CtorKind::Fn) |\n                             Def::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n                             _ => None,\n                         }\n@@ -486,7 +486,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 Def::Variant(variant_id) => {\n                                     assert!(base.is_none());\n \n-                                    let index = adt.variant_index_with_id(variant_id);\n+                                    let index = adt.variant_index_with_variant_id(variant_id);\n                                     let user_provided_types = cx.tables().user_provided_types();\n                                     let user_ty = user_provided_types.get(expr.hir_id)\n                                         .map(|u_ty| *u_ty);\n@@ -677,8 +677,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         .ty_adt_def()\n                         .and_then(|adt_def| {\n                         match def {\n-                            Def::VariantCtor(variant_id, CtorKind::Const) => {\n-                                let idx = adt_def.variant_index_with_id(variant_id);\n+                            Def::Ctor(hir::CtorOf::Variant, variant_ctor_id, CtorKind::Const) => {\n+                                let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n                                 let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                 use rustc::ty::util::IntTypeExt;\n                                 let ty = adt_def.repr.discr_type();\n@@ -804,17 +804,15 @@ fn user_substs_applied_to_def(\n         // `Fn` but with the user-given substitutions.\n         Def::Fn(_) |\n         Def::Method(_) |\n-        Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) |\n+        Def::Ctor(_, _, CtorKind::Fn) |\n         Def::Const(_) |\n         Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n         // this variant -- but with the substitutions given by the\n         // user.\n-        Def::StructCtor(_def_id, CtorKind::Const) |\n-        Def::VariantCtor(_def_id, CtorKind::Const) =>\n+        Def::Ctor(_, _, CtorKind::Const) =>\n             cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n         // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n@@ -911,8 +909,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         // A regular function, constructor function or a constant.\n         Def::Fn(_) |\n         Def::Method(_) |\n-        Def::StructCtor(_, CtorKind::Fn) |\n-        Def::VariantCtor(_, CtorKind::Fn) |\n+        Def::Ctor(_, _, CtorKind::Fn) |\n         Def::SelfCtor(..) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n@@ -956,8 +953,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         },\n \n-        Def::StructCtor(def_id, CtorKind::Const) |\n-        Def::VariantCtor(def_id, CtorKind::Const) => {\n+        Def::Ctor(_, def_id, CtorKind::Const) => {\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n@@ -968,7 +964,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::Adt(adt_def, substs) => {\n                     ExprKind::Adt {\n                         adt_def,\n-                        variant_index: adt_def.variant_index_with_id(def_id),\n+                        variant_index: adt_def.variant_index_with_ctor_id(def_id),\n                         substs,\n                         user_ty: user_provided_type,\n                         fields: vec![],"}, {"sha": "9637a111f42a02ed63adfd9d489a9befd860b33b", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -435,7 +435,7 @@ impl<'tcx> Constructor<'tcx> {\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n         match self {\n-            &Variant(vid) => adt.variant_index_with_id(vid),\n+            &Variant(id) => adt.variant_index_with_ctor_or_variant_id(id),\n             &Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n@@ -659,7 +659,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::Adt(def, substs) if def.is_enum() => {\n             def.variants.iter()\n                 .filter(|v| !cx.is_variant_uninhabited(v, substs))\n-                .map(|v| Variant(v.did))\n+                .map(|v| v.ctor_did().map_or_else(|| Variant(v.variant_did()), |did| Variant(did)))\n                 .collect()\n         }\n         ty::Char => {\n@@ -1307,7 +1307,9 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatternKind::Binding { .. } | PatternKind::Wild => None,\n         PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } => {\n-            Some(vec![Variant(adt_def.variants[variant_index].did)])\n+            let variant = &adt_def.variants[variant_index];\n+            Some(variant.ctor_did()\n+                .map_or_else(|| vec![Variant(variant.variant_did())], |did| vec![Variant(did)]))\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n         PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n@@ -1742,11 +1744,11 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n-            if *constructor == Variant(variant.did) {\n-                Some(patterns_for_variant(subpatterns, wild_patterns))\n-            } else {\n-                None\n-            }\n+            variant.ctor_did()\n+                .map(|did| Variant(did))\n+                .or_else(|| Some(Variant(variant.variant_did())))\n+                .filter(|variant_constructor| variant_constructor == constructor)\n+                .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n         }\n \n         PatternKind::Leaf { ref subpatterns } => {"}, {"sha": "8349f21cdb47eaad2d0020d583aa02927af54c1b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -733,8 +733,16 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     ) -> PatternKind<'tcx> {\n+        let def = match def {\n+            Def::Ctor(hir::CtorOf::Variant, variant_ctor_id, ..) => {\n+                let variant_id = self.tcx.parent(variant_ctor_id).unwrap();\n+                Def::Variant(variant_id)\n+            },\n+            def => def,\n+        };\n+\n         let mut kind = match def {\n-            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n+            Def::Variant(variant_id) => {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n@@ -749,15 +757,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     PatternKind::Variant {\n                         adt_def,\n                         substs,\n-                        variant_index: adt_def.variant_index_with_id(variant_id),\n+                        variant_index: adt_def.variant_index_with_variant_id(variant_id),\n                         subpatterns,\n                     }\n                 } else {\n                     PatternKind::Leaf { subpatterns }\n                 }\n             }\n \n-            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+            Def::Struct(..) | Def::Ctor(hir::CtorOf::Struct, ..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) => {\n                 PatternKind::Leaf { subpatterns }\n             }"}, {"sha": "cb25db73cd2becaca867c00c2f150c48078ad548", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -880,7 +880,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     };\n \n     let variant_no = if adt_def.is_enum() {\n-        adt_def.variant_index_with_id(def_id)\n+        adt_def.variant_index_with_ctor_id(def_id)\n     } else {\n         VariantIdx::new(0)\n     };"}, {"sha": "5e5e451b75bf2d2b853aedf5c0c316302142bb94", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1,5 +1,4 @@\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::def::CtorKind;\n use rustc::mir::*;\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, TyCtxt};\n@@ -587,15 +586,12 @@ fn write_mir_sig(\n     trace!(\"write_mir_sig: {:?}\", src.instance);\n     let descr = tcx.describe_def(src.def_id());\n     let is_function = match descr {\n-        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Variant(..)) |\n-        Some(Def::StructCtor(_, CtorKind::Fn)) => true,\n+        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Ctor(..)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n     match (descr, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n-        (Some(Def::StructCtor(..)), _) => write!(w, \"struct \")?,\n-        (Some(Def::Const(_)), _)\n-        | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n+        (Some(Def::Const(_)), _) | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n         (Some(Def::Static(_, /*is_mutbl*/false)), _) => write!(w, \"static \")?,\n         (Some(Def::Static(_, /*is_mutbl*/true)), _) => write!(w, \"static mut \")?,\n         (_, _) if is_function => write!(w, \"fn \")?,"}, {"sha": "71eb6ed7e0517be357bfb9038198eb437f60f0f0", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -322,8 +322,8 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Path(ref qpath) => {\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n-                Def::VariantCtor(..) | Def::StructCtor(..) |\n-                Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => Promotable,\n+                Def::Ctor(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) =>\n+                    Promotable,\n \n                 // References to a static that are themselves within a static\n                 // are inherently promotable with the exception\n@@ -387,8 +387,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 Def::Err\n             };\n             let def_result = match def {\n-                Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::Ctor(_, _, CtorKind::Fn) |\n                 Def::SelfCtor(..) => Promotable,\n                 Def::Fn(did) => v.handle_const_fn_call(did),\n                 Def::Method(did) => {"}, {"sha": "96fdb6a438228e5e0b0cec9e92140485f4981edb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -225,7 +225,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             let vis = match tcx.hir().get_by_hir_id(hir_id) {\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n-                Node::TraitItem(..) | Node::Variant(..) => {\n+                Node::TraitItem(..) | Node::Variant(..) | Node::Ctor(hir::CtorOf::Variant, ..) => {\n                     return def_id_visibility(tcx, tcx.hir().get_parent_did_by_hir_id(hir_id));\n                 }\n                 Node::ImplItem(impl_item) => {\n@@ -239,7 +239,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                         node => bug!(\"unexpected node kind: {:?}\", node),\n                     }\n                 }\n-                Node::StructCtor(vdata) => {\n+                Node::Ctor(hir::CtorOf::Struct, vdata) => {\n                     let struct_hir_id = tcx.hir().get_parent_item(hir_id);\n                     let item = match tcx.hir().get_by_hir_id(struct_hir_id) {\n                         Node::Item(item) => item,\n@@ -504,7 +504,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.data.hir_id(), item_level);\n+                    let variant_level = self.update(variant.node.id, item_level);\n+                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                        self.update(ctor_hir_id, item_level);\n+                    }\n                     for field in variant.node.data.fields() {\n                         self.update(field.hir_id, variant_level);\n                     }\n@@ -523,8 +526,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n-                if !def.is_struct() {\n-                    self.update(def.hir_id(), item_level);\n+                if let Some(ctor_hir_id) = def.ctor_hir_id() {\n+                    self.update(ctor_hir_id, item_level);\n                 }\n                 for field in def.fields() {\n                     if field.vis.node.is_pub() {\n@@ -624,7 +627,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.data.hir_id());\n+                    let variant_level = self.get(variant.node.id);\n                     if variant_level.is_some() {\n                         for field in variant.node.data.fields() {\n                             self.reach(field.hir_id, variant_level).ty();\n@@ -1468,7 +1471,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.data.hir_id()) {\n+        if self.access_levels.is_reachable(v.node.id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;"}, {"sha": "72197d4a17aa503757c9b60b7d7f147762b9eeab", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -12,7 +12,7 @@ use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n use crate::{resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::bug;\n-use rustc::hir::def::*;\n+use rustc::hir::{self, def::*};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n@@ -532,9 +532,10 @@ impl<'a> Resolver<'a> {\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n-                if !struct_def.is_struct() {\n-                    let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n-                                                   CtorKind::from_ast(struct_def));\n+                if let Some(ctor_node_id) = struct_def.ctor_id() {\n+                    let ctor_def = Def::Ctor(hir::CtorOf::Struct,\n+                                             self.definitions.local_def_id(ctor_node_id),\n+                                             CtorKind::from_ast(struct_def));\n                     self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, sp, expansion));\n                     self.struct_constructors.insert(def.def_id(), (ctor_def, ctor_vis));\n                 }\n@@ -581,7 +582,7 @@ impl<'a> Resolver<'a> {\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n         let ident = variant.node.ident;\n-        let def_id = self.definitions.local_def_id(variant.node.data.id());\n+        let def_id = self.definitions.local_def_id(variant.node.id);\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n@@ -590,10 +591,22 @@ impl<'a> Resolver<'a> {\n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n-        let ctor_kind = CtorKind::from_ast(&variant.node.data);\n-        let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n+        if let Some(ctor_node_id) = variant.node.data.ctor_id() {\n+            let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n+            let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+            let ctor_def = Def::Ctor(hir::CtorOf::Variant, ctor_def_id, ctor_kind);\n \n-        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n+            self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        } else {\n+            // We normally don't have a `Def::Ctor(hir::CtorOf::Variant, ..)` for\n+            // `Struct`-variants, but we must define one for name resolution to succeed. This also\n+            // takes place in `build_reduced_graph_for_external_crate_def`.\n+            let def_id = self.definitions.local_def_id(variant.node.id);\n+            let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+            let ctor_def = Def::Ctor(hir::CtorOf::Variant, def_id, ctor_kind);\n+\n+            self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        }\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -645,14 +658,29 @@ impl<'a> Resolver<'a> {\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Def::Variant(..) | Def::TyAlias(..) | Def::ForeignTy(..) | Def::Existential(..) |\n-            Def::TraitAlias(..) | Def::PrimTy(..) | Def::ToolMod => {\n+            Def::Variant(def_id) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n+\n+                if hir::def::CtorKind::Fictive == self.cstore.ctor_kind_untracked(def_id) {\n+                    // We do not normally generate `Def::Ctor(hir::CtorOf::Variant, ..)` for\n+                    // `Struct`-variants. Therefore, `build_reduced_graph_for_external_crate_def`\n+                    // will not be called to define one. However, name resolution currently expects\n+                    // there to be one, so we generate one here. This is easy to solve for local\n+                    // code, see `build_reduced_graph_for_variant` for this case.\n+                    let ctor_def = Def::Ctor(hir::CtorOf::Variant, def_id,\n+                                             hir::def::CtorKind::Fictive);\n+\n+                    let _ = self.try_define(\n+                        parent, ident, ValueNS,\n+                        (ctor_def, vis, DUMMY_SP, expansion).to_name_binding(self.arenas),\n+                    );\n+                }\n             }\n-            Def::Fn(..) | Def::Static(..) | Def::Const(..) | Def::VariantCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n+            Def::TyAlias(..) | Def::ForeignTy(..) | Def::Existential(..) | Def::TraitAlias(..) |\n+            Def::PrimTy(..) | Def::ToolMod => {\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }\n-            Def::StructCtor(def_id, ..) => {\n+            Def::Ctor(hir::CtorOf::Struct, def_id, ..) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n@@ -661,6 +689,15 @@ impl<'a> Resolver<'a> {\n                     self.struct_constructors.insert(struct_def_id, (def, vis));\n                 }\n             }\n+            Def::Ctor(hir::CtorOf::Variant, ..) => {\n+                let _ = self.try_define(\n+                    parent, ident, ValueNS,\n+                    (def, vis, DUMMY_SP, expansion).to_name_binding(self.arenas),\n+                );\n+            }\n+            Def::Fn(..) | Def::Static(..) | Def::Const(..) => {\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n+            }\n             Def::Trait(def_id) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);\n                 let module = self.new_module(parent,"}, {"sha": "6426ca12c6c92eb8684781fcbbb97a8879d335c0", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::*;\n+use rustc::hir::{self, def::*};\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::config::nightly_options;\n@@ -417,7 +417,7 @@ impl<'a> Resolver<'a> {\n             }\n             (Def::Union(..), _) |\n             (Def::Variant(..), _) |\n-            (Def::VariantCtor(_, CtorKind::Fictive), _) if ns == ValueNS => {\n+            (Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Fictive), _) if ns == ValueNS => {\n                 err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n                                              path_str));\n             }"}, {"sha": "e421a9edf89276cd361d34707fc17f82fc846f8e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -571,24 +571,20 @@ impl<'a> PathSource<'a> {\n                 _ => false,\n             },\n             PathSource::Expr(..) => match def {\n-                Def::StructCtor(_, CtorKind::Const) | Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Const) | Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::Ctor(_, _, CtorKind::Const) | Def::Ctor(_, _, CtorKind::Fn) |\n                 Def::Const(..) | Def::Static(..) | Def::Local(..) | Def::Upvar(..) |\n                 Def::Fn(..) | Def::Method(..) | Def::AssociatedConst(..) |\n                 Def::SelfCtor(..) | Def::ConstParam(..) => true,\n                 _ => false,\n             },\n             PathSource::Pat => match def {\n-                Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) |\n+                Def::Ctor(_, _, CtorKind::Const) |\n                 Def::Const(..) | Def::AssociatedConst(..) |\n                 Def::SelfCtor(..) => true,\n                 _ => false,\n             },\n             PathSource::TupleStruct => match def {\n-                Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) |\n-                Def::SelfCtor(..) => true,\n+                Def::Ctor(_, _, CtorKind::Fn) | Def::SelfCtor(..) => true,\n                 _ => false,\n             },\n             PathSource::Struct => match def {\n@@ -1364,7 +1360,7 @@ impl<'a> NameBinding<'a> {\n     fn is_variant(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Def(Def::Variant(..), _) |\n-            NameBindingKind::Def(Def::VariantCtor(..), _) => true,\n+            NameBindingKind::Def(Def::Ctor(hir::CtorOf::Variant, ..), _) => true,\n             _ => false,\n         }\n     }\n@@ -3089,16 +3085,14 @@ impl<'a> Resolver<'a> {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n                             bmode == BindingMode::ByValue(Mutability::Immutable);\n                         match def {\n-                            Def::StructCtor(_, CtorKind::Const) |\n-                            Def::VariantCtor(_, CtorKind::Const) |\n+                            Def::Ctor(_, _, CtorKind::Const) |\n                             Def::Const(..) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n                                 self.record_use(ident, ValueNS, binding.unwrap(), false);\n                                 Some(PathResolution::new(def))\n                             }\n-                            Def::StructCtor(..) | Def::VariantCtor(..) |\n-                            Def::Const(..) | Def::Static(..) => {\n+                            Def::Ctor(..) | Def::Const(..) | Def::Static(..) => {\n                                 // This is unambiguously a fresh binding, either syntactically\n                                 // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n                                 // to something unusable as a pattern (e.g., constructor function),\n@@ -4458,8 +4452,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match def {\n-                                Def::StructCtor(did, _) | Def::VariantCtor(did, _) =>\n-                                    self.parent(did),\n+                                Def::Ctor(_, did, _) => self.parent(did),\n                                 _ => def.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });"}, {"sha": "77fe57910cb780f7c30fe839af13ef7130a5e484", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -880,10 +880,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Ok(binding) => {\n                     let imported_binding = this.import(binding, directive);\n                     target_bindings[ns].set(Some(imported_binding));\n-                    let conflict = this.try_define(parent, target, ns, imported_binding);\n-                    if let Err(old_binding) = conflict {\n-                        this.report_conflict(parent, target, ns, imported_binding, old_binding);\n-                    }\n+                    this.define(parent, target, ns, imported_binding);\n                 }\n             }\n         });"}, {"sha": "263f5acb662fc6ba1e3505d81e7f2abf8b13407e", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -488,8 +488,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         };\n \n         let (value, fields) = match item.node {\n-            ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), _) |\n-            ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), _) => {\n+            ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, ..), ..) |\n+            ast::ItemKind::Union(ast::VariantData::Struct(ref fields, ..), ..) => {\n                 let include_priv_fields = !self.save_ctxt.config.pub_only;\n                 let fields_str = fields\n                     .iter()\n@@ -581,7 +581,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n+                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -619,7 +619,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n+                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -648,7 +648,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n \n             for field in variant.node.data.fields() {\n-                self.process_struct_field_def(field, variant.node.data.id());\n+                self.process_struct_field_def(field, variant.node.id);\n                 self.visit_ty(&field.ty);\n             }\n         }\n@@ -957,8 +957,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         );\n                     }\n                 }\n-                HirDef::StructCtor(..) |\n-                HirDef::VariantCtor(..) |\n+                HirDef::Ctor(_, _, _) |\n                 HirDef::Const(..) |\n                 HirDef::AssociatedConst(..) |\n                 HirDef::Struct(..) |"}, {"sha": "de9a4b92c820d6b209adde653dd6fb5cf2954037", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -298,7 +298,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     parent: None,\n                     children: def.variants\n                         .iter()\n-                        .map(|v| id_from_node_id(v.node.data.id(), self))\n+                        .map(|v| id_from_node_id(v.node.id, self))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n@@ -725,16 +725,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_node_id(id, self),\n                 })\n             }\n-            HirDef::Static(..) |\n-            HirDef::Const(..) |\n-            HirDef::AssociatedConst(..) |\n-            HirDef::VariantCtor(..) => {\n-                Some(Ref {\n-                    kind: RefKind::Variable,\n-                    span,\n-                    ref_id: id_from_def_id(def.def_id()),\n-                })\n-            }\n             HirDef::Trait(def_id) if fn_type(path_seg) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n@@ -767,7 +757,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::StructCtor(def_id, _) => {\n+            HirDef::Ctor(hir::CtorOf::Struct, def_id, _) => {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n@@ -778,6 +768,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(parent_def_id),\n                 })\n             }\n+            HirDef::Static(..) |\n+            HirDef::Const(..) |\n+            HirDef::AssociatedConst(..) |\n+            HirDef::Ctor(..) => {\n+                Some(Ref {\n+                    kind: RefKind::Variable,\n+                    span,\n+                    ref_id: id_from_def_id(def.def_id()),\n+                })\n+            }\n             HirDef::Method(decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);"}, {"sha": "76034f32c741c9d396ab550a6733eb22040f986e", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -586,7 +586,7 @@ impl Sig for ast::Path {\n                     refs: vec![],\n                 })\n             }\n-            Def::AssociatedConst(..) | Def::Variant(..) | Def::VariantCtor(..) => {\n+            Def::AssociatedConst(..) | Def::Variant(..) | Def::Ctor(..) => {\n                 let len = self.segments.len();\n                 if len < 2 {\n                     return Err(\"Bad path\");\n@@ -700,10 +700,11 @@ impl Sig for ast::StructField {\n \n \n impl Sig for ast::Variant_ {\n-    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n+    fn make(&self, offset: usize, parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {\n-            ast::VariantData::Struct(ref fields, id, r) => {\n+            ast::VariantData::Struct(ref fields, r) => {\n+                let id = parent_id.unwrap();\n                 let name_def = SigElement {\n                     id: id_from_node_id(id, scx),\n                     start: offset,"}, {"sha": "ad62d2160b1ebdbf7e5d99ff397e169b59b9df90", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1318,10 +1318,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    let def = Def::Variant(variant_def.did);\n+                    let did = variant_def.variant_did();\n+                    let def = Def::Variant(did);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n-                        tcx.check_stability(variant_def.did, Some(hir_ref_id), span);\n+                        tcx.check_stability(did, Some(hir_ref_id), span);\n                         return (qself_ty, def);\n                     } else {\n                         variant_resolution = Some(def);\n@@ -1596,7 +1597,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         match def {\n             // Case 1. Reference to a struct constructor.\n-            Def::StructCtor(def_id, ..) |\n+            Def::Ctor(hir::CtorOf::Struct, def_id, ..) |\n             Def::SelfCtor(.., def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n@@ -1608,15 +1609,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 2. Reference to a variant constructor.\n-            Def::Variant(def_id) |\n-            Def::VariantCtor(def_id, ..) => {\n+            Def::Ctor(hir::CtorOf::Variant, def_id, ..) | Def::Variant(def_id, ..) => {\n                 let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n                 let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                     debug_assert!(adt_def.is_enum());\n                     (adt_def.did, last)\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n                     // Everything but the penultimate segment should have no\n                     // parameters at all.\n+                    let mut def_id = def_id;\n+\n+                    // `Def::Ctor` -> `Def::Variant`\n+                    if let Def::Ctor(..) = def {\n+                        def_id = tcx.parent(def_id).unwrap()\n+                    }\n+\n+                    // `Def::Variant` -> `Def::Item` (enum)\n                     let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {"}, {"sha": "6d441521a9e9841efdd3fde536207101d6aceb6e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -807,15 +807,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Fictive) |\n-            Def::VariantCtor(_, CtorKind::Fn) => {\n+            Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Fictive) |\n+            Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Fn) => {\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Const) |\n-            Def::StructCtor(_, CtorKind::Const) |\n-            Def::SelfCtor(..) |\n-            Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n+            Def::Ctor(_, _, CtorKind::Const) | Def::SelfCtor(..) | Def::Const(..) |\n+            Def::AssociatedConst(..) => {} // OK\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         }\n \n@@ -876,8 +874,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 report_unexpected_def(def);\n                 return tcx.types.err;\n             }\n-            Def::VariantCtor(_, CtorKind::Fn) |\n-            Def::StructCtor(_, CtorKind::Fn) => {\n+            Def::Ctor(_, _, CtorKind::Fn) => {\n                 tcx.expect_variant_def(def)\n             }\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n@@ -950,7 +947,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n+            let ident = tcx.adjust_ident(\n+                field.ident, variant.variant_did_or_parent_struct_did(), self.body_id).0;\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,\n@@ -998,18 +996,19 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                             .join(\", \")), \"these\", \"s\")\n             };\n             let spans = inexistent_fields.iter().map(|(span, _)| *span).collect::<Vec<_>>();\n+            let did = variant.variant_did_or_parent_struct_did();\n             let mut err = struct_span_err!(tcx.sess,\n                                            spans,\n                                            E0026,\n                                            \"{} `{}` does not have {}\",\n                                            kind_name,\n-                                           tcx.def_path_str(variant.did),\n+                                           tcx.def_path_str(did),\n                                            field_names);\n             if let Some((span, ident)) = inexistent_fields.last() {\n                 err.span_label(*span,\n                                format!(\"{} `{}` does not have {} field{}\",\n                                        kind_name,\n-                                       tcx.def_path_str(variant.did),\n+                                       tcx.def_path_str(did),\n                                        t,\n                                        plural));\n                 if plural == \"\" {"}, {"sha": "5d10f531ced4d9f96803eef31a9f772a0bd627f7", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.def_path_str(variant.did);\n+                            let variant_path = self.tcx.def_path_str(variant.variant_did());\n                             // FIXME #56861: DRYer prelude filtering\n                             Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n                         } else {"}, {"sha": "f860ab649f990799ed178d6972f2a6ab505d6df1", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -417,7 +417,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(variant_def) = variant_def {\n                     check_type_alias_enum_variants_enabled(tcx, span);\n \n-                    let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n+                    let def = if let Some(ctor_did) = variant_def.ctor_did() {\n+                        Def::Ctor(hir::CtorOf::Variant, ctor_did, variant_def.ctor_kind)\n+                    } else {\n+                        // Normally, there do not exist any `Def::Ctor` for `Struct`-variants but\n+                        // in this case, we can get better error messages as diagnostics will\n+                        // specialize the message around a `CtorKind::Fictive`.\n+                        Def::Ctor(hir::CtorOf::Variant, variant_def.variant_did(),\n+                                  hir::def::CtorKind::Fictive)\n+                    };\n+\n                     tcx.check_stability(def.def_id(), Some(expr_id), span);\n                     return Ok(def);\n                 }"}, {"sha": "fe17f247916b68586e7c7d46f581f2e3e211daf9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1863,7 +1863,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_did = def.variants[VariantIdx::new(i)].did;\n+            let variant_did = def.variants[VariantIdx::new(i)].variant_did();\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.node.disr_expr {\n@@ -3693,7 +3693,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n             if skip.iter().any(|x| *x == field.ident.as_str()) ||\n-               (variant.did.krate != LOCAL_CRATE && field.vis != Visibility::Public) {\n+               (!variant.is_local() && field.vis != Visibility::Public)\n+            {\n                 None\n             } else {\n                 Some(&field.ident.name)\n@@ -3705,7 +3706,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n         variant.fields.iter().filter(|field| {\n-            let def_scope = self.tcx.adjust_ident(field.ident, variant.did, self.body_id).1;\n+            let did = variant.variant_did_or_parent_struct_did();\n+            let def_scope = self.tcx.adjust_ident(field.ident, did, self.body_id).1;\n             field.vis.is_accessible_from(def_scope, self.tcx)\n         })\n         .map(|field| field.ident.name)\n@@ -3823,7 +3825,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type-check each field.\n         for field in ast_fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n+            let ident = tcx.adjust_ident(\n+                field.ident, variant.variant_did_or_parent_struct_did(), self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.hir_id, i);\n@@ -4237,7 +4240,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.set_tainted_by_errors();\n                         tcx.types.err\n                     }\n-                    Def::VariantCtor(_, CtorKind::Fictive) => {\n+                    Def::Ctor(hir::CtorOf::Variant, _, CtorKind::Fictive) => {\n                         report_unexpected_variant_def(tcx, &def, expr.span, qpath);\n                         tcx.types.err\n                     }\n@@ -5343,8 +5346,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match adt_def {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n-                    let def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                    (def, variant.did, tcx.type_of(variant.did))\n+                    let ctor_did = variant.ctor_did().unwrap();\n+                    let def = Def::Ctor(hir::CtorOf::Struct, ctor_did, variant.ctor_kind);\n+                    (def, ctor_did, tcx.type_of(ctor_did))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(span,\n@@ -5416,7 +5420,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n         match def {\n-            Def::VariantCtor(_, _) => {\n+            Def::Ctor(hir::CtorOf::Variant, _, _) => {\n                 if let Some(self_ty) = self_ty {\n                     let adt_def = self_ty.ty_adt_def().unwrap();\n                     user_self_ty = Some(UserSelfTy {"}, {"sha": "56129479f775548db82dda0910ea26817ddd4173", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 66, "deletions": 73, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -446,8 +446,8 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n                 tcx.predicates_of(def_id);\n             }\n \n-            if !struct_def.is_struct() {\n-                convert_variant_ctor(tcx, struct_def.hir_id());\n+            if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                convert_variant_ctor(tcx, ctor_hir_id);\n             }\n         }\n \n@@ -556,21 +556,24 @@ fn convert_enum_variant_types<'a, 'tcx>(\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        convert_variant_ctor(tcx, variant.node.data.hir_id());\n+        if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+            convert_variant_ctor(tcx, ctor_hir_id);\n+        }\n     }\n }\n \n fn convert_variant<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    did: DefId,\n+    variant_did: Option<DefId>,\n+    ctor_did: Option<DefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n     adt_kind: ty::AdtKind,\n-    attribute_def_id: DefId\n+    parent_did: DefId\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().as_local_hir_id(did).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n     let fields = def\n         .fields()\n         .iter()\n@@ -599,17 +602,19 @@ fn convert_variant<'a, 'tcx>(\n         })\n         .collect();\n     let recovered = match def {\n-        hir::VariantData::Struct(_, _, r) => *r,\n+        hir::VariantData::Struct(_, r) => *r,\n         _ => false,\n     };\n-    ty::VariantDef::new(tcx,\n-        did,\n+    ty::VariantDef::new(\n+        tcx,\n         ident,\n+        variant_did,\n+        ctor_did,\n         discr,\n         fields,\n-        adt_kind,\n         CtorKind::from_hir(def),\n-        attribute_def_id,\n+        adt_kind,\n+        parent_did,\n         recovered,\n     )\n }\n@@ -627,58 +632,52 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n     let (kind, variants) = match item.node {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n-            (\n-                AdtKind::Enum,\n-                def.variants\n-                    .iter()\n-                    .map(|v| {\n-                        let did = tcx.hir().local_def_id_from_hir_id(v.node.data.hir_id());\n-                        let discr = if let Some(ref e) = v.node.disr_expr {\n-                            distance_from_explicit = 0;\n-                            ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n-                        } else {\n-                            ty::VariantDiscr::Relative(distance_from_explicit)\n-                        };\n-                        distance_from_explicit += 1;\n+            let variants = def.variants\n+                .iter()\n+                .map(|v| {\n+                    let variant_did = Some(tcx.hir().local_def_id_from_hir_id(v.node.id));\n+                    let ctor_did = v.node.data.ctor_hir_id()\n+                        .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+\n+                    let discr = if let Some(ref e) = v.node.disr_expr {\n+                        distance_from_explicit = 0;\n+                        ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n+                    } else {\n+                        ty::VariantDiscr::Relative(distance_from_explicit)\n+                    };\n+                    distance_from_explicit += 1;\n \n-                        convert_variant(tcx, did, v.node.ident, discr, &v.node.data, AdtKind::Enum,\n-                                        did)\n-                    })\n-                    .collect(),\n-            )\n+                    convert_variant(tcx, variant_did, ctor_did, v.node.ident, discr,\n+                                    &v.node.data, AdtKind::Enum, def_id)\n+                })\n+                .collect();\n+\n+            (AdtKind::Enum, variants)\n         }\n         ItemKind::Struct(ref def, _) => {\n-            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-            let ctor_id = if !def.is_struct() {\n-                Some(tcx.hir().local_def_id_from_hir_id(def.hir_id()))\n-            } else {\n-                None\n-            };\n-            (\n-                AdtKind::Struct,\n-                std::iter::once(convert_variant(\n-                    tcx,\n-                    ctor_id.unwrap_or(def_id),\n-                    item.ident,\n-                    ty::VariantDiscr::Relative(0),\n-                    def,\n-                    AdtKind::Struct,\n-                    def_id\n-                )).collect(),\n-            )\n-        }\n-        ItemKind::Union(ref def, _) => (\n-            AdtKind::Union,\n-            std::iter::once(convert_variant(\n-                tcx,\n-                def_id,\n-                item.ident,\n-                ty::VariantDiscr::Relative(0),\n-                def,\n-                AdtKind::Union,\n-                def_id\n-            )).collect(),\n-        ),\n+            let variant_did = None;\n+            let ctor_did = def.ctor_hir_id()\n+                .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+\n+            let variants = std::iter::once(convert_variant(\n+                tcx, variant_did, ctor_did, item.ident, ty::VariantDiscr::Relative(0), def,\n+                AdtKind::Struct, def_id,\n+            )).collect();\n+\n+            (AdtKind::Struct, variants)\n+        }\n+        ItemKind::Union(ref def, _) => {\n+            let variant_did = None;\n+            let ctor_did = def.ctor_hir_id()\n+                .map(|hir_id| tcx.hir().local_def_id_from_hir_id(hir_id));\n+\n+            let variants = std::iter::once(convert_variant(\n+                tcx, variant_did, ctor_did, item.ident, ty::VariantDiscr::Relative(0), def,\n+                AdtKind::Union, def_id,\n+            )).collect();\n+\n+            (AdtKind::Union, variants)\n+        },\n         _ => bug!(),\n     };\n     tcx.alloc_adt_def(def_id, kind, variants, repr)\n@@ -889,8 +888,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n     let node = tcx.hir().get_by_hir_id(hir_id);\n     let parent_def_id = match node {\n-        Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_)\n-        | Node::StructCtor(_) | Node::Field(_) => {\n+        Node::ImplItem(_) | Node::TraitItem(_) | Node::Variant(_) |\n+        Node::Ctor(..) | Node::Field(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id_from_hir_id(parent_id))\n         }\n@@ -1248,8 +1247,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        Node::StructCtor(&ref def)\n-        | Node::Variant(&Spanned {\n+        Node::Ctor(_, &ref def) | Node::Variant(&Spanned {\n             node: hir::VariantKind { data: ref def, .. },\n             ..\n         }) => match *def {\n@@ -1627,17 +1625,12 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        StructCtor(&VariantData::Tuple(ref fields, ..))\n-        | Variant(&Spanned {\n-            node:\n-                hir::VariantKind {\n-                    data: VariantData::Tuple(ref fields, ..),\n-                    ..\n-                },\n+        Ctor(_, data) | Variant(Spanned {\n+            node: hir::VariantKind { data, ..  },\n             ..\n-        }) => {\n+        }) if data.ctor_hir_id().is_some() => {\n             let ty = tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id));\n-            let inputs = fields\n+            let inputs = data.fields()\n                 .iter()\n                 .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n             ty::Binder::bind(tcx.mk_fn_sig("}, {"sha": "f2406bd8540b5b804bde26bbdd1687a0bef150bf", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 self.visit_node_helper(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.visit_node_helper(struct_def.hir_id());\n+                    self.visit_node_helper(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n@@ -84,7 +84,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.hir_id());\n+                        self.visit_node_helper(variant.node.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "9b9a6bace96b10fbf35454ab9201b4ceee089fe2", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -79,7 +79,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             _ => unsupported()\n         },\n \n-        Node::Variant(_) | Node::StructCtor(_) => {}\n+        Node::Variant(_) | Node::Ctor(..) => {}\n \n         _ => unsupported()\n     }"}, {"sha": "ac686e40076eb54a8de4e6923c7a7a5728fc1c9f", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.add_inferreds_for_item(struct_def.hir_id());\n+                    self.add_inferreds_for_item(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n@@ -145,7 +145,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.hir_id());\n+                        self.add_inferreds_for_item(variant.node.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "5969aa758df2c292fa7e933e33d3f3a8272fa909", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -88,9 +88,7 @@ pub fn try_inline(\n         Def::Variant(..) => return None,\n         // Assume that enum variants and struct types are re-exported next to\n         // their constructors.\n-        Def::VariantCtor(..) |\n-        Def::StructCtor(..) |\n-        Def::SelfCtor(..) => return Some(Vec::new()),\n+        Def::Ctor(..) | Def::SelfCtor(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, did, visited))"}, {"sha": "3ebca05f7dd85850e3e129aad724b8e55fd28037", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -3133,7 +3133,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.def.hir_id()),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -3169,15 +3169,16 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n                 })\n             }\n         };\n+        let did = self.variant_did_or_parent_struct_did();\n         Item {\n             name: Some(self.ident.clean(cx)),\n-            attrs: inline::load_attrs(cx, self.did),\n-            source: cx.tcx.def_span(self.did).clean(cx),\n+            attrs: inline::load_attrs(cx, did),\n+            source: cx.tcx.def_span(did).clean(cx),\n             visibility: Some(Inherited),\n-            def_id: self.did,\n+            def_id: did,\n             inner: VariantItem(Variant { kind }),\n-            stability: get_stability(cx, self.did),\n-            deprecation: get_deprecation(cx, self.did),\n+            stability: get_stability(cx, did),\n+            deprecation: get_deprecation(cx, did),\n         }\n     }\n }"}, {"sha": "7a528e50e9c3f8aaccc00936d51d84ed3a3d2920", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -125,6 +125,7 @@ pub struct Enum {\n \n pub struct Variant {\n     pub name: Name,\n+    pub id: hir::HirId,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub def: hir::VariantData,\n     pub stab: Option<attr::Stability>,"}, {"sha": "ee182237b49ec540d8f5546a8e7adf3decf04d91", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -344,9 +344,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 .and_then(|(def, fragment)| {\n                                     // Constructors are picked up in the type namespace.\n                                     match def {\n-                                        Def::StructCtor(..)\n-                                        | Def::VariantCtor(..)\n-                                        | Def::SelfCtor(..) => None,\n+                                        Def::Ctor(..) | Def::SelfCtor(..) => None,\n                                         _ => Some((def, fragment))\n                                     }\n                                 }),"}, {"sha": "a7e2b2155e9f34dacd0d2598655482edab98522c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -141,9 +141,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n                 name: v.node.ident.name,\n+                id: v.node.id,\n                 attrs: v.node.attrs.clone(),\n-                stab: self.stability(v.node.data.hir_id()),\n-                depr: self.deprecation(v.node.data.hir_id()),\n+                stab: self.stability(v.node.id),\n+                depr: self.deprecation(v.node.id),\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n@@ -420,8 +421,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // Struct and variant constructors and proc macro stubs always show up alongside\n                 // their definitions, we've already processed them so just discard these.\n                 match path.def {\n-                    Def::StructCtor(..) | Def::VariantCtor(..) | Def::SelfCtor(..) |\n-                    Def::Macro(_, MacroKind::ProcMacroStub) => return,\n+                    Def::Ctor(..) | Def::SelfCtor(..) | Def::Macro(_, MacroKind::ProcMacroStub) =>\n+                        return,\n                     _ => {}\n                 }\n "}, {"sha": "c64ffb1232fbaaef4a9f46c8950a20e62eb6a2d0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1956,8 +1956,13 @@ pub struct EnumDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Variant_ {\n+    /// Name of the variant.\n     pub ident: Ident,\n+    /// Attributes of the variant.\n     pub attrs: Vec<Attribute>,\n+    /// Id of the variant (not the constructor, see `VariantData::ctor_id()`).\n+    pub id: NodeId,\n+    /// Fields and constructor id of the variant.\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`.\n     pub disr_expr: Option<AnonConst>,\n@@ -2117,23 +2122,13 @@ pub struct StructField {\n     pub attrs: Vec<Attribute>,\n }\n \n-/// Fields and Ids of enum variants and structs\n-///\n-/// For enum variants: `NodeId` represents both an Id of the variant itself (relevant for all\n-/// variant kinds) and an Id of the variant's constructor (not relevant for `Struct`-variants).\n-/// One shared Id can be successfully used for these two purposes.\n-/// Id of the whole enum lives in `Item`.\n-///\n-/// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n-/// the variant itself\" from enum variants.\n-/// Id of the whole struct lives in `Item`.\n+/// Fields and constructor ids of enum variants and structs.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<StructField>, NodeId, bool),\n+    Struct(Vec<StructField>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n@@ -2145,31 +2140,41 @@ pub enum VariantData {\n }\n \n impl VariantData {\n+    /// Return the fields of this variant.\n     pub fn fields(&self) -> &[StructField] {\n         match *self {\n             VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n             _ => &[],\n         }\n     }\n-    pub fn id(&self) -> NodeId {\n+\n+    /// Return the `NodeId` of this variant's constructor, if it has one.\n+    pub fn ctor_id(&self) -> Option<NodeId> {\n         match *self {\n-            VariantData::Struct(_, id, _) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id,\n+            VariantData::Struct(..) => None,\n+            VariantData::Tuple(_, id) | VariantData::Unit(id) => Some(id),\n         }\n     }\n+\n+    /// Does this `VariantData` represent a `Struct`-struct/variant?\n     pub fn is_struct(&self) -> bool {\n         if let VariantData::Struct(..) = *self {\n             true\n         } else {\n             false\n         }\n     }\n+\n+    /// Does this `VariantData` represent a tuple struct/variant?\n     pub fn is_tuple(&self) -> bool {\n         if let VariantData::Tuple(..) = *self {\n             true\n         } else {\n             false\n         }\n     }\n+\n+    /// Does this `VariantData` represent a unit struct/variant?\n     pub fn is_unit(&self) -> bool {\n         if let VariantData::Unit(..) = *self {\n             true"}, {"sha": "18173628a2602f922cf89d8b0cb89ed675ffc295", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -225,10 +225,9 @@ impl<'a> StripUnconfigured<'a> {\n \n     fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n         match vdata {\n-            ast::VariantData::Struct(fields, _id, _) |\n-            ast::VariantData::Tuple(fields, _id) =>\n+            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) =>\n                 fields.flat_map_in_place(|field| self.configure(field)),\n-            ast::VariantData::Unit(_id) => {}\n+            ast::VariantData::Unit(_) => {}\n         }\n     }\n "}, {"sha": "614967bdeb447002eef0cd67bd5604608ae19872", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -1062,6 +1062,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         respan(span,\n                ast::Variant_ {\n                    ident,\n+                   id: ast::DUMMY_NODE_ID,\n                    attrs: Vec::new(),\n                    data: vdata,\n                    disr_expr: None,"}, {"sha": "784d0049ac51f7069a1aecf83e0b1861a6f0b807", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -450,9 +450,10 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n }\n \n pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n-    let Spanned { node: Variant_ { ident, attrs, data, disr_expr }, span } = variant;\n+    let Spanned { node: Variant_ { ident, attrs, id, data, disr_expr }, span } = variant;\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n+    vis.visit_id(id);\n     vis.visit_variant_data(data);\n     visit_opt(disr_expr, |disr_expr| vis.visit_anon_const(disr_expr));\n     vis.visit_span(span);\n@@ -765,11 +766,11 @@ pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis:\n \n pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut T) {\n     match vdata {\n-        VariantData::Struct(fields, id, _) |\n+        VariantData::Struct(fields, ..) => visit_vec(fields, |field| vis.visit_struct_field(field)),\n         VariantData::Tuple(fields, id) => {\n             visit_vec(fields, |field| vis.visit_struct_field(field));\n             vis.visit_id(id);\n-        }\n+        },\n         VariantData::Unit(id) => vis.visit_id(id),\n     }\n }"}, {"sha": "d7a2170342d7f42fbc435a453b26992c7eb673e1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -6844,15 +6844,15 @@ impl<'a> Parser<'a> {\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n                 let (fields, recovered) = self.parse_record_struct_body()?;\n-                VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+                VariantData::Struct(fields, recovered)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if self.eat(&token::Semi) {\n             VariantData::Unit(ast::DUMMY_NODE_ID)\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n             let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+            VariantData::Struct(fields, recovered)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n             let body = VariantData::Tuple(self.parse_tuple_struct_body()?, ast::DUMMY_NODE_ID);\n@@ -6881,10 +6881,10 @@ impl<'a> Parser<'a> {\n         let vdata = if self.token.is_keyword(keywords::Where) {\n             generics.where_clause = self.parse_where_clause()?;\n             let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+            VariantData::Struct(fields, recovered)\n         } else if self.token == token::OpenDelim(token::Brace) {\n             let (fields, recovered) = self.parse_record_struct_body()?;\n-            VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered)\n+            VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = self.this_token_descr();\n             let mut err = self.fatal(&format!(\n@@ -7708,7 +7708,7 @@ impl<'a> Parser<'a> {\n                 // Parse a struct variant.\n                 all_nullary = false;\n                 let (fields, recovered) = self.parse_record_struct_body()?;\n-                struct_def = VariantData::Struct(fields, ast::DUMMY_NODE_ID, recovered);\n+                struct_def = VariantData::Struct(fields, recovered);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n                 all_nullary = false;\n                 struct_def = VariantData::Tuple(\n@@ -7730,6 +7730,7 @@ impl<'a> Parser<'a> {\n \n             let vr = ast::Variant_ {\n                 ident,\n+                id: ast::DUMMY_NODE_ID,\n                 attrs: variant_attrs,\n                 data: struct_def,\n                 disr_expr,"}, {"sha": "946fdc0c46942125a27b8687139eb1e8a83e1882", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -3266,6 +3266,7 @@ mod tests {\n             let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n                 ident,\n                 attrs: Vec::new(),\n+                id: ast::DUMMY_NODE_ID,\n                 // making this up as I go.... ?\n                 data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n                 disr_expr: None,"}, {"sha": "29c97ed6d3845b65d0a81dd2d4883af50af2c808", "filename": "src/test/mir-opt/unusual-item-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funusual-item-types.rs?ref=5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "patch": "@@ -72,7 +72,7 @@ fn main() {\n // }\n // END rustc.ptr-real_drop_in_place.std__vec__Vec_i32_.AddMovesForPackedDrops.before.mir\n \n-// START rustc.Test-X.mir_map.0.mir\n+// START rustc.Test-X-{{variant constructor}}.mir_map.0.mir\n // fn Test::X(_1: usize) -> Test {\n //     let mut _0: Test;\n //\n@@ -81,4 +81,4 @@ fn main() {\n //         return;\n //     }\n // }\n-// END rustc.Test-X.mir_map.0.mir\n+// END rustc.Test-X-{{variant constructor}}.mir_map.0.mir"}]}