{"sha": "1491e5cc148391f7679542b8e9b4e6d2430a7b69", "node_id": "C_kwDOAAsO6NoAKDE0OTFlNWNjMTQ4MzkxZjc2Nzk1NDJiOGU5YjRlNmQyNDMwYTdiNjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T01:15:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T01:15:20Z"}, "message": "Auto merge of #95990 - Dylan-DPC:rollup-r9bh9t7, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95316 (Rustdoc: Discriminate required and provided associated constants and types)\n - #95405 (Move name resolution logic to a dedicated file)\n - #95914 (Implement tuples using recursion)\n - #95918 (Delay a bug when we see SelfCtor in ref pattern)\n - #95970 (Fix suggestions in case of `T:` bounds)\n - #95973 (prevent opaque types from appearing in impl headers)\n - #95986 (Autolabel library PRs with T-libs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ca5d43841892d5f0d3ba8bf0e128baba2c965930", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca5d43841892d5f0d3ba8bf0e128baba2c965930"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1491e5cc148391f7679542b8e9b4e6d2430a7b69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1491e5cc148391f7679542b8e9b4e6d2430a7b69", "html_url": "https://github.com/rust-lang/rust/commit/1491e5cc148391f7679542b8e9b4e6d2430a7b69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1491e5cc148391f7679542b8e9b4e6d2430a7b69/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6cef572d6d75a3b7dea5f496d3bd981986e94ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6cef572d6d75a3b7dea5f496d3bd981986e94ca", "html_url": "https://github.com/rust-lang/rust/commit/f6cef572d6d75a3b7dea5f496d3bd981986e94ca"}, {"sha": "bdbc398e826c22d385aa3514d41b544d2f72b0fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbc398e826c22d385aa3514d41b544d2f72b0fd", "html_url": "https://github.com/rust-lang/rust/commit/bdbc398e826c22d385aa3514d41b544d2f72b0fd"}], "stats": {"total": 5742, "additions": 3184, "deletions": 2558}, "files": [{"sha": "76971d7ad3a05404d45b5875277f83d51637aba3", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -17,7 +17,7 @@ use rustc_error_messages::MultiSpan;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::Spanned;\n+use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{def_id::LocalDefId, BytePos, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -523,6 +523,40 @@ impl<'hir> GenericParam<'hir> {\n             })\n             .map(|sp| sp.shrink_to_hi())\n     }\n+\n+    /// Returns the span of `:` after a generic parameter.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```text\n+    /// fn a<T:>()\n+    ///       ^\n+    ///       |      here\n+    ///       here   |\n+    ///              v\n+    /// fn b<T       :>()\n+    ///\n+    /// fn c<T\n+    ///\n+    /// :>()\n+    /// ^\n+    /// |\n+    /// here\n+    /// ```\n+    pub fn colon_span_for_suggestions(&self, source_map: &SourceMap) -> Option<Span> {\n+        let sp = source_map\n+            .span_extend_while(self.span.shrink_to_hi(), |c| c.is_whitespace() || c == ':')\n+            .ok()?;\n+\n+        let snippet = source_map.span_to_snippet(sp).ok()?;\n+        let offset = snippet.find(':')?;\n+\n+        let colon_sp = sp\n+            .with_lo(BytePos(sp.lo().0 + offset as u32))\n+            .with_hi(BytePos(sp.lo().0 + (offset + ':'.len_utf8()) as u32));\n+\n+        Some(colon_sp)\n+    }\n }\n \n #[derive(Default)]"}, {"sha": "3b044b19259d0b2000dad7c3abc5387c3b1cb3e9", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -336,10 +336,14 @@ pub fn suggest_constraining_type_params<'a>(\n         }\n \n         let constraint = constraints.iter().map(|&(c, _)| c).collect::<Vec<_>>().join(\" + \");\n-        let mut suggest_restrict = |span| {\n+        let mut suggest_restrict = |span, bound_list_non_empty| {\n             suggestions.push((\n                 span,\n-                format!(\" + {}\", constraint),\n+                if bound_list_non_empty {\n+                    format!(\" + {}\", constraint)\n+                } else {\n+                    format!(\" {}\", constraint)\n+                },\n                 SuggestChangingConstraintsMessage::RestrictBoundFurther,\n             ))\n         };\n@@ -360,7 +364,10 @@ pub fn suggest_constraining_type_params<'a>(\n             //             |\n             //             replace with: `impl Foo + Bar`\n \n-            suggest_restrict(param.span.shrink_to_hi());\n+            // `impl Trait` must have at least one trait in the list\n+            let bound_list_non_empty = true;\n+\n+            suggest_restrict(param.span.shrink_to_hi(), bound_list_non_empty);\n             continue;\n         }\n \n@@ -383,15 +390,25 @@ pub fn suggest_constraining_type_params<'a>(\n                 //          --\n                 //          |\n                 //          replace with: `T: Bar +`\n-                suggest_restrict(span);\n+\n+                // `bounds_span_for_suggestions` returns `None` if the list is empty\n+                let bound_list_non_empty = true;\n+\n+                suggest_restrict(span, bound_list_non_empty);\n             } else {\n+                let (colon, span) = match param.colon_span_for_suggestions(tcx.sess.source_map()) {\n+                    // If there is already a colon after generic, do not suggest adding it again\n+                    Some(sp) => (\"\", sp.shrink_to_hi()),\n+                    None => (\":\", param.span.shrink_to_hi()),\n+                };\n+\n                 // If user hasn't provided any bounds, suggest adding a new one:\n                 //\n                 //   fn foo<T>(t: T) { ... }\n                 //          - help: consider restricting this type parameter with `T: Foo`\n                 suggestions.push((\n-                    param.span.shrink_to_hi(),\n-                    format!(\": {}\", constraint),\n+                    span,\n+                    format!(\"{colon} {constraint}\"),\n                     SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n                 ));\n             }\n@@ -459,17 +476,21 @@ pub fn suggest_constraining_type_params<'a>(\n                 ));\n             } else {\n                 let mut param_spans = Vec::new();\n+                let mut non_empty = false;\n \n                 for predicate in generics.where_clause.predicates {\n                     if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n                         span,\n                         bounded_ty,\n+                        bounds,\n                         ..\n                     }) = predicate\n                     {\n                         if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n                             if let Some(segment) = path.segments.first() {\n                                 if segment.ident.to_string() == param_name {\n+                                    non_empty = !bounds.is_empty();\n+\n                                     param_spans.push(span);\n                                 }\n                             }\n@@ -478,7 +499,7 @@ pub fn suggest_constraining_type_params<'a>(\n                 }\n \n                 match param_spans[..] {\n-                    [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                    [&param_span] => suggest_restrict(param_span.shrink_to_hi(), non_empty),\n                     _ => {\n                         suggestions.push((\n                             generics.where_clause.tail_span_for_suggestion(),"}, {"sha": "54e8c03156d558448b64e58721c885d99457b7bd", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -297,6 +297,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     Some(TypeNS),\n                     parent_scope,\n                     if finalize { Finalize::SimplePath(id, path.span) } else { Finalize::No },\n+                    None,\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n@@ -1124,12 +1125,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n-                let result = self.r.resolve_ident_in_module(\n+                let result = self.r.maybe_resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n                     &self.parent_scope,\n-                    None,\n                 );\n                 if let Ok(binding) = result {\n                     let import = macro_use_import(self, ident.span);"}, {"sha": "d979311171be66c657192e895dc88a8e3a442dd4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 660, "deletions": 18, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,19 +1,24 @@\n use std::ptr;\n \n-use rustc_ast::{self as ast, Path};\n+use rustc_ast::ptr::P;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::{self as ast, Crate, ItemKind, ModKind, NodeId, Path, CRATE_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n-};\n+use rustc_errors::struct_span_err;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty::DefIdTree;\n+use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n+use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::Session;\n+use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n@@ -22,11 +27,13 @@ use rustc_span::{BytePos, Span};\n use tracing::debug;\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n+use crate::late::Rib;\n use crate::path_names_to_string;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n-use crate::{Finalize, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n-use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n+use crate::{HasGenericParams, MacroRulesScope, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{LexicalScopeBinding, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n+use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet};\n+use crate::{Segment, UseError};\n \n type Res = def::Res<ast::NodeId>;\n \n@@ -82,6 +89,390 @@ fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n }\n \n impl<'a> Resolver<'a> {\n+    crate fn report_errors(&mut self, krate: &Crate) {\n+        self.report_with_use_injections(krate);\n+\n+        for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n+            let msg = \"macro-expanded `macro_export` macros from the current crate \\\n+                       cannot be referred to by absolute paths\";\n+            self.lint_buffer.buffer_lint_with_diagnostic(\n+                MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n+                CRATE_NODE_ID,\n+                span_use,\n+                msg,\n+                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def),\n+            );\n+        }\n+\n+        for ambiguity_error in &self.ambiguity_errors {\n+            self.report_ambiguity_error(ambiguity_error);\n+        }\n+\n+        let mut reported_spans = FxHashSet::default();\n+        for error in &self.privacy_errors {\n+            if reported_spans.insert(error.dedup_span) {\n+                self.report_privacy_error(error);\n+            }\n+        }\n+    }\n+\n+    fn report_with_use_injections(&mut self, krate: &Crate) {\n+        for UseError { mut err, candidates, def_id, instead, suggestion } in\n+            self.use_injections.drain(..)\n+        {\n+            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n+                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n+            } else {\n+                (None, false)\n+            };\n+            if !candidates.is_empty() {\n+                show_candidates(\n+                    &self.definitions,\n+                    self.session,\n+                    &mut err,\n+                    span,\n+                    &candidates,\n+                    instead,\n+                    found_use,\n+                );\n+            } else if let Some((span, msg, sugg, appl)) = suggestion {\n+                err.span_suggestion(span, msg, sugg, appl);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn report_conflict<'b>(\n+        &mut self,\n+        parent: Module<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        new_binding: &NameBinding<'b>,\n+        old_binding: &NameBinding<'b>,\n+    ) {\n+        // Error on the second of two conflicting names\n+        if old_binding.span.lo() > new_binding.span.lo() {\n+            return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n+        }\n+\n+        let container = match parent.kind {\n+            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n+            ModuleKind::Block(..) => \"block\",\n+        };\n+\n+        let old_noun = match old_binding.is_import() {\n+            true => \"import\",\n+            false => \"definition\",\n+        };\n+\n+        let new_participle = match new_binding.is_import() {\n+            true => \"imported\",\n+            false => \"defined\",\n+        };\n+\n+        let (name, span) =\n+            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n+\n+        if let Some(s) = self.name_already_seen.get(&name) {\n+            if s == &span {\n+                return;\n+            }\n+        }\n+\n+        let old_kind = match (ns, old_binding.module()) {\n+            (ValueNS, _) => \"value\",\n+            (MacroNS, _) => \"macro\",\n+            (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n+            (TypeNS, Some(module)) if module.is_normal() => \"module\",\n+            (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n+            (TypeNS, _) => \"type\",\n+        };\n+\n+        let msg = format!(\"the name `{}` is defined multiple times\", name);\n+\n+        let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n+            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n+                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+            },\n+            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+            },\n+        };\n+\n+        err.note(&format!(\n+            \"`{}` must be defined only once in the {} namespace of this {}\",\n+            name,\n+            ns.descr(),\n+            container\n+        ));\n+\n+        err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n+        err.span_label(\n+            self.session.source_map().guess_head_span(old_binding.span),\n+            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n+        );\n+\n+        // See https://github.com/rust-lang/rust/issues/32354\n+        use NameBindingKind::Import;\n+        let import = match (&new_binding.kind, &old_binding.kind) {\n+            // If there are two imports where one or both have attributes then prefer removing the\n+            // import without attributes.\n+            (Import { import: new, .. }, Import { import: old, .. })\n+                if {\n+                    !new_binding.span.is_dummy()\n+                        && !old_binding.span.is_dummy()\n+                        && (new.has_attributes || old.has_attributes)\n+                } =>\n+            {\n+                if old.has_attributes {\n+                    Some((new, new_binding.span, true))\n+                } else {\n+                    Some((old, old_binding.span, true))\n+                }\n+            }\n+            // Otherwise prioritize the new binding.\n+            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+                Some((import, new_binding.span, other.is_import()))\n+            }\n+            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+                Some((import, old_binding.span, other.is_import()))\n+            }\n+            _ => None,\n+        };\n+\n+        // Check if the target of the use for both bindings is the same.\n+        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n+        let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n+        let from_item =\n+            self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n+        // Only suggest removing an import if both bindings are to the same def, if both spans\n+        // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n+        // been introduced by an item.\n+        let should_remove_import = duplicate\n+            && !has_dummy_span\n+            && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n+\n+        match import {\n+            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n+                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n+            }\n+            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n+                // Simple case - remove the entire import. Due to the above match arm, this can\n+                // only be a single use so just remove it entirely.\n+                err.tool_only_span_suggestion(\n+                    import.use_span_with_attributes,\n+                    \"remove unnecessary import\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            Some((import, span, _)) => {\n+                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n+            }\n+            _ => {}\n+        }\n+\n+        err.emit();\n+        self.name_already_seen.insert(name, span);\n+    }\n+\n+    /// This function adds a suggestion to change the binding name of a new import that conflicts\n+    /// with an existing import.\n+    ///\n+    /// ```text,ignore (diagnostic)\n+    /// help: you can use `as` to change the binding name of the import\n+    ///    |\n+    /// LL | use foo::bar as other_bar;\n+    ///    |     ^^^^^^^^^^^^^^^^^^^^^\n+    /// ```\n+    fn add_suggestion_for_rename_of_use(\n+        &self,\n+        err: &mut Diagnostic,\n+        name: Symbol,\n+        import: &Import<'_>,\n+        binding_span: Span,\n+    ) {\n+        let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n+            format!(\"Other{}\", name)\n+        } else {\n+            format!(\"other_{}\", name)\n+        };\n+\n+        let mut suggestion = None;\n+        match import.kind {\n+            ImportKind::Single { type_ns_only: true, .. } => {\n+                suggestion = Some(format!(\"self as {}\", suggested_name))\n+            }\n+            ImportKind::Single { source, .. } => {\n+                if let Some(pos) =\n+                    source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n+                {\n+                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n+                        if pos <= snippet.len() {\n+                            suggestion = Some(format!(\n+                                \"{} as {}{}\",\n+                                &snippet[..pos],\n+                                suggested_name,\n+                                if snippet.ends_with(';') { \";\" } else { \"\" }\n+                            ))\n+                        }\n+                    }\n+                }\n+            }\n+            ImportKind::ExternCrate { source, target } => {\n+                suggestion = Some(format!(\n+                    \"extern crate {} as {};\",\n+                    source.unwrap_or(target.name),\n+                    suggested_name,\n+                ))\n+            }\n+            _ => unreachable!(),\n+        }\n+\n+        let rename_msg = \"you can use `as` to change the binding name of the import\";\n+        if let Some(suggestion) = suggestion {\n+            err.span_suggestion(\n+                binding_span,\n+                rename_msg,\n+                suggestion,\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(binding_span, rename_msg);\n+        }\n+    }\n+\n+    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n+    /// nested. In the following example, this function will be invoked to remove the `a` binding\n+    /// in the second use statement:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// use issue_52891::a;\n+    /// use issue_52891::{d, a, e};\n+    /// ```\n+    ///\n+    /// The following suggestion will be added:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// use issue_52891::{d, a, e};\n+    ///                      ^-- help: remove unnecessary import\n+    /// ```\n+    ///\n+    /// If the nested use contains only one import then the suggestion will remove the entire\n+    /// line.\n+    ///\n+    /// It is expected that the provided import is nested - this isn't checked by the\n+    /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n+    /// as characters expected by span manipulations won't be present.\n+    fn add_suggestion_for_duplicate_nested_use(\n+        &self,\n+        err: &mut Diagnostic,\n+        import: &Import<'_>,\n+        binding_span: Span,\n+    ) {\n+        assert!(import.is_nested());\n+        let message = \"remove unnecessary import\";\n+\n+        // Two examples will be used to illustrate the span manipulations we're doing:\n+        //\n+        // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n+        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n+        // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n+        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n+\n+        let (found_closing_brace, span) =\n+            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n+\n+        // If there was a closing brace then identify the span to remove any trailing commas from\n+        // previous imports.\n+        if found_closing_brace {\n+            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+                err.tool_only_span_suggestion(\n+                    span,\n+                    message,\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                // Remove the entire line if we cannot extend the span back, this indicates an\n+                // `issue_52891::{self}` case.\n+                err.span_suggestion(\n+                    import.use_span_with_attributes,\n+                    message,\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            return;\n+        }\n+\n+        err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n+    }\n+\n+    crate fn lint_if_path_starts_with_module(\n+        &mut self,\n+        finalize: Finalize,\n+        path: &[Segment],\n+        second_binding: Option<&NameBinding<'_>>,\n+    ) {\n+        let (diag_id, diag_span) = match finalize {\n+            Finalize::No => return,\n+            Finalize::SimplePath(id, path_span) => (id, path_span),\n+            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n+            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n+        };\n+\n+        let first_name = match path.get(0) {\n+            // In the 2018 edition this lint is a hard error, so nothing to do\n+            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n+            _ => return,\n+        };\n+\n+        // We're only interested in `use` paths which should start with\n+        // `{{root}}` currently.\n+        if first_name != kw::PathRoot {\n+            return;\n+        }\n+\n+        match path.get(1) {\n+            // If this import looks like `crate::...` it's already good\n+            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n+            // Otherwise go below to see if it's an extern crate\n+            Some(_) => {}\n+            // If the path has length one (and it's `PathRoot` most likely)\n+            // then we don't know whether we're gonna be importing a crate or an\n+            // item in our crate. Defer this lint to elsewhere\n+            None => return,\n+        }\n+\n+        // If the first element of our path was actually resolved to an\n+        // `ExternCrate` (also used for `crate::...`) then no need to issue a\n+        // warning, this looks all good!\n+        if let Some(binding) = second_binding {\n+            if let NameBindingKind::Import { import, .. } = binding.kind {\n+                // Careful: we still want to rewrite paths from renamed extern crates.\n+                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n+        self.lint_buffer.buffer_lint_with_diagnostic(\n+            ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n+            diag_id,\n+            diag_span,\n+            \"absolute paths must start with `self`, `super`, \\\n+             `crate`, or an external crate name in the 2018 edition\",\n+            diag,\n+        );\n+    }\n+\n     crate fn add_module_candidates(\n         &mut self,\n         module: Module<'a>,\n@@ -1076,6 +1467,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 None,\n                 false,\n+                false,\n+                None,\n             ) {\n                 let desc = match binding.res() {\n                     Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n@@ -1223,7 +1616,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n+    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n         let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n         let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n             // We have to print the span-less alternative first, otherwise formatting looks bad.\n@@ -1289,7 +1682,7 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+    fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n         let PrivacyError { ident, binding, .. } = *privacy_error;\n \n         let res = binding.res();\n@@ -1375,6 +1768,188 @@ impl<'a> Resolver<'a> {\n             sugg => sugg,\n         }\n     }\n+\n+    crate fn report_path_resolution_error(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+        module: Option<ModuleOrUniformRoot<'a>>,\n+        i: usize,\n+        ident: Ident,\n+    ) -> (String, Option<Suggestion>) {\n+        let is_last = i == path.len() - 1;\n+        let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+        let module_res = match module {\n+            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n+            _ => None,\n+        };\n+        if module_res == self.graph_root.res() {\n+            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n+            let mut candidates = self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n+            candidates\n+                .sort_by_cached_key(|c| (c.path.segments.len(), pprust::path_to_string(&c.path)));\n+            if let Some(candidate) = candidates.get(0) {\n+                (\n+                    String::from(\"unresolved import\"),\n+                    Some((\n+                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n+                        String::from(\"a similar path exists\"),\n+                        Applicability::MaybeIncorrect,\n+                    )),\n+                )\n+            } else if self.session.edition() == Edition::Edition2015 {\n+                (format!(\"maybe a missing crate `{}`?\", ident), None)\n+            } else {\n+                (format!(\"could not find `{}` in the crate root\", ident), None)\n+            }\n+        } else if i > 0 {\n+            let parent = path[i - 1].ident.name;\n+            let parent = match parent {\n+                // ::foo is mounted at the crate root for 2015, and is the extern\n+                // prelude for 2018+\n+                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                    \"the list of imported crates\".to_owned()\n+                }\n+                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n+                _ => format!(\"`{}`\", parent),\n+            };\n+\n+            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n+            if ns == TypeNS || ns == ValueNS {\n+                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n+                let binding = if let Some(module) = module {\n+                    self.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns_to_try,\n+                        parent_scope,\n+                        None,\n+                        false,\n+                        unusable_binding,\n+                    ).ok()\n+                } else if let Some(ribs) = ribs\n+                    && let Some(TypeNS | ValueNS) = opt_ns\n+                {\n+                    match self.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns_to_try,\n+                        parent_scope,\n+                        Finalize::No,\n+                        &ribs[ns_to_try],\n+                        unusable_binding,\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Some(binding),\n+                        _ => None,\n+                    }\n+                } else {\n+                    let scopes = ScopeSet::All(ns_to_try, opt_ns.is_none());\n+                    self.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        None,\n+                        false,\n+                        false,\n+                        unusable_binding,\n+                    ).ok()\n+                };\n+                if let Some(binding) = binding {\n+                    let mut found = |what| {\n+                        msg = format!(\n+                            \"expected {}, found {} `{}` in {}\",\n+                            ns.descr(),\n+                            what,\n+                            ident,\n+                            parent\n+                        )\n+                    };\n+                    if binding.module().is_some() {\n+                        found(\"module\")\n+                    } else {\n+                        match binding.res() {\n+                            Res::Def(kind, id) => found(kind.descr(id)),\n+                            _ => found(ns_to_try.descr()),\n+                        }\n+                    }\n+                };\n+            }\n+            (msg, None)\n+        } else if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n+            // Check whether the name refers to an item in the value namespace.\n+            let binding = if let Some(ribs) = ribs {\n+                self.resolve_ident_in_lexical_scope(\n+                    ident,\n+                    ValueNS,\n+                    parent_scope,\n+                    Finalize::No,\n+                    &ribs[ValueNS],\n+                    unusable_binding,\n+                )\n+            } else {\n+                None\n+            };\n+            let match_span = match binding {\n+                // Name matches a local variable. For example:\n+                // ```\n+                // fn f() {\n+                //     let Foo: &str = \"\";\n+                //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                //                               // variable `Foo`.\n+                // }\n+                // ```\n+                Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                    Some(*self.pat_span_map.get(&id).unwrap())\n+                }\n+                // Name matches item from a local name binding\n+                // created by `use` declaration. For example:\n+                // ```\n+                // pub Foo: &str = \"\";\n+                //\n+                // mod submod {\n+                //     use super::Foo;\n+                //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                //                               // binding `Foo`.\n+                // }\n+                // ```\n+                Some(LexicalScopeBinding::Item(name_binding)) => Some(name_binding.span),\n+                _ => None,\n+            };\n+            let suggestion = if let Some(span) = match_span {\n+                Some((\n+                    vec![(span, String::from(\"\"))],\n+                    format!(\"`{}` is defined here, but is not a type\", ident),\n+                    Applicability::MaybeIncorrect,\n+                ))\n+            } else {\n+                None\n+            };\n+\n+            (format!(\"use of undeclared type `{}`\", ident), suggestion)\n+        } else {\n+            let suggestion = if ident.name == sym::alloc {\n+                Some((\n+                    vec![],\n+                    String::from(\"add `extern crate alloc` to use the `alloc` crate\"),\n+                    Applicability::MaybeIncorrect,\n+                ))\n+            } else {\n+                self.find_similarly_named_module_or_crate(ident.name, &parent_scope.module).map(\n+                    |sugg| {\n+                        (\n+                            vec![(ident.span, sugg.to_string())],\n+                            String::from(\"there is a crate or module with a similar name\"),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                    },\n+                )\n+            };\n+            (format!(\"use of undeclared crate or module `{}`\", ident), suggestion)\n+        }\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {\n@@ -1422,7 +1997,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1441,7 +2016,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1472,7 +2047,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1506,7 +2081,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n+            let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result\n@@ -1673,7 +2248,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n /// use foo::{a, b, c};\n ///              ^^^\n /// ```\n-pub(crate) fn find_span_of_binding_until_next_binding(\n+fn find_span_of_binding_until_next_binding(\n     sess: &Session,\n     binding_span: Span,\n     use_span: Span,\n@@ -1724,7 +2299,7 @@ pub(crate) fn find_span_of_binding_until_next_binding(\n /// use foo::{a, b, c};\n ///           --- binding span\n /// ```\n-pub(crate) fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n+fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n     let source_map = sess.source_map();\n \n     // `prev_source` will contain all of the source that came before the span.\n@@ -1812,7 +2387,7 @@ fn find_span_immediately_after_crate_name(\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n-crate fn show_candidates(\n+fn show_candidates(\n     definitions: &rustc_hir::definitions::Definitions,\n     session: &Session,\n     err: &mut Diagnostic,\n@@ -1947,3 +2522,70 @@ crate fn show_candidates(\n         }\n     }\n }\n+\n+#[derive(Debug)]\n+struct UsePlacementFinder {\n+    target_module: NodeId,\n+    first_legal_span: Option<Span>,\n+    first_use_span: Option<Span>,\n+}\n+\n+impl UsePlacementFinder {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+        let mut finder =\n+            UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n+        finder.visit_crate(krate);\n+        if let Some(use_span) = finder.first_use_span {\n+            (Some(use_span), true)\n+        } else {\n+            (finder.first_legal_span, false)\n+        }\n+    }\n+}\n+\n+impl<'tcx> visit::Visitor<'tcx> for UsePlacementFinder {\n+    fn visit_crate(&mut self, c: &Crate) {\n+        if self.target_module == CRATE_NODE_ID {\n+            let inject = c.spans.inject_use_span;\n+            if is_span_suitable_for_use_injection(inject) {\n+                self.first_legal_span = Some(inject);\n+            }\n+            self.first_use_span = search_for_any_use_in_items(&c.items);\n+            return;\n+        } else {\n+            visit::walk_crate(self, c);\n+        }\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx ast::Item) {\n+        if self.target_module == item.id {\n+            if let ItemKind::Mod(_, ModKind::Loaded(items, _inline, mod_spans)) = &item.kind {\n+                let inject = mod_spans.inject_use_span;\n+                if is_span_suitable_for_use_injection(inject) {\n+                    self.first_legal_span = Some(inject);\n+                }\n+                self.first_use_span = search_for_any_use_in_items(items);\n+                return;\n+            }\n+        } else {\n+            visit::walk_item(self, item);\n+        }\n+    }\n+}\n+\n+fn search_for_any_use_in_items(items: &[P<ast::Item>]) -> Option<Span> {\n+    for item in items {\n+        if let ItemKind::Use(..) = item.kind {\n+            if is_span_suitable_for_use_injection(item.span) {\n+                return Some(item.span.shrink_to_lo());\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+fn is_span_suitable_for_use_injection(s: Span) -> bool {\n+    // don't suggest placing a use before the prelude\n+    // import or other generated ones\n+    !s.from_expansion()\n+}"}, {"sha": "25ab3f7dacf905aa7bf48680616d1ee19cd55620", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "added", "additions": 1582, "deletions": 0, "changes": 1582, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,1582 @@\n+use rustc_ast::{self as ast, NodeId};\n+use rustc_feature::is_builtin_attr_name;\n+use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n+use rustc_hir::PrimTy;\n+use rustc_middle::bug;\n+use rustc_middle::ty;\n+use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::edition::Edition;\n+use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n+use rustc_span::symbol::{kw, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::ptr;\n+\n+use crate::late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind};\n+use crate::macros::{sub_namespace_match, MacroRulesScope};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n+use crate::{ImportKind, LexicalScopeBinding, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PrivacyError, Res};\n+use crate::{ResolutionError, Resolver, Scope, ScopeSet, Segment, ToNameBinding, Weak};\n+\n+use Determinacy::*;\n+use Namespace::*;\n+use RibKind::*;\n+\n+impl<'a> Resolver<'a> {\n+    /// A generic scope visitor.\n+    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n+    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n+    crate fn visit_scopes<T>(\n+        &mut self,\n+        scope_set: ScopeSet<'a>,\n+        parent_scope: &ParentScope<'a>,\n+        ctxt: SyntaxContext,\n+        mut visitor: impl FnMut(\n+            &mut Self,\n+            Scope<'a>,\n+            /*use_prelude*/ bool,\n+            SyntaxContext,\n+        ) -> Option<T>,\n+    ) -> Option<T> {\n+        // General principles:\n+        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n+        //    built into the language or standard library. This way we can add new names into the\n+        //    language or standard library without breaking user code.\n+        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n+        // Places to search (in order of decreasing priority):\n+        // (Type NS)\n+        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n+        // 4. Tool modules (closed, controlled right now, but not in the future).\n+        // 5. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude (closed, controlled).\n+        // (Value NS)\n+        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n+        //    (open set, not controlled).\n+        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled).\n+        // 3. Standard library prelude (de-facto closed, controlled).\n+        // (Macro NS)\n+        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n+        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n+        //    priority than prelude macros, but create ambiguities with macros in modules.\n+        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n+        //    (open, not controlled). Have higher priority than prelude macros, but create\n+        //    ambiguities with `macro_rules`.\n+        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n+        // 4a. User-defined prelude from macro-use\n+        //    (open, the open part is from macro expansions, not controlled).\n+        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n+        // 4c. Standard library prelude (de-facto closed, controlled).\n+        // 6. Language prelude: builtin attributes (closed, controlled).\n+\n+        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n+        let (ns, macro_kind, is_absolute_path) = match scope_set {\n+            ScopeSet::All(ns, _) => (ns, None, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+        let module = match scope_set {\n+            // Start with the specified module.\n+            ScopeSet::Late(_, module, _) => module,\n+            // Jump out of trait or enum modules, they do not act as scopes.\n+            _ => parent_scope.module.nearest_item_scope(),\n+        };\n+        let mut scope = match ns {\n+            _ if is_absolute_path => Scope::CrateRoot,\n+            TypeNS | ValueNS => Scope::Module(module, None),\n+            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n+        };\n+        let mut ctxt = ctxt.normalize_to_macros_2_0();\n+        let mut use_prelude = !module.no_implicit_prelude;\n+\n+        loop {\n+            let visit = match scope {\n+                // Derive helpers are not in scope when resolving derives in the same container.\n+                Scope::DeriveHelpers(expn_id) => {\n+                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n+                }\n+                Scope::DeriveHelpersCompat => true,\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n+                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n+                    // As another consequence of this optimization visitors never observe invocation\n+                    // scopes for macros that were already expanded.\n+                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n+                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n+                            macro_rules_scope.set(next_scope.get());\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    true\n+                }\n+                Scope::CrateRoot => true,\n+                Scope::Module(..) => true,\n+                Scope::RegisteredAttrs => use_prelude,\n+                Scope::MacroUsePrelude => use_prelude || rust_2015,\n+                Scope::BuiltinAttrs => true,\n+                Scope::ExternPrelude => use_prelude || is_absolute_path,\n+                Scope::ToolPrelude => use_prelude,\n+                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n+                Scope::BuiltinTypes => true,\n+            };\n+\n+            if visit {\n+                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n+                    return break_result;\n+                }\n+            }\n+\n+            scope = match scope {\n+                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n+                Scope::DeriveHelpers(expn_id) => {\n+                    // Derive helpers are not visible to code generated by bang or derive macros.\n+                    let expn_data = expn_id.expn_data();\n+                    match expn_data.kind {\n+                        ExpnKind::Root\n+                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n+                            Scope::DeriveHelpersCompat\n+                        }\n+                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n+                    }\n+                }\n+                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n+                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n+                    MacroRulesScope::Binding(binding) => {\n+                        Scope::MacroRules(binding.parent_macro_rules_scope)\n+                    }\n+                    MacroRulesScope::Invocation(invoc_id) => {\n+                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n+                    }\n+                    MacroRulesScope::Empty => Scope::Module(module, None),\n+                },\n+                Scope::CrateRoot => match ns {\n+                    TypeNS => {\n+                        ctxt.adjust(ExpnId::root());\n+                        Scope::ExternPrelude\n+                    }\n+                    ValueNS | MacroNS => break,\n+                },\n+                Scope::Module(module, prev_lint_id) => {\n+                    use_prelude = !module.no_implicit_prelude;\n+                    let derive_fallback_lint_id = match scope_set {\n+                        ScopeSet::Late(.., lint_id) => lint_id,\n+                        _ => None,\n+                    };\n+                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n+                        Some((parent_module, lint_id)) => {\n+                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n+                        }\n+                        None => {\n+                            ctxt.adjust(ExpnId::root());\n+                            match ns {\n+                                TypeNS => Scope::ExternPrelude,\n+                                ValueNS => Scope::StdLibPrelude,\n+                                MacroNS => Scope::RegisteredAttrs,\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n+                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n+                Scope::BuiltinAttrs => break, // nowhere else to search\n+                Scope::ExternPrelude if is_absolute_path => break,\n+                Scope::ExternPrelude => Scope::ToolPrelude,\n+                Scope::ToolPrelude => Scope::StdLibPrelude,\n+                Scope::StdLibPrelude => match ns {\n+                    TypeNS => Scope::BuiltinTypes,\n+                    ValueNS => break, // nowhere else to search\n+                    MacroNS => Scope::BuiltinAttrs,\n+                },\n+                Scope::BuiltinTypes => break, // nowhere else to search\n+            };\n+        }\n+\n+        None\n+    }\n+\n+    fn hygienic_lexical_parent(\n+        &mut self,\n+        module: Module<'a>,\n+        ctxt: &mut SyntaxContext,\n+        derive_fallback_lint_id: Option<NodeId>,\n+    ) -> Option<(Module<'a>, Option<NodeId>)> {\n+        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n+            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n+        }\n+\n+        if let ModuleKind::Block(..) = module.kind {\n+            return Some((module.parent.unwrap().nearest_item_scope(), None));\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if derive_fallback_lint_id.is_some() {\n+            if let Some(parent) = module.parent {\n+                // Inner module is inside the macro, parent module is outside of the macro.\n+                if module.expansion != parent.expansion\n+                    && module.expansion.is_descendant_of(parent.expansion)\n+                {\n+                    // The macro is a proc macro derive\n+                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n+                        let ext = self.get_macro_by_def_id(def_id);\n+                        if ext.builtin_name.is_none()\n+                            && ext.macro_kind() == MacroKind::Derive\n+                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n+                        {\n+                            return Some((parent, derive_fallback_lint_id));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n+    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n+    /// `ident` in the first scope that defines it (or None if no scopes define it).\n+    ///\n+    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n+    /// the items are defined in the block. For example,\n+    /// ```rust\n+    /// fn f() {\n+    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n+    ///    let g = || {};\n+    ///    fn g() {}\n+    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n+    /// }\n+    /// ```\n+    ///\n+    /// Invariant: This must only be called during main resolution, not during\n+    /// import resolution.\n+    #[tracing::instrument(level = \"debug\", skip(self, ribs))]\n+    crate fn resolve_ident_in_lexical_scope(\n+        &mut self,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: &[Rib<'a>],\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        let orig_ident = ident;\n+        if ident.name == kw::Empty {\n+            return Some(LexicalScopeBinding::Res(Res::Err));\n+        }\n+        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n+            // FIXME(jseyfried) improve `Self` hygiene\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n+            (empty_span, empty_span)\n+        } else if ns == TypeNS {\n+            let normalized_span = ident.span.normalize_to_macros_2_0();\n+            (normalized_span, normalized_span)\n+        } else {\n+            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n+        };\n+        ident.span = general_span;\n+        let normalized_ident = Ident { span: normalized_span, ..ident };\n+\n+        // Walk backwards up the ribs in scope.\n+        let finalize = finalize_full.path_span();\n+        let mut module = self.graph_root;\n+        for i in (0..ribs.len()).rev() {\n+            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n+            // Use the rib kind to determine whether we are resolving parameters\n+            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n+            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n+            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n+            {\n+                // The ident resolves to a type parameter or local variable.\n+                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n+                    i,\n+                    rib_ident,\n+                    *res,\n+                    finalize,\n+                    *original_rib_ident_def,\n+                    ribs,\n+                )));\n+            }\n+\n+            module = match ribs[i].kind {\n+                ModuleRibKind(module) => module,\n+                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    ident.span.remove_mark();\n+                    continue;\n+                }\n+                _ => continue,\n+            };\n+\n+            match module.kind {\n+                ModuleKind::Block(..) => {} // We can see through blocks\n+                _ => break,\n+            }\n+\n+            let item = self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                parent_scope,\n+                finalize,\n+                false,\n+                unusable_binding,\n+            );\n+            if let Ok(binding) = item {\n+                // The ident resolves to an item.\n+                return Some(LexicalScopeBinding::Item(binding));\n+            }\n+        }\n+        self.early_resolve_ident_in_lexical_scope(\n+            orig_ident,\n+            ScopeSet::Late(ns, module, finalize_full.node_id()),\n+            parent_scope,\n+            finalize,\n+            finalize.is_some(),\n+            false,\n+            unusable_binding,\n+        )\n+        .ok()\n+        .map(LexicalScopeBinding::Item)\n+    }\n+\n+    /// Resolve an identifier in lexical scope.\n+    /// This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n+    /// expansion and import resolution (perhaps they can be merged in the future).\n+    /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n+    /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n+    #[tracing::instrument(level = \"debug\", skip(self, scope_set))]\n+    crate fn early_resolve_ident_in_lexical_scope(\n+        &mut self,\n+        orig_ident: Ident,\n+        scope_set: ScopeSet<'a>,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        force: bool,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        bitflags::bitflags! {\n+            struct Flags: u8 {\n+                const MACRO_RULES          = 1 << 0;\n+                const MODULE               = 1 << 1;\n+                const MISC_SUGGEST_CRATE   = 1 << 2;\n+                const MISC_SUGGEST_SELF    = 1 << 3;\n+                const MISC_FROM_PRELUDE    = 1 << 4;\n+            }\n+        }\n+\n+        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n+\n+        // Make sure `self`, `super` etc produce an error when passed to here.\n+        if orig_ident.is_path_segment_keyword() {\n+            return Err(Determinacy::Determined);\n+        }\n+\n+        let (ns, macro_kind, is_import) = match scope_set {\n+            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+\n+        // This is *the* result, resolution from the scope closest to the resolved identifier.\n+        // However, sometimes this result is \"weak\" because it comes from a glob import or\n+        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n+        // mod m { ... } // solution in outer scope\n+        // {\n+        //     use prefix::*; // imports another `m` - innermost solution\n+        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n+        //     m::mac!();\n+        // }\n+        // So we have to save the innermost solution and continue searching in outer scopes\n+        // to detect potential ambiguities.\n+        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n+        let mut determinacy = Determinacy::Determined;\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let break_result = self.visit_scopes(\n+            scope_set,\n+            parent_scope,\n+            orig_ident.span.ctxt(),\n+            |this, scope, use_prelude, ctxt| {\n+                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n+                let ok = |res, span, arenas| {\n+                    Ok((\n+                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n+                            .to_name_binding(arenas),\n+                        Flags::empty(),\n+                    ))\n+                };\n+                let result = match scope {\n+                    Scope::DeriveHelpers(expn_id) => {\n+                        if let Some(attr) = this\n+                            .helper_attrs\n+                            .get(&expn_id)\n+                            .and_then(|attrs| attrs.iter().rfind(|i| ident == **i))\n+                        {\n+                            let binding = (\n+                                Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                ty::Visibility::Public,\n+                                attr.span,\n+                                expn_id,\n+                            )\n+                                .to_name_binding(this.arenas);\n+                            Ok((binding, Flags::empty()))\n+                        } else {\n+                            Err(Determinacy::Determined)\n+                        }\n+                    }\n+                    Scope::DeriveHelpersCompat => {\n+                        let mut result = Err(Determinacy::Determined);\n+                        for derive in parent_scope.derives {\n+                            let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n+                            match this.resolve_macro_path(\n+                                derive,\n+                                Some(MacroKind::Derive),\n+                                parent_scope,\n+                                true,\n+                                force,\n+                            ) {\n+                                Ok((Some(ext), _)) => {\n+                                    if ext.helper_attrs.contains(&ident.name) {\n+                                        result = ok(\n+                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n+                                            derive.span,\n+                                            this.arenas,\n+                                        );\n+                                        break;\n+                                    }\n+                                }\n+                                Ok(_) | Err(Determinacy::Determined) => {}\n+                                Err(Determinacy::Undetermined) => {\n+                                    result = Err(Determinacy::Undetermined)\n+                                }\n+                            }\n+                        }\n+                        result\n+                    }\n+                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n+                        MacroRulesScope::Binding(macro_rules_binding)\n+                            if ident == macro_rules_binding.ident =>\n+                        {\n+                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n+                        }\n+                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n+                        _ => Err(Determinacy::Determined),\n+                    },\n+                    Scope::CrateRoot => {\n+                        let root_ident = Ident::new(kw::PathRoot, ident.span);\n+                        let root_module = this.resolve_crate_root(root_ident);\n+                        let binding = this.resolve_ident_in_module_ext(\n+                            ModuleOrUniformRoot::Module(root_module),\n+                            ident,\n+                            ns,\n+                            parent_scope,\n+                            finalize,\n+                            last_import_segment,\n+                            unusable_binding,\n+                        );\n+                        match binding {\n+                            Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n+                            Err((Determinacy::Undetermined, Weak::No)) => {\n+                                return Some(Err(Determinacy::determined(force)));\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n+                                Err(Determinacy::Undetermined)\n+                            }\n+                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                        }\n+                    }\n+                    Scope::Module(module, derive_fallback_lint_id) => {\n+                        let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n+                        let binding = this.resolve_ident_in_module_unadjusted_ext(\n+                            ModuleOrUniformRoot::Module(module),\n+                            ident,\n+                            ns,\n+                            adjusted_parent_scope,\n+                            !matches!(scope_set, ScopeSet::Late(..)),\n+                            finalize,\n+                            last_import_segment,\n+                            unusable_binding,\n+                        );\n+                        match binding {\n+                            Ok(binding) => {\n+                                if let Some(lint_id) = derive_fallback_lint_id {\n+                                    this.lint_buffer.buffer_lint_with_diagnostic(\n+                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                                        lint_id,\n+                                        orig_ident.span,\n+                                        &format!(\n+                                            \"cannot find {} `{}` in this scope\",\n+                                            ns.descr(),\n+                                            ident\n+                                        ),\n+                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n+                                            orig_ident.span,\n+                                        ),\n+                                    );\n+                                }\n+                                let misc_flags = if ptr::eq(module, this.graph_root) {\n+                                    Flags::MISC_SUGGEST_CRATE\n+                                } else if module.is_normal() {\n+                                    Flags::MISC_SUGGEST_SELF\n+                                } else {\n+                                    Flags::empty()\n+                                };\n+                                Ok((binding, Flags::MODULE | misc_flags))\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::No)) => {\n+                                return Some(Err(Determinacy::determined(force)));\n+                            }\n+                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n+                                Err(Determinacy::Undetermined)\n+                            }\n+                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n+                        }\n+                    }\n+                    Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n+                        Some(ident) => ok(\n+                            Res::NonMacroAttr(NonMacroAttrKind::Registered),\n+                            ident.span,\n+                            this.arenas,\n+                        ),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                    Scope::MacroUsePrelude => {\n+                        match this.macro_use_prelude.get(&ident.name).cloned() {\n+                            Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n+                    Scope::BuiltinAttrs => {\n+                        if is_builtin_attr_name(ident.name) {\n+                            ok(\n+                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n+                                DUMMY_SP,\n+                                this.arenas,\n+                            )\n+                        } else {\n+                            Err(Determinacy::Determined)\n+                        }\n+                    }\n+                    Scope::ExternPrelude => {\n+                        match this.extern_prelude_get(ident, finalize.is_some()) {\n+                            Some(binding) => Ok((binding, Flags::empty())),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n+                    Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n+                        Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                    Scope::StdLibPrelude => {\n+                        let mut result = Err(Determinacy::Determined);\n+                        if let Some(prelude) = this.prelude {\n+                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n+                                ModuleOrUniformRoot::Module(prelude),\n+                                ident,\n+                                ns,\n+                                parent_scope,\n+                                None,\n+                                last_import_segment,\n+                                unusable_binding,\n+                            ) {\n+                                if use_prelude || this.is_builtin_macro(binding.res()) {\n+                                    result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n+                                }\n+                            }\n+                        }\n+                        result\n+                    }\n+                    Scope::BuiltinTypes => match PrimTy::from_name(ident.name) {\n+                        Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n+                        None => Err(Determinacy::Determined),\n+                    },\n+                };\n+\n+                match result {\n+                    Ok((binding, flags))\n+                        if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n+                    {\n+                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n+                            return Some(Ok(binding));\n+                        }\n+\n+                        if let Some((innermost_binding, innermost_flags)) = innermost_result {\n+                            // Found another solution, if the first one was \"weak\", report an error.\n+                            let (res, innermost_res) = (binding.res(), innermost_binding.res());\n+                            if res != innermost_res {\n+                                let is_builtin = |res| {\n+                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n+                                };\n+                                let derive_helper =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                                let derive_helper_compat =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n+\n+                                let ambiguity_error_kind = if is_import {\n+                                    Some(AmbiguityKind::Import)\n+                                } else if is_builtin(innermost_res) || is_builtin(res) {\n+                                    Some(AmbiguityKind::BuiltinAttr)\n+                                } else if innermost_res == derive_helper_compat\n+                                    || res == derive_helper_compat && innermost_res != derive_helper\n+                                {\n+                                    Some(AmbiguityKind::DeriveHelper)\n+                                } else if innermost_flags.contains(Flags::MACRO_RULES)\n+                                    && flags.contains(Flags::MODULE)\n+                                    && !this.disambiguate_macro_rules_vs_modularized(\n+                                        innermost_binding,\n+                                        binding,\n+                                    )\n+                                    || flags.contains(Flags::MACRO_RULES)\n+                                        && innermost_flags.contains(Flags::MODULE)\n+                                        && !this.disambiguate_macro_rules_vs_modularized(\n+                                            binding,\n+                                            innermost_binding,\n+                                        )\n+                                {\n+                                    Some(AmbiguityKind::MacroRulesVsModularized)\n+                                } else if innermost_binding.is_glob_import() {\n+                                    Some(AmbiguityKind::GlobVsOuter)\n+                                } else if innermost_binding\n+                                    .may_appear_after(parent_scope.expansion, binding)\n+                                {\n+                                    Some(AmbiguityKind::MoreExpandedVsOuter)\n+                                } else {\n+                                    None\n+                                };\n+                                if let Some(kind) = ambiguity_error_kind {\n+                                    let misc = |f: Flags| {\n+                                        if f.contains(Flags::MISC_SUGGEST_CRATE) {\n+                                            AmbiguityErrorMisc::SuggestCrate\n+                                        } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n+                                            AmbiguityErrorMisc::SuggestSelf\n+                                        } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n+                                            AmbiguityErrorMisc::FromPrelude\n+                                        } else {\n+                                            AmbiguityErrorMisc::None\n+                                        }\n+                                    };\n+                                    this.ambiguity_errors.push(AmbiguityError {\n+                                        kind,\n+                                        ident: orig_ident,\n+                                        b1: innermost_binding,\n+                                        b2: binding,\n+                                        misc1: misc(innermost_flags),\n+                                        misc2: misc(flags),\n+                                    });\n+                                    return Some(Ok(innermost_binding));\n+                                }\n+                            }\n+                        } else {\n+                            // Found the first solution.\n+                            innermost_result = Some((binding, flags));\n+                        }\n+                    }\n+                    Ok(..) | Err(Determinacy::Determined) => {}\n+                    Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n+                }\n+\n+                None\n+            },\n+        );\n+\n+        if let Some(break_result) = break_result {\n+            return break_result;\n+        }\n+\n+        // The first found solution was the only one, return it.\n+        if let Some((binding, _)) = innermost_result {\n+            return Ok(binding);\n+        }\n+\n+        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn maybe_resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, None, false, None)\n+            .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        // We are resolving a last import segment during import validation.\n+        last_import_segment: bool,\n+        // This binding should be ignored during in-module resolution, so that we don't get\n+        // \"self-confirming\" import resolutions during import validation.\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_ext(\n+            module,\n+            ident,\n+            ns,\n+            parent_scope,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+        .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_ident_in_module_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n+        let tmp_parent_scope;\n+        let mut adjusted_parent_scope = parent_scope;\n+        match module {\n+            ModuleOrUniformRoot::Module(m) => {\n+                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n+            }\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n+                // No adjustments\n+            }\n+        }\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module,\n+            ident,\n+            ns,\n+            adjusted_parent_scope,\n+            false,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_ident_in_module_unadjusted(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+        self.resolve_ident_in_module_unadjusted_ext(\n+            module,\n+            ident,\n+            ns,\n+            parent_scope,\n+            false,\n+            finalize,\n+            last_import_segment,\n+            unusable_binding,\n+        )\n+        .map_err(|(determinacy, _)| determinacy)\n+    }\n+\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n+    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_ident_in_module_unadjusted_ext(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'a>,\n+        restricted_shadowing: bool,\n+        finalize: Option<Span>,\n+        last_import_segment: bool,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n+        let module = match module {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident,\n+                    ScopeSet::AbsolutePath(ns),\n+                    parent_scope,\n+                    finalize,\n+                    finalize.is_some(),\n+                    last_import_segment,\n+                    unusable_binding,\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+            ModuleOrUniformRoot::ExternPrelude => {\n+                assert!(!restricted_shadowing);\n+                return if ns != TypeNS {\n+                    Err((Determined, Weak::No))\n+                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n+                    Ok(binding)\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n+                    // Macro-expanded `extern crate` items can add names to extern prelude.\n+                    Err((Undetermined, Weak::No))\n+                } else {\n+                    Err((Determined, Weak::No))\n+                };\n+            }\n+            ModuleOrUniformRoot::CurrentScope => {\n+                assert!(!restricted_shadowing);\n+                if ns == TypeNS {\n+                    if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n+                        let module = self.resolve_crate_root(ident);\n+                        let binding =\n+                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n+                                .to_name_binding(self.arenas);\n+                        return Ok(binding);\n+                    } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n+                        // FIXME: Implement these with renaming requirements so that e.g.\n+                        // `use super;` doesn't work, but `use super as name;` does.\n+                        // Fall through here to get an error from `early_resolve_...`.\n+                    }\n+                }\n+\n+                let scopes = ScopeSet::All(ns, true);\n+                let binding = self.early_resolve_ident_in_lexical_scope(\n+                    ident,\n+                    scopes,\n+                    parent_scope,\n+                    finalize,\n+                    finalize.is_some(),\n+                    last_import_segment,\n+                    unusable_binding,\n+                );\n+                return binding.map_err(|determinacy| (determinacy, Weak::No));\n+            }\n+        };\n+\n+        let key = self.new_key(ident, ns);\n+        let resolution =\n+            self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n+\n+        if let Some(path_span) = finalize {\n+            // If the primary binding is unusable, search further and return the shadowed glob\n+            // binding if it exists. What we really want here is having two separate scopes in\n+            // a module - one for non-globs and one for globs, but until that's done use this\n+            // hack to avoid inconsistent resolution ICEs during import validation.\n+            let binding = [resolution.binding, resolution.shadowed_glob]\n+                .into_iter()\n+                .filter_map(|binding| match (binding, unusable_binding) {\n+                    (Some(binding), Some(unusable_binding))\n+                        if ptr::eq(binding, unusable_binding) =>\n+                    {\n+                        None\n+                    }\n+                    _ => binding,\n+                })\n+                .next();\n+            let Some(binding) = binding else {\n+                return Err((Determined, Weak::No));\n+            };\n+\n+            if !self.is_accessible_from(binding.vis, parent_scope.module) {\n+                if last_import_segment {\n+                    return Err((Determined, Weak::No));\n+                } else {\n+                    self.privacy_errors.push(PrivacyError {\n+                        ident,\n+                        binding,\n+                        dedup_span: path_span,\n+                    });\n+                }\n+            }\n+\n+            // Forbid expanded shadowing to avoid time travel.\n+            if let Some(shadowed_glob) = resolution.shadowed_glob\n+                && restricted_shadowing\n+                && binding.expansion != LocalExpnId::ROOT\n+                && binding.res() != shadowed_glob.res()\n+            {\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    kind: AmbiguityKind::GlobVsExpanded,\n+                    ident,\n+                    b1: binding,\n+                    b2: shadowed_glob,\n+                    misc1: AmbiguityErrorMisc::None,\n+                    misc2: AmbiguityErrorMisc::None,\n+                });\n+            }\n+\n+            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n+                if let NameBindingKind::Res(_, true) = binding.kind {\n+                    self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n+                }\n+            }\n+\n+            self.record_use(ident, binding, restricted_shadowing);\n+            return Ok(binding);\n+        }\n+\n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            if let Some(unusable_binding) = unusable_binding {\n+                if ptr::eq(binding, unusable_binding) {\n+                    return Err((Determined, Weak::No));\n+                }\n+            }\n+            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n+            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n+        };\n+\n+        // Items and single imports are not shadowable, if we have one, then it's determined.\n+        if let Some(binding) = resolution.binding {\n+            if !binding.is_glob_import() {\n+                return check_usable(self, binding);\n+            }\n+        }\n+\n+        // --- From now on we either have a glob resolution or no resolution. ---\n+\n+        // Check if one of single imports can still define the name,\n+        // if it can then our result is not determined and can be invalidated.\n+        for single_import in &resolution.single_imports {\n+            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n+                continue;\n+            }\n+            let Some(module) = single_import.imported_module.get() else {\n+                return Err((Undetermined, Weak::No));\n+            };\n+            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n+                unreachable!();\n+            };\n+            match self.resolve_ident_in_module(\n+                module,\n+                ident,\n+                ns,\n+                &single_import.parent_scope,\n+                None,\n+                last_import_segment,\n+                unusable_binding,\n+            ) {\n+                Err(Determined) => continue,\n+                Ok(binding)\n+                    if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n+                {\n+                    continue;\n+                }\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n+            }\n+        }\n+\n+        // So we have a resolution that's from a glob import. This resolution is determined\n+        // if it cannot be shadowed by some new item/import expanded from a macro.\n+        // This happens either if there are no unexpanded macros, or expanded names cannot\n+        // shadow globs (that happens in macro namespace or with restricted shadowing).\n+        //\n+        // Additionally, any macro in any module can plant names in the root module if it creates\n+        // `macro_export` macros, so the root module effectively has unresolved invocations if any\n+        // module has unresolved invocations.\n+        // However, it causes resolution/expansion to stuck too often (#53144), so, to make\n+        // progress, we have to ignore those potential unresolved invocations from other modules\n+        // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n+        // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n+        if let Some(binding) = resolution.binding {\n+            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n+                return check_usable(self, binding);\n+            } else {\n+                return Err((Undetermined, Weak::No));\n+            }\n+        }\n+\n+        // --- From now on we have no resolution. ---\n+\n+        // Now we are in situation when new item/import can appear only from a glob or a macro\n+        // expansion. With restricted shadowing names from globs and macro expansions cannot\n+        // shadow names from outer scopes, so we can freely fallback from module search to search\n+        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n+        // scopes we return `Undetermined` with `Weak::Yes`.\n+\n+        // Check if one of unexpanded macros can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        if unexpanded_macros {\n+            return Err((Undetermined, Weak::Yes));\n+        }\n+\n+        // Check if one of glob imports can still define the name,\n+        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n+        for glob_import in module.globs.borrow().iter() {\n+            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n+                continue;\n+            }\n+            let module = match glob_import.imported_module.get() {\n+                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                Some(_) => continue,\n+                None => return Err((Undetermined, Weak::Yes)),\n+            };\n+            let tmp_parent_scope;\n+            let (mut adjusted_parent_scope, mut ident) =\n+                (parent_scope, ident.normalize_to_macros_2_0());\n+            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n+                Some(Some(def)) => {\n+                    tmp_parent_scope =\n+                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n+                    adjusted_parent_scope = &tmp_parent_scope;\n+                }\n+                Some(None) => {}\n+                None => continue,\n+            };\n+            let result = self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                adjusted_parent_scope,\n+                None,\n+                last_import_segment,\n+                unusable_binding,\n+            );\n+\n+            match result {\n+                Err(Determined) => continue,\n+                Ok(binding)\n+                    if !self.is_accessible_from(binding.vis, glob_import.parent_scope.module) =>\n+                {\n+                    continue;\n+                }\n+                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n+            }\n+        }\n+\n+        // No resolution and no one else can define the name - determinate error.\n+        Err((Determined, Weak::No))\n+    }\n+\n+    /// Validate a local resolution (from ribs).\n+    #[tracing::instrument(level = \"debug\", skip(self, all_ribs))]\n+    fn validate_res_from_ribs(\n+        &mut self,\n+        rib_index: usize,\n+        rib_ident: Ident,\n+        mut res: Res,\n+        finalize: Option<Span>,\n+        original_rib_ident_def: Ident,\n+        all_ribs: &[Rib<'a>],\n+    ) -> Res {\n+        const CG_BUG_STR: &str = \"min_const_generics resolve check didn't stop compilation\";\n+        debug!(\"validate_res_from_ribs({:?})\", res);\n+        let ribs = &all_ribs[rib_index + 1..];\n+\n+        // An invalid forward use of a generic parameter from a previous default.\n+        if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n+            if let Some(span) = finalize {\n+                let res_error = if rib_ident.name == kw::SelfUpper {\n+                    ResolutionError::SelfInGenericParamDefault\n+                } else {\n+                    ResolutionError::ForwardDeclaredGenericParam\n+                };\n+                self.report_error(span, res_error);\n+            }\n+            assert_eq!(res, Res::Err);\n+            return Res::Err;\n+        }\n+\n+        match res {\n+            Res::Local(_) => {\n+                use ResolutionError::*;\n+                let mut res_err = None;\n+\n+                for rib in ribs {\n+                    match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n+                            if let Some(span) = finalize {\n+                                // We don't immediately trigger a resolve error, because\n+                                // we want certain other resolution errors (namely those\n+                                // emitted for `ConstantItemRibKind` below) to take\n+                                // precedence.\n+                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n+                            }\n+                        }\n+                        ConstantItemRibKind(_, item) => {\n+                            // Still doesn't deal with upvars\n+                            if let Some(span) = finalize {\n+                                let (span, resolution_error) =\n+                                    if let Some((ident, constant_item_kind)) = item {\n+                                        let kind_str = match constant_item_kind {\n+                                            ConstantItemKind::Const => \"const\",\n+                                            ConstantItemKind::Static => \"static\",\n+                                        };\n+                                        (\n+                                            span,\n+                                            AttemptToUseNonConstantValueInConstant(\n+                                                ident, \"let\", kind_str,\n+                                            ),\n+                                        )\n+                                    } else {\n+                                        (\n+                                            rib_ident.span,\n+                                            AttemptToUseNonConstantValueInConstant(\n+                                                original_rib_ident_def,\n+                                                \"const\",\n+                                                \"let\",\n+                                            ),\n+                                        )\n+                                    };\n+                                self.report_error(span, resolution_error);\n+                            }\n+                            return Res::Err;\n+                        }\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n+                            }\n+                            return Res::Err;\n+                        }\n+                    }\n+                }\n+                if let Some((span, res_err)) = res_err {\n+                    self.report_error(span, res_err);\n+                    return Res::Err;\n+                }\n+            }\n+            Res::Def(DefKind::TyParam, _) | Res::SelfTy { .. } => {\n+                for rib in ribs {\n+                    let has_generic_params: HasGenericParams = match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | AssocItemRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => {\n+                            // Nothing to do. Continue.\n+                            continue;\n+                        }\n+\n+                        ConstantItemRibKind(trivial, _) => {\n+                            let features = self.session.features_untracked();\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !(trivial || features.generic_const_exprs) {\n+                                // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n+                                // we can't easily tell if it's generic at this stage, so we instead remember\n+                                // this and then enforce the self type to be concrete later on.\n+                                if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n+                                    res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n+                                } else {\n+                                    if let Some(span) = finalize {\n+                                        self.report_error(\n+                                            span,\n+                                            ResolutionError::ParamInNonTrivialAnonConst {\n+                                                name: rib_ident.name,\n+                                                is_type: true,\n+                                            },\n+                                        );\n+                                        self.session.delay_span_bug(span, CG_BUG_STR);\n+                                    }\n+\n+                                    return Res::Err;\n+                                }\n+                            }\n+\n+                            continue;\n+                        }\n+\n+                        // This was an attempt to use a type parameter outside its scope.\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(\n+                                    span,\n+                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                );\n+                            }\n+                            return Res::Err;\n+                        }\n+                    };\n+\n+                    if let Some(span) = finalize {\n+                        self.report_error(\n+                            span,\n+                            ResolutionError::GenericParamsFromOuterFunction(\n+                                res,\n+                                has_generic_params,\n+                            ),\n+                        );\n+                    }\n+                    return Res::Err;\n+                }\n+            }\n+            Res::Def(DefKind::ConstParam, _) => {\n+                let mut ribs = ribs.iter().peekable();\n+                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n+                    // When declaring const parameters inside function signatures, the first rib\n+                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n+                    // (spuriously) conflicting with the const param.\n+                    ribs.next();\n+                }\n+\n+                for rib in ribs {\n+                    let has_generic_params = match rib.kind {\n+                        NormalRibKind\n+                        | ClosureOrAsyncRibKind\n+                        | AssocItemRibKind\n+                        | ModuleRibKind(..)\n+                        | MacroDefinition(..)\n+                        | ForwardGenericParamBanRibKind => continue,\n+\n+                        ConstantItemRibKind(trivial, _) => {\n+                            let features = self.session.features_untracked();\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !(trivial || features.generic_const_exprs) {\n+                                if let Some(span) = finalize {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst {\n+                                            name: rib_ident.name,\n+                                            is_type: false,\n+                                        },\n+                                    );\n+                                    self.session.delay_span_bug(span, CG_BUG_STR);\n+                                }\n+\n+                                return Res::Err;\n+                            }\n+\n+                            continue;\n+                        }\n+\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        ConstParamTyRibKind => {\n+                            if let Some(span) = finalize {\n+                                self.report_error(\n+                                    span,\n+                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                );\n+                            }\n+                            return Res::Err;\n+                        }\n+                    };\n+\n+                    // This was an attempt to use a const parameter outside its scope.\n+                    if let Some(span) = finalize {\n+                        self.report_error(\n+                            span,\n+                            ResolutionError::GenericParamsFromOuterFunction(\n+                                res,\n+                                has_generic_params,\n+                            ),\n+                        );\n+                    }\n+                    return Res::Err;\n+                }\n+            }\n+            _ => {}\n+        }\n+        res\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn maybe_resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, Finalize::No, None, None)\n+    }\n+\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    crate fn resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize: Finalize,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> PathResult<'a> {\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, unusable_binding)\n+    }\n+\n+    crate fn resolve_path_with_ribs(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        finalize_full: Finalize,\n+        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n+    ) -> PathResult<'a> {\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n+\n+        let finalize = finalize_full.path_span();\n+        let mut module = None;\n+        let mut allow_super = true;\n+        let mut second_binding = None;\n+\n+        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n+            let record_segment_res = |this: &mut Self, res| {\n+                if finalize.is_some() {\n+                    if let Some(id) = id {\n+                        if !this.partial_res_map.contains_key(&id) {\n+                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                            this.record_partial_res(id, PartialRes::new(res));\n+                        }\n+                    }\n+                }\n+            };\n+\n+            let is_last = i == path.len() - 1;\n+            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+            let name = ident.name;\n+\n+            allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);\n+\n+            if ns == TypeNS {\n+                if allow_super && name == kw::Super {\n+                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n+                    let self_module = match i {\n+                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n+                        _ => match module {\n+                            Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n+                            _ => None,\n+                        },\n+                    };\n+                    if let Some(self_module) = self_module {\n+                        if let Some(parent) = self_module.parent {\n+                            module = Some(ModuleOrUniformRoot::Module(\n+                                self.resolve_self(&mut ctxt, parent),\n+                            ));\n+                            continue;\n+                        }\n+                    }\n+                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                        (\"there are too many leading `super` keywords\".to_string(), None)\n+                    });\n+                }\n+                if i == 0 {\n+                    if name == kw::SelfLower {\n+                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n+                        module = Some(ModuleOrUniformRoot::Module(\n+                            self.resolve_self(&mut ctxt, parent_scope.module),\n+                        ));\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot && ident.span.rust_2018() {\n+                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n+                        // `::a::b` from 2015 macro on 2018 global edition\n+                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n+                        continue;\n+                    }\n+                    if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {\n+                        // `::a::b`, `crate::a::b` or `$crate::a::b`\n+                        module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Report special messages for path segment keywords in wrong positions.\n+            if ident.is_path_segment_keyword() && i != 0 {\n+                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n+                    let name_str = if name == kw::PathRoot {\n+                        \"crate root\".to_string()\n+                    } else {\n+                        format!(\"`{}`\", name)\n+                    };\n+                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n+                        format!(\"global paths cannot start with {}\", name_str)\n+                    } else {\n+                        format!(\"{} in paths can only be used in start position\", name_str)\n+                    };\n+                    (label, None)\n+                });\n+            }\n+\n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                Res(Res),\n+            }\n+            let find_binding_in_ns = |this: &mut Self, ns| {\n+                let binding = if let Some(module) = module {\n+                    this.resolve_ident_in_module(\n+                        module,\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        finalize,\n+                        false,\n+                        unusable_binding,\n+                    )\n+                } else if let Some(ribs) = ribs\n+                    && let Some(TypeNS | ValueNS) = opt_ns\n+                {\n+                    match this.resolve_ident_in_lexical_scope(\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        finalize_full,\n+                        &ribs[ns],\n+                        unusable_binding,\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res)) => return FindBindingResult::Res(res),\n+                        _ => Err(Determinacy::determined(finalize.is_some())),\n+                    }\n+                } else {\n+                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n+                    this.early_resolve_ident_in_lexical_scope(\n+                        ident,\n+                        scopes,\n+                        parent_scope,\n+                        finalize,\n+                        finalize.is_some(),\n+                        false,\n+                        unusable_binding,\n+                    )\n+                };\n+                FindBindingResult::Binding(binding)\n+            };\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::Res(res) => {\n+                    record_segment_res(self, res);\n+                    return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                        res,\n+                        path.len() - 1,\n+                    ));\n+                }\n+                FindBindingResult::Binding(binding) => binding,\n+            };\n+            match binding {\n+                Ok(binding) => {\n+                    if i == 1 {\n+                        second_binding = Some(binding);\n+                    }\n+                    let res = binding.res();\n+                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n+                    if let Some(next_module) = binding.module() {\n+                        module = Some(ModuleOrUniformRoot::Module(next_module));\n+                        record_segment_res(self, res);\n+                    } else if res == Res::ToolMod && i + 1 != path.len() {\n+                        if binding.is_import() {\n+                            self.session\n+                                .struct_span_err(\n+                                    ident.span,\n+                                    \"cannot use a tool module through an import\",\n+                                )\n+                                .span_note(binding.span, \"the tool module imported here\")\n+                                .emit();\n+                        }\n+                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                        return PathResult::NonModule(PartialRes::new(res));\n+                    } else if res == Res::Err {\n+                        return PathResult::NonModule(PartialRes::new(Res::Err));\n+                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n+                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                            res,\n+                            path.len() - i - 1,\n+                        ));\n+                    } else {\n+                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                            let label = format!(\n+                                \"`{ident}` is {} {}, not a module\",\n+                                res.article(),\n+                                res.descr()\n+                            );\n+                            (label, None)\n+                        });\n+                    }\n+                }\n+                Err(Undetermined) => return PathResult::Indeterminate,\n+                Err(Determined) => {\n+                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n+                        if opt_ns.is_some() && !module.is_normal() {\n+                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n+                                module.res().unwrap(),\n+                                path.len() - i,\n+                            ));\n+                        }\n+                    }\n+\n+                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                        self.report_path_resolution_error(\n+                            path,\n+                            opt_ns,\n+                            parent_scope,\n+                            ribs,\n+                            unusable_binding,\n+                            module,\n+                            i,\n+                            ident,\n+                        )\n+                    });\n+                }\n+            }\n+        }\n+\n+        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+\n+        PathResult::Module(match module {\n+            Some(module) => module,\n+            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n+            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n+        })\n+    }\n+}"}, {"sha": "aab0c1f97717c79b6fe3117c2543838181858dbf", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 26, "deletions": 301, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -2,12 +2,11 @@\n \n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n-use crate::Namespace::{self, MacroNS, TypeNS};\n+use crate::Namespace::{MacroNS, TypeNS};\n use crate::{module_to_string, names_to_string};\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n-use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n-use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n+use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n+use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n+use crate::{NameBinding, NameBindingKind, PathResult};\n \n use rustc_ast::NodeId;\n use rustc_data_structures::fx::FxHashSet;\n@@ -125,15 +124,15 @@ impl<'a> Import<'a> {\n     }\n }\n \n-#[derive(Clone, Default, Debug)]\n /// Records information about the resolution of a name in a namespace of a module.\n-pub struct NameResolution<'a> {\n+#[derive(Clone, Default, Debug)]\n+crate struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n+    pub single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n-    shadowed_glob: Option<&'a NameBinding<'a>>,\n+    pub shadowed_glob: Option<&'a NameBinding<'a>>,\n }\n \n impl<'a> NameResolution<'a> {\n@@ -169,278 +168,6 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolve_ident_in_module_unadjusted(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_unadjusted_ext(\n-            module,\n-            ident,\n-            ns,\n-            parent_scope,\n-            false,\n-            finalize,\n-        )\n-        .map_err(|(determinacy, _)| determinacy)\n-    }\n-\n-    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n-    crate fn resolve_ident_in_module_unadjusted_ext(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        restricted_shadowing: bool,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let module = match module {\n-            ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::CrateRootAndExternPrelude => {\n-                assert!(!restricted_shadowing);\n-                let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    ScopeSet::AbsolutePath(ns),\n-                    parent_scope,\n-                    finalize,\n-                    finalize.is_some(),\n-                );\n-                return binding.map_err(|determinacy| (determinacy, Weak::No));\n-            }\n-            ModuleOrUniformRoot::ExternPrelude => {\n-                assert!(!restricted_shadowing);\n-                return if ns != TypeNS {\n-                    Err((Determined, Weak::No))\n-                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n-                    Ok(binding)\n-                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n-                    // Macro-expanded `extern crate` items can add names to extern prelude.\n-                    Err((Undetermined, Weak::No))\n-                } else {\n-                    Err((Determined, Weak::No))\n-                };\n-            }\n-            ModuleOrUniformRoot::CurrentScope => {\n-                assert!(!restricted_shadowing);\n-                if ns == TypeNS {\n-                    if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n-                        let module = self.resolve_crate_root(ident);\n-                        let binding =\n-                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n-                                .to_name_binding(self.arenas);\n-                        return Ok(binding);\n-                    } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n-                        // FIXME: Implement these with renaming requirements so that e.g.\n-                        // `use super;` doesn't work, but `use super as name;` does.\n-                        // Fall through here to get an error from `early_resolve_...`.\n-                    }\n-                }\n-\n-                let scopes = ScopeSet::All(ns, true);\n-                let binding = self.early_resolve_ident_in_lexical_scope(\n-                    ident,\n-                    scopes,\n-                    parent_scope,\n-                    finalize,\n-                    finalize.is_some(),\n-                );\n-                return binding.map_err(|determinacy| (determinacy, Weak::No));\n-            }\n-        };\n-\n-        let key = self.new_key(ident, ns);\n-        let resolution =\n-            self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n-\n-        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n-            if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n-                if let NameBindingKind::Res(_, true) = binding.kind {\n-                    self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n-                }\n-            }\n-        }\n-\n-        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            if let Some(unusable_binding) = this.unusable_binding {\n-                if ptr::eq(binding, unusable_binding) {\n-                    return Err((Determined, Weak::No));\n-                }\n-            }\n-            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n-            if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n-        };\n-\n-        if let Some(path_span) = finalize {\n-            return resolution\n-                .binding\n-                .and_then(|binding| {\n-                    // If the primary binding is unusable, search further and return the shadowed glob\n-                    // binding if it exists. What we really want here is having two separate scopes in\n-                    // a module - one for non-globs and one for globs, but until that's done use this\n-                    // hack to avoid inconsistent resolution ICEs during import validation.\n-                    if let Some(unusable_binding) = self.unusable_binding {\n-                        if ptr::eq(binding, unusable_binding) {\n-                            return resolution.shadowed_glob;\n-                        }\n-                    }\n-                    Some(binding)\n-                })\n-                .ok_or((Determined, Weak::No))\n-                .and_then(|binding| {\n-                    if self.last_import_segment && check_usable(self, binding).is_err() {\n-                        Err((Determined, Weak::No))\n-                    } else {\n-                        self.record_use(ident, binding, restricted_shadowing);\n-\n-                        if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                            // Forbid expanded shadowing to avoid time travel.\n-                            if restricted_shadowing\n-                                && binding.expansion != LocalExpnId::ROOT\n-                                && binding.res() != shadowed_glob.res()\n-                            {\n-                                self.ambiguity_errors.push(AmbiguityError {\n-                                    kind: AmbiguityKind::GlobVsExpanded,\n-                                    ident,\n-                                    b1: binding,\n-                                    b2: shadowed_glob,\n-                                    misc1: AmbiguityErrorMisc::None,\n-                                    misc2: AmbiguityErrorMisc::None,\n-                                });\n-                            }\n-                        }\n-\n-                        if !self.is_accessible_from(binding.vis, parent_scope.module) {\n-                            self.privacy_errors.push(PrivacyError {\n-                                ident,\n-                                binding,\n-                                dedup_span: path_span,\n-                            });\n-                        }\n-\n-                        Ok(binding)\n-                    }\n-                });\n-        }\n-\n-        // Items and single imports are not shadowable, if we have one, then it's determined.\n-        if let Some(binding) = resolution.binding {\n-            if !binding.is_glob_import() {\n-                return check_usable(self, binding);\n-            }\n-        }\n-\n-        // --- From now on we either have a glob resolution or no resolution. ---\n-\n-        // Check if one of single imports can still define the name,\n-        // if it can then our result is not determined and can be invalidated.\n-        for single_import in &resolution.single_imports {\n-            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n-                continue;\n-            }\n-            let Some(module) = single_import.imported_module.get() else {\n-                return Err((Undetermined, Weak::No));\n-            };\n-            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n-                unreachable!();\n-            };\n-            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n-            {\n-                Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n-                {\n-                    continue;\n-                }\n-                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::No)),\n-            }\n-        }\n-\n-        // So we have a resolution that's from a glob import. This resolution is determined\n-        // if it cannot be shadowed by some new item/import expanded from a macro.\n-        // This happens either if there are no unexpanded macros, or expanded names cannot\n-        // shadow globs (that happens in macro namespace or with restricted shadowing).\n-        //\n-        // Additionally, any macro in any module can plant names in the root module if it creates\n-        // `macro_export` macros, so the root module effectively has unresolved invocations if any\n-        // module has unresolved invocations.\n-        // However, it causes resolution/expansion to stuck too often (#53144), so, to make\n-        // progress, we have to ignore those potential unresolved invocations from other modules\n-        // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n-        // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n-        if let Some(binding) = resolution.binding {\n-            if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n-                return check_usable(self, binding);\n-            } else {\n-                return Err((Undetermined, Weak::No));\n-            }\n-        }\n-\n-        // --- From now on we have no resolution. ---\n-\n-        // Now we are in situation when new item/import can appear only from a glob or a macro\n-        // expansion. With restricted shadowing names from globs and macro expansions cannot\n-        // shadow names from outer scopes, so we can freely fallback from module search to search\n-        // in outer scopes. For `early_resolve_ident_in_lexical_scope` to continue search in outer\n-        // scopes we return `Undetermined` with `Weak::Yes`.\n-\n-        // Check if one of unexpanded macros can still define the name,\n-        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n-        if unexpanded_macros {\n-            return Err((Undetermined, Weak::Yes));\n-        }\n-\n-        // Check if one of glob imports can still define the name,\n-        // if it can then our \"no resolution\" result is not determined and can be invalidated.\n-        for glob_import in module.globs.borrow().iter() {\n-            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n-                continue;\n-            }\n-            let module = match glob_import.imported_module.get() {\n-                Some(ModuleOrUniformRoot::Module(module)) => module,\n-                Some(_) => continue,\n-                None => return Err((Undetermined, Weak::Yes)),\n-            };\n-            let tmp_parent_scope;\n-            let (mut adjusted_parent_scope, mut ident) =\n-                (parent_scope, ident.normalize_to_macros_2_0());\n-            match ident.span.glob_adjust(module.expansion, glob_import.span) {\n-                Some(Some(def)) => {\n-                    tmp_parent_scope =\n-                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n-                    adjusted_parent_scope = &tmp_parent_scope;\n-                }\n-                Some(None) => {}\n-                None => continue,\n-            };\n-            let result = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                adjusted_parent_scope,\n-                None,\n-            );\n-\n-            match result {\n-                Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, glob_import.parent_scope.module) =>\n-                {\n-                    continue;\n-                }\n-                Ok(_) | Err(Undetermined) => return Err((Undetermined, Weak::Yes)),\n-            }\n-        }\n-\n-        // No resolution and no one else can define the name - determinate error.\n-        Err((Determined, Weak::No))\n-    }\n-\n     // Given a binding and an import that resolves to it,\n     // return the corresponding binding defined by the import.\n     crate fn import(\n@@ -772,7 +499,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res =\n-                self.r.resolve_path(&import.module_path, None, &import.parent_scope, Finalize::No);\n+                self.r.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -812,6 +539,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         None,\n+                        false,\n+                        None,\n                     );\n                     import.vis.set(orig_vis);\n                     source_bindings[ns].set(binding);\n@@ -857,10 +586,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-        let orig_unusable_binding = match &import.kind {\n-            ImportKind::Single { target_bindings, .. } => {\n-                Some(mem::replace(&mut self.r.unusable_binding, target_bindings[TypeNS].get()))\n-            }\n+        let unusable_binding = match &import.kind {\n+            ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n@@ -869,12 +596,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             root_span: import.root_span,\n             path_span: import.span,\n         };\n-        let path_res =\n-            self.r.resolve_path(&import.module_path, None, &import.parent_scope, finalize);\n+        let path_res = self.r.resolve_path(\n+            &import.module_path,\n+            None,\n+            &import.parent_scope,\n+            finalize,\n+            unusable_binding,\n+        );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        if let Some(orig_unusable_binding) = orig_unusable_binding {\n-            self.r.unusable_binding = orig_unusable_binding;\n-        }\n         import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n@@ -987,18 +716,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-                let orig_unusable_binding =\n-                    mem::replace(&mut this.unusable_binding, target_bindings[ns].get());\n-                let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n                     ns,\n                     &import.parent_scope,\n                     Some(import.span),\n+                    true,\n+                    target_bindings[ns].get(),\n                 );\n-                this.last_import_segment = orig_last_import_segment;\n-                this.unusable_binding = orig_unusable_binding;\n                 import.vis.set(orig_vis);\n \n                 match binding {\n@@ -1057,6 +783,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         Some(import.span),\n+                        false,\n+                        None,\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1271,15 +999,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     return;\n                 }\n \n-                let orig_unusable_binding =\n-                    mem::replace(&mut this.unusable_binding, target_bindings[ns].get());\n-\n                 match this.early_resolve_ident_in_lexical_scope(\n                     target,\n                     ScopeSet::All(ns, false),\n                     &import.parent_scope,\n                     None,\n                     false,\n+                    false,\n+                    target_bindings[ns].get(),\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some(\n@@ -1289,8 +1016,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     }\n                     Err(_) => is_redundant[ns] = Some(false),\n                 }\n-\n-                this.unusable_binding = orig_unusable_binding;\n             }\n         });\n "}, {"sha": "f27b60e889f6b9c10154ccfc2806569cedd524f5", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -8,7 +8,7 @@\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, NameBinding, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use rustc_ast::ptr::P;\n@@ -487,6 +487,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         self_ty,\n                         TypeNS,\n                         Finalize::SimplePath(ty.id, ty.span),\n+                        None,\n                     )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -676,12 +677,8 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     // checking.\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() {\n                         let mut check_ns = |ns| {\n-                            self.resolve_ident_in_lexical_scope(\n-                                path.segments[0].ident,\n-                                ns,\n-                                Finalize::No,\n-                            )\n-                            .is_some()\n+                            self.maybe_resolve_ident_in_lexical_scope(path.segments[0].ident, ns)\n+                                .is_some()\n                         };\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n@@ -750,18 +747,35 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n+    fn maybe_resolve_ident_in_lexical_scope(\n+        &mut self,\n+        ident: Ident,\n+        ns: Namespace,\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        self.r.resolve_ident_in_lexical_scope(\n+            ident,\n+            ns,\n+            &self.parent_scope,\n+            Finalize::No,\n+            &self.ribs[ns],\n+            None,\n+        )\n+    }\n+\n     fn resolve_ident_in_lexical_scope(\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n         finalize: Finalize,\n+        unusable_binding: Option<&'a NameBinding<'a>>,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n             finalize,\n             &self.ribs[ns],\n+            unusable_binding,\n         )\n     }\n \n@@ -771,7 +785,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.r.resolve_path_with_ribs(path, opt_ns, &self.parent_scope, finalize, Some(&self.ribs))\n+        self.r.resolve_path_with_ribs(\n+            path,\n+            opt_ns,\n+            &self.parent_scope,\n+            finalize,\n+            Some(&self.ribs),\n+            None,\n+        )\n     }\n \n     // AST resolution\n@@ -934,19 +955,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No) {\n+                match self.maybe_resolve_ident_in_lexical_scope(ident, ns) {\n                     Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n-                        let orig_unusable_binding =\n-                            replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) =\n-                            self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No)\n+                        if let Some(LexicalScopeBinding::Res(..)) = self\n+                            .resolve_ident_in_lexical_scope(ident, ns, Finalize::No, Some(binding))\n                         {\n                             report_error(self, ns);\n                         }\n-                        self.r.unusable_binding = orig_unusable_binding;\n                     }\n                     None => {}\n                 }\n@@ -1802,7 +1820,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No)?;\n+        let ls_binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS)?;\n         let (res, binding) = match ls_binding {\n             LexicalScopeBinding::Item(binding)\n                 if is_syntactic_ambiguity && binding.is_ambiguity() =>\n@@ -1870,6 +1888,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // These entities are explicitly allowed to be shadowed by fresh bindings.\n                 None\n             }\n+            Res::SelfCtor(_) => {\n+                // We resolve `Self` in pattern position as an ident sometimes during recovery,\n+                // so delay a bug instead of ICEing.\n+                self.r.session.delay_span_bug(\n+                    ident.span,\n+                    \"unexpected `SelfCtor` in pattern, expected identifier\"\n+                );\n+                None\n+            }\n             _ => span_bug!(\n                 ident.span,\n                 \"unexpected resolution for an identifier in pattern: {:?}\",\n@@ -2071,17 +2098,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn self_type_is_available(&mut self) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_dummy_span(kw::SelfUpper),\n-            TypeNS,\n-            Finalize::No,\n-        );\n+        let binding = self\n+            .maybe_resolve_ident_in_lexical_scope(Ident::with_dummy_span(kw::SelfUpper), TypeNS);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No);\n+        let binding = self.maybe_resolve_ident_in_lexical_scope(ident, ValueNS);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n "}, {"sha": "0926f24ae70efb44f497a1a654e1d72c1d597423", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1271,12 +1271,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.r.resolve_ident_in_module(\n+            if let Ok(binding) = self.r.maybe_resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n                 &self.parent_scope,\n-                None,\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {"}, {"sha": "b2c7a4d18de386c42a18ce55e126ee724c5bbd5e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1483, "changes": 1494, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! This crate is responsible for the part of name resolution that doesn't require type checker.\n //!\n //! Module structure of the crate is built here.\n@@ -26,27 +24,18 @@ extern crate tracing;\n \n pub use rustc_hir::def::{Namespace, PerNS};\n \n-use Determinacy::*;\n-\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::ptr::P;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n-use rustc_ast::{Crate, CRATE_NODE_ID};\n-use rustc_ast::{Expr, ExprKind, LitKind};\n-use rustc_ast::{ItemKind, ModKind, Path};\n+use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n+use rustc_ast::{Crate, Expr, ExprKind, LitKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n-use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n@@ -55,16 +44,14 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n-use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n-use rustc_session::lint;\n-use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n+use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n-use rustc_span::edition::Edition;\n-use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n+use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -75,10 +62,9 @@ use std::collections::BTreeSet;\n use std::{cmp, fmt, mem, ptr};\n use tracing::debug;\n \n-use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n-use late::{ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind::*};\n+use late::{HasGenericParams, PathSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n use crate::access_levels::AccessLevelsVisitor;\n@@ -90,6 +76,7 @@ mod build_reduced_graph;\n mod check_unused;\n mod def_collector;\n mod diagnostics;\n+mod ident;\n mod imports;\n mod late;\n mod macros;\n@@ -315,73 +302,6 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-#[derive(Debug)]\n-struct UsePlacementFinder {\n-    target_module: NodeId,\n-    first_legal_span: Option<Span>,\n-    first_use_span: Option<Span>,\n-}\n-\n-impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n-        let mut finder =\n-            UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n-        finder.visit_crate(krate);\n-        if let Some(use_span) = finder.first_use_span {\n-            (Some(use_span), true)\n-        } else {\n-            (finder.first_legal_span, false)\n-        }\n-    }\n-}\n-\n-fn is_span_suitable_for_use_injection(s: Span) -> bool {\n-    // don't suggest placing a use before the prelude\n-    // import or other generated ones\n-    !s.from_expansion()\n-}\n-\n-fn search_for_any_use_in_items(items: &[P<ast::Item>]) -> Option<Span> {\n-    for item in items {\n-        if let ItemKind::Use(..) = item.kind {\n-            if is_span_suitable_for_use_injection(item.span) {\n-                return Some(item.span.shrink_to_lo());\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n-    fn visit_crate(&mut self, c: &Crate) {\n-        if self.target_module == CRATE_NODE_ID {\n-            let inject = c.spans.inject_use_span;\n-            if is_span_suitable_for_use_injection(inject) {\n-                self.first_legal_span = Some(inject);\n-            }\n-            self.first_use_span = search_for_any_use_in_items(&c.items);\n-            return;\n-        } else {\n-            visit::walk_crate(self, c);\n-        }\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx ast::Item) {\n-        if self.target_module == item.id {\n-            if let ItemKind::Mod(_, ModKind::Loaded(items, _inline, mod_spans)) = &item.kind {\n-                let inject = mod_spans.inject_use_span;\n-                if is_span_suitable_for_use_injection(inject) {\n-                    self.first_legal_span = Some(inject);\n-                }\n-                self.first_use_span = search_for_any_use_in_items(items);\n-                return;\n-            }\n-        } else {\n-            visit::walk_item(self, item);\n-        }\n-    }\n-}\n-\n /// An intermediate resolution result.\n ///\n /// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n@@ -928,13 +848,6 @@ pub struct Resolver<'a> {\n     /// All non-determined imports.\n     indeterminate_imports: Vec<&'a Import<'a>>,\n \n-    /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n-    /// We are resolving a last import segment during import validation.\n-    last_import_segment: bool,\n-    /// This binding should be ignored during in-module resolution, so that we don't get\n-    /// \"self-confirming\" import resolutions during import validation.\n-    unusable_binding: Option<&'a NameBinding<'a>>,\n-\n     // Spans for local variables found during pattern resolution.\n     // Used for suggestions during error reporting.\n     pat_span_map: NodeMap<Span>,\n@@ -1342,9 +1255,6 @@ impl<'a> Resolver<'a> {\n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n \n-            last_import_segment: false,\n-            unusable_binding: None,\n-\n             pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n@@ -1731,387 +1641,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// A generic scope visitor.\n-    /// Visits scopes in order to resolve some identifier in them or perform other actions.\n-    /// If the callback returns `Some` result, we stop visiting scopes and return it.\n-    fn visit_scopes<T>(\n-        &mut self,\n-        scope_set: ScopeSet<'a>,\n-        parent_scope: &ParentScope<'a>,\n-        ctxt: SyntaxContext,\n-        mut visitor: impl FnMut(\n-            &mut Self,\n-            Scope<'a>,\n-            /*use_prelude*/ bool,\n-            SyntaxContext,\n-        ) -> Option<T>,\n-    ) -> Option<T> {\n-        // General principles:\n-        // 1. Not controlled (user-defined) names should have higher priority than controlled names\n-        //    built into the language or standard library. This way we can add new names into the\n-        //    language or standard library without breaking user code.\n-        // 2. \"Closed set\" below means new names cannot appear after the current resolution attempt.\n-        // Places to search (in order of decreasing priority):\n-        // (Type NS)\n-        // 1. FIXME: Ribs (type parameters), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Extern prelude (open, the open part is from macro expansions, not controlled).\n-        // 4. Tool modules (closed, controlled right now, but not in the future).\n-        // 5. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude (closed, controlled).\n-        // (Value NS)\n-        // 1. FIXME: Ribs (local variables), there's no necessary infrastructure yet\n-        //    (open set, not controlled).\n-        // 2. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled).\n-        // 3. Standard library prelude (de-facto closed, controlled).\n-        // (Macro NS)\n-        // 1-3. Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and probably even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n-        //    priority than prelude macros, but create ambiguities with macros in modules.\n-        // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n-        //    (open, not controlled). Have higher priority than prelude macros, but create\n-        //    ambiguities with `macro_rules`.\n-        // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n-        // 4a. User-defined prelude from macro-use\n-        //    (open, the open part is from macro expansions, not controlled).\n-        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n-        // 4c. Standard library prelude (de-facto closed, controlled).\n-        // 6. Language prelude: builtin attributes (closed, controlled).\n-\n-        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n-        let (ns, macro_kind, is_absolute_path) = match scope_set {\n-            ScopeSet::All(ns, _) => (ns, None, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Late(ns, ..) => (ns, None, false),\n-        };\n-        let module = match scope_set {\n-            // Start with the specified module.\n-            ScopeSet::Late(_, module, _) => module,\n-            // Jump out of trait or enum modules, they do not act as scopes.\n-            _ => parent_scope.module.nearest_item_scope(),\n-        };\n-        let mut scope = match ns {\n-            _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module, None),\n-            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n-        };\n-        let mut ctxt = ctxt.normalize_to_macros_2_0();\n-        let mut use_prelude = !module.no_implicit_prelude;\n-\n-        loop {\n-            let visit = match scope {\n-                // Derive helpers are not in scope when resolving derives in the same container.\n-                Scope::DeriveHelpers(expn_id) => {\n-                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n-                }\n-                Scope::DeriveHelpersCompat => true,\n-                Scope::MacroRules(macro_rules_scope) => {\n-                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n-                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n-                    // As another consequence of this optimization visitors never observe invocation\n-                    // scopes for macros that were already expanded.\n-                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n-                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n-                            macro_rules_scope.set(next_scope.get());\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-                    true\n-                }\n-                Scope::CrateRoot => true,\n-                Scope::Module(..) => true,\n-                Scope::RegisteredAttrs => use_prelude,\n-                Scope::MacroUsePrelude => use_prelude || rust_2015,\n-                Scope::BuiltinAttrs => true,\n-                Scope::ExternPrelude => use_prelude || is_absolute_path,\n-                Scope::ToolPrelude => use_prelude,\n-                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n-                Scope::BuiltinTypes => true,\n-            };\n-\n-            if visit {\n-                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ctxt) {\n-                    return break_result;\n-                }\n-            }\n-\n-            scope = match scope {\n-                Scope::DeriveHelpers(LocalExpnId::ROOT) => Scope::DeriveHelpersCompat,\n-                Scope::DeriveHelpers(expn_id) => {\n-                    // Derive helpers are not visible to code generated by bang or derive macros.\n-                    let expn_data = expn_id.expn_data();\n-                    match expn_data.kind {\n-                        ExpnKind::Root\n-                        | ExpnKind::Macro(MacroKind::Bang | MacroKind::Derive, _) => {\n-                            Scope::DeriveHelpersCompat\n-                        }\n-                        _ => Scope::DeriveHelpers(expn_data.parent.expect_local()),\n-                    }\n-                }\n-                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n-                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n-                    MacroRulesScope::Binding(binding) => {\n-                        Scope::MacroRules(binding.parent_macro_rules_scope)\n-                    }\n-                    MacroRulesScope::Invocation(invoc_id) => {\n-                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n-                    }\n-                    MacroRulesScope::Empty => Scope::Module(module, None),\n-                },\n-                Scope::CrateRoot => match ns {\n-                    TypeNS => {\n-                        ctxt.adjust(ExpnId::root());\n-                        Scope::ExternPrelude\n-                    }\n-                    ValueNS | MacroNS => break,\n-                },\n-                Scope::Module(module, prev_lint_id) => {\n-                    use_prelude = !module.no_implicit_prelude;\n-                    let derive_fallback_lint_id = match scope_set {\n-                        ScopeSet::Late(.., lint_id) => lint_id,\n-                        _ => None,\n-                    };\n-                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n-                        Some((parent_module, lint_id)) => {\n-                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n-                        }\n-                        None => {\n-                            ctxt.adjust(ExpnId::root());\n-                            match ns {\n-                                TypeNS => Scope::ExternPrelude,\n-                                ValueNS => Scope::StdLibPrelude,\n-                                MacroNS => Scope::RegisteredAttrs,\n-                            }\n-                        }\n-                    }\n-                }\n-                Scope::RegisteredAttrs => Scope::MacroUsePrelude,\n-                Scope::MacroUsePrelude => Scope::StdLibPrelude,\n-                Scope::BuiltinAttrs => break, // nowhere else to search\n-                Scope::ExternPrelude if is_absolute_path => break,\n-                Scope::ExternPrelude => Scope::ToolPrelude,\n-                Scope::ToolPrelude => Scope::StdLibPrelude,\n-                Scope::StdLibPrelude => match ns {\n-                    TypeNS => Scope::BuiltinTypes,\n-                    ValueNS => break, // nowhere else to search\n-                    MacroNS => Scope::BuiltinAttrs,\n-                },\n-                Scope::BuiltinTypes => break, // nowhere else to search\n-            };\n-        }\n-\n-        None\n-    }\n-\n-    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n-    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n-    /// `ident` in the first scope that defines it (or None if no scopes define it).\n-    ///\n-    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n-    /// the items are defined in the block. For example,\n-    /// ```rust\n-    /// fn f() {\n-    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n-    ///    let g = || {};\n-    ///    fn g() {}\n-    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n-    /// }\n-    /// ```\n-    ///\n-    /// Invariant: This must only be called during main resolution, not during\n-    /// import resolution.\n-    fn resolve_ident_in_lexical_scope(\n-        &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n-        ribs: &[Rib<'a>],\n-    ) -> Option<LexicalScopeBinding<'a>> {\n-        assert!(ns == TypeNS || ns == ValueNS);\n-        let orig_ident = ident;\n-        if ident.name == kw::Empty {\n-            return Some(LexicalScopeBinding::Res(Res::Err));\n-        }\n-        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n-            // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n-            (empty_span, empty_span)\n-        } else if ns == TypeNS {\n-            let normalized_span = ident.span.normalize_to_macros_2_0();\n-            (normalized_span, normalized_span)\n-        } else {\n-            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n-        };\n-        ident.span = general_span;\n-        let normalized_ident = Ident { span: normalized_span, ..ident };\n-\n-        // Walk backwards up the ribs in scope.\n-        let finalize = finalize_full.path_span();\n-        let mut module = self.graph_root;\n-        for i in (0..ribs.len()).rev() {\n-            debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n-            // Use the rib kind to determine whether we are resolving parameters\n-            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n-            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n-            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n-            {\n-                // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n-                    i,\n-                    rib_ident,\n-                    *res,\n-                    finalize,\n-                    *original_rib_ident_def,\n-                    ribs,\n-                )));\n-            }\n-\n-            module = match ribs[i].kind {\n-                ModuleRibKind(module) => module,\n-                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n-                    // If an invocation of this macro created `ident`, give up on `ident`\n-                    // and switch to `ident`'s source from the macro definition.\n-                    ident.span.remove_mark();\n-                    continue;\n-                }\n-                _ => continue,\n-            };\n-\n-            match module.kind {\n-                ModuleKind::Block(..) => {} // We can see through blocks\n-                _ => break,\n-            }\n-\n-            let item = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                parent_scope,\n-                finalize,\n-            );\n-            if let Ok(binding) = item {\n-                // The ident resolves to an item.\n-                return Some(LexicalScopeBinding::Item(binding));\n-            }\n-        }\n-        self.early_resolve_ident_in_lexical_scope(\n-            orig_ident,\n-            ScopeSet::Late(ns, module, finalize_full.node_id()),\n-            parent_scope,\n-            finalize,\n-            finalize.is_some(),\n-        )\n-        .ok()\n-        .map(LexicalScopeBinding::Item)\n-    }\n-\n-    fn hygienic_lexical_parent(\n-        &mut self,\n-        module: Module<'a>,\n-        ctxt: &mut SyntaxContext,\n-        derive_fallback_lint_id: Option<NodeId>,\n-    ) -> Option<(Module<'a>, Option<NodeId>)> {\n-        if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n-        }\n-\n-        if let ModuleKind::Block(..) = module.kind {\n-            return Some((module.parent.unwrap().nearest_item_scope(), None));\n-        }\n-\n-        // We need to support the next case under a deprecation warning\n-        // ```\n-        // struct MyStruct;\n-        // ---- begin: this comes from a proc macro derive\n-        // mod implementation_details {\n-        //     // Note that `MyStruct` is not in scope here.\n-        //     impl SomeTrait for MyStruct { ... }\n-        // }\n-        // ---- end\n-        // ```\n-        // So we have to fall back to the module's parent during lexical resolution in this case.\n-        if derive_fallback_lint_id.is_some() {\n-            if let Some(parent) = module.parent {\n-                // Inner module is inside the macro, parent module is outside of the macro.\n-                if module.expansion != parent.expansion\n-                    && module.expansion.is_descendant_of(parent.expansion)\n-                {\n-                    // The macro is a proc macro derive\n-                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                        let ext = self.get_macro_by_def_id(def_id);\n-                        if ext.builtin_name.is_none()\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n-                        {\n-                            return Some((parent, derive_fallback_lint_id));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn resolve_ident_in_module(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n-            .map_err(|(determinacy, _)| determinacy)\n-    }\n-\n-    fn resolve_ident_in_module_ext(\n-        &mut self,\n-        module: ModuleOrUniformRoot<'a>,\n-        mut ident: Ident,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-    ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n-        let tmp_parent_scope;\n-        let mut adjusted_parent_scope = parent_scope;\n-        match module {\n-            ModuleOrUniformRoot::Module(m) => {\n-                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n-                    tmp_parent_scope =\n-                        ParentScope { module: self.expn_def_scope(def), ..*parent_scope };\n-                    adjusted_parent_scope = &tmp_parent_scope;\n-                }\n-            }\n-            ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n-            }\n-            ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n-                // No adjustments\n-            }\n-        }\n-        self.resolve_ident_in_module_unadjusted_ext(\n-            module,\n-            ident,\n-            ns,\n-            adjusted_parent_scope,\n-            false,\n-            finalize,\n-        )\n-    }\n-\n     fn resolve_crate_root(&mut self, ident: Ident) -> Module<'a> {\n         debug!(\"resolve_crate_root({:?})\", ident);\n         let mut ctxt = ident.span.ctxt();\n@@ -2194,676 +1723,6 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    fn resolve_path(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Finalize,\n-    ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n-    }\n-\n-    fn resolve_path_with_ribs(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n-        ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n-    ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n-\n-        let finalize = finalize_full.path_span();\n-        let mut module = None;\n-        let mut allow_super = true;\n-        let mut second_binding = None;\n-\n-        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n-            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n-            let record_segment_res = |this: &mut Self, res| {\n-                if finalize.is_some() {\n-                    if let Some(id) = id {\n-                        if !this.partial_res_map.contains_key(&id) {\n-                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_partial_res(id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-            };\n-\n-            let is_last = i == path.len() - 1;\n-            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n-            let name = ident.name;\n-\n-            allow_super &= ns == TypeNS && (name == kw::SelfLower || name == kw::Super);\n-\n-            if ns == TypeNS {\n-                if allow_super && name == kw::Super {\n-                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                    let self_module = match i {\n-                        0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n-                        _ => match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => Some(module),\n-                            _ => None,\n-                        },\n-                    };\n-                    if let Some(self_module) = self_module {\n-                        if let Some(parent) = self_module.parent {\n-                            module = Some(ModuleOrUniformRoot::Module(\n-                                self.resolve_self(&mut ctxt, parent),\n-                            ));\n-                            continue;\n-                        }\n-                    }\n-                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                        (\"there are too many leading `super` keywords\".to_string(), None)\n-                    });\n-                }\n-                if i == 0 {\n-                    if name == kw::SelfLower {\n-                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n-                        module = Some(ModuleOrUniformRoot::Module(\n-                            self.resolve_self(&mut ctxt, parent_scope.module),\n-                        ));\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot && ident.span.rust_2018() {\n-                        module = Some(ModuleOrUniformRoot::ExternPrelude);\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n-                        // `::a::b` from 2015 macro on 2018 global edition\n-                        module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n-                        continue;\n-                    }\n-                    if name == kw::PathRoot || name == kw::Crate || name == kw::DollarCrate {\n-                        // `::a::b`, `crate::a::b` or `$crate::a::b`\n-                        module = Some(ModuleOrUniformRoot::Module(self.resolve_crate_root(ident)));\n-                        continue;\n-                    }\n-                }\n-            }\n-\n-            // Report special messages for path segment keywords in wrong positions.\n-            if ident.is_path_segment_keyword() && i != 0 {\n-                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n-                    let name_str = if name == kw::PathRoot {\n-                        \"crate root\".to_string()\n-                    } else {\n-                        format!(\"`{}`\", name)\n-                    };\n-                    let label = if i == 1 && path[0].ident.name == kw::PathRoot {\n-                        format!(\"global paths cannot start with {}\", name_str)\n-                    } else {\n-                        format!(\"{} in paths can only be used in start position\", name_str)\n-                    };\n-                    (label, None)\n-                });\n-            }\n-\n-            enum FindBindingResult<'a> {\n-                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n-                PathResult(PathResult<'a>),\n-            }\n-            let find_binding_in_ns = |this: &mut Self, ns| {\n-                let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n-                } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n-                    let scopes = ScopeSet::All(ns, opt_ns.is_none());\n-                    this.early_resolve_ident_in_lexical_scope(\n-                        ident,\n-                        scopes,\n-                        parent_scope,\n-                        finalize,\n-                        finalize.is_some(),\n-                    )\n-                } else {\n-                    match this.resolve_ident_in_lexical_scope(\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        finalize_full,\n-                        &ribs.unwrap()[ns],\n-                    ) {\n-                        // we found a locally-imported or available item/module\n-                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                        // we found a local variable or type param\n-                        Some(LexicalScopeBinding::Res(res))\n-                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n-                        {\n-                            record_segment_res(this, res);\n-                            return FindBindingResult::PathResult(PathResult::NonModule(\n-                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n-                            ));\n-                        }\n-                        _ => Err(Determinacy::determined(finalize.is_some())),\n-                    }\n-                };\n-                FindBindingResult::Binding(binding)\n-            };\n-            let binding = match find_binding_in_ns(self, ns) {\n-                FindBindingResult::PathResult(x) => return x,\n-                FindBindingResult::Binding(binding) => binding,\n-            };\n-            match binding {\n-                Ok(binding) => {\n-                    if i == 1 {\n-                        second_binding = Some(binding);\n-                    }\n-                    let res = binding.res();\n-                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n-                    if let Some(next_module) = binding.module() {\n-                        module = Some(ModuleOrUniformRoot::Module(next_module));\n-                        record_segment_res(self, res);\n-                    } else if res == Res::ToolMod && i + 1 != path.len() {\n-                        if binding.is_import() {\n-                            self.session\n-                                .struct_span_err(\n-                                    ident.span,\n-                                    \"cannot use a tool module through an import\",\n-                                )\n-                                .span_note(binding.span, \"the tool module imported here\")\n-                                .emit();\n-                        }\n-                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        return PathResult::NonModule(PartialRes::new(res));\n-                    } else if res == Res::Err {\n-                        return PathResult::NonModule(PartialRes::new(Res::Err));\n-                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n-                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                            res,\n-                            path.len() - i - 1,\n-                        ));\n-                    } else {\n-                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                            let label = format!(\n-                                \"`{ident}` is {} {}, not a module\",\n-                                res.article(),\n-                                res.descr()\n-                            );\n-                            (label, None)\n-                        });\n-                    }\n-                }\n-                Err(Undetermined) => return PathResult::Indeterminate,\n-                Err(Determined) => {\n-                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n-                        if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n-                                module.res().unwrap(),\n-                                path.len() - i,\n-                            ));\n-                        }\n-                    }\n-\n-                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n-                        let module_res = match module {\n-                            Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                            _ => None,\n-                        };\n-                        if module_res == self.graph_root.res() {\n-                            let is_mod = |res| matches!(res, Res::Def(DefKind::Mod, _));\n-                            let mut candidates =\n-                                self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n-                            candidates.sort_by_cached_key(|c| {\n-                                (c.path.segments.len(), pprust::path_to_string(&c.path))\n-                            });\n-                            if let Some(candidate) = candidates.get(0) {\n-                                (\n-                                    String::from(\"unresolved import\"),\n-                                    Some((\n-                                        vec![(ident.span, pprust::path_to_string(&candidate.path))],\n-                                        String::from(\"a similar path exists\"),\n-                                        Applicability::MaybeIncorrect,\n-                                    )),\n-                                )\n-                            } else if self.session.edition() == Edition::Edition2015 {\n-                                (format!(\"maybe a missing crate `{}`?\", ident), None)\n-                            } else {\n-                                (format!(\"could not find `{}` in the crate root\", ident), None)\n-                            }\n-                        } else if i == 0 {\n-                            if ident\n-                                .name\n-                                .as_str()\n-                                .chars()\n-                                .next()\n-                                .map_or(false, |c| c.is_ascii_uppercase())\n-                            {\n-                                // Check whether the name refers to an item in the value namespace.\n-                                let suggestion = if ribs.is_some() {\n-                                    let match_span = match self.resolve_ident_in_lexical_scope(\n-                                        ident,\n-                                        ValueNS,\n-                                        parent_scope,\n-                                        Finalize::No,\n-                                        &ribs.unwrap()[ValueNS],\n-                                    ) {\n-                                        // Name matches a local variable. For example:\n-                                        // ```\n-                                        // fn f() {\n-                                        //     let Foo: &str = \"\";\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // variable `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                                            Some(*self.pat_span_map.get(&id).unwrap())\n-                                        }\n-\n-                                        // Name matches item from a local name binding\n-                                        // created by `use` declaration. For example:\n-                                        // ```\n-                                        // pub Foo: &str = \"\";\n-                                        //\n-                                        // mod submod {\n-                                        //     use super::Foo;\n-                                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                                        //                               // binding `Foo`.\n-                                        // }\n-                                        // ```\n-                                        Some(LexicalScopeBinding::Item(name_binding)) => {\n-                                            Some(name_binding.span)\n-                                        }\n-                                        _ => None,\n-                                    };\n-\n-                                    if let Some(span) = match_span {\n-                                        Some((\n-                                            vec![(span, String::from(\"\"))],\n-                                            format!(\n-                                                \"`{}` is defined here, but is not a type\",\n-                                                ident\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        None\n-                                    }\n-                                } else {\n-                                    None\n-                                };\n-\n-                                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n-                            } else {\n-                                (\n-                                    format!(\"use of undeclared crate or module `{}`\", ident),\n-                                    if ident.name == sym::alloc {\n-                                        Some((\n-                                            vec![],\n-                                            String::from(\n-                                                \"add `extern crate alloc` to use the `alloc` crate\",\n-                                            ),\n-                                            Applicability::MaybeIncorrect,\n-                                        ))\n-                                    } else {\n-                                        self.find_similarly_named_module_or_crate(\n-                                            ident.name,\n-                                            &parent_scope.module,\n-                                        )\n-                                        .map(|sugg| {\n-                                            (\n-                                                vec![(ident.span, sugg.to_string())],\n-                                                String::from(\n-                                                    \"there is a crate or module with a similar name\",\n-                                                ),\n-                                                Applicability::MaybeIncorrect,\n-                                            )\n-                                        })\n-                                    },\n-                                )\n-                            }\n-                        } else {\n-                            let parent = path[i - 1].ident.name;\n-                            let parent = match parent {\n-                                // ::foo is mounted at the crate root for 2015, and is the extern\n-                                // prelude for 2018+\n-                                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n-                                    \"the list of imported crates\".to_owned()\n-                                }\n-                                kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                                _ => {\n-                                    format!(\"`{}`\", parent)\n-                                }\n-                            };\n-\n-                            let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n-                            if ns == TypeNS || ns == ValueNS {\n-                                let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                                if let FindBindingResult::Binding(Ok(binding)) =\n-                                    find_binding_in_ns(self, ns_to_try)\n-                                {\n-                                    let mut found = |what| {\n-                                        msg = format!(\n-                                            \"expected {}, found {} `{}` in {}\",\n-                                            ns.descr(),\n-                                            what,\n-                                            ident,\n-                                            parent\n-                                        )\n-                                    };\n-                                    if binding.module().is_some() {\n-                                        found(\"module\")\n-                                    } else {\n-                                        match binding.res() {\n-                                            def::Res::<NodeId>::Def(kind, id) => {\n-                                                found(kind.descr(id))\n-                                            }\n-                                            _ => found(ns_to_try.descr()),\n-                                        }\n-                                    }\n-                                };\n-                            }\n-                            (msg, None)\n-                        }\n-                    });\n-                }\n-            }\n-        }\n-\n-        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n-\n-        PathResult::Module(match module {\n-            Some(module) => module,\n-            None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n-            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n-        })\n-    }\n-\n-    fn lint_if_path_starts_with_module(\n-        &mut self,\n-        finalize: Finalize,\n-        path: &[Segment],\n-        second_binding: Option<&NameBinding<'_>>,\n-    ) {\n-        let (diag_id, diag_span) = match finalize {\n-            Finalize::No => return,\n-            Finalize::SimplePath(id, path_span) => (id, path_span),\n-            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n-            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n-        };\n-\n-        let first_name = match path.get(0) {\n-            // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n-            _ => return,\n-        };\n-\n-        // We're only interested in `use` paths which should start with\n-        // `{{root}}` currently.\n-        if first_name != kw::PathRoot {\n-            return;\n-        }\n-\n-        match path.get(1) {\n-            // If this import looks like `crate::...` it's already good\n-            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n-            // Otherwise go below to see if it's an extern crate\n-            Some(_) => {}\n-            // If the path has length one (and it's `PathRoot` most likely)\n-            // then we don't know whether we're gonna be importing a crate or an\n-            // item in our crate. Defer this lint to elsewhere\n-            None => return,\n-        }\n-\n-        // If the first element of our path was actually resolved to an\n-        // `ExternCrate` (also used for `crate::...`) then no need to issue a\n-        // warning, this looks all good!\n-        if let Some(binding) = second_binding {\n-            if let NameBindingKind::Import { import, .. } = binding.kind {\n-                // Careful: we still want to rewrite paths from renamed extern crates.\n-                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n-        self.lint_buffer.buffer_lint_with_diagnostic(\n-            lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            diag_id,\n-            diag_span,\n-            \"absolute paths must start with `self`, `super`, \\\n-             `crate`, or an external crate name in the 2018 edition\",\n-            diag,\n-        );\n-    }\n-\n-    // Validate a local resolution (from ribs).\n-    fn validate_res_from_ribs(\n-        &mut self,\n-        rib_index: usize,\n-        rib_ident: Ident,\n-        mut res: Res,\n-        finalize: Option<Span>,\n-        original_rib_ident_def: Ident,\n-        all_ribs: &[Rib<'a>],\n-    ) -> Res {\n-        const CG_BUG_STR: &str = \"min_const_generics resolve check didn't stop compilation\";\n-        debug!(\"validate_res_from_ribs({:?})\", res);\n-        let ribs = &all_ribs[rib_index + 1..];\n-\n-        // An invalid forward use of a generic parameter from a previous default.\n-        if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n-            if let Some(span) = finalize {\n-                let res_error = if rib_ident.name == kw::SelfUpper {\n-                    ResolutionError::SelfInGenericParamDefault\n-                } else {\n-                    ResolutionError::ForwardDeclaredGenericParam\n-                };\n-                self.report_error(span, res_error);\n-            }\n-            assert_eq!(res, Res::Err);\n-            return Res::Err;\n-        }\n-\n-        match res {\n-            Res::Local(_) => {\n-                use ResolutionError::*;\n-                let mut res_err = None;\n-\n-                for rib in ribs {\n-                    match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => {\n-                            // Nothing to do. Continue.\n-                        }\n-                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n-                            // This was an attempt to access an upvar inside a\n-                            // named function item. This is not allowed, so we\n-                            // report an error.\n-                            if let Some(span) = finalize {\n-                                // We don't immediately trigger a resolve error, because\n-                                // we want certain other resolution errors (namely those\n-                                // emitted for `ConstantItemRibKind` below) to take\n-                                // precedence.\n-                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n-                            }\n-                        }\n-                        ConstantItemRibKind(_, item) => {\n-                            // Still doesn't deal with upvars\n-                            if let Some(span) = finalize {\n-                                let (span, resolution_error) =\n-                                    if let Some((ident, constant_item_kind)) = item {\n-                                        let kind_str = match constant_item_kind {\n-                                            ConstantItemKind::Const => \"const\",\n-                                            ConstantItemKind::Static => \"static\",\n-                                        };\n-                                        (\n-                                            span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                ident, \"let\", kind_str,\n-                                            ),\n-                                        )\n-                                    } else {\n-                                        (\n-                                            rib_ident.span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                original_rib_ident_def,\n-                                                \"const\",\n-                                                \"let\",\n-                                            ),\n-                                        )\n-                                    };\n-                                self.report_error(span, resolution_error);\n-                            }\n-                            return Res::Err;\n-                        }\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n-                            }\n-                            return Res::Err;\n-                        }\n-                    }\n-                }\n-                if let Some((span, res_err)) = res_err {\n-                    self.report_error(span, res_err);\n-                    return Res::Err;\n-                }\n-            }\n-            Res::Def(DefKind::TyParam, _) | Res::SelfTy { .. } => {\n-                for rib in ribs {\n-                    let has_generic_params: HasGenericParams = match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => {\n-                            // Nothing to do. Continue.\n-                            continue;\n-                        }\n-\n-                        ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial || features.generic_const_exprs) {\n-                                // HACK(min_const_generics): If we encounter `Self` in an anonymous constant\n-                                // we can't easily tell if it's generic at this stage, so we instead remember\n-                                // this and then enforce the self type to be concrete later on.\n-                                if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n-                                    res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n-                                } else {\n-                                    if let Some(span) = finalize {\n-                                        self.report_error(\n-                                            span,\n-                                            ResolutionError::ParamInNonTrivialAnonConst {\n-                                                name: rib_ident.name,\n-                                                is_type: true,\n-                                            },\n-                                        );\n-                                        self.session.delay_span_bug(span, CG_BUG_STR);\n-                                    }\n-\n-                                    return Res::Err;\n-                                }\n-                            }\n-\n-                            continue;\n-                        }\n-\n-                        // This was an attempt to use a type parameter outside its scope.\n-                        ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(\n-                                    span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n-                    };\n-\n-                    if let Some(span) = finalize {\n-                        self.report_error(\n-                            span,\n-                            ResolutionError::GenericParamsFromOuterFunction(\n-                                res,\n-                                has_generic_params,\n-                            ),\n-                        );\n-                    }\n-                    return Res::Err;\n-                }\n-            }\n-            Res::Def(DefKind::ConstParam, _) => {\n-                let mut ribs = ribs.iter().peekable();\n-                if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n-                    // When declaring const parameters inside function signatures, the first rib\n-                    // is always a `FnItemRibKind`. In this case, we can skip it, to avoid it\n-                    // (spuriously) conflicting with the const param.\n-                    ribs.next();\n-                }\n-\n-                for rib in ribs {\n-                    let has_generic_params = match rib.kind {\n-                        NormalRibKind\n-                        | ClosureOrAsyncRibKind\n-                        | AssocItemRibKind\n-                        | ModuleRibKind(..)\n-                        | MacroDefinition(..)\n-                        | ForwardGenericParamBanRibKind => continue,\n-\n-                        ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial || features.generic_const_exprs) {\n-                                if let Some(span) = finalize {\n-                                    self.report_error(\n-                                        span,\n-                                        ResolutionError::ParamInNonTrivialAnonConst {\n-                                            name: rib_ident.name,\n-                                            is_type: false,\n-                                        },\n-                                    );\n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n-                                }\n-\n-                                return Res::Err;\n-                            }\n-\n-                            continue;\n-                        }\n-\n-                        ItemRibKind(has_generic_params) => has_generic_params,\n-                        FnItemRibKind => HasGenericParams::Yes,\n-                        ConstParamTyRibKind => {\n-                            if let Some(span) = finalize {\n-                                self.report_error(\n-                                    span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n-                    };\n-\n-                    // This was an attempt to use a const parameter outside its scope.\n-                    if let Some(span) = finalize {\n-                        self.report_error(\n-                            span,\n-                            ResolutionError::GenericParamsFromOuterFunction(\n-                                res,\n-                                has_generic_params,\n-                            ),\n-                        );\n-                    }\n-                    return Res::Err;\n-                }\n-            }\n-            _ => {}\n-        }\n-        res\n-    }\n-\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n@@ -2910,331 +1769,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn report_errors(&mut self, krate: &Crate) {\n-        self.report_with_use_injections(krate);\n-\n-        for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n-            let msg = \"macro-expanded `macro_export` macros from the current crate \\\n-                       cannot be referred to by absolute paths\";\n-            self.lint_buffer.buffer_lint_with_diagnostic(\n-                lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n-                CRATE_NODE_ID,\n-                span_use,\n-                msg,\n-                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def),\n-            );\n-        }\n-\n-        for ambiguity_error in &self.ambiguity_errors {\n-            self.report_ambiguity_error(ambiguity_error);\n-        }\n-\n-        let mut reported_spans = FxHashSet::default();\n-        for error in &self.privacy_errors {\n-            if reported_spans.insert(error.dedup_span) {\n-                self.report_privacy_error(error);\n-            }\n-        }\n-    }\n-\n-    fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, def_id, instead, suggestion } in\n-            self.use_injections.drain(..)\n-        {\n-            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n-                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n-            } else {\n-                (None, false)\n-            };\n-            if !candidates.is_empty() {\n-                diagnostics::show_candidates(\n-                    &self.definitions,\n-                    self.session,\n-                    &mut err,\n-                    span,\n-                    &candidates,\n-                    instead,\n-                    found_use,\n-                );\n-            } else if let Some((span, msg, sugg, appl)) = suggestion {\n-                err.span_suggestion(span, msg, sugg, appl);\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    fn report_conflict<'b>(\n-        &mut self,\n-        parent: Module<'_>,\n-        ident: Ident,\n-        ns: Namespace,\n-        new_binding: &NameBinding<'b>,\n-        old_binding: &NameBinding<'b>,\n-    ) {\n-        // Error on the second of two conflicting names\n-        if old_binding.span.lo() > new_binding.span.lo() {\n-            return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n-        }\n-\n-        let container = match parent.kind {\n-            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n-            ModuleKind::Block(..) => \"block\",\n-        };\n-\n-        let old_noun = match old_binding.is_import() {\n-            true => \"import\",\n-            false => \"definition\",\n-        };\n-\n-        let new_participle = match new_binding.is_import() {\n-            true => \"imported\",\n-            false => \"defined\",\n-        };\n-\n-        let (name, span) =\n-            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n-\n-        if let Some(s) = self.name_already_seen.get(&name) {\n-            if s == &span {\n-                return;\n-            }\n-        }\n-\n-        let old_kind = match (ns, old_binding.module()) {\n-            (ValueNS, _) => \"value\",\n-            (MacroNS, _) => \"macro\",\n-            (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n-            (TypeNS, Some(module)) if module.is_normal() => \"module\",\n-            (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n-            (TypeNS, _) => \"type\",\n-        };\n-\n-        let msg = format!(\"the name `{}` is defined multiple times\", name);\n-\n-        let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n-            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n-            (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n-                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n-                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n-            },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n-                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n-                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n-            },\n-        };\n-\n-        err.note(&format!(\n-            \"`{}` must be defined only once in the {} namespace of this {}\",\n-            name,\n-            ns.descr(),\n-            container\n-        ));\n-\n-        err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        err.span_label(\n-            self.session.source_map().guess_head_span(old_binding.span),\n-            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n-        );\n-\n-        // See https://github.com/rust-lang/rust/issues/32354\n-        use NameBindingKind::Import;\n-        let import = match (&new_binding.kind, &old_binding.kind) {\n-            // If there are two imports where one or both have attributes then prefer removing the\n-            // import without attributes.\n-            (Import { import: new, .. }, Import { import: old, .. })\n-                if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n-                } =>\n-            {\n-                if old.has_attributes {\n-                    Some((new, new_binding.span, true))\n-                } else {\n-                    Some((old, old_binding.span, true))\n-                }\n-            }\n-            // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n-                Some((import, new_binding.span, other.is_import()))\n-            }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n-                Some((import, old_binding.span, other.is_import()))\n-            }\n-            _ => None,\n-        };\n-\n-        // Check if the target of the use for both bindings is the same.\n-        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n-        let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n-        let from_item =\n-            self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n-        // Only suggest removing an import if both bindings are to the same def, if both spans\n-        // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n-        // been introduced by an item.\n-        let should_remove_import = duplicate\n-            && !has_dummy_span\n-            && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n-\n-        match import {\n-            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n-                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n-            }\n-            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n-                // Simple case - remove the entire import. Due to the above match arm, this can\n-                // only be a single use so just remove it entirely.\n-                err.tool_only_span_suggestion(\n-                    import.use_span_with_attributes,\n-                    \"remove unnecessary import\",\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            Some((import, span, _)) => {\n-                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n-            }\n-            _ => {}\n-        }\n-\n-        err.emit();\n-        self.name_already_seen.insert(name, span);\n-    }\n-\n-    /// This function adds a suggestion to change the binding name of a new import that conflicts\n-    /// with an existing import.\n-    ///\n-    /// ```text,ignore (diagnostic)\n-    /// help: you can use `as` to change the binding name of the import\n-    ///    |\n-    /// LL | use foo::bar as other_bar;\n-    ///    |     ^^^^^^^^^^^^^^^^^^^^^\n-    /// ```\n-    fn add_suggestion_for_rename_of_use(\n-        &self,\n-        err: &mut Diagnostic,\n-        name: Symbol,\n-        import: &Import<'_>,\n-        binding_span: Span,\n-    ) {\n-        let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n-            format!(\"Other{}\", name)\n-        } else {\n-            format!(\"other_{}\", name)\n-        };\n-\n-        let mut suggestion = None;\n-        match import.kind {\n-            ImportKind::Single { type_ns_only: true, .. } => {\n-                suggestion = Some(format!(\"self as {}\", suggested_name))\n-            }\n-            ImportKind::Single { source, .. } => {\n-                if let Some(pos) =\n-                    source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n-                {\n-                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n-                        if pos <= snippet.len() {\n-                            suggestion = Some(format!(\n-                                \"{} as {}{}\",\n-                                &snippet[..pos],\n-                                suggested_name,\n-                                if snippet.ends_with(';') { \";\" } else { \"\" }\n-                            ))\n-                        }\n-                    }\n-                }\n-            }\n-            ImportKind::ExternCrate { source, target } => {\n-                suggestion = Some(format!(\n-                    \"extern crate {} as {};\",\n-                    source.unwrap_or(target.name),\n-                    suggested_name,\n-                ))\n-            }\n-            _ => unreachable!(),\n-        }\n-\n-        let rename_msg = \"you can use `as` to change the binding name of the import\";\n-        if let Some(suggestion) = suggestion {\n-            err.span_suggestion(\n-                binding_span,\n-                rename_msg,\n-                suggestion,\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            err.span_label(binding_span, rename_msg);\n-        }\n-    }\n-\n-    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n-    /// nested. In the following example, this function will be invoked to remove the `a` binding\n-    /// in the second use statement:\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// use issue_52891::a;\n-    /// use issue_52891::{d, a, e};\n-    /// ```\n-    ///\n-    /// The following suggestion will be added:\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// use issue_52891::{d, a, e};\n-    ///                      ^-- help: remove unnecessary import\n-    /// ```\n-    ///\n-    /// If the nested use contains only one import then the suggestion will remove the entire\n-    /// line.\n-    ///\n-    /// It is expected that the provided import is nested - this isn't checked by the\n-    /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n-    /// as characters expected by span manipulations won't be present.\n-    fn add_suggestion_for_duplicate_nested_use(\n-        &self,\n-        err: &mut Diagnostic,\n-        import: &Import<'_>,\n-        binding_span: Span,\n-    ) {\n-        assert!(import.is_nested());\n-        let message = \"remove unnecessary import\";\n-\n-        // Two examples will be used to illustrate the span manipulations we're doing:\n-        //\n-        // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n-        // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n-\n-        let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n-\n-        // If there was a closing brace then identify the span to remove any trailing commas from\n-        // previous imports.\n-        if found_closing_brace {\n-            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n-                err.tool_only_span_suggestion(\n-                    span,\n-                    message,\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                // Remove the entire line if we cannot extend the span back, this indicates an\n-                // `issue_52891::{self}` case.\n-                err.span_suggestion(\n-                    import.use_span_with_attributes,\n-                    message,\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            return;\n-        }\n-\n-        err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n-    }\n-\n     fn extern_prelude_get(&mut self, ident: Ident, finalize: bool) -> Option<&'a NameBinding<'a>> {\n         if ident.is_path_segment_keyword() {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n@@ -3289,12 +1823,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let module = self.expect_module(module_id);\n-        match self.resolve_path(\n-            &segments,\n-            Some(ns),\n-            &ParentScope::module(module, self),\n-            Finalize::No,\n-        ) {\n+        match self.maybe_resolve_path(&segments, Some(ns), &ParentScope::module(module, self)) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                 Some(path_res.base_res())\n@@ -3384,12 +1913,11 @@ impl<'a> Resolver<'a> {\n         let ident = Ident::with_dummy_span(sym::main);\n         let parent_scope = &ParentScope::module(module, self);\n \n-        let Ok(name_binding) = self.resolve_ident_in_module(\n+        let Ok(name_binding) = self.maybe_resolve_ident_in_module(\n             ModuleOrUniformRoot::Module(module),\n             ident,\n             ValueNS,\n             parent_scope,\n-            None\n         ) else {\n             return;\n         };"}, {"sha": "01f0b11f1ac3beb0030649a55e360f50bb7d09c9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 19, "deletions": 364, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -3,9 +3,9 @@\n \n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n-use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n-use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n+use crate::{BuiltinMacroState, Determinacy};\n+use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n+use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n@@ -18,14 +18,11 @@ use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, Resolver\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, Invocation, InvocationKind, SupportsMacroExpansion};\n-use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{CrateNum, LocalDefId};\n-use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::{self, RegisteredTools};\n-use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, PROC_MACRO_DERIVE_RESOLUTION_FALLBACK};\n-use rustc_session::lint::builtin::{SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_middle::ty::RegisteredTools;\n+use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE, UNUSED_MACROS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -35,7 +32,7 @@ use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n-use std::{mem, ptr};\n+use std::mem;\n \n type Res = def::Res<NodeId>;\n \n@@ -73,10 +70,10 @@ pub enum MacroRulesScope<'a> {\n /// in a module (including derives) and hurt performance.\n pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>;\n \n-// Macro namespace is separated into two sub-namespaces, one for bang macros and\n-// one for attribute-like macros (attributes, derives).\n-// We ignore resolutions from one sub-namespace when searching names in scope for another.\n-fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n+/// Macro namespace is separated into two sub-namespaces, one for bang macros and\n+/// one for attribute-like macros (attributes, derives).\n+/// We ignore resolutions from one sub-namespace when searching names in scope for another.\n+crate fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS {\n         Bang,\n@@ -415,7 +412,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         let mut indeterminate = false;\n         for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n-            match self.resolve_path(path, Some(ns), &parent_scope, Finalize::No) {\n+            match self.maybe_resolve_path(path, Some(ns), &parent_scope) {\n                 PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n                 PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n                     return Ok(true);\n@@ -575,7 +572,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let res = if path.len() > 1 {\n-            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, Finalize::No) {\n+            let res = match self.maybe_resolve_path(&path, Some(MacroNS), parent_scope) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     Ok(path_res.base_res())\n                 }\n@@ -607,6 +604,8 @@ impl<'a> Resolver<'a> {\n                 parent_scope,\n                 None,\n                 force,\n+                false,\n+                None,\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n                 return Err(Determinacy::Undetermined);\n@@ -630,355 +629,6 @@ impl<'a> Resolver<'a> {\n         res.map(|res| (self.get_macro(res), res))\n     }\n \n-    // Resolve an identifier in lexical scope.\n-    // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n-    // expansion and import resolution (perhaps they can be merged in the future).\n-    // The function is used for resolving initial segments of macro paths (e.g., `foo` in\n-    // `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n-    crate fn early_resolve_ident_in_lexical_scope(\n-        &mut self,\n-        orig_ident: Ident,\n-        scope_set: ScopeSet<'a>,\n-        parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-        force: bool,\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        bitflags::bitflags! {\n-            struct Flags: u8 {\n-                const MACRO_RULES          = 1 << 0;\n-                const MODULE               = 1 << 1;\n-                const MISC_SUGGEST_CRATE   = 1 << 2;\n-                const MISC_SUGGEST_SELF    = 1 << 3;\n-                const MISC_FROM_PRELUDE    = 1 << 4;\n-            }\n-        }\n-\n-        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n-\n-        // Make sure `self`, `super` etc produce an error when passed to here.\n-        if orig_ident.is_path_segment_keyword() {\n-            return Err(Determinacy::Determined);\n-        }\n-\n-        let (ns, macro_kind, is_import) = match scope_set {\n-            ScopeSet::All(ns, is_import) => (ns, None, is_import),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n-            ScopeSet::Late(ns, ..) => (ns, None, false),\n-        };\n-\n-        // This is *the* result, resolution from the scope closest to the resolved identifier.\n-        // However, sometimes this result is \"weak\" because it comes from a glob import or\n-        // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n-        // mod m { ... } // solution in outer scope\n-        // {\n-        //     use prefix::*; // imports another `m` - innermost solution\n-        //                    // weak, cannot shadow the outer `m`, need to report ambiguity error\n-        //     m::mac!();\n-        // }\n-        // So we have to save the innermost solution and continue searching in outer scopes\n-        // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n-        let mut determinacy = Determinacy::Determined;\n-\n-        // Go through all the scopes and try to resolve the name.\n-        let break_result = self.visit_scopes(\n-            scope_set,\n-            parent_scope,\n-            orig_ident.span.ctxt(),\n-            |this, scope, use_prelude, ctxt| {\n-                let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n-                let ok = |res, span, arenas| {\n-                    Ok((\n-                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n-                            .to_name_binding(arenas),\n-                        Flags::empty(),\n-                    ))\n-                };\n-                let result = match scope {\n-                    Scope::DeriveHelpers(expn_id) => {\n-                        if let Some(attr) = this\n-                            .helper_attrs\n-                            .get(&expn_id)\n-                            .and_then(|attrs| attrs.iter().rfind(|i| ident == **i))\n-                        {\n-                            let binding = (\n-                                Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                ty::Visibility::Public,\n-                                attr.span,\n-                                expn_id,\n-                            )\n-                                .to_name_binding(this.arenas);\n-                            Ok((binding, Flags::empty()))\n-                        } else {\n-                            Err(Determinacy::Determined)\n-                        }\n-                    }\n-                    Scope::DeriveHelpersCompat => {\n-                        let mut result = Err(Determinacy::Determined);\n-                        for derive in parent_scope.derives {\n-                            let parent_scope = &ParentScope { derives: &[], ..*parent_scope };\n-                            match this.resolve_macro_path(\n-                                derive,\n-                                Some(MacroKind::Derive),\n-                                parent_scope,\n-                                true,\n-                                force,\n-                            ) {\n-                                Ok((Some(ext), _)) => {\n-                                    if ext.helper_attrs.contains(&ident.name) {\n-                                        result = ok(\n-                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n-                                            derive.span,\n-                                            this.arenas,\n-                                        );\n-                                        break;\n-                                    }\n-                                }\n-                                Ok(_) | Err(Determinacy::Determined) => {}\n-                                Err(Determinacy::Undetermined) => {\n-                                    result = Err(Determinacy::Undetermined)\n-                                }\n-                            }\n-                        }\n-                        result\n-                    }\n-                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope.get() {\n-                        MacroRulesScope::Binding(macro_rules_binding)\n-                            if ident == macro_rules_binding.ident =>\n-                        {\n-                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n-                        }\n-                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n-                        _ => Err(Determinacy::Determined),\n-                    },\n-                    Scope::CrateRoot => {\n-                        let root_ident = Ident::new(kw::PathRoot, ident.span);\n-                        let root_module = this.resolve_crate_root(root_ident);\n-                        let binding = this.resolve_ident_in_module_ext(\n-                            ModuleOrUniformRoot::Module(root_module),\n-                            ident,\n-                            ns,\n-                            parent_scope,\n-                            finalize,\n-                        );\n-                        match binding {\n-                            Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n-                            Err((Determinacy::Undetermined, Weak::No)) => {\n-                                return Some(Err(Determinacy::determined(force)));\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n-                                Err(Determinacy::Undetermined)\n-                            }\n-                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n-                        }\n-                    }\n-                    Scope::Module(module, derive_fallback_lint_id) => {\n-                        let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n-                        let binding = this.resolve_ident_in_module_unadjusted_ext(\n-                            ModuleOrUniformRoot::Module(module),\n-                            ident,\n-                            ns,\n-                            adjusted_parent_scope,\n-                            !matches!(scope_set, ScopeSet::Late(..)),\n-                            finalize,\n-                        );\n-                        match binding {\n-                            Ok(binding) => {\n-                                if let Some(lint_id) = derive_fallback_lint_id {\n-                                    this.lint_buffer.buffer_lint_with_diagnostic(\n-                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                                        lint_id,\n-                                        orig_ident.span,\n-                                        &format!(\n-                                            \"cannot find {} `{}` in this scope\",\n-                                            ns.descr(),\n-                                            ident\n-                                        ),\n-                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n-                                            orig_ident.span,\n-                                        ),\n-                                    );\n-                                }\n-                                let misc_flags = if ptr::eq(module, this.graph_root) {\n-                                    Flags::MISC_SUGGEST_CRATE\n-                                } else if module.is_normal() {\n-                                    Flags::MISC_SUGGEST_SELF\n-                                } else {\n-                                    Flags::empty()\n-                                };\n-                                Ok((binding, Flags::MODULE | misc_flags))\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::No)) => {\n-                                return Some(Err(Determinacy::determined(force)));\n-                            }\n-                            Err((Determinacy::Undetermined, Weak::Yes)) => {\n-                                Err(Determinacy::Undetermined)\n-                            }\n-                            Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n-                        }\n-                    }\n-                    Scope::RegisteredAttrs => match this.registered_attrs.get(&ident).cloned() {\n-                        Some(ident) => ok(\n-                            Res::NonMacroAttr(NonMacroAttrKind::Registered),\n-                            ident.span,\n-                            this.arenas,\n-                        ),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                    Scope::MacroUsePrelude => {\n-                        match this.macro_use_prelude.get(&ident.name).cloned() {\n-                            Some(binding) => Ok((binding, Flags::MISC_FROM_PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                            )),\n-                        }\n-                    }\n-                    Scope::BuiltinAttrs => {\n-                        if is_builtin_attr_name(ident.name) {\n-                            ok(\n-                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n-                                DUMMY_SP,\n-                                this.arenas,\n-                            )\n-                        } else {\n-                            Err(Determinacy::Determined)\n-                        }\n-                    }\n-                    Scope::ExternPrelude => {\n-                        match this.extern_prelude_get(ident, finalize.is_some()) {\n-                            Some(binding) => Ok((binding, Flags::empty())),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                            )),\n-                        }\n-                    }\n-                    Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n-                        Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                    Scope::StdLibPrelude => {\n-                        let mut result = Err(Determinacy::Determined);\n-                        if let Some(prelude) = this.prelude {\n-                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n-                                ModuleOrUniformRoot::Module(prelude),\n-                                ident,\n-                                ns,\n-                                parent_scope,\n-                                None,\n-                            ) {\n-                                if use_prelude || this.is_builtin_macro(binding.res()) {\n-                                    result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n-                                }\n-                            }\n-                        }\n-                        result\n-                    }\n-                    Scope::BuiltinTypes => match PrimTy::from_name(ident.name) {\n-                        Some(prim_ty) => ok(Res::PrimTy(prim_ty), DUMMY_SP, this.arenas),\n-                        None => Err(Determinacy::Determined),\n-                    },\n-                };\n-\n-                match result {\n-                    Ok((binding, flags))\n-                        if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n-                    {\n-                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n-                            return Some(Ok(binding));\n-                        }\n-\n-                        if let Some((innermost_binding, innermost_flags)) = innermost_result {\n-                            // Found another solution, if the first one was \"weak\", report an error.\n-                            let (res, innermost_res) = (binding.res(), innermost_binding.res());\n-                            if res != innermost_res {\n-                                let is_builtin = |res| {\n-                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n-                                };\n-                                let derive_helper =\n-                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n-                                let derive_helper_compat =\n-                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n-\n-                                let ambiguity_error_kind = if is_import {\n-                                    Some(AmbiguityKind::Import)\n-                                } else if is_builtin(innermost_res) || is_builtin(res) {\n-                                    Some(AmbiguityKind::BuiltinAttr)\n-                                } else if innermost_res == derive_helper_compat\n-                                    || res == derive_helper_compat && innermost_res != derive_helper\n-                                {\n-                                    Some(AmbiguityKind::DeriveHelper)\n-                                } else if innermost_flags.contains(Flags::MACRO_RULES)\n-                                    && flags.contains(Flags::MODULE)\n-                                    && !this.disambiguate_macro_rules_vs_modularized(\n-                                        innermost_binding,\n-                                        binding,\n-                                    )\n-                                    || flags.contains(Flags::MACRO_RULES)\n-                                        && innermost_flags.contains(Flags::MODULE)\n-                                        && !this.disambiguate_macro_rules_vs_modularized(\n-                                            binding,\n-                                            innermost_binding,\n-                                        )\n-                                {\n-                                    Some(AmbiguityKind::MacroRulesVsModularized)\n-                                } else if innermost_binding.is_glob_import() {\n-                                    Some(AmbiguityKind::GlobVsOuter)\n-                                } else if innermost_binding\n-                                    .may_appear_after(parent_scope.expansion, binding)\n-                                {\n-                                    Some(AmbiguityKind::MoreExpandedVsOuter)\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(kind) = ambiguity_error_kind {\n-                                    let misc = |f: Flags| {\n-                                        if f.contains(Flags::MISC_SUGGEST_CRATE) {\n-                                            AmbiguityErrorMisc::SuggestCrate\n-                                        } else if f.contains(Flags::MISC_SUGGEST_SELF) {\n-                                            AmbiguityErrorMisc::SuggestSelf\n-                                        } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n-                                            AmbiguityErrorMisc::FromPrelude\n-                                        } else {\n-                                            AmbiguityErrorMisc::None\n-                                        }\n-                                    };\n-                                    this.ambiguity_errors.push(AmbiguityError {\n-                                        kind,\n-                                        ident: orig_ident,\n-                                        b1: innermost_binding,\n-                                        b2: binding,\n-                                        misc1: misc(innermost_flags),\n-                                        misc2: misc(flags),\n-                                    });\n-                                    return Some(Ok(innermost_binding));\n-                                }\n-                            }\n-                        } else {\n-                            // Found the first solution.\n-                            innermost_result = Some((binding, flags));\n-                        }\n-                    }\n-                    Ok(..) | Err(Determinacy::Determined) => {}\n-                    Err(Determinacy::Undetermined) => determinacy = Determinacy::Undetermined,\n-                }\n-\n-                None\n-            },\n-        );\n-\n-        if let Some(break_result) = break_result {\n-            return break_result;\n-        }\n-\n-        // The first found solution was the only one, return it.\n-        if let Some((binding, _)) = innermost_result {\n-            return Ok(binding);\n-        }\n-\n-        Err(Determinacy::determined(determinacy == Determinacy::Determined || force))\n-    }\n-\n     crate fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self,\n                                  path: &[Segment],\n@@ -1024,6 +674,7 @@ impl<'a> Resolver<'a> {\n                 Some(MacroNS),\n                 &parent_scope,\n                 Finalize::SimplePath(ast::CRATE_NODE_ID, path_span),\n+                None,\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n@@ -1059,6 +710,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 Some(ident.span),\n                 true,\n+                false,\n+                None,\n             ) {\n                 Ok(binding) => {\n                     let initial_res = initial_binding.map(|initial_binding| {\n@@ -1100,6 +753,8 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 Some(ident.span),\n                 true,\n+                false,\n+                None,\n             );\n         }\n     }"}, {"sha": "77a537448291719a0966c6435cb68f45c95ed087", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -7,6 +7,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, ImplPolarity, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_session::lint;\n@@ -141,13 +142,56 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGua\n         }\n     }\n \n-    if let ty::Opaque(def_id, _) = *trait_ref.self_ty().kind() {\n-        let reported = tcx\n-            .sess\n-            .struct_span_err(sp, \"cannot implement trait on type alias impl trait\")\n-            .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-            .emit();\n-        return Err(reported);\n+    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n+    // and #84660 where it would otherwise allow unsoundness.\n+    if trait_ref.has_opaque_types() {\n+        trace!(\"{:#?}\", item);\n+        // First we find the opaque type in question.\n+        for ty in trait_ref.substs {\n+            for ty in ty.walk() {\n+                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n+                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n+                trace!(?def_id);\n+\n+                // Then we search for mentions of the opaque type's type alias in the HIR\n+                struct SpanFinder<'tcx> {\n+                    sp: Span,\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n+                    #[instrument(level = \"trace\", skip(self, _id))]\n+                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n+                        // You can't mention an opaque type directly, so we look for type aliases\n+                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n+                            // And check if that type alias's type contains the opaque type we're looking for\n+                            for arg in self.tcx.type_of(def_id).walk() {\n+                                if let GenericArgKind::Type(ty) = arg.unpack() {\n+                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n+                                        if def_id == self.def_id {\n+                                            // Finally we update the span to the mention of the type alias\n+                                            self.sp = path.span;\n+                                            return;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        hir::intravisit::walk_path(self, path)\n+                    }\n+                }\n+\n+                let mut visitor = SpanFinder { sp, def_id, tcx };\n+                hir::intravisit::walk_item(&mut visitor, item);\n+                let reported = tcx\n+                    .sess\n+                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n+                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n+                    .emit();\n+                return Err(reported);\n+            }\n+        }\n+        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n     }\n \n     Ok(())"}, {"sha": "181717f35bd25dd3de4f763b032a624f349b5108", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 74, "deletions": 67, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -3,68 +3,88 @@\n use crate::cmp::Ordering::*;\n use crate::cmp::*;\n \n-// macro for implementing n-ary tuple functions and operations\n+// Recursive macro for implementing n-ary tuple functions and operations\n+//\n+// Also provides implementations for tuples with lesser arity. For example, tuple_impls!(A B C)\n+// will implement everything for (A, B, C), (A, B) and (A,).\n macro_rules! tuple_impls {\n-    ( $( ( $( $T:ident )+ ) )+ ) => {\n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n-                }\n-                #[inline]\n-                fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $( ${ignore(T)} self.${index()} != other.${index()} )||+\n-                }\n+    // Stopping criteria (1-ary tuple)\n+    ($T:ident) => {\n+        tuple_impls!(@impl $T);\n+    };\n+    // Running criteria (n-ary tuple, with n >= 2)\n+    ($T:ident $( $U:ident )+) => {\n+        tuple_impls!($( $U )+);\n+        tuple_impls!(@impl $T $( $U )+);\n+    };\n+    // \"Private\" internal implementation\n+    (@impl $( $T:ident )+) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {\n+            #[inline]\n+            fn eq(&self, other: &($($T,)+)) -> bool {\n+                $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n+            }\n+            #[inline]\n+            fn ne(&self, other: &($($T,)+)) -> bool {\n+                $( ${ignore(T)} self.${index()} != other.${index()} )||+\n             }\n+        }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Eq),+> Eq for ($($T,)+) where last_type!($($T,)+): ?Sized {}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:Eq),+> Eq for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {}\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n-            where\n-                last_type!($($T,)+): ?Sized\n-            {\n-                #[inline]\n-                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                    lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n-                #[inline]\n-                fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {\n+            #[inline]\n+            fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+            #[inline]\n+            fn lt(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(lt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+            #[inline]\n+            fn le(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(le, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n             }\n+            #[inline]\n+            fn ge(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(ge, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+            #[inline]\n+            fn gt(&self, other: &($($T,)+)) -> bool {\n+                lexical_ord!(gt, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n+            }\n+        }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Ord),+> Ord for ($($T,)+) where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n-                }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:Ord),+> Ord for ($($T,)+)\n+        where\n+            last_type!($($T,)+): ?Sized\n+        {\n+            #[inline]\n+            fn cmp(&self, other: &($($T,)+)) -> Ordering {\n+                lexical_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n             }\n+        }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[inline]\n-                fn default() -> ($($T,)+) {\n-                    ($({ let x: $T = Default::default(); x},)+)\n-                }\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<$($T:Default),+> Default for ($($T,)+) {\n+            #[inline]\n+            fn default() -> ($($T,)+) {\n+                ($({ let x: $T = Default::default(); x},)+)\n             }\n-        )+\n+        }\n     }\n }\n \n@@ -105,17 +125,4 @@ macro_rules! last_type {\n     ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n }\n \n-tuple_impls! {\n-    (A)\n-    (A B)\n-    (A B C)\n-    (A B C D)\n-    (A B C D E)\n-    (A B C D E F)\n-    (A B C D E F G)\n-    (A B C D E F G H)\n-    (A B C D E F G H I)\n-    (A B C D E F G H I J)\n-    (A B C D E F G H I J K)\n-    (A B C D E F G H I J K L)\n-}\n+tuple_impls!(A B C D E F G H I J K L);"}, {"sha": "33db6583125efbc9d03ecf9fea4a9244042d72a3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -79,7 +79,7 @@ crate fn try_inline(\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, ItemType::Typedef);\n             build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n-            clean::TypedefItem(build_type_alias(cx, did), false)\n+            clean::TypedefItem(build_type_alias(cx, did))\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, ItemType::Enum);"}, {"sha": "a6763d2827cec0fc486919126d422ac006d8a83c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -964,11 +964,11 @@ impl Clean<Item> for hir::TraitItem<'_> {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n-                hir::TraitItemKind::Const(ref ty, default) => {\n-                    let default =\n-                        default.map(|e| ConstantKind::Local { def_id: local_did, body: e });\n-                    AssocConstItem(ty.clean(cx), default)\n-                }\n+                hir::TraitItemKind::Const(ref ty, Some(default)) => AssocConstItem(\n+                    ty.clean(cx),\n+                    ConstantKind::Local { def_id: local_did, body: default },\n+                ),\n+                hir::TraitItemKind::Const(ref ty, None) => TyAssocConstItem(ty.clean(cx)),\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                     let m = clean_function(cx, sig, &self.generics, body);\n                     MethodItem(m, None)\n@@ -983,11 +983,19 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     });\n                     TyMethodItem(Function { decl, generics })\n                 }\n-                hir::TraitItemKind::Type(bounds, ref default) => {\n+                hir::TraitItemKind::Type(bounds, Some(default)) => {\n+                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n+                    let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n+                    let item_type = hir_ty_to_ty(cx.tcx, default).clean(cx);\n+                    AssocTypeItem(\n+                        Typedef { type_: default.clean(cx), generics, item_type: Some(item_type) },\n+                        bounds,\n+                    )\n+                }\n+                hir::TraitItemKind::Type(bounds, None) => {\n                     let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    let default = default.map(|t| t.clean(cx));\n-                    AssocTypeItem(Box::new(generics), bounds, default)\n+                    TyAssocTypeItem(Box::new(generics), bounds)\n                 }\n             };\n             let what_rustc_thinks =\n@@ -1004,7 +1012,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ref ty, expr) => {\n-                    let default = Some(ConstantKind::Local { def_id: local_did, body: expr });\n+                    let default = ConstantKind::Local { def_id: local_did, body: expr };\n                     AssocConstItem(ty.clean(cx), default)\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n@@ -1016,7 +1024,10 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                     let type_ = hir_ty.clean(cx);\n                     let generics = self.generics.clean(cx);\n                     let item_type = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                    TypedefItem(Typedef { type_, generics, item_type: Some(item_type) }, true)\n+                    AssocTypeItem(\n+                        Typedef { type_, generics, item_type: Some(item_type) },\n+                        Vec::new(),\n+                    )\n                 }\n             };\n \n@@ -1041,13 +1052,17 @@ impl Clean<Item> for ty::AssocItem {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n-                let ty = tcx.type_of(self.def_id);\n-                let default = if self.defaultness.has_value() {\n-                    Some(ConstantKind::Extern { def_id: self.def_id })\n-                } else {\n-                    None\n+                let ty = tcx.type_of(self.def_id).clean(cx);\n+\n+                let provided = match self.container {\n+                    ty::ImplContainer(_) => true,\n+                    ty::TraitContainer(_) => self.defaultness.has_value(),\n                 };\n-                AssocConstItem(ty.clean(cx), default)\n+                if provided {\n+                    AssocConstItem(ty, ConstantKind::Extern { def_id: self.def_id })\n+                } else {\n+                    TyAssocConstItem(ty)\n+                }\n             }\n             ty::AssocKind::Fn => {\n                 let generics = clean_ty_generics(\n@@ -1181,23 +1196,28 @@ impl Clean<Item> for ty::AssocItem {\n                         None => bounds.push(GenericBound::maybe_sized(cx)),\n                     }\n \n-                    let ty = if self.defaultness.has_value() {\n-                        Some(tcx.type_of(self.def_id))\n+                    if self.defaultness.has_value() {\n+                        AssocTypeItem(\n+                            Typedef {\n+                                type_: tcx.type_of(self.def_id).clean(cx),\n+                                generics,\n+                                // FIXME: should we obtain the Type from HIR and pass it on here?\n+                                item_type: None,\n+                            },\n+                            bounds,\n+                        )\n                     } else {\n-                        None\n-                    };\n-\n-                    AssocTypeItem(Box::new(generics), bounds, ty.map(|t| t.clean(cx)))\n+                        TyAssocTypeItem(Box::new(generics), bounds)\n+                    }\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n-                    let type_ = tcx.type_of(self.def_id).clean(cx);\n-                    TypedefItem(\n+                    AssocTypeItem(\n                         Typedef {\n-                            type_,\n+                            type_: tcx.type_of(self.def_id).clean(cx),\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n                             item_type: None,\n                         },\n-                        true,\n+                        Vec::new(),\n                     )\n                 }\n             }\n@@ -1837,14 +1857,11 @@ fn clean_maybe_renamed_item(\n             ItemKind::TyAlias(hir_ty, ref generics) => {\n                 let rustdoc_ty = hir_ty.clean(cx);\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                TypedefItem(\n-                    Typedef {\n-                        type_: rustdoc_ty,\n-                        generics: generics.clean(cx),\n-                        item_type: Some(ty),\n-                    },\n-                    false,\n-                )\n+                TypedefItem(Typedef {\n+                    type_: rustdoc_ty,\n+                    generics: generics.clean(cx),\n+                    item_type: Some(ty),\n+                })\n             }\n             ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),"}, {"sha": "d2abfc35b932cfa1f3e6be1ef946ec737b985cb4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -577,10 +577,16 @@ impl Item {\n         self.type_() == ItemType::Variant\n     }\n     crate fn is_associated_type(&self) -> bool {\n-        self.type_() == ItemType::AssocType\n+        matches!(&*self.kind, AssocTypeItem(..) | StrippedItem(box AssocTypeItem(..)))\n+    }\n+    crate fn is_ty_associated_type(&self) -> bool {\n+        matches!(&*self.kind, TyAssocTypeItem(..) | StrippedItem(box TyAssocTypeItem(..)))\n     }\n     crate fn is_associated_const(&self) -> bool {\n-        self.type_() == ItemType::AssocConst\n+        matches!(&*self.kind, AssocConstItem(..) | StrippedItem(box AssocConstItem(..)))\n+    }\n+    crate fn is_ty_associated_const(&self) -> bool {\n+        matches!(&*self.kind, TyAssocConstItem(..) | StrippedItem(box TyAssocConstItem(..)))\n     }\n     crate fn is_method(&self) -> bool {\n         self.type_() == ItemType::Method\n@@ -726,17 +732,18 @@ crate enum ItemKind {\n     EnumItem(Enum),\n     FunctionItem(Function),\n     ModuleItem(Module),\n-    TypedefItem(Typedef, bool /* is associated type */),\n+    TypedefItem(Typedef),\n     OpaqueTyItem(OpaqueTy),\n     StaticItem(Static),\n     ConstantItem(Constant),\n     TraitItem(Trait),\n     TraitAliasItem(TraitAlias),\n     ImplItem(Impl),\n-    /// A method signature only. Used for required methods in traits (ie,\n-    /// non-default-methods).\n+    /// A required method in a trait declaration meaning it's only a function signature.\n     TyMethodItem(Function),\n-    /// A method with a body.\n+    /// A method in a trait impl or a provided method in a trait declaration.\n+    ///\n+    /// Compared to [TyMethodItem], it also contains a method body.\n     MethodItem(Function, Option<hir::Defaultness>),\n     StructFieldItem(Type),\n     VariantItem(Variant),\n@@ -749,12 +756,16 @@ crate enum ItemKind {\n     MacroItem(Macro),\n     ProcMacroItem(ProcMacro),\n     PrimitiveItem(PrimitiveType),\n-    AssocConstItem(Type, Option<ConstantKind>),\n-    /// An associated item in a trait or trait impl.\n+    /// A required associated constant in a trait declaration.\n+    TyAssocConstItem(Type),\n+    /// An associated associated constant in a trait impl or a provided one in a trait declaration.\n+    AssocConstItem(Type, ConstantKind),\n+    /// A required associated type in a trait declaration.\n     ///\n     /// The bounds may be non-empty if there is a `where` clause.\n-    /// The `Option<Type>` is the default concrete type (e.g. `trait Trait { type Target = usize; }`)\n-    AssocTypeItem(Box<Generics>, Vec<GenericBound>, Option<Type>),\n+    TyAssocTypeItem(Box<Generics>, Vec<GenericBound>),\n+    /// An associated type in a trait impl or a provided one in a trait declaration.\n+    AssocTypeItem(Typedef, Vec<GenericBound>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemKind>),\n     KeywordItem(Symbol),\n@@ -776,7 +787,7 @@ impl ItemKind {\n             ExternCrateItem { .. }\n             | ImportItem(_)\n             | FunctionItem(_)\n-            | TypedefItem(_, _)\n+            | TypedefItem(_)\n             | OpaqueTyItem(_)\n             | StaticItem(_)\n             | ConstantItem(_)\n@@ -791,7 +802,9 @@ impl ItemKind {\n             | MacroItem(_)\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n+            | TyAssocConstItem(_)\n             | AssocConstItem(_, _)\n+            | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | StrippedItem(_)\n             | KeywordItem(_) => [].iter(),"}, {"sha": "fe6d680991f80f3e6652cf532a7fb4f065907ae6", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -178,7 +178,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n \n     for item in items {\n         let target = match *item.kind {\n-            ItemKind::TypedefItem(ref t, true) => &t.type_,\n+            ItemKind::AssocTypeItem(ref t, _) => &t.type_,\n             _ => continue,\n         };\n "}, {"sha": "95adc4426b585a1edb791d1bcecf6223aff768bd", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -71,7 +71,7 @@ crate trait DocFolder: Sized {\n             ExternCrateItem { src: _ }\n             | ImportItem(_)\n             | FunctionItem(_)\n-            | TypedefItem(_, _)\n+            | TypedefItem(_)\n             | OpaqueTyItem(_)\n             | StaticItem(_)\n             | ConstantItem(_)\n@@ -85,7 +85,9 @@ crate trait DocFolder: Sized {\n             | MacroItem(_)\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n-            | AssocConstItem(_, _)\n+            | TyAssocConstItem(..)\n+            | AssocConstItem(..)\n+            | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | KeywordItem(_) => kind,\n         }"}, {"sha": "663e18fe9129fd594ebae6885b74ee88b7f25e0d", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -242,14 +242,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         if let Some(ref s) = item.name {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n+                clean::AssocConstItem(..) | clean::AssocTypeItem(..)\n                     if self.cache.parent_is_trait_impl =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n                 }\n-                clean::AssocTypeItem(..)\n-                | clean::TyMethodItem(..)\n+                clean::TyMethodItem(..)\n+                | clean::TyAssocConstItem(..)\n+                | clean::TyAssocTypeItem(..)\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n@@ -258,7 +259,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     ),\n                     false,\n                 ),\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                clean::MethodItem(..) | clean::AssocConstItem(..) | clean::AssocTypeItem(..) => {\n                     if self.cache.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n@@ -373,7 +374,9 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::TyMethodItem(..)\n             | clean::MethodItem(..)\n             | clean::StructFieldItem(..)\n+            | clean::TyAssocConstItem(..)\n             | clean::AssocConstItem(..)\n+            | clean::TyAssocTypeItem(..)\n             | clean::AssocTypeItem(..)\n             | clean::StrippedItem(..)\n             | clean::KeywordItem(..) => {"}, {"sha": "fb4afb769ad15697ced9f1513db320bc65d13a39", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -14,7 +14,7 @@ use crate::clean;\n /// The search index uses item types encoded as smaller numbers which equal to\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n-/// the `itemTypes` mapping table in `html/static/main.js`.\n+/// the `itemTypes` mapping table in `html/static/js/search.js`.\n ///\n /// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n@@ -89,8 +89,8 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::ForeignStaticItem(..) => ItemType::Static,     // no ForeignStatic\n             clean::MacroItem(..) => ItemType::Macro,\n             clean::PrimitiveItem(..) => ItemType::Primitive,\n-            clean::AssocConstItem(..) => ItemType::AssocConst,\n-            clean::AssocTypeItem(..) => ItemType::AssocType,\n+            clean::TyAssocConstItem(..) | clean::AssocConstItem(..) => ItemType::AssocConst,\n+            clean::TyAssocTypeItem(..) | clean::AssocTypeItem(..) => ItemType::AssocType,\n             clean::ForeignTypeItem => ItemType::ForeignType,\n             clean::KeywordItem(..) => ItemType::Keyword,\n             clean::TraitAliasItem(..) => ItemType::TraitAlias,"}, {"sha": "55b0028180f66fece8164bb2f1c903a36154e7c4", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -527,6 +527,21 @@ crate enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///\n     /// This can only happen for non-local items.\n+    ///\n+    /// # Example\n+    ///\n+    /// Crate `a` defines a public trait and crate `b` \u2013 the target crate that depends on `a` \u2013\n+    /// implements it for a local type.\n+    /// We document `b` but **not** `a` (we only _build_ the latter \u2013 with `rustc`):\n+    ///\n+    /// ```sh\n+    /// rustc a.rs --crate-type=lib\n+    /// rustdoc b.rs --crate-type=lib --extern=a=liba.rlib\n+    /// ```\n+    ///\n+    /// Now, the associated items in the trait impl want to link to the corresponding item in the\n+    /// trait declaration (see `html::render::assoc_href_attr`) but it's not available since their\n+    /// *documentation (was) not built*.\n     DocumentationNotBuilt,\n     /// This can only happen for non-local items when `--document-private-items` is not passed.\n     Private,"}, {"sha": "1ebb41b5933d0b0350165494ce61bbe4198cd7d9", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1452,8 +1452,10 @@ fn init_id_map() -> FxHashMap<String, usize> {\n     map.insert(\"trait-implementations\".to_owned(), 1);\n     map.insert(\"synthetic-implementations\".to_owned(), 1);\n     map.insert(\"blanket-implementations\".to_owned(), 1);\n-    map.insert(\"associated-types\".to_owned(), 1);\n-    map.insert(\"associated-const\".to_owned(), 1);\n+    map.insert(\"required-associated-types\".to_owned(), 1);\n+    map.insert(\"provided-associated-types\".to_owned(), 1);\n+    map.insert(\"provided-associated-consts\".to_owned(), 1);\n+    map.insert(\"required-associated-consts\".to_owned(), 1);\n     map.insert(\"required-methods\".to_owned(), 1);\n     map.insert(\"provided-methods\".to_owned(), 1);\n     map.insert(\"implementors\".to_owned(), 1);"}, {"sha": "9891c4b676fb4d2e32bea23619bed94b2ad05261", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 157, "deletions": 90, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -521,7 +521,7 @@ fn document_short(\n         let mut summary_html = MarkdownSummaryLine(&s, &item.links(cx)).into_string();\n \n         if s.contains('\\n') {\n-            let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx));\n+            let link = format!(r#\" <a{}>Read more</a>\"#, assoc_href_attr(item, link, cx));\n \n             if let Some(idx) = summary_html.rfind(\"</p>\") {\n                 summary_html.insert_str(idx, &link);\n@@ -737,42 +737,82 @@ fn render_impls(\n     w.write_str(&rendered_impls.join(\"\"));\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n-    use crate::formats::item_type::ItemType::*;\n+/// Build a (possibly empty) `href` attribute (a key-value pair) for the given associated item.\n+fn assoc_href_attr(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n+    let name = it.name.unwrap();\n+    let item_type = it.type_();\n \n-    let name = it.name.as_ref().unwrap();\n-    let ty = match it.type_() {\n-        Typedef | AssocType => AssocType,\n-        s => s,\n-    };\n+    let href = match link {\n+        AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n+        AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", item_type, name)),\n+        AssocItemLink::GotoSource(did, provided_methods) => {\n+            // We're creating a link from the implementation of an associated item to its\n+            // declaration in the trait declaration.\n+            let item_type = match item_type {\n+                // For historical but not technical reasons, the item type of methods in\n+                // trait declarations depends on whether the method is required (`TyMethod`) or\n+                // provided (`Method`).\n+                ItemType::Method | ItemType::TyMethod => {\n+                    if provided_methods.contains(&name) {\n+                        ItemType::Method\n+                    } else {\n+                        ItemType::TyMethod\n+                    }\n+                }\n+                // For associated types and constants, no such distinction exists.\n+                item_type => item_type,\n+            };\n \n-    let anchor = format!(\"#{}.{}\", ty, name);\n-    match link {\n-        AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n-        AssocItemLink::Anchor(None) => anchor,\n-        AssocItemLink::GotoSource(did, _) => {\n-            href(did.expect_def_id(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            match href(did.expect_def_id(), cx) {\n+                Ok((url, ..)) => Some(format!(\"{}#{}.{}\", url, item_type, name)),\n+                // The link is broken since it points to an external crate that wasn't documented.\n+                // Do not create any link in such case. This is better than falling back to a\n+                // dummy anchor like `#{item_type}.{name}` representing the `id` of *this* impl item\n+                // (that used to happen in older versions). Indeed, in most cases this dummy would\n+                // coincide with the `id`. However, it would not always do so.\n+                // In general, this dummy would be incorrect:\n+                // If the type with the trait impl also had an inherent impl with an assoc. item of\n+                // the *same* name as this impl item, the dummy would link to that one even though\n+                // those two items are distinct!\n+                // In this scenario, the actual `id` of this impl item would be\n+                // `#{item_type}.{name}-{n}` for some number `n` (a disambiguator).\n+                Err(HrefError::DocumentationNotBuilt) => None,\n+                Err(_) => Some(format!(\"#{}.{}\", item_type, name)),\n+            }\n         }\n-    }\n+    };\n+\n+    // If there is no `href` for the reason explained above, simply do not render it which is valid:\n+    // https://html.spec.whatwg.org/multipage/links.html#links-created-by-a-and-area-elements\n+    href.map(|href| format!(\" href=\\\"{}\\\"\", href)).unwrap_or_default()\n }\n \n fn assoc_const(\n     w: &mut Buffer,\n     it: &clean::Item,\n     ty: &clean::Type,\n+    default: Option<&clean::ConstantKind>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n     write!(\n         w,\n-        \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\">{}</a>: {}\",\n-        extra,\n-        it.visibility.print_with_space(it.def_id, cx),\n-        naive_assoc_href(it, link, cx),\n-        it.name.as_ref().unwrap(),\n-        ty.print(cx)\n+        \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n+        extra = extra,\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n+        href = assoc_href_attr(it, link, cx),\n+        name = it.name.as_ref().unwrap(),\n+        ty = ty.print(cx),\n     );\n+    if let Some(default) = default {\n+        // FIXME: `.value()` uses `clean::utils::format_integer_with_underscore_sep` under the\n+        //        hood which adds noisy underscores and a type suffix to number literals.\n+        //        This hurts readability in this context especially when more complex expressions\n+        //        are involved and it doesn't add much of value.\n+        //        Find a way to print constants here without all that jazz.\n+        write!(w, \" = {}\", default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx())));\n+    }\n }\n \n fn assoc_type(\n@@ -787,9 +827,9 @@ fn assoc_type(\n ) {\n     write!(\n         w,\n-        \"{indent}type <a href=\\\"{href}\\\" class=\\\"associatedtype\\\">{name}</a>{generics}\",\n+        \"{indent}type <a{href} class=\\\"associatedtype\\\">{name}</a>{generics}\",\n         indent = \" \".repeat(indent),\n-        href = naive_assoc_href(it, link, cx),\n+        href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         generics = generics.print(cx),\n     );\n@@ -814,22 +854,6 @@ fn assoc_method(\n ) {\n     let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let href = match link {\n-        AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n-        AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n-        AssocItemLink::GotoSource(did, provided_methods) => {\n-            // We're creating a link from an impl-item to the corresponding\n-            // trait-item and need to map the anchored type accordingly.\n-            let ty =\n-                if provided_methods.contains(name) { ItemType::Method } else { ItemType::TyMethod };\n-\n-            match (href(did.expect_def_id(), cx), ty) {\n-                (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n-                (Err(HrefError::DocumentationNotBuilt), ItemType::TyMethod) => None,\n-                (Err(_), ty) => Some(format!(\"#{}.{}\", ty, name)),\n-            }\n-        }\n-    };\n     let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n@@ -843,6 +867,7 @@ fn assoc_method(\n     let unsafety = header.unsafety.print_with_space();\n     let defaultness = print_default_space(meth.is_default());\n     let abi = print_abi_with_space(header.abi).to_string();\n+    let href = assoc_href_attr(meth, link, cx);\n \n     // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n     let generics_len = format!(\"{:#}\", g.print(cx)).len();\n@@ -868,7 +893,7 @@ fn assoc_method(\n     w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n     write!(\n         w,\n-        \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n+        \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a{href} class=\\\"fnname\\\">{name}</a>\\\n          {generics}{decl}{notable_traits}{where_clause}\",\n         indent = indent_str,\n         vis = vis,\n@@ -877,8 +902,7 @@ fn assoc_method(\n         unsafety = unsafety,\n         defaultness = defaultness,\n         abi = abi,\n-        // links without a href are valid - https://www.w3schools.com/tags/att_a_href.asp\n-        href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n+        href = href,\n         name = name,\n         generics = g.print(cx),\n         decl = d.full_print(header_len, indent, header.asyncness, cx),\n@@ -968,23 +992,43 @@ fn render_assoc_item(\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n-    match *item.kind {\n+    match &*item.kind {\n         clean::StrippedItem(..) => {}\n-        clean::TyMethodItem(ref m) => {\n+        clean::TyMethodItem(m) => {\n             assoc_method(w, item, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n-        clean::MethodItem(ref m, _) => {\n+        clean::MethodItem(m, _) => {\n             assoc_method(w, item, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n-        clean::AssocConstItem(ref ty, _) => {\n-            assoc_const(w, item, ty, link, if parent == ItemType::Trait { \"    \" } else { \"\" }, cx)\n-        }\n-        clean::AssocTypeItem(ref generics, ref bounds, ref default) => assoc_type(\n+        kind @ (clean::TyAssocConstItem(ty) | clean::AssocConstItem(ty, _)) => assoc_const(\n+            w,\n+            item,\n+            ty,\n+            match kind {\n+                clean::TyAssocConstItem(_) => None,\n+                clean::AssocConstItem(_, default) => Some(default),\n+                _ => unreachable!(),\n+            },\n+            link,\n+            if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            cx,\n+        ),\n+        clean::TyAssocTypeItem(ref generics, ref bounds) => assoc_type(\n             w,\n             item,\n             generics,\n             bounds,\n-            default.as_ref(),\n+            None,\n+            link,\n+            if parent == ItemType::Trait { 4 } else { 0 },\n+            cx,\n+        ),\n+        clean::AssocTypeItem(ref ty, ref bounds) => assoc_type(\n+            w,\n+            item,\n+            &ty.generics,\n+            bounds,\n+            Some(ty.item_type.as_ref().unwrap_or(&ty.type_)),\n             link,\n             if parent == ItemType::Trait { 4 } else { 0 },\n             cx,\n@@ -1205,7 +1249,7 @@ fn render_deref_methods(\n         .items\n         .iter()\n         .find_map(|item| match *item.kind {\n-            clean::TypedefItem(ref t, true) => Some(match *t {\n+            clean::AssocTypeItem(ref t, _) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n             }),\n@@ -1291,7 +1335,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                             impl_.print(false, cx)\n                         );\n                         for it in &impl_.items {\n-                            if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                            if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n                                 out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n                                 let empty_set = FxHashSet::default();\n                                 let src_link =\n@@ -1300,7 +1344,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                                     &mut out,\n                                     it,\n                                     &tydef.generics,\n-                                    &[],\n+                                    &[], // intentionally leaving out bounds\n                                     Some(&tydef.type_),\n                                     src_link,\n                                     0,\n@@ -1439,7 +1483,7 @@ fn render_impl(\n                 if item_type == ItemType::Method { \" method-toggle\" } else { \"\" };\n             write!(w, \"<details class=\\\"rustdoc-toggle{}\\\" open><summary>\", method_toggle_class);\n         }\n-        match *item.kind {\n+        match &*item.kind {\n             clean::MethodItem(..) | clean::TyMethodItem(_) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n@@ -1471,63 +1515,68 @@ fn render_impl(\n                     w.write_str(\"</section>\");\n                 }\n             }\n-            clean::TypedefItem(ref tydef, _) => {\n-                let source_id = format!(\"{}.{}\", ItemType::AssocType, name);\n+            kind @ (clean::TyAssocConstItem(ty) | clean::AssocConstItem(ty, _)) => {\n+                let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n                 write!(\n                     w,\n                     \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n                     id, item_type, in_trait_class\n                 );\n+                render_rightside(w, cx, item, containing_item, render_mode);\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n-                assoc_type(\n+                assoc_const(\n                     w,\n                     item,\n-                    &tydef.generics,\n-                    &[],\n-                    Some(&tydef.type_),\n+                    ty,\n+                    match kind {\n+                        clean::TyAssocConstItem(_) => None,\n+                        clean::AssocConstItem(_, default) => Some(default),\n+                        _ => unreachable!(),\n+                    },\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    0,\n+                    \"\",\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n                 w.write_str(\"</section>\");\n             }\n-            clean::AssocConstItem(ref ty, _) => {\n+            clean::TyAssocTypeItem(generics, bounds) => {\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n-                write!(\n-                    w,\n-                    \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n-                    id, item_type, in_trait_class\n-                );\n-                render_rightside(w, cx, item, containing_item, render_mode);\n+                write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class);\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n-                assoc_const(\n+                assoc_type(\n                     w,\n                     item,\n-                    ty,\n+                    generics,\n+                    bounds,\n+                    None,\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    \"\",\n+                    0,\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n                 w.write_str(\"</section>\");\n             }\n-            clean::AssocTypeItem(ref generics, ref bounds, ref default) => {\n+            clean::AssocTypeItem(tydef, _bounds) => {\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n-                write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class,);\n+                write!(\n+                    w,\n+                    \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n+                    id, item_type, in_trait_class\n+                );\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_type(\n                     w,\n                     item,\n-                    generics,\n-                    bounds,\n-                    default.as_ref(),\n+                    &tydef.generics,\n+                    &[], // intentionally leaving out bounds\n+                    Some(tydef.item_type.as_ref().unwrap_or(&tydef.type_)),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n                     0,\n                     cx,\n@@ -1748,13 +1797,13 @@ pub(crate) fn render_impl_summary(\n         write!(w, \"{}\", i.inner_impl().print(use_absolute, cx));\n         if show_def_docs {\n             for it in &i.inner_impl().items {\n-                if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n                     w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n                     assoc_type(\n                         w,\n                         it,\n                         &tydef.generics,\n-                        &[],\n+                        &[], // intentionally leaving out bounds\n                         Some(&tydef.type_),\n                         AssocItemLink::Anchor(None),\n                         0,\n@@ -1822,7 +1871,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n         clean::PrimitiveItem(_) => sidebar_primitive(cx, buffer, it),\n         clean::UnionItem(ref u) => sidebar_union(cx, buffer, it, u),\n         clean::EnumItem(ref e) => sidebar_enum(cx, buffer, it, e),\n-        clean::TypedefItem(_, _) => sidebar_typedef(cx, buffer, it),\n+        clean::TypedefItem(_) => sidebar_typedef(cx, buffer, it),\n         clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n         clean::ForeignTypeItem => sidebar_foreign_type(cx, buffer, it),\n         _ => {}\n@@ -1917,7 +1966,7 @@ fn get_methods(\n                 if !for_deref || should_render_item(item, deref_mut, tcx) {\n                     Some(SidebarLink {\n                         name,\n-                        url: get_next_url(used_links, format!(\"method.{}\", name)),\n+                        url: get_next_url(used_links, format!(\"{}.{}\", ItemType::Method, name)),\n                     })\n                 } else {\n                     None\n@@ -1937,7 +1986,7 @@ fn get_associated_constants(\n         .filter_map(|item| match item.name {\n             Some(name) if !name.is_empty() && item.is_associated_const() => Some(SidebarLink {\n                 name,\n-                url: get_next_url(used_links, format!(\"associatedconstant.{}\", name)),\n+                url: get_next_url(used_links, format!(\"{}.{}\", ItemType::AssocConst, name)),\n             }),\n             _ => None,\n         })\n@@ -2106,7 +2155,7 @@ fn sidebar_deref_methods(\n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n         impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-            clean::TypedefItem(ref t, true) => Some(match *t {\n+            clean::AssocTypeItem(ref t, _) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n             }),\n@@ -2281,19 +2330,37 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     print_sidebar_section(\n         buf,\n         &t.items,\n-        \"associated-types\",\n-        \"Associated Types\",\n+        \"required-associated-types\",\n+        \"Required Associated Types\",\n+        |m| m.is_ty_associated_type(),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"provided-associated-types\",\n+        \"Provided Associated Types\",\n         |m| m.is_associated_type(),\n-        |sym| format!(\"<a href=\\\"#associatedtype.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"required-associated-consts\",\n+        \"Required Associated Constants\",\n+        |m| m.is_ty_associated_const(),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n     );\n \n     print_sidebar_section(\n         buf,\n         &t.items,\n-        \"associated-const\",\n-        \"Associated Constants\",\n+        \"provided-associated-consts\",\n+        \"Provided Associated Constants\",\n         |m| m.is_associated_const(),\n-        |sym| format!(\"<a href=\\\"#associatedconstant.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n     );\n \n     print_sidebar_section(\n@@ -2302,7 +2369,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"required-methods\",\n         \"Required Methods\",\n         |m| m.is_ty_method(),\n-        |sym| format!(\"<a href=\\\"#tymethod.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::TyMethod),\n     );\n \n     print_sidebar_section(\n@@ -2311,7 +2378,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"provided-methods\",\n         \"Provided Methods\",\n         |m| m.is_method(),\n-        |sym| format!(\"<a href=\\\"#method.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::Method),\n     );\n \n     let cache = cx.cache();"}, {"sha": "1ed5c662c41cc162280b91829ff0b813b06d92ac", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 85, "deletions": 75, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -141,7 +141,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n \n     item_vars.render_into(buf).unwrap();\n \n-    match *item.kind {\n+    match &*item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n@@ -150,7 +150,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n         clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n         clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n         clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n-        clean::TypedefItem(ref t, is_associated) => item_typedef(buf, cx, item, t, is_associated),\n+        clean::TypedefItem(ref t) => item_typedef(buf, cx, item, t),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n         clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n@@ -507,13 +507,15 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n \n fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n     let bounds = bounds(&t.bounds, false, cx);\n-    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n-    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n-    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n-    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n-    let count_types = types.len();\n-    let count_consts = consts.len();\n-    let count_methods = required.len() + provided.len();\n+    let required_types = t.items.iter().filter(|m| m.is_ty_associated_type()).collect::<Vec<_>>();\n+    let provided_types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n+    let required_consts = t.items.iter().filter(|m| m.is_ty_associated_const()).collect::<Vec<_>>();\n+    let provided_consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n+    let required_methods = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n+    let provided_methods = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n+    let count_types = required_types.len() + provided_types.len();\n+    let count_consts = required_consts.len() + provided_consts.len();\n+    let count_methods = required_methods.len() + provided_methods.len();\n \n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n@@ -554,16 +556,18 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                         ),\n                     );\n                 }\n-                for t in &types {\n-                    render_assoc_item(\n-                        w,\n-                        t,\n-                        AssocItemLink::Anchor(None),\n-                        ItemType::Trait,\n-                        cx,\n-                        RenderMode::Normal,\n-                    );\n-                    w.write_str(\";\\n\");\n+                for types in [&required_types, &provided_types] {\n+                    for t in types {\n+                        render_assoc_item(\n+                            w,\n+                            t,\n+                            AssocItemLink::Anchor(None),\n+                            ItemType::Trait,\n+                            cx,\n+                            RenderMode::Normal,\n+                        );\n+                        w.write_str(\";\\n\");\n+                    }\n                 }\n                 // If there are too many associated constants, hide everything after them\n                 // We also do this if the types + consts is large because otherwise we could\n@@ -582,28 +586,30 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                         ),\n                     );\n                 }\n-                if !types.is_empty() && !consts.is_empty() {\n+                if count_types != 0 && (count_consts != 0 || count_methods != 0) {\n                     w.write_str(\"\\n\");\n                 }\n-                for t in &consts {\n-                    render_assoc_item(\n-                        w,\n-                        t,\n-                        AssocItemLink::Anchor(None),\n-                        ItemType::Trait,\n-                        cx,\n-                        RenderMode::Normal,\n-                    );\n-                    w.write_str(\";\\n\");\n+                for consts in [&required_consts, &provided_consts] {\n+                    for c in consts {\n+                        render_assoc_item(\n+                            w,\n+                            c,\n+                            AssocItemLink::Anchor(None),\n+                            ItemType::Trait,\n+                            cx,\n+                            RenderMode::Normal,\n+                        );\n+                        w.write_str(\";\\n\");\n+                    }\n                 }\n                 if !toggle && should_hide_fields(count_methods) {\n                     toggle = true;\n                     toggle_open(w, format_args!(\"{} methods\", count_methods));\n                 }\n-                if !consts.is_empty() && !required.is_empty() {\n+                if count_consts != 0 && count_methods != 0 {\n                     w.write_str(\"\\n\");\n                 }\n-                for (pos, m) in required.iter().enumerate() {\n+                for (pos, m) in required_methods.iter().enumerate() {\n                     render_assoc_item(\n                         w,\n                         m,\n@@ -614,14 +620,14 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                     );\n                     w.write_str(\";\\n\");\n \n-                    if pos < required.len() - 1 {\n+                    if pos < required_methods.len() - 1 {\n                         w.write_str(\"<span class=\\\"item-spacer\\\"></span>\");\n                     }\n                 }\n-                if !required.is_empty() && !provided.is_empty() {\n+                if !required_methods.is_empty() && !provided_methods.is_empty() {\n                     w.write_str(\"\\n\");\n                 }\n-                for (pos, m) in provided.iter().enumerate() {\n+                for (pos, m) in provided_methods.iter().enumerate() {\n                     render_assoc_item(\n                         w,\n                         m,\n@@ -640,7 +646,8 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                             w.write_str(\" { ... }\\n\");\n                         }\n                     }\n-                    if pos < provided.len() - 1 {\n+\n+                    if pos < provided_methods.len() - 1 {\n                         w.write_str(\"<span class=\\\"item-spacer\\\"></span>\");\n                     }\n                 }\n@@ -703,53 +710,77 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n     }\n \n-    if !types.is_empty() {\n+    if !required_types.is_empty() {\n         write_small_section_header(\n             w,\n-            \"associated-types\",\n-            \"Associated Types\",\n+            \"required-associated-types\",\n+            \"Required Associated Types\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for t in types {\n+        for t in required_types {\n+            trait_item(w, cx, t, it);\n+        }\n+        w.write_str(\"</div>\");\n+    }\n+    if !provided_types.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"provided-associated-types\",\n+            \"Provided Associated Types\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in provided_types {\n             trait_item(w, cx, t, it);\n         }\n         w.write_str(\"</div>\");\n     }\n \n-    if !consts.is_empty() {\n+    if !required_consts.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"required-associated-consts\",\n+            \"Required Associated Constants\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in required_consts {\n+            trait_item(w, cx, t, it);\n+        }\n+        w.write_str(\"</div>\");\n+    }\n+    if !provided_consts.is_empty() {\n         write_small_section_header(\n             w,\n-            \"associated-const\",\n-            \"Associated Constants\",\n+            \"provided-associated-consts\",\n+            \"Provided Associated Constants\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for t in consts {\n+        for t in provided_consts {\n             trait_item(w, cx, t, it);\n         }\n         w.write_str(\"</div>\");\n     }\n \n     // Output the documentation for each function individually\n-    if !required.is_empty() {\n+    if !required_methods.is_empty() {\n         write_small_section_header(\n             w,\n             \"required-methods\",\n-            \"Required methods\",\n+            \"Required Methods\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for m in required {\n+        for m in required_methods {\n             trait_item(w, cx, m, it);\n         }\n         w.write_str(\"</div>\");\n     }\n-    if !provided.is_empty() {\n+    if !provided_methods.is_empty() {\n         write_small_section_header(\n             w,\n             \"provided-methods\",\n-            \"Provided methods\",\n+            \"Provided Methods\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for m in provided {\n+        for m in provided_methods {\n             trait_item(w, cx, m, it);\n         }\n         w.write_str(\"</div>\");\n@@ -933,25 +964,11 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n-fn item_typedef(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    it: &clean::Item,\n-    t: &clean::Typedef,\n-    is_associated: bool,\n-) {\n-    fn write_content(\n-        w: &mut Buffer,\n-        cx: &Context<'_>,\n-        it: &clean::Item,\n-        t: &clean::Typedef,\n-        is_associated: bool,\n-    ) {\n+fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n+    fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            if !is_associated {\n-                write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n-            }\n+            write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -963,14 +980,7 @@ fn item_typedef(\n         });\n     }\n \n-    // If this is an associated typedef, we don't want to wrap it into a docblock.\n-    if is_associated {\n-        write_content(w, cx, it, t, is_associated);\n-    } else {\n-        wrap_into_docblock(w, |w| {\n-            write_content(w, cx, it, t, is_associated);\n-        });\n-    }\n+    wrap_into_docblock(w, |w| write_content(w, cx, it, t));\n \n     document(w, cx, it, None, HeadingOffset::H2);\n "}, {"sha": "ab52304491a2bc17841d3515f9227f9c916a57a2", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -3,7 +3,7 @@\n \n (function() {\n // This mapping table should match the discriminants of\n-// `rustdoc::html::item_type::ItemType` type in Rust.\n+// `rustdoc::formats::item_type::ItemType` type in Rust.\n var itemTypes = [\n     \"mod\",\n     \"externcrate\","}, {"sha": "a9a6a31fccd0d7c8b3457feda0250b6fab56bc83", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -219,20 +219,23 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         StaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignStaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignTypeItem => ItemEnum::ForeignType,\n-        TypedefItem(t, _) => ItemEnum::Typedef(t.into_tcx(tcx)),\n+        TypedefItem(t) => ItemEnum::Typedef(t.into_tcx(tcx)),\n         OpaqueTyItem(t) => ItemEnum::OpaqueTy(t.into_tcx(tcx)),\n         ConstantItem(c) => ItemEnum::Constant(c.into_tcx(tcx)),\n         MacroItem(m) => ItemEnum::Macro(m.source),\n         ProcMacroItem(m) => ItemEnum::ProcMacro(m.into_tcx(tcx)),\n         PrimitiveItem(p) => ItemEnum::PrimitiveType(p.as_sym().to_string()),\n+        TyAssocConstItem(ty) => ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: None },\n         AssocConstItem(ty, default) => {\n-            ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: default.map(|c| c.expr(tcx)) }\n+            ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: Some(default.expr(tcx)) }\n         }\n-        AssocTypeItem(g, b, t) => ItemEnum::AssocType {\n+        TyAssocTypeItem(g, b) => ItemEnum::AssocType {\n             generics: (*g).into_tcx(tcx),\n             bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n-            default: t.map(|x| x.into_tcx(tcx)),\n+            default: None,\n         },\n+        // FIXME: do not map to Typedef but to a custom variant\n+        AssocTypeItem(t, _) => ItemEnum::Typedef(t.into_tcx(tcx)),\n         // `convert_item` early returns `None` for striped items\n         StrippedItem(_) => unreachable!(),\n         KeywordItem(_) => {"}, {"sha": "b541fb63bd413422e694053c68a2bb86cb28a63f", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -61,9 +61,9 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n             *item.kind,\n             clean::StructFieldItem(_)\n                 | clean::VariantItem(_)\n-                | clean::AssocConstItem(_, _)\n+                | clean::AssocConstItem(..)\n                 | clean::AssocTypeItem(..)\n-                | clean::TypedefItem(_, _)\n+                | clean::TypedefItem(_)\n                 | clean::StaticItem(_)\n                 | clean::ConstantItem(_)\n                 | clean::ExternCrateItem { .. }"}, {"sha": "4ab942c8f1bdc977ab9d482c714edd34261f06f9", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -93,7 +93,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                 let target = items\n                     .iter()\n                     .find_map(|item| match *item.kind {\n-                        TypedefItem(ref t, true) => Some(&t.type_),\n+                        AssocTypeItem(ref t, _) => Some(&t.type_),\n                         _ => None,\n                     })\n                     .expect(\"Deref impl without Target type\");"}, {"sha": "82627aaf7a4cb339ff5deff0dea4f6f703345d8b", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -41,6 +41,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ConstantItem(..)\n             | clean::UnionItem(..)\n             | clean::AssocConstItem(..)\n+            | clean::AssocTypeItem(..)\n             | clean::TraitAliasItem(..)\n             | clean::MacroItem(..)\n             | clean::ForeignTypeItem => {\n@@ -72,18 +73,15 @@ impl<'a> DocFolder for Stripper<'a> {\n \n             clean::ImplItem(..) => {}\n \n-            // tymethods have no control over privacy\n-            clean::TyMethodItem(..) => {}\n+            // tymethods etc. have no control over privacy\n+            clean::TyMethodItem(..) | clean::TyAssocConstItem(..) | clean::TyAssocTypeItem(..) => {}\n \n             // Proc-macros are always public\n             clean::ProcMacroItem(..) => {}\n \n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n \n-            // Associated types are never stripped\n-            clean::AssocTypeItem(..) => {}\n-\n             // Keywords are never stripped\n             clean::KeywordItem(..) => {}\n         }"}, {"sha": "ef50292674276c17d6a656f134604f00dc04ca44", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -26,7 +26,7 @@ crate trait DocVisitor: Sized {\n             ExternCrateItem { src: _ }\n             | ImportItem(_)\n             | FunctionItem(_)\n-            | TypedefItem(_, _)\n+            | TypedefItem(_)\n             | OpaqueTyItem(_)\n             | StaticItem(_)\n             | ConstantItem(_)\n@@ -40,7 +40,9 @@ crate trait DocVisitor: Sized {\n             | MacroItem(_)\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n-            | AssocConstItem(_, _)\n+            | TyAssocConstItem(..)\n+            | AssocConstItem(..)\n+            | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | KeywordItem(_) => {}\n         }"}, {"sha": "0ac6dc763df88bd0e3641fe2f9d3b958915a8ab5", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,8 +1,8 @@\n pub trait Foo {\n     // @has assoc_consts/trait.Foo.html '//*[@class=\"rust trait\"]' \\\n-    //      'const FOO: usize;'\n+    //      'const FOO: usize = 13usize;'\n     // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO: usize'\n-    const FOO: usize = 12;\n+    const FOO: usize = 12 + 1;\n     // @has - '//*[@id=\"associatedconstant.FOO_NO_DEFAULT\"]' 'const FOO_NO_DEFAULT: bool'\n     const FOO_NO_DEFAULT: bool;\n     // @!has - FOO_HIDDEN"}, {"sha": "dab0a64952955b6352e264c12c662a9dbb5557a0", "filename": "src/test/rustdoc/extern-default-method.no_href_on_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fextern-default-method.no_href_on_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fextern-default-method.no_href_on_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-default-method.no_href_on_anchor.html?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1 @@\n+<a class=\"fnname\">provided</a>(&amp;self)\n\\ No newline at end of file"}, {"sha": "8139f5b2619b3143a0927cee582b8e4dd3f9c5c7", "filename": "src/test/rustdoc/extern-default-method.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fextern-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fextern-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-default-method.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,9 +1,23 @@\n // aux-build:rustdoc-extern-default-method.rs\n // ignore-cross-compile\n+// ignore-tidy-linelength\n \n extern crate rustdoc_extern_default_method as ext;\n \n+// For this test, the dependency is compiled but not documented.\n+//\n+// Still, the struct from the external crate and its impl should be documented since\n+// the struct is re-exported from this crate.\n+// However, the method in the trait impl should *not* have a link (an `href` attribute) to\n+// its corresponding item in the trait declaration since it would otherwise be broken.\n+//\n+// In older versions of rustdoc, the impl item (`a[@class=\"fnname\"]`) used to link to\n+// `#method.provided` \u2013 i.e. \"to itself\". Put in quotes since that was actually incorrect in\n+// general: If the type `Struct` also had an inherent method called `provided`, the impl item\n+// would link to that one even though those two methods are distinct items!\n+\n // @count extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]' 1\n-// @has extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]//a[@class=\"fnname\"]/@href' #method.provided\n+// @count extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]//a[@class=\"fnname\"]' 1\n+// @snapshot no_href_on_anchor - '//*[@id=\"method.provided\"]//a[@class=\"fnname\"]'\n // @has extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]//a[@class=\"anchor\"]/@href' #method.provided\n pub use ext::Struct;"}, {"sha": "c7ce71b15f30c572c8f6b7110c17e69519fee6b5", "filename": "src/test/rustdoc/intra-doc/prim-self.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -5,6 +5,7 @@\n #![feature(no_core)]\n #![feature(rustdoc_internals)]\n #![feature(inherent_associated_types)]\n+#![feature(lang_items)]\n #![no_core]\n \n /// [Self::f]\n@@ -35,3 +36,6 @@ pub struct S;\n impl S {\n     pub fn f() {}\n }\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}"}, {"sha": "b5b681ab085bf7d0b1fe4411e18b9ce7184a2e6c", "filename": "src/test/rustdoc/sidebar-items.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fsidebar-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Frustdoc%2Fsidebar-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsidebar-items.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,16 +1,23 @@\n+#![feature(associated_type_defaults)]\n #![crate_name = \"foo\"]\n \n // @has foo/trait.Foo.html\n // @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#required-methods\"]' 'Required Methods'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'bar'\n // @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#provided-methods\"]' 'Provided Methods'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'foo'\n-// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#associated-const\"]' 'Associated Constants'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#required-associated-consts\"]' 'Required Associated Constants'\n+// @has - '//*[@class=\"sidebar-elems\"]//section//a' 'FOO'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#provided-associated-consts\"]' 'Provided Associated Constants'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'BAR'\n-// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#associated-types\"]' 'Associated Types'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#required-associated-types\"]' 'Required Associated Types'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'Output'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#provided-associated-types\"]' 'Provided Associated Types'\n+// @has - '//*[@class=\"sidebar-elems\"]//section//a' 'Extra'\n pub trait Foo {\n+    const FOO: usize;\n     const BAR: u32 = 0;\n+    type Extra: Copy = ();\n     type Output: ?Sized;\n \n     fn foo() {}"}, {"sha": "afa95645a27869ba85a4948bac49ac89d2d7c584", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -20,6 +20,7 @@ impl<T: Send> AnotherTrait for T {}\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n     //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+    //~| ERROR cannot implement trait on type alias impl trait\n }\n \n fn main() {}"}, {"sha": "3b360f492b70e4d7ccbafdf05c8f9dd6aca8040a", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,3 +1,15 @@\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/auto-trait.rs:21:25\n+   |\n+LL | impl AnotherTrait for D<OpaqueType> {\n+   |                         ^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/auto-trait.rs:7:19\n+   |\n+LL | type OpaqueType = impl OpaqueTrait;\n+   |                   ^^^^^^^^^^^^^^^^\n+\n error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n   --> $DIR/auto-trait.rs:21:1\n    |\n@@ -7,6 +19,6 @@ LL | impl<T: Send> AnotherTrait for T {}\n LL | impl AnotherTrait for D<OpaqueType> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "da69bb349ae24ac586d98b727b36e32c47a3f328", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -18,6 +18,7 @@ impl<T: std::fmt::Debug> AnotherTrait for T {}\n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n     //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+    //~| ERROR cannot implement trait on type alias impl trait\n }\n \n fn main() {}"}, {"sha": "98f9fbd8fefb7cae56993bc6e06ebe167f564d4e", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,3 +1,15 @@\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/negative-reasoning.rs:19:25\n+   |\n+LL | impl AnotherTrait for D<OpaqueType> {\n+   |                         ^^^^^^^^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/negative-reasoning.rs:7:19\n+   |\n+LL | type OpaqueType = impl OpaqueTrait;\n+   |                   ^^^^^^^^^^^^^^^^\n+\n error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n   --> $DIR/negative-reasoning.rs:19:1\n    |\n@@ -9,6 +21,6 @@ LL | impl AnotherTrait for D<OpaqueType> {\n    |\n    = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "621c4ea6e0d4822010620f79302bf3a13e3c6d7b", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -5,13 +5,14 @@ type Foo = impl PartialEq<(Foo, i32)>;\n struct Bar;\n \n impl PartialEq<(Foo, i32)> for Bar {\n+//~^ ERROR cannot implement trait on type alias impl trait\n     fn eq(&self, _other: &(Foo, i32)) -> bool {\n         true\n     }\n }\n \n fn foo() -> Foo {\n-    Bar //~ ERROR can't compare `Bar` with `(Bar, i32)`\n+    Bar\n }\n \n fn main() {}"}, {"sha": "2ef1697ba341d8e259c7db468fa096a4c8f69827", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,12 +1,14 @@\n-error[E0277]: can't compare `Bar` with `(Bar, i32)`\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:14:5\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:7:17\n    |\n-LL |     Bar\n-   |     ^^^ no implementation for `Bar == (Bar, i32)`\n+LL | impl PartialEq<(Foo, i32)> for Bar {\n+   |                 ^^^\n    |\n-   = help: the trait `PartialEq<(Bar, i32)>` is not implemented for `Bar`\n-   = help: the trait `PartialEq<(Foo, i32)>` is implemented for `Bar`\n+note: type alias impl trait defined here\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:3:12\n+   |\n+LL | type Foo = impl PartialEq<(Foo, i32)>;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "df7966f00e17238570ef51fec97ac42bf99b071d", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -2,7 +2,6 @@\n \n mod a {\n     type Foo = impl PartialEq<(Foo, i32)>;\n-    //~^ ERROR unconstrained opaque type\n \n     struct Bar;\n \n@@ -15,13 +14,12 @@ mod a {\n \n mod b {\n     type Foo = impl PartialEq<(Foo, i32)>;\n-    //~^ ERROR unconstrained opaque type\n \n     struct Bar;\n \n     impl PartialEq<(Foo, i32)> for Bar {\n+        //~^ ERROR cannot implement trait on type alias impl trait\n         fn eq(&self, _other: &(Bar, i32)) -> bool {\n-            //~^ ERROR impl has stricter requirements than trait\n             true\n         }\n     }"}, {"sha": "6cd63dcf81c7fcbb2e3531ed7da057faa13c1124", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,25 +1,14 @@\n-error: unconstrained opaque type\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:4:16\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:20:21\n    |\n-LL |     type Foo = impl PartialEq<(Foo, i32)>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     impl PartialEq<(Foo, i32)> for Bar {\n+   |                     ^^^\n    |\n-   = note: `Foo` must be used in combination with a concrete type within the same module\n-\n-error: unconstrained opaque type\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:17:16\n+note: type alias impl trait defined here\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:16:16\n    |\n LL |     type Foo = impl PartialEq<(Foo, i32)>;\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `Foo` must be used in combination with a concrete type within the same module\n-\n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:23:9\n-   |\n-LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `b::Bar: PartialEq<(b::Bar, i32)>`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0276`."}, {"sha": "fb6cf7e8996c0b93107b71fe2ea2d42408c604b1", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.fixed?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -69,4 +69,18 @@ where\n     (t, t) //~ use of moved value: `t`\n }\n \n+#[rustfmt::skip]\n+fn existing_colon<T: Copy>(t: T) {\n+    //~^ HELP consider restricting type parameter `T`\n+    [t, t]; //~ use of moved value: `t`\n+}\n+\n+fn existing_colon_in_where<T>(t: T)\n+where\n+    T: Copy,\n+    //~^ HELP consider further restricting this bound\n+{\n+    [t, t]; //~ use of moved value: `t`\n+}\n+\n fn main() {}"}, {"sha": "cadbf2a54cc3765dfecc3764d78f0549f65bf862", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -69,4 +69,18 @@ where\n     (t, t) //~ use of moved value: `t`\n }\n \n+#[rustfmt::skip]\n+fn existing_colon<T:>(t: T) {\n+    //~^ HELP consider restricting type parameter `T`\n+    [t, t]; //~ use of moved value: `t`\n+}\n+\n+fn existing_colon_in_where<T>(t: T)\n+where\n+    T:,\n+    //~^ HELP consider further restricting this bound\n+{\n+    [t, t]; //~ use of moved value: `t`\n+}\n+\n fn main() {}"}, {"sha": "f5252084d6884f76534992c0f5f3a0a9a59731e0", "filename": "src/test/ui/moves/use_of_moved_value_copy_suggestions.stderr", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fuse_of_moved_value_copy_suggestions.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -142,6 +142,38 @@ help: consider further restricting this bound\n LL |     T: B + Trait + Copy,\n    |          ++++++++++++++\n \n-error: aborting due to 9 previous errors\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:83:9\n+   |\n+LL | fn existing_colon_in_where<T>(t: T)\n+   |                               - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+...\n+LL |     [t, t];\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider further restricting this bound\n+   |\n+LL |     T: Copy,\n+   |        ++++\n+\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/use_of_moved_value_copy_suggestions.rs:75:9\n+   |\n+LL | fn existing_colon<T:>(t: T) {\n+   |                       - move occurs because `t` has type `T`, which does not implement the `Copy` trait\n+LL |\n+LL |     [t, t];\n+   |      -  ^ value used here after move\n+   |      |\n+   |      value moved here\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn existing_colon<T: Copy>(t: T) {\n+   |                      ++++\n+\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "f59814468b2f146eeeddc180f720b7be4e47e8b3", "filename": "src/test/ui/pattern/issue-95878.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fpattern%2Fissue-95878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fpattern%2Fissue-95878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-95878.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<'a>(&'a ());\n+\n+impl<'a> Foo<'a> {\n+    fn spam(&mut self, baz: &mut Vec<u32>) {\n+        match 15 {\n+            ref Self => (),\n+            //~^ ERROR expected identifier, found keyword `Self`\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e0eea06e0a3c3dcaa1f7fc49200be04bd8a23a4f", "filename": "src/test/ui/pattern/issue-95878.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fpattern%2Fissue-95878.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Fpattern%2Fissue-95878.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-95878.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,8 @@\n+error: expected identifier, found keyword `Self`\n+  --> $DIR/issue-95878.rs:6:17\n+   |\n+LL |             ref Self => (),\n+   |                 ^^^^ expected identifier, found keyword\n+\n+error: aborting due to previous error\n+"}, {"sha": "bbc240b6aec4931eead6f42a28e3277ae89994f6", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,8 +1,8 @@\n error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-83613.rs:10:1\n+  --> $DIR/issue-83613.rs:10:23\n    |\n LL | impl AnotherTrait for OpaqueType {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^\n    |\n note: type alias impl trait defined here\n   --> $DIR/issue-83613.rs:4:19"}, {"sha": "41bcea27e1fa317f45f311ac9b9a6e332cdb25a6", "filename": "src/test/ui/type-alias-impl-trait/issue-65384.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,8 +1,8 @@\n error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-65384.rs:10:1\n+  --> $DIR/issue-65384.rs:10:18\n    |\n LL | impl MyTrait for Bar {}\n-   | ^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^\n    |\n note: type alias impl trait defined here\n   --> $DIR/issue-65384.rs:8:12"}, {"sha": "2d4a6854a920be74ffc2add35ade869546709f08", "filename": "src/test/ui/type-alias-impl-trait/issue-76202-trait-impl-for-tait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,8 +1,8 @@\n error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-76202-trait-impl-for-tait.rs:16:1\n+  --> $DIR/issue-76202-trait-impl-for-tait.rs:16:15\n    |\n LL | impl Test for F {\n-   | ^^^^^^^^^^^^^^^\n+   |               ^\n    |\n note: type alias impl trait defined here\n   --> $DIR/issue-76202-trait-impl-for-tait.rs:9:10"}, {"sha": "fa25d8f762e6c3f8031ea50e22ceac7a640f5e93", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-trait-impl-for-tait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for issues #84660 and #86411: both are variations on #76202.\n+// Tests that we don't ICE when we have an opaque type appearing anywhere in an impl header.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Foo {}\n+impl Foo for () {}\n+type Bar = impl Foo;\n+fn _defining_use() -> Bar {}\n+\n+trait TraitArg<T> {\n+    fn f();\n+}\n+\n+impl TraitArg<Bar> for () { //~ ERROR cannot implement trait\n+    fn f() {\n+        println!(\"ho\");\n+    }\n+}\n+\n+fn main() {\n+    <() as TraitArg<Bar>>::f();\n+}"}, {"sha": "bb70d07be59bb0da395cd94836186ebc06d5e379", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-trait-impl-for-tait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,14 @@\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/issue-84660-trait-impl-for-tait.rs:15:15\n+   |\n+LL | impl TraitArg<Bar> for () {\n+   |               ^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/issue-84660-trait-impl-for-tait.rs:8:12\n+   |\n+LL | type Bar = impl Foo;\n+   |            ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "f12d1b6d953cd6ee9890db3f4da4ddcdf5d972c4", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-unsoundness.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,41 @@\n+// Another example from issue #84660, this time weaponized as a safe transmute: an opaque type in an\n+// impl header being accepted was used to create unsoundness.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Foo {}\n+impl Foo for () {}\n+type Bar = impl Foo;\n+fn _defining_use() -> Bar {}\n+\n+trait Trait<T, In> {\n+    type Out;\n+    fn convert(i: In) -> Self::Out;\n+}\n+\n+impl<In, Out> Trait<Bar, In> for Out { //~ ERROR cannot implement trait\n+    type Out = Out;\n+    fn convert(_i: In) -> Self::Out {\n+        unreachable!();\n+    }\n+}\n+\n+impl<In, Out> Trait<(), In> for Out {\n+    type Out = In;\n+    fn convert(i: In) -> Self::Out {\n+        i\n+    }\n+}\n+\n+fn transmute<In, Out>(i: In) -> Out {\n+    <Out as Trait<Bar, In>>::convert(i)\n+}\n+\n+fn main() {\n+    let d;\n+    {\n+        let x = \"Hello World\".to_string();\n+        d = transmute::<&String, &String>(&x);\n+    }\n+    println!(\"{}\", d);\n+}"}, {"sha": "f2d600fb46c54ee4e64922393a27b0e06bb27f02", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-unsoundness.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -0,0 +1,14 @@\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/issue-84660-unsoundness.rs:16:21\n+   |\n+LL | impl<In, Out> Trait<Bar, In> for Out {\n+   |                     ^^^\n+   |\n+note: type alias impl trait defined here\n+  --> $DIR/issue-84660-unsoundness.rs:8:12\n+   |\n+LL | type Bar = impl Foo;\n+   |            ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ebf3a99bbf9f09ae56bee7390c12aee4d6f0a487", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -4,11 +4,11 @@\n use std::fmt::Debug;\n \n type FooX = impl Debug;\n-//~^ unconstrained opaque type\n \n trait Foo<A> { }\n \n impl Foo<FooX> for () { }\n+//~^ cannot implement trait on type alias impl trait\n \n fn foo() -> impl Foo<FooX> {\n     ()"}, {"sha": "4a3fb16733e04964fc53cc8f5ade4388a9c9aa6f", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -1,10 +1,14 @@\n-error: unconstrained opaque type\n+error: cannot implement trait on type alias impl trait\n+  --> $DIR/nested-tait-inference3.rs:10:10\n+   |\n+LL | impl Foo<FooX> for () { }\n+   |          ^^^^\n+   |\n+note: type alias impl trait defined here\n   --> $DIR/nested-tait-inference3.rs:6:13\n    |\n LL | type FooX = impl Debug;\n    |             ^^^^^^^^^^\n-   |\n-   = note: `FooX` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "a5724ddfb88eb6f805c140eac1a39e12b6757e81", "filename": "triagebot.toml", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1491e5cc148391f7679542b8e9b4e6d2430a7b69/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1491e5cc148391f7679542b8e9b4e6d2430a7b69/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=1491e5cc148391f7679542b8e9b4e6d2430a7b69", "patch": "@@ -136,6 +136,21 @@ exclude_labels = [\n     \"T-*\",\n ]\n \n+[autolabel.\"T-libs\"]\n+trigger_files = [\n+    \"library/alloc\",\n+    \"library/core\",\n+    \"library/panic_abort\",\n+    \"library/panic_unwind\",\n+    \"library/std\",\n+    \"library/stdarch\",\n+    \"library/term\",\n+    \"library/test\",\n+]\n+exclude_labels = [\n+    \"T-*\",\n+]\n+\n [notify-zulip.\"I-prioritize\"]\n zulip_stream = 245100 # #t-compiler/wg-prioritization/alerts\n topic = \"#{number} {title}\""}]}