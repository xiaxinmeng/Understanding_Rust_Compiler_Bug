{"sha": "96dc03bad73cd18e7f58d90c2fc0198e618851e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZGMwM2JhZDczY2QxOGU3ZjU4ZDkwYzJmYzAxOThlNjE4ODUxZTU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-22T22:03:25Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-09T20:43:22Z"}, "message": "Remove `uniform_array_move_out` passes\n\nThese passes were buggy, MIR building is now responsible for\ncanonicalizing `ConstantIndex` projections and `MoveData` is responsible\nfor splitting `Subslice` projections.", "tree": {"sha": "bb9e0b9f7f02afa67e99254c65fd40e6d021631e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb9e0b9f7f02afa67e99254c65fd40e6d021631e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96dc03bad73cd18e7f58d90c2fc0198e618851e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96dc03bad73cd18e7f58d90c2fc0198e618851e5", "html_url": "https://github.com/rust-lang/rust/commit/96dc03bad73cd18e7f58d90c2fc0198e618851e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96dc03bad73cd18e7f58d90c2fc0198e618851e5/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf278ebd9d82e15aba014034520e18120a1d6211", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf278ebd9d82e15aba014034520e18120a1d6211", "html_url": "https://github.com/rust-lang/rust/commit/bf278ebd9d82e15aba014034520e18120a1d6211"}], "stats": {"total": 657, "additions": 168, "deletions": 489}, "files": [{"sha": "73310dfcc45599f1697d72bd41ab6fb071d2f693", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -78,10 +78,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .collect();\n \n         if move_out_indices.is_empty() {\n-            let root_place = self\n-                .prefixes(used_place, PrefixSet::All)\n-                .last()\n-                .unwrap();\n+            let root_place = PlaceRef { projection: &[], ..used_place };\n \n             if !self.uninitialized_error_reported.insert(root_place) {\n                 debug!("}, {"sha": "0cec19394a7f100e078993f6b52711daf6056e18", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -174,7 +174,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(&body, tcx) {\n+        match MoveData::gather_moves(&body, tcx, param_env) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -1600,7 +1600,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         (prefix, place_span.0, place_span.1),\n                         mpi,\n                     );\n-                    return; // don't bother finding other problems.\n                 }\n             }\n             Err(NoMovePathFound::ReachedStatic) => {\n@@ -1614,6 +1613,46 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    /// Subslices correspond to multiple move paths, so we iterate through the\n+    /// elements of the base array. For each element we check\n+    ///\n+    /// * Does this element overlap with our slice.\n+    /// * Is any part of it uninitialized.\n+    fn check_if_subslice_element_is_moved(\n+        &mut self,\n+        location: Location,\n+        desired_action: InitializationRequiringAction,\n+        place_span: (PlaceRef<'cx, 'tcx>, Span),\n+        maybe_uninits: &FlowAtLocation<'tcx, MaybeUninitializedPlaces<'cx, 'tcx>>,\n+        from: u32,\n+        to: u32,\n+    ) {\n+        if let Some(mpi) = self.move_path_for_place(place_span.0) {\n+            let mut child = self.move_data.move_paths[mpi].first_child;\n+            while let Some(child_mpi) = child {\n+                let child_move_place = &self.move_data.move_paths[child_mpi];\n+                let child_place = &child_move_place.place;\n+                let last_proj = child_place.projection.last().unwrap();\n+                if let ProjectionElem::ConstantIndex { offset, from_end, .. } = last_proj {\n+                    debug_assert!(!from_end, \"Array constant indexing shouldn't be `from_end`.\");\n+\n+                    if (from..to).contains(offset) {\n+                        if let Some(uninit_child) = maybe_uninits.has_any_child_of(child_mpi) {\n+                            self.report_use_of_moved_or_uninitialized(\n+                                location,\n+                                desired_action,\n+                                (place_span.0, place_span.0, place_span.1),\n+                                uninit_child,\n+                            );\n+                            return; // don't bother finding other problems.\n+                        }\n+                    }\n+                }\n+                child = child_move_place.next_sibling;\n+            }\n+        }\n+    }\n+\n     fn check_if_path_or_subpath_is_moved(\n         &mut self,\n         location: Location,\n@@ -1640,6 +1679,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         self.check_if_full_path_is_moved(location, desired_action, place_span, flow_state);\n \n+        if let [\n+            base_proj @ ..,\n+            ProjectionElem::Subslice { from, to, from_end: false },\n+        ] = place_span.0.projection {\n+            let place_ty = Place::ty_from(\n+                place_span.0.base,\n+                base_proj,\n+                self.body(),\n+                self.infcx.tcx,\n+            );\n+            if let ty::Array(..) = place_ty.ty.kind {\n+                let array_place = PlaceRef { base: place_span.0.base, projection: base_proj };\n+                self.check_if_subslice_element_is_moved(\n+                    location,\n+                    desired_action,\n+                    (array_place, place_span.1),\n+                    maybe_uninits,\n+                    *from,\n+                    *to,\n+                );\n+                return;\n+            }\n+        }\n+\n         // A move of any shallow suffix of `place` also interferes\n         // with an attempt to use `place`. This is scenario 3 above.\n         //"}, {"sha": "9245064f8759422b086a0eda4fe3a8f7a41f286c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -533,8 +533,8 @@ fn place_projection_conflict<'tcx>(\n             }\n         }\n         (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n-         ProjectionElem::Subslice { to, .. })\n-        | (ProjectionElem::Subslice { to, .. },\n+         ProjectionElem::Subslice { to, from_end: true, .. })\n+        | (ProjectionElem::Subslice { to, from_end: true, .. },\n             ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n             if offset > to {\n                 debug!(\"place_element_conflict: \\"}, {"sha": "fa0864e0de7607fa4fbd5989488c54f75165d5da", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 93, "deletions": 38, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc_index::vec::IndexVec;\n use smallvec::{smallvec, SmallVec};\n \n-use std::collections::hash_map::Entry;\n+use std::convert::TryInto;\n use std::mem;\n \n use super::abs_domain::Lift;\n@@ -17,19 +17,21 @@ use super::{\n struct MoveDataBuilder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n \n         MoveDataBuilder {\n             body,\n             tcx,\n+            param_env,\n             errors: Vec::new(),\n             data: MoveData {\n                 moves: IndexVec::new(),\n@@ -148,42 +150,47 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n                         ));\n                     }\n-                    _ => {\n-                        // FIXME: still badly broken\n-                    }\n+                    _ => {}\n                 },\n                 _ => {}\n             };\n \n-            let proj = &place.projection[..i+1];\n-            base = match self\n-                .builder\n-                .data\n-                .rev_lookup\n-                .projections\n-                .entry((base, elem.lift()))\n-                {\n-                    Entry::Occupied(ent) => *ent.get(),\n-                    Entry::Vacant(ent) => {\n-                        let path = MoveDataBuilder::new_move_path(\n-                            &mut self.builder.data.move_paths,\n-                            &mut self.builder.data.path_map,\n-                            &mut self.builder.data.init_path_map,\n-                            Some(base),\n-                            Place {\n-                                base: place.base.clone(),\n-                                projection: tcx.intern_place_elems(proj),\n-                            },\n-                        );\n-                        ent.insert(path);\n-                        path\n-                    }\n-                };\n+            base = self.add_move_path(base, elem, |tcx| {\n+                Place {\n+                    base: place.base.clone(),\n+                    projection: tcx.intern_place_elems(&place.projection[..i+1]),\n+                }\n+            });\n         }\n \n         Ok(base)\n     }\n \n+    fn add_move_path(\n+        &mut self,\n+        base: MovePathIndex,\n+        elem: &PlaceElem<'tcx>,\n+        mk_place: impl FnOnce(TyCtxt<'tcx>) -> Place<'tcx>,\n+    ) -> MovePathIndex {\n+        let MoveDataBuilder {\n+            data: MoveData { rev_lookup, move_paths, path_map, init_path_map, .. },\n+            tcx,\n+            ..\n+        } = self.builder;\n+        *rev_lookup.projections\n+            .entry((base, elem.lift()))\n+            .or_insert_with(move || {\n+                let path = MoveDataBuilder::new_move_path(\n+                    move_paths,\n+                    path_map,\n+                    init_path_map,\n+                    Some(base),\n+                    mk_place(*tcx),\n+                );\n+                path\n+            })\n+    }\n+\n     fn create_move_path(&mut self, place: &Place<'tcx>) {\n         // This is an non-moving access (such as an overwrite or\n         // drop), so this not being a valid move path is OK.\n@@ -214,8 +221,9 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n pub(super) fn gather_moves<'tcx>(\n     body: &Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n-    let mut builder = MoveDataBuilder::new(body, tcx);\n+    let mut builder = MoveDataBuilder::new(body, tcx, param_env);\n \n     builder.gather_args();\n \n@@ -411,20 +419,67 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_move(&mut self, place: &Place<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, place);\n \n-        let path = match self.move_path_for(place) {\n-            Ok(path) | Err(MoveError::UnionMove { path }) => path,\n-            Err(error @ MoveError::IllegalMove { .. }) => {\n-                self.builder.errors.push((place.clone(), error));\n-                return;\n+        if let [\n+            ref base @ ..,\n+            ProjectionElem::Subslice { from, to, from_end: false },\n+        ] = **place.projection {\n+            // Split `Subslice` patterns into the corresponding list of\n+            // `ConstIndex` patterns. This is done to ensure that all move paths\n+            // are disjoint, which is expected by drop elaboration.\n+            let base_place = Place {\n+                base: place.base.clone(),\n+                projection: self.builder.tcx.intern_place_elems(base),\n+            };\n+            let base_path = match self.move_path_for(&base_place) {\n+                Ok(path) => path,\n+                Err(MoveError::UnionMove { path }) => {\n+                    self.record_move(place, path);\n+                    return;\n+                }\n+                Err(error @ MoveError::IllegalMove { .. }) => {\n+                    self.builder.errors.push((base_place, error));\n+                    return;\n+                }\n+            };\n+            let base_ty = base_place.ty(self.builder.body, self.builder.tcx).ty;\n+            let len: u32 = match base_ty.kind {\n+                ty::Array(_, size) => {\n+                    let length = size.eval_usize(self.builder.tcx, self.builder.param_env);\n+                    length.try_into().expect(\n+                        \"slice pattern of array with more than u32::MAX elements\"\n+                    )\n+                }\n+                _ => bug!(\"from_end: false slice pattern of non-array type\"),\n+            };\n+            for offset in from..to {\n+                let elem = ProjectionElem::ConstantIndex {\n+                    offset,\n+                    min_length: len,\n+                    from_end: false,\n+                };\n+                let path = self.add_move_path(\n+                    base_path,\n+                    &elem,\n+                    |tcx| tcx.mk_place_elem(base_place.clone(), elem),\n+                );\n+                self.record_move(place, path);\n             }\n-        };\n-        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n+        } else {\n+            match self.move_path_for(place) {\n+                Ok(path) | Err(MoveError::UnionMove { path }) => self.record_move(place, path),\n+                Err(error @ MoveError::IllegalMove { .. }) => {\n+                    self.builder.errors.push((place.clone(), error));\n+                }\n+            };\n+        }\n+    }\n \n+    fn record_move(&mut self, place: &Place<'tcx>, path: MovePathIndex) {\n+        let move_out = self.builder.data.moves.push(MoveOut { path: path, source: self.loc });\n         debug!(\n             \"gather_move({:?}, {:?}): adding move {:?} of {:?}\",\n             self.loc, place, move_out, path\n         );\n-\n         self.builder.data.path_map[path].push(move_out);\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }"}, {"sha": "1cacf1f3b0a578fe6961a6b8e559246a51263c07", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n \n         let def_id = src.def_id();\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n-        let move_data = match MoveData::gather_moves(body, tcx) {\n+        let move_data = match MoveData::gather_moves(body, tcx, param_env) {\n             Ok(move_data) => move_data,\n             Err(_) => bug!(\"No `move_errors` should be allowed in MIR borrowck\"),\n         };"}, {"sha": "2e1a08a022472c6fbc684e89a7a3ea60d50025fd", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -35,7 +35,6 @@ pub mod copy_prop;\n pub mod const_prop;\n pub mod generator;\n pub mod inline;\n-pub mod uniform_array_move_out;\n pub mod uninhabited_enum_branching;\n \n pub(crate) fn provide(providers: &mut Providers<'_>) {\n@@ -229,7 +228,6 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyAndCache<'_>> {\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &rustc_peek::SanityCheck,\n-        &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n     body.ensure_predecessors();\n     tcx.alloc_steal_mir(body)\n@@ -294,7 +292,6 @@ fn run_optimization_passes<'tcx>(\n         // Optimizations begin.\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n         &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n-        &uniform_array_move_out::RestoreSubsliceArrayMoveOut::new(tcx),\n         &inline::Inline,\n \n         // Lowering generator control-flow and variables"}, {"sha": "4345fc66bb95e8c73ee321cb858803d699493147", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(body, tcx).unwrap();\n+        let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n         let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n         let flow_inits ="}, {"sha": "71dd405386aa7b25b677b415edc2f2a589cabdeb", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "removed", "additions": 0, "deletions": 381, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf278ebd9d82e15aba014034520e18120a1d6211/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=bf278ebd9d82e15aba014034520e18120a1d6211", "patch": "@@ -1,381 +0,0 @@\n-// This pass converts move out from array by Subslice and\n-// ConstIndex{.., from_end: true} to ConstIndex move out(s) from begin\n-// of array. It allows detect error by mir borrowck and elaborate\n-// drops for array without additional work.\n-//\n-// Example:\n-//\n-// let a = [ box 1,box 2, box 3];\n-// if b {\n-//  let [_a.., _] = a;\n-// } else {\n-//  let [.., _b] = a;\n-// }\n-//\n-//  mir statement _10 = move _2[:-1]; replaced by:\n-//  StorageLive(_12);\n-//  _12 = move _2[0 of 3];\n-//  StorageLive(_13);\n-//  _13 = move _2[1 of 3];\n-//  _10 = [move _12, move _13]\n-//  StorageDead(_12);\n-//  StorageDead(_13);\n-//\n-//  and mir statement _11 = move _2[-1 of 1]; replaced by:\n-//  _11 = move _2[2 of 3];\n-//\n-// FIXME: integrate this transformation to the mir build\n-\n-use rustc::ty;\n-use rustc::ty::TyCtxt;\n-use rustc::mir::*;\n-use rustc::mir::visit::{Visitor, PlaceContext, NonUseContext};\n-use rustc_index::vec::{IndexVec};\n-use crate::transform::{MirPass, MirSource};\n-use crate::util::patch::MirPatch;\n-\n-pub struct UniformArrayMoveOut;\n-\n-impl<'tcx> MirPass<'tcx> for UniformArrayMoveOut {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n-        let mut patch = MirPatch::new(body);\n-        let param_env = tcx.param_env(src.def_id());\n-        {\n-            let read_only_cache = read_only!(body);\n-            let mut visitor\n-                = UniformArrayMoveOutVisitor{ body, patch: &mut patch, tcx, param_env};\n-            visitor.visit_body(read_only_cache);\n-        }\n-        patch.apply(body);\n-    }\n-}\n-\n-struct UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-    patch: &'a mut MirPatch<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    fn visit_assign(&mut self,\n-                    dst_place: &Place<'tcx>,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let &[ref proj_base @ .., elem] = src_place.projection.as_ref() {\n-                if let ProjectionElem::ConstantIndex{offset: _,\n-                                                     min_length: _,\n-                                                     from_end: false} = elem {\n-                    // no need to transformation\n-                } else {\n-                    let place_ty =\n-                        Place::ty_from(&src_place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Array(item_ty, const_size) = place_ty.kind {\n-                        if let Some(size) = const_size.try_eval_usize(self.tcx, self.param_env) {\n-                            assert!(size <= u32::max_value() as u64,\n-                                    \"uniform array move out doesn't supported\n-                                     for array bigger then u32\");\n-                            self.uniform(\n-                                location,\n-                                dst_place,\n-                                &src_place.base,\n-                                &src_place.projection,\n-                                item_ty,\n-                                size as u32,\n-                            );\n-                        }\n-                    }\n-\n-                }\n-            }\n-        }\n-        self.super_assign(dst_place, rvalue, location)\n-    }\n-}\n-\n-impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    fn uniform(&mut self,\n-               location: Location,\n-               dst_place: &Place<'tcx>,\n-               base: &PlaceBase<'tcx>,\n-               proj: &[PlaceElem<'tcx>],\n-               item_ty: &'tcx ty::TyS<'tcx>,\n-               size: u32) {\n-        if let [proj_base @ .., elem] = proj {\n-            match elem {\n-                // uniforms statements like_10 = move _2[:-1];\n-                ProjectionElem::Subslice{from, to} => {\n-                    self.patch.make_nop(location);\n-                    let temps : Vec<_> = (*from..(size-*to)).map(|i| {\n-                        let temp =\n-                            self.patch.new_temp(item_ty, self.body.source_info(location).span);\n-                        self.patch.add_statement(location, StatementKind::StorageLive(temp));\n-\n-                        let mut projection = proj_base.to_vec();\n-                        projection.push(ProjectionElem::ConstantIndex {\n-                            offset: i,\n-                            min_length: size,\n-                            from_end: false,\n-                        });\n-                        self.patch.add_assign(\n-                            location,\n-                            Place::from(temp),\n-                            Rvalue::Use(Operand::Move(Place {\n-                                base: base.clone(),\n-                                projection: self.tcx.intern_place_elems(&projection),\n-                            })),\n-                        );\n-                        temp\n-                    }).collect();\n-                    self.patch.add_assign(\n-                        location,\n-                        dst_place.clone(),\n-                        Rvalue::Aggregate(\n-                            box AggregateKind::Array(item_ty),\n-                            temps.iter().map(\n-                                |x| Operand::Move(Place::from(*x))\n-                            ).collect()\n-                        )\n-                    );\n-                    for temp in temps {\n-                        self.patch.add_statement(location, StatementKind::StorageDead(temp));\n-                    }\n-                }\n-                // uniforms statements like _11 = move _2[-1 of 1];\n-                ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n-                    self.patch.make_nop(location);\n-\n-                    let mut projection = proj_base.to_vec();\n-                    projection.push(ProjectionElem::ConstantIndex {\n-                        offset: size - offset,\n-                        min_length: size,\n-                        from_end: false,\n-                    });\n-                    self.patch.add_assign(\n-                        location,\n-                        dst_place.clone(),\n-                        Rvalue::Use(Operand::Move(Place {\n-                            base: base.clone(),\n-                            projection: self.tcx.intern_place_elems(&projection),\n-                        })),\n-                    );\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-// Restore Subslice move out after analysis\n-// Example:\n-//\n-//  next statements:\n-//   StorageLive(_12);\n-//   _12 = move _2[0 of 3];\n-//   StorageLive(_13);\n-//   _13 = move _2[1 of 3];\n-//   _10 = [move _12, move _13]\n-//   StorageDead(_12);\n-//   StorageDead(_13);\n-//\n-// replaced by _10 = move _2[:-1];\n-\n-pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n-    tcx: TyCtxt<'tcx>\n-}\n-\n-impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n-        let mut patch = MirPatch::new(body);\n-        let param_env = tcx.param_env(src.def_id());\n-        {\n-            let read_only_cache = read_only!(body);\n-            let mut visitor = RestoreDataCollector {\n-                locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n-                candidates: vec![],\n-            };\n-            visitor.visit_body(read_only_cache);\n-\n-            for candidate in &visitor.candidates {\n-                let statement = &body[candidate.block].statements[candidate.statement_index];\n-                if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n-                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n-                        let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(place) = item {\n-                                if let Some(local) = place.as_local() {\n-                                    let local_use = &visitor.locals_use[local];\n-                                    let opt_index_and_place =\n-                                        Self::try_get_item_source(local_use, body);\n-                                    // each local should be used twice:\n-                                    //  in assign and in aggregate statements\n-                                    if local_use.use_count == 2 && opt_index_and_place.is_some() {\n-                                        let (index, src_place) = opt_index_and_place.unwrap();\n-                                        return Some((local_use, index, src_place));\n-                                    }\n-                                }\n-                            }\n-                            None\n-                        }).collect();\n-\n-                        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n-                        let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = Place::ty_from(\n-                                src_place.base,\n-                                src_place.projection,\n-                                &**body,\n-                                tcx\n-                            ).ty;\n-                            if let ty::Array(_, ref size_o) = src_ty.kind {\n-                                size_o.try_eval_usize(tcx, param_env)\n-                            } else {\n-                                None\n-                            }\n-                        });\n-                        let restore_subslice = RestoreSubsliceArrayMoveOut { tcx };\n-                        restore_subslice\n-                            .check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n-                    }\n-                }\n-            }\n-        }\n-        patch.apply(body);\n-    }\n-}\n-\n-impl RestoreSubsliceArrayMoveOut<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        RestoreSubsliceArrayMoveOut { tcx }\n-    }\n-\n-    // Checks that source has size, all locals are inited from same source place and\n-    // indices is an integer interval. If all checks pass do the replacent.\n-    // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n-    fn check_and_patch(&self,\n-                       candidate: Location,\n-                       items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n-                       opt_size: Option<u64>,\n-                       patch: &mut MirPatch<'tcx>,\n-                       dst_place: &Place<'tcx>) {\n-        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n-\n-        if opt_size.is_some() && items.iter().all(\n-            |l| l.is_some() && l.unwrap().2 == opt_src_place.unwrap()) {\n-            let src_place = opt_src_place.unwrap();\n-\n-            let indices: Vec<_> = items.iter().map(|x| x.unwrap().1).collect();\n-            for i in 1..indices.len() {\n-                if indices[i - 1] + 1 != indices[i] {\n-                    return;\n-                }\n-            }\n-\n-            let min = *indices.first().unwrap();\n-            let max = *indices.last().unwrap();\n-\n-            for item in items {\n-                let locals_use = item.unwrap().0;\n-                patch.make_nop(locals_use.alive.unwrap());\n-                patch.make_nop(locals_use.dead.unwrap());\n-                patch.make_nop(locals_use.first_use.unwrap());\n-            }\n-            patch.make_nop(candidate);\n-            let size = opt_size.unwrap() as u32;\n-\n-            let mut projection = src_place.projection.to_vec();\n-            projection.push(ProjectionElem::Subslice { from: min, to: size - max - 1 });\n-            patch.add_assign(\n-                candidate,\n-                dst_place.clone(),\n-                Rvalue::Use(Operand::Move(Place {\n-                    base: src_place.base.clone(),\n-                    projection: self.tcx.intern_place_elems(&projection),\n-                })),\n-            );\n-        }\n-    }\n-\n-    fn try_get_item_source<'a>(local_use: &LocalUse,\n-                               body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n-        if let Some(location) = local_use.first_use {\n-            let block = &body[location.block];\n-            if block.statements.len() > location.statement_index {\n-                let statement = &block.statements[location.statement_index];\n-                if let StatementKind::Assign(\n-                    box(place, Rvalue::Use(Operand::Move(src_place)))\n-                ) = &statement.kind {\n-                    if let (Some(_), PlaceRef {\n-                        base: _,\n-                        projection: &[.., ProjectionElem::ConstantIndex {\n-                            offset, min_length: _, from_end: false\n-                        }],\n-                    }) = (place.as_local(), src_place.as_ref()) {\n-                        if let StatementKind::Assign(\n-                            box(_, Rvalue::Use(Operand::Move(place)))\n-                        ) = &statement.kind {\n-                            if let PlaceRef {\n-                                base,\n-                                projection: &[ref proj_base @ .., _],\n-                            } = place.as_ref() {\n-                                return Some((offset, PlaceRef {\n-                                    base,\n-                                    projection: proj_base,\n-                                }))\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-struct LocalUse {\n-    alive: Option<Location>,\n-    dead: Option<Location>,\n-    use_count: u32,\n-    first_use: Option<Location>,\n-}\n-\n-impl LocalUse {\n-    pub fn new() -> Self {\n-        LocalUse{alive: None, dead: None, use_count: 0, first_use: None}\n-    }\n-}\n-\n-struct RestoreDataCollector {\n-    locals_use: IndexVec<Local, LocalUse>,\n-    candidates: Vec<Location>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for RestoreDataCollector {\n-    fn visit_assign(&mut self,\n-                    place: &Place<'tcx>,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        if let Rvalue::Aggregate(box AggregateKind::Array(_), _) = *rvalue {\n-            self.candidates.push(location);\n-        }\n-        self.super_assign(place, rvalue, location)\n-    }\n-\n-    fn visit_local(&mut self,\n-                   local: &Local,\n-                   context: PlaceContext,\n-                   location: Location) {\n-        let local_use = &mut self.locals_use[*local];\n-        match context {\n-            PlaceContext::NonUse(NonUseContext::StorageLive) => local_use.alive = Some(location),\n-            PlaceContext::NonUse(NonUseContext::StorageDead) => local_use.dead = Some(location),\n-            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {}\n-            _ => {\n-                local_use.use_count += 1;\n-                if local_use.first_use.is_none() {\n-                    local_use.first_use = Some(location);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "ea7c1e7ccd0cb24e3ee95ce553394ac1ec789a6a", "filename": "src/test/mir-opt/const_prop/return_place.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freturn_place.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -21,9 +21,6 @@ fn main() {\n //         _0 = move (_1.0: u32);\n //         return;\n //     }\n-//     bb2 (cleanup): {\n-//         resume;\n-//     }\n // }\n // END rustc.add.ConstProp.before.mir\n // START rustc.add.ConstProp.after.mir\n@@ -38,9 +35,6 @@ fn main() {\n //         _0 = const 4u32;\n //         return;\n //     }\n-//     bb2 (cleanup): {\n-//         resume;\n-//     }\n // }\n // END rustc.add.ConstProp.after.mir\n // START rustc.add.PreCodegen.before.mir"}, {"sha": "f2e1864096ea974f9290d9f44a149ad1195197dd", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dc03bad73cd18e7f58d90c2fc0198e618851e5/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=96dc03bad73cd18e7f58d90c2fc0198e618851e5", "patch": "@@ -18,58 +18,12 @@ fn main() {\n \n // END RUST SOURCE\n \n-// START rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n-//     StorageLive(_6);\n-//      _6 = move _1[-1 of 1];\n-//      _0 = ();\n-// END rustc.move_out_from_end.UniformArrayMoveOut.before.mir\n-\n-// START rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n-//     StorageLive(_6);\n+// START rustc.move_out_from_end.mir_map.0.mir\n //      _6 = move _1[1 of 2];\n-//      nop;\n //      _0 = ();\n-// END rustc.move_out_from_end.UniformArrayMoveOut.after.mir\n-\n-// START rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n-//     StorageLive(_6);\n-//      _6 = move _1[0:];\n-// END rustc.move_out_by_subslice.UniformArrayMoveOut.before.mir\n-\n-// START rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n-//     StorageLive(_6);\n-//     StorageLive(_7);\n-//     _7 = move _1[0 of 2];\n-//     StorageLive(_8);\n-//     _8 = move _1[1 of 2];\n-//     _6 = [move _7, move _8];\n-//     StorageDead(_7);\n-//     StorageDead(_8);\n-//     nop;\n-//     _0 = ();\n-// END rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n-\n-// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n-//     StorageLive(_6);\n-//     StorageLive(_7);\n-//     _7 = move _1[0 of 2];\n-//     StorageLive(_8);\n-//     _8 = move _1[1 of 2];\n-//     _6 = [move _7, move _8];\n-//     StorageDead(_7);\n-//     StorageDead(_8);\n-//     _0 = ();\n-// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n+// END rustc.move_out_from_end.mir_map.0.mir\n \n-// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir\n-//     StorageLive(_6);\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     _6 = move _1[0:];\n-//     nop;\n-//     nop;\n-//     nop;\n+// START rustc.move_out_by_subslice.mir_map.0.mir\n+//     _6 = move _1[0..2];\n //     _0 = ();\n-// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir\n+// END rustc.move_out_by_subslice.mir_map.0.mir"}]}