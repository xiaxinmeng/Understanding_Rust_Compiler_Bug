{"sha": "7bccc4473c818bf826f017875189c3d45b750b11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiY2NjNDQ3M2M4MThiZjgyNmYwMTc4NzUxODljM2Q0NWI3NTBiMTE=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T12:04:06Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-08-05T12:04:06Z"}, "message": "Add a test for chains with comment", "tree": {"sha": "29373e4478412ff8d50c2ae15dc520a341898812", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29373e4478412ff8d50c2ae15dc520a341898812"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bccc4473c818bf826f017875189c3d45b750b11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bccc4473c818bf826f017875189c3d45b750b11", "html_url": "https://github.com/rust-lang/rust/commit/7bccc4473c818bf826f017875189c3d45b750b11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bccc4473c818bf826f017875189c3d45b750b11/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbfe0829d0ca4579c20c51100bb43c70f7c8e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbfe0829d0ca4579c20c51100bb43c70f7c8e2d", "html_url": "https://github.com/rust-lang/rust/commit/4bbfe0829d0ca4579c20c51100bb43c70f7c8e2d"}], "stats": {"total": 213, "additions": 213, "deletions": 0}, "files": [{"sha": "80c118d9eccbcf2af4a2742072eb659cb4b1459e", "filename": "tests/source/chains_with_comment.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7bccc4473c818bf826f017875189c3d45b750b11/tests%2Fsource%2Fchains_with_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bccc4473c818bf826f017875189c3d45b750b11/tests%2Fsource%2Fchains_with_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains_with_comment.rs?ref=7bccc4473c818bf826f017875189c3d45b750b11", "patch": "@@ -0,0 +1,95 @@\n+// Chains with comment.\n+\n+fn main() {\n+    let x = y // comment\n+        .z;\n+\n+    foo // foo\n+        // comment after parent\n+        .x\n+        .y\n+        // comment 1\n+        .bar() // comment after bar()\n+  // comment 2\n+        .foobar\n+  // comment after\n+        // comment 3\n+        .baz(x, y, z);\n+\n+    self.rev_dep_graph\n+        .iter()\n+       // Remove nodes that are not dirty\n+        .filter(|&(unit, _)| dirties.contains(&unit))\n+     // Retain only dirty dependencies of the ones that are dirty\n+       .map(|(k, deps)| {\n+            (\n+                k.clone(),\n+                deps.iter()\n+                .cloned()\n+               .filter(|d| dirties.contains(&d))\n+              .collect(),\n+            )\n+        });\n+\n+    let y = expr /* comment */.kaas()?\n+// comment\n+       .test();\n+    let loooooooooooooooooooooooooooooooooooooooooong = does_this?.look?.good?.should_we_break?.after_the_first_question_mark?;\n+    let zzzz = expr?   // comment after parent\n+// comment 0\n+.another??? // comment 1\n+.another????  // comment 2\n+.another? // comment 3\n+.another?;\n+\n+    let y = a.very .loooooooooooooooooooooooooooooooooooooong() /* comment */ .chain()\n+        .inside()  /* comment */        .weeeeeeeeeeeeeee()? .test()  .0\n+        .x;\n+\n+    parameterized(f,\n+                  substs,\n+                  def_id,\n+                  Ns::Value,\n+                  &[],\n+                  |tcx| tcx.lookup_item_type(def_id).generics)?;\n+    fooooooooooooooooooooooooooo()?.bar()?.baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz()?;\n+\n+    // #2559\n+    App::new(\"cargo-cache\")\n+.version(crate_version!())\n+.bin_name(\"cargo\")\n+.about(\"Manage cargo cache\")\n+.author(\"matthiaskrgr\")\n+.subcommand(\n+SubCommand::with_name(\"cache\")\n+.version(crate_version!())\n+.bin_name(\"cargo-cache\")\n+.about(\"Manage cargo cache\")\n+.author(\"matthiaskrgr\")\n+.arg(&list_dirs)\n+.arg(&remove_dir)\n+.arg(&gc_repos)\n+.arg(&info)\n+.arg(&keep_duplicate_crates)    .arg(&dry_run)\n+.arg(&auto_clean)\n+.arg(&auto_clean_expensive),\n+        ) // subcommand\n+        .arg(&list_dirs);\n+}\n+\n+// #2177\n+impl Foo {\n+    fn dirty_rev_dep_graph(\n+        &self,\n+        dirties: &HashSet<UnitKey>,\n+    ) -> HashMap<UnitKey, HashSet<UnitKey>> {\n+        let dirties = self.transitive_dirty_units(dirties);\n+        trace!(\"transitive_dirty_units: {:?}\", dirties);\n+\n+        self.rev_dep_graph.iter()\n+        // Remove nodes that are not dirty\n+            .filter(|&(unit, _)| dirties.contains(&unit))\n+        // Retain only dirty dependencies of the ones that are dirty\n+            .map(|(k, deps)| (k.clone(), deps.iter().cloned().filter(|d| dirties.contains(&d)).collect()))\n+    }\n+}"}, {"sha": "a1df2710234330d464bcc113c4ebcf19eee78ec4", "filename": "tests/target/chains_with_comment.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7bccc4473c818bf826f017875189c3d45b750b11/tests%2Ftarget%2Fchains_with_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bccc4473c818bf826f017875189c3d45b750b11/tests%2Ftarget%2Fchains_with_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains_with_comment.rs?ref=7bccc4473c818bf826f017875189c3d45b750b11", "patch": "@@ -0,0 +1,118 @@\n+// Chains with comment.\n+\n+fn main() {\n+    let x = y // comment\n+        .z;\n+\n+    foo // foo\n+        // comment after parent\n+        .x\n+        .y\n+        // comment 1\n+        .bar() // comment after bar()\n+        // comment 2\n+        .foobar\n+        // comment after\n+        // comment 3\n+        .baz(x, y, z);\n+\n+    self.rev_dep_graph\n+        .iter()\n+        // Remove nodes that are not dirty\n+        .filter(|&(unit, _)| dirties.contains(&unit))\n+        // Retain only dirty dependencies of the ones that are dirty\n+        .map(|(k, deps)| {\n+            (\n+                k.clone(),\n+                deps.iter()\n+                    .cloned()\n+                    .filter(|d| dirties.contains(&d))\n+                    .collect(),\n+            )\n+        });\n+\n+    let y = expr\n+        /* comment */\n+        .kaas()?\n+        // comment\n+        .test();\n+    let loooooooooooooooooooooooooooooooooooooooooong = does_this?\n+        .look?\n+        .good?\n+        .should_we_break?\n+        .after_the_first_question_mark?;\n+    let zzzz = expr? // comment after parent\n+        // comment 0\n+        .another??? // comment 1\n+        .another???? // comment 2\n+        .another? // comment 3\n+        .another?;\n+\n+    let y = a\n+        .very\n+        .loooooooooooooooooooooooooooooooooooooong()\n+        /* comment */\n+        .chain()\n+        .inside()\n+        /* comment */\n+        .weeeeeeeeeeeeeee()?\n+        .test()\n+        .0\n+        .x;\n+\n+    parameterized(f, substs, def_id, Ns::Value, &[], |tcx| {\n+        tcx.lookup_item_type(def_id).generics\n+    })?;\n+    fooooooooooooooooooooooooooo()?\n+        .bar()?\n+        .baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz()?;\n+\n+    // #2559\n+    App::new(\"cargo-cache\")\n+        .version(crate_version!())\n+        .bin_name(\"cargo\")\n+        .about(\"Manage cargo cache\")\n+        .author(\"matthiaskrgr\")\n+        .subcommand(\n+            SubCommand::with_name(\"cache\")\n+                .version(crate_version!())\n+                .bin_name(\"cargo-cache\")\n+                .about(\"Manage cargo cache\")\n+                .author(\"matthiaskrgr\")\n+                .arg(&list_dirs)\n+                .arg(&remove_dir)\n+                .arg(&gc_repos)\n+                .arg(&info)\n+                .arg(&keep_duplicate_crates)\n+                .arg(&dry_run)\n+                .arg(&auto_clean)\n+                .arg(&auto_clean_expensive),\n+        ) // subcommand\n+        .arg(&list_dirs);\n+}\n+\n+// #2177\n+impl Foo {\n+    fn dirty_rev_dep_graph(\n+        &self,\n+        dirties: &HashSet<UnitKey>,\n+    ) -> HashMap<UnitKey, HashSet<UnitKey>> {\n+        let dirties = self.transitive_dirty_units(dirties);\n+        trace!(\"transitive_dirty_units: {:?}\", dirties);\n+\n+        self.rev_dep_graph\n+            .iter()\n+            // Remove nodes that are not dirty\n+            .filter(|&(unit, _)| dirties.contains(&unit))\n+            // Retain only dirty dependencies of the ones that are dirty\n+            .map(|(k, deps)| {\n+                (\n+                    k.clone(),\n+                    deps.iter()\n+                        .cloned()\n+                        .filter(|d| dirties.contains(&d))\n+                        .collect(),\n+                )\n+            })\n+    }\n+}"}]}