{"sha": "22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "node_id": "C_kwDOAAsO6NoAKDIyYzZmMGE4YTU4NDMwNDUzNGVlNzVkYzhlZDdmNzU2NGVlZThhZTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-23T17:17:29Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-23T17:17:29Z"}, "message": "Support goto_def for intra-doc-links in macro invocations", "tree": {"sha": "6553abb2fba6e3f4e6b4d461003f2fc0b7530ace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6553abb2fba6e3f4e6b4d461003f2fc0b7530ace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "html_url": "https://github.com/rust-lang/rust/commit/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d99adc57387169df33d6e221b29f036525a7f645", "url": "https://api.github.com/repos/rust-lang/rust/commits/d99adc57387169df33d6e221b29f036525a7f645", "html_url": "https://github.com/rust-lang/rust/commit/d99adc57387169df33d6e221b29f036525a7f645"}], "stats": {"total": 157, "additions": 82, "deletions": 75}, "files": [{"sha": "adaaece719fee269928088dabff31b4866cfd626", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "patch": "@@ -19,7 +19,12 @@ use ide_db::{\n     helpers::pick_best_token,\n     RootDatabase,\n };\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, TextRange, T};\n+use syntax::{\n+    ast::{self, IsString},\n+    match_ast, AstNode, AstToken,\n+    SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n+};\n \n use crate::{\n     doc_links::intra_doc_links::{parse_intra_doc_link, strip_prefixes_suffixes},\n@@ -220,6 +225,66 @@ pub(crate) fn doc_attributes(\n     }\n }\n \n+pub(crate) struct DocCommentToken {\n+    doc_token: SyntaxToken,\n+    prefix_len: TextSize,\n+}\n+\n+pub(crate) fn token_as_doc_comment(doc_token: &SyntaxToken) -> Option<DocCommentToken> {\n+    (match_ast! {\n+        match doc_token {\n+            ast::Comment(comment) => TextSize::try_from(comment.prefix().len()).ok(),\n+            ast::String(string) => doc_token.ancestors().find_map(ast::Attr::cast)\n+                .filter(|attr| attr.simple_name().as_deref() == Some(\"doc\")).and_then(|_| string.open_quote_text_range().map(|it| it.len())),\n+            _ => None,\n+        }\n+    }).map(|prefix_len| DocCommentToken { prefix_len, doc_token: doc_token.clone() })\n+}\n+\n+impl DocCommentToken {\n+    pub(crate) fn get_definition_with_descend_at<T>(\n+        self,\n+        sema: &Semantics<RootDatabase>,\n+        offset: TextSize,\n+        // Definition, CommentOwner, range of intra doc link in original file\n+        mut cb: impl FnMut(Definition, SyntaxNode, TextRange) -> Option<T>,\n+    ) -> Option<T> {\n+        let DocCommentToken { prefix_len, doc_token } = self;\n+        // offset relative to the comments contents\n+        let original_start = doc_token.text_range().start();\n+        let relative_comment_offset = offset - original_start - prefix_len;\n+\n+        sema.descend_into_macros_many(doc_token.clone()).into_iter().find_map(|t| {\n+            let (node, descended_prefix_len) = match_ast! {\n+                match t {\n+                    ast::Comment(comment) => (t.parent()?, TextSize::try_from(comment.prefix().len()).ok()?),\n+                    ast::String(string) => (t.ancestors().skip_while(|n| n.kind() != ATTR).nth(1)?, string.open_quote_text_range()?.len()),\n+                    _ => return None,\n+                }\n+            };\n+            let token_start = t.text_range().start();\n+            let abs_in_expansion_offset = token_start + relative_comment_offset + descended_prefix_len;\n+\n+            let (attributes, def) = doc_attributes(sema, &node)?;\n+            let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n+            let (in_expansion_range, link, ns) =\n+                extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n+                    let mapped = doc_mapping.map(range)?;\n+                    (mapped.value.contains(abs_in_expansion_offset)).then(|| (mapped.value, link, ns))\n+                })?;\n+            // get the relative range to the doc/attribute in the expansion\n+            let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;\n+            // Apply relative range to the original input comment\n+            let absolute_range = in_expansion_relative_range + original_start + prefix_len;\n+            let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n+                Either::Left(it) => Definition::ModuleDef(it),\n+                Either::Right(it) => Definition::Macro(it),\n+            };\n+            cb(def, node, absolute_range)\n+        })\n+    }\n+}\n+\n fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, CowStr<'b>)> {\n     // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n     // this is fixed in the repo but not on the crates.io release yet"}, {"sha": "911998d69b5b4e321c76bc51198960cbbf87afbb", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "patch": "@@ -1,11 +1,9 @@\n use std::convert::TryInto;\n \n use crate::{\n-    display::TryToNav,\n-    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n-    FilePosition, NavigationTarget, RangeInfo,\n+    display::TryToNav, doc_links::token_as_doc_comment, FilePosition, NavigationTarget, RangeInfo,\n };\n-use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n+use hir::{AsAssocItem, ModuleDef, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::Definition,\n@@ -30,26 +28,19 @@ pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n-    let sema = Semantics::new(db);\n+    let sema = &Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let original_token =\n         pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n             IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | COMMENT => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         })?;\n-    if let Some(_) = ast::Comment::cast(original_token.clone()) {\n-        let parent = original_token.parent()?;\n-        let (attributes, def) = doc_attributes(&sema, &parent)?;\n-        let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n-        let (_, link, ns) =\n-            extract_definitions_from_docs(&docs).into_iter().find(|&(range, ..)| {\n-                doc_mapping.map(range).map_or(false, |InFile { file_id, value: range }| {\n-                    file_id == position.file_id.into() && range.contains(position.offset)\n-                })\n-            })?;\n-        let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n-        return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n+    if let Some(doc_comment) = token_as_doc_comment(&original_token) {\n+        return doc_comment.get_definition_with_descend_at(sema, position.offset, |def, _, _| {\n+            let nav = def.try_to_nav(db)?;\n+            Some(RangeInfo::new(original_token.text_range(), vec![nav]))\n+        });\n     }\n     let navs = sema\n         .descend_into_macros_many(original_token.clone())"}, {"sha": "4b7043bd9b7ab2bbd37f3f26225cbe962bb5624d", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 8, "deletions": 57, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c6f0a8a584304534ee75dc8ed7f7564eee8ae6/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=22c6f0a8a584304534ee75dc8ed7f7564eee8ae6", "patch": "@@ -1,4 +1,4 @@\n-use std::{convert::TryFrom, iter};\n+use std::iter;\n \n use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n@@ -14,20 +14,13 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo,\n-    ast::{self, IsString},\n-    display::fn_as_proc_macro_label,\n-    match_ast, AstNode, AstToken, Direction,\n-    SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextSize, T,\n+    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n     display::{macro_label, TryToNav},\n-    doc_links::{\n-        doc_attributes, extract_definitions_from_docs, remove_links, resolve_doc_path_for_def,\n-        rewrite_links,\n-    },\n+    doc_links::{remove_links, rewrite_links, token_as_doc_comment},\n     markdown_remove::remove_markdown,\n     markup::Markup,\n     runnables::{runnable_fn, runnable_mod},\n@@ -118,57 +111,15 @@ pub(crate) fn hover(\n         _ => 1,\n     })?;\n \n-    let descended = sema.descend_into_macros_many(original_token.clone());\n-    // magic intra doc link handling\n-    // FIXME: Lift this out to some other place, goto def wants this as well\n-    let comment_prefix_len = match_ast! {\n-        match original_token {\n-            ast::Comment(comment) => TextSize::try_from(comment.prefix().len()).ok(),\n-            ast::String(string) => original_token.ancestors().find_map(ast::Attr::cast)\n-                .filter(|attr| attr.simple_name().as_deref() == Some(\"doc\")).and_then(|_| string.open_quote_text_range().map(|it| it.len())),\n-            _ => None,\n-        }\n-    };\n-    if let Some(prefix_len) = comment_prefix_len {\n+    if let Some(doc_comment) = token_as_doc_comment(&original_token) {\n         cov_mark::hit!(no_highlight_on_comment_hover);\n-\n-        // offset relative to the comments contents\n-        let original_start = original_token.text_range().start();\n-        let relative_comment_offset = offset - original_start - prefix_len;\n-\n-        return descended.iter().find_map(|t| {\n-            let (node, descended_prefix_len) = match_ast! {\n-                match t {\n-                    ast::Comment(comment) => (t.parent()?, TextSize::try_from(comment.prefix().len()).ok()?),\n-                    ast::String(string) => (t.ancestors().skip_while(|n| n.kind() != ATTR).nth(1)?, string.open_quote_text_range()?.len()),\n-                    _ => return None,\n-                }\n-            };\n-            let token_start = t.text_range().start();\n-            let abs_in_expansion_offset = token_start + relative_comment_offset + descended_prefix_len;\n-\n-            let (attributes, def) = doc_attributes(sema, &node)?;\n-            let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n-            let (in_expansion_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n-                |(range, link, ns)| {\n-                    let mapped = doc_mapping.map(range)?;\n-                    (mapped.value.contains(abs_in_expansion_offset))\n-                        .then(|| (mapped.value, link, ns))\n-                },\n-            )?;\n-            // get the relative range to the doc/attribute in the expansion\n-            let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;\n-            // Apply relative range to the original input comment\n-            let absolute_range = in_expansion_relative_range + original_start + prefix_len;\n-            let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n-                Either::Left(it) => Definition::ModuleDef(it),\n-                Either::Right(it) => Definition::Macro(it),\n-            };\n+        return doc_comment.get_definition_with_descend_at(sema, offset, |def, node, range| {\n             let res = hover_for_definition(sema, file_id, def, &node, config)?;\n-            Some(RangeInfo::new(absolute_range, res))\n+            Some(RangeInfo::new(range, res))\n         });\n     }\n \n+    let descended = sema.descend_into_macros_many(original_token.clone());\n     // attributes, require special machinery as they are mere ident tokens\n \n     // FIXME: Definition should include known lints and the like instead of having this special case here"}]}