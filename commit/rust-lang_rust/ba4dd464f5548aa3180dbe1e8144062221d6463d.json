{"sha": "ba4dd464f5548aa3180dbe1e8144062221d6463d", "node_id": "C_kwDOAAsO6NoAKGJhNGRkNDY0ZjU1NDhhYTMxODBkYmUxZTgxNDQwNjIyMjFkNjQ2M2Q", "commit": {"author": {"name": "Tavian Barnes", "email": "tavianator@tavianator.com", "date": "2022-12-12T22:06:13Z"}, "committer": {"name": "Tavian Barnes", "email": "tavianator@tavianator.com", "date": "2022-12-12T22:17:26Z"}, "message": "fs: Fix #50619 (again) and add a regression test\n\nBug #50619 was fixed by adding an end_of_stream flag in #50630.\nUnfortunately, that fix only applied to the readdir_r() path.  When I\nswitched Linux to use readdir() in #92778, I inadvertently reintroduced\nthe bug on that platform.  Other platforms that had always used\nreaddir() were presumably never fixed.\n\nThis patch enables end_of_stream for all platforms, and adds a\nLinux-specific regression test that should hopefully prevent the bug\nfrom being reintroduced again.", "tree": {"sha": "53271b870a3174893668c21ff17a0ddb2acaa7b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53271b870a3174893668c21ff17a0ddb2acaa7b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba4dd464f5548aa3180dbe1e8144062221d6463d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba4dd464f5548aa3180dbe1e8144062221d6463d", "html_url": "https://github.com/rust-lang/rust/commit/ba4dd464f5548aa3180dbe1e8144062221d6463d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba4dd464f5548aa3180dbe1e8144062221d6463d/comments", "author": {"login": "tavianator", "id": 1692591, "node_id": "MDQ6VXNlcjE2OTI1OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1692591?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavianator", "html_url": "https://github.com/tavianator", "followers_url": "https://api.github.com/users/tavianator/followers", "following_url": "https://api.github.com/users/tavianator/following{/other_user}", "gists_url": "https://api.github.com/users/tavianator/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavianator/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavianator/subscriptions", "organizations_url": "https://api.github.com/users/tavianator/orgs", "repos_url": "https://api.github.com/users/tavianator/repos", "events_url": "https://api.github.com/users/tavianator/events{/privacy}", "received_events_url": "https://api.github.com/users/tavianator/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tavianator", "id": 1692591, "node_id": "MDQ6VXNlcjE2OTI1OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1692591?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavianator", "html_url": "https://github.com/tavianator", "followers_url": "https://api.github.com/users/tavianator/followers", "following_url": "https://api.github.com/users/tavianator/following{/other_user}", "gists_url": "https://api.github.com/users/tavianator/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavianator/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavianator/subscriptions", "organizations_url": "https://api.github.com/users/tavianator/orgs", "repos_url": "https://api.github.com/users/tavianator/repos", "events_url": "https://api.github.com/users/tavianator/events{/privacy}", "received_events_url": "https://api.github.com/users/tavianator/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37d7de337903a558dbeb1e82c844fe915ab8ff25", "url": "https://api.github.com/repos/rust-lang/rust/commits/37d7de337903a558dbeb1e82c844fe915ab8ff25", "html_url": "https://github.com/rust-lang/rust/commit/37d7de337903a558dbeb1e82c844fe915ab8ff25"}], "stats": {"total": 83, "additions": 45, "deletions": 38}, "files": [{"sha": "6d42adca5314a5681aa3d0ff3500a193302a6992", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba4dd464f5548aa3180dbe1e8144062221d6463d/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba4dd464f5548aa3180dbe1e8144062221d6463d/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=ba4dd464f5548aa3180dbe1e8144062221d6463d", "patch": "@@ -1567,3 +1567,29 @@ fn test_eq_direntry_metadata() {\n         assert_eq!(ft1, ft2);\n     }\n }\n+\n+/// Regression test for https://github.com/rust-lang/rust/issues/50619.\n+#[test]\n+#[cfg(target_os = \"linux\")]\n+fn test_read_dir_infinite_loop() {\n+    use crate::process::Command;\n+    use crate::thread::sleep;\n+    use crate::time::Duration;\n+\n+    // Create a child process\n+    let Ok(child) = Command::new(\"echo\").spawn() else { return };\n+\n+    // Wait for it to (probably) become a zombie.  We can't use wait() because\n+    // that will reap the process.\n+    sleep(Duration::from_millis(10));\n+\n+    // open() on this path will succeed, but readdir() will fail\n+    let id = child.id();\n+    let path = format!(\"/proc/{id}/net\");\n+\n+    // Skip the test if we can't open the directory in the first place\n+    let Ok(dir) = fs::read_dir(path) else { return };\n+\n+    // Iterate through the directory\n+    for _ in dir {}\n+}"}, {"sha": "26a99f913774232b9a73c506c8a0416748398aba", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ba4dd464f5548aa3180dbe1e8144062221d6463d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba4dd464f5548aa3180dbe1e8144062221d6463d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=ba4dd464f5548aa3180dbe1e8144062221d6463d", "patch": "@@ -243,17 +243,15 @@ struct InnerReadDir {\n \n pub struct ReadDir {\n     inner: Arc<InnerReadDir>,\n-    #[cfg(not(any(\n-        target_os = \"android\",\n-        target_os = \"linux\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-        target_os = \"fuchsia\",\n-        target_os = \"redox\",\n-    )))]\n     end_of_stream: bool,\n }\n \n+impl ReadDir {\n+    fn new(inner: InnerReadDir) -> Self {\n+        Self { inner: Arc::new(inner), end_of_stream: false }\n+    }\n+}\n+\n struct Dir(*mut libc::DIR);\n \n unsafe impl Send for Dir {}\n@@ -594,6 +592,10 @@ impl Iterator for ReadDir {\n         target_os = \"illumos\"\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        if self.end_of_stream {\n+            return None;\n+        }\n+\n         unsafe {\n             loop {\n                 // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n@@ -604,8 +606,12 @@ impl Iterator for ReadDir {\n                 super::os::set_errno(0);\n                 let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n-                    // null can mean either the end is reached or an error occurred.\n-                    // So we had to clear errno beforehand to check for an error now.\n+                    // We either encountered an error, or reached the end.  Either way,\n+                    // the next call to next() should return None.\n+                    self.end_of_stream = true;\n+\n+                    // To distinguish between errors and end-of-directory, we had to clear\n+                    // errno beforehand to check for an error now.\n                     return match super::os::errno() {\n                         0 => None,\n                         e => Some(Err(Error::from_raw_os_error(e))),\n@@ -1363,18 +1369,7 @@ pub fn readdir(path: &Path) -> io::Result<ReadDir> {\n     } else {\n         let root = path.to_path_buf();\n         let inner = InnerReadDir { dirp: Dir(ptr), root };\n-        Ok(ReadDir {\n-            inner: Arc::new(inner),\n-            #[cfg(not(any(\n-                target_os = \"android\",\n-                target_os = \"linux\",\n-                target_os = \"solaris\",\n-                target_os = \"illumos\",\n-                target_os = \"fuchsia\",\n-                target_os = \"redox\",\n-            )))]\n-            end_of_stream: false,\n-        })\n+        Ok(ReadDir::new(inner))\n     }\n }\n \n@@ -1755,7 +1750,6 @@ mod remove_dir_impl {\n     use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n     use crate::os::unix::prelude::{OwnedFd, RawFd};\n     use crate::path::{Path, PathBuf};\n-    use crate::sync::Arc;\n     use crate::sys::common::small_c_string::run_path_with_cstr;\n     use crate::sys::{cvt, cvt_r};\n \n@@ -1827,21 +1821,8 @@ mod remove_dir_impl {\n         // a valid root is not needed because we do not call any functions involving the full path\n         // of the DirEntrys.\n         let dummy_root = PathBuf::new();\n-        Ok((\n-            ReadDir {\n-                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n-                #[cfg(not(any(\n-                    target_os = \"android\",\n-                    target_os = \"linux\",\n-                    target_os = \"solaris\",\n-                    target_os = \"illumos\",\n-                    target_os = \"fuchsia\",\n-                    target_os = \"redox\",\n-                )))]\n-                end_of_stream: false,\n-            },\n-            new_parent_fd,\n-        ))\n+        let inner = InnerReadDir { dirp, root: dummy_root };\n+        Ok((ReadDir::new(inner), new_parent_fd))\n     }\n \n     #[cfg(any("}]}