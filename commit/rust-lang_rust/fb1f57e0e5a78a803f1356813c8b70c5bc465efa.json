{"sha": "fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMWY1N2UwZTVhNzhhODAzZjEzNTY4MTNjOGI3MGM1YmM0NjVlZmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-06T23:39:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-06T23:39:25Z"}, "message": "Rollup merge of #63034 - tmandry:reduce-generator-size-regressions, r=cramertj\n\nFix generator size regressions due to optimization\n\nI tested the generator optimizations in #60187 and #61922 on the Fuchsia\nbuild, and noticed that some small generators (about 8% of the async fns\nin our build) increased in size slightly.\n\nThis is because in #60187 we split the fields into two groups, a\n\"prefix\" non-overlap region and an overlap region, and lay them out\nseparately. This can introduce unnecessary padding bytes between the two\ngroups.\n\nIn every single case in the Fuchsia build, it was due to there being\nonly a single variant being used in the overlap region. This means that\nwe aren't doing any overlapping, period. So it's better to combine the\ntwo regions into one and lay out all the fields at once, which is what\nthis change does.\n\nr? @cramertj\ncc @eddyb @Zoxc", "tree": {"sha": "62426d9c56447eb1b513aa9224b7630e8d32e1b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62426d9c56447eb1b513aa9224b7630e8d32e1b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdSg+uCRBK7hj4Ov3rIwAAdHIIACwggFmYSkGbyMeDKLq0GQM1\nKJiUrtUVjEXwuuBalE0/33/VSle2+RnzW67gCFKOcSnp9vY173yQTF5wFqFiPvr2\niNj3leSoqot8lUIiW0EBdTmQa+pK9sw5soT2xgl9IsyhuS71hXXLOdiFtcL5lLI4\niSaCFXEtAOBHKAzfszlIUtN2bMMn1/OTSkIPYuN745ryQXYSY6i+y5VoWqUbtxIK\niUF0rXr7YlH+7ZRCm9k8MFQTbFcJkJ1Ocymzs0P2PZKU20qs41F0KO5Umm4xyxWD\nCxyTxfU2g6J/galDYPiCyeAN9KSN8BMyFWnacIUWcCNpJIvVV4IO0SWGsCo+JbA=\n=8jPo\n-----END PGP SIGNATURE-----\n", "payload": "tree 62426d9c56447eb1b513aa9224b7630e8d32e1b2\nparent 6a91782b72fca586b15ba68364bc7baab837af86\nparent b40788e89fac38781ddb838bb4fb0d706a6a3546\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565134765 +0200\ncommitter GitHub <noreply@github.com> 1565134765 +0200\n\nRollup merge of #63034 - tmandry:reduce-generator-size-regressions, r=cramertj\n\nFix generator size regressions due to optimization\n\nI tested the generator optimizations in #60187 and #61922 on the Fuchsia\nbuild, and noticed that some small generators (about 8% of the async fns\nin our build) increased in size slightly.\n\nThis is because in #60187 we split the fields into two groups, a\n\"prefix\" non-overlap region and an overlap region, and lay them out\nseparately. This can introduce unnecessary padding bytes between the two\ngroups.\n\nIn every single case in the Fuchsia build, it was due to there being\nonly a single variant being used in the overlap region. This means that\nwe aren't doing any overlapping, period. So it's better to combine the\ntwo regions into one and lay out all the fields at once, which is what\nthis change does.\n\nr? @cramertj\ncc @eddyb @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "html_url": "https://github.com/rust-lang/rust/commit/fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a91782b72fca586b15ba68364bc7baab837af86", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a91782b72fca586b15ba68364bc7baab837af86", "html_url": "https://github.com/rust-lang/rust/commit/6a91782b72fca586b15ba68364bc7baab837af86"}, {"sha": "b40788e89fac38781ddb838bb4fb0d706a6a3546", "url": "https://api.github.com/repos/rust-lang/rust/commits/b40788e89fac38781ddb838bb4fb0d706a6a3546", "html_url": "https://github.com/rust-lang/rust/commit/b40788e89fac38781ddb838bb4fb0d706a6a3546"}], "stats": {"total": 85, "additions": 75, "deletions": 10}, "files": [{"sha": "8d064de6f4751da48c1dc68fd33ef8fdd1f0d1f7", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "patch": "@@ -209,6 +209,8 @@ use crate::mem::ManuallyDrop;\n /// guarantee may evolve.\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+// Lang item so we can wrap other types in it. This is useful for generators.\n+#[cfg_attr(not(bootstrap), lang = \"maybe_uninit\")]\n #[derive(Copy)]\n #[repr(transparent)]\n pub union MaybeUninit<T> {"}, {"sha": "c5c8639324358123035b0f1bcf2145254b56d8da", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "patch": "@@ -365,6 +365,8 @@ language_item_table! {\n \n     ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n \n+    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n+\n     DebugTraitLangItem,          \"debug_trait\",        debug_trait,             Target::Trait;\n \n     // Align offset for stride != 1, must not panic."}, {"sha": "dadc126eba48ec062c2cb0e16d900edbc6e51d18", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "patch": "@@ -2347,18 +2347,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Foreign(def_id))\n     }\n \n-    pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n-        let adt_def = self.adt_def(def_id);\n-        let substs = InternalSubsts::for_item(self, def_id, |param, substs| {\n+    fn mk_generic_adt(self, wrapper_def_id: DefId, ty_param: Ty<'tcx>) -> Ty<'tcx> {\n+        let adt_def = self.adt_def(wrapper_def_id);\n+        let substs = InternalSubsts::for_item(self, wrapper_def_id, |param, substs| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime |\n                 GenericParamDefKind::Const => {\n                     bug!()\n                 }\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if param.index == 0 {\n-                        ty.into()\n+                        ty_param.into()\n                     } else {\n                         assert!(has_default);\n                         self.type_of(param.def_id).subst(self, substs).into()\n@@ -2369,6 +2368,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Adt(adt_def, substs))\n     }\n \n+    #[inline]\n+    pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n+    #[inline]\n+    pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n     #[inline]\n     pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(RawPtr(tm))"}, {"sha": "1c9a5ad621854b7bfd887eb79742098ec7118d34", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "patch": "@@ -1368,6 +1368,27 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n         }\n \n+        // Count the number of variants in use. If only one of them, then it is\n+        // impossible to overlap any locals in our layout. In this case it's\n+        // always better to make the remaining locals ineligible, so we can\n+        // lay them out with the other locals in the prefix and eliminate\n+        // unnecessary padding bytes.\n+        {\n+            let mut used_variants = BitSet::new_empty(info.variant_fields.len());\n+            for assignment in &assignments {\n+                match assignment {\n+                    Assigned(idx) => { used_variants.insert(*idx); }\n+                    _ => {}\n+                }\n+            }\n+            if used_variants.count() < 2 {\n+                for assignment in assignments.iter_mut() {\n+                    *assignment = Ineligible(None);\n+                }\n+                ineligible_locals.insert_all();\n+            }\n+        }\n+\n         // Write down the order of our locals that will be promoted to the prefix.\n         {\n             let mut idx = 0u32;\n@@ -1406,24 +1427,21 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             Abi::Scalar(s) => s.clone(),\n             _ => bug!(),\n         };\n-        // FIXME(eddyb) wrap each promoted type in `MaybeUninit` so that they\n-        // don't poison the `largest_niche` or `abi` fields of `prefix`.\n         let promoted_layouts = ineligible_locals.iter()\n             .map(|local| subst_field(info.field_tys[local]))\n+            .map(|ty| tcx.mk_maybe_uninit(ty))\n             .map(|ty| self.layout_of(ty));\n         let prefix_layouts = substs.prefix_tys(def_id, tcx)\n             .map(|ty| self.layout_of(ty))\n             .chain(iter::once(Ok(discr_layout)))\n             .chain(promoted_layouts)\n             .collect::<Result<Vec<_>, _>>()?;\n-        let mut prefix = self.univariant_uninterned(\n+        let prefix = self.univariant_uninterned(\n             ty,\n             &prefix_layouts,\n             &ReprOptions::default(),\n             StructKind::AlwaysSized,\n         )?;\n-        // FIXME(eddyb) need `MaybeUninit` around promoted types (see above).\n-        prefix.largest_niche = None;\n \n         let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n "}, {"sha": "9a644ed44a670b81cfe02d019a55c46b8fcd11f9", "filename": "src/test/run-pass/generator/niche-in-generator.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Ftest%2Frun-pass%2Fgenerator%2Fniche-in-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Ftest%2Frun-pass%2Fgenerator%2Fniche-in-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fniche-in-generator.rs?ref=fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "patch": "@@ -0,0 +1,17 @@\n+// Test that niche finding works with captured generator upvars.\n+\n+#![feature(generators)]\n+\n+use std::mem::size_of_val;\n+\n+fn take<T>(_: T) {}\n+\n+fn main() {\n+    let x = false;\n+    let gen1 = || {\n+        yield;\n+        take(x);\n+    };\n+\n+    assert_eq!(size_of_val(&gen1), size_of_val(&Some(gen1)));\n+}"}, {"sha": "8f4254b10ceafec8485651b0d2d692fa62887c78", "filename": "src/test/ui/async-await/issues/issue-59972.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1f57e0e5a78a803f1356813c8b70c5bc465efa/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-59972.rs?ref=fb1f57e0e5a78a803f1356813c8b70c5bc465efa", "patch": "@@ -1,3 +1,7 @@\n+// Incorrect handling of uninhabited types could cause us to mark generator\n+// types as entirely uninhabited, when they were in fact constructible. This\n+// caused us to hit \"unreachable\" code (illegal instruction on x86).\n+\n // run-pass\n \n // compile-flags: --edition=2018\n@@ -19,7 +23,18 @@ async fn contains_never() {\n     let error2 = error;\n }\n \n+#[allow(unused)]\n+async fn overlap_never() {\n+    let error1 = uninhabited_async();\n+    noop().await;\n+    let error2 = uninhabited_async();\n+    drop(error1);\n+    noop().await;\n+    drop(error2);\n+}\n+\n #[allow(unused_must_use)]\n fn main() {\n     contains_never();\n+    overlap_never();\n }"}]}