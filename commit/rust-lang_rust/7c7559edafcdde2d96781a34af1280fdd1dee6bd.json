{"sha": "7c7559edafcdde2d96781a34af1280fdd1dee6bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzU1OWVkYWZjZGRlMmQ5Njc4MWEzNGFmMTI4MGZkZDFkZWU2YmQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-05T19:46:38Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-06T22:44:43Z"}, "message": "Disallow variable names that shadow tags in scope\n\nNow, if you have a tag named \"foo\", a variable declaration like\n\"let foo...\" is illegal. This change makes it possible to eliminate\nthe '.' after a nullary tag pattern in an alt (but I'll be doing\nthat in a future commit) -- as now it's always obvious whether a\nname refers to a tag or a new declared variable.\n\nresolve implements this change -- all the other changes are just to\nget rid of existing code that declares variables that shadow tag\nnames.", "tree": {"sha": "167b04cf99e3e4f00d28f0dc44e0984f4938134c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167b04cf99e3e4f00d28f0dc44e0984f4938134c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c7559edafcdde2d96781a34af1280fdd1dee6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7559edafcdde2d96781a34af1280fdd1dee6bd", "html_url": "https://github.com/rust-lang/rust/commit/7c7559edafcdde2d96781a34af1280fdd1dee6bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c7559edafcdde2d96781a34af1280fdd1dee6bd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da519c8587c46ec519fada1aee7cc32ed2c1cd6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/da519c8587c46ec519fada1aee7cc32ed2c1cd6a", "html_url": "https://github.com/rust-lang/rust/commit/da519c8587c46ec519fada1aee7cc32ed2c1cd6a"}], "stats": {"total": 239, "additions": 170, "deletions": 69}, "files": [{"sha": "e339f4bc92e7f41935f5884c7e96f63934f39d6d", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -305,13 +305,13 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n }\n \n fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n-    let mut;\n+    let m;\n     alt peek(st) as char {\n-      'm' { next(st); mut = ast::mut; }\n-      '?' { next(st); mut = ast::maybe_mut; }\n-      _ { mut = ast::imm; }\n+      'm' { next(st); m = ast::mut; }\n+      '?' { next(st); m = ast::maybe_mut; }\n+      _ { m = ast::imm; }\n     }\n-    ret {ty: parse_ty(st, conv), mut: mut};\n+    ret {ty: parse_ty(st, conv), mut: m};\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {"}, {"sha": "f783943c0dcd5a6eb79488db79ef1f458ff2ec20", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -220,18 +220,18 @@ fn join_branches(branches: [set]) -> set {\n         i += 1u;\n         for {def, exprs} in set {\n             if !vec::any(found, {|v| v.def == def}) {\n-                let j = i, ne = exprs;\n+                let j = i, nne = exprs;\n                 while j < l {\n                     for {def: d2, exprs} in branches[j] {\n                         if d2 == def {\n                             list::iter(exprs) {|e|\n-                                if !list::has(ne, e) { ne = cons(e, @ne); }\n+                                if !list::has(nne, e) { nne = cons(e, @nne); }\n                             }\n                         }\n                     }\n                     j += 1u;\n                 }\n-                found += [{def: def, exprs: ne}];\n+                found += [{def: def, exprs: nne}];\n             }\n         }\n     }"}, {"sha": "24c8b2e204e2544b6141383e85434e6abe89646d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 141, "deletions": 54, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -69,7 +69,7 @@ fn new_ext_hash() -> ext_hash {\n     fn hash(v: key) -> uint {\n         ret str::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n-                  ns_value. { 1u }\n+                  ns_val(_) { 1u }\n                   ns_type. { 2u }\n                   ns_module. { 3u }\n                 };\n@@ -86,7 +86,7 @@ fn new_exp_hash() -> exp_map {\n     fn hash(v: key) -> uint {\n         ret str::hash(v.path) +\n                 alt v.ns {\n-                  ns_value. { 1u }\n+                  ns_val(_) { 1u }\n                   ns_type. { 2u }\n                   ns_module. { 3u }\n                 };\n@@ -152,7 +152,12 @@ type env =\n // since export restrictions should only be applied for the former.\n tag dir { inside; outside; }\n \n-tag namespace { ns_value; ns_type; ns_module; }\n+// There are two types of ns_value tag: \"definitely a tag\";\n+// and \"any value\". This is so that lookup can behave differently\n+// when looking up a variable name that's not yet in scope to check\n+// if it's already bound to a tag.\n+tag namespace { ns_val(ns_value_type); ns_type; ns_module; }\n+tag ns_value_type { ns_a_tag; ns_any_value; }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -322,7 +327,7 @@ fn check_unused_imports(e: @env) {\n \n fn resolve_capture_item(e: @env, sc: scopes, &&cap_item: @ast::capture_item) {\n     let dcur = lookup_in_scope_strict(\n-        *e, sc, cap_item.span, cap_item.name, ns_value);\n+        *e, sc, cap_item.span, cap_item.name, ns_val(ns_any_value));\n     maybe_insert(e, cap_item.id, dcur);\n }\n \n@@ -338,6 +343,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_block: visit_block_with_scope,\n           visit_decl: visit_decl_with_scope,\n           visit_arm: visit_arm_with_scope,\n+          visit_local: bind visit_local_with_scope(e, _, _, _),\n           visit_pat: bind walk_pat(e, _, _, _),\n           visit_expr: bind walk_expr(e, _, _, _),\n           visit_ty: bind walk_ty(e, _, _, _),\n@@ -355,7 +361,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           ast::expr_path(p) {\n             maybe_insert(e, exp.id,\n                          lookup_path_strict(*e, sc, exp.span, p.node,\n-                                            ns_value));\n+                                            ns_val(ns_any_value)));\n           }\n           ast::expr_fn(_, _, _, cap_clause) {\n             let rci = bind resolve_capture_item(e, sc, _);\n@@ -391,13 +397,15 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     }\n     fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id, sc: scopes,\n                    _v: vt<scopes>) {\n-        maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n+        maybe_insert(e, id, lookup_path_strict(*e, sc,\n+                         sp, p.node, ns_val(ns_any_value)));\n     }\n     fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_tag(p, _) {\n-            let fnd = lookup_path_strict(*e, sc, p.span, p.node, ns_value);\n+            let fnd = lookup_path_strict(*e, sc, p.span, p.node,\n+                                           ns_val(ns_any_value));\n             alt option::get(fnd) {\n               ast::def_variant(did, vid) {\n                 e.def_map.insert(pat.id, option::get(fnd));\n@@ -537,6 +545,34 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n     }\n }\n \n+fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n+    // Checks whether the given local has the same name as a tag that's\n+    // in scope\n+    // We disallow this, in order to make alt patterns consisting of\n+    // a single identifier unambiguous (does the pattern \"foo\" refer\n+    // to tag foo, or is it binding a new name foo?)\n+    alt loc.node.pat.node {\n+      pat_bind(an_ident,_) {\n+          // Be sure to pass ns_a_tag to lookup_in_scope so that\n+          // if this is a name that's being shadowed, we don't die\n+          alt lookup_in_scope(*e, sc, loc.span, an_ident, ns_val(ns_a_tag)) {\n+              some(ast::def_variant(tag_id,variant_id)) {\n+                  // Declaration shadows a tag that's in scope.\n+                  // That's an error.\n+                  e.sess.span_err(loc.span,\n+                    #fmt(\"Declaration of %s shadows a tag that's in scope\",\n+                         an_ident));\n+                  }\n+              _ {}\n+          }\n+      }\n+      _ {}\n+    }\n+\n+    visit::visit_local(loc, sc, v);\n+}\n+\n+\n fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n    option::t<def> {\n     let path_len = vec::len(path);\n@@ -563,7 +599,8 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n \n fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n     let new_def =\n-        lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_value);\n+        lookup_path_strict(*e, sc, c.span, c.node.path.node,\n+                           ns_val(ns_any_value));\n     if option::is_some(new_def) {\n         alt option::get(new_def) {\n           ast::def_fn(pred_id, ast::pure_fn.) {\n@@ -584,7 +621,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: block(namespace) -> option::t<def>,\n                 impls: [@_impl]) {\n-        let val = lookup(ns_value), typ = lookup(ns_type),\n+        let val = lookup(ns_val(ns_any_value)), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) &&\n            vec::len(impls) == 0u {\n@@ -688,9 +725,14 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n // Utilities\n fn ns_name(ns: namespace) -> str {\n     alt ns {\n-      ns_type. { ret \"typename\"; }\n-      ns_value. { ret \"name\"; }\n-      ns_module. { ret \"modulename\"; }\n+      ns_type. { \"typename\" }\n+      ns_val(v) {\n+          alt (v) {\n+              ns_any_value. { \"name\" }\n+              ns_a_tag.     { \"tag\" }\n+          }\n+      }\n+      ns_module. { ret \"modulename\" }\n     }\n }\n \n@@ -857,7 +899,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             }\n           }\n           scope_method(id, tps) {\n-            if (name == \"self\" && ns == ns_value) {\n+            if (name == \"self\" && ns == ns_val(ns_any_value)) {\n                 ret some(ast::def_self(local_def(id)));\n             } else if ns == ns_type {\n                 ret lookup_in_ty_params(e, name, tps);\n@@ -875,7 +917,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             ret lookup_in_fn(e, name, decl, ty_params, ns);\n           }\n           scope_loop(local) {\n-            if ns == ns_value {\n+            if ns == ns_val(ns_any_value) {\n                 alt lookup_in_pat(name, local.node.pat) {\n                   some(did) { ret some(ast::def_binding(did)); }\n                   _ { }\n@@ -886,7 +928,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             ret lookup_in_block(e, name, sp, b.node, *pos, *loc, ns);\n           }\n           scope_arm(a) {\n-            if ns == ns_value {\n+            if ns == ns_val(ns_any_value) {\n                 alt lookup_in_pat(name, a.pats[0]) {\n                   some(did) { ret some(ast::def_binding(did)); }\n                   _ { ret none; }\n@@ -916,6 +958,19 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                           ns_type. {\n                             \"Attempt to use a type argument out of scope\"\n                           }\n+                          ns_val(v) {\n+                              alt(v) {\n+                                  ns_a_tag. {\n+                              /* If we were looking for a tag, at this point\n+                                 we know it's bound to a non-tag value, and\n+                                 we can return none instead of failing */\n+                                      ret none;\n+                                  }\n+                                  _ {\n+                                      \"attempted dynamic environment-capture\"\n+                                  }\n+                              }\n+                          }\n                           _ { \"attempted dynamic environment-capture\" }\n                         };\n                     e.sess.span_fatal(sp, msg);\n@@ -933,7 +988,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             }\n             if left_fn {\n                 left_fn_level2 = true;\n-            } else if ns == ns_value || ns == ns_type {\n+            } else if ns != ns_module {\n                 left_fn = scope_is_fn(hd);\n                 alt scope_closes(hd) {\n                   some(node_id) { closing += [node_id]; }\n@@ -972,7 +1027,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ty_params: [ast::ty_param],\n                 ns: namespace) -> option::t<def> {\n     alt ns {\n-      ns_value. {\n+      ns_val(ns_any_value.) {\n         for a: ast::arg in decl.inputs {\n             if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(local_def(a.id), a.mode));\n@@ -989,10 +1044,11 @@ fn lookup_in_obj(e: env, name: ident, ob: ast::_obj,\n                  ty_params: [ast::ty_param],\n                  ns: namespace, id: node_id) -> option::t<def> {\n     alt ns {\n-      ns_value. {\n-        if name == \"self\" { ret some(ast::def_self(local_def(id))); }\n+      ns_val(val_ty) {\n+        if name == \"self\" && val_ty == ns_any_value\n+           { ret some(ast::def_self(local_def(id))); }\n         for f: ast::obj_field in ob.fields {\n-            if str::eq(f.ident, name) {\n+            if str::eq(f.ident, name) && val_ty == ns_any_value {\n                 ret some(ast::def_obj_field(local_def(f.id), f.mut));\n             }\n         }\n@@ -1018,7 +1074,8 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                     while j > 0u {\n                         j -= 1u;\n                         let (style, loc) = locs[j];\n-                        if ns == ns_value && (i < pos || j < loc_pos) {\n+                        if ns == ns_val(ns_any_value)\n+                                     && (i < pos || j < loc_pos) {\n                             alt lookup_in_pat(name, loc.node.pat) {\n                               some(did) {\n                                 ret some(ast::def_local(did, style));\n@@ -1036,13 +1093,18 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                         if str::eq(it.ident, name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n                         }\n-                    } else if ns == ns_value {\n-                        for v: ast::variant in variants {\n-                            if str::eq(v.node.name, name) {\n-                                let i = v.node.id;\n-                                ret some(ast::def_variant(local_def(it.id),\n-                                                          local_def(i)));\n-                            }\n+                    } else {\n+                        alt ns {\n+                           ns_val(_) {\n+                               for v: ast::variant in variants {\n+                                  if str::eq(v.node.name, name) {\n+                                     let i = v.node.id;\n+                                     ret some(ast::def_variant\n+                                        (local_def(it.id), local_def(i)));\n+                                  }\n+                               }\n+                          }\n+                           _ {}\n                         }\n                     }\n                   }\n@@ -1088,10 +1150,11 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n     alt i.node {\n       ast::item_const(_, _) {\n-        if ns == ns_value { ret some(ast::def_const(local_def(i.id))); }\n+        if ns == ns_val(ns_any_value) {\n+            ret some(ast::def_const(local_def(i.id))); }\n       }\n       ast::item_fn(decl, _, _) {\n-        if ns == ns_value {\n+        if ns == ns_val(ns_any_value) {\n             ret some(ast::def_fn(local_def(i.id), decl.purity));\n         }\n       }\n@@ -1106,7 +1169,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       }\n       ast::item_res(_, _, _, _, ctor_id) {\n         alt ns {\n-          ns_value. {\n+          ns_val(ns_any_value.) {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n           }\n           ns_type. { ret some(ast::def_ty(local_def(i.id))); }\n@@ -1115,7 +1178,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       }\n       ast::item_obj(_, _, ctor_id) {\n         alt ns {\n-          ns_value. {\n+          ns_val(ns_any_value.) {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n           }\n           ns_type. { ret some(ast::def_ty(local_def(i.id))); }\n@@ -1191,7 +1254,7 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n         if e.used_imports.track {\n             e.used_imports.data += [defid.node];\n         }\n-        ret alt ns { ns_value. { val } ns_type. { typ }\n+        ret alt ns { ns_val(_) { val } ns_type. { typ }\n                      ns_module. { md } };\n       }\n     }\n@@ -1251,7 +1314,8 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n                                   bind lookup_in_mod_(e, _, sp, id, ns, dr));\n     if vec::len(matches) == 0u {\n         ret none;\n-    } else if vec::len(matches) == 1u {\n+        }\n+    else if vec::len(matches) == 1u || ns == ns_val(ns_a_tag) {\n         ret some(matches[0].def);\n     } else {\n         for match: glob_imp_def in matches {\n@@ -1269,18 +1333,24 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     // absence takes the place of todo()\n     if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, glob_resolving(sp));\n-        let val = lookup_in_globs(e, info.glob_imports, sp, id, ns_value, dr);\n+        let val = lookup_in_globs(e, info.glob_imports, sp, id,\n+                                  // kludge\n+                                  (if wanted_ns == ns_val(ns_a_tag)\n+                                  { ns_val(ns_a_tag) }\n+                                  else { ns_val(ns_any_value) }), dr);\n         let typ = lookup_in_globs(e, info.glob_imports, sp, id, ns_type, dr);\n         let md = lookup_in_globs(e, info.glob_imports, sp, id, ns_module, dr);\n         info.glob_imported_names.insert(id, glob_resolved(val, typ, md));\n     }\n     alt info.glob_imported_names.get(id) {\n-      glob_resolving(sp) { ret none::<def>; }\n+      glob_resolving(sp) {\n+          ret none::<def>;\n+      }\n       glob_resolved(val, typ, md) {\n         ret alt wanted_ns {\n-          ns_value. { val }\n-          ns_type. { typ }\n-          ns_module. { md }\n+                ns_val(_) { val }\n+                ns_type. { typ }\n+                ns_module. { md }\n         };\n       }\n     }\n@@ -1297,11 +1367,14 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       mie_tag_variant(item, variant_idx) {\n         alt item.node {\n           ast::item_tag(variants, _) {\n-            if ns == ns_value {\n-                let vid = variants[variant_idx].node.id;\n-                ret some(ast::def_variant(local_def(item.id),\n-                                          local_def(vid)));\n-            } else { ret none::<def>; }\n+              alt ns {\n+                  ns_val(_) {\n+                     let vid = variants[variant_idx].node.id;\n+                     ret some(ast::def_variant(local_def(item.id),\n+                                        local_def(vid)));\n+                  }\n+                  _ { ret none::<def>; }\n+              }\n           }\n         }\n       }\n@@ -1313,7 +1386,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n             }\n           }\n           ast::native_item_fn(decl, _) {\n-            if ns == ns_value {\n+            if ns == ns_val(ns_any_value) {\n                 ret some(ast::def_native_fn(\n                     local_def(native_item.id),\n                     decl.purity));\n@@ -1406,18 +1479,31 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n // External lookups\n fn ns_for_def(d: def) -> namespace {\n     alt d {\n+      ast::def_variant(_, _) { ns_val(ns_a_tag) }\n       ast::def_fn(_, _) | ast::def_obj_field(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n-      ast::def_upvar(_, _, _) | ast::def_variant(_, _) |\n-      ast::def_native_fn(_, _) | ast::def_self(_) { ns_value }\n-\n+      ast::def_upvar(_, _, _) |  ast::def_native_fn(_, _) | ast::def_self(_)\n+        { ns_val(ns_any_value) }\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n-\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_native_ty(_) { ns_type }\n     }\n }\n \n+// if we're searching for a value, it's ok if we found\n+// a tag\n+fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n+    alt actual {\n+      ns_val(ns_a_tag.) {\n+        alt wanted {\n+          ns_val(_) { true }\n+          _ { false }\n+        }\n+      }\n+      _ { wanted == actual}\n+    }\n+}\n+\n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n    option::t<def> {\n     for d: def in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n@@ -1442,7 +1528,7 @@ fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n             e.ext_map.insert(did, ids);\n           }\n         }\n-        if ns == ns_for_def(d) { ret some(d); }\n+        if ns_ok(ns, ns_for_def(d)) { ret some(d); }\n     }\n     ret none::<def>;\n }\n@@ -1476,7 +1562,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n     while true {\n         alt entries {\n           cons(entry, rest) {\n-            if !is_none(lookup_in_mie(e, entry, ns_value)) {\n+            if !is_none(lookup_in_mie(e, entry, ns_val(ns_any_value))) {\n                 if saw_value {\n                     dup(e, mie_span(entry), \"\", name);\n                 } else { saw_value = true; }\n@@ -1685,10 +1771,10 @@ fn check_exports(e: @env) {\n         let lookup =\n             bind lookup_glob_in_mod(*e, info, sp, ident, _, inside);\n         let (m, v, t) = (lookup(ns_module),\n-                         lookup(ns_value),\n+                         lookup(ns_val(ns_any_value)),\n                          lookup(ns_type));\n         maybe_add_reexport(e, path + ident, ns_module, m);\n-        maybe_add_reexport(e, path + ident, ns_value, v);\n+        maybe_add_reexport(e, path + ident, ns_val(ns_any_value), v);\n         maybe_add_reexport(e, path + ident, ns_type, t);\n         ret is_some(m) || is_some(v) || is_some(t);\n     }\n@@ -1708,7 +1794,8 @@ fn check_exports(e: @env) {\n                   mie_import_ident(id, _) {\n                     alt e.imports.get(id) {\n                       resolved(v, t, m, _, rid, _) {\n-                        maybe_add_reexport(e, val.path + rid, ns_value, v);\n+                        maybe_add_reexport(e, val.path + rid,\n+                                           ns_val(ns_any_value), v);\n                         maybe_add_reexport(e, val.path + rid, ns_type, t);\n                         maybe_add_reexport(e, val.path + rid, ns_module, m);\n                       }"}, {"sha": "4c8e82c066d98b0e2c5592303da5dcbaa35e5bf6", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -126,7 +126,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n-    for clean in temp_cleanups { revoke_clean(bcx, clean); }\n+    for cln in temp_cleanups { revoke_clean(bcx, cln); }\n     ret trans::store_in_dest(bcx, vptr, dest);\n }\n "}, {"sha": "0b021bbeac4e94c34b4a36ad8b0bb4577337bd7f", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -450,9 +450,9 @@ fn extend_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) ->\n fn set_pre_and_post(ccx: crate_ctxt, id: node_id, pre: precond,\n                     post: postcond) {\n     #debug(\"set_pre_and_post\");\n-    let t = node_id_to_ts_ann(ccx, id);\n-    set_precondition(t, pre);\n-    set_postcondition(t, post);\n+    let tt = node_id_to_ts_ann(ccx, id);\n+    set_precondition(tt, pre);\n+    set_postcondition(tt, post);\n }\n \n fn copy_pre_post(ccx: crate_ctxt, id: node_id, sub: @expr) {\n@@ -464,9 +464,9 @@ fn copy_pre_post(ccx: crate_ctxt, id: node_id, sub: @expr) {\n fn copy_pre_post_(ccx: crate_ctxt, id: node_id, pre: prestate,\n                   post: poststate) {\n     #debug(\"set_pre_and_post\");\n-    let t = node_id_to_ts_ann(ccx, id);\n-    set_precondition(t, pre);\n-    set_postcondition(t, post);\n+    let tt = node_id_to_ts_ann(ccx, id);\n+    set_precondition(tt, pre);\n+    set_postcondition(tt, post);\n }\n \n /* sets all bits to *1* */"}, {"sha": "15b407063eb194e57d00ccd947dc0c010bd932a9", "filename": "src/test/compile-fail/name-clash-nullary-2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary-2.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern:Declaration of thpppt shadows a tag\n+tag ack { thpppt; ffff; }\n+\n+fn main() {\n+  let thpppt: int = 42;\n+  log(debug, thpppt);\n+}"}, {"sha": "421ef6bf767f3f1b2aac5250d1fbb6b1dc9a42c7", "filename": "src/test/compile-fail/name-clash-nullary.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7559edafcdde2d96781a34af1280fdd1dee6bd/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs?ref=7c7559edafcdde2d96781a34af1280fdd1dee6bd", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern:Declaration of none shadows a tag\n+import option::*;\n+\n+fn main() {\n+  let none: int = 42;\n+  log(debug, none);\n+}"}]}