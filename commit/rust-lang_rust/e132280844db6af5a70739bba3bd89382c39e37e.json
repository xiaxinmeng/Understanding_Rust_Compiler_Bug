{"sha": "e132280844db6af5a70739bba3bd89382c39e37e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMzIyODA4NDRkYjZhZjVhNzA3MzliYmEzYmQ4OTM4MmMzOWUzN2U=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-28T20:55:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-28T20:55:16Z"}, "message": "Start library", "tree": {"sha": "ca46ee8a5dba8a424842dc2082395f33a503eb56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca46ee8a5dba8a424842dc2082395f33a503eb56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e132280844db6af5a70739bba3bd89382c39e37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e132280844db6af5a70739bba3bd89382c39e37e", "html_url": "https://github.com/rust-lang/rust/commit/e132280844db6af5a70739bba3bd89382c39e37e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e132280844db6af5a70739bba3bd89382c39e37e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268cb2a04eb2a7519262632c09c55ee273545352", "url": "https://api.github.com/repos/rust-lang/rust/commits/268cb2a04eb2a7519262632c09c55ee273545352", "html_url": "https://github.com/rust-lang/rust/commit/268cb2a04eb2a7519262632c09c55ee273545352"}], "stats": {"total": 301, "additions": 112, "deletions": 189}, "files": [{"sha": "6aa106405a4b4a00d779beab77c90c9473a6d203", "filename": ".gitignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e132280844db6af5a70739bba3bd89382c39e37e/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/e132280844db6af5a70739bba3bd89382c39e37e/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=e132280844db6af5a70739bba3bd89382c39e37e", "patch": "@@ -0,0 +1,3 @@\n+/target/\n+**/*.rs.bk\n+Cargo.lock"}, {"sha": "c94b99fad7070ef3d49c49b109b8153a362ce6c6", "filename": "Cargo.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e132280844db6af5a70739bba3bd89382c39e37e/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e132280844db6af5a70739bba3bd89382c39e37e/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e132280844db6af5a70739bba3bd89382c39e37e", "patch": "@@ -0,0 +1,6 @@\n+[package]\n+name = \"libsyntax2\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]"}, {"sha": "9baa96039de76125773d39aa8e5f08698ccb1f23", "filename": "minirust.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/268cb2a04eb2a7519262632c09c55ee273545352/minirust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268cb2a04eb2a7519262632c09c55ee273545352/minirust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/minirust.rs?ref=268cb2a04eb2a7519262632c09c55ee273545352", "patch": "@@ -1,152 +0,0 @@\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct NodeKind(u16);\n-\n-pub struct File {\n-    text: String,\n-    nodes: Vec<NodeData>,\n-}\n-\n-struct NodeData {\n-    kind: NodeKind,\n-    range: (u32, u32),\n-    parent: Option<u32>,\n-    first_child: Option<u32>,\n-    next_sibling: Option<u32>,\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct Node<'f> {\n-    file: &'f File,\n-    idx: u32,\n-}\n-\n-pub struct Children<'f> {\n-    next: Option<Node<'f>>,\n-}\n-\n-impl File {\n-    pub fn root<'f>(&'f self) -> Node<'f> {\n-        assert!(!self.nodes.is_empty());\n-        Node { file: self, idx: 0 }\n-    }\n-}\n-\n-impl<'f> Node<'f> {\n-    pub fn kind(&self) -> NodeKind {\n-        self.data().kind\n-    }\n-\n-    pub fn text(&self) -> &'f str {\n-        let (start, end) = self.data().range;\n-        &self.file.text[start as usize..end as usize]\n-    }\n-\n-    pub fn parent(&self) -> Option<Node<'f>> {\n-        self.as_node(self.data().parent)\n-    }\n-\n-    pub fn children(&self) -> Children<'f> {\n-        Children { next: self.as_node(self.data().first_child) }\n-    }\n-\n-    fn data(&self) -> &'f NodeData {\n-        &self.file.nodes[self.idx as usize]\n-    }\n-\n-    fn as_node(&self, idx: Option<u32>) -> Option<Node<'f>> {\n-        idx.map(|idx| Node { file: self.file, idx })\n-    }\n-}\n-\n-impl<'f> Iterator for Children<'f> {\n-    type Item = Node<'f>;\n-\n-    fn next(&mut self) -> Option<Node<'f>> {\n-        let next = self.next;\n-        self.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n-        next\n-    }\n-}\n-\n-pub const ERROR: NodeKind = NodeKind(0);\n-pub const WHITESPACE: NodeKind = NodeKind(1);\n-pub const STRUCT_KW: NodeKind = NodeKind(2);\n-pub const IDENT: NodeKind = NodeKind(3);\n-pub const L_CURLY: NodeKind = NodeKind(4);\n-pub const R_CURLY: NodeKind = NodeKind(5);\n-pub const COLON: NodeKind = NodeKind(6);\n-pub const COMMA: NodeKind = NodeKind(7);\n-pub const AMP: NodeKind = NodeKind(8);\n-pub const LINE_COMMENT: NodeKind = NodeKind(9);\n-pub const FILE: NodeKind = NodeKind(10);\n-pub const STRUCT_DEF: NodeKind = NodeKind(11);\n-pub const FIELD_DEF: NodeKind = NodeKind(12);\n-pub const TYPE_REF: NodeKind = NodeKind(13);\n-\n-\n-pub trait AstNode<'f>: Copy + 'f {\n-    fn new(node: Node<'f>) -> Option<Self>;\n-    fn node(&self) -> Node<'f>;\n-}\n-\n-pub fn child_of_kind<'f>(node: Node<'f>, kind: NodeKind) -> Option<Node<'f>> {\n-    node.children().find(|child| child.kind() == kind)\n-}\n-\n-pub fn ast_children<'f, A: AstNode<'f>>(node: Node<'f>) -> Box<Iterator<Item=A> + 'f> {\n-    Box::new(node.children().filter_map(A::new))\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct StructDef<'f>(Node<'f>);\n-\n-#[derive(Clone, Copy)]\n-pub struct FieldDef<'f>(Node<'f>);\n-\n-#[derive(Clone, Copy)]\n-pub struct TypeRef<'f>(Node<'f>);\n-\n-pub trait NameOwner<'f>: AstNode<'f> {\n-    fn name_ident(&self) -> Node<'f> {\n-        child_of_kind(self.node(), IDENT).unwrap()\n-    }\n-\n-    fn name(&self) -> &'f str { self.name_ident().text() }\n-}\n-\n-\n-impl<'f> AstNode<'f> for StructDef<'f> {\n-    fn new(node: Node<'f>) -> Option<Self> {\n-        if node.kind() == STRUCT_DEF { Some(StructDef(node)) } else { None }\n-    }\n-    fn node(&self) -> Node<'f> { self.0 }\n-}\n-\n-impl<'f> AstNode<'f> for FieldDef<'f> {\n-    fn new(node: Node<'f>) -> Option<Self> {\n-        if node.kind() == FIELD_DEF { Some(FieldDef(node)) } else { None }\n-    }\n-    fn node(&self) -> Node<'f> { self.0 }\n-}\n-\n-impl<'f> AstNode<'f> for TypeRef<'f> {\n-    fn new(node: Node<'f>) -> Option<Self> {\n-        if node.kind() == TYPE_REF { Some(TypeRef(node)) } else { None }\n-    }\n-    fn node(&self) -> Node<'f> { self.0 }\n-}\n-\n-impl<'f> NameOwner<'f> for StructDef<'f> {}\n-impl<'f> NameOwner<'f> for FieldDef<'f> {}\n-\n-impl<'f> StructDef<'f> {\n-    pub fn fields(&self) -> Box<Iterator<Item=FieldDef<'f>> + 'f> {\n-        ast_children(self.node())\n-    }\n-}\n-\n-impl<'f> FieldDef<'f> {\n-    pub fn type_ref(&self) -> Option<TypeRef<'f>> {\n-        ast_children(self.node()).next()\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "2bd9f18f1d84a732258bffd71ab58533836720e4", "filename": "rfc.md", "status": "modified", "additions": 96, "deletions": 37, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/e132280844db6af5a70739bba3bd89382c39e37e/rfc.md", "raw_url": "https://github.com/rust-lang/rust/raw/e132280844db6af5a70739bba3bd89382c39e37e/rfc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rfc.md?ref=e132280844db6af5a70739bba3bd89382c39e37e", "patch": "@@ -30,12 +30,66 @@ other tools, and eventual libsyntax removal.\n \n Note that this RFC does not propose to stabilize any API for working\n with rust syntax: the semver version of the hypothetical library would\n-be `0.1.0`.\n+be `0.1.0`. It is intended to be used by tools, which are currently\n+closely related to the compiler: `rustc`, `rustfmt`, `clippy`, `rls`\n+and hypothetical `rustfix`. While it would be possible to create\n+third-party tools on top of the new libsyntax, the burden of adopting\n+to breaking changes would be on authors of such tools.\n \n \n # Motivation\n [motivation]: #motivation\n \n+There are two main drawbacks with the current version of libsyntax:\n+\n+* It is tightly integrated with the compiler and hard to use\n+  independently\n+\n+* The AST representation is not well-suited for use inside IDEs\n+\n+\n+## IDE support\n+\n+There are several differences in how IDEs and compilers typically\n+treat source code.\n+\n+In the compiler, it is convenient to transform the source\n+code into Abstract Syntax Tree form, which is independent of the\n+surface syntax. For example, it's convenient to discard comments,\n+whitespaces and desugar some syntactic constructs in terms of the\n+simpler ones.\n+\n+In contrast, IDEs work much closer to the source code, so it is\n+crucial to preserve full information about the original text. For\n+example, IDE may adjust indentation after typing a `}` which closes a\n+block, and to do this correctly, IDE must be aware of syntax (that is,\n+that `}` indeed closes some block, and is not a syntax error) and of\n+all whitespaces and comments. So, IDE suitable AST should explicitly\n+account for syntactic elements, not considered important by the\n+compiler.\n+\n+Another difference is that IDEs typically work with incomplete and\n+syntactically invalid code. This boils down to two parser properties.\n+First, the parser must produce syntax tree even if some required input\n+is missing. For example, for input `fn foo` the function node should\n+be present in the parse, despite the fact that there is no parameters\n+or body. Second, the parser must be able to skip over parts of input\n+it can't recognize and aggressively recover from errors. That is, the\n+syntax tree data structure should be able to handle both missing and\n+extra nodes.\n+\n+IDEs also need the ability to incrementally reparse and relex source\n+code after the user types. A smart IDE would use syntax tree structure\n+to handle editing commands (for example, to add/remove trailing commas\n+after join/split lines actions), so parsing time can be very\n+noticeable.\n+\n+\n+Currently rustc uses the classical AST approach, and preserves some of\n+the source code information in the form of spans in the AST. It is not\n+clear if this structure can full fill all IDE requirements.\n+\n+\n ## Reusability\n \n In theory, the parser can be a pure function, which takes a `&str` as\n@@ -67,43 +121,42 @@ files. As a data point, it turned out to be easier to move `rustfmt`\n into the main `rustc` repository than to move libsyntax outside!\n \n \n-## IDE support\n+# Guide-level explanation\n+[guide-level-explanation]: #guide-level-explanation\n \n-There is one big difference in how IDEs and compilers typically treat\n-source code.\n+Not applicable.\n \n-In the compiler, it is convenient to transform the source\n-code into Abstract Syntax Tree form, which is independent of the\n-surface syntax. For example, it's convenient to discard comments,\n-whitespaces and desugar some syntactic constructs in terms of the\n-simpler ones.\n \n-In contrast, for IDEs it is crucial to have a lossless view of the\n-source code because, for example, it's important to preserve comments\n-during refactorings. Ideally, IDEs should be able to incrementally\n-relex and reparse the file as the user types, because syntax tree is\n-necessary to correctly handle certain code-editing actions like\n-autoindentation or joining lines. IDE also must be able to produce\n-partial parse trees when some input is missing or invalid.\n+# Reference-level explanation\n+[reference-level-explanation]: #reference-level-explanation\n \n-Currently rustc uses the AST approach, and preserves some of the\n-source code information in the form of spans in the AST.\n+It is not clear if a single parser can accommodate the needs of the\n+compiler and the IDE, but there is hope that it is possible. The RFC\n+proposes to develop libsynax2.0 as an experimental crates.io crate. If\n+the experiment turns out to be a success, the second RFC will propose\n+to integrate it with all existing tools and `rustc`.\n \n+Next, a syntax tree data structure is proposed for libsyntax2.0. It\n+seems to have the following important properties:\n \n-# Guide-level explanation\n-[guide-level-explanation]: #guide-level-explanation\n+* It is lossless and faithfully represents the original source code,\n+  including explicit nodes for comments and whitespace.\n \n-Not applicable.\n+* It is flexible and allows to encode arbitrary node structure,\n+  even for invalid syntax.\n \n+* It is minimal: it stores small amount of data and has no\n+  dependencies. For instance, it does not need compiler's string\n+  interner or literal data representation.\n \n-# Reference-level explanation\n-[reference-level-explanation]: #reference-level-explanation\n+* While the tree itself is minimal, it is extensible in a sense that\n+  it possible to associate arbitrary data with certain nodes in a\n+  type-safe way.\n \n-This section proposes a new syntax tree data structure, which should\n-be suitable for both compiler and IDE. It is heavily inspired by [PSI]\n-data structure which used in [IntelliJ] based IDEs and in the [Kotlin]\n-compiler.\n \n+It is not clear if this representation is the best one. It is heavily\n+inspired by [PSI] data structure which used in [IntelliJ] based IDEs\n+and in the [Kotlin] compiler.\n \n [PSI]: http://www.jetbrains.org/intellij/sdk/docs/reference_guide/custom_language_support/implementing_parser_and_psi.html\n [IntelliJ]: https://github.com/JetBrains/intellij-community/\n@@ -351,6 +404,11 @@ impl<'f> AstNode<'f> for TypeRef<'f> {\n }\n ```\n \n+Note that although AST wrappers provide a type-safe access to the\n+tree, they are still represented as indexes, so clients of the syntax\n+tree can easily associated additional data with AST nodes by storing\n+it in a side-table.\n+\n \n ## Missing Source Code\n \n@@ -374,7 +432,8 @@ This RFC proposes huge changes to the internals of the compiler, so\n it's important to proceed carefully and incrementally. The following\n plan is suggested:\n \n-* RFC discussion about the theoretical feasibility of the proposal.\n+* RFC discussion about the theoretical feasibility of the proposal,\n+  and the best representation representation for the syntax tree.\n \n * Implementation of the proposal as a completely separate crates.io\n   crate, by refactoring existing libsyntax source code to produce a\n@@ -393,11 +452,11 @@ plan is suggested:\n - No harm will be done as long as the new libsyntax exists as an\n   experiemt on crates.io. However, actually using it in the compiler\n   and other tools would require massive refactorings.\n-  \n-- Proposed syntax tree requires to keep the original source code\n-  available, which might increase memory usage of the\n-  compiler. However, it should be possible to throw the original tree\n-  and source code away after conversion to HIR.\n+\n+- It's difficult to know upfront if the proposed syntax tree would\n+  actually work well in both the compiler and IDE. It may be possible\n+  that some drawbacks will be discovered during implementation.\n+\n \n # Rationale and alternatives\n [alternatives]: #alternatives\n@@ -422,14 +481,14 @@ plan is suggested:\n   the source code? It seems like the answer is yes, because the\n   language and especially macros were cleverly designed with this\n   use-case in mind.\n-  \n-  \n+\n+\n - Is it possible to implement macro expansion using the proposed\n   framework? This is the main question of this RFC. The proposed\n   solution of synthesizing source code on the fly seems workable: it's\n   not that different from the current implementation, which\n   synthesizes token trees.\n-  \n-  \n+\n+\n - How to actually phase out current libsyntax, if libsyntax2.0 turns\n   out to be a success?"}, {"sha": "31e1bb209f98ec5fc6b7cbea4c4766a555c87247", "filename": "src/lib.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e132280844db6af5a70739bba3bd89382c39e37e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e132280844db6af5a70739bba3bd89382c39e37e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e132280844db6af5a70739bba3bd89382c39e37e", "patch": "@@ -0,0 +1,7 @@\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(2 + 2, 4);\n+    }\n+}"}]}