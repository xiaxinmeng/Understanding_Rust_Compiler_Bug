{"sha": "7f19f161f24c9a02ff8c3f73122d0b015039221f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMTlmMTYxZjI0YzlhMDJmZjhjM2Y3MzEyMmQwYjAxNTAzOTIyMWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-23T14:14:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-23T14:14:04Z"}, "message": "Auto merge of #58669 - Centril:rollup, r=Centril\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #58100 (Transition librustdoc to Rust 2018)\n - #58122 (RangeInclusive internal iteration performance improvement.)\n - #58199 (Add better error message for partial move)\n - #58227 (Updated RELEASES.md for 1.33.0)\n - #58353 (Check the Self-type of inherent associated constants)\n - #58453 (SGX target: fix panic = abort)\n - #58476 (Remove `LazyTokenStream`.)\n - #58526 (Special suggestion for illegal unicode curly quote pairs)\n - #58595 (Turn duration consts into associated consts)\n - #58609 (Allow Self::Module to be mutated.)\n - #58628 (Optimise vec![false; N] to zero-alloc)\n - #58643 (Don't generate minification variables if minification disabled)\n - #58648 (Update tests to account for cross-platform testing and miri.)\n - #58654 (Do not underflow after resetting unmatched braces count)\n - #58658 (Add expected/provided byte alignments to validation error message)\n - #58667 (Reduce Miri-related Code Repetition `like (n << amt) >> amt`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e02114783d06bffa83bd348a8d5dec4bd0767721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e02114783d06bffa83bd348a8d5dec4bd0767721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f19f161f24c9a02ff8c3f73122d0b015039221f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f19f161f24c9a02ff8c3f73122d0b015039221f", "html_url": "https://github.com/rust-lang/rust/commit/7f19f161f24c9a02ff8c3f73122d0b015039221f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f19f161f24c9a02ff8c3f73122d0b015039221f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcfb5e8ac30c46ba512526d66f803756c124c7bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfb5e8ac30c46ba512526d66f803756c124c7bb", "html_url": "https://github.com/rust-lang/rust/commit/bcfb5e8ac30c46ba512526d66f803756c124c7bb"}, {"sha": "a36d1b930108a33182d412832aa4f6cc1b37158f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a36d1b930108a33182d412832aa4f6cc1b37158f", "html_url": "https://github.com/rust-lang/rust/commit/a36d1b930108a33182d412832aa4f6cc1b37158f"}], "stats": {"total": 1890, "additions": 1125, "deletions": 765}, "files": [{"sha": "841467b69c9866438db0f012fa791e5c4ae89362", "filename": "RELEASES.md", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,3 +1,151 @@\n+Version 1.33.0 (2019-02-28)\n+==========================\n+\n+Language\n+--------\n+- [You can now use the `cfg(target_vendor)` attribute.][57465] E.g.\n+  `#[cfg(target_vendor=\"linux\")] fn main() { println!(\"Hello Linux!\"); }`\n+- [Integer patterns such as in a match expression can now be exhaustive.][56362]\n+  E.g. You can have match statement on a `u8` that covers `0..=255` and\n+  you would no longer be required to have a `_ => unreachable!()` case. \n+- [You can now have multiple patterns in `if let` and `while let`\n+  expressions.][57532] You can do this with the same syntax as a `match`\n+  expression. E.g.\n+  ```rust\n+  enum Creature {\n+      Crab(String),\n+      Lobster(String),\n+      Person(String),\n+  }\n+\n+  fn main() {\n+      let state = Creature::Crab(\"Ferris\");\n+\n+      if let Creature::Crab(name) | Creature::Person(name) = state {\n+          println!(\"This creature's name is: {}\", name);\n+      }\n+  }\n+  ```\n+- [You can now have irrefutable `if let` and `while let` patterns.][57535] Using\n+  this feature will by default produce a warning as this behaviour can be\n+  unintuitive. E.g. `if let _ = 5 {}`\n+- [You can now use `let` bindings, assignments, expression statements,\n+  and irrefutable pattern destructuring in const functions.][57175]\n+- [You can now call unsafe const functions.][57067] E.g.\n+  ```rust\n+  const unsafe fn foo() -> i32 { 5 }\n+  const fn bar() -> i32 {\n+      unsafe { foo() }\n+  }\n+  ```\n+- [You can now specify multiple attributes in a `cfg_attr` attribute.][57332]\n+  E.g. `#[cfg_attr(all(), must_use, optimize)]`\n+- [You can now specify a specific alignment with the `#[repr(packed)]`\n+  attribute.][57049] E.g. `#[repr(packed(2))] struct Foo(i16, i32);` is a struct\n+  with an alignment of 2 bytes and a size of 6 bytes.\n+- [You can now import an item from a module as an `_`.][56303] This allows you to\n+  import a trait's impls, and not have the name in the namespace. E.g.\n+  ```rust\n+  use std::io::Read as _;\n+\n+  // Allowed as there is only one `Read` in the module.\n+  pub trait Read {}\n+  ```\n+- [`extern` functions will now abort by default when panicking.][55982]\n+  This was previously undefined behaviour.\n+\n+Compiler\n+--------\n+- [You can now set a linker flavor for `rustc` with the `-Clinker-flavor`\n+  command line argument.][56351]\n+- [The mininum required LLVM version has been bumped to 6.0.][56642]\n+- [Added support for the PowerPC64 architecture on FreeBSD.][57615]\n+- [The `x86_64-fortanix-unknown-sgx` target support has been upgraded to\n+  tier 2 support.][57130] Visit the [platform support][platform-support] page for\n+  information on Rust's platform support.\n+- [Added support for the `thumbv7neon-linux-androideabi` and\n+  `thumbv7neon-unknown-linux-gnueabihf` targets.][56947]\n+- [Added support for the `x86_64-unknown-uefi` target.][56769]\n+\n+Libraries\n+---------\n+- [The methods `overflowing_{add, sub, mul, shl, shr}` are now `const`\n+  functions for all numeric types.][57566]\n+- [The methods `rotate_left`, `rotate_right`, and `wrapping_{add, sub, mul, shl, shr}`\n+  are now `const` functions for all numeric types.][57105]\n+- [The methods `is_positive` and `is_negative` are now `const` functions for\n+  all signed numeric types.][57105]\n+- [The `get` method for all `NonZero` types is now `const`.][57167]\n+- [The methods `count_ones`, `count_zeros`, `leading_zeros`, `trailing_zeros`,\n+  `swap_bytes`, `from_be`, `from_le`, `to_be`, `to_le` are now `const` for all\n+  numeric types.][57234]\n+- [`Ipv4Addr::new` is now a `const` function][57234]\n+\n+Stabilized APIs\n+---------------\n+- [`unix::FileExt::read_exact_at`]\n+- [`unix::FileExt::write_all_at`]\n+- [`Option::transpose`]\n+- [`Result::transpose`]\n+- [`convert::identity`]\n+- [`pin::Pin`]\n+- [`marker::Unpin`]\n+- [`marker::PhantomPinned`]\n+- [`Vec::resize_with`]\n+- [`VecDeque::resize_with`]\n+- [`Duration::as_millis`]\n+- [`Duration::as_micros`]\n+- [`Duration::as_nanos`]\n+\n+\n+Cargo\n+-----\n+- [Cargo should now rebuild a crate if a file was modified during the initial\n+  build.][cargo/6484]\n+\n+Compatibility Notes\n+-------------------\n+- The methods `str::{trim_left, trim_right, trim_left_matches, trim_right_matches}`\n+  are now deprecated in the standard library, and their usage will now produce a warning.\n+  Please use the `str::{trim_start, trim_end, trim_start_matches, trim_end_matches}`\n+  methods instead.\n+\n+[57615]: https://github.com/rust-lang/rust/pull/57615/\n+[57465]: https://github.com/rust-lang/rust/pull/57465/\n+[57532]: https://github.com/rust-lang/rust/pull/57532/\n+[57535]: https://github.com/rust-lang/rust/pull/57535/\n+[57566]: https://github.com/rust-lang/rust/pull/57566/\n+[57130]: https://github.com/rust-lang/rust/pull/57130/\n+[57167]: https://github.com/rust-lang/rust/pull/57167/\n+[57175]: https://github.com/rust-lang/rust/pull/57175/\n+[57234]: https://github.com/rust-lang/rust/pull/57234/\n+[57332]: https://github.com/rust-lang/rust/pull/57332/\n+[56947]: https://github.com/rust-lang/rust/pull/56947/\n+[57049]: https://github.com/rust-lang/rust/pull/57049/\n+[57067]: https://github.com/rust-lang/rust/pull/57067/\n+[56769]: https://github.com/rust-lang/rust/pull/56769/\n+[56642]: https://github.com/rust-lang/rust/pull/56642/\n+[56303]: https://github.com/rust-lang/rust/pull/56303/\n+[56351]: https://github.com/rust-lang/rust/pull/56351/\n+[55982]: https://github.com/rust-lang/rust/pull/55982/\n+[56362]: https://github.com/rust-lang/rust/pull/56362\n+[57105]: https://github.com/rust-lang/rust/pull/57105\n+[cargo/6484]: https://github.com/rust-lang/cargo/pull/6484/\n+[`unix::FileExt::read_exact_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at\n+[`unix::FileExt::write_all_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at\n+[`Option::transpose`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose\n+[`Result::transpose`]: https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose\n+[`convert::identity`]: https://doc.rust-lang.org/std/convert/fn.identity.html\n+[`pin::Pin`]: https://doc.rust-lang.org/std/pin/struct.Pin.html\n+[`marker::Unpin`]: https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html\n+[`marker::PhantomPinned`]: https://doc.rust-lang.org/nightly/std/marker/struct.PhantomPinned.html\n+[`Vec::resize_with`]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize_with\n+[`VecDeque::resize_with`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.resize_with\n+[`Duration::as_millis`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_millis\n+[`Duration::as_micros`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_micros\n+[`Duration::as_nanos`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_nanos\n+[platform-support]: https://forge.rust-lang.org/platform-support.html\n+\n Version 1.32.0 (2019-01-17)\n ==========================\n "}, {"sha": "229dafc5fdc3a7d8fc7f6145e081eccad7ce906b", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1610,6 +1610,7 @@ impl_is_zero!(u64, |x| x == 0);\n impl_is_zero!(u128, |x| x == 0);\n impl_is_zero!(usize, |x| x == 0);\n \n+impl_is_zero!(bool, |x| x == false);\n impl_is_zero!(char, |x| x == '\\0');\n \n impl_is_zero!(f32, |x: f32| x.to_bits() == 0);"}, {"sha": "e7efd9728b94ace02076a367598c883c6f46a45d", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,6 +1,6 @@\n use convert::TryFrom;\n use mem;\n-use ops::{self, Add, Sub};\n+use ops::{self, Add, Sub, Try};\n use usize;\n \n use super::{FusedIterator, TrustedLen};\n@@ -368,11 +368,11 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n                 Some(Less) => {\n                     self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n-                    return Some(plus_n)\n+                    return Some(plus_n);\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n-                    return Some(plus_n)\n+                    return Some(plus_n);\n                 }\n                 _ => {}\n             }\n@@ -382,6 +382,34 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         None\n     }\n \n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.compute_is_empty();\n+\n+        if self.is_empty() {\n+            return Try::from_ok(init);\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n = self.start.add_one();\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.is_empty = Some(true);\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        Try::from_ok(accum)\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()\n@@ -415,6 +443,33 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             self.end.clone()\n         })\n     }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.compute_is_empty();\n+\n+        if self.is_empty() {\n+            return Try::from_ok(init);\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n = self.end.sub_one();\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.is_empty = Some(true);\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        Try::from_ok(accum)\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "998b597d5e113a12a63e54436f5ec0e1d98e9211", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -334,12 +334,14 @@ pub struct RangeInclusive<Idx> {\n trait RangeInclusiveEquality: Sized {\n     fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n }\n+\n impl<T> RangeInclusiveEquality for T {\n     #[inline]\n     default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n         range.is_empty.unwrap_or_default()\n     }\n }\n+\n impl<T: PartialOrd> RangeInclusiveEquality for T {\n     #[inline]\n     fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {"}, {"sha": "d880abb181c20f20608155eb210d1ac8f6b4495b", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1741,19 +1741,37 @@ fn test_range_inclusive_folds() {\n     assert_eq!((1..=10).sum::<i32>(), 55);\n     assert_eq!((1..=10).rev().sum::<i32>(), 55);\n \n-    let mut it = 40..=50;\n+    let mut it = 44..=50;\n     assert_eq!(it.try_fold(0, i8::checked_add), None);\n-    assert_eq!(it, 44..=50);\n+    assert_eq!(it, 47..=50);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it, 50..=50);\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(50));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+    assert!(it.is_empty());\n+\n+    let mut it = 40..=47;\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it, 40..=44);\n     assert_eq!(it.try_rfold(0, i8::checked_add), None);\n-    assert_eq!(it, 44..=47);\n+    assert_eq!(it, 40..=41);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), Some(81));\n+    assert!(it.is_empty());\n+    assert_eq!(it.try_rfold(0, i8::checked_add), Some(0));\n+    assert!(it.is_empty());\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_fold(0, |a,b| Some(a+b)), Some(165));\n     assert!(it.is_empty());\n+    assert_eq!(it.try_fold(0, |a,b| Some(a+b)), Some(0));\n+    assert!(it.is_empty());\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_rfold(0, |a,b| Some(a+b)), Some(165));\n     assert!(it.is_empty());\n+    assert_eq!(it.try_rfold(0, |a,b| Some(a+b)), Some(0));\n+    assert!(it.is_empty());\n }\n \n #[test]"}, {"sha": "91161ca477e398ff2d675125af8aeb352e274751", "filename": "src/libcore/time.rs", "status": "modified", "additions": 52, "deletions": 16, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -23,22 +23,6 @@ const MILLIS_PER_SEC: u64 = 1_000;\n const MICROS_PER_SEC: u64 = 1_000_000;\n const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n \n-/// The duration of one second.\n-#[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-pub const SECOND: Duration = Duration::from_secs(1);\n-\n-/// The duration of one millisecond.\n-#[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-pub const MILLISECOND: Duration = Duration::from_millis(1);\n-\n-/// The duration of one microsecond.\n-#[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-pub const MICROSECOND: Duration = Duration::from_micros(1);\n-\n-/// The duration of one nanosecond.\n-#[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-pub const NANOSECOND: Duration = Duration::from_nanos(1);\n-\n /// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n ///\n@@ -75,6 +59,58 @@ pub struct Duration {\n }\n \n impl Duration {\n+    /// The duration of one second.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::SECOND, Duration::from_secs(1));\n+    /// ```\n+    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n+    pub const SECOND: Duration = Duration::from_secs(1);\n+\n+    /// The duration of one millisecond.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::MILLISECOND, Duration::from_millis(1));\n+    /// ```\n+    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n+    pub const MILLISECOND: Duration = Duration::from_millis(1);\n+\n+    /// The duration of one microsecond.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::MICROSECOND, Duration::from_micros(1));\n+    /// ```\n+    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n+    pub const MICROSECOND: Duration = Duration::from_micros(1);\n+\n+    /// The duration of one nanosecond.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_constants)]\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::NANOSECOND, Duration::from_nanos(1));\n+    /// ```\n+    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n+    pub const NANOSECOND: Duration = Duration::from_nanos(1);\n+\n     /// Creates a new `Duration` from the specified number of whole seconds and\n     /// additional nanoseconds.\n     ///"}, {"sha": "8c20a6ea55ad03cdcd55aa9add54041f46ea6850", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -58,8 +58,9 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n \n     #[cfg(all(target_vendor=\"fortanix\", target_env=\"sgx\"))]\n     unsafe fn abort() -> ! {\n-        extern \"C\" { pub fn panic_exit() -> !; }\n-        panic_exit();\n+        // call std::sys::abort_internal\n+        extern \"C\" { pub fn __rust_abort() -> !; }\n+        __rust_abort();\n     }\n }\n "}, {"sha": "f6b68682886e713f115ac391f0f0f04f5cdfc691", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1124,19 +1124,19 @@ impl<'a> LoweringContext<'a> {\n             TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n                 span,\n                 delim,\n-                self.lower_token_stream(tts.into()).into(),\n+                self.lower_token_stream(tts),\n             ).into(),\n         }\n     }\n \n     fn lower_token(&mut self, token: Token, span: Span) -> TokenStream {\n         match token {\n-            Token::Interpolated(_) => {}\n-            other => return TokenTree::Token(span, other).into(),\n+            Token::Interpolated(nt) => {\n+                let tts = nt.to_tokenstream(&self.sess.parse_sess, span);\n+                self.lower_token_stream(tts)\n+            }\n+            other => TokenTree::Token(span, other).into(),\n         }\n-\n-        let tts = token.interpolated_to_tokenstream(&self.sess.parse_sess, span);\n-        self.lower_token_stream(tts)\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {"}, {"sha": "72aa9570cc2ffa04f8025ec16e992677a65c5955", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -339,7 +339,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_token(&mut self, t: Token) {\n         if let Token::Interpolated(nt) = t {\n-            if let token::NtExpr(ref expr) = nt.0 {\n+            if let token::NtExpr(ref expr) = *nt {\n                 if let ExprKind::Mac(..) = expr.node {\n                     self.visit_macro_invoc(expr.id);\n                 }"}, {"sha": "9787b07ef8cc2cbca9b681dccaa6ed79464a16aa", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -9,7 +9,7 @@ use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {"}, {"sha": "7b2e8ec3df6bb42ac96df64f23d7cd4b2945ce7f", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -46,7 +46,7 @@ use crate::value::Value;\n \n pub fn write_metadata<'a, 'gcx>(\n     tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    llvm_module: &ModuleLlvm\n+    llvm_module: &mut ModuleLlvm\n ) -> EncodedMetadata {\n     use std::io::Write;\n     use flate2::Compression;"}, {"sha": "9a75b8495ded35a13c8378065c9a66a6464be02c", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -120,11 +120,11 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     fn write_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n-        metadata: &ModuleLlvm\n+        metadata: &mut ModuleLlvm\n     ) -> EncodedMetadata {\n         base::write_metadata(tcx, metadata)\n     }\n-    fn codegen_allocator(&self, tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind) {\n+    fn codegen_allocator(&self, tcx: TyCtxt, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n     fn compile_codegen_unit<'a, 'tcx: 'a>("}, {"sha": "92f5c39fe5a181fba9bfa87f3bdfacfe0005747a", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -551,9 +551,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                                                             &[\"crate\"],\n                                                             Some(\"metadata\")).as_str()\n                                                                              .to_string();\n-    let metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n+    let mut metadata_llvm_module = backend.new_metadata(tcx, &metadata_cgu_name);\n     let metadata = time(tcx.sess, \"write metadata\", || {\n-        backend.write_metadata(tcx, &metadata_llvm_module)\n+        backend.write_metadata(tcx, &mut metadata_llvm_module)\n     });\n     tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n \n@@ -636,9 +636,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                                                        &[\"crate\"],\n                                                        Some(\"allocator\")).as_str()\n                                                                          .to_string();\n-        let modules = backend.new_metadata(tcx, &llmod_id);\n+        let mut modules = backend.new_metadata(tcx, &llmod_id);\n         time(tcx.sess, \"write allocator module\", || {\n-            backend.codegen_allocator(tcx, &modules, kind)\n+            backend.codegen_allocator(tcx, &mut modules, kind)\n         });\n \n         Some(ModuleCodegen {"}, {"sha": "6f92024ea8af3fd8a8b275c66873b619742c99ea", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -36,9 +36,9 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n     fn write_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n-        metadata: &Self::Module,\n+        metadata: &mut Self::Module,\n     ) -> EncodedMetadata;\n-    fn codegen_allocator(&self, tcx: TyCtxt, mods: &Self::Module, kind: AllocatorKind);\n+    fn codegen_allocator(&self, tcx: TyCtxt, mods: &mut Self::Module, kind: AllocatorKind);\n     fn compile_codegen_unit<'a, 'tcx: 'a>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "739125729d41a329ee446c50a74b7d2ebe7c42d9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -130,6 +130,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n \n             let mut is_loop_move = false;\n+            let is_partial_move = move_site_vec.iter().any(|move_site| {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+                used_place != moved_place && used_place.is_prefix_of(moved_place)\n+            });\n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n@@ -175,8 +180,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 err.span_label(\n                     span,\n                     format!(\n-                        \"value {} here after move\",\n-                        desired_action.as_verb_in_past_tense()\n+                        \"value {} here {}\",\n+                        desired_action.as_verb_in_past_tense(),\n+                        if is_partial_move { \"after partial move\" } else { \"after move\" },\n                     ),\n                 );\n             }"}, {"sha": "06b44c26e5ae8b991bb3b7ba3f0aabe7e9db8684", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -7,6 +7,7 @@ use std::hash::Hash;\n \n use rustc::hir;\n use rustc::mir;\n+use rustc::mir::interpret::truncate;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n use rustc::ty::TypeFoldable;\n@@ -965,8 +966,7 @@ where\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n                 let size = tag.value.size(self);\n-                let shift = 128 - size.bits();\n-                let discr_val = (discr_val << shift) >> shift;\n+                let discr_val = truncate(discr_val, size);\n \n                 let discr_dest = self.place_field(dest, 0)?;\n                 self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;"}, {"sha": "6b932b17524c93cd67c7e3a0dc4e39fe1298d7dc", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -357,8 +357,10 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         match err.kind {\n                             EvalErrorKind::InvalidNullPointerUsage =>\n                                 return validation_failure!(\"NULL reference\", self.path),\n-                            EvalErrorKind::AlignmentCheckFailed { .. } =>\n-                                return validation_failure!(\"unaligned reference\", self.path),\n+                            EvalErrorKind::AlignmentCheckFailed { required, has } =>\n+                                return validation_failure!(format!(\"unaligned reference \\\n+                                    (required {} byte alignment but found {})\",\n+                                    required.bytes(), has.bytes()), self.path),\n                             _ =>\n                                 return validation_failure!(\n                                     \"dangling (out-of-bounds) reference (might be NULL at \\"}, {"sha": "29de5308a3cdb8055cfbeb6d25e5e34714e86aef", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1025,7 +1025,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_token(&mut self, t: Token) {\n         if let Token::Interpolated(nt) = t {\n-            if let token::NtExpr(ref expr) = nt.0 {\n+            if let token::NtExpr(ref expr) = *nt {\n                 if let ast::ExprKind::Mac(..) = expr.node {\n                     self.visit_invoc(expr.id);\n                 }"}, {"sha": "fe13be0b1266402b731716cc5738bc79694fc9d7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2234,7 +2234,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir_id, def_id, substs, user_self_ty, self.tag(),\n         );\n \n-        if !substs.is_noop() {\n+        if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n             let canonicalized = self.infcx.canonicalize_user_type_annotation(\n                 &UserType::TypeOf(def_id, UserSubsts {\n                     substs,\n@@ -2429,15 +2429,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n-        // If the type given by the user has free regions, save it for\n-        // later, since NLL would like to enforce those. Also pass in\n-        // types that involve projections, since those can resolve to\n-        // `'static` bounds (modulo #54940, which hopefully will be\n-        // fixed by the time you see this comment, dear reader,\n-        // although I have my doubts). Also pass in types with inference\n-        // types, because they may be repeated. Other sorts of things\n-        // are already sufficiently enforced with erased regions. =)\n-        if ty.has_free_regions() || ty.has_projections() || ty.has_infer_types() {\n+        if Self::can_contain_user_lifetime_bounds(ty) {\n             let c_ty = self.infcx.canonicalize_response(&UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.tables.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n@@ -2446,6 +2438,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n+    // If the type given by the user has free regions, save it for later, since\n+    // NLL would like to enforce those. Also pass in types that involve\n+    // projections, since those can resolve to `'static` bounds (modulo #54940,\n+    // which hopefully will be fixed by the time you see this comment, dear\n+    // reader, although I have my doubts). Also pass in types with inference\n+    // types, because they may be repeated. Other sorts of things are already\n+    // sufficiently enforced with erased regions. =)\n+    fn can_contain_user_lifetime_bounds<T>(t: T) -> bool\n+    where\n+        T: TypeFoldable<'tcx>\n+    {\n+        t.has_free_regions() || t.has_projections() || t.has_infer_types()\n+    }\n+\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,"}, {"sha": "bdd18e88840da352b7f00d6a3115c272304284ce", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustdoc\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustdoc\""}, {"sha": "952541bb85f9bc26057626c36a403e7420dbf0cb", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -220,7 +220,10 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         }\n     }\n \n-    fn get_lifetime(&self, region: Region, names_map: &FxHashMap<String, Lifetime>) -> Lifetime {\n+    fn get_lifetime(\n+        &self, region: Region<'_>,\n+        names_map: &FxHashMap<String, Lifetime>\n+    ) -> Lifetime {\n         self.region_name(region)\n             .map(|name| {\n                 names_map.get(&name).unwrap_or_else(|| {\n@@ -231,7 +234,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             .clone()\n     }\n \n-    fn region_name(&self, region: Region) -> Option<String> {\n+    fn region_name(&self, region: Region<'_>) -> Option<String> {\n         match region {\n             &ty::ReEarlyBound(r) => Some(r.name.to_string()),\n             _ => None,\n@@ -259,7 +262,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         // we need to create the Generics.\n         let mut finished: FxHashMap<_, Vec<_>> = Default::default();\n \n-        let mut vid_map: FxHashMap<RegionTarget, RegionDeps> = Default::default();\n+        let mut vid_map: FxHashMap<RegionTarget<'_>, RegionDeps<'_>> = Default::default();\n \n         // Flattening is done in two parts. First, we insert all of the constraints\n         // into a map. Each RegionTarget (either a RegionVid or a Region) maps\n@@ -842,7 +845,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         vec.sort_by_cached_key(|x| format!(\"{:?}\", x))\n     }\n \n-    fn is_fn_ty(&self, tcx: &TyCtxt, ty: &Type) -> bool {\n+    fn is_fn_ty(&self, tcx: &TyCtxt<'_, '_, '_>, ty: &Type) -> bool {\n         match &ty {\n             &&Type::ResolvedPath { ref did, .. } => {\n                 *did == tcx.require_lang_item(lang_items::FnTraitLangItem)"}, {"sha": "55abcb4a93bd3e4b44af89c603c4bc2cc64da999", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::subst::Subst;\n use rustc::infer::InferOk;\n use syntax_pos::DUMMY_SP;\n \n-use core::DocAccessLevels;\n+use crate::core::DocAccessLevels;\n \n use super::*;\n "}, {"sha": "6a0b6003600148af363f3e1aa02a54f73a347033", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -14,7 +14,7 @@ use syntax::feature_gate::Features;\n \n use syntax_pos::Span;\n \n-use html::escape::Escape;\n+use crate::html::escape::Escape;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, Hash)]\n pub enum Cfg {\n@@ -261,7 +261,7 @@ impl ops::BitOr for Cfg {\n struct Html<'a>(&'a Cfg, bool);\n \n fn write_with_opt_paren<T: fmt::Display>(\n-    fmt: &mut fmt::Formatter,\n+    fmt: &mut fmt::Formatter<'_>,\n     has_paren: bool,\n     obj: T,\n ) -> fmt::Result {\n@@ -277,7 +277,7 @@ fn write_with_opt_paren<T: fmt::Display>(\n \n \n impl<'a> fmt::Display for Html<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.0 {\n             Cfg::Not(ref child) => match **child {\n                 Cfg::Any(ref sub_cfgs) => {"}, {"sha": "fce86d590159b56bc07db985805aa835b740149a", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,8 +1,8 @@\n-use core::DocContext;\n+use crate::core::DocContext;\n \n use super::*;\n \n-pub fn get_def_from_def_id<F>(cx: &DocContext,\n+pub fn get_def_from_def_id<F>(cx: &DocContext<'_, '_, '_>,\n                               def_id: DefId,\n                               callback: &F,\n ) -> Vec<Item>\n@@ -38,7 +38,7 @@ where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n     }\n }\n \n-pub fn get_def_from_node_id<F>(cx: &DocContext,\n+pub fn get_def_from_node_id<F>(cx: &DocContext<'_, '_, '_>,\n                                id: ast::NodeId,\n                                name: String,\n                                callback: &F,"}, {"sha": "9664cae5a68c4a4afaddf3191fd627957726d648", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -13,9 +13,9 @@ use rustc_metadata::cstore::LoadedMacro;\n use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n-use core::{DocContext, DocAccessLevels};\n-use doctree;\n-use clean::{\n+use crate::core::{DocContext, DocAccessLevels};\n+use crate::doctree;\n+use crate::clean::{\n     self,\n     GetDefId,\n     ToSource,\n@@ -35,7 +35,12 @@ use super::Clean;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n-pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHashSet<DefId>)\n+pub fn try_inline(\n+    cx: &DocContext<'_, '_, '_>,\n+    def: Def,\n+    name: ast::Name,\n+    visited: &mut FxHashSet<DefId>\n+)\n                   -> Option<Vec<clean::Item>> {\n     let did = if let Some(did) = def.opt_def_id() {\n         did\n@@ -124,7 +129,7 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n     Some(ret)\n }\n \n-pub fn try_inline_glob(cx: &DocContext, def: Def, visited: &mut FxHashSet<DefId>)\n+pub fn try_inline_glob(cx: &DocContext<'_, '_, '_>, def: Def, visited: &mut FxHashSet<DefId>)\n     -> Option<Vec<clean::Item>>\n {\n     if def == Def::Err { return None }\n@@ -141,15 +146,15 @@ pub fn try_inline_glob(cx: &DocContext, def: Def, visited: &mut FxHashSet<DefId>\n     }\n }\n \n-pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n+pub fn load_attrs(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Attributes {\n     cx.tcx.get_attrs(did).clean(cx)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n+pub fn record_extern_fqn(cx: &DocContext<'_, '_, '_>, did: DefId, kind: clean::TypeKind) {\n     let mut crate_name = cx.tcx.crate_name(did.krate).to_string();\n     if did.is_local() {\n         crate_name = cx.crate_name.clone().unwrap_or(crate_name);\n@@ -177,7 +182,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     }\n }\n \n-pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n+pub fn build_external_trait(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Trait {\n     let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.predicates_of(did);\n@@ -197,7 +202,7 @@ pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n     }\n }\n \n-fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n+fn build_external_function(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness = if cx.tcx.is_min_const_fn(did) {\n@@ -219,7 +224,7 @@ fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n     }\n }\n \n-fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n+fn build_enum(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Enum {\n     let predicates = cx.tcx.predicates_of(did);\n \n     clean::Enum {\n@@ -229,7 +234,7 @@ fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n     }\n }\n \n-fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Struct {\n     let predicates = cx.tcx.predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -245,7 +250,7 @@ fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n     }\n }\n \n-fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n+fn build_union(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -257,7 +262,7 @@ fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n     }\n }\n \n-fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n+fn build_type_alias(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Typedef {\n     let predicates = cx.tcx.predicates_of(did);\n \n     clean::Typedef {\n@@ -266,7 +271,7 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n     }\n }\n \n-pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext<'_, '_, '_>, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n@@ -277,7 +282,7 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     impls\n }\n \n-pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n+pub fn build_impl(cx: &DocContext<'_, '_, '_>, did: DefId, ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n@@ -387,15 +392,19 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     });\n }\n \n-fn build_module(cx: &DocContext, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {\n+fn build_module(\n+    cx: &DocContext<'_, '_, '_>,\n+    did: DefId,\n+    visited: &mut FxHashSet<DefId>\n+) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, did, &mut items, visited);\n     return clean::Module {\n         items,\n         is_crate: false,\n     };\n \n-    fn fill_in(cx: &DocContext, did: DefId, items: &mut Vec<clean::Item>,\n+    fn fill_in(cx: &DocContext<'_, '_, '_>, did: DefId, items: &mut Vec<clean::Item>,\n                visited: &mut FxHashSet<DefId>) {\n         // If we're re-exporting a re-export it may actually re-export something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n@@ -412,30 +421,30 @@ fn build_module(cx: &DocContext, did: DefId, visited: &mut FxHashSet<DefId>) ->\n     }\n }\n \n-pub fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n+pub fn print_inlined_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> String {\n     if let Some(node_id) = cx.tcx.hir().as_local_node_id(did) {\n         cx.tcx.hir().node_to_pretty_string(node_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }\n }\n \n-fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n+fn build_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Constant {\n     clean::Constant {\n         type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did)\n     }\n }\n \n-fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n+fn build_static(cx: &DocContext<'_, '_, '_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n         type_: cx.tcx.type_of(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }\n }\n \n-fn build_macro(cx: &DocContext, did: DefId, name: ast::Name) -> clean::ItemEnum {\n+fn build_macro(cx: &DocContext<'_, '_, '_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.cstore.load_macro_untracked(did, cx.sess()) {\n         LoadedMacro::MacroDef(def) => {\n@@ -537,7 +546,7 @@ fn separate_supertrait_bounds(mut g: clean::Generics)\n     (g, ty_bounds)\n }\n \n-pub fn record_extern_trait(cx: &DocContext, did: DefId) {\n+pub fn record_extern_trait(cx: &DocContext<'_, '_, '_>, did: DefId) {\n     if did.is_local() {\n         return;\n     }"}, {"sha": "172bd9180622f19e70ffd557ca45eef95c7053d5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 140, "deletions": 120, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -48,11 +48,12 @@ use std::u32;\n \n use parking_lot::ReentrantMutex;\n \n-use core::{self, DocContext};\n-use doctree;\n-use visit_ast;\n-use html::render::{cache, ExternalLocation};\n-use html::item_type::ItemType;\n+use crate::core::{self, DocContext};\n+use crate::doctree;\n+use crate::visit_ast;\n+use crate::html::render::{cache, ExternalLocation};\n+use crate::html::item_type::ItemType;\n+\n \n use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n@@ -70,56 +71,56 @@ thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Defau\n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n // extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n+fn get_stability(cx: &DocContext<'_, '_, '_>, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).clean(cx)\n }\n \n-fn get_deprecation(cx: &DocContext, def_id: DefId) -> Option<Deprecation> {\n+fn get_deprecation(cx: &DocContext<'_, '_, '_>, def_id: DefId) -> Option<Deprecation> {\n     cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n pub trait Clean<T> {\n-    fn clean(&self, cx: &DocContext) -> T;\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> T;\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &DocContext) -> IndexVec<V, U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> IndexVec<V, U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for P<T> {\n-    fn clean(&self, cx: &DocContext) -> U {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self, cx: &DocContext) -> U {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self, cx: &DocContext) -> Option<U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<U> {\n         self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n-    fn clean(&self, cx: &DocContext) -> U {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n         self.skip_binder().clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n-    fn clean(&self, cx: &DocContext) -> Vec<U> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n@@ -139,8 +140,8 @@ pub struct Crate {\n }\n \n impl<'a, 'tcx, 'rcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx, 'rcx> {\n-    fn clean(&self, cx: &DocContext) -> Crate {\n-        use ::visit_lib::LibEmbargoVisitor;\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Crate {\n+        use crate::visit_lib::LibEmbargoVisitor;\n \n         {\n             let mut r = cx.renderinfo.borrow_mut();\n@@ -233,7 +234,7 @@ pub struct ExternalCrate {\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &DocContext) -> ExternalCrate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = cx.tcx.def_span(root);\n         let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n@@ -365,7 +366,7 @@ pub struct Item {\n }\n \n impl fmt::Debug for Item {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n \n         let fake = MAX_DEF_ID.with(|m| m.borrow().get(&self.def_id.krate)\n                                    .map(|id| self.def_id >= *id).unwrap_or(false));\n@@ -581,7 +582,7 @@ pub struct Module {\n }\n \n impl Clean<Item> for doctree::Module {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let name = if self.name.is_some() {\n             self.name.expect(\"No name provided\").clean(cx)\n         } else {\n@@ -949,7 +950,8 @@ impl Attributes {\n     ///\n     /// Cache must be populated before call\n     pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n-        use html::format::href;\n+        use crate::html::format::href;\n+\n         self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n             match did {\n                 Some(did) => {\n@@ -1019,7 +1021,7 @@ impl AttributesExt for Attributes {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &DocContext) -> Attributes {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n@@ -1031,7 +1033,7 @@ pub enum GenericBound {\n }\n \n impl GenericBound {\n-    fn maybe_sized(cx: &DocContext) -> GenericBound {\n+    fn maybe_sized(cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n@@ -1048,7 +1050,7 @@ impl GenericBound {\n         }, hir::TraitBoundModifier::Maybe)\n     }\n \n-    fn is_sized_bound(&self, cx: &DocContext) -> bool {\n+    fn is_sized_bound(&self, cx: &DocContext<'_, '_, '_>) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n@@ -1074,7 +1076,7 @@ impl GenericBound {\n }\n \n impl Clean<GenericBound> for hir::GenericBound {\n-    fn clean(&self, cx: &DocContext) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::Trait(ref t, modifier) => {\n@@ -1084,8 +1086,8 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n-                        bindings: Vec<TypeBinding>, substs: &Substs) -> GenericArgs {\n+fn external_generic_args(cx: &DocContext<'_, '_, '_>, trait_did: Option<DefId>, has_self: bool,\n+                        bindings: Vec<TypeBinding>, substs: &Substs<'_>) -> GenericArgs {\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n     let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n@@ -1126,8 +1128,8 @@ fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bo\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self: bool,\n-                 bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n+fn external_path(cx: &DocContext<'_, '_, '_>, name: &str, trait_did: Option<DefId>, has_self: bool,\n+                 bindings: Vec<TypeBinding>, substs: &Substs<'_>) -> Path {\n     Path {\n         global: false,\n         def: Def::Err,\n@@ -1139,7 +1141,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n }\n \n impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n-    fn clean(&self, cx: &DocContext) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(cx, &cx.tcx.item_name(trait_ref.def_id).as_str(),\n@@ -1183,13 +1185,13 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n }\n \n impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n         (self, vec![]).clean(cx)\n     }\n }\n \n impl<'tcx> Clean<Option<Vec<GenericBound>>> for Substs<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Option<Vec<GenericBound>> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n         v.extend(self.types().map(|t| GenericBound::TraitBound(PolyTrait {\n@@ -1216,7 +1218,7 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &DocContext) -> Lifetime {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Lifetime {\n         if self.id != ast::DUMMY_NODE_ID {\n             let def = cx.tcx.named_region(self.hir_id);\n             match def {\n@@ -1235,7 +1237,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n }\n \n impl Clean<Lifetime> for hir::GenericParam {\n-    fn clean(&self, _: &DocContext) -> Lifetime {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if self.bounds.len() > 0 {\n@@ -1259,7 +1261,7 @@ impl Clean<Lifetime> for hir::GenericParam {\n }\n \n impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &DocContext) -> Constant {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Constant {\n         Constant {\n             type_: cx.tcx.type_of(cx.tcx.hir().body_owner_def_id(self.value.body)).clean(cx),\n             expr: print_const_expr(cx, self.value.body),\n@@ -1268,13 +1270,13 @@ impl Clean<Constant> for hir::ConstArg {\n }\n \n impl<'tcx> Clean<Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &DocContext) -> Lifetime {\n+    fn clean(&self, _cx: &DocContext<'_, '_, '_>) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::RegionKind {\n-    fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n@@ -1303,7 +1305,7 @@ pub enum WherePredicate {\n }\n \n impl Clean<WherePredicate> for hir::WherePredicate {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => {\n                 WherePredicate::BoundPredicate {\n@@ -1330,7 +1332,7 @@ impl Clean<WherePredicate> for hir::WherePredicate {\n }\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &DocContext) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n         use rustc::ty::Predicate;\n \n         match *self {\n@@ -1349,7 +1351,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n }\n \n impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         WherePredicate::BoundPredicate {\n             ty: self.trait_ref.self_ty().clean(cx),\n             bounds: vec![self.trait_ref.clean(cx)]\n@@ -1358,7 +1360,7 @@ impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n-    fn clean(&self, _cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, _cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         panic!(\"subtype predicates are an internal rustc artifact \\\n                 and should not be seen by rustdoc\")\n     }\n@@ -1367,7 +1369,7 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n impl<'tcx> Clean<Option<WherePredicate>> for\n     ty::OutlivesPredicate<ty::Region<'tcx>,ty::Region<'tcx>> {\n \n-    fn clean(&self, cx: &DocContext) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n         match (a, b) {\n@@ -1385,7 +1387,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for\n }\n \n impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &DocContext) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n         match lt {\n@@ -1401,7 +1403,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n         WherePredicate::EqPredicate {\n             lhs: self.projection_ty.clean(cx),\n             rhs: self.ty.clean(cx)\n@@ -1410,7 +1412,7 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         let trait_ = match self.trait_ref(cx.tcx).clean(cx) {\n             GenericBound::TraitBound(t, _) => t.trait_,\n             GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n@@ -1458,7 +1460,7 @@ impl GenericParamDef {\n }\n \n impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n@@ -1488,7 +1490,7 @@ impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n }\n \n impl Clean<GenericParamDef> for hir::GenericParam {\n-    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 let name = if self.bounds.len() > 0 {\n@@ -1538,7 +1540,7 @@ pub struct Generics {\n }\n \n impl Clean<Generics> for hir::Generics {\n-    fn clean(&self, cx: &DocContext) -> Generics {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -1608,7 +1610,7 @@ impl Clean<Generics> for hir::Generics {\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                                     &'a Lrc<ty::GenericPredicates<'tcx>>) {\n-    fn clean(&self, cx: &DocContext) -> Generics {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Generics {\n         use self::WherePredicate as WP;\n \n         let (gens, preds) = *self;\n@@ -1689,7 +1691,7 @@ pub struct Method {\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId) {\n-    fn clean(&self, cx: &DocContext) -> Method {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Method {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n@@ -1716,7 +1718,7 @@ pub struct Function {\n }\n \n impl Clean<Item> for doctree::Function {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n@@ -1788,7 +1790,7 @@ pub struct Arguments {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n-    fn clean(&self, cx: &DocContext) -> Arguments {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Arguments {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 let mut name = self.1.get(i).map(|ident| ident.to_string())\n@@ -1806,7 +1808,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n-    fn clean(&self, cx: &DocContext) -> Arguments {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n@@ -1823,7 +1825,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n     where (&'a [hir::Ty], A): Clean<Arguments>\n {\n-    fn clean(&self, cx: &DocContext) -> FnDecl {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n@@ -1834,7 +1836,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n }\n \n impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &DocContext) -> FnDecl {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if cx.tcx.hir().as_local_node_id(did).is_some() {\n             vec![].into_iter()\n@@ -1895,7 +1897,7 @@ pub enum FunctionRetTy {\n }\n \n impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n-    fn clean(&self, cx: &DocContext) -> FunctionRetTy {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n             hir::DefaultReturn(..) => DefaultReturn,\n@@ -1924,7 +1926,7 @@ pub struct Trait {\n }\n \n impl Clean<Item> for doctree::Trait {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n         Item {\n@@ -1955,7 +1957,7 @@ pub struct TraitAlias {\n }\n \n impl Clean<Item> for doctree::TraitAlias {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -1974,7 +1976,7 @@ impl Clean<Item> for doctree::TraitAlias {\n }\n \n impl Clean<bool> for hir::IsAuto {\n-    fn clean(&self, _: &DocContext) -> bool {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n             hir::IsAuto::No => false,\n@@ -1983,13 +1985,13 @@ impl Clean<bool> for hir::IsAuto {\n }\n \n impl Clean<Type> for hir::TraitRef {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         resolve_type(cx, self.path.clean(cx), self.ref_id)\n     }\n }\n \n impl Clean<PolyTrait> for hir::PolyTraitRef {\n-    fn clean(&self, cx: &DocContext) -> PolyTrait {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self.bound_generic_params.clean(cx)\n@@ -1998,7 +2000,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n }\n \n impl Clean<Item> for hir::TraitItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssociatedConstItem(ty.clean(cx),\n@@ -2035,7 +2037,7 @@ impl Clean<Item> for hir::TraitItem {\n }\n \n impl Clean<Item> for hir::ImplItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.node {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n@@ -2067,7 +2069,7 @@ impl Clean<Item> for hir::ImplItem {\n }\n \n impl<'tcx> Clean<Item> for ty::AssociatedItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n                 let ty = cx.tcx.type_of(self.def_id);\n@@ -2385,7 +2387,7 @@ impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => ::html::render::cache().primitive_locations.get(&p).cloned(),\n+            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n             BorrowedRef { type_: box Generic(..), .. } =>\n                 Primitive(PrimitiveType::Reference).def_id(),\n             BorrowedRef { ref type_, .. } => type_.def_id(),\n@@ -2509,7 +2511,7 @@ impl From<ast::FloatTy> for PrimitiveType {\n }\n \n impl Clean<Type> for hir::Ty {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         use rustc::hir::*;\n \n         match self.node {\n@@ -2708,7 +2710,7 @@ impl Clean<Type> for hir::Ty {\n }\n \n impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Type {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n         match self.sty {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n@@ -2903,7 +2905,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n }\n \n impl Clean<Item> for hir::StructField {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n@@ -2918,7 +2920,7 @@ impl Clean<Item> for hir::StructField {\n }\n \n impl<'tcx> Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: cx.tcx.get_attrs(self.did).clean(cx),\n@@ -2941,7 +2943,7 @@ pub enum Visibility {\n }\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n-    fn clean(&self, cx: &DocContext) -> Option<Visibility> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Visibility> {\n         Some(match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n@@ -2956,7 +2958,7 @@ impl Clean<Option<Visibility>> for hir::Visibility {\n }\n \n impl Clean<Option<Visibility>> for ty::Visibility {\n-    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Option<Visibility> {\n         Some(if *self == ty::Visibility::Public { Public } else { Inherited })\n     }\n }\n@@ -2978,7 +2980,7 @@ pub struct Union {\n }\n \n impl Clean<Item> for doctree::Struct {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2998,7 +3000,7 @@ impl Clean<Item> for doctree::Struct {\n }\n \n impl Clean<Item> for doctree::Union {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3028,7 +3030,7 @@ pub struct VariantStruct {\n }\n \n impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n-    fn clean(&self, cx: &DocContext) -> VariantStruct {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n@@ -3045,7 +3047,7 @@ pub struct Enum {\n }\n \n impl Clean<Item> for doctree::Enum {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3069,7 +3071,7 @@ pub struct Variant {\n }\n \n impl Clean<Item> for doctree::Variant {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3086,7 +3088,7 @@ impl Clean<Item> for doctree::Variant {\n }\n \n impl<'tcx> Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => VariantKind::CLike,\n             CtorKind::Fn => {\n@@ -3134,7 +3136,7 @@ pub enum VariantKind {\n }\n \n impl Clean<VariantKind> for hir::VariantData {\n-    fn clean(&self, cx: &DocContext) -> VariantKind {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> VariantKind {\n         if self.is_struct() {\n             VariantKind::Struct(self.clean(cx))\n         } else if self.is_unit() {\n@@ -3165,7 +3167,7 @@ impl Span {\n }\n \n impl Clean<Span> for syntax_pos::Span {\n-    fn clean(&self, cx: &DocContext) -> Span {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Span {\n         if self.is_dummy() {\n             return Span::empty();\n         }\n@@ -3198,7 +3200,7 @@ impl Path {\n }\n \n impl Clean<Path> for hir::Path {\n-    fn clean(&self, cx: &DocContext) -> Path {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Path {\n         Path {\n             global: self.is_global(),\n             def: self.def,\n@@ -3221,7 +3223,7 @@ pub enum GenericArgs {\n }\n \n impl Clean<GenericArgs> for hir::GenericArgs {\n-    fn clean(&self, cx: &DocContext) -> GenericArgs {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty.clean(cx);\n             GenericArgs::Parenthesized {\n@@ -3263,7 +3265,7 @@ pub struct PathSegment {\n }\n \n impl Clean<PathSegment> for hir::PathSegment {\n-    fn clean(&self, cx: &DocContext) -> PathSegment {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> PathSegment {\n         PathSegment {\n             name: self.ident.name.clean(cx),\n             args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n@@ -3335,21 +3337,21 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n \n impl Clean<String> for Ident {\n     #[inline]\n-    fn clean(&self, cx: &DocContext) -> String {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> String {\n         self.name.clean(cx)\n     }\n }\n \n impl Clean<String> for ast::Name {\n     #[inline]\n-    fn clean(&self, _: &DocContext) -> String {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> String {\n         self.to_string()\n     }\n }\n \n impl Clean<String> for InternedString {\n     #[inline]\n-    fn clean(&self, _: &DocContext) -> String {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> String {\n         self.to_string()\n     }\n }\n@@ -3361,7 +3363,7 @@ pub struct Typedef {\n }\n \n impl Clean<Item> for doctree::Typedef {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3385,7 +3387,7 @@ pub struct Existential {\n }\n \n impl Clean<Item> for doctree::Existential {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3411,7 +3413,7 @@ pub struct BareFunctionDecl {\n }\n \n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n-    fn clean(&self, cx: &DocContext) -> BareFunctionDecl {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n             (self.generic_params.clean(cx), (&*self.decl, &self.arg_names[..]).clean(cx))\n         });\n@@ -3435,7 +3437,7 @@ pub struct Static {\n }\n \n impl Clean<Item> for doctree::Static {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3461,7 +3463,7 @@ pub struct Constant {\n }\n \n impl Clean<Item> for doctree::Constant {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3485,7 +3487,7 @@ pub enum Mutability {\n }\n \n impl Clean<Mutability> for hir::Mutability {\n-    fn clean(&self, _: &DocContext) -> Mutability {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Mutability {\n         match self {\n             &hir::MutMutable => Mutable,\n             &hir::MutImmutable => Immutable,\n@@ -3500,7 +3502,7 @@ pub enum ImplPolarity {\n }\n \n impl Clean<ImplPolarity> for hir::ImplPolarity {\n-    fn clean(&self, _: &DocContext) -> ImplPolarity {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> ImplPolarity {\n         match self {\n             &hir::ImplPolarity::Positive => ImplPolarity::Positive,\n             &hir::ImplPolarity::Negative => ImplPolarity::Negative,\n@@ -3521,30 +3523,44 @@ pub struct Impl {\n     pub blanket_impl: Option<Type>,\n }\n \n-pub fn get_auto_traits_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+pub fn get_auto_traits_with_node_id(\n+    cx: &DocContext<'_, '_, '_>,\n+    id: ast::NodeId,\n+    name: String\n+) -> Vec<Item> {\n     let finder = AutoTraitFinder::new(cx);\n     finder.get_with_node_id(id, name)\n }\n \n-pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+pub fn get_auto_traits_with_def_id(\n+    cx: &DocContext<'_, '_, '_>,\n+    id: DefId\n+) -> Vec<Item> {\n     let finder = AutoTraitFinder::new(cx);\n \n     finder.get_with_def_id(id)\n }\n \n-pub fn get_blanket_impls_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n+pub fn get_blanket_impls_with_node_id(\n+    cx: &DocContext<'_, '_, '_>,\n+    id: ast::NodeId,\n+    name: String\n+) -> Vec<Item> {\n     let finder = BlanketImplFinder::new(cx);\n     finder.get_with_node_id(id, name)\n }\n \n-pub fn get_blanket_impls_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n+pub fn get_blanket_impls_with_def_id(\n+    cx: &DocContext<'_, '_, '_>,\n+    id: DefId\n+) -> Vec<Item> {\n     let finder = BlanketImplFinder::new(cx);\n \n     finder.get_with_def_id(id)\n }\n \n impl Clean<Vec<Item>> for doctree::Impl {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n         let trait_ = self.trait_.clean(cx);\n         let items = self.items.clean(cx);\n@@ -3586,7 +3602,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n     }\n }\n \n-fn build_deref_target_impls(cx: &DocContext,\n+fn build_deref_target_impls(cx: &DocContext<'_, '_, '_>,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n     use self::PrimitiveType::*;\n@@ -3644,7 +3660,7 @@ fn build_deref_target_impls(cx: &DocContext,\n }\n \n impl Clean<Vec<Item>> for doctree::ExternCrate {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n             a.name() == \"doc\" && match a.meta_item_list() {\n@@ -3680,7 +3696,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n }\n \n impl Clean<Vec<Item>> for doctree::Import {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n@@ -3754,7 +3770,7 @@ pub struct ImportSource {\n }\n \n impl Clean<Vec<Item>> for hir::ForeignMod {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n         let mut items = self.items.clean(cx);\n         for item in &mut items {\n             if let ForeignFunctionItem(ref mut f) = item.inner {\n@@ -3766,7 +3782,7 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n }\n \n impl Clean<Item> for hir::ForeignItem {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let inner = match self.node {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n@@ -3811,11 +3827,11 @@ impl Clean<Item> for hir::ForeignItem {\n // Utilities\n \n pub trait ToSource {\n-    fn to_src(&self, cx: &DocContext) -> String;\n+    fn to_src(&self, cx: &DocContext<'_, '_, '_>) -> String;\n }\n \n impl ToSource for syntax_pos::Span {\n-    fn to_src(&self, cx: &DocContext) -> String {\n+    fn to_src(&self, cx: &DocContext<'_, '_, '_>) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().source_map().span_to_snippet(*self) {\n             Ok(x) => x,\n@@ -3862,7 +3878,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n+fn print_const(cx: &DocContext<'_, '_, '_>, n: ty::LazyConst<'_>) -> String {\n     match n {\n         ty::LazyConst::Unevaluated(def_id, _) => {\n             if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n@@ -3884,12 +3900,12 @@ fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n     }\n }\n \n-fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n+fn print_const_expr(cx: &DocContext<'_, '_, '_>, body: hir::BodyId) -> String {\n     cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-fn resolve_type(cx: &DocContext,\n+fn resolve_type(cx: &DocContext<'_, '_, '_>,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n     if id == ast::DUMMY_NODE_ID {\n@@ -3920,7 +3936,7 @@ fn resolve_type(cx: &DocContext,\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n+pub fn register_def(cx: &DocContext<'_, '_, '_>, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n@@ -3955,7 +3971,7 @@ pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n     did\n }\n \n-fn resolve_use_source(cx: &DocContext, path: Path) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext<'_, '_, '_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.def.opt_def_id().is_none() {\n             None\n@@ -3973,7 +3989,7 @@ pub struct Macro {\n }\n \n impl Clean<Item> for doctree::Macro {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         let name = self.name.clean(cx);\n         Item {\n             name: Some(name.clone()),\n@@ -4002,7 +4018,7 @@ pub struct ProcMacro {\n }\n \n impl Clean<Item> for doctree::ProcMacro {\n-    fn clean(&self, cx: &DocContext) -> Item {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -4036,7 +4052,7 @@ pub struct Deprecation {\n }\n \n impl Clean<Stability> for attr::Stability {\n-    fn clean(&self, _: &DocContext) -> Stability {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Stability {\n         Stability {\n             level: stability::StabilityLevel::from_attr_level(&self.level),\n             feature: Some(self.feature.to_string()).filter(|f| !f.is_empty()),\n@@ -4063,13 +4079,13 @@ impl Clean<Stability> for attr::Stability {\n }\n \n impl<'a> Clean<Stability> for &'a attr::Stability {\n-    fn clean(&self, dc: &DocContext) -> Stability {\n+    fn clean(&self, dc: &DocContext<'_, '_, '_>) -> Stability {\n         (**self).clean(dc)\n     }\n }\n \n impl Clean<Deprecation> for attr::Deprecation {\n-    fn clean(&self, _: &DocContext) -> Deprecation {\n+    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Deprecation {\n         Deprecation {\n             since: self.since.map(|s| s.to_string()).filter(|s| !s.is_empty()),\n             note: self.note.map(|n| n.to_string()).filter(|n| !n.is_empty()),\n@@ -4085,15 +4101,19 @@ pub struct TypeBinding {\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding {\n-    fn clean(&self, cx: &DocContext) -> TypeBinding {\n+    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> TypeBinding {\n         TypeBinding {\n             name: self.ident.name.clean(cx),\n             ty: self.ty.clean(cx)\n         }\n     }\n }\n \n-pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<String> {\n+pub fn def_id_to_path(\n+    cx: &DocContext<'_, '_, '_>,\n+    did: DefId,\n+    name: Option<String>\n+) -> Vec<String> {\n     let crate_name = name.unwrap_or_else(|| cx.tcx.crate_name(did.krate).to_string());\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n@@ -4107,7 +4127,7 @@ pub fn def_id_to_path(cx: &DocContext, did: DefId, name: Option<String>) -> Vec<\n     once(crate_name).chain(relative).collect()\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext, f: F) -> R\n+pub fn enter_impl_trait<F, R>(cx: &DocContext<'_, '_, '_>, f: F) -> R\n where\n     F: FnOnce() -> R,\n {\n@@ -4120,7 +4140,7 @@ where\n \n // Start of code copied from rust-clippy\n \n-pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def_local(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     let krate = tcx.hir().krate();\n     let mut items = krate.module.item_ids.clone();\n     let mut path_it = path.iter().peekable();\n@@ -4145,7 +4165,7 @@ pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n+pub fn path_to_def(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     let crates = tcx.crates();\n \n     let krate = crates\n@@ -4182,7 +4202,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n+pub fn get_path_for_type<F>(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n     #[derive(Debug)]\n     struct AbsolutePathBuffer {"}, {"sha": "8614b72dffba7211d5d1f807f3484b6583146f7e", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -17,12 +17,12 @@ use std::collections::BTreeMap;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n \n-use clean::GenericArgs as PP;\n-use clean::WherePredicate as WP;\n-use clean;\n-use core::DocContext;\n+use crate::clean::GenericArgs as PP;\n+use crate::clean::WherePredicate as WP;\n+use crate::clean;\n+use crate::core::DocContext;\n \n-pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n+pub fn where_clauses(cx: &DocContext<'_, '_, '_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n     let mut params: BTreeMap<_, Vec<_>> = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n@@ -141,7 +141,7 @@ fn ty_bounds(bounds: Vec<clean::GenericBound>) -> Vec<clean::GenericBound> {\n     bounds\n }\n \n-fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n+fn trait_is_same_or_supertrait(cx: &DocContext<'_, '_, '_>, child: DefId,\n                                trait_: DefId) -> bool {\n     if child == trait_ {\n         return true"}, {"sha": "e5caf7fdfa23591d9ba088ea9892ebfca96ce5e8", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -15,14 +15,14 @@ use rustc_driver;\n use rustc_target::spec::TargetTriple;\n use syntax::edition::Edition;\n \n-use core::new_handler;\n-use externalfiles::ExternalHtml;\n-use html;\n-use html::markdown::IdMap;\n-use html::static_files;\n-use opts;\n-use passes::{self, DefaultPassOption};\n-use theme;\n+use crate::core::new_handler;\n+use crate::externalfiles::ExternalHtml;\n+use crate::html;\n+use crate::html::{static_files};\n+use crate::html::markdown::{IdMap};\n+use crate::opts;\n+use crate::passes::{self, DefaultPassOption};\n+use crate::theme;\n \n /// Configuration options for rustdoc.\n #[derive(Clone)]\n@@ -95,11 +95,11 @@ pub struct Options {\n }\n \n impl fmt::Debug for Options {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         struct FmtExterns<'a>(&'a Externs);\n \n         impl<'a> fmt::Debug for FmtExterns<'a> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 f.debug_map()\n                     .entries(self.0.iter())\n                     .finish()\n@@ -204,7 +204,7 @@ impl Options {\n         nightly_options::check_nightly_options(&matches, &opts());\n \n         if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-            ::usage(\"rustdoc\");\n+            crate::usage(\"rustdoc\");\n             return Err(0);\n         } else if matches.opt_present(\"version\") {\n             rustc_driver::version(\"rustdoc\", &matches);"}, {"sha": "4f70751c90537899cb8ce6b3eec4812e9b617d01", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -33,12 +33,13 @@ use rustc_data_structures::sync::{self, Lrc};\n use std::rc::Rc;\n use std::sync::Arc;\n \n-use visit_ast::RustdocVisitor;\n-use config::{Options as RustdocOptions, RenderOptions};\n-use clean;\n-use clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n-use html::render::RenderInfo;\n-use passes;\n+use crate::visit_ast::RustdocVisitor;\n+use crate::config::{Options as RustdocOptions, RenderOptions};\n+use crate::clean;\n+use crate::clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n+use crate::html::render::RenderInfo;\n+\n+use crate::passes;\n \n pub use rustc::session::config::{Input, Options, CodegenOptions};\n pub use rustc::session::search_paths::SearchPath;"}, {"sha": "0378b12662da26fa5fd6ee525f7ae5d8b244d18a", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2,8 +2,9 @@ use std::fs;\n use std::path::Path;\n use std::str;\n use errors;\n-use syntax::feature_gate::UnstableFeatures;\n-use html::markdown::{IdMap, ErrorCodes, Markdown};\n+use crate::syntax::feature_gate::UnstableFeatures;\n+use crate::html::markdown::{IdMap, ErrorCodes, Markdown};\n+\n use std::cell::RefCell;\n \n #[derive(Clone, Debug)]"}, {"sha": "cfa22bc27b7587ed99b94bd1b119240b6ccd385a", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,4 +1,4 @@\n-use clean::*;\n+use crate::clean::*;\n \n pub struct StripItem(pub Item);\n "}, {"sha": "182a2dd2e9c9f95858ff133ca0e63b25c6b97963", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -10,7 +10,7 @@ use std::fmt;\n pub struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Display for Escape<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let Escape(s) = *self;"}, {"sha": "4463dad1c8a1f8de1e264ebad0909b3474e86084", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -12,10 +12,11 @@ use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n \n-use clean::{self, PrimitiveType};\n-use core::DocAccessLevels;\n-use html::item_type::ItemType;\n-use html::render::{self, cache, CURRENT_LOCATION_KEY};\n+use crate::clean::{self, PrimitiveType};\n+use crate::core::DocAccessLevels;\n+use crate::html::item_type::ItemType;\n+use crate::html::render::{self, cache, CURRENT_LOCATION_KEY};\n+\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n@@ -42,7 +43,7 @@ pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n-pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n+pub struct CommaSep<'a, T>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n /// Wrapper struct for properly emitting a function or method declaration.\n@@ -94,7 +95,7 @@ impl ConstnessSpace {\n }\n \n impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n             fmt::Display::fmt(item, f)?;\n@@ -104,7 +105,7 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n }\n \n impl<'a> fmt::Display for GenericBounds<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let &GenericBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n             if i > 0 {\n@@ -117,7 +118,7 @@ impl<'a> fmt::Display for GenericBounds<'a> {\n }\n \n impl fmt::Display for clean::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n@@ -156,7 +157,7 @@ impl fmt::Display for clean::GenericParamDef {\n }\n \n impl fmt::Display for clean::Generics {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let real_params = self.params\n             .iter()\n             .filter(|p| !p.is_synthetic_type_param())\n@@ -173,7 +174,7 @@ impl fmt::Display for clean::Generics {\n }\n \n impl<'a> fmt::Display for WhereClause<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let &WhereClause { gens, indent, end_newline } = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n@@ -252,14 +253,14 @@ impl<'a> fmt::Display for WhereClause<'a> {\n }\n \n impl fmt::Display for clean::Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(self.get_ref())?;\n         Ok(())\n     }\n }\n \n impl fmt::Display for clean::PolyTrait {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if !self.generic_params.is_empty() {\n             if f.alternate() {\n                 write!(f, \"for<{:#}> \", CommaSep(&self.generic_params))?;\n@@ -276,7 +277,7 @@ impl fmt::Display for clean::PolyTrait {\n }\n \n impl fmt::Display for clean::GenericBound {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::GenericBound::Outlives(ref lt) => {\n                 write!(f, \"{}\", *lt)\n@@ -297,7 +298,7 @@ impl fmt::Display for clean::GenericBound {\n }\n \n impl fmt::Display for clean::GenericArgs {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::GenericArgs::AngleBracketed {\n                 ref lifetimes, ref types, ref bindings\n@@ -374,7 +375,7 @@ impl fmt::Display for clean::GenericArgs {\n }\n \n impl fmt::Display for clean::PathSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.name)?;\n         if f.alternate() {\n             write!(f, \"{:#}\", self.args)\n@@ -385,7 +386,7 @@ impl fmt::Display for clean::PathSegment {\n }\n \n impl fmt::Display for clean::Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if self.global {\n             f.write_str(\"::\")?\n         }\n@@ -445,7 +446,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n+fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n                  print_all: bool, use_absolute: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n \n@@ -474,7 +475,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n     Ok(())\n }\n \n-fn primitive_link(f: &mut fmt::Formatter,\n+fn primitive_link(f: &mut fmt::Formatter<'_>,\n                   prim: clean::PrimitiveType,\n                   name: &str) -> fmt::Result {\n     let m = cache();\n@@ -519,7 +520,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut fmt::Formatter,\n+fn tybounds(w: &mut fmt::Formatter<'_>,\n             typarams: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n@@ -540,7 +541,7 @@ impl<'a> HRef<'a> {\n }\n \n impl<'a> fmt::Display for HRef<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match href(self.did) {\n             Some((url, shortty, fqp)) => if !f.alternate() {\n                 write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n@@ -553,7 +554,7 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n     match *t {\n         clean::Generic(ref name) => {\n             f.write_str(name)\n@@ -745,13 +746,13 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n }\n \n impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt_type(self, f, false)\n     }\n }\n \n fn fmt_impl(i: &clean::Impl,\n-            f: &mut fmt::Formatter,\n+            f: &mut fmt::Formatter<'_>,\n             link_trait: bool,\n             use_absolute: bool) -> fmt::Result {\n     if f.alternate() {\n@@ -791,20 +792,20 @@ fn fmt_impl(i: &clean::Impl,\n }\n \n impl fmt::Display for clean::Impl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt_impl(self, f, true, false)\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n-                               f: &mut fmt::Formatter,\n+                               f: &mut fmt::Formatter<'_>,\n                                use_absolute: bool) -> fmt::Result {\n     fmt_impl(i, f, false, use_absolute)\n }\n \n impl fmt::Display for clean::Arguments {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n             if !input.name.is_empty() {\n                 write!(f, \"{}: \", input.name)?;\n@@ -821,7 +822,7 @@ impl fmt::Display for clean::Arguments {\n }\n \n impl fmt::Display for clean::FunctionRetTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n             clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n@@ -832,7 +833,7 @@ impl fmt::Display for clean::FunctionRetTy {\n }\n \n impl fmt::Display for clean::FnDecl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if self.variadic {\n             if f.alternate() {\n                 write!(f, \"({args:#}, ...){arrow:#}\", args = self.inputs, arrow = self.output)\n@@ -850,7 +851,7 @@ impl fmt::Display for clean::FnDecl {\n }\n \n impl<'a> fmt::Display for Function<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let &Function { decl, header_len, indent, asyncness } = self;\n         let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n@@ -947,7 +948,7 @@ impl<'a> fmt::Display for Function<'a> {\n }\n \n impl<'a> fmt::Display for VisSpace<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.get() {\n             Some(clean::Public) => f.write_str(\"pub \"),\n             Some(clean::Inherited) | None => Ok(()),\n@@ -967,7 +968,7 @@ impl<'a> fmt::Display for VisSpace<'a> {\n }\n \n impl fmt::Display for UnsafetySpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n             hir::Unsafety::Unsafe => write!(f, \"unsafe \"),\n             hir::Unsafety::Normal => Ok(())\n@@ -976,7 +977,7 @@ impl fmt::Display for UnsafetySpace {\n }\n \n impl fmt::Display for ConstnessSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.get() {\n             hir::Constness::Const => write!(f, \"const \"),\n             hir::Constness::NotConst => Ok(())\n@@ -985,7 +986,7 @@ impl fmt::Display for ConstnessSpace {\n }\n \n impl fmt::Display for AsyncSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n             hir::IsAsync::Async => write!(f, \"async \"),\n             hir::IsAsync::NotAsync => Ok(()),\n@@ -994,7 +995,7 @@ impl fmt::Display for AsyncSpace {\n }\n \n impl fmt::Display for clean::Import {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             clean::Import::Simple(ref name, ref src) => {\n                 if *name == src.path.last_name() {\n@@ -1015,7 +1016,7 @@ impl fmt::Display for clean::Import {\n }\n \n impl fmt::Display for clean::ImportSource {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.did {\n             Some(did) => resolved_path(f, did, &self.path, true, false),\n             _ => {\n@@ -1032,7 +1033,7 @@ impl fmt::Display for clean::ImportSource {\n }\n \n impl fmt::Display for clean::TypeBinding {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if f.alternate() {\n             write!(f, \"{} = {:#}\", self.name, self.ty)\n         } else {\n@@ -1042,7 +1043,7 @@ impl fmt::Display for clean::TypeBinding {\n }\n \n impl fmt::Display for MutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             MutableSpace(clean::Immutable) => Ok(()),\n             MutableSpace(clean::Mutable) => write!(f, \"mut \"),\n@@ -1051,7 +1052,7 @@ impl fmt::Display for MutableSpace {\n }\n \n impl fmt::Display for RawMutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             RawMutableSpace(clean::Immutable) => write!(f, \"const \"),\n             RawMutableSpace(clean::Mutable) => write!(f, \"mut \"),\n@@ -1060,7 +1061,7 @@ impl fmt::Display for RawMutableSpace {\n }\n \n impl fmt::Display for AbiSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match self.0 {\n             Abi::Rust => Ok(()),"}, {"sha": "d66455f91ba1a2e3e127ebb4d39d0b458110f41b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -5,7 +5,7 @@\n //!\n //! Use the `render_with_highlighting` to highlight some rust code.\n \n-use html::escape::Escape;\n+use crate::html::escape::Escape;\n \n use std::fmt::Display;\n use std::io;"}, {"sha": "353fa4ae8c999e9bbd74ecda52feb8c73b9109fa", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt;\n use syntax::ext::base::MacroKind;\n-use clean;\n+use crate::clean;\n \n /// Item type. Corresponds to `clean::ItemEnum` variants.\n ///\n@@ -189,7 +189,7 @@ impl ItemType {\n }\n \n impl fmt::Display for ItemType {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.css_class().fmt(f)\n     }\n }\n@@ -211,7 +211,7 @@ impl NameSpace {\n }\n \n impl fmt::Display for NameSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.to_static_str().fmt(f)\n     }\n }"}, {"sha": "6ff3917a265ed9d096a89bc1a2810890d1baf979", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2,9 +2,8 @@ use std::fmt;\n use std::io;\n use std::path::PathBuf;\n \n-use externalfiles::ExternalHtml;\n-\n-use html::render::SlashChecker;\n+use crate::externalfiles::ExternalHtml;\n+use crate::html::render::SlashChecker;\n \n #[derive(Clone)]\n pub struct Layout {\n@@ -29,7 +28,7 @@ pub struct Page<'a> {\n pub fn render<T: fmt::Display, S: fmt::Display>(\n     dst: &mut dyn io::Write,\n     layout: &Layout,\n-    page: &Page,\n+    page: &Page<'_>,\n     sidebar: &S,\n     t: &T,\n     css_file_extension: bool,"}, {"sha": "a70fe363ca69a493b61c9190bce1068ef2333b7c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -29,9 +29,9 @@ use std::ops::Range;\n use std::str;\n use syntax::edition::Edition;\n \n-use html::toc::TocBuilder;\n-use html::highlight;\n-use test;\n+use crate::html::toc::TocBuilder;\n+use crate::html::highlight;\n+use crate::test;\n \n use pulldown_cmark::{html, Event, Tag, Parser};\n use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n@@ -101,7 +101,7 @@ impl<'a> Line<'a> {\n // is done in the single # case. This inconsistency seems okay, if non-ideal. In\n // order to fix it we'd have to iterate to find the first non-# character, and\n // then reallocate to remove it; which would make us return a String.\n-fn map_line(s: &str) -> Line {\n+fn map_line(s: &str) -> Line<'_> {\n     let trimmed = s.trim();\n     if trimmed.starts_with(\"##\") {\n         Line::Shown(Cow::Owned(s.replacen(\"##\", \"#\", 1)))\n@@ -185,7 +185,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n             }\n         }\n         let lines = origtext.lines().filter_map(|l| map_line(l).for_html());\n-        let text = lines.collect::<Vec<Cow<str>>>().join(\"\\n\");\n+        let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n             // previous block so we can shorten the html output\n@@ -196,7 +196,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                 }\n                 let test = origtext.lines()\n                     .map(|l| map_line(l).for_code())\n-                    .collect::<Vec<Cow<str>>>().join(\"\\n\");\n+                    .collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let (test, _) = test::make_test(&test, krate, false,\n                                            &Default::default());\n@@ -386,7 +386,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n     }\n }\n \n-fn check_if_allowed_tag(t: &Tag) -> bool {\n+fn check_if_allowed_tag(t: &Tag<'_>) -> bool {\n     match *t {\n         Tag::Paragraph\n         | Tag::Item\n@@ -523,7 +523,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n pub struct TestableCodeError(());\n \n impl fmt::Display for TestableCodeError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"invalid start of a new code block\")\n     }\n }\n@@ -569,7 +569,7 @@ pub fn find_testable_code<T: test::Tester>(\n                 }\n                 if let Some(offset) = offset {\n                     let lines = test_s.lines().map(|l| map_line(l).for_code());\n-                    let text = lines.collect::<Vec<Cow<str>>>().join(\"\\n\");\n+                    let text = lines.collect::<Vec<Cow<'_, str>>>().join(\"\\n\");\n                     nb_lines += doc[prev_offset..offset].lines().count();\n                     let line = tests.get_line() + (nb_lines - 1);\n                     tests.add_test(text, block_info, line);\n@@ -681,7 +681,7 @@ impl LangString {\n }\n \n impl<'a> fmt::Display for Markdown<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Markdown(md, links, ref ids, codes) = *self;\n         let mut ids = ids.borrow_mut();\n \n@@ -714,7 +714,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let MarkdownWithToc(md, ref ids, codes) = *self;\n         let mut ids = ids.borrow_mut();\n \n@@ -742,7 +742,7 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n }\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let MarkdownHtml(md, ref ids, codes) = *self;\n         let mut ids = ids.borrow_mut();\n \n@@ -772,7 +772,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n }\n \n impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let MarkdownSummaryLine(md, links) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }"}, {"sha": "d711e4514a04955dc9d04b9eaca71740b1f7679a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 95, "deletions": 86, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -55,18 +55,18 @@ use rustc::hir;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n-use clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutability};\n-use config::RenderOptions;\n-use doctree;\n-use fold::DocFolder;\n-use html::escape::Escape;\n-use html::format::{AsyncSpace, ConstnessSpace};\n-use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n-use html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n-use html::format::fmt_impl_for_trait_page;\n-use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n-use html::{highlight, layout, static_files};\n+use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutability};\n+use crate::config::RenderOptions;\n+use crate::doctree;\n+use crate::fold::DocFolder;\n+use crate::html::escape::Escape;\n+use crate::html::format::{AsyncSpace, ConstnessSpace};\n+use crate::html::format::{GenericBounds, WhereClause, href, AbiSpace};\n+use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n+use crate::html::format::fmt_impl_for_trait_page;\n+use crate::html::item_type::ItemType;\n+use crate::html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n+use crate::html::{highlight, layout, static_files};\n \n use minifier;\n \n@@ -76,7 +76,7 @@ pub type NameDoc = (String, Option<String>);\n pub struct SlashChecker<'a>(pub &'a str);\n \n impl<'a> Display for SlashChecker<'a> {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         if !self.0.ends_with(\"/\") && !self.0.is_empty() {\n             write!(f, \"{}/\", self.0)\n         } else {\n@@ -223,7 +223,7 @@ impl error::Error for Error {\n }\n \n impl Display for Error {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n     }\n }\n@@ -367,7 +367,7 @@ pub struct Cache {\n #[derive(Default)]\n pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n-    pub external_paths: ::core::ExternalPaths,\n+    pub external_paths: crate::core::ExternalPaths,\n     pub external_typarams: FxHashMap<DefId, String>,\n     pub exact_paths: FxHashMap<DefId, Vec<String>>,\n     pub access_levels: AccessLevels<DefId>,\n@@ -1117,7 +1117,11 @@ themePicker.onblur = handleThemeButtonsBlur;\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n     let mut w = try_err!(File::create(&dst), &dst);\n-    try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n+    if options.enable_minification {\n+        try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n+    } else {\n+        try_err!(writeln!(&mut w, \"var searchIndex={{}};\"), &dst);\n+    }\n     try_err!(write_minify_replacer(&mut w,\n                                    &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n                                    options.enable_minification),\n@@ -1130,7 +1134,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             md_opts.output = cx.dst.clone();\n             md_opts.external_html = (*cx.shared).layout.external_html.clone();\n \n-            ::markdown::render(index_page, md_opts, diag);\n+            crate::markdown::render(index_page, md_opts, diag);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n             let mut w = BufWriter::new(try_err!(File::create(&dst), &dst));\n@@ -1808,7 +1812,7 @@ impl ItemEntry {\n }\n \n impl fmt::Display for ItemEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n     }\n }\n@@ -1893,7 +1897,7 @@ impl AllTypes {\n     }\n }\n \n-fn print_entries(f: &mut fmt::Formatter, e: &FxHashSet<ItemEntry>, title: &str,\n+fn print_entries(f: &mut fmt::Formatter<'_>, e: &FxHashSet<ItemEntry>, title: &str,\n                  class: &str) -> fmt::Result {\n     if !e.is_empty() {\n         let mut e: Vec<&ItemEntry> = e.iter().collect();\n@@ -1908,7 +1912,7 @@ fn print_entries(f: &mut fmt::Formatter, e: &FxHashSet<ItemEntry>, title: &str,\n }\n \n impl fmt::Display for AllTypes {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f,\n \"<h1 class='fqn'>\\\n      <span class='out-of-band'>\\\n@@ -1965,7 +1969,7 @@ impl<'a> Settings<'a> {\n }\n \n impl<'a> fmt::Display for Settings<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f,\n \"<h1 class='fqn'>\\\n      <span class='in-band'>Rustdoc settings</span>\\\n@@ -2364,16 +2368,16 @@ impl<'a> Item<'a> {\n     }\n }\n \n-fn wrap_into_docblock<F>(w: &mut fmt::Formatter,\n+fn wrap_into_docblock<F>(w: &mut fmt::Formatter<'_>,\n                          f: F) -> fmt::Result\n-where F: Fn(&mut fmt::Formatter) -> fmt::Result {\n+where F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result {\n     write!(w, \"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\")?;\n     f(w)?;\n     write!(w, \"</div>\")\n }\n \n impl<'a> fmt::Display for Item<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"<h1 class='fqn'><span class='out-of-band'>\")?;\n@@ -2516,7 +2520,7 @@ fn plain_summary_line_short(s: Option<&str>) -> String {\n     markdown::plain_summary_line_full(&line[..], true)\n }\n \n-fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n+fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt::Result {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n@@ -2526,7 +2530,7 @@ fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Re\n }\n \n /// Render md_text as markdown.\n-fn render_markdown(w: &mut fmt::Formatter,\n+fn render_markdown(w: &mut fmt::Formatter<'_>,\n                    cx: &Context,\n                    md_text: &str,\n                    links: Vec<(String, String)>,\n@@ -2541,8 +2545,13 @@ fn render_markdown(w: &mut fmt::Formatter,\n            cx.codes))\n }\n \n-fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link: AssocItemLink,\n-                  prefix: &str, is_hidden: bool) -> fmt::Result {\n+fn document_short(\n+    w: &mut fmt::Formatter<'_>,\n+    cx: &Context,\n+    item: &clean::Item,\n+    link: AssocItemLink<'_>,\n+    prefix: &str, is_hidden: bool\n+) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n             format!(\"{} [Read more]({})\",\n@@ -2559,7 +2568,7 @@ fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link\n     Ok(())\n }\n \n-fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n+fn document_full(w: &mut fmt::Formatter<'_>, item: &clean::Item,\n                  cx: &Context, prefix: &str, is_hidden: bool) -> fmt::Result {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n@@ -2572,7 +2581,7 @@ fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n     Ok(())\n }\n \n-fn document_stability(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n+fn document_stability(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item,\n                       is_hidden: bool) -> fmt::Result {\n     let stabilities = short_stability(item, cx);\n     if !stabilities.is_empty() {\n@@ -2589,7 +2598,7 @@ fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n     if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n }\n \n-fn document_non_exhaustive(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n+fn document_non_exhaustive(w: &mut fmt::Formatter<'_>, item: &clean::Item) -> fmt::Result {\n     if item.is_non_exhaustive() {\n         write!(w, \"<div class='docblock non-exhaustive non-exhaustive-{}'>\", {\n             if item.is_struct() { \"struct\" } else if item.is_enum() { \"enum\" } else { \"type\" }\n@@ -2637,7 +2646,7 @@ fn name_key(name: &str) -> (&str, u64, usize) {\n     }\n }\n \n-fn item_module(w: &mut fmt::Formatter, cx: &Context,\n+fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     document(w, cx, item)?;\n \n@@ -2741,7 +2750,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n-                use html::format::HRef;\n+                use crate::html::format::HRef;\n \n                 match *src {\n                     Some(ref src) => {\n@@ -2957,7 +2966,7 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     stability\n }\n \n-fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_constant(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>\")?;\n     render_attributes(w, it)?;\n@@ -2969,7 +2978,7 @@ fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_static(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>\")?;\n     render_attributes(w, it)?;\n@@ -2982,7 +2991,7 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_function(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n@@ -3016,7 +3025,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter,\n+fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter<'_>,\n                       implementor_dups: &FxHashMap<&str, (DefId, bool)>) -> fmt::Result {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -3033,7 +3042,7 @@ fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn render_impls(cx: &Context, w: &mut fmt::Formatter,\n+fn render_impls(cx: &Context, w: &mut fmt::Formatter<'_>,\n                 traits: &[&&Impl],\n                 containing_item: &clean::Item) -> fmt::Result {\n     for i in traits {\n@@ -3070,7 +3079,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n }\n \n fn item_trait(\n-    w: &mut fmt::Formatter,\n+    w: &mut fmt::Formatter<'_>,\n     cx: &Context,\n     it: &clean::Item,\n     t: &clean::Trait,\n@@ -3156,7 +3165,7 @@ fn item_trait(\n     document(w, cx, it)?;\n \n     fn write_small_section_header(\n-        w: &mut fmt::Formatter,\n+        w: &mut fmt::Formatter<'_>,\n         id: &str,\n         title: &str,\n         extra_content: &str,\n@@ -3167,11 +3176,11 @@ fn item_trait(\n             </h2>{2}\", id, title, extra_content)\n     }\n \n-    fn write_loading_content(w: &mut fmt::Formatter, extra_content: &str) -> fmt::Result {\n+    fn write_loading_content(w: &mut fmt::Formatter<'_>, extra_content: &str) -> fmt::Result {\n         write!(w, \"{}<span class='loading-content'>Loading content...</span>\", extra_content)\n     }\n \n-    fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n+    fn trait_item(w: &mut fmt::Formatter<'_>, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let item_type = m.type_();\n@@ -3328,8 +3337,8 @@ fn item_trait(\n     Ok(())\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n-    use html::item_type::ItemType::*;\n+fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n+    use crate::html::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n     let ty = match it.type_() {\n@@ -3347,11 +3356,11 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n     }\n }\n \n-fn assoc_const(w: &mut fmt::Formatter,\n+fn assoc_const(w: &mut fmt::Formatter<'_>,\n                it: &clean::Item,\n                ty: &clean::Type,\n                _default: Option<&String>,\n-               link: AssocItemLink) -> fmt::Result {\n+               link: AssocItemLink<'_>) -> fmt::Result {\n     write!(w, \"{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            VisSpace(&it.visibility),\n            naive_assoc_href(it, link),\n@@ -3363,7 +3372,7 @@ fn assoc_const(w: &mut fmt::Formatter,\n fn assoc_type<W: fmt::Write>(w: &mut W, it: &clean::Item,\n                              bounds: &[clean::GenericBound],\n                              default: Option<&clean::Type>,\n-                             link: AssocItemLink) -> fmt::Result {\n+                             link: AssocItemLink<'_>) -> fmt::Result {\n     write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n@@ -3389,22 +3398,22 @@ fn render_stability_since_raw<'a, T: fmt::Write>(\n     Ok(())\n }\n \n-fn render_stability_since(w: &mut fmt::Formatter,\n+fn render_stability_since(w: &mut fmt::Formatter<'_>,\n                           item: &clean::Item,\n                           containing_item: &clean::Item) -> fmt::Result {\n     render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n }\n \n-fn render_assoc_item(w: &mut fmt::Formatter,\n+fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n                      item: &clean::Item,\n-                     link: AssocItemLink,\n+                     link: AssocItemLink<'_>,\n                      parent: ItemType) -> fmt::Result {\n-    fn method(w: &mut fmt::Formatter,\n+    fn method(w: &mut fmt::Formatter<'_>,\n               meth: &clean::Item,\n               header: hir::FnHeader,\n               g: &clean::Generics,\n               d: &clean::FnDecl,\n-              link: AssocItemLink,\n+              link: AssocItemLink<'_>,\n               parent: ItemType)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n@@ -3481,7 +3490,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n     }\n }\n \n-fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_struct(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust struct'>\")?;\n@@ -3532,7 +3541,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_union(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                s: &clean::Union) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust union'>\")?;\n@@ -3577,7 +3586,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust enum'>\")?;\n@@ -3666,7 +3675,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             write!(w, \"</code></span>\")?;\n             document(w, cx, variant)?;\n \n-            use clean::{Variant, VariantKind};\n+            use crate::clean::{Variant, VariantKind};\n             if let clean::VariantItem(Variant {\n                 kind: VariantKind::Struct(ref s)\n             }) = variant.inner {\n@@ -3678,7 +3687,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 write!(w, \"<h3>Fields of <b>{name}</b></h3><div>\",\n                        name = variant.name.as_ref().unwrap())?;\n                 for field in &s.fields {\n-                    use clean::StructFieldItem;\n+                    use crate::clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n                         let id = cx.derive_id(format!(\"variant.{}.field.{}\",\n                                                    variant.name.as_ref().unwrap(),\n@@ -3741,7 +3750,7 @@ const ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n     \"non_exhaustive\"\n ];\n \n-fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n+fn render_attributes(w: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::Result {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n@@ -3759,7 +3768,7 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n+fn render_struct(w: &mut fmt::Formatter<'_>, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n@@ -3835,7 +3844,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n+fn render_union(w: &mut fmt::Formatter<'_>, it: &clean::Item,\n                 g: Option<&clean::Generics>,\n                 fields: &[clean::Item],\n                 tab: &str,\n@@ -3893,11 +3902,11 @@ enum RenderMode {\n     ForDeref { mut_: bool },\n }\n \n-fn render_assoc_items(w: &mut fmt::Formatter,\n+fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n                       cx: &Context,\n                       containing_item: &clean::Item,\n                       it: DefId,\n-                      what: AssocItemRender) -> fmt::Result {\n+                      what: AssocItemRender<'_>) -> fmt::Result {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n@@ -3955,7 +3964,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         struct RendererStruct<'a, 'b, 'c>(&'a Context, Vec<&'b &'b Impl>, &'c clean::Item);\n \n         impl<'a, 'b, 'c> fmt::Display for RendererStruct<'a, 'b, 'c> {\n-            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 render_impls(self.0, fmt, &self.1, self.2)\n             }\n         }\n@@ -3996,7 +4005,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n+fn render_deref_methods(w: &mut fmt::Formatter<'_>, cx: &Context, impl_: &Impl,\n                         container_item: &clean::Item, deref_mut: bool) -> fmt::Result {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let target = impl_.inner_impl().items.iter().filter_map(|item| {\n@@ -4107,7 +4116,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n     Ok(out)\n }\n \n-fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n+fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                render_mode: RenderMode, outer_version: Option<&str>,\n                show_def_docs: bool, use_absolute: Option<bool>) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n@@ -4149,8 +4158,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n     }\n \n-    fn doc_impl_item(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n-                     link: AssocItemLink, render_mode: RenderMode,\n+    fn doc_impl_item(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item,\n+                     link: AssocItemLink<'_>, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n                      trait_: Option<&clean::Trait>, show_def_docs: bool) -> fmt::Result {\n         let item_type = item.type_();\n@@ -4264,7 +4273,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                       false, outer_version, trait_, show_def_docs)?;\n     }\n \n-    fn render_default_items(w: &mut fmt::Formatter,\n+    fn render_default_items(w: &mut fmt::Formatter<'_>,\n                             cx: &Context,\n                             t: &clean::Trait,\n                             i: &clean::Impl,\n@@ -4297,7 +4306,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n }\n \n fn item_existential(\n-    w: &mut fmt::Formatter,\n+    w: &mut fmt::Formatter<'_>,\n     cx: &Context,\n     it: &clean::Item,\n     t: &clean::Existential,\n@@ -4319,7 +4328,7 @@ fn item_existential(\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_trait_alias(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_trait_alias(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                     t: &clean::TraitAlias) -> fmt::Result {\n     write!(w, \"<pre class='rust trait-alias'>\")?;\n     render_attributes(w, it)?;\n@@ -4338,7 +4347,7 @@ fn item_trait_alias(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_typedef(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     write!(w, \"<pre class='rust typedef'>\")?;\n     render_attributes(w, it)?;\n@@ -4357,7 +4366,7 @@ fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_foreign_type(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item) -> fmt::Result {\n+fn item_foreign_type(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item) -> fmt::Result {\n     writeln!(w, \"<pre class='rust foreigntype'>extern {{\")?;\n     render_attributes(w, it)?;\n     write!(\n@@ -4373,7 +4382,7 @@ fn item_foreign_type(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item) ->\n }\n \n impl<'a> fmt::Display for Sidebar<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n@@ -4638,7 +4647,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n     out\n }\n \n-fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_struct(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                   s: &clean::Struct) -> fmt::Result {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&s.fields);\n@@ -4675,7 +4684,7 @@ fn is_negative_impl(i: &clean::Impl) -> bool {\n     i.polarity == Some(clean::ImplPolarity::Negative)\n }\n \n-fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_trait(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                  t: &clean::Trait) -> fmt::Result {\n     let mut sidebar = String::new();\n \n@@ -4787,7 +4796,7 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n     write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n }\n \n-fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_primitive(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                      _p: &clean::PrimitiveType) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n \n@@ -4797,7 +4806,7 @@ fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn sidebar_typedef(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_typedef(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                    _t: &clean::Typedef) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n \n@@ -4822,7 +4831,7 @@ fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n           .collect()\n }\n \n-fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_union(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                  u: &clean::Union) -> fmt::Result {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&u.fields);\n@@ -4840,7 +4849,7 @@ fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n+fn sidebar_enum(fmt: &mut fmt::Formatter<'_>, it: &clean::Item,\n                 e: &clean::Enum) -> fmt::Result {\n     let mut sidebar = String::new();\n \n@@ -4895,7 +4904,7 @@ fn item_ty_to_strs(ty: &ItemType) -> (&'static str, &'static str) {\n     }\n }\n \n-fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n+fn sidebar_module(fmt: &mut fmt::Formatter<'_>, _it: &clean::Item,\n                   items: &[clean::Item]) -> fmt::Result {\n     let mut sidebar = String::new();\n \n@@ -4927,7 +4936,7 @@ fn sidebar_module(fmt: &mut fmt::Formatter, _it: &clean::Item,\n     Ok(())\n }\n \n-fn sidebar_foreign_type(fmt: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n+fn sidebar_foreign_type(fmt: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n     if !sidebar.is_empty() {\n         write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n@@ -4936,7 +4945,7 @@ fn sidebar_foreign_type(fmt: &mut fmt::Formatter, it: &clean::Item) -> fmt::Resu\n }\n \n impl<'a> fmt::Display for Source<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Source(s) = *self;\n         let lines = s.lines().count();\n         let mut cols = 0;\n@@ -4956,7 +4965,7 @@ impl<'a> fmt::Display for Source<'a> {\n     }\n }\n \n-fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+fn item_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     wrap_into_docblock(w, |w| {\n         w.write_str(&highlight::render_with_highlighting(&t.source,\n@@ -4967,7 +4976,7 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)\n }\n \n-fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n+fn item_proc_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n     -> fmt::Result\n {\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n@@ -5000,14 +5009,14 @@ fn item_proc_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item, m: &c\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n+fn item_primitive(w: &mut fmt::Formatter<'_>, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     document(w, cx, it)?;\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_keyword(w: &mut fmt::Formatter, cx: &Context,\n+fn item_keyword(w: &mut fmt::Formatter<'_>, cx: &Context,\n                 it: &clean::Item,\n                 _p: &str) -> fmt::Result {\n     document(w, cx, it)"}, {"sha": "409f2479ccc7c29317e2cbb83ac879789d3494ce", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -166,13 +166,13 @@ impl TocBuilder {\n }\n \n impl fmt::Debug for Toc {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)\n     }\n }\n \n impl fmt::Display for Toc {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"<ul>\")?;\n         for entry in &self.entries {\n             // recursively format this table of contents (the"}, {"sha": "5e9f9ee9f80af7e2dd81ffbf1a68fe22b333c7ef", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rust_2018_idioms)]\n+\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n \n@@ -17,7 +19,6 @@\n \n #![recursion_limit=\"256\"]\n \n-extern crate arena;\n extern crate getopts;\n extern crate env_logger;\n extern crate rustc;\n@@ -35,10 +36,6 @@ extern crate syntax_pos;\n extern crate test as testing;\n #[macro_use] extern crate log;\n extern crate rustc_errors as errors;\n-extern crate pulldown_cmark;\n-extern crate tempfile;\n-extern crate minifier;\n-extern crate parking_lot;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "0014d9ceb5ba2b7f5af947e3894d3c6f13f7deb6", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,4 +1,3 @@\n-use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n@@ -9,13 +8,12 @@ use testing;\n use syntax::source_map::DUMMY_SP;\n use syntax::feature_gate::UnstableFeatures;\n \n-use externalfiles::{LoadStringError, load_string};\n-\n-use config::{Options, RenderOptions};\n-use html::escape::Escape;\n-use html::markdown;\n-use html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n-use test::{TestOptions, Collector};\n+use crate::externalfiles::{LoadStringError, load_string};\n+use crate::config::{Options, RenderOptions};\n+use crate::html::escape::Escape;\n+use crate::html::markdown;\n+use crate::html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n+use crate::test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {"}, {"sha": "f960374370e043ef193d7706d4ad102f32d00a7c", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -4,17 +4,17 @@ use syntax::parse::{ParseSess, token};\n use syntax::source_map::FilePathMapping;\n use syntax_pos::FileName;\n \n-use clean;\n-use core::DocContext;\n-use fold::DocFolder;\n-use html::markdown::{self, RustCodeBlock};\n-use passes::Pass;\n+use crate::clean;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use crate::html::markdown::{self, RustCodeBlock};\n+use crate::passes::Pass;\n \n pub const CHECK_CODE_BLOCK_SYNTAX: Pass =\n     Pass::early(\"check-code-block-syntax\", check_code_block_syntax,\n                 \"validates syntax inside Rust code blocks\");\n \n-pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n+pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_, '_, '_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n "}, {"sha": "e5e60cbe717001e1f446673e515a9ca7955aa10b", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,7 +1,8 @@\n-use clean::{self, DocFragment, Item};\n-use fold;\n-use fold::DocFolder;\n-use passes::Pass;\n+use crate::clean::{self, DocFragment, Item};\n+use crate::fold;\n+use crate::fold::{DocFolder};\n+use crate::passes::Pass;\n+\n use std::mem::replace;\n \n pub const COLLAPSE_DOCS: Pass ="}, {"sha": "cf2c3aa484600244202163a533109c27daf88feb", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -10,19 +10,19 @@ use syntax_pos::DUMMY_SP;\n \n use std::ops::Range;\n \n-use core::DocContext;\n-use fold::DocFolder;\n-use html::markdown::markdown_links;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use crate::html::markdown::markdown_links;\n+use crate::clean::*;\n+use crate::passes::{look_for_tests, Pass};\n \n-use clean::*;\n-use passes::{look_for_tests, Pass};\n use super::span_of_attrs;\n \n pub const COLLECT_INTRA_DOC_LINKS: Pass =\n     Pass::early(\"collect-intra-doc-links\", collect_intra_doc_links,\n                 \"reads a crate's documentation to resolve intra-doc-links\");\n \n-pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext) -> Crate {\n+pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     if !UnstableFeatures::from_environment().is_nightly_build() {\n         krate\n     } else {\n@@ -423,7 +423,7 @@ impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n }\n \n /// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n+fn macro_resolve(cx: &DocContext<'_, '_, '_>, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n@@ -451,7 +451,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n /// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n /// line containing the failure as a note as well.\n fn resolution_failure(\n-    cx: &DocContext,\n+    cx: &DocContext<'_, '_, '_>,\n     attrs: &Attributes,\n     path_str: &str,\n     dox: &str,\n@@ -493,7 +493,7 @@ fn resolution_failure(\n     diag.emit();\n }\n \n-fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n+fn ambiguity_error(cx: &DocContext<'_, '_, '_>, attrs: &Attributes,\n                    path_str: &str,\n                    article1: &str, kind1: &str, disambig1: &str,\n                    article2: &str, kind2: &str, disambig2: &str) {\n@@ -549,7 +549,7 @@ fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String\n }\n \n /// Given an enum variant's def, return the def of its enum and the associated fragment.\n-fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()> {\n+fn handle_variant(cx: &DocContext<'_, '_, '_>, def: Def) -> Result<(Def, Option<String>), ()> {\n     use rustc::ty::DefIdTree;\n \n     let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {"}, {"sha": "903cce3bc032a3a6e6065a8176efe2e503310033", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,17 +1,16 @@\n-use clean::*;\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::def_id::DefId;\n \n-use super::Pass;\n-use core::DocContext;\n-use fold::DocFolder;\n-\n pub const COLLECT_TRAIT_IMPLS: Pass =\n     Pass::early(\"collect-trait-impls\", collect_trait_impls,\n                 \"retrieves trait impls for items in the crate\");\n \n-pub fn collect_trait_impls(krate: Crate, cx: &DocContext) -> Crate {\n+pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     let mut synth = SyntheticImplCollector::new(cx);\n     let mut krate = synth.fold_crate(krate);\n "}, {"sha": "4d7fef7a76a9fe936dadc75ebb248692ed6af387", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -11,12 +11,10 @@ use syntax::ast::NodeId;\n use syntax_pos::{DUMMY_SP, Span};\n use std::ops::Range;\n \n-use clean::{self, GetDefId, Item};\n-use core::{DocContext, DocAccessLevels};\n-use fold;\n-use fold::StripItem;\n-\n-use html::markdown::{find_testable_code, ErrorCodes, LangString};\n+use crate::clean::{self, GetDefId, Item};\n+use crate::core::{DocContext, DocAccessLevels};\n+use crate::fold::{DocFolder, StripItem};\n+use crate::html::markdown::{find_testable_code, ErrorCodes, LangString};\n \n mod collapse_docs;\n pub use self::collapse_docs::COLLAPSE_DOCS;\n@@ -55,7 +53,7 @@ pub enum Pass {\n     /// traits and the like.\n     EarlyPass {\n         name: &'static str,\n-        pass: fn(clean::Crate, &DocContext) -> clean::Crate,\n+        pass: fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate,\n         description: &'static str,\n     },\n     /// A \"late pass\" is run between crate cleaning and page generation.\n@@ -67,7 +65,7 @@ pub enum Pass {\n }\n \n impl fmt::Debug for Pass {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut dbg = match *self {\n             Pass::EarlyPass { .. } => f.debug_struct(\"EarlyPass\"),\n             Pass::LatePass { .. } => f.debug_struct(\"LatePass\"),\n@@ -83,7 +81,7 @@ impl fmt::Debug for Pass {\n impl Pass {\n     /// Constructs a new early pass.\n     pub const fn early(name: &'static str,\n-                       pass: fn(clean::Crate, &DocContext) -> clean::Crate,\n+                       pass: fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate,\n                        description: &'static str) -> Pass {\n         Pass::EarlyPass { name, pass, description }\n     }\n@@ -112,7 +110,7 @@ impl Pass {\n     }\n \n     /// If this pass is an early pass, returns the pointer to its function.\n-    pub fn early_fn(self) -> Option<fn(clean::Crate, &DocContext) -> clean::Crate> {\n+    pub fn early_fn(self) -> Option<fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate> {\n         match self {\n             Pass::EarlyPass { pass, .. } => Some(pass),\n             _ => None,\n@@ -196,7 +194,7 @@ struct Stripper<'a> {\n     update_retained: bool,\n }\n \n-impl<'a> fold::DocFolder for Stripper<'a> {\n+impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::StrippedItem(..) => {\n@@ -308,7 +306,7 @@ struct ImplStripper<'a> {\n     retained: &'a DefIdSet,\n }\n \n-impl<'a> fold::DocFolder for ImplStripper<'a> {\n+impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n             // emptied none trait impls can be stripped\n@@ -345,7 +343,7 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n \n // This stripper discards all private import statements (`use`, `extern crate`)\n struct ImportStripper;\n-impl fold::DocFolder for ImportStripper {\n+impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::ExternCrateItem(..) | clean::ImportItem(..)\n@@ -373,7 +371,7 @@ pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a>(\n         found_tests: usize,\n     }\n \n-    impl ::test::Tester for Tests {\n+    impl crate::test::Tester for Tests {\n         fn add_test(&mut self, _: String, _: LangString, _: usize) {\n             self.found_tests += 1;\n         }\n@@ -420,7 +418,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Span {\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n crate fn source_span_for_markdown_range(\n-    cx: &DocContext,\n+    cx: &DocContext<'_, '_, '_>,\n     markdown: &str,\n     md_range: &Range<usize>,\n     attrs: &clean::Attributes,"}, {"sha": "819d15f65e8ef33678d14946e7371ce57270c22b", "filename": "src/librustdoc/passes/private_items_doc_tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,9 +1,8 @@\n-use clean::*;\n+use crate::clean::*;\n+use crate::core::DocContext;\n+use crate::fold::DocFolder;\n+use crate::passes::{look_for_tests, Pass};\n \n-use core::DocContext;\n-use fold::DocFolder;\n-\n-use passes::{look_for_tests, Pass};\n \n pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass =\n     Pass::early(\"check-private-items-doc-tests\", check_private_items_doc_tests,\n@@ -21,7 +20,7 @@ impl<'a, 'tcx, 'rcx> PrivateItemDocTestLinter<'a, 'tcx, 'rcx> {\n     }\n }\n \n-pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext) -> Crate {\n+pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     let mut coll = PrivateItemDocTestLinter::new(cx);\n \n     coll.fold_crate(krate)"}, {"sha": "9ba0b2272869125acde15fbc77223ccf5067dedd", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,9 +1,9 @@\n use std::sync::Arc;\n \n-use clean::{Crate, Item};\n-use clean::cfg::Cfg;\n-use fold::DocFolder;\n-use passes::Pass;\n+use crate::clean::{Crate, Item};\n+use crate::clean::cfg::Cfg;\n+use crate::fold::DocFolder;\n+use crate::passes::Pass;\n \n pub const PROPAGATE_DOC_CFG: Pass =\n     Pass::late(\"propagate-doc-cfg\", propagate_doc_cfg,"}, {"sha": "b3d50e06816c5cc8d07b4d6fabeaefaed081a3d1", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,20 +1,18 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n \n-use clean::{self, AttributesExt, NestedAttributesExt};\n-use clean::Item;\n-use core::DocContext;\n-use fold;\n-use fold::DocFolder;\n-use fold::StripItem;\n-use passes::{ImplStripper, Pass};\n+use crate::clean::{self, AttributesExt, NestedAttributesExt};\n+use crate::clean::Item;\n+use crate::core::DocContext;\n+use crate::fold::{DocFolder, StripItem};\n+use crate::passes::{ImplStripper, Pass};\n \n pub const STRIP_HIDDEN: Pass =\n     Pass::early(\"strip-hidden\", strip_hidden,\n                 \"strips all doc(hidden) items from the output\");\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate, _: &DocContext) -> clean::Crate {\n+pub fn strip_hidden(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items\n@@ -35,7 +33,7 @@ struct Stripper<'a> {\n     update_retained: bool,\n }\n \n-impl<'a> fold::DocFolder for Stripper<'a> {\n+impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n             debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);"}, {"sha": "3af1403e8749cc251248a76091392534d17afefe", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,11 +1,11 @@\n-use clean;\n-use core::DocContext;\n-use fold::DocFolder;\n-use passes::{ImportStripper, Pass};\n+use crate::clean;\n+use crate::fold::{DocFolder};\n+use crate::core::DocContext;\n+use crate::passes::{ImportStripper, Pass};\n \n pub const STRIP_PRIV_IMPORTS: Pass = Pass::early(\"strip-priv-imports\", strip_priv_imports,\n      \"strips all private import statements (`use`, `extern crate`) from a crate\");\n \n-pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext)  -> clean::Crate {\n+pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_, '_, '_>)  -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "e553d792eb697329fe683bff733468cc988368d6", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,9 +1,9 @@\n use rustc::util::nodemap::DefIdSet;\n \n-use clean;\n-use core::DocContext;\n-use fold::DocFolder;\n-use passes::{ImplStripper, ImportStripper, Stripper, Pass};\n+use crate::clean;\n+use crate::fold::{DocFolder};\n+use crate::core::DocContext;\n+use crate::passes::{ImplStripper, ImportStripper, Stripper, Pass};\n \n pub const STRIP_PRIVATE: Pass =\n     Pass::early(\"strip-private\", strip_private,\n@@ -12,7 +12,7 @@ pub const STRIP_PRIVATE: Pass =\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n+pub fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_, '_, '_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "269e4cbe65f8bbb98a8307a9fd8cb3d1907e7d15", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2,9 +2,9 @@ use std::cmp;\n use std::string::String;\n use std::usize;\n \n-use clean::{self, DocFragment, Item};\n-use fold::{self, DocFolder};\n-use passes::Pass;\n+use crate::clean::{self, DocFragment, Item};\n+use crate::fold::{self, DocFolder};\n+use crate::passes::Pass;\n \n pub const UNINDENT_COMMENTS: Pass =\n     Pass::late(\"unindent-comments\", unindent_comments,"}, {"sha": "3fdded6a4ab386fa0f7a1c93bc88bcc661fd9627", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -28,9 +28,9 @@ use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n \n-use clean::Attributes;\n-use config::Options;\n-use html::markdown::{self, ErrorCodes, LangString};\n+use crate::clean::Attributes;\n+use crate::config::Options;\n+use crate::html::markdown::{self, ErrorCodes, LangString};\n \n #[derive(Clone, Default)]\n pub struct TestOptions {"}, {"sha": "2428a823d0b39d81c6585f53c824b7ad9d2bedbb", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -14,9 +14,10 @@ use syntax_pos::{self, Span};\n \n use std::mem;\n \n-use core;\n-use clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n-use doctree::*;\n+use crate::core;\n+use crate::clean::{self, AttributesExt, NestedAttributesExt, def_id_to_path};\n+use crate::doctree::*;\n+\n \n // Looks to me like the first two of these are actually\n // output parameters, maybe only mutated once; perhaps\n@@ -268,7 +269,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                           om: &mut Module,\n                           please_inline: bool) -> bool {\n \n-        fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n+        fn inherits_doc_hidden(cx: &core::DocContext<'_, '_, '_>, mut node: ast::NodeId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n                 if cx.tcx.hir().attrs(node).lists(\"doc\").has_word(\"hidden\") {\n@@ -315,7 +316,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                         .insert(did, AccessLevel::Public);\n                 },\n                 Def::Mod(did) => if !self_is_hidden {\n-                    ::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n+                    crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n                 },\n                 _ => {},\n             }"}, {"sha": "f538c58c213ee203ec17d80336c04a4ee3809513", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -6,14 +6,14 @@ use rustc::util::nodemap::FxHashSet;\n \n use std::cell::RefMut;\n \n-use clean::{AttributesExt, NestedAttributesExt};\n+use crate::clean::{AttributesExt, NestedAttributesExt};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a ::core::DocContext<'a, 'tcx, 'rcx>,\n+    cx: &'a crate::core::DocContext<'a, 'tcx, 'rcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -24,7 +24,7 @@ pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n \n impl<'a, 'tcx, 'rcx> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n     pub fn new(\n-        cx: &'a ::core::DocContext<'a, 'tcx, 'rcx>\n+        cx: &'a crate::core::DocContext<'a, 'tcx, 'rcx>\n     ) -> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n         LibEmbargoVisitor {\n             cx,"}, {"sha": "4dfbe86d14f4dedd2dd13f9d40925a127eb959d4", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -204,6 +204,7 @@ pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n }\n \n #[no_mangle]\n+// NB. used by both libunwind and libpanic_abort\n pub unsafe extern \"C\" fn __rust_abort() {\n     ::sys::abort_internal();\n }"}, {"sha": "e1f5e1fcb938dde5e46349af963edfdc149cc9eb", "filename": "src/libstd/time.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -23,9 +23,6 @@ use sys_common::mutex::Mutex;\n #[stable(feature = \"time\", since = \"1.3.0\")]\n pub use core::time::Duration;\n \n-#[unstable(feature = \"duration_constants\", issue = \"57391\")]\n-pub use core::time::{SECOND, MILLISECOND, MICROSECOND, NANOSECOND};\n-\n /// A measurement of a monotonically nondecreasing clock.\n /// Opaque and useful only with `Duration`.\n ///"}, {"sha": "b5fc8507314047a3fffb19635bb1e61b8723e49c", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -517,7 +517,7 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments }\n             }\n-            Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n+            Some(TokenTree::Token(_, Token::Interpolated(nt))) => match *nt {\n                 token::Nonterminal::NtIdent(ident, _) => Path::from_ident(ident),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n@@ -682,7 +682,7 @@ impl LitKind {\n         match token {\n             Token::Ident(ident, false) if ident.name == \"true\" => Some(LitKind::Bool(true)),\n             Token::Ident(ident, false) if ident.name == \"false\" => Some(LitKind::Bool(false)),\n-            Token::Interpolated(ref nt) => match nt.0 {\n+            Token::Interpolated(nt) => match *nt {\n                 token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n                     ExprKind::Lit(ref lit) => Some(lit.node.clone()),\n                     _ => None,"}, {"sha": "452cc2f2c65ccc68cee03502b9710cb35987f1ad", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -266,7 +266,7 @@ impl<F> TTMacroExpander for F\n         impl MutVisitor for AvoidInterpolatedIdents {\n             fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n                 if let tokenstream::TokenTree::Token(_, token::Interpolated(nt)) = tt {\n-                    if let token::NtIdent(ident, is_raw) = nt.0 {\n+                    if let token::NtIdent(ident, is_raw) = **nt {\n                         *tt = tokenstream::TokenTree::Token(ident.span,\n                                                             token::Ident(ident, is_raw));\n                     }"}, {"sha": "b805213bb1a4cad139ed72cebb9c5cdf80d4acde", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -25,6 +25,7 @@ use syntax_pos::{Span, DUMMY_SP, FileName};\n use syntax_pos::hygiene::ExpnFormat;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n use std::fs;\n use std::io::ErrorKind;\n use std::{iter, mem};\n@@ -584,14 +585,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             AttrProcMacro(ref mac, ..) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n-                let item_tok = TokenTree::Token(DUMMY_SP, Token::interpolated(match item {\n+                let item_tok = TokenTree::Token(DUMMY_SP, Token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n                     Annotatable::TraitItem(item) => token::NtTraitItem(item.into_inner()),\n                     Annotatable::ImplItem(item) => token::NtImplItem(item.into_inner()),\n                     Annotatable::ForeignItem(item) => token::NtForeignItem(item.into_inner()),\n                     Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n                     Annotatable::Expr(expr) => token::NtExpr(expr),\n-                })).into();\n+                }))).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n                 let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n                 let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,"}, {"sha": "fe1cffb092b1c30a3b7fa3af418a2eff4a42c537", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -88,6 +88,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n@@ -179,7 +180,7 @@ struct MatcherPos<'root, 'tt: 'root> {\n     /// all bound matches from the submatcher into the shared top-level `matches` vector. If `sep`\n     /// and `up` are `Some`, then `matches` is _not_ the shared top-level list. Instead, if one\n     /// wants the shared `matches`, one should use `up.matches`.\n-    matches: Box<[Rc<NamedMatchVec>]>,\n+    matches: Box<[Lrc<NamedMatchVec>]>,\n     /// The position in `matches` corresponding to the first metavar in this matcher's sequence of\n     /// token trees. In other words, the first metavar in the first token of `top_elts` corresponds\n     /// to `matches[match_lo]`.\n@@ -218,7 +219,7 @@ struct MatcherPos<'root, 'tt: 'root> {\n impl<'root, 'tt> MatcherPos<'root, 'tt> {\n     /// Adds `m` as a named match for the `idx`-th metavar.\n     fn push_match(&mut self, idx: usize, m: NamedMatch) {\n-        let matches = Rc::make_mut(&mut self.matches[idx]);\n+        let matches = Lrc::make_mut(&mut self.matches[idx]);\n         matches.push(m);\n     }\n }\n@@ -295,11 +296,11 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n }\n \n /// `len` `Vec`s (initially shared and empty) that will store matches of metavars.\n-fn create_matches(len: usize) -> Box<[Rc<NamedMatchVec>]> {\n+fn create_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {\n     if len == 0 {\n         vec![]\n     } else {\n-        let empty_matches = Rc::new(SmallVec::new());\n+        let empty_matches = Lrc::new(SmallVec::new());\n         vec![empty_matches; len]\n     }.into_boxed_slice()\n }\n@@ -353,8 +354,8 @@ fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree], open: Span) -> MatcherP\n /// token tree it was derived from.\n #[derive(Debug, Clone)]\n pub enum NamedMatch {\n-    MatchedSeq(Rc<NamedMatchVec>, DelimSpan),\n-    MatchedNonterminal(Rc<Nonterminal>),\n+    MatchedSeq(Lrc<NamedMatchVec>, DelimSpan),\n+    MatchedNonterminal(Lrc<Nonterminal>),\n }\n \n /// Takes a sequence of token trees `ms` representing a matcher which successfully matched input\n@@ -561,7 +562,7 @@ fn inner_parse_loop<'root, 'tt>(\n                         new_item.match_cur += seq.num_captures;\n                         new_item.idx += 1;\n                         for idx in item.match_cur..item.match_cur + seq.num_captures {\n-                            new_item.push_match(idx, MatchedSeq(Rc::new(smallvec![]), sp));\n+                            new_item.push_match(idx, MatchedSeq(Lrc::new(smallvec![]), sp));\n                         }\n                         cur_items.push(new_item);\n                     }\n@@ -707,7 +708,7 @@ pub fn parse(\n                 let matches = eof_items[0]\n                     .matches\n                     .iter_mut()\n-                    .map(|dv| Rc::make_mut(dv).pop().unwrap());\n+                    .map(|dv| Lrc::make_mut(dv).pop().unwrap());\n                 return nameize(sess, ms, matches);\n             } else if eof_items.len() > 1 {\n                 return Error(\n@@ -780,7 +781,7 @@ pub fn parse(\n                 let match_cur = item.match_cur;\n                 item.push_match(\n                     match_cur,\n-                    MatchedNonterminal(Rc::new(parse_nt(&mut parser, span, &ident.as_str()))),\n+                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, &ident.as_str()))),\n                 );\n                 item.idx += 1;\n                 item.match_cur += 1;\n@@ -829,7 +830,7 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n         },\n         \"block\" => match *token {\n             Token::OpenDelim(token::Brace) => true,\n-            Token::Interpolated(ref nt) => match nt.0 {\n+            Token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n                 | token::NtPat(_)\n                 | token::NtTy(_)\n@@ -843,9 +844,9 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n         },\n         \"path\" | \"meta\" => match *token {\n             Token::ModSep | Token::Ident(..) => true,\n-            Token::Interpolated(ref nt) => match nt.0 {\n+            Token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n-                _ => may_be_ident(&nt.0),\n+                _ => may_be_ident(&nt),\n             },\n             _ => false,\n         },\n@@ -862,12 +863,12 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n             Token::ModSep |                     // path\n             Token::Lt |                         // path (UFCS constant)\n             Token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            Token::Interpolated(ref nt) => may_be_ident(&nt.0),\n+            Token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n         \"lifetime\" => match *token {\n             Token::Lifetime(_) => true,\n-            Token::Interpolated(ref nt) => match nt.0 {\n+            Token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n                 _ => false,\n             },"}, {"sha": "bd2adb5ac13ba11ded836173314dcb1a69d3b916", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -149,7 +149,7 @@ pub fn transcribe(cx: &ExtCtxt<'_>,\n                             result.push(tt.clone().into());\n                         } else {\n                             sp = sp.apply_mark(cx.current_expansion.mark);\n-                            let token = TokenTree::Token(sp, Token::interpolated((**nt).clone()));\n+                            let token = TokenTree::Token(sp, Token::Interpolated(nt.clone()));\n                             result.push(token.into());\n                         }\n                     } else {"}, {"sha": "86849f580d081eda2fe59f9ce53c8769bf92070d", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -581,9 +581,8 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n         token::Ident(id, _is_raw) => vis.visit_ident(id),\n         token::Lifetime(id) => vis.visit_ident(id),\n         token::Interpolated(nt) => {\n-            let nt = Lrc::make_mut(nt);\n-            vis.visit_interpolated(&mut nt.0);\n-            nt.1 = token::LazyTokenStream::new();\n+            let mut nt = Lrc::make_mut(nt);\n+            vis.visit_interpolated(&mut nt);\n         }\n         _ => {}\n     }"}, {"sha": "9020c8c6a2dc66fb9c3760e11bab580e4e72b4f0", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -141,7 +141,7 @@ impl<'a> Parser<'a> {\n     /// The delimiters or `=` are still put into the resulting token stream.\n     crate fn parse_meta_item_unrestricted(&mut self) -> PResult<'a, (ast::Path, TokenStream)> {\n         let meta = match self.token {\n-            token::Interpolated(ref nt) => match nt.0 {\n+            token::Interpolated(ref nt) => match **nt {\n                 Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n                 _ => None,\n             },\n@@ -227,7 +227,7 @@ impl<'a> Parser<'a> {\n     /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token {\n-            token::Interpolated(ref nt) => match nt.0 {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n                 _ => None,\n             },"}, {"sha": "a7cde5fbb92cd27a83a1e78da595016fadb886cf", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -125,6 +125,28 @@ impl<'a> StringReader<'a> {\n         Ok(ret_val)\n     }\n \n+    /// Immutably extract string if found at current position with given delimiters\n+    pub fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<String> {\n+        let mut pos = self.pos;\n+        let mut idx = self.src_index(pos);\n+        let mut ch = char_at(&self.src, idx);\n+        if ch != from_ch {\n+            return None;\n+        }\n+        pos = pos + Pos::from_usize(ch.len_utf8());\n+        let start_pos = pos;\n+        idx = self.src_index(pos);\n+        while idx < self.end_src_index {\n+            ch = char_at(&self.src, idx);\n+            if ch == to_ch {\n+                return Some(self.src[self.src_index(start_pos)..self.src_index(pos)].to_string());\n+            }\n+            pos = pos + Pos::from_usize(ch.len_utf8());\n+            idx = self.src_index(pos);\n+        }\n+        return None;\n+    }\n+\n     fn try_real_token(&mut self) -> Result<TokenAndSpan, ()> {\n         let mut t = self.try_next_token()?;\n         loop {"}, {"sha": "94ce6297fbefbfcfb9d13d09b8c05af344e56e60", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,7 +1,7 @@\n // Characters and their corresponding confusables were collected from\n // http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n-use syntax_pos::{Span, NO_EXPANSION};\n+use syntax_pos::{Span, Pos, NO_EXPANSION};\n use errors::{Applicability, DiagnosticBuilder};\n use super::StringReader;\n \n@@ -333,14 +333,27 @@ crate fn check_for_substitution<'a>(reader: &StringReader<'a>,\n         let span = Span::new(reader.pos, reader.next_pos, NO_EXPANSION);\n         match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n             Some(&(ascii_char, ascii_name)) => {\n-                let msg =\n-                    format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n-                            ch, u_name, ascii_char, ascii_name);\n-                err.span_suggestion(\n-                    span,\n-                    &msg,\n-                    ascii_char.to_string(),\n-                    Applicability::MaybeIncorrect);\n+                // special help suggestion for \"directed\" double quotes\n+                if let Some(s) = reader.peek_delimited('\u201c', '\u201d') {\n+                    let msg = format!(\"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n+                        '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n+                                ascii_char, ascii_name);\n+                    err.span_suggestion(\n+                        Span::new(reader.pos, reader.next_pos + Pos::from_usize(s.len()) +\n+                            Pos::from_usize('\u201d'.len_utf8()), NO_EXPANSION),\n+                        &msg,\n+                        format!(\"\\\"{}\\\"\", s),\n+                        Applicability::MaybeIncorrect);\n+                } else {\n+                    let msg =\n+                        format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n+                                ch, u_name, ascii_char, ascii_name);\n+                    err.span_suggestion(\n+                        span,\n+                        &msg,\n+                        ascii_char.to_string(),\n+                        Applicability::MaybeIncorrect);\n+                }\n                 true\n             },\n             None => {"}, {"sha": "5a753e1f8c8a5d932c6d7c09513bba9d0be5cd2b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -119,7 +119,7 @@ enum BlockMode {\n macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n         if let token::Interpolated(nt) = $p.token.clone() {\n-            match nt.0 {\n+            match *nt {\n                 token::NtExpr(ref e) | token::NtLiteral(ref e) => {\n                     $p.bump();\n                     return Ok((*e).clone());\n@@ -146,7 +146,7 @@ macro_rules! maybe_whole_expr {\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n         if let token::Interpolated(nt) = $p.token.clone() {\n-            if let token::$constructor($x) = nt.0.clone() {\n+            if let token::$constructor($x) = (*nt).clone() {\n                 $p.bump();\n                 return Ok($e);\n             }\n@@ -1184,8 +1184,10 @@ impl<'a> Parser<'a> {\n         match ate {\n             Some(_) => {\n                 // See doc comment for `unmatched_angle_bracket_count`.\n-                self.unmatched_angle_bracket_count -= 1;\n-                debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+                if self.unmatched_angle_bracket_count > 0 {\n+                    self.unmatched_angle_bracket_count -= 1;\n+                    debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+                }\n \n                 Ok(())\n             },\n@@ -1570,7 +1572,7 @@ impl<'a> Parser<'a> {\n                     Some(body)\n                 }\n                 token::Interpolated(ref nt) => {\n-                    match &nt.0 {\n+                    match **nt {\n                         token::NtBlock(..) => {\n                             *at_end = true;\n                             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -1913,7 +1915,7 @@ impl<'a> Parser<'a> {\n \n     fn is_named_argument(&mut self) -> bool {\n         let offset = match self.token {\n-            token::Interpolated(ref nt) => match nt.0 {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             }\n@@ -2099,7 +2101,7 @@ impl<'a> Parser<'a> {\n     /// Matches `token_lit = LIT_INTEGER | ...`.\n     fn parse_lit_token(&mut self) -> PResult<'a, LitKind> {\n         let out = match self.token {\n-            token::Interpolated(ref nt) => match nt.0 {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtExpr(ref v) | token::NtLiteral(ref v) => match v.node {\n                     ExprKind::Lit(ref lit) => { lit.node.clone() }\n                     _ => { return self.unexpected_last(&self.token); }\n@@ -2248,8 +2250,10 @@ impl<'a> Parser<'a> {\n \n         // See doc comment for `unmatched_angle_bracket_count`.\n         self.expect(&token::Gt)?;\n-        self.unmatched_angle_bracket_count -= 1;\n-        debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+        if self.unmatched_angle_bracket_count > 0 {\n+            self.unmatched_angle_bracket_count -= 1;\n+            debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+        }\n \n         self.expect(&token::ModSep)?;\n \n@@ -2299,7 +2303,7 @@ impl<'a> Parser<'a> {\n     /// attributes.\n     pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n         let meta_ident = match self.token {\n-            token::Interpolated(ref nt) => match nt.0 {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref meta) => match meta.node {\n                     ast::MetaItemKind::Word => Some(meta.ident.clone()),\n                     _ => None,\n@@ -3271,7 +3275,7 @@ impl<'a> Parser<'a> {\n                 self.meta_var_span = Some(self.span);\n                 // Interpolated identifier and lifetime tokens are replaced with usual identifier\n                 // and lifetime tokens, so the former are never encountered during normal parsing.\n-                match nt.0 {\n+                match **nt {\n                     token::NtIdent(ident, is_raw) => (token::Ident(ident, is_raw), ident.span),\n                     token::NtLifetime(ident) => (token::Lifetime(ident), ident.span),\n                     _ => return,\n@@ -3403,7 +3407,7 @@ impl<'a> Parser<'a> {\n                     // can't continue an expression after an ident\n                     token::Ident(ident, is_raw) => token::ident_can_begin_expr(ident, is_raw),\n                     token::Literal(..) | token::Pound => true,\n-                    token::Interpolated(ref nt) => match nt.0 {\n+                    token::Interpolated(ref nt) => match **nt {\n                         token::NtIdent(..) | token::NtExpr(..) |\n                         token::NtBlock(..) | token::NtPath(..) => true,\n                         _ => false,"}, {"sha": "eec422d6266c36574f01db02cb660d3510d26833", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 92, "deletions": 156, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -13,16 +13,15 @@ use crate::syntax::parse::parse_stream_from_source_str;\n use crate::syntax::parse::parser::emit_unclosed_delims;\n use crate::tokenstream::{self, DelimSpan, TokenStream, TokenTree};\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n use syntax_pos::symbol::{self, Symbol};\n use syntax_pos::{self, Span, FileName};\n use log::info;\n \n-use std::{cmp, fmt};\n+use std::fmt;\n use std::mem;\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert;\n-use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sync::Lrc;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOpToken {\n@@ -87,7 +86,7 @@ impl Lit {\n         }\n     }\n \n-    // See comments in `interpolated_to_tokenstream` for why we care about\n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     fn probably_equal_for_proc_macro(&self, other: &Lit) -> bool {\n         mem::discriminant(self) == mem::discriminant(other)\n@@ -184,9 +183,8 @@ pub enum Token {\n     Ident(ast::Ident, /* is_raw */ bool),\n     Lifetime(ast::Ident),\n \n-    // The `LazyTokenStream` is a pure function of the `Nonterminal`,\n-    // and so the `LazyTokenStream` can be ignored by Eq, Hash, etc.\n-    Interpolated(Lrc<(Nonterminal, LazyTokenStream)>),\n+    Interpolated(Lrc<Nonterminal>),\n+\n     // Can be expanded into several tokens.\n     /// A doc comment.\n     DocComment(ast::Name),\n@@ -209,10 +207,6 @@ pub enum Token {\n static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Token>() == 16);\n \n impl Token {\n-    pub fn interpolated(nt: Nonterminal) -> Token {\n-        Token::Interpolated(Lrc::new((nt, LazyTokenStream::new())))\n-    }\n-\n     /// Recovers a `Token` from an `ast::Ident`. This creates a raw identifier if necessary.\n     pub fn from_ast_ident(ident: ast::Ident) -> Token {\n         Ident(ident, ident.is_raw_guess())\n@@ -244,7 +238,7 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt) => match nt.0 {\n+            Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) |\n                 NtIdent(..)   |\n                 NtExpr(..)    |\n@@ -272,7 +266,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt) => match nt.0 {\n+            Interpolated(ref nt) => match **nt {\n                 NtIdent(..) | NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n                 _ => false,\n             },\n@@ -284,7 +278,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt) => match nt.0 {\n+            Interpolated(ref nt) => match **nt {\n                 NtExpr(..) => true,\n                 NtBlock(..) => true,\n                 NtLiteral(..) => true,\n@@ -316,7 +310,7 @@ impl Token {\n             BinOp(Minus) => true,\n             Ident(ident, false) if ident.name == keywords::True.name() => true,\n             Ident(ident, false) if ident.name == keywords::False.name() => true,\n-            Interpolated(ref nt) => match nt.0 {\n+            Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) => true,\n                 _             => false,\n             },\n@@ -328,7 +322,7 @@ impl Token {\n     pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n         match *self {\n             Ident(ident, is_raw) => Some((ident, is_raw)),\n-            Interpolated(ref nt) => match nt.0 {\n+            Interpolated(ref nt) => match **nt {\n                 NtIdent(ident, is_raw) => Some((ident, is_raw)),\n                 _ => None,\n             },\n@@ -339,7 +333,7 @@ impl Token {\n     pub fn lifetime(&self) -> Option<ast::Ident> {\n         match *self {\n             Lifetime(ident) => Some(ident),\n-            Interpolated(ref nt) => match nt.0 {\n+            Interpolated(ref nt) => match **nt {\n                 NtLifetime(ident) => Some(ident),\n                 _ => None,\n             },\n@@ -367,7 +361,7 @@ impl Token {\n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n         if let Interpolated(ref nt) = *self {\n-            if let NtPath(..) = nt.0 {\n+            if let NtPath(..) = **nt {\n                 return true;\n             }\n         }\n@@ -508,98 +502,7 @@ impl Token {\n         }\n     }\n \n-    pub fn interpolated_to_tokenstream(&self, sess: &ParseSess, span: Span)\n-        -> TokenStream\n-    {\n-        let nt = match *self {\n-            Token::Interpolated(ref nt) => nt,\n-            _ => panic!(\"only works on interpolated tokens\"),\n-        };\n-\n-        // An `Interpolated` token means that we have a `Nonterminal`\n-        // which is often a parsed AST item. At this point we now need\n-        // to convert the parsed AST to an actual token stream, e.g.\n-        // un-parse it basically.\n-        //\n-        // Unfortunately there's not really a great way to do that in a\n-        // guaranteed lossless fashion right now. The fallback here is\n-        // to just stringify the AST node and reparse it, but this loses\n-        // all span information.\n-        //\n-        // As a result, some AST nodes are annotated with the token\n-        // stream they came from. Here we attempt to extract these\n-        // lossless token streams before we fall back to the\n-        // stringification.\n-        let mut tokens = None;\n-\n-        match nt.0 {\n-            Nonterminal::NtItem(ref item) => {\n-                tokens = prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span);\n-            }\n-            Nonterminal::NtTraitItem(ref item) => {\n-                tokens = prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span);\n-            }\n-            Nonterminal::NtImplItem(ref item) => {\n-                tokens = prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span);\n-            }\n-            Nonterminal::NtIdent(ident, is_raw) => {\n-                let token = Token::Ident(ident, is_raw);\n-                tokens = Some(TokenTree::Token(ident.span, token).into());\n-            }\n-            Nonterminal::NtLifetime(ident) => {\n-                let token = Token::Lifetime(ident);\n-                tokens = Some(TokenTree::Token(ident.span, token).into());\n-            }\n-            Nonterminal::NtTT(ref tt) => {\n-                tokens = Some(tt.clone().into());\n-            }\n-            _ => {}\n-        }\n-\n-        let tokens_for_real = nt.1.force(|| {\n-            // FIXME(#43081): Avoid this pretty-print + reparse hack\n-            let source = pprust::token_to_string(self);\n-            let filename = FileName::macro_expansion_source_code(&source);\n-            let (tokens, errors) = parse_stream_from_source_str(\n-                filename, source, sess, Some(span));\n-            emit_unclosed_delims(&errors, &sess.span_diagnostic);\n-            tokens\n-        });\n-\n-        // During early phases of the compiler the AST could get modified\n-        // directly (e.g., attributes added or removed) and the internal cache\n-        // of tokens my not be invalidated or updated. Consequently if the\n-        // \"lossless\" token stream disagrees with our actual stringification\n-        // (which has historically been much more battle-tested) then we go\n-        // with the lossy stream anyway (losing span information).\n-        //\n-        // Note that the comparison isn't `==` here to avoid comparing spans,\n-        // but it *also* is a \"probable\" equality which is a pretty weird\n-        // definition. We mostly want to catch actual changes to the AST\n-        // like a `#[cfg]` being processed or some weird `macro_rules!`\n-        // expansion.\n-        //\n-        // What we *don't* want to catch is the fact that a user-defined\n-        // literal like `0xf` is stringified as `15`, causing the cached token\n-        // stream to not be literal `==` token-wise (ignoring spans) to the\n-        // token stream we got from stringification.\n-        //\n-        // Instead the \"probably equal\" check here is \"does each token\n-        // recursively have the same discriminant?\" We basically don't look at\n-        // the token values here and assume that such fine grained token stream\n-        // modifications, including adding/removing typically non-semantic\n-        // tokens such as extra braces and commas, don't happen.\n-        if let Some(tokens) = tokens {\n-            if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n-                return tokens\n-            }\n-            info!(\"cached tokens found, but they're not \\\"probably equal\\\", \\\n-                   going with stringified version\");\n-        }\n-        return tokens_for_real\n-    }\n-\n-    // See comments in `interpolated_to_tokenstream` for why we care about\n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     crate fn probably_equal_for_proc_macro(&self, other: &Token) -> bool {\n         if mem::discriminant(self) != mem::discriminant(other) {\n@@ -731,61 +634,94 @@ impl fmt::Debug for Nonterminal {\n     }\n }\n \n-crate fn is_op(tok: &Token) -> bool {\n-    match *tok {\n-        OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) |\n-        Ident(..) | Lifetime(..) | Interpolated(..) |\n-        Whitespace | Comment | Shebang(..) | Eof => false,\n-        _ => true,\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct LazyTokenStream(Lock<Option<TokenStream>>);\n-\n-impl cmp::Eq for LazyTokenStream {}\n-impl PartialEq for LazyTokenStream {\n-    fn eq(&self, _other: &LazyTokenStream) -> bool {\n-        true\n-    }\n-}\n-\n-impl fmt::Debug for LazyTokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(&self.clone().0.into_inner(), f)\n-    }\n-}\n+impl Nonterminal {\n+    pub fn to_tokenstream(&self, sess: &ParseSess, span: Span) -> TokenStream {\n+        // A `Nonterminal` is often a parsed AST item. At this point we now\n+        // need to convert the parsed AST to an actual token stream, e.g.\n+        // un-parse it basically.\n+        //\n+        // Unfortunately there's not really a great way to do that in a\n+        // guaranteed lossless fashion right now. The fallback here is to just\n+        // stringify the AST node and reparse it, but this loses all span\n+        // information.\n+        //\n+        // As a result, some AST nodes are annotated with the token stream they\n+        // came from. Here we attempt to extract these lossless token streams\n+        // before we fall back to the stringification.\n+        let tokens = match *self {\n+            Nonterminal::NtItem(ref item) => {\n+                prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n+            }\n+            Nonterminal::NtTraitItem(ref item) => {\n+                prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n+            }\n+            Nonterminal::NtImplItem(ref item) => {\n+                prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n+            }\n+            Nonterminal::NtIdent(ident, is_raw) => {\n+                let token = Token::Ident(ident, is_raw);\n+                Some(TokenTree::Token(ident.span, token).into())\n+            }\n+            Nonterminal::NtLifetime(ident) => {\n+                let token = Token::Lifetime(ident);\n+                Some(TokenTree::Token(ident.span, token).into())\n+            }\n+            Nonterminal::NtTT(ref tt) => {\n+                Some(tt.clone().into())\n+            }\n+            _ => None,\n+        };\n \n-impl LazyTokenStream {\n-    pub fn new() -> Self {\n-        LazyTokenStream(Lock::new(None))\n-    }\n+        // FIXME(#43081): Avoid this pretty-print + reparse hack\n+        let source = pprust::nonterminal_to_string(self);\n+        let filename = FileName::macro_expansion_source_code(&source);\n+        let (tokens_for_real, errors) =\n+            parse_stream_from_source_str(filename, source, sess, Some(span));\n+        emit_unclosed_delims(&errors, &sess.span_diagnostic);\n \n-    fn force<F: FnOnce() -> TokenStream>(&self, f: F) -> TokenStream {\n-        let mut opt_stream = self.0.lock();\n-        if opt_stream.is_none() {\n-            *opt_stream = Some(f());\n+        // During early phases of the compiler the AST could get modified\n+        // directly (e.g., attributes added or removed) and the internal cache\n+        // of tokens my not be invalidated or updated. Consequently if the\n+        // \"lossless\" token stream disagrees with our actual stringification\n+        // (which has historically been much more battle-tested) then we go\n+        // with the lossy stream anyway (losing span information).\n+        //\n+        // Note that the comparison isn't `==` here to avoid comparing spans,\n+        // but it *also* is a \"probable\" equality which is a pretty weird\n+        // definition. We mostly want to catch actual changes to the AST\n+        // like a `#[cfg]` being processed or some weird `macro_rules!`\n+        // expansion.\n+        //\n+        // What we *don't* want to catch is the fact that a user-defined\n+        // literal like `0xf` is stringified as `15`, causing the cached token\n+        // stream to not be literal `==` token-wise (ignoring spans) to the\n+        // token stream we got from stringification.\n+        //\n+        // Instead the \"probably equal\" check here is \"does each token\n+        // recursively have the same discriminant?\" We basically don't look at\n+        // the token values here and assume that such fine grained token stream\n+        // modifications, including adding/removing typically non-semantic\n+        // tokens such as extra braces and commas, don't happen.\n+        if let Some(tokens) = tokens {\n+            if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n+                return tokens\n+            }\n+            info!(\"cached tokens found, but they're not \\\"probably equal\\\", \\\n+                   going with stringified version\");\n         }\n-        opt_stream.clone().unwrap()\n-    }\n-}\n-\n-impl Encodable for LazyTokenStream {\n-    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> {\n-        Ok(())\n+        return tokens_for_real\n     }\n }\n \n-impl Decodable for LazyTokenStream {\n-    fn decode<D: Decoder>(_: &mut D) -> Result<LazyTokenStream, D::Error> {\n-        Ok(LazyTokenStream::new())\n+crate fn is_op(tok: &Token) -> bool {\n+    match *tok {\n+        OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) |\n+        Ident(..) | Lifetime(..) | Interpolated(..) |\n+        Whitespace | Comment | Shebang(..) | Eof => false,\n+        _ => true,\n     }\n }\n \n-impl ::std::hash::Hash for LazyTokenStream {\n-    fn hash<H: ::std::hash::Hasher>(&self, _hasher: &mut H) {}\n-}\n-\n fn prepend_attrs(sess: &ParseSess,\n                  attrs: &[ast::Attribute],\n                  tokens: Option<&tokenstream::TokenStream>,"}, {"sha": "dcf9815f6d1ba47a4df2facd444514455fb87293", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -4,7 +4,7 @@ use crate::ast::{Attribute, MacDelimiter, GenericArg};\n use crate::util::parser::{self, AssocOp, Fixity};\n use crate::attr;\n use crate::source_map::{self, SourceMap, Spanned};\n-use crate::parse::token::{self, BinOpToken, Token};\n+use crate::parse::token::{self, BinOpToken, Nonterminal, Token};\n use crate::parse::lexer::comments;\n use crate::parse::{self, ParseSess};\n use crate::print::pp::{self, Breaks};\n@@ -257,29 +257,33 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n-        token::Interpolated(ref nt) => match nt.0 {\n-            token::NtExpr(ref e)        => expr_to_string(e),\n-            token::NtMeta(ref e)        => meta_item_to_string(e),\n-            token::NtTy(ref e)          => ty_to_string(e),\n-            token::NtPath(ref e)        => path_to_string(e),\n-            token::NtItem(ref e)        => item_to_string(e),\n-            token::NtBlock(ref e)       => block_to_string(e),\n-            token::NtStmt(ref e)        => stmt_to_string(e),\n-            token::NtPat(ref e)         => pat_to_string(e),\n-            token::NtIdent(e, false)    => ident_to_string(e),\n-            token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n-            token::NtLifetime(e)        => ident_to_string(e),\n-            token::NtLiteral(ref e)     => expr_to_string(e),\n-            token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n-            token::NtArm(ref e)         => arm_to_string(e),\n-            token::NtImplItem(ref e)    => impl_item_to_string(e),\n-            token::NtTraitItem(ref e)   => trait_item_to_string(e),\n-            token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n-            token::NtWhereClause(ref e) => where_clause_to_string(e),\n-            token::NtArg(ref e)         => arg_to_string(e),\n-            token::NtVis(ref e)         => vis_to_string(e),\n-            token::NtForeignItem(ref e) => foreign_item_to_string(e),\n-        }\n+        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n+    }\n+}\n+\n+pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n+    match *nt {\n+        token::NtExpr(ref e)        => expr_to_string(e),\n+        token::NtMeta(ref e)        => meta_item_to_string(e),\n+        token::NtTy(ref e)          => ty_to_string(e),\n+        token::NtPath(ref e)        => path_to_string(e),\n+        token::NtItem(ref e)        => item_to_string(e),\n+        token::NtBlock(ref e)       => block_to_string(e),\n+        token::NtStmt(ref e)        => stmt_to_string(e),\n+        token::NtPat(ref e)         => pat_to_string(e),\n+        token::NtIdent(e, false)    => ident_to_string(e),\n+        token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n+        token::NtLifetime(e)        => ident_to_string(e),\n+        token::NtLiteral(ref e)     => expr_to_string(e),\n+        token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n+        token::NtArm(ref e)         => arm_to_string(e),\n+        token::NtImplItem(ref e)    => impl_item_to_string(e),\n+        token::NtTraitItem(ref e)   => trait_item_to_string(e),\n+        token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n+        token::NtWhereClause(ref e) => where_clause_to_string(e),\n+        token::NtArg(ref e)         => arg_to_string(e),\n+        token::NtVis(ref e)         => vis_to_string(e),\n+        token::NtForeignItem(ref e) => foreign_item_to_string(e),\n     }\n }\n "}, {"sha": "283679e758b54e5f6c45268b1ac4a9998a1b6b18", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -72,7 +72,7 @@ impl TokenTree {\n         }\n     }\n \n-    // See comments in `interpolated_to_tokenstream` for why we care about\n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     //\n     // This is otherwise the same as `eq_unspanned`, only recursing with a\n@@ -310,7 +310,7 @@ impl TokenStream {\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n-    // See comments in `interpolated_to_tokenstream` for why we care about\n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     //\n     // This is otherwise the same as `eq_unspanned`, only recursing with a"}, {"sha": "cfc3c931598a1df73a4372d3689a49813d0a3277", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -2,6 +2,7 @@ use crate::proc_macro_impl::EXEC_STRATEGY;\n use crate::proc_macro_server;\n \n use errors::FatalError;\n+use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, ItemKind, Attribute, Mac};\n use syntax::attr::{mark_used, mark_known};\n use syntax::source_map::Span;\n@@ -65,7 +66,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         // Mark attributes as known, and used.\n         MarkAttrs(&self.attrs).visit_item(&item);\n \n-        let token = Token::interpolated(token::NtItem(item));\n+        let token = Token::Interpolated(Lrc::new(token::NtItem(item)));\n         let input = tokenstream::TokenTree::Token(DUMMY_SP, token).into();\n \n         let server = proc_macro_server::Rustc::new(ecx);"}, {"sha": "699539b62f515b98238bd718e6523ff5aa2864e0", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -178,8 +178,8 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                 tt!(Punct::new('#', false))\n             }\n \n-            Interpolated(_) => {\n-                let stream = token.interpolated_to_tokenstream(sess, span);\n+            Interpolated(nt) => {\n+                let stream = nt.to_tokenstream(sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,"}, {"sha": "99cbf64fd5d466b6a3701d981fa651ef60760b53", "filename": "src/test/ui/borrowck/borrowck-uninit-field-access.ast.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.ast.nll.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -20,7 +20,7 @@ error[E0382]: use of moved value: `line2`\n LL |     let _moved = (line2.origin, line2.middle);\n    |                                 ------------ value moved here\n LL |     line2.consume(); //[ast]~ ERROR use of partially moved value: `line2` [E0382]\n-   |     ^^^^^ value used here after move\n+   |     ^^^^^ value used here after partial move\n    |\n    = note: move occurs because `line2.middle` has type `Point`, which does not implement the `Copy` trait\n "}, {"sha": "99cbf64fd5d466b6a3701d981fa651ef60760b53", "filename": "src/test/ui/borrowck/borrowck-uninit-field-access.mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.mir.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -20,7 +20,7 @@ error[E0382]: use of moved value: `line2`\n LL |     let _moved = (line2.origin, line2.middle);\n    |                                 ------------ value moved here\n LL |     line2.consume(); //[ast]~ ERROR use of partially moved value: `line2` [E0382]\n-   |     ^^^^^ value used here after move\n+   |     ^^^^^ value used here after partial move\n    |\n    = note: move occurs because `line2.middle` has type `Point`, which does not implement the `Copy` trait\n "}, {"sha": "6fd8e9cbc806b17c872bcc12c77623134faa428a", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -3,11 +3,11 @@\n //\n // This test is checking the count in an array expression.\n \n-// FIXME (#23926): the error output is not consistent between a\n-// self-hosted and a cross-compiled setup; therefore resorting to\n-// error-pattern for now.\n \n-// error-pattern: attempt to add with overflow\n+\n+\n+\n+\n \n #![allow(unused_imports)]\n \n@@ -18,6 +18,7 @@ use std::{u8, u16, u32, u64, usize};\n const A_I8_I\n     : [u32; (i8::MAX as usize) + 1]\n     = [0; (i8::MAX + 1) as usize];\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n     foo(&A_I8_I[..]);"}, {"sha": "d9b06370dff794b5171756aa73869db418dc1794", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -7,11 +7,11 @@\n // types for the left- and right-hand sides of the addition do not\n // match (as well as overflow).\n \n-// FIXME (#23926): the error output is not consistent between a\n-// self-hosted and a cross-compiled setup; therefore resorting to\n-// error-pattern for now.\n \n-// error-pattern: mismatched types\n+\n+\n+\n+\n \n #![allow(unused_imports)]\n \n@@ -22,6 +22,8 @@ use std::{u8, u16, u32, u64, usize};\n const A_I8_I\n     : [u32; (i8::MAX as usize) + 1]\n     = [0; (i8::MAX + 1u8) as usize];\n+//~^ ERROR mismatched types\n+//~| ERROR cannot add `u8` to `i8`\n \n fn main() {\n     foo(&A_I8_I[..]);"}, {"sha": "0d8f30159b3160fb19958338d5f2fa95d5c15208", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,10 +1,12 @@\n+// ignore-tidy-linelength\n #![feature(const_transmute)]\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n \n const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n //~^ ERROR it is undefined behavior to use this value\n+//~^^ type validation failed: encountered unaligned reference (required 2 byte alignment but found 1)\n \n const NULL: &u16 = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value"}, {"sha": "33535c235e3a341f8186e8e98689ad775c6f8237", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,37 +1,37 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:6:1\n+  --> $DIR/ub-ref.rs:7:1\n    |\n LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned reference\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned reference (required 2 byte alignment but found 1)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:9:1\n+  --> $DIR/ub-ref.rs:11:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:12:1\n+  --> $DIR/ub-ref.rs:14:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:15:1\n+  --> $DIR/ub-ref.rs:17:1\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:18:1\n+  --> $DIR/ub-ref.rs:20:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered integer pointer in non-ZST reference"}, {"sha": "8b244a47232fab30b084d723e4250b50117aa274", "filename": "src/test/ui/huge-array-simple.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fhuge-array-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fhuge-array-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-array-simple.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,11 +1,16 @@\n-// FIXME (#23926): the error output is not consistent between a\n-// self-hosted and a cross-compiled setup. Skipping for now.\n-\n-// ignore-test FIXME(#23926)\n+// error-pattern: too big for the current architecture\n \n+// normalize-stderr-test \"; \\d+]\" -> \"; N]\"\n #![allow(exceeding_bitshifts)]\n \n+#[cfg(target_pointer_width = \"64\")]\n fn main() {\n     let _fat : [u8; (1<<61)+(1<<31)] =\n         [0; (1u64<<61) as usize +(1u64<<31) as usize];\n }\n+\n+#[cfg(target_pointer_width = \"32\")]\n+fn main() {\n+    let _fat : [u8; (1<<31)+(1<<15)] =\n+        [0; (1u32<<31) as usize +(1u32<<15) as usize];\n+}"}, {"sha": "3e9c86296cec2ecdd74b1f022001b76d73dfd927", "filename": "src/test/ui/huge-array-simple.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fhuge-array-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fhuge-array-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhuge-array-simple.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -0,0 +1,4 @@\n+error: the type `[u8; N]` is too big for the current architecture\n+\n+error: aborting due to previous error\n+"}, {"sha": "5f0d2b42671de71633e5053db328e0981ad9fc52", "filename": "src/test/ui/moves/moves-based-on-type-cyclic-types-issue-4821.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-cyclic-types-issue-4821.nll.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -5,7 +5,7 @@ LL |         Some(right) => consume(right),\n    |              ----- value moved here\n ...\n LL |     consume(node) + r //~ ERROR use of partially moved value: `node`\n-   |             ^^^^ value used here after move\n+   |             ^^^^ value used here after partial move\n    |\n    = note: move occurs because value has type `std::boxed::Box<List>`, which does not implement the `Copy` trait\n "}, {"sha": "6d523fc09c08b9dcddcc025f7bbd6934963868f1", "filename": "src/test/ui/moves/moves-based-on-type-match-bindings.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-match-bindings.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-match-bindings.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-match-bindings.nll.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -5,7 +5,7 @@ LL |         Foo {f} => {}\n    |              - value moved here\n ...\n LL |     touch(&x); //~ ERROR use of partially moved value: `x`\n-   |           ^^ value borrowed here after move\n+   |           ^^ value borrowed here after partial move\n    |\n    = note: move occurs because `x.f` has type `std::string::String`, which does not implement the `Copy` trait\n "}, {"sha": "8b52cc113ccc5fc1660eb5e3955d22c1fd231868", "filename": "src/test/ui/nll/move-subpaths-moves-root.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fmove-subpaths-moves-root.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fmove-subpaths-moves-root.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmove-subpaths-moves-root.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -4,7 +4,7 @@ error[E0382]: use of moved value: `x`\n LL |     drop(x.0);\n    |          --- value moved here\n LL |     drop(x); //~ ERROR use of moved value\n-   |          ^ value used here after move\n+   |          ^ value used here after partial move\n    |\n    = note: move occurs because `x.0` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n "}, {"sha": "45f56836d18b539f4d9eb2122a6b44782e469021", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -15,5 +15,7 @@ fn main() {\n \n     SomeStruct::<_> { t: 22 }; // Nothing interesting given, no annotation.\n \n-    SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]\n+    SomeStruct::<u32> { t: 22 }; // No lifetime bounds given.\n+\n+    SomeStruct::<&'static u32> { t: &22 }; //~ ERROR [&ReStatic u32]\n }"}, {"sha": "6e24da094e0d2fb36bbfb4a36e51eca664d9207b", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,8 +1,8 @@\n-error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n-  --> $DIR/dump-adt-brace-struct.rs:18:5\n+error: user substs: UserSubsts { substs: [&ReStatic u32], user_self_ty: None }\n+  --> $DIR/dump-adt-brace-struct.rs:20:5\n    |\n-LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     SomeStruct::<&'static u32> { t: &22 }; //~ ERROR [&ReStatic u32]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b689f18c2259319f12043c07e931189862495b74", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -11,7 +11,7 @@ trait Bazoom<T> {\n     fn method<U>(&self, arg: T, arg2: U) { }\n }\n \n-impl<T, U> Bazoom<U> for T {\n+impl<S, T> Bazoom<T> for S {\n }\n \n fn foo<'a, T>(_: T) { }\n@@ -22,20 +22,29 @@ fn main() {\n     let x = foo;\n     x(22);\n \n-    // Here: `u32` is given.\n-    let x = foo::<u32>; //~ ERROR [u32]\n+    // Here: `u32` is given, which doesn't contain any lifetimes, so we don't\n+    // have any annotation.\n+    let x = foo::<u32>;\n     x(22);\n \n+    let x = foo::<&'static u32>; //~ ERROR [&ReStatic u32]\n+    x(&22);\n+\n     // Here: we only want the `T` to be given, the rest should be variables.\n     //\n     // (`T` refers to the declaration of `Bazoom`)\n     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n     x(&22, 44, 66);\n \n-    // Here: all are given\n-    let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n+    // Here: all are given and definitely contain no lifetimes, so we\n+    // don't have any annotation.\n+    let x = <u8 as Bazoom<u16>>::method::<u32>;\n     x(&22, 44, 66);\n \n+    // Here: all are given and we have a lifetime.\n+    let x = <u8 as Bazoom<&'static u16>>::method::<u32>; //~ ERROR [u8, &ReStatic u16, u32]\n+    x(&22, &44, 66);\n+\n     // Here: we want in particular that *only* the method `U`\n     // annotation is given, the rest are variables.\n     //"}, {"sha": "04ceb8e5f84953a77dee83d965827fd729a3c332", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -1,23 +1,23 @@\n-error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n-  --> $DIR/dump-fn-method.rs:26:13\n+error: user substs: UserSubsts { substs: [&ReStatic u32], user_self_ty: None }\n+  --> $DIR/dump-fn-method.rs:30:13\n    |\n-LL |     let x = foo::<u32>; //~ ERROR [u32]\n-   |             ^^^^^^^^^^\n+LL |     let x = foo::<&'static u32>; //~ ERROR [&ReStatic u32]\n+   |             ^^^^^^^^^^^^^^^^^^^\n \n error: user substs: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None }\n-  --> $DIR/dump-fn-method.rs:32:13\n+  --> $DIR/dump-fn-method.rs:36:13\n    |\n LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: UserSubsts { substs: [u8, u16, u32], user_self_ty: None }\n-  --> $DIR/dump-fn-method.rs:36:13\n+error: user substs: UserSubsts { substs: [u8, &ReStatic u16, u32], user_self_ty: None }\n+  --> $DIR/dump-fn-method.rs:45:13\n    |\n-LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let x = <u8 as Bazoom<&'static u16>>::method::<u32>; //~ ERROR [u8, &ReStatic u16, u32]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: user substs: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None }\n-  --> $DIR/dump-fn-method.rs:44:5\n+  --> $DIR/dump-fn-method.rs:53:5\n    |\n LL |     y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "2490187605ac1ecae4d2d137a72419b352b86f79", "filename": "src/test/ui/nll/user-annotations/inherent-associated-constants.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Finherent-associated-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Finherent-associated-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Finherent-associated-constants.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -0,0 +1,17 @@\n+#![feature(nll)]\n+\n+struct A<'a>(&'a ());\n+\n+impl A<'static> {\n+    const IC: i32 = 10;\n+}\n+\n+fn non_wf_associated_const<'a>(x: i32) {\n+    A::<'a>::IC; //~ ERROR lifetime may not live long enough\n+}\n+\n+fn wf_associated_const<'a>(x: i32) {\n+    A::<'static>::IC;\n+}\n+\n+fn main() {}"}, {"sha": "785b39ec887a0c75baef99ec6bbed1ea623ed009", "filename": "src/test/ui/nll/user-annotations/inherent-associated-constants.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Finherent-associated-constants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Finherent-associated-constants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Finherent-associated-constants.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/inherent-associated-constants.rs:10:5\n+   |\n+LL | fn non_wf_associated_const<'a>(x: i32) {\n+   |                            -- lifetime `'a` defined here\n+LL |     A::<'a>::IC; //~ ERROR lifetime may not live long enough\n+   |     ^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "69644211b8a11c750ed94a70c46a338f4a62a34a", "filename": "src/test/ui/parser/unicode-quote-chars.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.rs?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -0,0 +1,7 @@\n+// ignore-tidy-linelength\n+\n+fn main() {\n+    println!(\u201chello world\u201d);\n+    //~^ ERROR unknown start of token: \\u{201c}\n+    //~^^ HELP Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '\"' (Quotation Mark), but are not\n+}"}, {"sha": "315e20cf854cda13d1fcfb63fa9fb1d6fc37b5cf", "filename": "src/test/ui/parser/unicode-quote-chars.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-quote-chars.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -0,0 +1,12 @@\n+error: unknown start of token: /u{201c}\n+  --> $DIR/unicode-quote-chars.rs:4:14\n+   |\n+LL |     println!(\u201chello world\u201d);\n+   |              ^\n+help: Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '\"' (Quotation Mark), but are not\n+   |\n+LL |     println!(\"hello world\");\n+   |              ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "402f3c77cdb7b27330752f2bae1648e10c328abf", "filename": "src/test/ui/ref-suggestion.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fref-suggestion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Fref-suggestion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fref-suggestion.nll.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -25,7 +25,7 @@ LL |         (Some(y), ()) => {},\n    |               - value moved here\n ...\n LL |     x; //~ ERROR use of partially moved value\n-   |     ^ value used here after move\n+   |     ^ value used here after partial move\n    |\n    = note: move occurs because value has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n "}, {"sha": "010e182674b75b2e4458811f250e06a132cbb546", "filename": "src/test/ui/unsized-locals/borrow-after-move.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.nll.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -5,7 +5,7 @@ LL |         let y = *x;\n    |                 -- value moved here\n LL |         drop_unsized(y);\n LL |         println!(\"{}\", &x);\n-   |                        ^^ value borrowed here after move\n+   |                        ^^ value borrowed here after partial move\n    |\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n@@ -27,7 +27,7 @@ LL |         let y = *x;\n    |                 -- value moved here\n LL |         y.foo();\n LL |         println!(\"{}\", &x);\n-   |                        ^^ value borrowed here after move\n+   |                        ^^ value borrowed here after partial move\n    |\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n \n@@ -48,7 +48,7 @@ error[E0382]: borrow of moved value: `x`\n LL |         x.foo();\n    |         - value moved here\n LL |         println!(\"{}\", &x);\n-   |                        ^^ value borrowed here after move\n+   |                        ^^ value borrowed here after partial move\n    |\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n "}, {"sha": "c0c3e436f535be5b7b43840fa18916a89f488f37", "filename": "src/test/ui/unsized-locals/double-move.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f19f161f24c9a02ff8c3f73122d0b015039221f/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.nll.stderr?ref=7f19f161f24c9a02ff8c3f73122d0b015039221f", "patch": "@@ -14,7 +14,7 @@ error[E0382]: use of moved value: `x`\n LL |         let _y = *x;\n    |                  -- value moved here\n LL |         drop_unsized(x); //~ERROR use of moved value\n-   |                      ^ value used here after move\n+   |                      ^ value used here after partial move\n    |\n    = note: move occurs because `*x` has type `str`, which does not implement the `Copy` trait\n "}]}