{"sha": "0447be7589445826a859ee6aa117e70c0bb179ef", "node_id": "C_kwDOAAsO6NoAKDA0NDdiZTc1ODk0NDU4MjZhODU5ZWU2YWExMTdlNzBjMGJiMTc5ZWY", "commit": {"author": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2021-11-27T11:25:05Z"}, "committer": {"name": "Jake Heinz", "email": "jh@discordapp.com", "date": "2021-11-27T11:25:05Z"}, "message": "wip", "tree": {"sha": "1065694ed7b44fafd2f38cf121985b9519cfd0f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1065694ed7b44fafd2f38cf121985b9519cfd0f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0447be7589445826a859ee6aa117e70c0bb179ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0447be7589445826a859ee6aa117e70c0bb179ef", "html_url": "https://github.com/rust-lang/rust/commit/0447be7589445826a859ee6aa117e70c0bb179ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0447be7589445826a859ee6aa117e70c0bb179ef/comments", "author": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jhgg", "id": 5489149, "node_id": "MDQ6VXNlcjU0ODkxNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5489149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhgg", "html_url": "https://github.com/jhgg", "followers_url": "https://api.github.com/users/jhgg/followers", "following_url": "https://api.github.com/users/jhgg/following{/other_user}", "gists_url": "https://api.github.com/users/jhgg/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhgg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhgg/subscriptions", "organizations_url": "https://api.github.com/users/jhgg/orgs", "repos_url": "https://api.github.com/users/jhgg/repos", "events_url": "https://api.github.com/users/jhgg/events{/privacy}", "received_events_url": "https://api.github.com/users/jhgg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dca8f612d0522aecad27f0f5053987b3e5c6b3e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca8f612d0522aecad27f0f5053987b3e5c6b3e2", "html_url": "https://github.com/rust-lang/rust/commit/dca8f612d0522aecad27f0f5053987b3e5c6b3e2"}], "stats": {"total": 215, "additions": 172, "deletions": 43}, "files": [{"sha": "afa773aaa4b0c4bc49988fffeda63eae6577f8ea", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0447be7589445826a859ee6aa117e70c0bb179ef", "patch": "@@ -40,16 +40,13 @@ use hir_def::{\n     adt::{ReprKind, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n-    item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n     nameres,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n-    src::HasSource as _,\n-    AdtId, AssocContainerId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId,\n-    DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule, ImplId, LifetimeParamId,\n-    LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId,\n+    AssocContainerId, AssocItemId, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n+    FunctionId, GenericDefId, HasModule, ImplId, LifetimeParamId, LocalEnumVariantId, LocalFieldId,\n+    StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n };\n use hir_expand::{name::name, MacroCallKind, MacroDefId, MacroDefKind};\n use hir_ty::{\n@@ -109,10 +106,19 @@ pub use {\n         attr::{Attr, Attrs, AttrsWithOwner, Documentation},\n         find_path::PrefixKind,\n         import_map,\n-        nameres::ModuleSource,\n+        item_scope::ItemScope,\n+        item_tree::ItemTreeNode,\n+        nameres::{DefMap, ModuleData, ModuleOrigin, ModuleSource},\n         path::{ModPath, PathKind},\n+        src::HasSource as DefHasSource, // xx: I don't like this shadowing of HasSource... :(\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n+        AdtId,\n+        AssocItemLoc,\n+        ItemLoc,\n+        Lookup,\n+        ModuleDefId,\n+        ModuleId,\n     },\n     hir_expand::{\n         name::{known, Name},"}, {"sha": "cf670e5cc17b83730d5d0ce5f6b7f79c093bf76a", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=0447be7589445826a859ee6aa117e70c0bb179ef", "patch": "@@ -148,7 +148,7 @@ pub enum ModuleOrigin {\n }\n \n impl ModuleOrigin {\n-    fn declaration(&self) -> Option<AstId<ast::Module>> {\n+    pub fn declaration(&self) -> Option<AstId<ast::Module>> {\n         match self {\n             ModuleOrigin::File { declaration: module, .. }\n             | ModuleOrigin::Inline { definition: module, .. } => Some(*module),"}, {"sha": "f7cdb3ce8ddc2add3c7e91c838313d7c708bf468", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=0447be7589445826a859ee6aa117e70c0bb179ef", "patch": "@@ -4,8 +4,8 @@ use std::fmt;\n \n use either::Either;\n use hir::{\n-    AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay, InFile, ModuleSource,\n-    Semantics,\n+    db::AstDatabase, AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay,\n+    InFile, ModuleSource, Semantics,\n };\n use ide_db::{\n     base_db::{FileId, FileRange},\n@@ -170,7 +170,7 @@ impl NavigationTarget {\n impl ToNav for FileSymbol {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         NavigationTarget {\n-            file_id: self.file_id,\n+            file_id: self.file_id.original_file(db),\n             name: self.name.clone(),\n             kind: Some(match self.kind {\n                 FileSymbolKind::Function => SymbolKind::Function,\n@@ -517,8 +517,8 @@ impl TryToNav for hir::ConstParam {\n /// e.g. `struct Name`, `enum Name`, `fn Name`\n pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option<String> {\n     let sema = Semantics::new(db);\n-    let parse = sema.parse(symbol.file_id);\n-    let node = symbol.ptr.to_node(parse.syntax());\n+    let syntax = sema.db.parse_or_expand(symbol.file_id)?;\n+    let node = symbol.ptr.to_node(&syntax);\n \n     match_ast! {\n         match node {"}, {"sha": "33bb14addee562163b64fe161bbf33fe6c7fb06e", "filename": "crates/ide_db/src/items_locator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=0447be7589445826a859ee6aa117e70c0bb179ef", "patch": "@@ -4,6 +4,7 @@\n //! are located in different caches, with different APIs.\n use either::Either;\n use hir::{\n+    db::AstDatabase,\n     import_map::{self, ImportKind},\n     AsAssocItem, Crate, ItemInNs, Semantics,\n };\n@@ -135,7 +136,7 @@ fn get_name_definition(\n     let _p = profile::span(\"get_name_definition\");\n     let file_id = import_candidate.file_id;\n \n-    let candidate_node = import_candidate.ptr.to_node(sema.parse(file_id).syntax());\n+    let candidate_node = import_candidate.ptr.to_node(&sema.db.parse_or_expand(file_id)?);\n     let candidate_name_node = if candidate_node.kind() != NAME {\n         candidate_node.children().find(|it| it.kind() == NAME)?\n     } else {"}, {"sha": "5bea5837a7ee7f8613af450f6337fbf98c3860e0", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 151, "deletions": 29, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0447be7589445826a859ee6aa117e70c0bb179ef/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=0447be7589445826a859ee6aa117e70c0bb179ef", "patch": "@@ -33,7 +33,10 @@ use base_db::{\n     CrateId, FileId, SourceDatabaseExt, SourceRootId,\n };\n use fst::{self, Streamer};\n-use hir::db::DefDatabase;\n+use hir::{\n+    db::DefDatabase, AdtId, AssocItemLoc, DefHasSource, HirFileId, ItemLoc, ItemScope,\n+    ItemTreeNode, Lookup, ModuleData, ModuleDefId, ModuleId,\n+};\n use rayon::prelude::*;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n@@ -202,21 +205,29 @@ pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<Fil\n     // that instead?\n \n     let def_map = db.crate_def_map(krate);\n-    let mut files = Vec::new();\n-    let mut modules = vec![def_map.root()];\n-    while let Some(module) = modules.pop() {\n-        let data = &def_map[module];\n-        files.extend(data.origin.file_id());\n-        modules.extend(data.children.values());\n-    }\n-\n-    let snap = Snap(db.snapshot());\n-\n-    let buf = files\n-        .par_iter()\n-        .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n-        .collect::<Vec<_>>();\n-    let buf = buf.iter().map(|it| &**it).collect::<Vec<_>>();\n+    // let mut files = Vec::new();\n+    // let mut modules = vec![def_map.root()];\n+    // while let Some(module) = modules.pop() {\n+    //     let data = &def_map[module];\n+    //     files.extend(data.origin.file_id());\n+    //     modules.extend(data.children.values());\n+    // }\n+\n+    // let snap = Snap(db.snapshot());\n+\n+    // let buf = files\n+    //     .par_iter()\n+    //     .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n+    //     .collect::<Vec<_>>();\n+\n+    // todo: make this fast!!!\n+    // how do i salsa this?\n+\n+    let buf: Vec<_> = def_map\n+        .modules()\n+        .map(|(_, module_data)| SymbolIndex::new(module_data_to_file_symbols(db, module_data)))\n+        .collect();\n+    let buf = buf.iter().collect::<Vec<_>>();\n \n     query.search(&buf)\n }\n@@ -364,7 +375,7 @@ impl Query {\n /// possible.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FileSymbol {\n-    pub file_id: FileId,\n+    pub file_id: HirFileId,\n     pub name: SmolStr,\n     pub kind: FileSymbolKind,\n     pub range: TextRange,\n@@ -456,23 +467,134 @@ fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {\n     to_symbol(node).map(move |(name, ptr, name_range)| FileSymbol {\n         name,\n         kind: match node.kind() {\n-            FN => FileSymbolKind::Function,\n-            STRUCT => FileSymbolKind::Struct,\n-            ENUM => FileSymbolKind::Enum,\n-            TRAIT => FileSymbolKind::Trait,\n-            MODULE => FileSymbolKind::Module,\n-            TYPE_ALIAS => FileSymbolKind::TypeAlias,\n-            CONST => FileSymbolKind::Const,\n-            STATIC => FileSymbolKind::Static,\n-            MACRO_RULES => FileSymbolKind::Macro,\n-            MACRO_DEF => FileSymbolKind::Macro,\n-            UNION => FileSymbolKind::Union,\n+            FN => FileSymbolKind::Function,          // FunctionId\n+            STRUCT => FileSymbolKind::Struct,        // AdtId::StructId\n+            ENUM => FileSymbolKind::Enum,            // AdtId::EnumId\n+            TRAIT => FileSymbolKind::Trait,          // TraitId\n+            MODULE => FileSymbolKind::Module,        // ModuleId\n+            TYPE_ALIAS => FileSymbolKind::TypeAlias, // TypeAliasId\n+            CONST => FileSymbolKind::Const,          // ConstId\n+            STATIC => FileSymbolKind::Static,        // StaticId\n+            MACRO_RULES => FileSymbolKind::Macro,    // via ItemScope::macros\n+            MACRO_DEF => FileSymbolKind::Macro,      // via ItemScope::macros\n+            UNION => FileSymbolKind::Union,          // AdtId::UnionId\n             kind => unreachable!(\"{:?}\", kind),\n         },\n         range: node.text_range(),\n         ptr,\n-        file_id,\n+        file_id: file_id.into(),\n         name_range: Some(name_range),\n         container_name: None,\n     })\n }\n+\n+fn module_data_to_file_symbols(db: &dyn DefDatabase, module_data: &ModuleData) -> Vec<FileSymbol> {\n+    let mut symbols = Vec::new();\n+    collect_symbols_from_item_scope(db, &mut symbols, &module_data.scope);\n+    // todo: collect macros from scope.macros().\n+    symbols\n+}\n+\n+fn collect_symbols_from_item_scope(\n+    db: &dyn DefDatabase,\n+    symbols: &mut Vec<FileSymbol>,\n+    scope: &ItemScope,\n+) {\n+    // todo: dedupe code.\n+    fn decl_assoc<L, T>(db: &dyn DefDatabase, id: L, kind: FileSymbolKind) -> Option<FileSymbol>\n+    where\n+        L: Lookup<Data = AssocItemLoc<T>>,\n+        T: ItemTreeNode,\n+        <T as ItemTreeNode>::Source: HasName,\n+    {\n+        let loc = id.lookup(db);\n+        let source = loc.source(db);\n+        let name = source.value.name()?;\n+        let file_id = loc.id.file_id();\n+\n+        let name_range = name.syntax().text_range();\n+        let name = name.text().into();\n+        let ptr = SyntaxNodePtr::new(source.value.syntax());\n+\n+        Some(FileSymbol {\n+            name,\n+            kind,\n+            range: source.value.syntax().text_range(),\n+            // todo: fill out based on loc.container.\n+            container_name: None,\n+            file_id,\n+            name_range: Some(name_range),\n+            ptr,\n+        })\n+    }\n+    fn decl<L, T>(db: &dyn DefDatabase, id: L, kind: FileSymbolKind) -> Option<FileSymbol>\n+    where\n+        L: Lookup<Data = ItemLoc<T>>,\n+        T: ItemTreeNode,\n+        <T as ItemTreeNode>::Source: HasName,\n+    {\n+        let loc = id.lookup(db);\n+        let source = loc.source(db);\n+        let name = source.value.name()?;\n+        let file_id = loc.id.file_id();\n+        let name_range = name.syntax().text_range();\n+        let name = name.text().into();\n+        let ptr = SyntaxNodePtr::new(source.value.syntax());\n+\n+        Some(FileSymbol {\n+            name,\n+            kind,\n+            range: source.value.syntax().text_range(),\n+            container_name: None,\n+            file_id,\n+            name_range: Some(name_range),\n+            ptr,\n+        })\n+    }\n+\n+    fn decl_module(db: &dyn DefDatabase, module_id: ModuleId) -> Option<FileSymbol> {\n+        let def_map = module_id.def_map(db);\n+        let module_data = &def_map[module_id.local_id];\n+        let declaration = module_data.origin.declaration()?;\n+        let file_id = match module_data.origin.file_id() {\n+            Some(file_id) => file_id.into(),\n+            None => declaration.file_id,\n+        };\n+\n+        let module = declaration.to_node(db.upcast());\n+        let name = module.name()?;\n+        let name_range = name.syntax().text_range();\n+        let name = name.text().into();\n+        let ptr = SyntaxNodePtr::new(module.syntax());\n+\n+        Some(FileSymbol {\n+            name,\n+            kind: FileSymbolKind::Module,\n+            range: module.syntax().text_range(),\n+            container_name: None,\n+            file_id,\n+            name_range: Some(name_range),\n+            ptr,\n+        })\n+    }\n+\n+    let symbols_iter = scope.declarations().filter_map(|module_def_id| match module_def_id {\n+        ModuleDefId::ModuleId(module_id) => decl_module(db, module_id),\n+        ModuleDefId::FunctionId(function_id) => {\n+            decl_assoc(db, function_id, FileSymbolKind::Function)\n+        }\n+        ModuleDefId::AdtId(AdtId::StructId(struct_id)) => {\n+            decl(db, struct_id, FileSymbolKind::Struct)\n+        }\n+        ModuleDefId::AdtId(AdtId::EnumId(enum_id)) => decl(db, enum_id, FileSymbolKind::Enum),\n+        ModuleDefId::AdtId(AdtId::UnionId(union_id)) => decl(db, union_id, FileSymbolKind::Union),\n+        ModuleDefId::EnumVariantId(_) => None,\n+        ModuleDefId::ConstId(const_id) => decl_assoc(db, const_id, FileSymbolKind::Const),\n+        ModuleDefId::StaticId(static_id) => decl(db, static_id, FileSymbolKind::Static),\n+        ModuleDefId::TraitId(trait_id) => decl(db, trait_id, FileSymbolKind::Trait),\n+        ModuleDefId::TypeAliasId(alias_id) => decl_assoc(db, alias_id, FileSymbolKind::TypeAlias),\n+        ModuleDefId::BuiltinType(_) => None,\n+    });\n+\n+    symbols.extend(symbols_iter);\n+}"}]}