{"sha": "07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NTYzYmU2ZWJlMDgxYzhmNjY2NmE3YjZlYjY4ZDhlMzI3NzRmMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T00:21:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T00:21:20Z"}, "message": "auto merge of #14373 : sfackler/rust/unused-attr, r=huonw\n\nThe compiler now tracks which attributes were actually looked at during the compilation process and warns for those that were unused.\r\n\r\nSome things of note:\r\n\r\n* The tracking is done via thread locals, as it made the implementation more straightforward. Note that this shouldn't hamper any future parallelization as each task can have its own thread local state which can be merged for the lint pass. If there are serious objections to this, I can restructure things to explicitly pass the state around.\r\n* There are a number of attributes that have to be special-cased and globally whitelisted. This happens for four reasons:\r\n  * The `doc` and `automatically_derived` attributes are used by rustdoc, but not by the compiler.\r\n  * The crate-level attributes `license`, `desc` and `comment` aren't currently used by anything.\r\n  * Stability attributes as well as `must_use` are checked only when the tagged item is used, so we can't guarantee that the compiler's looked at them.\r\n  * 12 attributes are used only in trans, which happens after the lint pass.\r\n\r\n#14300 is adding infrastructure to track lint state through trans, which this lint should also be able to use to handle the last case. For the other attributes, the right solution would probably involve a specific pass to mark uses that occur in the correct context. For example, a `doc` attribute attached to a match arm should generate a warning, but will not currently.\r\n\r\nRFC: 0002-attribute-usage", "tree": {"sha": "30b4848c49319e66eaf68b86081f6fdf5c99455b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30b4848c49319e66eaf68b86081f6fdf5c99455b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "html_url": "https://github.com/rust-lang/rust/commit/07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6304a27b80f3923a8ffc009418c302aa8b06fb93", "url": "https://api.github.com/repos/rust-lang/rust/commits/6304a27b80f3923a8ffc009418c302aa8b06fb93", "html_url": "https://github.com/rust-lang/rust/commit/6304a27b80f3923a8ffc009418c302aa8b06fb93"}, {"sha": "334799326486e46b67c5405ba9584a26878988a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/334799326486e46b67c5405ba9584a26878988a4", "html_url": "https://github.com/rust-lang/rust/commit/334799326486e46b67c5405ba9584a26878988a4"}], "stats": {"total": 409, "additions": 277, "deletions": 132}, "files": [{"sha": "b8fa4075e7a758656e6e1b5c3fd609c714193bb6", "filename": "src/doc/rust.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -661,6 +661,7 @@ Attributes on the anonymous crate module define important metadata that influenc\n the behavior of the compiler.\n \n ~~~~ {.rust}\n+# #![allow(unused_attribute)]\n // Crate ID\n #![crate_id = \"projx#2.5\"]\n "}, {"sha": "af9cff7be67b0b432f39bd891c177f6473433e82", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -11,6 +11,7 @@ Documenting Rust APIs is quite simple. To document a given item, we have \"doc\n comments\":\n \n ~~~\n+# #![allow(unused_attribute)]\n // the \"link\" crate attribute is currently required for rustdoc, but normally\n // isn't needed.\n #![crate_id = \"universe\"]"}, {"sha": "d85734508bc137f87d5c2aa1d4fc083aa881fb80", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -3166,6 +3166,7 @@ without conflict.\n Therefore, if you plan to compile your crate as a library, you should annotate it with that information:\n \n ~~~~\n+# #![allow(unused_attribute)]\n // `lib.rs`\n \n # #![crate_type = \"lib\"]\n@@ -3189,6 +3190,7 @@ Other crate settings and metadata include things like enabling/disabling certain\n or setting the crate type (library or executable) explicitly:\n \n ~~~~\n+# #![allow(unused_attribute)]\n // `lib.rs`\n // ...\n \n@@ -3208,6 +3210,7 @@ Now for something that you can actually compile yourself.\n We define two crates, and use one of them as a library in the other.\n \n ~~~~\n+# #![allow(unused_attribute)]\n // `world.rs`\n #![crate_id = \"world#0.42\"]\n \n@@ -3282,11 +3285,13 @@ fn main() {\n Both auto-insertions can be disabled with an attribute if necessary:\n \n ~~~\n+# #![allow(unused_attribute)]\n // In the crate root:\n #![no_std]\n ~~~\n \n ~~~\n+# #![allow(unused_attribute)]\n // In any module:\n #![no_implicit_prelude]\n ~~~"}, {"sha": "9ad653498ba06f91b902677902d05e237f605b37", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -91,7 +91,12 @@ impl Svh {\n         // types and then use hash_content.  But, since all crate\n         // attributes should appear near beginning of the file, it is\n         // not such a big deal to be sensitive to their spans for now.\n-        krate.attrs.hash(&mut state);\n+        //\n+        // We hash only the MetaItems instead of the entire Attribute\n+        // to avoid hashing the AttrId\n+        for attr in krate.attrs.iter() {\n+            attr.node.value.hash(&mut state);\n+        }\n \n         let hash = state.result();\n         return Svh {"}, {"sha": "ee9b10a805901d2eddd0707aa99cd7236e3111b5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -716,6 +716,45 @@ fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n \n pub fn collect_crate_types(session: &Session,\n                            attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n+    // Unconditionally collect crate types from attributes to make them used\n+    let attr_types: Vec<config::CrateType> = attrs.iter().filter_map(|a| {\n+        if a.check_name(\"crate_type\") {\n+            match a.value_str() {\n+                Some(ref n) if n.equiv(&(\"rlib\")) => {\n+                    Some(config::CrateTypeRlib)\n+                }\n+                Some(ref n) if n.equiv(&(\"dylib\")) => {\n+                    Some(config::CrateTypeDylib)\n+                }\n+                Some(ref n) if n.equiv(&(\"lib\")) => {\n+                    Some(config::default_lib_output())\n+                }\n+                Some(ref n) if n.equiv(&(\"staticlib\")) => {\n+                    Some(config::CrateTypeStaticlib)\n+                }\n+                Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n+                Some(_) => {\n+                    session.add_lint(lint::UnknownCrateType,\n+                                     ast::CRATE_NODE_ID,\n+                                     a.span,\n+                                     \"invalid `crate_type` \\\n+                                      value\".to_strbuf());\n+                    None\n+                }\n+                _ => {\n+                    session.add_lint(lint::UnknownCrateType,\n+                                     ast::CRATE_NODE_ID,\n+                                     a.span,\n+                                     \"`crate_type` requires a \\\n+                                      value\".to_strbuf());\n+                    None\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }).collect();\n+\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n@@ -729,44 +768,7 @@ pub fn collect_crate_types(session: &Session,\n     if base.len() > 0 {\n         return base\n     } else {\n-        let iter = attrs.iter().filter_map(|a| {\n-            if a.name().equiv(&(\"crate_type\")) {\n-                match a.value_str() {\n-                    Some(ref n) if n.equiv(&(\"rlib\")) => {\n-                        Some(config::CrateTypeRlib)\n-                    }\n-                    Some(ref n) if n.equiv(&(\"dylib\")) => {\n-                        Some(config::CrateTypeDylib)\n-                    }\n-                    Some(ref n) if n.equiv(&(\"lib\")) => {\n-                        Some(config::default_lib_output())\n-                    }\n-                    Some(ref n) if n.equiv(&(\"staticlib\")) => {\n-                        Some(config::CrateTypeStaticlib)\n-                    }\n-                    Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n-                    Some(_) => {\n-                        session.add_lint(lint::UnknownCrateType,\n-                                         ast::CRATE_NODE_ID,\n-                                         a.span,\n-                                         \"invalid `crate_type` \\\n-                                          value\".to_strbuf());\n-                        None\n-                    }\n-                    _ => {\n-                        session.add_lint(lint::UnknownCrateType,\n-                                         ast::CRATE_NODE_ID,\n-                                         a.span,\n-                                         \"`crate_type` requires a \\\n-                                          value\".to_strbuf());\n-                        None\n-                    }\n-                }\n-            } else {\n-                None\n-            }\n-        });\n-        base.extend(iter);\n+        base.extend(attr_types.move_iter());\n         if base.len() == 0 {\n             base.push(config::CrateTypeExecutable);\n         }"}, {"sha": "4f9957ee980294bf73992a6cfcd2e249b1f4c216", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -327,7 +327,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     };\n \n     for attr in krate.attrs.iter() {\n-        if !attr.name().equiv(&(\"feature\")) {\n+        if !attr.check_name(\"feature\") {\n             continue\n         }\n "}, {"sha": "fe636f7b686a018f839e37229238214752c671c0", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -78,7 +78,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n                                          with_version(\"std\"),\n                                          ast::DUMMY_NODE_ID),\n             attrs: vec!(\n-                attr::mk_attr_outer(attr::mk_list_item(\n+                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_list_item(\n                         InternedString::new(\"phase\"),\n                         vec!(\n                             attr::mk_word_item(InternedString::new(\"syntax\")),\n@@ -110,10 +110,13 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n         // Add it during the prelude injection instead.\n \n         // Add #![feature(phase)] here, because we use #[phase] on extern crate std.\n-        let feat_phase_attr = attr::mk_attr_inner(attr::mk_list_item(\n+        let feat_phase_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n+                                                  attr::mk_list_item(\n                                   InternedString::new(\"feature\"),\n                                   vec![attr::mk_word_item(InternedString::new(\"phase\"))],\n                               ));\n+        // std_inject runs after feature checking so manually mark this attr\n+        attr::mark_used(&feat_phase_attr);\n         krate.attrs.push(feat_phase_attr);\n \n         krate\n@@ -138,19 +141,25 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         // This must happen here and not in StandardLibraryInjector because this\n         // fold happens second.\n \n-        let no_std_attr = attr::mk_attr_inner(attr::mk_word_item(InternedString::new(\"no_std\")));\n+        let no_std_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n+                                              attr::mk_word_item(InternedString::new(\"no_std\")));\n+        // std_inject runs after feature checking so manually mark this attr\n+        attr::mark_used(&no_std_attr);\n         krate.attrs.push(no_std_attr);\n \n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n \n             // fold_mod() will insert glob path.\n-            let globs_attr = attr::mk_attr_inner(attr::mk_list_item(\n+            let globs_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n+                                                 attr::mk_list_item(\n                 InternedString::new(\"feature\"),\n                 vec!(\n                     attr::mk_word_item(InternedString::new(\"globs\")),\n                 )));\n+            // std_inject runs after feature checking so manually mark this attr\n+            attr::mark_used(&globs_attr);\n             krate.attrs.push(globs_attr);\n \n             krate.module = self.fold_mod(&krate.module);"}, {"sha": "679444238085542c49e2e450da2120bb938d6cc9", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -253,7 +253,7 @@ fn is_bench_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n-        attr.name().equiv(&(\"ignore\")) && match attr.meta_item_list() {\n+        attr.check_name(\"ignore\") && match attr.meta_item_list() {\n             Some(ref cfgs) => {\n                 attr::test_cfg(cx.config.as_slice(), cfgs.iter().map(|x| *x))\n             }\n@@ -341,7 +341,8 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_str = InternedString::new(\"!resolve_unexported\");\n     let resolve_unexported_attr =\n-        attr::mk_attr_inner(attr::mk_word_item(resolve_unexported_str));\n+        attr::mk_attr_inner(attr::mk_attr_id(),\n+                            attr::mk_word_item(resolve_unexported_str));\n \n     let item = ast::Item {\n         ident: token::str_to_ident(\"__test\"),"}, {"sha": "d2b567395f020f10e5ed8de996f680bcc48cf1b2", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -176,7 +176,7 @@ pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: |Vec<@ast::MetaItem> |) {\n+                      f: |Vec<ast::Attribute> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node, f)\n }"}, {"sha": "54243ea6f1f4c1aada156cf219d482e1815ebc39", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -953,20 +953,14 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       orig_node_id: ast::NodeId,\n-                      f: |Vec<@ast::MetaItem> |) {\n+                      f: |Vec<ast::Attribute>|) {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n     let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n     let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n     let item = lookup_item(node_id, cdata.data());\n-    reader::tagged_docs(item, tag_attributes, |attributes| {\n-        reader::tagged_docs(attributes, tag_attribute, |attribute| {\n-            f(get_meta_items(attribute));\n-            true\n-        });\n-        true\n-    });\n+    f(get_attributes(item));\n }\n \n fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n@@ -1056,6 +1050,7 @@ fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n             attrs.push(\n                 codemap::Spanned {\n                     node: ast::Attribute_ {\n+                        id: attr::mk_attr_id(),\n                         style: ast::AttrOuter,\n                         value: meta_item,\n                         is_sugared_doc: false,"}, {"sha": "2e3dc360ac29185b142cd07a817cf8c247531a0f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -1436,7 +1436,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n     fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n         assert!(!ecx.link_meta.crateid.name.is_empty());\n \n-        attr::mk_attr_inner(\n+        attr::mk_attr_inner(attr::mk_attr_id(),\n             attr::mk_name_value_item_str(\n                 InternedString::new(\"crate_id\"),\n                 token::intern_and_get_ident(ecx.link_meta\n@@ -1447,7 +1447,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n     let mut attrs = Vec::new();\n     for attr in krate.attrs.iter() {\n-        if !attr.name().equiv(&(\"crate_id\")) {\n+        if !attr.check_name(\"crate_id\") {\n             attrs.push(*attr);\n         }\n     }"}, {"sha": "2b1e28548f99fe1b47e62a1e445d62046ef29c37", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -64,7 +64,7 @@ use collections::SmallIntMap;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n-use syntax::attr::{AttrMetaMethods, AttributeMethods};\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n@@ -90,6 +90,7 @@ pub enum Lint {\n     UnusedUnsafe,\n     UnsafeBlock,\n     AttributeUsage,\n+    UnusedAttribute,\n     UnknownFeatures,\n     UnknownCrateType,\n     UnsignedNegate,\n@@ -288,6 +289,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: Warn\n     }),\n \n+    (\"unused_attribute\",\n+     LintSpec {\n+         lint: UnusedAttribute,\n+         desc: \"detects attributes that were not used by the compiler\",\n+         default: Warn\n+    }),\n+\n     (\"unused_variable\",\n      LintSpec {\n         lint: UnusedVariable,\n@@ -619,7 +627,7 @@ pub fn each_lint(sess: &session::Session,\n     let xs = [Allow, Warn, Deny, Forbid];\n     for &level in xs.iter() {\n         let level_name = level_to_str(level);\n-        for attr in attrs.iter().filter(|m| m.name().equiv(&level_name)) {\n+        for attr in attrs.iter().filter(|m| m.check_name(level_name)) {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::MetaList(_, ref metas) => metas,\n@@ -1137,6 +1145,54 @@ fn check_attrs_usage(cx: &Context, attrs: &[ast::Attribute]) {\n     }\n }\n \n+fn check_unused_attribute(cx: &Context, attrs: &[ast::Attribute]) {\n+    static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n+        // FIXME: #14408 whitelist docs since rustdoc looks at them\n+        \"doc\",\n+\n+        // FIXME: #14406 these are processed in trans, which happens after the\n+        // lint pass\n+        \"address_insignificant\",\n+        \"cold\",\n+        \"inline\",\n+        \"link\",\n+        \"link_name\",\n+        \"link_section\",\n+        \"no_builtins\",\n+        \"no_mangle\",\n+        \"no_split_stack\",\n+        \"packed\",\n+        \"static_assert\",\n+        \"thread_local\",\n+\n+        // not used anywhere (!?) but apparently we want to keep them around\n+        \"comment\",\n+        \"desc\",\n+        \"license\",\n+\n+        // FIXME: #14407 these are only looked at on-demand so we can't\n+        // guarantee they'll have already been checked\n+        \"deprecated\",\n+        \"experimental\",\n+        \"frozen\",\n+        \"locked\",\n+        \"must_use\",\n+        \"stable\",\n+        \"unstable\",\n+    ];\n+    for attr in attrs.iter() {\n+        for &name in ATTRIBUTE_WHITELIST.iter() {\n+            if attr.check_name(name) {\n+                break;\n+            }\n+        }\n+\n+        if !attr::is_used(attr) {\n+            cx.span_lint(UnusedAttribute, attr.span, \"unused attribute\");\n+        }\n+    }\n+}\n+\n fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n     let ty = ty::expr_ty(cx.tcx, e);\n     check_heap_type(cx, e.span, ty);\n@@ -1637,9 +1693,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     let stability = if ast_util::is_local(id) {\n         // this crate\n         let s = cx.tcx.map.with_attrs(id.node, |attrs| {\n-            attrs.map(|a| {\n-                attr::find_stability(a.iter().map(|a| a.meta()))\n-            })\n+            attrs.map(|a| attr::find_stability(a.as_slice()))\n         });\n         match s {\n             Some(s) => s,\n@@ -1655,9 +1709,9 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         let mut s = None;\n         // run through all the attributes and take the first\n         // stability one.\n-        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |meta_items| {\n+        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |attrs| {\n             if s.is_none() {\n-                s = attr::find_stability(meta_items.move_iter())\n+                s = attr::find_stability(attrs.as_slice())\n             }\n         });\n         s\n@@ -1694,6 +1748,7 @@ impl<'a> Visitor<()> for Context<'a> {\n             check_heap_item(cx, it);\n             check_missing_doc_item(cx, it);\n             check_attrs_usage(cx, it.attrs.as_slice());\n+            check_unused_attribute(cx, it.attrs.as_slice());\n             check_raw_ptr_deriving(cx, it);\n \n             cx.visit_ids(|v| v.visit_item(it, ()));\n@@ -1900,6 +1955,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         check_crate_attrs_usage(cx, krate.attrs.as_slice());\n         // since the root module isn't visited as an item (because it isn't an item), warn for it\n         // here.\n+        check_unused_attribute(cx, krate.attrs.as_slice());\n         check_missing_doc_attrs(cx,\n                                 None,\n                                 krate.attrs.as_slice(),"}, {"sha": "da28c3008ddd02ad996021d5b6b04288546729a3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -227,9 +227,8 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n \n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n-    csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n-        set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr_outer(x))\n-                                    .collect::<Vec<_>>().as_slice(), f)\n+    csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n+        set_llvm_fn_attrs(attrs.as_slice(), f)\n     });\n \n     ccx.externs.borrow_mut().insert(name.to_strbuf(), f);"}, {"sha": "9176b33331f1af7858e26ba770e2f620055980b5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -3889,20 +3889,22 @@ pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n }\n \n-/// Iterate over meta_items of a definition.\n+/// Iterate over attributes of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: &ctxt, did: DefId, f: |@ast::MetaItem| -> bool) -> bool {\n+pub fn each_attr(tcx: &ctxt, did: DefId, f: |&ast::Attribute| -> bool) -> bool {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n-        item.attrs.iter().advance(|attr| f(attr.node.value))\n+        item.attrs.iter().advance(|attr| f(attr))\n     } else {\n+        info!(\"getting foreign attrs\");\n         let mut cont = true;\n-        csearch::get_item_attrs(&tcx.sess.cstore, did, |meta_items| {\n+        csearch::get_item_attrs(&tcx.sess.cstore, did, |attrs| {\n             if cont {\n-                cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n+                cont = attrs.iter().advance(|attr| f(attr));\n             }\n         });\n+        info!(\"done\");\n         cont\n     }\n }\n@@ -3911,7 +3913,7 @@ pub fn each_attr(tcx: &ctxt, did: DefId, f: |@ast::MetaItem| -> bool) -> bool {\n pub fn has_attr(tcx: &ctxt, did: DefId, attr: &str) -> bool {\n     let mut found = false;\n     each_attr(tcx, did, |item| {\n-        if item.name().equiv(&attr) {\n+        if item.check_name(attr) {\n             found = true;\n             false\n         } else {"}, {"sha": "6f3c6e4cd6f397cec5d6723f93cf004fcff8a92c", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -314,17 +314,17 @@ impl Clean<Attribute> for ast::Attribute {\n }\n \n // This is a rough approximation that gets us what we want.\n-impl<'a> attr::AttrMetaMethods for &'a Attribute {\n+impl attr::AttrMetaMethods for Attribute {\n     fn name(&self) -> InternedString {\n-        match **self {\n+        match *self {\n             Word(ref n) | List(ref n, _) | NameValue(ref n, _) => {\n                 token::intern_and_get_ident(n.as_slice())\n             }\n         }\n     }\n \n     fn value_str(&self) -> Option<InternedString> {\n-        match **self {\n+        match *self {\n             NameValue(_, ref v) => {\n                 Some(token::intern_and_get_ident(v.as_slice()))\n             }"}, {"sha": "b09ac8f94af983b2ff962c6fd95c54f53d4cf430", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -1091,8 +1091,8 @@ impl<'a> fmt::Show for Item<'a> {\n                     shortty(self.item), self.item.name.get_ref().as_slice()));\n \n         // Write stability attributes\n-        match attr::find_stability(self.item.attrs.iter()) {\n-            Some(ref stability) => {\n+        match attr::find_stability_generic(self.item.attrs.iter()) {\n+            Some((ref stability, _)) => {\n                 try!(write!(fmt,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),"}, {"sha": "e77d1faf05d89a0790e9908d3ef3b2bfb549aad6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -1024,9 +1024,13 @@ pub enum AttrStyle {\n     AttrInner,\n }\n \n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+pub struct AttrId(pub uint);\n+\n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Attribute_ {\n+    pub id: AttrId,\n     pub style: AttrStyle,\n     pub value: @MetaItem,\n     pub is_sugared_doc: bool,"}, {"sha": "527e851ae35ac6024f6ecf4baac67206452b0497", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 85, "deletions": 35, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -11,7 +11,7 @@\n // Functions dealing with attributes and meta items\n \n use ast;\n-use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n+use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n@@ -21,11 +21,26 @@ use parse::token;\n use crateid::CrateId;\n \n use collections::HashSet;\n+use collections::bitv::BitvSet;\n+\n+local_data_key!(used_attrs: BitvSet)\n+\n+pub fn mark_used(attr: &Attribute) {\n+    let mut used = used_attrs.replace(None).unwrap_or_else(|| BitvSet::new());\n+    let AttrId(id) = attr.node.id;\n+    used.insert(id);\n+    used_attrs.replace(Some(used));\n+}\n+\n+pub fn is_used(attr: &Attribute) -> bool {\n+    let AttrId(id) = attr.node.id;\n+    used_attrs.get().map_or(false, |used| used.contains(&id))\n+}\n \n pub trait AttrMetaMethods {\n-    // This could be changed to `fn check_name(&self, name: InternedString) ->\n-    // bool` which would facilitate a side table recording which\n-    // attributes/meta items are used/unused.\n+    fn check_name(&self, name: &str) -> bool {\n+        name == self.name().get()\n+    }\n \n     /// Retrieve the name of the meta item, e.g. foo in #[foo],\n     /// #[foo=\"bar\"] and #[foo(bar)]\n@@ -47,6 +62,13 @@ pub trait AttrMetaMethods {\n }\n \n impl AttrMetaMethods for Attribute {\n+    fn check_name(&self, name: &str) -> bool {\n+        let matches = name == self.name().get();\n+        if matches {\n+            mark_used(self);\n+        }\n+        matches\n+    }\n     fn name(&self) -> InternedString { self.meta().name() }\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n@@ -127,9 +149,9 @@ impl AttributeMethods for Attribute {\n                 token::intern_and_get_ident(strip_doc_comment_decoration(\n                         comment.get()).as_slice()));\n             if self.node.style == ast::AttrOuter {\n-                mk_attr_outer(meta)\n+                mk_attr_outer(self.node.id, meta)\n             } else {\n-                mk_attr_inner(meta)\n+                mk_attr_inner(self.node.id, meta)\n             }\n         } else {\n             *self\n@@ -158,29 +180,41 @@ pub fn mk_word_item(name: InternedString) -> @MetaItem {\n     @dummy_spanned(MetaWord(name))\n }\n \n+local_data_key!(next_attr_id: uint)\n+\n+pub fn mk_attr_id() -> AttrId {\n+    let id = next_attr_id.replace(None).unwrap_or(0);\n+    next_attr_id.replace(Some(id + 1));\n+    AttrId(id)\n+}\n+\n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(item: @MetaItem) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: @MetaItem) -> Attribute {\n     dummy_spanned(Attribute_ {\n+        id: id,\n         style: ast::AttrInner,\n         value: item,\n         is_sugared_doc: false,\n     })\n }\n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(item: @MetaItem) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: @MetaItem) -> Attribute {\n     dummy_spanned(Attribute_ {\n+        id: id,\n         style: ast::AttrOuter,\n         value: item,\n         is_sugared_doc: false,\n     })\n }\n \n-pub fn mk_sugared_doc_attr(text: InternedString, lo: BytePos, hi: BytePos)\n+pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n+                           hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(text.get());\n     let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n+        id: id,\n         style: style,\n         value: @spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n                                               lit)),\n@@ -206,22 +240,22 @@ pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n     metas.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n-        item.name().equiv(&name)\n+        item.check_name(name)\n     })\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n                                  -> Option<InternedString> {\n     attrs.iter()\n-        .find(|at| at.name().equiv(&name))\n+        .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<InternedString> {\n     items.iter()\n          .rev()\n-         .find(|mi| mi.name().equiv(&name))\n+         .find(|mi| mi.check_name(name))\n          .and_then(|i| i.value_str())\n }\n \n@@ -257,7 +291,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> Vec<@MetaItem> {\n  */\n pub fn find_linkage_metas(attrs: &[Attribute]) -> Vec<@MetaItem> {\n     let mut result = Vec::new();\n-    for attr in attrs.iter().filter(|at| at.name().equiv(&(\"link\"))) {\n+    for attr in attrs.iter().filter(|at| at.check_name(\"link\")) {\n         match attr.meta().node {\n             MetaList(_, ref items) => result.push_all(items.as_slice()),\n             _ => ()\n@@ -286,17 +320,21 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n-          MetaWord(ref n) if n.equiv(&(\"inline\")) => InlineHint,\n-          MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n-            if contains_name(items.as_slice(), \"always\") {\n-                InlineAlways\n-            } else if contains_name(items.as_slice(), \"never\") {\n-                InlineNever\n-            } else {\n+            MetaWord(ref n) if n.equiv(&(\"inline\")) => {\n+                mark_used(attr);\n                 InlineHint\n             }\n-          }\n-          _ => ia\n+            MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n+                mark_used(attr);\n+                if contains_name(items.as_slice(), \"always\") {\n+                    InlineAlways\n+                } else if contains_name(items.as_slice(), \"never\") {\n+                    InlineNever\n+                } else {\n+                    InlineHint\n+                }\n+            }\n+            _ => ia\n         }\n     })\n }\n@@ -314,9 +352,9 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n \n     // this would be much nicer as a chain of iterator adaptors, but\n     // this doesn't work.\n-    let some_cfg_matches = metas.any(|mi| {\n+    let some_cfg_matches = metas.fold(false, |matches, mi| {\n         debug!(\"testing name: {}\", mi.name());\n-        if mi.name().equiv(&(\"cfg\")) { // it is a #[cfg()] attribute\n+        let this_matches = if mi.check_name(\"cfg\") { // it is a #[cfg()] attribute\n             debug!(\"is cfg\");\n             no_cfgs = false;\n              // only #[cfg(...)] ones are understood.\n@@ -344,7 +382,8 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n             }\n         } else {\n             false\n-        }\n+        };\n+        matches || this_matches\n     });\n     debug!(\"test_cfg (no_cfgs={}, some_cfg_matches={})\", no_cfgs, some_cfg_matches);\n     no_cfgs || some_cfg_matches\n@@ -367,11 +406,13 @@ pub enum StabilityLevel {\n     Locked\n }\n \n-/// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n-                      -> Option<Stability> {\n-    for m in metas {\n-        let level = match m.name().get() {\n+pub fn find_stability_generic<'a,\n+                              AM: AttrMetaMethods,\n+                              I: Iterator<&'a AM>>\n+                             (mut attrs: I)\n+                             -> Option<(Stability, &'a AM)> {\n+    for attr in attrs {\n+        let level = match attr.name().get() {\n             \"deprecated\" => Deprecated,\n             \"experimental\" => Experimental,\n             \"unstable\" => Unstable,\n@@ -381,14 +422,22 @@ pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n             _ => continue // not a stability level\n         };\n \n-        return Some(Stability {\n+        return Some((Stability {\n                 level: level,\n-                text: m.value_str()\n-            });\n+                text: attr.value_str()\n+            }, attr));\n     }\n     None\n }\n \n+/// Find the first stability attribute. `None` if none exists.\n+pub fn find_stability(attrs: &[Attribute]) -> Option<Stability> {\n+    find_stability_generic(attrs.iter()).map(|(s, attr)| {\n+        mark_used(attr);\n+        s\n+    })\n+}\n+\n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n@@ -415,11 +464,12 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n  * present (before fields, if any) with that type; reprensentation\n  * optimizations which would remove it will not be done.\n  */\n-pub fn find_repr_attr(diagnostic: &SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n+pub fn find_repr_attr(diagnostic: &SpanHandler, attr: &Attribute, acc: ReprAttr)\n     -> ReprAttr {\n     let mut acc = acc;\n-    match attr.node {\n+    match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n+            mark_used(attr);\n             for item in items.iter() {\n                 match item.node {\n                     ast::MetaWord(ref word) => {"}, {"sha": "449feb3afbf96d1f906e42c49d5a7ee28db0e420", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -12,6 +12,7 @@ use abi;\n use ast::{P, Ident};\n use ast;\n use ast_util;\n+use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n@@ -927,6 +928,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute {\n         respan(sp, ast::Attribute_ {\n+            id: attr::mk_attr_id(),\n             style: ast::AttrOuter,\n             value: mi,\n             is_sugared_doc: false,"}, {"sha": "5f18193437e9a3b96d6ed71df60e62a62ffa65c3", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -182,6 +182,7 @@ use std::cell::RefCell;\n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n+use attr;\n use attr::AttrMetaMethods;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -430,6 +431,8 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             cx.meta_word(self.span,\n                          InternedString::new(\"automatically_derived\")));\n+        // Just mark it now since we know that it'll end up used downstream\n+        attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let ident = ast_util::impl_pretty_name(&opt_trait_ref, self_type);\n         cx.item("}, {"sha": "658e4bafbe25a090dc304985a522f86392690c33", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -265,6 +265,8 @@ pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n \n         match fld.extsbox.find(&intern(mname.get())) {\n             Some(&ItemDecorator(dec_fn)) => {\n+                attr::mark_used(attr);\n+\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: attr.span,\n                     callee: NameAndSpan {\n@@ -336,6 +338,7 @@ fn expand_item_modifiers(mut it: @ast::Item, fld: &mut MacroExpander)\n \n         match fld.extsbox.find(&intern(mname.get())) {\n             Some(&ItemModifier(dec_fn)) => {\n+                attr::mark_used(attr);\n                 fld.cx.bt_push(ExpnInfo {\n                     call_site: attr.span,\n                     callee: NameAndSpan {\n@@ -474,7 +477,7 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n     match vi.node {\n         ast::ViewItemExternCrate(..) => {\n             let should_load = vi.attrs.iter().any(|attr| {\n-                attr.name().get() == \"phase\" &&\n+                attr.check_name(\"phase\") &&\n                     attr.meta_item_list().map_or(false, |phases| {\n                         attr::contains_name(phases, \"syntax\")\n                     })\n@@ -972,6 +975,7 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n+    use attr;\n     use codemap;\n     use codemap::Spanned;\n     use ext::base::{CrateLoader, MacroCrate};\n@@ -1103,6 +1107,7 @@ mod test {\n         Spanned {\n             span:codemap::DUMMY_SP,\n             node: Attribute_ {\n+                id: attr::mk_attr_id(),\n                 style: AttrOuter,\n                 value: @Spanned {\n                     node: MetaWord(token::intern_and_get_ident(s)),"}, {"sha": "ae5cf550bb9bc0bd00e5de08ddd1a2767be17cf8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -360,6 +360,7 @@ fn fold_attribute_<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n     Spanned {\n         span: fld.new_span(at.span),\n         node: ast::Attribute_ {\n+            id: at.node.id,\n             style: at.node.style,\n             value: fold_meta_item_(at.node.value, fld),\n             is_sugared_doc: at.node.is_sugared_doc"}, {"sha": "9dcc0877fa489783e449605e67f48ae26f0523cf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use attr;\n use ast;\n use codemap::{spanned, Spanned, mk_sp, Span};\n use parse::common::*; //resolve bug?\n@@ -39,6 +40,7 @@ impl<'a> ParserAttr for Parser<'a> {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n+                    attr::mk_attr_id(),\n                     self.id_to_interned_str(s),\n                     self.span.lo,\n                     self.span.hi\n@@ -101,6 +103,7 @@ impl<'a> ParserAttr for Parser<'a> {\n         return Spanned {\n             span: span,\n             node: ast::Attribute_ {\n+                id: attr::mk_attr_id(),\n                 style: style,\n                 value: value,\n                 is_sugared_doc: false\n@@ -132,7 +135,10 @@ impl<'a> ParserAttr for Parser<'a> {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n                     self.bump();\n-                    ::attr::mk_sugared_doc_attr(self.id_to_interned_str(s), lo, hi)\n+                    attr::mk_sugared_doc_attr(attr::mk_attr_id(),\n+                                              self.id_to_interned_str(s),\n+                                              lo,\n+                                              hi)\n                 }\n                 _ => {\n                     break;"}, {"sha": "f7db5c97aab111fec139dbabff50502ad6eeb653", "filename": "src/test/compile-fail/lint-misplaced-attr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Fcompile-fail%2Flint-misplaced-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Fcompile-fail%2Flint-misplaced-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-misplaced-attr.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -12,9 +12,12 @@\n // injected intrinsics by the compiler.\n \n #![deny(attribute_usage)]\n+#![deny(unused_attribute)]\n \n mod a {\n     #![crate_type = \"bin\"] //~ ERROR: crate-level attribute\n+                           //~^ ERROR: unused attribute\n }\n \n #[crate_type = \"bin\"] fn main() {} //~ ERROR: crate-level attribute\n+                                   //~^ ERROR: unused attribute"}, {"sha": "32058737ed3023e755d9128a759197474420fb1e", "filename": "src/test/compile-fail/lint-obsolete-attr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -12,10 +12,13 @@\n // injected intrinsics by the compiler.\n \n #![deny(attribute_usage)]\n+#![deny(unused_attribute)]\n #![allow(dead_code)]\n \n #[abi=\"stdcall\"] extern {} //~ ERROR: obsolete attribute\n+                           //~^ ERROR: unused attribute\n \n #[fixed_stack_segment] fn f() {} //~ ERROR: obsolete attribute\n+                                 //~^ ERROR: unused attribute\n \n fn main() {}"}, {"sha": "32c0722d1ac2609df16a4859f7c349f66c46d1a4", "filename": "src/test/compile-fail/lint-unknown-attr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -12,9 +12,13 @@\n // injected intrinsics by the compiler.\n \n #![deny(attribute_usage)]\n+#![deny(unused_attribute)]\n \n #![mutable_doc] //~ ERROR: unknown crate attribute\n+                //~^ ERROR: unused attribute\n \n #[dance] mod a {} //~ ERROR: unknown attribute\n+                //~^ ERROR: unused attribute\n \n #[dance] fn main() {} //~ ERROR: unknown attribute\n+                //~^ ERROR: unused attribute"}, {"sha": "55ca75b4b7131256a7252a5d57b805a014d1dafa", "filename": "src/test/run-pass/attr-mix-new.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fattr-mix-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fattr-mix-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-mix-new.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+#![allow(unused_attribute)]\n \n #[foo(bar)]\n mod foo {"}, {"sha": "cf6126a37fa851a188c4cdf41e5302b626fa98c1", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // ignore-win32 FIXME #13259\n-#![no_uv]\n-\n extern crate native;\n \n use std::os;"}, {"sha": "186fec45c4bb3ab969dee4957a196337454e9ffd", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // pp-exact - Make sure we actually print the attributes\n+#![allow(unused_attribute)]\n \n struct cat {\n     name: StrBuf,"}, {"sha": "6da8123c8c49cc7b58f97adb87be2c0bb629cab9", "filename": "src/test/run-pass/class-attributes-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+#![allow(unused_attribute)]\n \n struct cat {\n   name: StrBuf,"}, {"sha": "255f6b1635c1fca81508e3256fd21c2a70ee8ed3", "filename": "src/test/run-pass/issue-3250.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6304a27b80f3923a8ffc009418c302aa8b06fb93/src%2Ftest%2Frun-pass%2Fissue-3250.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6304a27b80f3923a8ffc009418c302aa8b06fb93/src%2Ftest%2Frun-pass%2Fissue-3250.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3250.rs?ref=6304a27b80f3923a8ffc009418c302aa8b06fb93", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[auto_serialize]\n-\n-type t = (uint, uint);\n-\n-pub fn main() { }"}, {"sha": "bf94af601fea0624c7738d1429f546c2ac729df2", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -11,6 +11,7 @@\n // These are attributes of the implicit crate. Really this just needs to parse\n // for completeness since .rs files linked from .rc files support this\n // notation to specify their module's attributes\n+#![allow(unused_attribute)]\n #![attr1 = \"val\"]\n #![attr2 = \"val\"]\n #![attr3]"}, {"sha": "c015244d520cee80fc484c3ffc7c75825a028d3c", "filename": "src/test/run-pass/method-attributes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fmethod-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07563be6ebe081c8f6666a7b6eb68d8e32774f2f/src%2Ftest%2Frun-pass%2Fmethod-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-attributes.rs?ref=07563be6ebe081c8f6666a7b6eb68d8e32774f2f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // pp-exact - Make sure we print all the attributes\n+#![allow(unused_attribute)]\n \n #[frobable]\n trait frobable {"}]}