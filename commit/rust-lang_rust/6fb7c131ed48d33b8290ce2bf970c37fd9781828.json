{"sha": "6fb7c131ed48d33b8290ce2bf970c37fd9781828", "node_id": "C_kwDOAAsO6NoAKDZmYjdjMTMxZWQ0OGQzM2I4MjkwY2UyYmY5NzBjMzdmZDk3ODE4Mjg", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-05T19:47:01Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:16:02Z"}, "message": "Remove unused lifetimes", "tree": {"sha": "9b955067f4a6a82bd9224efaf445c4b4e235f27d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b955067f4a6a82bd9224efaf445c4b4e235f27d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fb7c131ed48d33b8290ce2bf970c37fd9781828", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRGIACgkQGBtJ+fOP\nM3SyagwAh2yjOzx/PcMXifavGJqAIyEQ8DIuaj4UB1VTUCtugpAHP2jE1tzTNqO0\nyjYQZpHz2ItKRS7jLOLKKXAVbtUZn+z3cZqAq2PCkD15IzuICQwkbIXb3Oe+MtIz\nWocE7S0EPRqNmU1bq6QUTNp3NT71+bxlsRj6hk7JPypN3B345GVEAK4JjKabqOwf\nSjm2m4GLp+Q/mJggCakbhknzYEjWaTsggaNY8cZljtT7DLjOwZ2A3LYRfWaURwSU\ncwCvPpxJjQUSUxD1SKntwoy51xQOo5Fmhd9lqTHET77GUReLfvir2IAP59CsluzA\nI0/2n0zXZLIst7wCXweoGviHCIDmRPgMMYVzjn4mJ0BCECN9MqeFMkE+HGoOErj3\niXu4ENNsnEYcQIjEbsmngwjAJ+GulXmTqq+IyszQsyG1+KMPBBIeAX23J75Ym7W9\ndpoWGrp2JaH5Z33Uj+53WdXGXQa2eRMEqgF6FDhMmtEWaihBID6SEG22ngStME+z\nN6Ob3lYG\n=TyfS\n-----END PGP SIGNATURE-----", "payload": "tree 9b955067f4a6a82bd9224efaf445c4b4e235f27d\nparent 137903671305d30ede80586388cd4db535aa92be\nauthor Andy Wang <cbeuw.andy@gmail.com> 1654458421 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539362 +0100\n\nRemove unused lifetimes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb7c131ed48d33b8290ce2bf970c37fd9781828", "html_url": "https://github.com/rust-lang/rust/commit/6fb7c131ed48d33b8290ce2bf970c37fd9781828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fb7c131ed48d33b8290ce2bf970c37fd9781828/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "137903671305d30ede80586388cd4db535aa92be", "url": "https://api.github.com/repos/rust-lang/rust/commits/137903671305d30ede80586388cd4db535aa92be", "html_url": "https://github.com/rust-lang/rust/commit/137903671305d30ede80586388cd4db535aa92be"}], "stats": {"total": 8, "additions": 2, "deletions": 6}, "files": [{"sha": "28b09d2f909a3e9437de5c5a6ea87a67b19648b8", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fb7c131ed48d33b8290ce2bf970c37fd9781828/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb7c131ed48d33b8290ce2bf970c37fd9781828/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=6fb7c131ed48d33b8290ce2bf970c37fd9781828", "patch": "@@ -939,11 +939,7 @@ impl VClockAlloc {\n \n     /// Detect racing atomic read and writes (not data races)\n     /// on every byte of the current access range\n-    pub(super) fn race_free_with_atomic<'tcx>(\n-        &self,\n-        range: AllocRange,\n-        global: &GlobalState,\n-    ) -> bool {\n+    pub(super) fn race_free_with_atomic(&self, range: AllocRange, global: &GlobalState) -> bool {\n         if global.race_detecting() {\n             let (_, clocks) = global.current_thread_state();\n             let alloc_ranges = self.alloc_ranges.borrow();"}, {"sha": "a771a09ed1ece46b5dbb6136ef5c7ffc7407db85", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fb7c131ed48d33b8290ce2bf970c37fd9781828/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb7c131ed48d33b8290ce2bf970c37fd9781828/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=6fb7c131ed48d33b8290ce2bf970c37fd9781828", "patch": "@@ -138,7 +138,7 @@ impl StoreBufferAlloc {\n     /// before without data race, we can determine that the non-atomic access fully happens\n     /// after all the prior atomic accesses so the location no longer needs to exhibit\n     /// any weak memory behaviours until further atomic accesses.\n-    pub fn memory_accessed<'tcx>(&self, range: AllocRange, global: &GlobalState) {\n+    pub fn memory_accessed(&self, range: AllocRange, global: &GlobalState) {\n         if !global.ongoing_action_data_race_free() {\n             let mut buffers = self.store_buffers.borrow_mut();\n             let access_type = buffers.access_type(range);"}]}