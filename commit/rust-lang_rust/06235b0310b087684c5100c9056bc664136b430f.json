{"sha": "06235b0310b087684c5100c9056bc664136b430f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MjM1YjAzMTBiMDg3Njg0YzUxMDBjOTA1NmJjNjY0MTM2YjQzMGY=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2016-08-24T19:47:46Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2016-08-24T19:47:46Z"}, "message": "refactored misc to reduce passes\n\nrelated to #1062\n\nBefore: 960MB After: 956MB\n\nSo while this reduces code size somewhat, I don't see much memory\nimprovement here. Still, it's probably worthwile to consider reducing\nour passes at least within modules.", "tree": {"sha": "18259017ed3783140c8300935f945061f6e078b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18259017ed3783140c8300935f945061f6e078b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06235b0310b087684c5100c9056bc664136b430f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06235b0310b087684c5100c9056bc664136b430f", "html_url": "https://github.com/rust-lang/rust/commit/06235b0310b087684c5100c9056bc664136b430f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06235b0310b087684c5100c9056bc664136b430f/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf84ea8459d170b53b387ea1e8919b961064915", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf84ea8459d170b53b387ea1e8919b961064915", "html_url": "https://github.com/rust-lang/rust/commit/ddf84ea8459d170b53b387ea1e8919b961064915"}], "stats": {"total": 499, "additions": 202, "deletions": 297}, "files": [{"sha": "39d2c6b5f0d11ee9861c4992870163eb5f197451", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06235b0310b087684c5100c9056bc664136b430f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06235b0310b087684c5100c9056bc664136b430f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=06235b0310b087684c5100c9056bc664136b430f", "patch": "@@ -176,8 +176,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box types::TypePass);\n     reg.register_late_lint_pass(box booleans::NonminimalBool);\n     reg.register_early_lint_pass(box module_inception::Pass);\n-    reg.register_late_lint_pass(box misc::TopLevelRefPass);\n-    reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n     reg.register_early_lint_pass(box enum_variants::EnumVariantNames::new(conf.enum_variant_name_threshold));\n     reg.register_late_lint_pass(box enum_glob_use::EnumGlobUse);\n@@ -187,19 +185,17 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box needless_bool::NeedlessBool);\n     reg.register_late_lint_pass(box needless_bool::BoolComparison);\n     reg.register_late_lint_pass(box approx_const::Pass);\n-    reg.register_late_lint_pass(box misc::FloatCmp);\n+    reg.register_late_lint_pass(box misc::Pass);\n     reg.register_early_lint_pass(box precedence::Precedence);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n     reg.register_late_lint_pass(box identity_op::IdentityOp);\n     reg.register_early_lint_pass(box items_after_statements::ItemsAfterStatements);\n     reg.register_late_lint_pass(box mut_mut::MutMut);\n     reg.register_late_lint_pass(box mut_reference::UnnecessaryMutPassed);\n     reg.register_late_lint_pass(box len_zero::LenZero);\n-    reg.register_late_lint_pass(box misc::CmpOwned);\n     reg.register_late_lint_pass(box attrs::AttrPass);\n     reg.register_early_lint_pass(box collapsible_if::CollapsibleIf);\n     reg.register_late_lint_pass(box block_in_if_condition::BlockInIfCondition);\n-    reg.register_late_lint_pass(box misc::ModuloOne);\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n     reg.register_early_lint_pass(box returns::ReturnPass);\n@@ -214,7 +210,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box types::CastPass);\n     reg.register_late_lint_pass(box types::TypeComplexityPass::new(conf.type_complexity_threshold));\n     reg.register_late_lint_pass(box matches::MatchPass);\n-    reg.register_late_lint_pass(box misc::PatternPass);\n     reg.register_late_lint_pass(box minmax::MinMaxPass);\n     reg.register_late_lint_pass(box open_options::NonSensical);\n     reg.register_late_lint_pass(box zero_div_zero::Pass);\n@@ -228,7 +223,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n-    reg.register_late_lint_pass(box misc::UsedUnderscoreBinding);\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n     reg.register_late_lint_pass(box panic::Pass);\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);"}, {"sha": "5526c8660f47d8f8928bd5ae9c78669f1175bf29", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 201, "deletions": 290, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/06235b0310b087684c5100c9056bc664136b430f/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06235b0310b087684c5100c9056bc664136b430f/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=06235b0310b087684c5100c9056bc664136b430f", "patch": "@@ -40,16 +40,134 @@ declare_lint! {\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n \n-#[allow(missing_copy_implementations)]\n-pub struct TopLevelRefPass;\n+/// **What it does:** Checks for comparisons to NaN.\n+///\n+/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n+/// even itself \u2013 so those comparisons are simply wrong.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x == NAN\n+/// ```\n+declare_lint! {\n+    pub CMP_NAN,\n+    Deny,\n+    \"comparisons to NAN, which will always return false, probably not intended\"\n+}\n+\n+/// **What it does:** Checks for (in-)equality comparisons on floating-point\n+/// values (apart from zero), except in functions called `*eq*` (which probably\n+/// implement equality for a type involving floats).\n+///\n+/// **Why is this bad?** Floating point calculations are usually imprecise, so\n+/// asking if two values are *exactly* equal is asking for trouble. For a good\n+/// guide on what to do, see [the floating point\n+/// guide](http://www.floating-point-gui.de/errors/comparison).\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// y == 1.23f64\n+/// y != x  // where both are floats\n+/// ```\n+declare_lint! {\n+    pub FLOAT_CMP,\n+    Warn,\n+    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n+}\n+\n+/// **What it does:** Checks for conversions to owned values just for the sake\n+/// of a comparison.\n+///\n+/// **Why is this bad?** The comparison can operate on a reference, so creating\n+/// an owned value effectively throws it away directly afterwards, which is\n+/// needlessly consuming code and heap space.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x.to_owned() == y\n+/// ```\n+declare_lint! {\n+    pub CMP_OWNED,\n+    Warn,\n+    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n+}\n+\n+/// **What it does:** Checks for getting the remainder of a division by one.\n+///\n+/// **Why is this bad?** The result can only ever be zero. No one will write\n+/// such code deliberately, unless trying to win an Underhanded Rust\n+/// Contest. Even for that contest, it's probably a bad idea. Use something more\n+/// underhanded.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x % 1\n+/// ```\n+declare_lint! {\n+    pub MODULO_ONE,\n+    Warn,\n+    \"taking a number modulo 1, which always returns 0\"\n+}\n+\n+/// **What it does:** Checks for patterns in the form `name @ _`.\n+///\n+/// **Why is this bad?** It's almost always more readable to just use direct bindings.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// match v {\n+///     Some(x) => (),\n+///     y @ _   => (), // easier written as `y`,\n+/// }\n+/// ```\n+declare_lint! {\n+    pub REDUNDANT_PATTERN,\n+    Warn,\n+    \"using `name @ _` in a pattern\"\n+}\n+\n+/// **What it does:** Checks for the use of bindings with a single leading underscore.\n+///\n+/// **Why is this bad?** A single leading underscore is usually used to indicate\n+/// that a binding will not be used. Using such a binding breaks this\n+/// expectation.\n+///\n+/// **Known problems:** The lint does not work properly with desugaring and\n+/// macro, it has been allowed in the mean time.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _x = 0;\n+/// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n+///                 // We should rename `_x` to `x`\n+/// ```\n+declare_lint! {\n+    pub USED_UNDERSCORE_BINDING,\n+    Allow,\n+    \"using a binding which is prefixed with an underscore\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Pass;\n \n-impl LintPass for TopLevelRefPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(TOPLEVEL_REF_ARG)\n+        lint_array!(TOPLEVEL_REF_ARG, CMP_NAN, FLOAT_CMP, CMP_OWNED, MODULO_ONE, REDUNDANT_PATTERN,\n+                    USED_UNDERSCORE_BINDING)\n     }\n }\n \n-impl LateLintPass for TopLevelRefPass {\n+impl LateLintPass for Pass {\n     fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n@@ -64,6 +182,7 @@ impl LateLintPass for TopLevelRefPass {\n             }\n         }\n     }\n+\n     fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n         if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n@@ -97,103 +216,28 @@ impl LateLintPass for TopLevelRefPass {\n             );\n         }}\n     }\n-}\n \n-/// **What it does:** Checks for comparisons to NaN.\n-///\n-/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n-/// even itself \u2013 so those comparisons are simply wrong.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x == NAN\n-/// ```\n-declare_lint! {\n-    pub CMP_NAN,\n-    Deny,\n-    \"comparisons to NAN, which will always return false, probably not intended\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct CmpNan;\n-\n-impl LintPass for CmpNan {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CMP_NAN)\n-    }\n-}\n-\n-impl LateLintPass for CmpNan {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            if cmp.node.is_comparison() {\n+            let op = cmp.node;\n+            if op.is_comparison() {\n                 if let ExprPath(_, ref path) = left.node {\n                     check_nan(cx, path, expr.span);\n                 }\n                 if let ExprPath(_, ref path) = right.node {\n                     check_nan(cx, path, expr.span);\n                 }\n+                check_to_owned(cx, left, right, true, cmp.span);\n+                check_to_owned(cx, right, left, false, cmp.span)\n             }\n-        }\n-    }\n-}\n-\n-fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n-    path.segments.last().map(|seg| {\n-        if seg.name.as_str() == \"NAN\" {\n-            span_lint(cx,\n-                      CMP_NAN,\n-                      span,\n-                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n-        }\n-    });\n-}\n-\n-/// **What it does:** Checks for (in-)equality comparisons on floating-point\n-/// values (apart from zero), except in functions called `*eq*` (which probably\n-/// implement equality for a type involving floats).\n-///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so\n-/// asking if two values are *exactly* equal is asking for trouble. For a good\n-/// guide on what to do, see [the floating point\n-/// guide](http://www.floating-point-gui.de/errors/comparison).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// y == 1.23f64\n-/// y != x  // where both are floats\n-/// ```\n-declare_lint! {\n-    pub FLOAT_CMP,\n-    Warn,\n-    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct FloatCmp;\n-\n-impl LintPass for FloatCmp {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(FLOAT_CMP)\n-    }\n-}\n-\n-impl LateLintPass for FloatCmp {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n                 if is_allowed(cx, left) || is_allowed(cx, right) {\n                     return;\n                 }\n                 if let Some(name) = get_item_name(cx, expr) {\n                     let name = name.as_str();\n                     if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                       name.ends_with(\"_eq\") {\n+                        name.ends_with(\"_eq\") {\n                         return;\n                     }\n                 }\n@@ -202,19 +246,84 @@ impl LateLintPass for FloatCmp {\n                                    expr.span,\n                                    \"strict comparison of f32 or f64\",\n                                    |db| {\n-                    let lhs = Sugg::hir(cx, left, \"..\");\n-                    let rhs = Sugg::hir(cx, right, \"..\");\n+                                       let lhs = Sugg::hir(cx, left, \"..\");\n+                                       let rhs = Sugg::hir(cx, right, \"..\");\n+\n+                                       db.span_suggestion(expr.span,\n+                                                          \"consider comparing them within some error\",\n+                                                          format!(\"({}).abs() < error\", lhs - rhs));\n+                                       db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                                   });\n+            } else if op == BiRem && is_integer_literal(right, 1) {\n+                span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+            }\n+        }\n+        if in_attributes_expansion(cx, expr) {\n+            // Don't lint things expanded by #[derive(...)], etc\n+            return;\n+        }\n+        let binding = match expr.node {\n+            ExprPath(_, ref path) => {\n+                let binding = path.segments\n+                    .last()\n+                    .expect(\"path should always have at least one segment\")\n+                    .name\n+                    .as_str();\n+                if binding.starts_with('_') &&\n+                    !binding.starts_with(\"__\") &&\n+                    binding != \"_result\" && // FIXME: #944\n+                    is_used(cx, expr) &&\n+                    // don't lint if the declaration is in a macro\n+                    non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n+                    Some(binding)\n+                } else {\n+                    None\n+                }\n+            }\n+            ExprField(_, spanned) => {\n+                let name = spanned.node.as_str();\n+                if name.starts_with('_') && !name.starts_with(\"__\") {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        };\n+        if let Some(binding) = binding {\n+            span_lint(cx,\n+                      USED_UNDERSCORE_BINDING,\n+                      expr.span,\n+                      &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n+                                underscore signals that a binding will not be used.\", binding));\n+        }\n+    }\n \n-                    db.span_suggestion(expr.span,\n-                                       \"consider comparing them within some error\",\n-                                       format!(\"({}).abs() < error\", lhs - rhs));\n-                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n-                });\n+    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n+            if right.node == PatKind::Wild {\n+                span_lint(cx,\n+                          REDUNDANT_PATTERN,\n+                          pat.span,\n+                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n+                                   ident.node,\n+                                   ident.node));\n             }\n         }\n     }\n }\n \n+fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n+    path.segments.last().map(|seg| {\n+        if seg.name.as_str() == \"NAN\" {\n+            span_lint(cx,\n+                      CMP_NAN,\n+                      span,\n+                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+        }\n+    });\n+}\n+\n fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n     let res = eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None);\n     if let Ok(ConstVal::Float(val)) = res {\n@@ -247,45 +356,6 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tcx.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-/// **What it does:** Checks for conversions to owned values just for the sake\n-/// of a comparison.\n-///\n-/// **Why is this bad?** The comparison can operate on a reference, so creating\n-/// an owned value effectively throws it away directly afterwards, which is\n-/// needlessly consuming code and heap space.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.to_owned() == y\n-/// ```\n-declare_lint! {\n-    pub CMP_OWNED,\n-    Warn,\n-    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct CmpOwned;\n-\n-impl LintPass for CmpOwned {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CMP_OWNED)\n-    }\n-}\n-\n-impl LateLintPass for CmpOwned {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            if cmp.node.is_comparison() {\n-                check_to_owned(cx, left, right, true, cmp.span);\n-                check_to_owned(cx, right, left, false, cmp.span)\n-            }\n-        }\n-    }\n-}\n-\n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n@@ -346,165 +416,6 @@ fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n         matches!(walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n-/// **What it does:** Checks for getting the remainder of a division by one.\n-///\n-/// **Why is this bad?** The result can only ever be zero. No one will write\n-/// such code deliberately, unless trying to win an Underhanded Rust\n-/// Contest. Even for that contest, it's probably a bad idea. Use something more\n-/// underhanded.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x % 1\n-/// ```\n-declare_lint! {\n-    pub MODULO_ONE,\n-    Warn,\n-    \"taking a number modulo 1, which always returns 0\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct ModuloOne;\n-\n-impl LintPass for ModuloOne {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MODULO_ONE)\n-    }\n-}\n-\n-impl LateLintPass for ModuloOne {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, _, ref right) = expr.node {\n-            if let Spanned { node: BinOp_::BiRem, .. } = *cmp {\n-                if is_integer_literal(right, 1) {\n-                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// **What it does:** Checks for patterns in the form `name @ _`.\n-///\n-/// **Why is this bad?** It's almost always more readable to just use direct bindings.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match v {\n-///     Some(x) => (),\n-///     y @ _   => (), // easier written as `y`,\n-/// }\n-/// ```\n-declare_lint! {\n-    pub REDUNDANT_PATTERN,\n-    Warn,\n-    \"using `name @ _` in a pattern\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct PatternPass;\n-\n-impl LintPass for PatternPass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(REDUNDANT_PATTERN)\n-    }\n-}\n-\n-impl LateLintPass for PatternPass {\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n-            if right.node == PatKind::Wild {\n-                span_lint(cx,\n-                          REDUNDANT_PATTERN,\n-                          pat.span,\n-                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                   ident.node,\n-                                   ident.node));\n-            }\n-        }\n-    }\n-}\n-\n-\n-/// **What it does:** Checks for the use of bindings with a single leading underscore.\n-///\n-/// **Why is this bad?** A single leading underscore is usually used to indicate\n-/// that a binding will not be used. Using such a binding breaks this\n-/// expectation.\n-///\n-/// **Known problems:** The lint does not work properly with desugaring and\n-/// macro, it has been allowed in the mean time.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _x = 0;\n-/// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n-///                 // We should rename `_x` to `x`\n-/// ```\n-declare_lint! {\n-    pub USED_UNDERSCORE_BINDING,\n-    Allow,\n-    \"using a binding which is prefixed with an underscore\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UsedUnderscoreBinding;\n-\n-impl LintPass for UsedUnderscoreBinding {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(USED_UNDERSCORE_BINDING)\n-    }\n-}\n-\n-impl LateLintPass for UsedUnderscoreBinding {\n-    #[cfg_attr(rustfmt, rustfmt_skip)]\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if in_attributes_expansion(cx, expr) {\n-            // Don't lint things expanded by #[derive(...)], etc\n-            return;\n-        }\n-        let binding = match expr.node {\n-            ExprPath(_, ref path) => {\n-                let binding = path.segments\n-                                .last()\n-                                .expect(\"path should always have at least one segment\")\n-                                .name\n-                                .as_str();\n-                if binding.starts_with('_') &&\n-                   !binding.starts_with(\"__\") &&\n-                   binding != \"_result\" && // FIXME: #944\n-                   is_used(cx, expr) &&\n-                   // don't lint if the declaration is in a macro\n-                   non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n-                    Some(binding)\n-                } else {\n-                    None\n-                }\n-            }\n-            ExprField(_, spanned) => {\n-                let name = spanned.node.as_str();\n-                if name.starts_with('_') && !name.starts_with(\"__\") {\n-                    Some(name)\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        };\n-        if let Some(binding) = binding {\n-            span_lint(cx,\n-                      USED_UNDERSCORE_BINDING,\n-                      expr.span,\n-                      &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n-                                underscore signals that a binding will not be used.\", binding));\n-        }\n-    }\n-}\n-\n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {"}]}