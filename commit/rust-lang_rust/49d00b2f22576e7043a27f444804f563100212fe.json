{"sha": "49d00b2f22576e7043a27f444804f563100212fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZDAwYjJmMjI1NzZlNzA0M2EyN2Y0NDQ4MDRmNTYzMTAwMjEyZmU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-24T16:55:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:29:41Z"}, "message": "libstd: port json over to serialization2", "tree": {"sha": "f827dbd75648c0ce0ff921e71dbed1a2d87c5a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f827dbd75648c0ce0ff921e71dbed1a2d87c5a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d00b2f22576e7043a27f444804f563100212fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d00b2f22576e7043a27f444804f563100212fe", "html_url": "https://github.com/rust-lang/rust/commit/49d00b2f22576e7043a27f444804f563100212fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d00b2f22576e7043a27f444804f563100212fe/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "html_url": "https://github.com/rust-lang/rust/commit/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035"}], "stats": {"total": 1346, "additions": 819, "deletions": 527}, "files": [{"sha": "b5c9fc174162f60ddadbcdcb020f4ae88688f695", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 59, "deletions": 60, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/49d00b2f22576e7043a27f444804f563100212fe/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d00b2f22576e7043a27f444804f563100212fe/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=49d00b2f22576e7043a27f444804f563100212fe", "patch": "@@ -11,6 +11,7 @@ use syntax::diagnostic;\n \n use result::{Ok, Err};\n use io::WriterUtil;\n+use send_map::linear::LinearMap;\n use std::{map, json, tempfile, term, sort, getopts};\n use map::HashMap;\n use to_str::to_str;\n@@ -400,7 +401,7 @@ fn need_dir(s: &Path) {\n     }\n }\n \n-fn valid_pkg_name(s: ~str) -> bool {\n+fn valid_pkg_name(s: &str) -> bool {\n     fn is_valid_digit(c: char) -> bool {\n         ('0' <= c && c <= '9') ||\n         ('a' <= c && c <= 'z') ||\n@@ -412,27 +413,27 @@ fn valid_pkg_name(s: ~str) -> bool {\n     s.all(is_valid_digit)\n }\n \n-fn parse_source(name: ~str, j: json::Json) -> @Source {\n+fn parse_source(name: ~str, j: &json::Json) -> @Source {\n     if !valid_pkg_name(name) {\n         fail fmt!(\"'%s' is an invalid source name\", name);\n     }\n \n-    match j {\n-        json::Dict(j) => {\n-            let mut url = match j.find(~\"url\") {\n-                Some(json::String(u)) => *u,\n+    match *j {\n+        json::Object(j) => {\n+            let mut url = match j.find(&~\"url\") {\n+                Some(json::String(u)) => u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n-            let method = match j.find(~\"method\") {\n-                Some(json::String(u)) => *u,\n+            let method = match j.find(&~\"method\") {\n+                Some(json::String(u)) => u,\n                 _ => assume_source_method(url)\n             };\n-            let key = match j.find(~\"key\") {\n-                Some(json::String(u)) => Some(*u),\n+            let key = match j.find(&~\"key\") {\n+                Some(json::String(u)) => Some(u),\n                 _ => None\n             };\n-            let keyfp = match j.find(~\"keyfp\") {\n-                Some(json::String(u)) => Some(*u),\n+            let keyfp = match j.find(&~\"keyfp\") {\n+                Some(json::String(u)) => Some(u),\n                 _ => None\n             };\n             if method == ~\"file\" {\n@@ -454,88 +455,88 @@ fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(c.get()) {\n-        Ok(json::Dict(j)) => {\n-          for j.each |k, v| {\n-                sources.insert(k, parse_source(k, v));\n-                debug!(\"source: %s\", k);\n+        Ok(json::Object(j)) => {\n+            for j.each |k, v| {\n+                sources.insert(copy *k, parse_source(*k, v));\n+                debug!(\"source: %s\", *k);\n             }\n         }\n         Ok(_) => fail ~\"malformed sources.json\",\n         Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n     }\n }\n \n-fn load_one_source_package(src: @Source, p: map::HashMap<~str, json::Json>) {\n-    let name = match p.find(~\"name\") {\n+fn load_one_source_package(src: @Source, p: &json::Object) {\n+    let name = match p.find(&~\"name\") {\n         Some(json::String(n)) => {\n-            if !valid_pkg_name(*n) {\n+            if !valid_pkg_name(n) {\n                 warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + *n + ~\"'\"+\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n                      ~\" is an invalid name (alphanumeric, underscores and\" +\n                      ~\" dashes only)\");\n                 return;\n             }\n-            *n\n+            n\n         }\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n             return;\n         }\n     };\n \n-    let uuid = match p.find(~\"uuid\") {\n+    let uuid = match p.find(&~\"uuid\") {\n         Some(json::String(n)) => {\n-            if !is_uuid(*n) {\n+            if !is_uuid(n) {\n                 warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + *n + ~\"'\"+\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n                      ~\" is an invalid uuid\");\n                 return;\n             }\n-            *n\n+            n\n         }\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n             return;\n         }\n     };\n \n-    let url = match p.find(~\"url\") {\n-        Some(json::String(n)) => *n,\n+    let url = match p.find(&~\"url\") {\n+        Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n-    let method = match p.find(~\"method\") {\n-        Some(json::String(n)) => *n,\n+    let method = match p.find(&~\"method\") {\n+        Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n             return;\n         }\n     };\n \n-    let reference = match p.find(~\"ref\") {\n-        Some(json::String(n)) => Some(*n),\n+    let reference = match p.find(&~\"ref\") {\n+        Some(json::String(n)) => Some(n),\n         _ => None\n     };\n \n     let mut tags = ~[];\n-    match p.find(~\"tags\") {\n+    match p.find(&~\"tags\") {\n         Some(json::List(js)) => {\n-          for (*js).each |j| {\n+          for js.each |j| {\n                 match *j {\n-                    json::String(j) => vec::grow(tags, 1u, *j),\n+                    json::String(j) => vec::grow(tags, 1u, j),\n                     _ => ()\n                 }\n             }\n         }\n         _ => ()\n     }\n \n-    let description = match p.find(~\"description\") {\n-        Some(json::String(n)) => *n,\n+    let description = match p.find(&~\"description\") {\n+        Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");\n@@ -573,8 +574,8 @@ fn load_source_info(c: &Cargo, src: @Source) {\n     if !os::path_exists(&srcfile) { return; }\n     let srcstr = io::read_whole_file_str(&srcfile);\n     match json::from_str(srcstr.get()) {\n-        Ok(json::Dict(s)) => {\n-            let o = parse_source(src.name, json::Dict(s));\n+        Ok(ref json @ json::Object(_)) => {\n+            let o = parse_source(src.name, json);\n \n             src.key = o.key;\n             src.keyfp = o.keyfp;\n@@ -596,9 +597,9 @@ fn load_source_packages(c: &Cargo, src: @Source) {\n     let pkgstr = io::read_whole_file_str(&pkgfile);\n     match json::from_str(pkgstr.get()) {\n         Ok(json::List(js)) => {\n-          for (*js).each |j| {\n+          for js.each |j| {\n                 match *j {\n-                    json::Dict(p) => {\n+                    json::Object(p) => {\n                         load_one_source_package(src, p);\n                     }\n                     _ => {\n@@ -663,11 +664,11 @@ fn configure(opts: Options) -> Cargo {\n \n     let p = get_cargo_dir().get();\n \n-    let sources = map::HashMap();\n+    let sources = HashMap();\n     try_parse_sources(&home.push(\"sources.json\"), sources);\n     try_parse_sources(&home.push(\"local-sources.json\"), sources);\n \n-    let dep_cache = map::HashMap();\n+    let dep_cache = HashMap();\n \n     let mut c = Cargo {\n         pgp: pgp::supported(),\n@@ -707,10 +708,10 @@ fn configure(opts: Options) -> Cargo {\n     c\n }\n \n-fn for_each_package(c: &Cargo, b: fn(s: @Source, p: Package)) {\n+fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n     for c.sources.each_value |v| {\n         for v.packages.each |p| {\n-            b(v, *p);\n+            b(v, p);\n         }\n     }\n }\n@@ -876,7 +877,7 @@ fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n     match method {\n         ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n         ~\"file\" => install_file(c, wd, &Path(url)),\n-        ~\"curl\" => install_curl(c, wd, copy url),\n+        ~\"curl\" => install_curl(c, wd, url),\n         _ => ()\n     }\n }\n@@ -895,7 +896,7 @@ fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n-            vec::grow(ps, 1u, (s.name, copy p));\n+            vec::push(ps, (s.name, copy *p));\n         }\n     });\n     if vec::len(ps) == 1u {\n@@ -919,7 +920,7 @@ fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n-            vec::grow(ps, 1u, (s.name, copy p));\n+            vec::push(ps, (s.name, copy *p));\n         }\n     });\n     if vec::len(ps) == 1u {\n@@ -1477,7 +1478,7 @@ fn cmd_init(c: &Cargo) {\n     info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n }\n \n-fn print_pkg(s: @Source, p: Package) {\n+fn print_pkg(s: @Source, p: &Package) {\n     let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n     if vec::len(p.tags) > 0u {\n         m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n@@ -1572,7 +1573,7 @@ fn dump_cache(c: &Cargo) {\n     need_dir(&c.root);\n \n     let out = c.root.push(\"cache.json\");\n-    let _root = json::Dict(map::HashMap());\n+    let _root = json::Object(~LinearMap());\n \n     if os::path_exists(&out) {\n         copy_warn(&out, &c.root.push(\"cache.json.old\"));\n@@ -1593,33 +1594,31 @@ fn dump_sources(c: &Cargo) {\n \n     match io::buffered_file_writer(&out) {\n         result::Ok(writer) => {\n-            let hash = map::HashMap();\n-            let root = json::Dict(hash);\n+            let mut hash = ~LinearMap();\n \n-          for c.sources.each |k, v| {\n-                let chash = map::HashMap();\n-                let child = json::Dict(chash);\n+            for c.sources.each |k, v| {\n+                let mut chash = ~LinearMap();\n \n-                chash.insert(~\"url\", json::String(@v.url));\n-                chash.insert(~\"method\", json::String(@v.method));\n+                chash.insert(~\"url\", json::String(v.url));\n+                chash.insert(~\"method\", json::String(v.method));\n \n                 match copy v.key {\n                     Some(key) => {\n-                        chash.insert(~\"key\", json::String(@key));\n+                        chash.insert(~\"key\", json::String(copy key));\n                     }\n                     _ => ()\n                 }\n                 match copy v.keyfp {\n                     Some(keyfp) => {\n-                        chash.insert(~\"keyfp\", json::String(@keyfp));\n+                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n                     }\n                     _ => ()\n                 }\n \n-                hash.insert(k, child);\n+                hash.insert(copy k, json::Object(chash));\n             }\n \n-            writer.write_str(json::to_str(root));\n+            json::to_writer(writer, &json::Object(hash))\n         }\n         result::Err(e) => {\n             error(fmt!(\"could not dump sources: %s\", e));"}, {"sha": "f75f033bb8ed58b268c1e766f91974d691123027", "filename": "src/libstd/json.rs", "status": "modified", "additions": 754, "deletions": 462, "changes": 1216, "blob_url": "https://github.com/rust-lang/rust/blob/49d00b2f22576e7043a27f444804f563100212fe/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d00b2f22576e7043a27f444804f563100212fe/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=49d00b2f22576e7043a27f444804f563100212fe", "patch": "@@ -11,214 +11,327 @@ use result::{Result, Ok, Err};\n use io::{WriterUtil, ReaderUtil};\n use map::HashMap;\n use map::Map;\n+use send_map::linear;\n use sort::Sort;\n \n-export Json;\n-export Error;\n-export to_writer;\n-export to_writer_pretty;\n-export to_str;\n-export to_str_pretty;\n-export from_reader;\n-export from_str;\n-export eq;\n-export ToJson;\n-\n-export Num;\n-export String;\n-export Boolean;\n-export List;\n-export Dict;\n-export Null;\n-\n /// Represents a json value\n-enum Json {\n-    Num(float),\n-    String(@~str),\n+pub enum Json {\n+    Number(float),\n+    String(~str),\n     Boolean(bool),\n-    List(@~[Json]),\n-    Dict(map::HashMap<~str, Json>),\n+    List(List),\n+    Object(~Object),\n     Null,\n }\n \n-type Error = {\n+pub type List = ~[Json];\n+pub type Object = linear::LinearMap<~str, Json>;\n+\n+pub struct Error {\n     line: uint,\n     col: uint,\n     msg: @~str,\n-};\n+}\n \n-/// Serializes a json value into a io::writer\n-fn to_writer(wr: io::Writer, j: Json) {\n-    match j {\n-      Num(n) => wr.write_str(float::to_str(n, 6u)),\n-      String(s) => wr.write_str(escape_str(*s)),\n-      Boolean(b) => wr.write_str(if b { ~\"true\" } else { ~\"false\" }),\n-      List(v) => {\n-        wr.write_char('[');\n-        let mut first = true;\n-        for (*v).each |item| {\n-            if !first {\n-                wr.write_str(~\", \");\n-            }\n-            first = false;\n-            to_writer(wr, *item);\n-        };\n-        wr.write_char(']');\n-      }\n-      Dict(d) => {\n-        if d.size() == 0u {\n-            wr.write_str(~\"{}\");\n-            return;\n+fn escape_str(s: &str) -> ~str {\n+    let mut escaped = ~\"\\\"\";\n+    for str::chars_each(s) |c| {\n+        match c {\n+          '\"' => escaped += ~\"\\\\\\\"\",\n+          '\\\\' => escaped += ~\"\\\\\\\\\",\n+          '\\x08' => escaped += ~\"\\\\b\",\n+          '\\x0c' => escaped += ~\"\\\\f\",\n+          '\\n' => escaped += ~\"\\\\n\",\n+          '\\r' => escaped += ~\"\\\\r\",\n+          '\\t' => escaped += ~\"\\\\t\",\n+          _ => escaped += str::from_char(c)\n         }\n+    };\n \n-        wr.write_str(~\"{ \");\n-        let mut first = true;\n-        for d.each |key, value| {\n-            if !first {\n-                wr.write_str(~\", \");\n-            }\n-            first = false;\n-            wr.write_str(escape_str(key));\n-            wr.write_str(~\": \");\n-            to_writer(wr, value);\n-        };\n-        wr.write_str(~\" }\");\n-      }\n-      Null => wr.write_str(~\"null\")\n-    }\n+    escaped += ~\"\\\"\";\n+\n+    escaped\n }\n \n-/// Serializes a json value into a io::writer\n-fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n-    fn spaces(n: uint) -> ~str {\n-        let mut ss = ~\"\";\n-        for n.times { str::push_str(&mut ss, \" \"); }\n-        return ss;\n-    }\n-\n-    match j {\n-      Num(n) => wr.write_str(float::to_str(n, 6u)),\n-      String(s) => wr.write_str(escape_str(*s)),\n-      Boolean(b) => wr.write_str(if b { ~\"true\" } else { ~\"false\" }),\n-      List(vv) => {\n-        if vv.len() == 0u {\n-            wr.write_str(~\"[]\");\n-            return;\n+fn spaces(n: uint) -> ~str {\n+    let mut ss = ~\"\";\n+    for n.times { str::push_str(&ss, \" \"); }\n+    return ss;\n+}\n+\n+pub struct Serializer {\n+    priv wr: io::Writer,\n+}\n+\n+pub fn Serializer(wr: io::Writer) -> Serializer {\n+    Serializer { wr: wr }\n+}\n+\n+pub impl Serializer: serialization2::Serializer {\n+    fn emit_nil(&self) { self.wr.write_str(\"null\") }\n+\n+    fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n+    fn emit_u64(&self, v: u64) { self.emit_float(v as float); }\n+    fn emit_u32(&self, v: u32) { self.emit_float(v as float); }\n+    fn emit_u16(&self, v: u16) { self.emit_float(v as float); }\n+    fn emit_u8(&self, v: u8)   { self.emit_float(v as float); }\n+\n+    fn emit_int(&self, v: int) { self.emit_float(v as float); }\n+    fn emit_i64(&self, v: i64) { self.emit_float(v as float); }\n+    fn emit_i32(&self, v: i32) { self.emit_float(v as float); }\n+    fn emit_i16(&self, v: i16) { self.emit_float(v as float); }\n+    fn emit_i8(&self, v: i8)   { self.emit_float(v as float); }\n+\n+    fn emit_bool(&self, v: bool) {\n+        if v {\n+            self.wr.write_str(\"true\");\n+        } else {\n+            self.wr.write_str(\"false\");\n         }\n+    }\n \n-        let inner_indent = indent + 2;\n+    fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n+    fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n+    fn emit_float(&self, v: float) {\n+        self.wr.write_str(float::to_str(v, 6u));\n+    }\n \n-        // [\n-        wr.write_str(\"[\\n\");\n-        wr.write_str(spaces(inner_indent));\n+    fn emit_str(&self, v: &str) {\n+        let s = escape_str(v);\n+        self.wr.write_str(s);\n+    }\n \n-        // [ elem,\n-        //   elem,\n-        //   elem ]\n-        let mut first = true;\n-        for (*vv).each |item| {\n-            if !first {\n-                wr.write_str(~\",\\n\");\n-                wr.write_str(spaces(inner_indent));\n-            }\n-            first = false;\n-            to_writer_pretty(wr, *item, inner_indent);\n-        };\n+    fn emit_enum(&self, name: &str, f: fn()) {\n+        if name != \"option\" { fail ~\"only supports option enum\" }\n+        f()\n+    }\n+    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n+        if id == 0 {\n+            self.emit_nil();\n+        } else {\n+            f()\n+        }\n+    }\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) {\n+        f()\n+    }\n+\n+    fn emit_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_char('[');\n+        f();\n+        self.wr.write_char(']');\n+    }\n+\n+    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        f()\n+    }\n+\n+    fn emit_box(&self, f: fn()) { f() }\n+    fn emit_uniq(&self, f: fn()) { f() }\n+    fn emit_rec(&self, f: fn()) {\n+        self.wr.write_char('{');\n+        f();\n+        self.wr.write_char('}');\n+    }\n+    fn emit_rec_field(&self, name: &str, idx: uint, f: fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_char(':');\n+        f();\n+    }\n+    fn emit_tup(&self, sz: uint, f: fn()) {\n+        self.emit_vec(sz, f);\n+    }\n+    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+        self.emit_vec_elt(idx, f)\n+    }\n+}\n+\n+pub struct PrettySerializer {\n+    priv wr: io::Writer,\n+    priv mut indent: uint,\n+}\n+\n+pub fn PrettySerializer(wr: io::Writer) -> PrettySerializer {\n+    PrettySerializer { wr: wr, indent: 0 }\n+}\n \n-        // ]\n-        wr.write_str(\"\\n\");\n-        wr.write_str(spaces(indent));\n-        wr.write_str(~\"]\");\n-      }\n-      Dict(dd) => {\n-        if dd.size() == 0u {\n-            wr.write_str(~\"{}\");\n-            return;\n+pub impl PrettySerializer: serialization2::Serializer {\n+    fn emit_nil(&self) { self.wr.write_str(\"null\") }\n+\n+    fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n+    fn emit_u64(&self, v: u64) { self.emit_float(v as float); }\n+    fn emit_u32(&self, v: u32) { self.emit_float(v as float); }\n+    fn emit_u16(&self, v: u16) { self.emit_float(v as float); }\n+    fn emit_u8(&self, v: u8)   { self.emit_float(v as float); }\n+\n+    fn emit_int(&self, v: int) { self.emit_float(v as float); }\n+    fn emit_i64(&self, v: i64) { self.emit_float(v as float); }\n+    fn emit_i32(&self, v: i32) { self.emit_float(v as float); }\n+    fn emit_i16(&self, v: i16) { self.emit_float(v as float); }\n+    fn emit_i8(&self, v: i8)   { self.emit_float(v as float); }\n+\n+    fn emit_bool(&self, v: bool) {\n+        if v {\n+            self.wr.write_str(\"true\");\n+        } else {\n+            self.wr.write_str(\"false\");\n         }\n+    }\n+\n+    fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n+    fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n+    fn emit_float(&self, v: float) {\n+        self.wr.write_str(float::to_str(v, 6u));\n+    }\n \n-        let inner_indent = indent + 2;\n+    fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n \n-        // convert from a dictionary\n-        let mut pairs = ~[];\n-        for dd.each |key, value| {\n-            vec::push(pairs, (key, value));\n+    fn emit_enum(&self, name: &str, f: fn()) {\n+        if name != \"option\" { fail ~\"only supports option enum\" }\n+        f()\n+    }\n+    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n+        if id == 0 {\n+            self.emit_nil();\n+        } else {\n+            f()\n         }\n+    }\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) {\n+        f()\n+    }\n \n-        // sort by key strings\n-        let sorted_pairs = sort::merge_sort(|a,b| *a <= *b, pairs);\n-\n-        // {\n-        wr.write_str(~\"{\\n\");\n-        wr.write_str(spaces(inner_indent));\n-\n-        // { k: v,\n-        //   k: v,\n-        //   k: v }\n-        let mut first = true;\n-        for sorted_pairs.each |kv| {\n-            let (key, value) = *kv;\n-            if !first {\n-                wr.write_str(~\",\\n\");\n-                wr.write_str(spaces(inner_indent));\n-            }\n-            first = false;\n-            let key = str::append(escape_str(key), ~\": \");\n-            let key_indent = inner_indent + str::len(key);\n-            wr.write_str(key);\n-            to_writer_pretty(wr, value, key_indent);\n-        };\n+    fn emit_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_char('[');\n+        self.indent += 2;\n+        f();\n+        self.indent -= 2;\n+        self.wr.write_char(']');\n+    }\n+\n+    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        f()\n+    }\n \n-        // }\n-        wr.write_str(~\"\\n\");\n-        wr.write_str(spaces(indent));\n-        wr.write_str(~\"}\");\n-      }\n-      Null => wr.write_str(~\"null\")\n+    fn emit_box(&self, f: fn()) { f() }\n+    fn emit_uniq(&self, f: fn()) { f() }\n+    fn emit_rec(&self, f: fn()) {\n+        self.wr.write_char('{');\n+        self.indent += 2;\n+        f();\n+        self.indent -= 2;\n+        self.wr.write_char('}');\n+    }\n+    fn emit_rec_field(&self, name: &str, idx: uint, f: fn()) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_str(\": \");\n+        f();\n+    }\n+    fn emit_tup(&self, sz: uint, f: fn()) {\n+        self.emit_vec(sz, f);\n+    }\n+    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+        self.emit_vec_elt(idx, f)\n     }\n }\n \n-fn escape_str(s: &str) -> ~str {\n-    let mut escaped = ~\"\\\"\";\n-    for str::chars_each(s) |c| {\n-        match c {\n-          '\"' => escaped += ~\"\\\\\\\"\",\n-          '\\\\' => escaped += ~\"\\\\\\\\\",\n-          '\\x08' => escaped += ~\"\\\\b\",\n-          '\\x0c' => escaped += ~\"\\\\f\",\n-          '\\n' => escaped += ~\"\\\\n\",\n-          '\\r' => escaped += ~\"\\\\r\",\n-          '\\t' => escaped += ~\"\\\\t\",\n-          _ => escaped += str::from_char(c)\n+pub fn to_serializer<S: serialization2::Serializer>(ser: &S, json: &Json) {\n+    match *json {\n+        Number(f) => ser.emit_float(f),\n+        String(s) => ser.emit_str(s),\n+        Boolean(b) => ser.emit_bool(b),\n+        List(v) => {\n+            do ser.emit_vec(v.len()) || {\n+                for v.eachi |i, elt| {\n+                    ser.emit_vec_elt(i, || to_serializer(ser, elt))\n+                }\n+            }\n         }\n-    };\n+        Object(o) => {\n+            do ser.emit_rec || {\n+                let mut idx = 0;\n+                for o.each |key, value| {\n+                    do ser.emit_rec_field(*key, idx) {\n+                        to_serializer(ser, value);\n+                    }\n+                    idx += 1;\n+                }\n+            }\n+        }\n+        Null => ser.emit_nil(),\n+    }\n+}\n \n-    escaped += ~\"\\\"\";\n+/// Serializes a json value into a io::writer\n+pub fn to_writer(wr: io::Writer, json: &Json) {\n+    to_serializer(&Serializer(wr), json)\n+}\n \n-    escaped\n+/// Serializes a json value into a string\n+pub fn to_str(json: &Json) -> ~str {\n+    io::with_str_writer(|wr| to_writer(wr, json))\n+}\n+\n+/// Serializes a json value into a io::writer\n+pub fn to_pretty_writer(wr: io::Writer, json: &Json) {\n+    to_serializer(&PrettySerializer(wr), json)\n }\n \n /// Serializes a json value into a string\n-fn to_str(j: Json) -> ~str {\n-    io::with_str_writer(|wr| to_writer(wr, j))\n+pub fn to_pretty_str(json: &Json) -> ~str {\n+    io::with_str_writer(|wr| to_pretty_writer(wr, json))\n }\n \n-/// Serializes a json value into a string, with whitespace and sorting\n-fn to_str_pretty(j: Json) -> ~str {\n-    io::with_str_writer(|wr| to_writer_pretty(wr, j, 0))\n+pub struct Parser {\n+    priv rdr: io::Reader,\n+    priv mut ch: char,\n+    priv mut line: uint,\n+    priv mut col: uint,\n }\n \n-type Parser_ = {\n-    rdr: io::Reader,\n-    mut ch: char,\n-    mut line: uint,\n-    mut col: uint,\n-};\n+/// Deserializes a json value from an io::reader\n+pub fn Parser(rdr: io::Reader) -> Parser {\n+    Parser {\n+        rdr: rdr,\n+        ch: rdr.read_char(),\n+        line: 1u,\n+        col: 1u,\n+    }\n+}\n \n-enum Parser {\n-    Parser_(Parser_)\n+pub impl Parser {\n+    fn parse() -> Result<Json, Error> {\n+        match move self.parse_value() {\n+          Ok(move value) => {\n+            // Skip trailing whitespaces.\n+            self.parse_whitespace();\n+            // Make sure there is no trailing characters.\n+            if self.eof() {\n+                Ok(value)\n+            } else {\n+                self.error(~\"trailing characters\")\n+            }\n+          }\n+          Err(move e) => Err(e)\n+        }\n+    }\n }\n \n-impl Parser {\n+priv impl Parser {\n     fn eof() -> bool { self.ch == -1 as char }\n \n     fn bump() {\n@@ -238,23 +351,7 @@ impl Parser {\n     }\n \n     fn error<T>(+msg: ~str) -> Result<T, Error> {\n-        Err({ line: self.line, col: self.col, msg: @msg })\n-    }\n-\n-    fn parse() -> Result<Json, Error> {\n-        match self.parse_value() {\n-          Ok(value) => {\n-            // Skip trailing whitespaces.\n-            self.parse_whitespace();\n-            // Make sure there is no trailing characters.\n-            if self.eof() {\n-                Ok(value)\n-            } else {\n-                self.error(~\"trailing characters\")\n-            }\n-          }\n-          e => e\n-        }\n+        Err(Error { line: self.line, col: self.col, msg: @msg })\n     }\n \n     fn parse_value() -> Result<Json, Error> {\n@@ -267,10 +364,11 @@ impl Parser {\n           't' => self.parse_ident(~\"rue\", Boolean(true)),\n           'f' => self.parse_ident(~\"alse\", Boolean(false)),\n           '0' .. '9' | '-' => self.parse_number(),\n-          '\"' => match self.parse_str() {\n-            Ok(s) => Ok(String(s)),\n-            Err(e) => Err(e)\n-          },\n+          '\"' =>\n+            match move self.parse_str() {\n+              Ok(move s) => Ok(String(s)),\n+              Err(move e) => Err(e),\n+            },\n           '[' => self.parse_list(),\n           '{' => self.parse_object(),\n           _ => self.error(~\"invalid syntax\")\n@@ -281,10 +379,10 @@ impl Parser {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: ~str, value: Json) -> Result<Json, Error> {\n+    fn parse_ident(ident: ~str, +value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n-            Ok(value)\n+            Ok(move value)\n         } else {\n             self.error(~\"invalid syntax\")\n         }\n@@ -317,7 +415,7 @@ impl Parser {\n             }\n         }\n \n-        Ok(Num(neg * res))\n+        Ok(Number(neg * res))\n     }\n \n     fn parse_integer() -> Result<float, Error> {\n@@ -419,7 +517,7 @@ impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_str() -> Result<@~str, Error> {\n+    fn parse_str() -> Result<~str, Error> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -428,14 +526,14 @@ impl Parser {\n \n             if (escape) {\n                 match self.ch {\n-                  '\"' => str::push_char(&mut res, '\"'),\n-                  '\\\\' => str::push_char(&mut res, '\\\\'),\n-                  '/' => str::push_char(&mut res, '/'),\n-                  'b' => str::push_char(&mut res, '\\x08'),\n-                  'f' => str::push_char(&mut res, '\\x0c'),\n-                  'n' => str::push_char(&mut res, '\\n'),\n-                  'r' => str::push_char(&mut res, '\\r'),\n-                  't' => str::push_char(&mut res, '\\t'),\n+                  '\"' => str::push_char(&res, '\"'),\n+                  '\\\\' => str::push_char(&res, '\\\\'),\n+                  '/' => str::push_char(&res, '/'),\n+                  'b' => str::push_char(&res, '\\x08'),\n+                  'f' => str::push_char(&res, '\\x0c'),\n+                  'n' => str::push_char(&res, '\\n'),\n+                  'r' => str::push_char(&res, '\\r'),\n+                  't' => str::push_char(&res, '\\t'),\n                   'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n@@ -464,7 +562,7 @@ impl Parser {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      str::push_char(&mut res, n as char);\n+                      str::push_char(&res, n as char);\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }\n@@ -474,9 +572,9 @@ impl Parser {\n             } else {\n                 if self.ch == '\"' {\n                     self.bump();\n-                    return Ok(@res);\n+                    return Ok(res);\n                 }\n-                str::push_char(&mut res, self.ch);\n+                str::push_char(&res, self.ch);\n             }\n         }\n \n@@ -491,13 +589,13 @@ impl Parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            return Ok(List(@values));\n+            return Ok(List(values));\n         }\n \n         loop {\n-            match self.parse_value() {\n-              Ok(v) => vec::push(values, v),\n-              e => return e\n+            match move self.parse_value() {\n+              Ok(move v) => vec::push(values, v),\n+              Err(move e) => return Err(e)\n             }\n \n             self.parse_whitespace();\n@@ -507,7 +605,7 @@ impl Parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(@values)); }\n+              ']' => { self.bump(); return Ok(List(values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n@@ -517,11 +615,11 @@ impl Parser {\n         self.bump();\n         self.parse_whitespace();\n \n-        let values = map::HashMap();\n+        let mut values = ~linear::LinearMap();\n \n         if self.ch == '}' {\n           self.bump();\n-          return Ok(Dict(values));\n+          return Ok(Object(values));\n         }\n \n         while !self.eof() {\n@@ -531,9 +629,9 @@ impl Parser {\n                 return self.error(~\"key must be a string\");\n             }\n \n-            let key = match self.parse_str() {\n-              Ok(key) => key,\n-              Err(e) => return Err(e)\n+            let key = match move self.parse_str() {\n+              Ok(move key) => key,\n+              Err(move e) => return Err(e)\n             };\n \n             self.parse_whitespace();\n@@ -544,15 +642,15 @@ impl Parser {\n             }\n             self.bump();\n \n-            match self.parse_value() {\n-              Ok(value) => { values.insert(copy *key, value); }\n-              e => return e\n+            match move self.parse_value() {\n+              Ok(move value) => { values.insert(key, value); }\n+              Err(move e) => return Err(e)\n             }\n             self.parse_whitespace();\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Dict(values)); }\n+              '}' => { self.bump(); return Ok(Object(values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -565,198 +663,382 @@ impl Parser {\n }\n \n /// Deserializes a json value from an io::reader\n-fn from_reader(rdr: io::Reader) -> Result<Json, Error> {\n-    let parser = Parser_({\n-        rdr: rdr,\n-        mut ch: rdr.read_char(),\n-        mut line: 1u,\n-        mut col: 1u,\n-    });\n-\n-    parser.parse()\n+pub fn from_reader(rdr: io::Reader) -> Result<Json, Error> {\n+    Parser(rdr).parse()\n }\n \n /// Deserializes a json value from a string\n-fn from_str(s: &str) -> Result<Json, Error> {\n-    io::with_str_reader(s, from_reader)\n+pub fn from_str(s: &str) -> Result<Json, Error> {\n+    do io::with_str_reader(s) |rdr| {\n+        from_reader(rdr)\n+    }\n }\n \n-/// Test if two json values are equal\n-pure fn eq(value0: Json, value1: Json) -> bool {\n-    match (value0, value1) {\n-      (Num(f0), Num(f1)) => f0 == f1,\n-      (String(s0), String(s1)) => s0 == s1,\n-      (Boolean(b0), Boolean(b1)) => b0 == b1,\n-      (List(l0), List(l1)) => vec::all2(*l0, *l1, eq),\n-      (Dict(d0), Dict(d1)) => {\n-          if d0.size() == d1.size() {\n-              let mut equal = true;\n-              for d0.each |k, v0| {\n-                  match d1.find(k) {\n-                    Some(v1) => if !eq(v0, v1) { equal = false },\n-                    None => equal = false\n-                  }\n-              };\n-              equal\n-          } else {\n-              false\n-          }\n-      }\n-      (Null, Null) => true,\n-      _ => false\n+pub struct Deserializer {\n+    priv json: Json,\n+    priv mut stack: ~[&Json],\n+}\n+\n+pub fn Deserializer(rdr: io::Reader) -> Result<Deserializer, Error> {\n+    match move from_reader(rdr) {\n+        Ok(move json) => {\n+            let des = Deserializer { json: json, stack: ~[] };\n+            Ok(move des)\n+        }\n+        Err(move e) => Err(e)\n     }\n }\n \n-/// Test if two json values are less than one another\n-pure fn lt(value0: Json, value1: Json) -> bool {\n-    match value0 {\n-        Num(f0) => {\n-            match value1 {\n-                Num(f1) => f0 < f1,\n-                String(_) | Boolean(_) | List(_) | Dict(_) | Null => true\n-            }\n+priv impl Deserializer {\n+    fn peek() -> &self/Json {\n+        if self.stack.len() == 0 { vec::push(self.stack, &self.json); }\n+        vec::last(self.stack)\n+    }\n+\n+    fn pop() -> &self/Json {\n+        if self.stack.len() == 0 { vec::push(self.stack, &self.json); }\n+        vec::pop(self.stack)\n+    }\n+}\n+\n+pub impl Deserializer: serialization2::Deserializer {\n+    fn read_nil(&self) -> () {\n+        debug!(\"read_nil\");\n+        match *self.pop() {\n+            Null => (),\n+            _ => fail ~\"not a null\"\n         }\n+    }\n \n-        String(s0) => {\n-            match value1 {\n-                Num(_) => false,\n-                String(s1) => s0 < s1,\n-                Boolean(_) | List(_) | Dict(_) | Null => true\n-            }\n+    fn read_u64(&self)  -> u64  { self.read_float() as u64 }\n+    fn read_u32(&self)  -> u32  { self.read_float() as u32 }\n+    fn read_u16(&self)  -> u16  { self.read_float() as u16 }\n+    fn read_u8 (&self)  -> u8   { self.read_float() as u8 }\n+    fn read_uint(&self) -> uint { self.read_float() as uint }\n+\n+    fn read_i64(&self) -> i64 { self.read_float() as i64 }\n+    fn read_i32(&self) -> i32 { self.read_float() as i32 }\n+    fn read_i16(&self) -> i16 { self.read_float() as i16 }\n+    fn read_i8 (&self) -> i8  { self.read_float() as i8 }\n+    fn read_int(&self) -> int { self.read_float() as int }\n+\n+    fn read_bool(&self) -> bool {\n+        debug!(\"read_bool\");\n+        match *self.pop() {\n+            Boolean(b) => b,\n+            _ => fail ~\"not a boolean\"\n         }\n+    }\n \n-        Boolean(b0) => {\n-            match value1 {\n-                Num(_) | String(_) => false,\n-                Boolean(b1) => b0 < b1,\n-                List(_) | Dict(_) | Null => true\n-            }\n+    fn read_f64(&self) -> f64 { self.read_float() as f64 }\n+    fn read_f32(&self) -> f32 { self.read_float() as f32 }\n+    fn read_float(&self) -> float {\n+        debug!(\"read_float\");\n+        match *self.pop() {\n+            Number(f) => f,\n+            _ => fail ~\"not a number\"\n+        }\n+    }\n+\n+    fn read_str(&self) -> ~str {\n+        debug!(\"read_str\");\n+        match *self.pop() {\n+            String(ref s) => copy *s,\n+            _ => fail ~\"not a string\"\n         }\n+    }\n+\n+    fn read_enum<T>(&self, name: ~str, f: fn() -> T) -> T {\n+        debug!(\"read_enum(%s)\", name);\n+        if name != ~\"option\" { fail ~\"only supports the option enum\" }\n+        f()\n+    }\n+\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_enum_variant()\");\n+        let idx = match *self.peek() {\n+            Null => 0,\n+            _ => 1,\n+        };\n+        f(idx)\n+    }\n+\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+        if idx != 0 { fail ~\"unknown index\" }\n+        f()\n+    }\n \n-        List(l0) => {\n-            match value1 {\n-                Num(_) | String(_) | Boolean(_) => false,\n-                List(l1) => l0 < l1,\n-                Dict(_) | Null => true\n+    fn read_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_vec()\");\n+        let len = match *self.peek() {\n+            List(list) => list.len(),\n+            _ => fail ~\"not a list\",\n+        };\n+        let res = f(len);\n+        self.pop();\n+        res\n+    }\n+\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_vec_elt(idx=%u)\", idx);\n+        match *self.peek() {\n+            List(ref list) => {\n+                vec::push(self.stack, &list[idx]);\n+                f()\n             }\n+            _ => fail ~\"not a list\",\n         }\n+    }\n \n-        Dict(d0) => {\n-            match value1 {\n-                Num(_) | String(_) | Boolean(_) | List(_) => false,\n-                Dict(d1) => {\n-                    unsafe {\n-                        let (d0_flat, d1_flat) = {\n-                            let d0_flat = dvec::DVec();\n-                            for d0.each |k, v| { d0_flat.push((k, v)); }\n-                            let mut d0_flat = dvec::unwrap(move d0_flat);\n-                            d0_flat.qsort();\n+    fn read_box<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_box()\");\n+        f()\n+    }\n \n-                            let mut d1_flat = dvec::DVec();\n-                            for d1.each |k, v| { d1_flat.push((k, v)); }\n-                            let mut d1_flat = dvec::unwrap(move d1_flat);\n-                            d1_flat.qsort();\n+    fn read_uniq<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_uniq()\");\n+        f()\n+    }\n \n-                            (move d0_flat, move d1_flat)\n-                        };\n+    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_rec()\");\n+        let value = f();\n+        self.pop();\n+        value\n+    }\n \n-                        d0_flat < d1_flat\n+    fn read_rec_field<T>(&self, f_name: ~str, f_idx: uint,\n+                         f: fn() -> T) -> T {\n+        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n+        let top = self.peek();\n+        match *top {\n+            Object(ref obj) => {\n+                // FIXME(#3148) This hint should not be necessary.\n+                let obj: &self/~Object = obj;\n+\n+                match obj.find_ref(&f_name) {\n+                    None => fail fmt!(\"no such field: %s\", f_name),\n+                    Some(json) => {\n+                        vec::push(self.stack, json);\n+                        f()\n                     }\n                 }\n-                Null => true\n             }\n-        }\n+            Number(_) => fail ~\"num\",\n+            String(_) => fail ~\"str\",\n+            Boolean(_) => fail ~\"bool\",\n+            List(_) => fail fmt!(\"list: %?\", top),\n+            Null => fail ~\"null\",\n \n-        Null => {\n-            match value1 {\n-                Num(_) | String(_) | Boolean(_) | List(_) | Dict(_) => false,\n-                Null => true\n-            }\n+            //_ => fail fmt!(\"not an object: %?\", *top)\n         }\n     }\n-}\n \n-impl Error : Eq {\n-    pure fn eq(other: &Error) -> bool {\n-        self.line == (*other).line &&\n-        self.col == (*other).col &&\n-        self.msg == (*other).msg\n+    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup(sz=%u)\", sz);\n+        let value = f();\n+        self.pop();\n+        value\n+    }\n+\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup_elt(idx=%u)\", idx);\n+        match *self.peek() {\n+            List(list) => {\n+                vec::push(self.stack, &list[idx]);\n+                f()\n+            }\n+            _ => fail ~\"not a list\"\n+        }\n     }\n-    pure fn ne(other: &Error) -> bool { !self.eq(other) }\n }\n \n impl Json : Eq {\n-    pure fn eq(other: &Json) -> bool { eq(self, (*other)) }\n+    pure fn eq(other: &Json) -> bool {\n+        // XXX: This is ugly because matching on references is broken, and\n+        // we can't match on dereferenced tuples without a copy.\n+        match self {\n+            Number(f0) =>\n+                match *other { Number(f1) => f0 == f1, _ => false },\n+            String(s0) =>\n+                match *other { String(s1) => s0 == s1, _ => false },\n+            Boolean(b0) =>\n+                match *other { Boolean(b1) => b0 == b1, _ => false },\n+            Null =>\n+                match *other { Null => true, _ => false },\n+            List(v0) =>\n+                match *other { List(v1) => v0 == v1, _ => false },\n+            Object(ref d0) => {\n+                match *other {\n+                    Object(ref d1) => {\n+                        if d0.len() == d1.len() {\n+                            let mut equal = true;\n+                            for d0.each |k, v0| {\n+                                match d1.find_ref(k) {\n+                                    Some(v1) if v0 == v1 => { },\n+                                    _ => { equal = false; break }\n+                                }\n+                            };\n+                            equal\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n     pure fn ne(other: &Json) -> bool { !self.eq(other) }\n }\n \n+/// Test if two json values are less than one another\n impl Json : Ord {\n-    pure fn lt(other: &Json) -> bool { lt(self, (*other))  }\n+    pure fn lt(other: &Json) -> bool {\n+        match self {\n+            Number(f0) => {\n+                match *other {\n+                    Number(f1) => f0 < f1,\n+                    String(_) | Boolean(_) | List(_) | Object(_) |\n+                    Null => true\n+                }\n+            }\n+\n+            String(s0) => {\n+                match *other {\n+                    Number(_) => false,\n+                    String(s1) => s0 < s1,\n+                    Boolean(_) | List(_) | Object(_) | Null => true\n+                }\n+            }\n+\n+            Boolean(b0) => {\n+                match *other {\n+                    Number(_) | String(_) => false,\n+                    Boolean(b1) => b0 < b1,\n+                    List(_) | Object(_) | Null => true\n+                }\n+            }\n+\n+            List(l0) => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) => false,\n+                    List(l1) => l0 < l1,\n+                    Object(_) | Null => true\n+                }\n+            }\n+\n+            Object(d0) => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n+                    Object(d1) => {\n+                        unsafe {\n+                            let mut d0_flat = ~[];\n+                            let mut d1_flat = ~[];\n+\n+                            // XXX: this is horribly inefficient...\n+                            for d0.each |k, v| {\n+                                 vec::push(d0_flat, (@copy *k, @copy *v));\n+                            }\n+                            d0_flat.qsort();\n+\n+                            for d1.each |k, v| {\n+                                vec::push(d1_flat, (@copy *k, @copy *v));\n+                            }\n+                            d1_flat.qsort();\n+\n+                            d0_flat < d1_flat\n+                        }\n+                    }\n+                    Null => true\n+                }\n+            }\n+\n+            Null => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) | List(_) |\n+                    Object(_) =>\n+                        false,\n+                    Null => true\n+                }\n+            }\n+        }\n+    }\n     pure fn le(other: &Json) -> bool { !(*other).lt(&self) }\n-    pure fn ge(other: &Json) -> bool { !self.lt(other)     }\n+    pure fn ge(other: &Json) -> bool { !self.lt(other) }\n     pure fn gt(other: &Json) -> bool { (*other).lt(&self)  }\n }\n \n+impl Error : Eq {\n+    pure fn eq(other: &Error) -> bool {\n+        self.line == other.line &&\n+        self.col == other.col &&\n+        self.msg == other.msg\n+    }\n+    pure fn ne(other: &Error) -> bool { !self.eq(other) }\n+}\n+\n trait ToJson { fn to_json() -> Json; }\n \n impl Json: ToJson {\n-    fn to_json() -> Json { self }\n+    fn to_json() -> Json { copy self }\n }\n \n impl @Json: ToJson {\n-    fn to_json() -> Json { *self }\n+    fn to_json() -> Json { (*self).to_json() }\n }\n \n impl int: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl i8: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl i16: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl i32: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl i64: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl uint: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl u8: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl u16: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl u32: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl u64: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl float: ToJson {\n-    fn to_json() -> Json { Num(self) }\n+    fn to_json() -> Json { Number(self) }\n }\n \n impl f32: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl f64: ToJson {\n-    fn to_json() -> Json { Num(self as float) }\n+    fn to_json() -> Json { Number(self as float) }\n }\n \n impl (): ToJson {\n@@ -768,47 +1050,58 @@ impl bool: ToJson {\n }\n \n impl ~str: ToJson {\n-    fn to_json() -> Json { String(@copy self) }\n+    fn to_json() -> Json { String(copy self) }\n }\n \n impl @~str: ToJson {\n-    fn to_json() -> Json { String(self) }\n+    fn to_json() -> Json { String(copy *self) }\n }\n \n impl <A: ToJson, B: ToJson> (A, B): ToJson {\n     fn to_json() -> Json {\n         match self {\n           (a, b) => {\n-            List(@~[a.to_json(), b.to_json()])\n+            List(~[a.to_json(), b.to_json()])\n           }\n         }\n     }\n }\n \n impl <A: ToJson, B: ToJson, C: ToJson> (A, B, C): ToJson {\n-\n     fn to_json() -> Json {\n         match self {\n           (a, b, c) => {\n-            List(@~[a.to_json(), b.to_json(), c.to_json()])\n+            List(~[a.to_json(), b.to_json(), c.to_json()])\n           }\n         }\n     }\n }\n \n impl <A: ToJson> ~[A]: ToJson {\n-    fn to_json() -> Json { List(@self.map(|elt| elt.to_json())) }\n+    fn to_json() -> Json { List(self.map(|elt| elt.to_json())) }\n }\n \n-impl <A: ToJson Copy> HashMap<~str, A>: ToJson {\n+impl <A: ToJson Copy> linear::LinearMap<~str, A>: ToJson {\n     fn to_json() -> Json {\n-        let d = map::HashMap();\n+        let mut d = linear::LinearMap();\n         for self.each() |key, value| {\n-            d.insert(copy key, value.to_json());\n+            d.insert(copy *key, value.to_json());\n+        }\n+        Object(~d)\n+    }\n+}\n+\n+/*\n+impl <A: ToJson Copy> @std::map::HashMap<~str, A>: ToJson {\n+    fn to_json() -> Json {\n+        let mut d = linear::LinearMap();\n+        for self.each_ref |key, value| {\n+            d.insert(copy *key, value.to_json());\n         }\n-        Dict(d)\n+        Object(~d)\n     }\n }\n+*/\n \n impl <A: ToJson> Option<A>: ToJson {\n     fn to_json() -> Json {\n@@ -820,7 +1113,7 @@ impl <A: ToJson> Option<A>: ToJson {\n }\n \n impl Json: to_str::ToStr {\n-    fn to_str() -> ~str { to_str(self) }\n+    fn to_str() -> ~str { to_str(&self) }\n }\n \n impl Error: to_str::ToStr {\n@@ -831,105 +1124,104 @@ impl Error: to_str::ToStr {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-    fn mk_dict(items: &[(~str, Json)]) -> Json {\n-        let d = map::HashMap();\n+    fn mk_object(items: &[(~str, Json)]) -> Json {\n+        let mut d = ~linear::LinearMap();\n \n-        for vec::each(items) |item| {\n-            let (key, value) = copy *item;\n-            d.insert(key, value);\n+        for items.each |item| {\n+            match *item {\n+                (key, value) => { d.insert(copy key, copy value); },\n+            }\n         };\n \n-        Dict(d)\n+        Object(d)\n     }\n \n     #[test]\n     fn test_write_null() {\n-        assert to_str(Null) == ~\"null\";\n+        assert to_str(&Null) == ~\"null\";\n     }\n \n     #[test]\n-    fn test_write_num() {\n-        assert to_str(Num(3f)) == ~\"3\";\n-        assert to_str(Num(3.1f)) == ~\"3.1\";\n-        assert to_str(Num(-1.5f)) == ~\"-1.5\";\n-        assert to_str(Num(0.5f)) == ~\"0.5\";\n+    fn test_write_number() {\n+        assert to_str(&Number(3f)) == ~\"3\";\n+        assert to_str(&Number(3.1f)) == ~\"3.1\";\n+        assert to_str(&Number(-1.5f)) == ~\"-1.5\";\n+        assert to_str(&Number(0.5f)) == ~\"0.5\";\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(String(@~\"\")) == ~\"\\\"\\\"\";\n-        assert to_str(String(@~\"foo\")) == ~\"\\\"foo\\\"\";\n+        assert to_str(&String(~\"\")) == ~\"\\\"\\\"\";\n+        assert to_str(&String(~\"foo\")) == ~\"\\\"foo\\\"\";\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert to_str(Boolean(true)) == ~\"true\";\n-        assert to_str(Boolean(false)) == ~\"false\";\n+        assert to_str(&Boolean(true)) == ~\"true\";\n+        assert to_str(&Boolean(false)) == ~\"false\";\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(List(@~[])) == ~\"[]\";\n-        assert to_str(List(@~[Boolean(true)])) == ~\"[true]\";\n-        assert to_str(List(@~[\n+        assert to_str(&List(~[])) == ~\"[]\";\n+        assert to_str(&List(~[Boolean(true)])) == ~\"[true]\";\n+        assert to_str(&List(~[\n             Boolean(false),\n             Null,\n-            List(@~[String(@~\"foo\\nbar\"), Num(3.5f)])\n-        ])) == ~\"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n+            List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n+        ])) == ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\";\n     }\n \n     #[test]\n-    fn test_write_dict() {\n-        assert to_str(mk_dict(~[])) == ~\"{}\";\n-        assert to_str(mk_dict(~[(~\"a\", Boolean(true))]))\n-            == ~\"{ \\\"a\\\": true }\";\n-        let a = mk_dict(~[\n+    fn test_write_object() {\n+        assert to_str(&mk_object(~[])) == ~\"{}\";\n+        assert to_str(&mk_object(~[(~\"a\", Boolean(true))]))\n+            == ~\"{\\\"a\\\":true}\";\n+        let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n-            (~\"b\", List(@~[\n-                mk_dict(~[(~\"c\", String(@~\"\\x0c\\r\"))]),\n-                mk_dict(~[(~\"d\", String(@~\"\"))])\n+            (~\"b\", List(~[\n+                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n+                mk_object(~[(~\"d\", String(~\"\"))])\n             ]))\n         ]);\n-        let astr = to_str(a);\n-        let b = result::get(&from_str(astr));\n-        let bstr = to_str(b);\n-        assert astr == bstr;\n+        // We can't compare the strings directly because the object fields be\n+        // printed in a different order.\n+        let b = result::unwrap(from_str(to_str(&a)));\n         assert a == b;\n     }\n \n     #[test]\n     fn test_trailing_characters() {\n         assert from_str(~\"nulla\") ==\n-            Err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n+            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"});\n         assert from_str(~\"truea\") ==\n-            Err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n+            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"});\n         assert from_str(~\"falsea\") ==\n-            Err({line: 1u, col: 6u, msg: @~\"trailing characters\"});\n+            Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"});\n         assert from_str(~\"1a\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"trailing characters\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"});\n         assert from_str(~\"[]a\") ==\n-            Err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"});\n         assert from_str(~\"{}a\") ==\n-            Err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"});\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert from_str(~\"n\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"nul\") ==\n-            Err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"t\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"truz\") ==\n-            Err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"f\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"faz\") ==\n-            Err({line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"null\") == Ok(Null);\n         assert from_str(~\"true\") == Ok(Boolean(true));\n@@ -940,148 +1232,148 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_read_num() {\n+    fn test_read_number() {\n         assert from_str(~\"+\") ==\n-            Err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n         assert from_str(~\".\") ==\n-            Err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n \n         assert from_str(~\"-\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"});\n         assert from_str(~\"00\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"});\n         assert from_str(~\"1.\") ==\n-            Err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"});\n         assert from_str(~\"1e\") ==\n-            Err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"});\n         assert from_str(~\"1e+\") ==\n-            Err({line: 1u, col: 4u, msg: @~\"invalid number\"});\n-\n-        assert from_str(~\"3\") == Ok(Num(3f));\n-        assert from_str(~\"3.1\") == Ok(Num(3.1f));\n-        assert from_str(~\"-1.2\") == Ok(Num(-1.2f));\n-        assert from_str(~\"0.4\") == Ok(Num(0.4f));\n-        assert from_str(~\"0.4e5\") == Ok(Num(0.4e5f));\n-        assert from_str(~\"0.4e+15\") == Ok(Num(0.4e15f));\n-        assert from_str(~\"0.4e-01\") == Ok(Num(0.4e-01f));\n-        assert from_str(~\" 3 \") == Ok(Num(3f));\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"});\n+\n+        assert from_str(~\"3\") == Ok(Number(3f));\n+        assert from_str(~\"3.1\") == Ok(Number(3.1f));\n+        assert from_str(~\"-1.2\") == Ok(Number(-1.2f));\n+        assert from_str(~\"0.4\") == Ok(Number(0.4f));\n+        assert from_str(~\"0.4e5\") == Ok(Number(0.4e5f));\n+        assert from_str(~\"0.4e+15\") == Ok(Number(0.4e15f));\n+        assert from_str(~\"0.4e-01\") == Ok(Number(0.4e-01f));\n+        assert from_str(~\" 3 \") == Ok(Number(3f));\n     }\n \n     #[test]\n     fn test_read_str() {\n         assert from_str(~\"\\\"\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n         assert from_str(~\"\\\"lol\") ==\n-            Err({line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n-\n-        assert from_str(~\"\\\"\\\"\") == Ok(String(@~\"\"));\n-        assert from_str(~\"\\\"foo\\\"\") == Ok(String(@~\"foo\"));\n-        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(@~\"\\\"\"));\n-        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(String(@~\"\\x08\"));\n-        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(String(@~\"\\n\"));\n-        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(String(@~\"\\r\"));\n-        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(String(@~\"\\t\"));\n-        assert from_str(~\" \\\"foo\\\" \") == Ok(String(@~\"foo\"));\n+            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n+\n+        assert from_str(~\"\\\"\\\"\") == Ok(String(~\"\"));\n+        assert from_str(~\"\\\"foo\\\"\") == Ok(String(~\"foo\"));\n+        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(~\"\\\"\"));\n+        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(String(~\"\\x08\"));\n+        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(String(~\"\\n\"));\n+        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(String(~\"\\r\"));\n+        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(String(~\"\\t\"));\n+        assert from_str(~\" \\\"foo\\\" \") == Ok(String(~\"foo\"));\n     }\n \n     #[test]\n     fn test_unicode_hex_escapes_in_str() {\n-        assert from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(@~\"\\u12ab\"));\n-        assert from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(@~\"\\uAB12\"));\n+        assert from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(~\"\\u12ab\"));\n+        assert from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(~\"\\uAB12\"));\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert from_str(~\"[\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n         assert from_str(~\"[1\") ==\n-            Err({line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n         assert from_str(~\"[1,\") ==\n-            Err({line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n+            Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n         assert from_str(~\"[1,]\") ==\n-            Err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n         assert from_str(~\"[6 7]\") ==\n-            Err({line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n-\n-        assert from_str(~\"[]\") == Ok(List(@~[]));\n-        assert from_str(~\"[ ]\") == Ok(List(@~[]));\n-        assert from_str(~\"[true]\") == Ok(List(@~[Boolean(true)]));\n-        assert from_str(~\"[ false ]\") == Ok(List(@~[Boolean(false)]));\n-        assert from_str(~\"[null]\") == Ok(List(@~[Null]));\n-        assert from_str(~\"[3, 1]\") == Ok(List(@~[Num(3f), Num(1f)]));\n-        assert from_str(~\"\\n[3, 2]\\n\") == Ok(List(@~[Num(3f), Num(2f)]));\n+            Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n+\n+        assert from_str(~\"[]\") == Ok(List(~[]));\n+        assert from_str(~\"[ ]\") == Ok(List(~[]));\n+        assert from_str(~\"[true]\") == Ok(List(~[Boolean(true)]));\n+        assert from_str(~\"[ false ]\") == Ok(List(~[Boolean(false)]));\n+        assert from_str(~\"[null]\") == Ok(List(~[Null]));\n+        assert from_str(~\"[3, 1]\") == Ok(List(~[Number(3f), Number(1f)]));\n+        assert from_str(~\"\\n[3, 2]\\n\") == Ok(List(~[Number(3f), Number(2f)]));\n         assert from_str(~\"[2, [4, 1]]\") ==\n-               Ok(List(@~[Num(2f), List(@~[Num(4f), Num(1f)])]));\n+               Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])]));\n     }\n \n     #[test]\n-    fn test_read_dict() {\n+    fn test_read_object() {\n         assert from_str(~\"{\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{ \") ==\n-            Err({line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{1\") ==\n-            Err({line: 1u, col: 2u, msg: @~\"key must be a string\"});\n+            Err(Error {line: 1u, col: 2u, msg: @~\"key must be a string\"});\n         assert from_str(~\"{ \\\"a\\\"\") ==\n-            Err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{\\\"a\\\"\") ==\n-            Err({line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{\\\"a\\\" \") ==\n-            Err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n \n         assert from_str(~\"{\\\"a\\\" 1\") ==\n-            Err({line: 1u, col: 6u, msg: @~\"expected `:`\"});\n+            Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"});\n         assert from_str(~\"{\\\"a\\\":\") ==\n-            Err({line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n+            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n         assert from_str(~\"{\\\"a\\\":1\") ==\n-            Err({line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n         assert from_str(~\"{\\\"a\\\":1 1\") ==\n-            Err({line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n+            Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n         assert from_str(~\"{\\\"a\\\":1,\") ==\n-            Err({line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n \n-        assert eq(result::get(&from_str(~\"{}\")), mk_dict(~[]));\n-        assert eq(result::get(&from_str(~\"{\\\"a\\\": 3}\")),\n-                  mk_dict(~[(~\"a\", Num(3.0f))]));\n+        assert result::unwrap(from_str(~\"{}\")) == mk_object(~[]);\n+        assert result::unwrap(from_str(~\"{\\\"a\\\": 3}\")) ==\n+                  mk_object(~[(~\"a\", Number(3.0f))]);\n \n-        assert eq(result::get(&from_str(~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n-                  mk_dict(~[\n+        assert result::unwrap(from_str(~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")) ==\n+                  mk_object(~[\n                       (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]));\n-        assert eq(result::get(&from_str(\n-                  ~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n-                  mk_dict(~[\n+                      (~\"b\", Boolean(true))]);\n+        assert result::unwrap(\n+                      from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")) ==\n+                  mk_object(~[\n                       (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]));\n-        assert eq(result::get(&from_str(~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n-                  mk_dict(~[\n-                      (~\"a\", Num(1.0)),\n-                      (~\"b\", List(@~[Boolean(true)]))\n-                  ]));\n-        assert eq(result::get(&from_str(\n+                      (~\"b\", Boolean(true))]);\n+        assert result::unwrap(from_str(~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")) ==\n+                  mk_object(~[\n+                      (~\"a\", Number(1.0)),\n+                      (~\"b\", List(~[Boolean(true)]))\n+                  ]);\n+        assert result::unwrap(from_str(\n                       ~\"{\" +\n                           ~\"\\\"a\\\": 1.0, \" +\n                           ~\"\\\"b\\\": [\" +\n                               ~\"true,\" +\n                               ~\"\\\"foo\\\\nbar\\\", \" +\n                               ~\"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n                           ~\"]\" +\n-                      ~\"}\")),\n-                  mk_dict(~[\n-                      (~\"a\", Num(1.0f)),\n-                      (~\"b\", List(@~[\n+                      ~\"}\")) ==\n+                  mk_object(~[\n+                      (~\"a\", Number(1.0f)),\n+                      (~\"b\", List(~[\n                           Boolean(true),\n-                          String(@~\"foo\\nbar\"),\n-                          mk_dict(~[\n-                              (~\"c\", mk_dict(~[(~\"d\", Null)]))\n+                          String(~\"foo\\nbar\"),\n+                          mk_object(~[\n+                              (~\"c\", mk_object(~[(~\"d\", Null)]))\n                           ])\n                       ]))\n-                  ]));\n+                  ]);\n     }\n \n     #[test]\n     fn test_multiline_errors() {\n         assert from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            Err({line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n+            Err(Error {line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n     }\n }"}, {"sha": "7ef4ef225604e4bcb5bc42c60d15e576d45cef4e", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49d00b2f22576e7043a27f444804f563100212fe/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d00b2f22576e7043a27f444804f563100212fe/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=49d00b2f22576e7043a27f444804f563100212fe", "patch": "@@ -1,20 +1,21 @@\n extern mod std;\n use io::WriterUtil;\n use std::map::HashMap;\n+use std::json;\n \n enum object\n {\n     bool_value(bool),\n     int_value(i64),\n }\n \n-fn lookup(table: std::map::HashMap<~str, std::json::Json>, key: ~str, default: ~str) -> ~str\n+fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n {\n-    match table.find(key)\n+    match table.find(&key)\n     {\n         option::Some(std::json::String(s)) =>\n         {\n-            *s\n+            s\n         }\n         option::Some(value) =>\n         {\n@@ -32,7 +33,7 @@ fn add_interface(store: int, managed_ip: ~str, data: std::json::Json) -> (~str,\n {\n     match data\n     {\n-        std::json::Dict(interface) =>\n+        std::json::Object(interface) =>\n         {\n             let name = lookup(interface, ~\"ifDescr\", ~\"\");\n             let label = fmt!(\"%s-%s\", managed_ip, name);\n@@ -53,7 +54,7 @@ fn add_interfaces(store: int, managed_ip: ~str, device: std::map::HashMap<~str,\n     {\n         std::json::List(interfaces) =>\n         {\n-          do vec::map(*interfaces) |interface| {\n+          do vec::map(interfaces) |interface| {\n                 add_interface(store, managed_ip, *interface)\n           }\n         }"}]}