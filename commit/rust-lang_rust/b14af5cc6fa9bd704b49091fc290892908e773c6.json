{"sha": "b14af5cc6fa9bd704b49091fc290892908e773c6", "node_id": "C_kwDOAAsO6NoAKGIxNGFmNWNjNmZhOWJkNzA0YjQ5MDkxZmMyOTA4OTI5MDhlNzczYzY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-03T16:00:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-03T16:00:05Z"}, "message": "Merge #11115\n\n11115: internal: refactor: avoid separate traversal in replace filter map next with find map r=Veykril a=rainy-me\n\nfix: #7428\n\nCo-authored-by: rainy-me <github@yue.coffee>", "tree": {"sha": "a74c11a4aa10b5c0307a91e0fcf9a8178f063e97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a74c11a4aa10b5c0307a91e0fcf9a8178f063e97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b14af5cc6fa9bd704b49091fc290892908e773c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh0x2FCRBK7hj4Ov3rIwAAjEIIAICo0sJRiGryM+98eNpj2yDc\nt8K8CXJGZNbqHjaeKd1dN2yaFjTtq6b4lwk3NWnJo0QR1Wr58Lgx3soSawey5Yum\n1YAdWMEf/SSz9Z1OnSXa2EbUyaFGcnyjjsvtnVPOm2NkRQh15u2T/fNwaeULGgE8\nVKEfwp/uGbEb2PGda4h3vgxjC4GW0uM6za2TZkL5JDcH4F4G4M2+vRaWK79aAsxn\n/Jj6scx9X/iOog74KNW/F7jBTsx8Z0eEfqATitBqTsiv9a6UFflB4LxZGJ8RXnmh\nfNJWWS6w5UDHWPy+ptcLH156V5bKzyOrjIp0uvc/xYoNdUo98qlj0gnJ75g0V6A=\n=5OxU\n-----END PGP SIGNATURE-----\n", "payload": "tree a74c11a4aa10b5c0307a91e0fcf9a8178f063e97\nparent 1ba9a924d7b161c52e605e157ee16d582e4a8684\nparent d77d3234ce861106cbf66738aafa4fafc6bf7db6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641225605 +0000\ncommitter GitHub <noreply@github.com> 1641225605 +0000\n\nMerge #11115\n\n11115: internal: refactor: avoid separate traversal in replace filter map next with find map r=Veykril a=rainy-me\n\nfix: #7428\n\nCo-authored-by: rainy-me <github@yue.coffee>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b14af5cc6fa9bd704b49091fc290892908e773c6", "html_url": "https://github.com/rust-lang/rust/commit/b14af5cc6fa9bd704b49091fc290892908e773c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b14af5cc6fa9bd704b49091fc290892908e773c6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba9a924d7b161c52e605e157ee16d582e4a8684", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba9a924d7b161c52e605e157ee16d582e4a8684", "html_url": "https://github.com/rust-lang/rust/commit/1ba9a924d7b161c52e605e157ee16d582e4a8684"}, {"sha": "d77d3234ce861106cbf66738aafa4fafc6bf7db6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77d3234ce861106cbf66738aafa4fafc6bf7db6", "html_url": "https://github.com/rust-lang/rust/commit/d77d3234ce861106cbf66738aafa4fafc6bf7db6"}], "stats": {"total": 143, "additions": 84, "deletions": 59}, "files": [{"sha": "b7d765c59b47d85d0fb536ad78456acc484e95d6", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b14af5cc6fa9bd704b49091fc290892908e773c6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14af5cc6fa9bd704b49091fc290892908e773c6/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=b14af5cc6fa9bd704b49091fc290892908e773c6", "patch": "@@ -81,9 +81,8 @@ impl ExprValidator {\n     }\n \n     fn validate_body(&mut self, db: &dyn HirDatabase) {\n-        self.check_for_filter_map_next(db);\n-\n         let body = db.body(self.owner);\n+        let mut filter_map_next_checker = None;\n \n         for (id, expr) in body.exprs.iter() {\n             if let Some((variant, missed_fields, true)) =\n@@ -101,7 +100,7 @@ impl ExprValidator {\n                     self.validate_match(id, *expr, arms, db, self.infer.clone());\n                 }\n                 Expr::Call { .. } | Expr::MethodCall { .. } => {\n-                    self.validate_call(db, id, expr);\n+                    self.validate_call(db, id, expr, &mut filter_map_next_checker);\n                 }\n                 _ => {}\n             }\n@@ -143,58 +142,13 @@ impl ExprValidator {\n             });\n     }\n \n-    fn check_for_filter_map_next(&mut self, db: &dyn HirDatabase) {\n-        // Find the FunctionIds for Iterator::filter_map and Iterator::next\n-        let iterator_path = path![core::iter::Iterator];\n-        let resolver = self.owner.resolver(db.upcast());\n-        let iterator_trait_id = match resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n-        let filter_map_function_id =\n-            match iterator_trait_items.iter().find(|item| item.0 == name![filter_map]) {\n-                Some((_, AssocItemId::FunctionId(id))) => id,\n-                _ => return,\n-            };\n-        let next_function_id = match iterator_trait_items.iter().find(|item| item.0 == name![next])\n-        {\n-            Some((_, AssocItemId::FunctionId(id))) => id,\n-            _ => return,\n-        };\n-\n-        // Search function body for instances of .filter_map(..).next()\n-        let body = db.body(self.owner);\n-        let mut prev = None;\n-        for (id, expr) in body.exprs.iter() {\n-            if let Expr::MethodCall { receiver, .. } = expr {\n-                let function_id = match self.infer.method_resolution(id) {\n-                    Some((id, _)) => id,\n-                    None => continue,\n-                };\n-\n-                if function_id == *filter_map_function_id {\n-                    prev = Some(id);\n-                    continue;\n-                }\n-\n-                if function_id == *next_function_id {\n-                    if let Some(filter_map_id) = prev {\n-                        if *receiver == filter_map_id {\n-                            self.diagnostics.push(\n-                                BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap {\n-                                    method_call_expr: id,\n-                                },\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-            prev = None;\n-        }\n-    }\n-\n-    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) {\n+    fn validate_call(\n+        &mut self,\n+        db: &dyn HirDatabase,\n+        call_id: ExprId,\n+        expr: &Expr,\n+        filter_map_next_checker: &mut Option<FilterMapNextChecker>,\n+    ) {\n         // Check that the number of arguments matches the number of parameters.\n \n         // FIXME: Due to shortcomings in the current type system implementation, only emit this\n@@ -214,6 +168,24 @@ impl ExprValidator {\n                 (sig, args.len())\n             }\n             Expr::MethodCall { receiver, args, .. } => {\n+                let (callee, subst) = match self.infer.method_resolution(call_id) {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+\n+                if filter_map_next_checker\n+                    .get_or_insert_with(|| {\n+                        FilterMapNextChecker::new(&self.owner.resolver(db.upcast()), db)\n+                    })\n+                    .check(call_id, receiver, &callee)\n+                    .is_some()\n+                {\n+                    self.diagnostics.push(\n+                        BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap {\n+                            method_call_expr: call_id,\n+                        },\n+                    );\n+                }\n                 let receiver = &self.infer.type_of_expr[*receiver];\n                 if receiver.strip_references().is_unknown() {\n                     // if the receiver is of unknown type, it's very likely we\n@@ -222,10 +194,6 @@ impl ExprValidator {\n                     return;\n                 }\n \n-                let (callee, subst) = match self.infer.method_resolution(call_id) {\n-                    Some(it) => it,\n-                    None => return,\n-                };\n                 let sig = db.callable_item_signature(callee.into()).substitute(Interner, &subst);\n \n                 (sig, args.len() + 1)\n@@ -424,6 +392,63 @@ impl ExprValidator {\n     }\n }\n \n+struct FilterMapNextChecker {\n+    filter_map_function_id: Option<hir_def::FunctionId>,\n+    next_function_id: Option<hir_def::FunctionId>,\n+    prev_filter_map_expr_id: Option<ExprId>,\n+}\n+\n+impl FilterMapNextChecker {\n+    fn new(resolver: &hir_def::resolver::Resolver, db: &dyn HirDatabase) -> Self {\n+        // Find and store the FunctionIds for Iterator::filter_map and Iterator::next\n+        let iterator_path = path![core::iter::Iterator];\n+        let mut filter_map_function_id = None;\n+        let mut next_function_id = None;\n+\n+        if let Some(iterator_trait_id) = resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n+            let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n+            for item in iterator_trait_items.iter() {\n+                if let (name, AssocItemId::FunctionId(id)) = item {\n+                    if *name == name![filter_map] {\n+                        filter_map_function_id = Some(*id);\n+                    }\n+                    if *name == name![next] {\n+                        next_function_id = Some(*id);\n+                    }\n+                }\n+                if filter_map_function_id.is_some() && next_function_id.is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+        Self { filter_map_function_id, next_function_id, prev_filter_map_expr_id: None }\n+    }\n+\n+    // check for instances of .filter_map(..).next()\n+    fn check(\n+        &mut self,\n+        current_expr_id: ExprId,\n+        receiver_expr_id: &ExprId,\n+        function_id: &hir_def::FunctionId,\n+    ) -> Option<()> {\n+        if *function_id == self.filter_map_function_id? {\n+            self.prev_filter_map_expr_id = Some(current_expr_id);\n+            return None;\n+        }\n+\n+        if *function_id == self.next_function_id? {\n+            if let Some(prev_filter_map_expr_id) = self.prev_filter_map_expr_id {\n+                if *receiver_expr_id == prev_filter_map_expr_id {\n+                    return Some(());\n+                }\n+            }\n+        }\n+\n+        self.prev_filter_map_expr_id = None;\n+        None\n+    }\n+}\n+\n pub fn record_literal_missing_fields(\n     db: &dyn HirDatabase,\n     infer: &InferenceResult,"}]}