{"sha": "ff4075e553ccc5be73c05332f15ef46f761b0817", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNDA3NWU1NTNjY2M1YmU3M2MwNTMzMmYxNWVmNDZmNzYxYjA4MTc=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-11-21T07:33:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-25T20:41:11Z"}, "message": "Add improvements to insert_with_key\n\nThis commit adds a lower-level implementation of the generic\n`insert_with_key` which I expect to be faster. Now insert could be\ndefined with insert_with_key, too, although I'm not sure we want to do that.\n\nThis also clarifies the tests a bit and adds an `insert_with` function.", "tree": {"sha": "3a7348d2a0afc36b0799a4d42f8d15f834d55ffa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a7348d2a0afc36b0799a4d42f8d15f834d55ffa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff4075e553ccc5be73c05332f15ef46f761b0817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4075e553ccc5be73c05332f15ef46f761b0817", "html_url": "https://github.com/rust-lang/rust/commit/ff4075e553ccc5be73c05332f15ef46f761b0817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff4075e553ccc5be73c05332f15ef46f761b0817/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b13ef7d501daea5f56605659ae1f1e38371ab32", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b13ef7d501daea5f56605659ae1f1e38371ab32", "html_url": "https://github.com/rust-lang/rust/commit/7b13ef7d501daea5f56605659ae1f1e38371ab32"}], "stats": {"total": 151, "additions": 132, "deletions": 19}, "files": [{"sha": "730b5275e1d7950c40b9b21bea7853804568f332", "filename": "src/libstd/map.rs", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=ff4075e553ccc5be73c05332f15ef46f761b0817", "patch": "@@ -35,7 +35,16 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n      * If the map contains a value for the key, use the function\n      * to set a new value.\n      */\n-    fn insert_with_key(ff: fn(K, V, V) -> V, key: K, value: V) -> bool;\n+    fn insert_with_key(key: K, newval: V, ff: fn(K, V, V) -> V) -> bool;\n+\n+    /**\n+     * Add a value to the map.\n+     *\n+     * If the map contains a value for the key, use the function\n+     * to set a new value.  (Like insert_with_key, but with a function\n+     * of only values.)\n+     */\n+    fn insert_with(key: K, newval: V, ff: fn(V, V) -> V) -> bool;\n \n     /// Returns true if the map contains a value for the specified key\n     pure fn contains_key(key: K) -> bool;\n@@ -272,12 +281,57 @@ pub mod chained {\n             }\n         }\n \n-        fn insert_with_key(ff: fn(K, V, V) -> V, key: K, val: V) -> bool {\n-            // this can be optimized but first lets see if it compiles...\n+        fn insert_with_key(key: K, newval: V, ff: fn(K, V, V) -> V) -> bool {\n+/*\n             match self.find(key) {\n                 None            => return self.insert(key, val),\n                 Some(copy orig) => return self.insert(key, ff(key, orig, val))\n             }\n+*/\n+\n+            let hash = key.hash_keyed(0,0) as uint;\n+            match self.search_tbl(&key, hash) {\n+              NotFound => {\n+                self.count += 1u;\n+                let idx = hash % vec::len(self.chains);\n+                let old_chain = self.chains[idx];\n+                self.chains[idx] = Some(@Entry {\n+                    hash: hash,\n+                    key: key,\n+                    value: newval,\n+                    next: old_chain});\n+\n+                // consider rehashing if more 3/4 full\n+                let nchains = vec::len(self.chains);\n+                let load = {num: (self.count + 1u) as int,\n+                            den: nchains as int};\n+                if !util::rational_leq(load, {num:3, den:4}) {\n+                    self.rehash();\n+                }\n+\n+                return true;\n+              }\n+              FoundFirst(idx, entry) => {\n+                self.chains[idx] = Some(@Entry {\n+                    hash: hash,\n+                    key: key,\n+                    value: ff(key, entry.value, newval),\n+                    next: entry.next});\n+                return false;\n+              }\n+              FoundAfter(prev, entry) => {\n+                prev.next = Some(@Entry {\n+                    hash: hash,\n+                    key: key,\n+                    value: ff(key, entry.value, newval),\n+                    next: entry.next});\n+                return false;\n+              }\n+            }\n+        }\n+\n+        fn insert_with(key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n+            return self.insert_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n         pure fn get(k: K) -> V {\n@@ -463,12 +517,16 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n         }\n     }\n \n-     fn insert_with_key(ff: fn(K, V, V) -> V, key: K, val: V) -> bool {\n-         match self.find(key) {\n-             None            => return self.insert(key, val),\n-             Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n-         }\n-     }\n+    fn insert_with_key(key: K, newval: V, ff: fn(K, V, V) -> V) -> bool {\n+        match self.find(key) {\n+            None            => return self.insert(key, newval),\n+            Some(copy orig) => return self.insert(key, ff(key, orig, newval))\n+        }\n+    }\n+\n+    fn insert_with(key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n+        return self.insert_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    }\n \n     fn remove(key: K) -> bool {\n         do self.borrow_mut |p| {\n@@ -778,20 +836,30 @@ mod tests {\n     fn test_insert_with_key() {\n         let map = map::HashMap::<~str, uint>();\n \n-        fn inc(k: ~str, v0: uint, v1: uint) -> uint {\n+        // given a new key, initialize it with this new count, given\n+        // given an existing key, add more to its count\n+        fn addMoreToCount(_k: ~str, v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n             v0 + v1\n         }\n \n-        map.insert_with_key(inc, ~\"cat\", 1);\n-        map.insert_with_key(inc, ~\"mongoose\", 1);\n-        map.insert_with_key(inc, ~\"cat\", 7);\n-        map.insert_with_key(inc, ~\"ferret\", 3);\n-        map.insert_with_key(inc, ~\"cat\", 2);\n+        // count the number of several types of animal,\n+        // adding in groups as we go\n+        map.insert_with(~\"cat\",      1, addMoreToCount_simple);\n+        map.insert_with_key(~\"mongoose\", 1, addMoreToCount);\n+        map.insert_with(~\"cat\",      7, addMoreToCount_simple);\n+        map.insert_with_key(~\"ferret\",   3, addMoreToCount);\n+        map.insert_with_key(~\"cat\",      2, addMoreToCount);\n \n+        // check the total counts\n         assert 10 == option::get(map.find(~\"cat\"));\n         assert  3 == option::get(map.find(~\"ferret\"));\n         assert  1 == option::get(map.find(~\"mongoose\"));\n \n+        // sadly, no mythical animals were counted!\n         assert None == map.find(~\"unicorn\");\n     }\n }"}, {"sha": "2fdfa3deea85694d1ad29f74dbcb60cd62d9c593", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=ff4075e553ccc5be73c05332f15ef46f761b0817", "patch": "@@ -103,13 +103,17 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n     pure fn find(key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n \n-    fn insert_with_key(ff: fn(uint, V, V) -> V, key: uint, val: V) -> bool {\n+    fn insert_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n         match self.find(key) {\n             None            => return self.insert(key, val),\n             Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n         }\n     }\n \n+    fn insert_with(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        return self.insert_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    }\n+\n     pure fn each(it: fn(key: uint, value: V) -> bool) {\n         self.each_ref(|k, v| it(*k, *v))\n     }\n@@ -149,3 +153,37 @@ impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n pub fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::Map<uint, V> {\n     s as map::Map::<uint, V>\n }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_insert_with_key() {\n+        let map: SmallIntMap<uint> = mk();\n+\n+        // given a new key, initialize it with this new count, given\n+        // given an existing key, add more to its count\n+        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        // count integers\n+        map.insert_with(3, 1, addMoreToCount_simple);\n+        map.insert_with_key(9, 1, addMoreToCount);\n+        map.insert_with(3, 7, addMoreToCount_simple);\n+        map.insert_with_key(5, 3, addMoreToCount);\n+        map.insert_with_key(3, 2, addMoreToCount);\n+\n+        // check the total counts\n+        assert 10 == option::get(map.find(3));\n+        assert  3 == option::get(map.find(5));\n+        assert  1 == option::get(map.find(9));\n+\n+        // sadly, no sevens were counted\n+        assert None == map.find(7);\n+    }\n+}"}, {"sha": "8030ca2672175ae8dfeaf858f4f095cf36d9cf18", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ff4075e553ccc5be73c05332f15ef46f761b0817", "patch": "@@ -69,7 +69,7 @@ fn find(mm: HashMap<~[u8], uint>, key: ~str) -> uint {\n // given a map, increment the counter for a key\n fn update_freq(mm: HashMap<~[u8], uint>, key: &[u8]) {\n     let key = vec::slice(key, 0, key.len());\n-    mm.insert_with_key(|k,v,v1| {v + v1}, key, 1);\n+    mm.insert_with(key, 1, |v,v1| { v+v1 });\n }\n \n // given a ~[u8], for each window call a function"}, {"sha": "8efe3c7575fb76bd9569f093ce6116f219b11a39", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=ff4075e553ccc5be73c05332f15ef46f761b0817", "patch": "@@ -66,7 +66,7 @@ fn find(mm: HashMap<~[u8], uint>, key: ~str) -> uint {\n // given a map, increment the counter for a key\n fn update_freq(mm: HashMap<~[u8], uint>, key: &[u8]) {\n     let key = vec::slice(key, 0, key.len());\n-    mm.insert_with_key(|k,v,v1| {v + v1}, key, 1);\n+    mm.insert_with(key, 1, |v,v1| { v+v1 });\n }\n \n // given a ~[u8], for each window call a function"}, {"sha": "ad7be9d86da797d97d23af0bd87603e53f85bd08", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff4075e553ccc5be73c05332f15ef46f761b0817/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=ff4075e553ccc5be73c05332f15ef46f761b0817", "patch": "@@ -61,13 +61,20 @@ impl<T: Copy> cat<T> : Map<int, T> {\n      else { None }\n   }\n \n-  fn insert_with_key(ff: fn(+k: int, +v0: T, +v1: T) -> T, +key: int, +val: T) -> bool {\n+  fn insert_with_key(+key: int, +val: T, ff: fn(+k: int, +v0: T, +v1: T) -> T) -> bool {\n     match self.find(key) {\n       None            => return self.insert(key, val),\n       Some(copy orig) => return self.insert(key, ff(key, orig, val))\n     }\n   }\n \n+  fn insert_with(+key: int, +val: T, ff: fn(+v0: T, +v1: T) -> T) -> bool {\n+    match self.find(key) {\n+      None            => return self.insert(key, val),\n+      Some(copy orig) => return self.insert(key, ff(orig, val))\n+    }\n+  }\n+\n \n   fn remove(+k:int) -> bool {\n     match self.find(k) {"}]}