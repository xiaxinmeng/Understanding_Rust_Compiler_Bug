{"sha": "e220d3d5079eaabf485d8966e1eb3bb90d181c23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMjBkM2Q1MDc5ZWFhYmY0ODVkODk2NmUxZWIzYmI5MGQxODFjMjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-22T12:25:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-22T12:25:53Z"}, "message": "Merge #8139\n\n8139: Align `Canonical` and `InEnvironment` with the Chalk versions r=flodiebold a=flodiebold\n\n\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "8b0164f450467187821da7c5b2f1974e6a17cc72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b0164f450467187821da7c5b2f1974e6a17cc72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e220d3d5079eaabf485d8966e1eb3bb90d181c23", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgWIzRCRBK7hj4Ov3rIwAAdHIIACgHWE0mjqNto1360ukOmLmA\nGJ24gPzDjBO/z2L/COcBlHvJen6xSTGWA3PpQT2J2hWnsrb4ELEK5NlhiqDeeFQf\nNPPcAJwhITl2dIzs3+ts5DXBfxm8digaz6K9nVFtHaRNNBbYQki+RJnGpP0Fws1S\nSLQim04bAsMlAnQi3hWpT7+gpkIVwhk2nuEw/vueezm4rNP3JrrbskJ1OAOxarrt\nQqP+dxbjgSgvo2bGAew9vFFyYh4Osoo2Ux1f/2z+4Us60y+Di4rByXg6+S9VNJGJ\nvIDFsZHbzqdf81rymGUVFqR8XlN+ynjgZdICulNU9s11nUXbLZNspW/+NeBYOCo=\n=a+uy\n-----END PGP SIGNATURE-----\n", "payload": "tree 8b0164f450467187821da7c5b2f1974e6a17cc72\nparent 6f1f91cdcfc03e2a49cc66b76caff645f8b33d42\nparent c4fd3f47f5b4f34476f8f085f2412a46aa0fd24f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616415953 +0000\ncommitter GitHub <noreply@github.com> 1616415953 +0000\n\nMerge #8139\n\n8139: Align `Canonical` and `InEnvironment` with the Chalk versions r=flodiebold a=flodiebold\n\n\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e220d3d5079eaabf485d8966e1eb3bb90d181c23", "html_url": "https://github.com/rust-lang/rust/commit/e220d3d5079eaabf485d8966e1eb3bb90d181c23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e220d3d5079eaabf485d8966e1eb3bb90d181c23/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42", "html_url": "https://github.com/rust-lang/rust/commit/6f1f91cdcfc03e2a49cc66b76caff645f8b33d42"}, {"sha": "c4fd3f47f5b4f34476f8f085f2412a46aa0fd24f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4fd3f47f5b4f34476f8f085f2412a46aa0fd24f", "html_url": "https://github.com/rust-lang/rust/commit/c4fd3f47f5b4f34476f8f085f2412a46aa0fd24f"}], "stats": {"total": 373, "additions": 194, "deletions": 179}, "files": [{"sha": "97a78ca2521ce5aec83876d9060621e9e69cad9d", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -217,7 +217,7 @@ impl HirDisplay for Variant {\n \n impl HirDisplay for Type {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        self.ty.value.hir_fmt(f)\n+        self.ty.hir_fmt(f)\n     }\n }\n "}, {"sha": "30b96d7e2ed7c62676e9de340dfa85a28ac3031a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 62, "deletions": 69, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -56,9 +56,9 @@ use hir_ty::{\n     primitive::UintTy,\n     to_assoc_type_id,\n     traits::{FnTrait, Solution, SolutionVariables},\n-    AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, Cast, DebruijnIndex,\n-    InEnvironment, Interner, ProjectionTy, QuantifiedWhereClause, Scalar, Substitution, Ty,\n-    TyDefId, TyKind, TyVariableKind, WhereClause,\n+    AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n+    DebruijnIndex, InEnvironment, Interner, ProjectionTy, QuantifiedWhereClause, Scalar,\n+    Substitution, TraitEnvironment, Ty, TyDefId, TyKind, TyVariableKind, WhereClause,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -851,13 +851,7 @@ impl Function {\n             .iter()\n             .enumerate()\n             .map(|(idx, type_ref)| {\n-                let ty = Type {\n-                    krate,\n-                    ty: InEnvironment {\n-                        value: ctx.lower_ty(type_ref),\n-                        environment: environment.clone(),\n-                    },\n-                };\n+                let ty = Type { krate, env: environment.clone(), ty: ctx.lower_ty(type_ref) };\n                 Param { func: self, ty, idx }\n             })\n             .collect()\n@@ -1540,23 +1534,23 @@ impl Impl {\n         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n     }\n \n-    pub fn all_for_type(db: &dyn HirDatabase, Type { krate, ty }: Type) -> Vec<Impl> {\n-        let def_crates = match ty.value.def_crates(db, krate) {\n+    pub fn all_for_type(db: &dyn HirDatabase, Type { krate, ty, .. }: Type) -> Vec<Impl> {\n+        let def_crates = match ty.def_crates(db, krate) {\n             Some(def_crates) => def_crates,\n             None => return Vec::new(),\n         };\n \n         let filter = |impl_def: &Impl| {\n             let target_ty = impl_def.target_ty(db);\n             let rref = target_ty.remove_ref();\n-            ty.value.equals_ctor(rref.as_ref().map_or(&target_ty.ty.value, |it| &it.ty.value))\n+            ty.equals_ctor(rref.as_ref().map_or(&target_ty.ty, |it| &it.ty))\n         };\n \n         let mut all = Vec::new();\n         def_crates.iter().for_each(|&id| {\n             all.extend(db.inherent_impls_in_crate(id).all_impls().map(Self::from).filter(filter))\n         });\n-        let fp = TyFingerprint::for_impl(&ty.value);\n+        let fp = TyFingerprint::for_impl(&ty);\n         for id in def_crates\n             .iter()\n             .flat_map(|&id| Crate { id }.transitive_reverse_dependencies(db))\n@@ -1643,7 +1637,8 @@ impl Impl {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Type {\n     krate: CrateId,\n-    ty: InEnvironment<Ty>,\n+    env: Arc<TraitEnvironment>,\n+    ty: Ty,\n }\n \n impl Type {\n@@ -1663,14 +1658,14 @@ impl Type {\n     ) -> Type {\n         let environment =\n             resolver.generic_def().map_or_else(Default::default, |d| db.trait_environment(d));\n-        Type { krate, ty: InEnvironment { value: ty, environment } }\n+        Type { krate, env: environment, ty }\n     }\n \n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db.upcast());\n         let environment =\n             resolver.generic_def().map_or_else(Default::default, |d| db.trait_environment(d));\n-        Type { krate, ty: InEnvironment { value: ty, environment } }\n+        Type { krate, env: environment, ty }\n     }\n \n     fn from_def(\n@@ -1684,29 +1679,29 @@ impl Type {\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        matches!(self.ty.value.interned(&Interner), TyKind::Tuple(0, ..))\n+        matches!(self.ty.interned(&Interner), TyKind::Tuple(0, ..))\n     }\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.value.interned(&Interner), TyKind::Scalar(Scalar::Bool))\n+        matches!(self.ty.interned(&Interner), TyKind::Scalar(Scalar::Bool))\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {\n-        matches!(self.ty.value.interned(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n+        matches!(self.ty.interned(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n     }\n \n     pub fn is_usize(&self) -> bool {\n-        matches!(self.ty.value.interned(&Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n+        matches!(self.ty.interned(&Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n     }\n \n     pub fn remove_ref(&self) -> Option<Type> {\n-        match &self.ty.value.interned(&Interner) {\n+        match &self.ty.interned(&Interner) {\n             TyKind::Ref(.., ty) => Some(self.derived(ty.clone())),\n             _ => None,\n         }\n     }\n \n     pub fn is_unknown(&self) -> bool {\n-        self.ty.value.is_unknown()\n+        self.ty.is_unknown()\n     }\n \n     /// Checks that particular type `ty` implements `std::future::Future`.\n@@ -1723,11 +1718,12 @@ impl Type {\n             None => return false,\n         };\n \n-        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical_ty =\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n         method_resolution::implements_trait(\n             &canonical_ty,\n             db,\n-            self.ty.environment.clone(),\n+            self.env.clone(),\n             krate,\n             std_future_trait,\n         )\n@@ -1745,11 +1741,12 @@ impl Type {\n             None => return false,\n         };\n \n-        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical_ty =\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n         method_resolution::implements_trait_unique(\n             &canonical_ty,\n             db,\n-            self.ty.environment.clone(),\n+            self.env.clone(),\n             krate,\n             fnonce_trait,\n         )\n@@ -1759,17 +1756,14 @@ impl Type {\n         let trait_ref = hir_ty::TraitRef {\n             trait_id: hir_ty::to_chalk_trait_id(trait_.id),\n             substitution: Substitution::build_for_def(db, trait_.id)\n-                .push(self.ty.value.clone())\n-                .fill(args.iter().map(|t| t.ty.value.clone()))\n+                .push(self.ty.clone())\n+                .fill(args.iter().map(|t| t.ty.clone()))\n                 .build(),\n         };\n \n         let goal = Canonical {\n-            value: hir_ty::InEnvironment::new(\n-                self.ty.environment.clone(),\n-                trait_ref.cast(&Interner),\n-            ),\n-            kinds: Arc::new([]),\n+            value: hir_ty::InEnvironment::new(self.env.env.clone(), trait_ref.cast(&Interner)),\n+            binders: CanonicalVarKinds::empty(&Interner),\n         };\n \n         db.trait_solve(self.krate, goal).is_some()\n@@ -1783,12 +1777,12 @@ impl Type {\n         alias: TypeAlias,\n     ) -> Option<Type> {\n         let subst = Substitution::build_for_def(db, trait_.id)\n-            .push(self.ty.value.clone())\n-            .fill(args.iter().map(|t| t.ty.value.clone()))\n+            .push(self.ty.clone())\n+            .fill(args.iter().map(|t| t.ty.clone()))\n             .build();\n-        let goal = Canonical {\n-            value: InEnvironment::new(\n-                self.ty.environment.clone(),\n+        let goal = Canonical::new(\n+            InEnvironment::new(\n+                self.env.env.clone(),\n                 AliasEq {\n                     alias: AliasTy::Projection(ProjectionTy {\n                         associated_ty_id: to_assoc_type_id(alias.id),\n@@ -1799,8 +1793,8 @@ impl Type {\n                 }\n                 .cast(&Interner),\n             ),\n-            kinds: Arc::new([TyVariableKind::General]),\n-        };\n+            [TyVariableKind::General].iter().copied(),\n+        );\n \n         match db.trait_solve(self.krate, goal)? {\n             Solution::Unique(SolutionVariables(subst)) => {\n@@ -1820,22 +1814,22 @@ impl Type {\n     }\n \n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n-        let def = self.ty.value.callable_def(db);\n+        let def = self.ty.callable_def(db);\n \n-        let sig = self.ty.value.callable_sig(db)?;\n+        let sig = self.ty.callable_sig(db)?;\n         Some(Callable { ty: self.clone(), sig, def, is_bound_method: false })\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.value.interned(&Interner), TyKind::Closure { .. })\n+        matches!(&self.ty.interned(&Interner), TyKind::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.value.interned(&Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n+        matches!(&self.ty.interned(&Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n-        let adt_id = match self.ty.value.interned(&Interner) {\n+        let adt_id = match self.ty.interned(&Interner) {\n             &TyKind::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n             _ => return false,\n         };\n@@ -1848,11 +1842,11 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.value.interned(&Interner), TyKind::Raw(..))\n+        matches!(&self.ty.interned(&Interner), TyKind::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n-        return go(&self.ty.value);\n+        return go(&self.ty);\n \n         fn go(ty: &Ty) -> bool {\n             match ty.interned(&Interner) {\n@@ -1884,7 +1878,7 @@ impl Type {\n     }\n \n     pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n-        let (variant_id, substs) = match self.ty.value.interned(&Interner) {\n+        let (variant_id, substs) = match self.ty.interned(&Interner) {\n             &TyKind::Adt(hir_ty::AdtId(AdtId::StructId(s)), ref substs) => (s.into(), substs),\n             &TyKind::Adt(hir_ty::AdtId(AdtId::UnionId(u)), ref substs) => (u.into(), substs),\n             _ => return Vec::new(),\n@@ -1901,7 +1895,7 @@ impl Type {\n     }\n \n     pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n-        if let TyKind::Tuple(_, substs) = &self.ty.value.interned(&Interner) {\n+        if let TyKind::Tuple(_, substs) = &self.ty.interned(&Interner) {\n             substs.iter().map(|ty| self.derived(ty.clone())).collect()\n         } else {\n             Vec::new()\n@@ -1911,9 +1905,10 @@ impl Type {\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n-        let environment = self.ty.environment.clone();\n-        let ty = InEnvironment { value: canonical, environment };\n+        let canonical =\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n+        let environment = self.env.env.clone();\n+        let ty = InEnvironment { goal: canonical, environment };\n         autoderef(db, Some(self.krate), ty)\n             .map(|canonical| canonical.value)\n             .map(move |ty| self.derived(ty))\n@@ -1927,10 +1922,10 @@ impl Type {\n         krate: Crate,\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n-        for krate in self.ty.value.def_crates(db, krate.id)? {\n+        for krate in self.ty.def_crates(db, krate.id)? {\n             let impls = db.inherent_impls_in_crate(krate);\n \n-            for impl_def in impls.for_self_ty(&self.ty.value) {\n+            for impl_def in impls.for_self_ty(&self.ty) {\n                 for &item in db.impl_data(*impl_def).items.iter() {\n                     if let Some(result) = callback(item.into()) {\n                         return Some(result);\n@@ -1943,7 +1938,6 @@ impl Type {\n \n     pub fn type_parameters(&self) -> impl Iterator<Item = Type> + '_ {\n         self.ty\n-            .value\n             .strip_references()\n             .substs()\n             .into_iter()\n@@ -1962,9 +1956,10 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical =\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n \n-        let env = self.ty.environment.clone();\n+        let env = self.env.clone();\n         let krate = krate.id;\n \n         method_resolution::iterate_method_candidates(\n@@ -1993,9 +1988,10 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical =\n+            Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(&Interner) };\n \n-        let env = self.ty.environment.clone();\n+        let env = self.env.clone();\n         let krate = krate.id;\n \n         method_resolution::iterate_method_candidates(\n@@ -2011,16 +2007,16 @@ impl Type {\n     }\n \n     pub fn as_adt(&self) -> Option<Adt> {\n-        let (adt, _subst) = self.ty.value.as_adt()?;\n+        let (adt, _subst) = self.ty.as_adt()?;\n         Some(adt.into())\n     }\n \n     pub fn as_dyn_trait(&self) -> Option<Trait> {\n-        self.ty.value.dyn_trait().map(Into::into)\n+        self.ty.dyn_trait().map(Into::into)\n     }\n \n     pub fn as_impl_traits(&self, db: &dyn HirDatabase) -> Option<Vec<Trait>> {\n-        self.ty.value.impl_trait_bounds(db).map(|it| {\n+        self.ty.impl_trait_bounds(db).map(|it| {\n             it.into_iter()\n                 .filter_map(|pred| match pred.skip_binders() {\n                     hir_ty::WhereClause::Implemented(trait_ref) => {\n@@ -2033,14 +2029,11 @@ impl Type {\n     }\n \n     pub fn as_associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n-        self.ty.value.associated_type_parent_trait(db).map(Into::into)\n+        self.ty.associated_type_parent_trait(db).map(Into::into)\n     }\n \n     fn derived(&self, ty: Ty) -> Type {\n-        Type {\n-            krate: self.krate,\n-            ty: InEnvironment { value: ty, environment: self.ty.environment.clone() },\n-        }\n+        Type { krate: self.krate, env: self.env.clone(), ty }\n     }\n \n     pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n@@ -2079,7 +2072,7 @@ impl Type {\n         }\n \n         fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n-            let ty = type_.ty.value.strip_references();\n+            let ty = type_.ty.strip_references();\n             match ty.interned(&Interner) {\n                 TyKind::Adt(..) => {\n                     cb(type_.derived(ty.clone()));"}, {"sha": "dc5fc759a29fe459bcfc7a457279ad05126f17a1", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -16,8 +16,8 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::{InEnvironment, Solution},\n     utils::generics,\n-    AliasEq, AliasTy, BoundVar, Canonical, DebruijnIndex, Interner, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyKind,\n+    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, Interner,\n+    ProjectionTy, Substitution, TraitRef, Ty, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -27,9 +27,9 @@ pub fn autoderef<'a>(\n     krate: Option<CrateId>,\n     ty: InEnvironment<Canonical<Ty>>,\n ) -> impl Iterator<Item = Canonical<Ty>> + 'a {\n-    let InEnvironment { value: ty, environment } = ty;\n+    let InEnvironment { goal: ty, environment } = ty;\n     successors(Some(ty), move |ty| {\n-        deref(db, krate?, InEnvironment { value: ty, environment: environment.clone() })\n+        deref(db, krate?, InEnvironment { goal: ty, environment: environment.clone() })\n     })\n     .take(AUTODEREF_RECURSION_LIMIT)\n }\n@@ -39,8 +39,8 @@ pub(crate) fn deref(\n     krate: CrateId,\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n-    if let Some(derefed) = ty.value.value.builtin_deref() {\n-        Some(Canonical { value: derefed, kinds: ty.value.kinds.clone() })\n+    if let Some(derefed) = ty.goal.value.builtin_deref() {\n+        Some(Canonical { value: derefed, binders: ty.goal.binders.clone() })\n     } else {\n         deref_by_trait(db, krate, ty)\n     }\n@@ -67,15 +67,15 @@ fn deref_by_trait(\n     // FIXME make the Canonical / bound var handling nicer\n \n     let parameters =\n-        Substitution::build_for_generics(&generic_params).push(ty.value.value.clone()).build();\n+        Substitution::build_for_generics(&generic_params).push(ty.goal.value.clone()).build();\n \n     // Check that the type implements Deref at all\n     let trait_ref =\n         TraitRef { trait_id: to_chalk_trait_id(deref_trait), substitution: parameters.clone() };\n     let implements_goal = Canonical {\n-        kinds: ty.value.kinds.clone(),\n+        binders: ty.goal.binders.clone(),\n         value: InEnvironment {\n-            value: trait_ref.cast(&Interner),\n+            goal: trait_ref.cast(&Interner),\n             environment: ty.environment.clone(),\n         },\n     };\n@@ -89,18 +89,27 @@ fn deref_by_trait(\n             associated_ty_id: to_assoc_type_id(target),\n             substitution: parameters,\n         }),\n-        ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len()))\n-            .intern(&Interner),\n+        ty: TyKind::BoundVar(BoundVar::new(\n+            DebruijnIndex::INNERMOST,\n+            ty.goal.binders.len(&Interner),\n+        ))\n+        .intern(&Interner),\n     };\n \n     let obligation = projection.cast(&Interner);\n \n-    let in_env = InEnvironment { value: obligation, environment: ty.environment };\n-\n-    let canonical = Canonical::new(\n-        in_env,\n-        ty.value.kinds.iter().copied().chain(Some(chalk_ir::TyVariableKind::General)),\n-    );\n+    let in_env = InEnvironment { goal: obligation, environment: ty.environment };\n+\n+    let canonical = Canonical {\n+        value: in_env,\n+        binders: CanonicalVarKinds::from_iter(\n+            &Interner,\n+            ty.goal.binders.iter(&Interner).cloned().chain(Some(chalk_ir::WithKind::new(\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+                chalk_ir::UniverseIndex::ROOT,\n+            ))),\n+        ),\n+    };\n \n     let solution = db.trait_solve(krate, canonical)?;\n \n@@ -121,21 +130,21 @@ fn deref_by_trait(\n             // assumptions will be broken. We would need to properly introduce\n             // new variables in that case\n \n-            for i in 1..vars.0.kinds.len() {\n+            for i in 1..vars.0.binders.len(&Interner) {\n                 if vars.0.value[i - 1].interned(&Interner)\n                     != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n-                    warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.value, solution);\n+                    warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.goal, solution);\n                     return None;\n                 }\n             }\n             Some(Canonical {\n                 value: vars.0.value[vars.0.value.len() - 1].clone(),\n-                kinds: vars.0.kinds.clone(),\n+                binders: vars.0.binders.clone(),\n             })\n         }\n         Solution::Ambig(_) => {\n-            info!(\"Ambiguous solution for derefing {:?}: {:?}\", ty.value, solution);\n+            info!(\"Ambiguous solution for derefing {:?}: {:?}\", ty.goal, solution);\n             None\n         }\n     }"}, {"sha": "8f9cf74808f93a41b047e1e469ccd5fbd338a41d", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -331,7 +331,7 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_obligations_as_possible(&mut self) {\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n-            let in_env = InEnvironment::new(self.trait_env.clone(), obligation.clone());\n+            let in_env = InEnvironment::new(self.trait_env.env.clone(), obligation.clone());\n             let canonicalized = self.canonicalizer().canonicalize_obligation(in_env);\n             let solution =\n                 self.db.trait_solve(self.resolver.krate().unwrap(), canonicalized.value.clone());"}, {"sha": "9c62932b12f3ca726079d9a6cf7a9970c10a2fea", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -142,7 +142,7 @@ impl<'a> InferenceContext<'a> {\n             .build();\n         let trait_ref =\n             TraitRef { trait_id: to_chalk_trait_id(coerce_unsized_trait), substitution: substs };\n-        let goal = InEnvironment::new(self.trait_env.clone(), trait_ref.cast(&Interner));\n+        let goal = InEnvironment::new(self.trait_env.env.clone(), trait_ref.cast(&Interner));\n \n         let canonicalizer = self.canonicalizer();\n         let canonicalized = canonicalizer.canonicalize_obligation(goal);\n@@ -170,8 +170,8 @@ impl<'a> InferenceContext<'a> {\n             self.db,\n             self.resolver.krate(),\n             InEnvironment {\n-                value: canonicalized.value.clone(),\n-                environment: self.trait_env.clone(),\n+                goal: canonicalized.value.clone(),\n+                environment: self.trait_env.env.clone(),\n             },\n         ) {\n             let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);"}, {"sha": "19249973c9d31915c137a03ea75d16fc465dae5e", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -90,12 +90,12 @@ impl<'a> InferenceContext<'a> {\n         let substs =\n             Substitution::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n \n-        let trait_env = Arc::clone(&self.trait_env);\n+        let trait_env = self.trait_env.env.clone();\n         let implements_fn_trait: DomainGoal =\n             TraitRef { trait_id: to_chalk_trait_id(fn_once_trait), substitution: substs.clone() }\n                 .cast(&Interner);\n         let goal = self.canonicalizer().canonicalize_obligation(InEnvironment {\n-            value: implements_fn_trait.clone(),\n+            goal: implements_fn_trait.clone(),\n             environment: trait_env,\n         });\n         if self.db.trait_solve(krate, goal.value).is_some() {\n@@ -299,8 +299,8 @@ impl<'a> InferenceContext<'a> {\n                     self.db,\n                     self.resolver.krate(),\n                     InEnvironment {\n-                        value: canonicalized.value.clone(),\n-                        environment: self.trait_env.clone(),\n+                        goal: canonicalized.value.clone(),\n+                        environment: self.trait_env.env.clone(),\n                     },\n                 );\n                 let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs\n@@ -438,8 +438,8 @@ impl<'a> InferenceContext<'a> {\n                     self.db,\n                     self.resolver.krate(),\n                     InEnvironment {\n-                        value: canonicalized.value.clone(),\n-                        environment: self.trait_env.clone(),\n+                        goal: canonicalized.value.clone(),\n+                        environment: self.trait_env.env.clone(),\n                     },\n                 )\n                 .find_map(|derefed_ty| {\n@@ -538,8 +538,8 @@ impl<'a> InferenceContext<'a> {\n                                 self.db,\n                                 krate,\n                                 InEnvironment {\n-                                    value: &canonicalized.value,\n-                                    environment: self.trait_env.clone(),\n+                                    goal: &canonicalized.value,\n+                                    environment: self.trait_env.env.clone(),\n                                 },\n                             ) {\n                                 Some(derefed_ty) => {"}, {"sha": "75250a3694c65f3bb8fa0a732261f541417ab21d", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -2,13 +2,13 @@\n \n use std::borrow::Cow;\n \n-use chalk_ir::{FloatTy, IntTy, TyVariableKind};\n+use chalk_ir::{FloatTy, IntTy, TyVariableKind, UniverseIndex, VariableKind};\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use super::{DomainGoal, InferenceContext};\n use crate::{\n-    AliasEq, AliasTy, BoundVar, Canonical, DebruijnIndex, FnPointer, InEnvironment, InferenceVar,\n-    Interner, Scalar, Substitution, Ty, TyKind, TypeWalk, WhereClause,\n+    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer,\n+    InEnvironment, InferenceVar, Interner, Scalar, Substitution, Ty, TyKind, TypeWalk, WhereClause,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -76,8 +76,17 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n-        let kinds = self.free_vars.iter().map(|&(_, k)| k).collect();\n-        Canonicalized { value: Canonical { value: result, kinds }, free_vars: self.free_vars }\n+        let kinds = self\n+            .free_vars\n+            .iter()\n+            .map(|&(_, k)| chalk_ir::WithKind::new(VariableKind::Ty(k), UniverseIndex::ROOT));\n+        Canonicalized {\n+            value: Canonical {\n+                value: result,\n+                binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+            },\n+            free_vars: self.free_vars,\n+        }\n     }\n \n     pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n@@ -89,15 +98,12 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n         mut self,\n         obligation: InEnvironment<DomainGoal>,\n     ) -> Canonicalized<InEnvironment<DomainGoal>> {\n-        let result = match obligation.value {\n+        let result = match obligation.goal {\n             DomainGoal::Holds(wc) => {\n                 DomainGoal::Holds(self.do_canonicalize(wc, DebruijnIndex::INNERMOST))\n             }\n         };\n-        self.into_canonicalized(InEnvironment {\n-            value: result,\n-            environment: obligation.environment,\n-        })\n+        self.into_canonicalized(InEnvironment { goal: result, environment: obligation.environment })\n     }\n }\n \n@@ -125,12 +131,19 @@ impl<T> Canonicalized<T> {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substitution(\n             solution\n-                .kinds\n-                .iter()\n-                .map(|k| match k {\n-                    TyVariableKind::General => ctx.table.new_type_var(),\n-                    TyVariableKind::Integer => ctx.table.new_integer_var(),\n-                    TyVariableKind::Float => ctx.table.new_float_var(),\n+                .binders\n+                .iter(&Interner)\n+                .map(|k| match k.kind {\n+                    VariableKind::Ty(TyVariableKind::General) => ctx.table.new_type_var(),\n+                    VariableKind::Ty(TyVariableKind::Integer) => ctx.table.new_integer_var(),\n+                    VariableKind::Ty(TyVariableKind::Float) => ctx.table.new_float_var(),\n+                    // HACK: Chalk can sometimes return new lifetime variables. We\n+                    // want to just skip them, but to not mess up the indices of\n+                    // other variables, we'll just create a new type variable in\n+                    // their place instead. This should not matter (we never see the\n+                    // actual *uses* of the lifetime variable).\n+                    VariableKind::Lifetime => ctx.table.new_type_var(),\n+                    _ => panic!(\"const variable in solution\"),\n                 })\n                 .collect(),\n         );\n@@ -147,8 +160,8 @@ impl<T> Canonicalized<T> {\n pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     let mut table = InferenceTable::new();\n     let vars = Substitution(\n-        tys.kinds\n-            .iter()\n+        tys.binders\n+            .iter(&Interner)\n             // we always use type vars here because we want everything to\n             // fallback to Unknown in the end (kind of hacky, as below)\n             .map(|_| table.new_type_var())\n@@ -170,7 +183,7 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n         }\n     }\n     Some(\n-        Substitution::builder(tys.kinds.len())\n+        Substitution::builder(tys.binders.len(&Interner))\n             .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n             .build(),\n     )"}, {"sha": "0f49dd39b5d6a715f34229f50888e0b7420f6de4", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -61,6 +61,8 @@ pub type ClosureId = chalk_ir::ClosureId<Interner>;\n pub type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n \n+pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n+\n pub type ChalkTraitId = chalk_ir::TraitId<Interner>;\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -662,12 +664,18 @@ impl QuantifiedWhereClauses {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Canonical<T> {\n     pub value: T,\n-    pub kinds: Arc<[TyVariableKind]>,\n+    pub binders: CanonicalVarKinds,\n }\n \n impl<T> Canonical<T> {\n     pub fn new(value: T, kinds: impl IntoIterator<Item = TyVariableKind>) -> Self {\n-        Self { value, kinds: kinds.into_iter().collect() }\n+        let kinds = kinds.into_iter().map(|tk| {\n+            chalk_ir::CanonicalVarKind::new(\n+                chalk_ir::VariableKind::Ty(tk),\n+                chalk_ir::UniverseIndex::ROOT,\n+            )\n+        });\n+        Self { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n     }\n }\n "}, {"sha": "8e986ddde264c2d9baf6b1ed0251947d2532cb76", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -6,7 +6,7 @@ use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, Mutability};\n+use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n     lang_item::LangItemTarget, AssocContainerId, AssocItemId, FunctionId, GenericDefId, HasModule,\n     ImplId, Lookup, ModuleId, TraitId,\n@@ -21,8 +21,9 @@ use crate::{\n     primitive::{self, FloatTy, IntTy, UintTy},\n     to_chalk_trait_id,\n     utils::all_super_traits,\n-    AdtId, Canonical, DebruijnIndex, FnPointer, FnSig, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSig, ForeignDefId,\n+    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRef, Ty, TyKind,\n+    TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -375,7 +376,7 @@ fn iterate_method_candidates_impl(\n             // Also note that when we've got a receiver like &S, even if the method we\n             // find in the end takes &self, we still do the autoderef step (just as\n             // rustc does an autoderef and then autoref again).\n-            let ty = InEnvironment { value: ty.clone(), environment: env.clone() };\n+            let ty = InEnvironment { goal: ty.clone(), environment: env.env.clone() };\n \n             // We have to be careful about the order we're looking at candidates\n             // in here. Consider the case where we're resolving `x.clone()`\n@@ -443,7 +444,7 @@ fn iterate_method_candidates_with_autoref(\n         return true;\n     }\n     let refed = Canonical {\n-        kinds: deref_chain[0].kinds.clone(),\n+        binders: deref_chain[0].binders.clone(),\n         value: TyKind::Ref(Mutability::Not, deref_chain[0].value.clone()).intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n@@ -459,7 +460,7 @@ fn iterate_method_candidates_with_autoref(\n         return true;\n     }\n     let ref_muted = Canonical {\n-        kinds: deref_chain[0].kinds.clone(),\n+        binders: deref_chain[0].binders.clone(),\n         value: TyKind::Ref(Mutability::Mut, deref_chain[0].value.clone()).intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n@@ -621,7 +622,7 @@ pub fn resolve_indexing_op(\n     krate: CrateId,\n     index_trait: TraitId,\n ) -> Option<Canonical<Ty>> {\n-    let ty = InEnvironment { value: ty.clone(), environment: env.clone() };\n+    let ty = InEnvironment { goal: ty.clone(), environment: env.env.clone() };\n     let deref_chain = autoderef_method_receiver(db, krate, ty);\n     for ty in deref_chain {\n         let goal = generic_implements_goal(db, env.clone(), index_trait, ty.clone());\n@@ -677,19 +678,28 @@ pub(crate) fn inherent_impl_substs(\n     // we create a var for each type parameter of the impl; we need to keep in\n     // mind here that `self_ty` might have vars of its own\n     let vars = Substitution::build_for_def(db, impl_id)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.kinds.len())\n+        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.binders.len(&Interner))\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n-    let mut kinds = self_ty.kinds.to_vec();\n-    kinds.extend(iter::repeat(chalk_ir::TyVariableKind::General).take(vars.len()));\n-    let tys = Canonical { kinds: kinds.into(), value: (self_ty_with_vars, self_ty.value.clone()) };\n+    let mut kinds = self_ty.binders.interned().to_vec();\n+    kinds.extend(\n+        iter::repeat(chalk_ir::WithKind::new(\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+            UniverseIndex::ROOT,\n+        ))\n+        .take(vars.len()),\n+    );\n+    let tys = Canonical {\n+        binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+        value: (self_ty_with_vars, self_ty.value.clone()),\n+    };\n     let substs = super::infer::unify(&tys);\n     // We only want the substs for the vars we added, not the ones from self_ty.\n     // Also, if any of the vars we added are still in there, we replace them by\n     // Unknown. I think this can only really happen if self_ty contained\n     // Unknown, and in that case we want the result to contain Unknown in those\n     // places again.\n-    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.kinds.len()))\n+    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.binders.len(&Interner)))\n }\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n@@ -768,15 +778,24 @@ fn generic_implements_goal(\n     trait_: TraitId,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::DomainGoal>> {\n-    let mut kinds = self_ty.kinds.to_vec();\n+    let mut kinds = self_ty.binders.interned().to_vec();\n     let substs = super::Substitution::build_for_def(db, trait_)\n         .push(self_ty.value)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n-    kinds.extend(iter::repeat(chalk_ir::TyVariableKind::General).take(substs.len() - 1));\n+    kinds.extend(\n+        iter::repeat(chalk_ir::WithKind::new(\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+            UniverseIndex::ROOT,\n+        ))\n+        .take(substs.len() - 1),\n+    );\n     let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs };\n     let obligation = trait_ref.cast(&Interner);\n-    Canonical { kinds: kinds.into(), value: InEnvironment::new(env, obligation) }\n+    Canonical {\n+        binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+        value: InEnvironment::new(env.env.clone(), obligation),\n+    }\n }\n \n fn autoderef_method_receiver(\n@@ -789,9 +808,9 @@ fn autoderef_method_receiver(\n     if let Some(TyKind::Array(parameters)) =\n         deref_chain.last().map(|ty| ty.value.interned(&Interner))\n     {\n-        let kinds = deref_chain.last().unwrap().kinds.clone();\n+        let kinds = deref_chain.last().unwrap().binders.clone();\n         let unsized_ty = TyKind::Slice(parameters.clone()).intern(&Interner);\n-        deref_chain.push(Canonical { value: unsized_ty, kinds })\n+        deref_chain.push(Canonical { value: unsized_ty, binders: kinds })\n     }\n     deref_chain\n }"}, {"sha": "ccee0e5ad2bc3e52d8493510d79ff54a54f70e82", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -1,6 +1,5 @@\n //! Trait solving using Chalk.\n use std::env::var;\n-use std::sync::Arc;\n \n use base_db::CrateId;\n use chalk_ir::cast::Cast;\n@@ -44,7 +43,7 @@ pub struct TraitEnvironment {\n     // When we're using Chalk's Ty we can make this a BTreeMap since it's Ord,\n     // but for now it's too annoying...\n     pub(crate) traits_from_clauses: Vec<(Ty, TraitId)>,\n-    pub(crate) env: chalk_ir::Environment<Interner>,\n+    pub env: chalk_ir::Environment<Interner>,\n }\n \n impl TraitEnvironment {\n@@ -74,13 +73,13 @@ impl Default for TraitEnvironment {\n /// Something (usually a goal), along with an environment.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct InEnvironment<T> {\n-    pub environment: Arc<TraitEnvironment>,\n-    pub value: T,\n+    pub environment: chalk_ir::Environment<Interner>,\n+    pub goal: T,\n }\n \n impl<T> InEnvironment<T> {\n-    pub fn new(environment: Arc<TraitEnvironment>, value: T) -> InEnvironment<T> {\n-        InEnvironment { environment, value }\n+    pub fn new(environment: chalk_ir::Environment<Interner>, value: T) -> InEnvironment<T> {\n+        InEnvironment { environment, goal: value }\n     }\n }\n \n@@ -126,18 +125,18 @@ pub(crate) fn trait_solve_query(\n     krate: CrateId,\n     goal: Canonical<InEnvironment<DomainGoal>>,\n ) -> Option<Solution> {\n-    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.value {\n+    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal {\n         DomainGoal::Holds(WhereClause::Implemented(it)) => {\n             db.trait_data(it.hir_trait_id()).name.to_string()\n         }\n         DomainGoal::Holds(WhereClause::AliasEq(_)) => \"alias_eq\".to_string(),\n     });\n-    log::info!(\"trait_solve_query({})\", goal.value.value.display(db));\n+    log::info!(\"trait_solve_query({})\", goal.value.goal.display(db));\n \n     if let DomainGoal::Holds(WhereClause::AliasEq(AliasEq {\n         alias: AliasTy::Projection(projection_ty),\n         ..\n-    })) = &goal.value.value\n+    })) = &goal.value.goal\n     {\n         if let TyKind::BoundVar(_) = &projection_ty.substitution[0].interned(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible"}, {"sha": "aef6b8a15638f1881b08b943ee299d41088f53fe", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e220d3d5079eaabf485d8966e1eb3bb90d181c23/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=e220d3d5079eaabf485d8966e1eb3bb90d181c23", "patch": "@@ -439,35 +439,12 @@ where\n     type Chalk = chalk_ir::Canonical<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n-        let kinds = self.kinds.iter().map(|&tk| {\n-            chalk_ir::CanonicalVarKind::new(\n-                chalk_ir::VariableKind::Ty(tk),\n-                chalk_ir::UniverseIndex::ROOT,\n-            )\n-        });\n         let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical {\n-            value,\n-            binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds),\n-        }\n+        chalk_ir::Canonical { value, binders: self.binders }\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n-        let kinds = canonical\n-            .binders\n-            .iter(&Interner)\n-            .map(|k| match k.kind {\n-                chalk_ir::VariableKind::Ty(tk) => tk,\n-                // HACK: Chalk can sometimes return new lifetime variables. We\n-                // want to just skip them, but to not mess up the indices of\n-                // other variables, we'll just create a new type variable in\n-                // their place instead. This should not matter (we never see the\n-                // actual *uses* of the lifetime variable).\n-                chalk_ir::VariableKind::Lifetime => chalk_ir::TyVariableKind::General,\n-                chalk_ir::VariableKind::Const(_) => panic!(\"unexpected const from Chalk\"),\n-            })\n-            .collect();\n-        Canonical { kinds, value: from_chalk(db, canonical.value) }\n+        Canonical { binders: canonical.binders, value: from_chalk(db, canonical.value) }\n     }\n }\n \n@@ -478,10 +455,7 @@ where\n     type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n-        chalk_ir::InEnvironment {\n-            environment: self.environment.env.clone(),\n-            goal: self.value.to_chalk(db),\n-        }\n+        chalk_ir::InEnvironment { environment: self.environment, goal: self.goal.to_chalk(db) }\n     }\n \n     fn from_chalk("}]}