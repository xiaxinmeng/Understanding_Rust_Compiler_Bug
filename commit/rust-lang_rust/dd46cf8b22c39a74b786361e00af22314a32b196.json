{"sha": "dd46cf8b22c39a74b786361e00af22314a32b196", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNDZjZjhiMjJjMzlhNzRiNzg2MzYxZTAwYWYyMjMxNGEzMmIxOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-13T23:47:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-13T23:47:06Z"}, "message": "Auto merge of #26241 - SimonSapin:derefmut-for-string, r=alexcrichton\n\nSee https://github.com/rust-lang/rfcs/issues/1157", "tree": {"sha": "ef42015a6a4e59fe77648d41ca5a79f4e0cdb21f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef42015a6a4e59fe77648d41ca5a79f4e0cdb21f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd46cf8b22c39a74b786361e00af22314a32b196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd46cf8b22c39a74b786361e00af22314a32b196", "html_url": "https://github.com/rust-lang/rust/commit/dd46cf8b22c39a74b786361e00af22314a32b196", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd46cf8b22c39a74b786361e00af22314a32b196/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72483f58e355c6ec9016cbaba4d9b8d3adbd3867", "url": "https://api.github.com/repos/rust-lang/rust/commits/72483f58e355c6ec9016cbaba4d9b8d3adbd3867", "html_url": "https://github.com/rust-lang/rust/commit/72483f58e355c6ec9016cbaba4d9b8d3adbd3867"}, {"sha": "3226858e500fa70b46c18d1accedc60060f2bbc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3226858e500fa70b46c18d1accedc60060f2bbc0", "html_url": "https://github.com/rust-lang/rust/commit/3226858e500fa70b46c18d1accedc60060f2bbc0"}], "stats": {"total": 240, "additions": 213, "deletions": 27}, "files": [{"sha": "cb6613998b45452e83fbaea9683e2bce5c772d54", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -550,6 +550,14 @@ impl str {\n         core_str::StrExt::slice_unchecked(self, begin, end)\n     }\n \n+    /// Takes a bytewise mutable slice from a string.\n+    ///\n+    /// Same as `slice_unchecked`, but works with `&mut str` instead of `&str`.\n+    #[unstable(feature = \"str_slice_mut\", reason = \"recently added\")]\n+    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n+    }\n+\n     /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n     /// That is, start at the `begin`-th code point of the string and continue\n@@ -776,7 +784,7 @@ impl str {\n     ///\n     /// # Examples\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(str_split_at)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let first_space = s.find(' ').unwrap_or(s.len());\n     /// let (a, b) = s.split_at(first_space);\n@@ -785,10 +793,18 @@ impl str {\n     /// assert_eq!(b, \" \u8001\u864e L\u00e9opard\");\n     /// ```\n     #[inline]\n+    #[unstable(feature = \"str_split_at\", reason = \"recently added\")]\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         core_str::StrExt::split_at(self, mid)\n     }\n \n+    /// Divide one mutable string slice into two at an index.\n+    #[inline]\n+    #[unstable(feature = \"str_split_at\", reason = \"recently added\")]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        core_str::StrExt::split_at_mut(self, mid)\n+    }\n+\n     /// An iterator over the codepoints of `self`.\n     ///\n     /// # Examples"}, {"sha": "91142afeda346bd414b03d8e69357bef1b343345", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -979,6 +979,38 @@ impl ops::Index<ops::RangeFull> for String {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::Range<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n+        &mut self[..][index]\n+    }\n+}\n+#[cfg(not(stage0))]\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::RangeTo<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n+        &mut self[..][index]\n+    }\n+}\n+#[cfg(not(stage0))]\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::RangeFrom<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n+        &mut self[..][index]\n+    }\n+}\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::RangeFull> for String {\n+    #[inline]\n+    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n+        unsafe { mem::transmute(&mut *self.vec) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {\n     type Target = str;\n@@ -989,6 +1021,14 @@ impl ops::Deref for String {\n     }\n }\n \n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::DerefMut for String {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut str {\n+        unsafe { mem::transmute(&mut self.vec[..]) }\n+    }\n+}\n+\n /// Wrapper type providing a `&String` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n #[deprecated(since = \"1.2.0\","}, {"sha": "d161dc7a287f93846c1d74a80023b11b5c218ca8", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(ascii)]\n #![feature(append)]\n #![feature(bitset)]\n #![feature(bitvec)]\n@@ -43,6 +44,7 @@\n #![feature(str_char)]\n #![feature(str_escape)]\n #![feature(str_match_indices)]\n+#![feature(str_split_at)]\n #![feature(str_utf16)]\n #![feature(box_str)]\n #![feature(subslice_offset)]"}, {"sha": "5419c43ba096b7c1c8fa003411199856bf07f993", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -701,6 +701,18 @@ fn test_split_at() {\n     assert_eq!(b, \"\");\n }\n \n+#[test]\n+fn test_split_at_mut() {\n+    use std::ascii::AsciiExt;\n+    let mut s = \"Hello World\".to_string();\n+    {\n+        let (a, b) = s.split_at_mut(5);\n+        a.make_ascii_uppercase();\n+        b.make_ascii_lowercase();\n+    }\n+    assert_eq!(s, \"HELLO world\");\n+}\n+\n #[test]\n #[should_panic]\n fn test_split_at_boundscheck() {"}, {"sha": "7e4c2ba3be87590256d63b8ae45b02e4b4baa1df", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -1116,6 +1116,23 @@ mod traits {\n         }\n     }\n \n+    /// Returns a mutable slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::Range<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_mut_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n@@ -1138,6 +1155,21 @@ mod traits {\n         }\n     }\n \n+    /// Returns a mutable slice of the string from the beginning to byte\n+    /// `end`.\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::RangeTo<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_mut_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from `begin` to its end.\n     ///\n     /// Equivalent to `self[begin .. self.len()]`.\n@@ -1159,6 +1191,21 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the string from `begin` to its end.\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                let len = self.len();\n+                unsafe { self.slice_mut_unchecked(index.start, len) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n+        }\n+    }\n+\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n@@ -1168,6 +1215,14 @@ mod traits {\n             self\n         }\n     }\n+\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::RangeFull> for str {\n+        #[inline]\n+        fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n+            self\n+        }\n+    }\n }\n \n /// Methods for string slices\n@@ -1204,6 +1259,7 @@ pub trait StrExt {\n     fn char_len(&self) -> usize;\n     fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    unsafe fn slice_mut_unchecked<'a>(&'a mut self, begin: usize, end: usize) -> &'a mut str;\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n     fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n         where P::Searcher: ReverseSearcher<'a>;\n@@ -1223,6 +1279,7 @@ pub trait StrExt {\n         where P::Searcher: ReverseSearcher<'a>;\n     fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn split_at(&self, mid: usize) -> (&str, &str);\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n     fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n@@ -1379,6 +1436,14 @@ impl StrExt for str {\n         })\n     }\n \n+    #[inline]\n+    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        mem::transmute(Slice {\n+            data: self.as_ptr().offset(begin as isize),\n+            len: end - begin,\n+        })\n+    }\n+\n     #[inline]\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         pat.is_prefix_of(self)\n@@ -1527,6 +1592,20 @@ impl StrExt for str {\n         }\n     }\n \n+    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(mid) {\n+            let len = self.len();\n+            unsafe {\n+                let self2: &mut str = mem::transmute_copy(&self);\n+                (self.slice_mut_unchecked(0, mid),\n+                 self2.slice_mut_unchecked(mid, len))\n+            }\n+        } else {\n+            slice_error_fail(self, 0, mid)\n+        }\n+    }\n+\n     #[inline]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         if self.is_empty() {"}, {"sha": "cf78fa7b69a00bb2ec8bb88e47ef947ad08724d5", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -469,16 +469,19 @@ mod tests {\n     use char::from_u32;\n \n     #[test]\n-    fn test_ascii() {\n-        assert!(\"banana\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n-    }\n+    fn test_is_ascii() {\n+        assert!(b\"\".is_ascii());\n+        assert!(b\"banana\\0\\x7F\".is_ascii());\n+        assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n+        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n+        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n+        assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n \n-    #[test]\n-    fn test_ascii_vec() {\n         assert!(\"\".is_ascii());\n-        assert!(\"a\".is_ascii());\n-        assert!(!\"\\u{2009}\".is_ascii());\n+        assert!(\"banana\\0\\u{7F}\".is_ascii());\n+        assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n+        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n+        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n     }\n \n     #[test]\n@@ -537,6 +540,55 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_make_ascii_lower_case() {\n+        macro_rules! test {\n+            ($from: expr, $to: expr) => {\n+                {\n+                    let mut x = $from;\n+                    x.make_ascii_lowercase();\n+                    assert_eq!(x, $to);\n+                }\n+            }\n+        }\n+        test!(b'A', b'a');\n+        test!(b'a', b'a');\n+        test!(b'!', b'!');\n+        test!('A', 'a');\n+        test!('\u00c0', '\u00c0');\n+        test!('a', 'a');\n+        test!('!', '!');\n+        test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n+        test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n+    }\n+\n+\n+    #[test]\n+    fn test_make_ascii_upper_case() {\n+        macro_rules! test {\n+            ($from: expr, $to: expr) => {\n+                {\n+                    let mut x = $from;\n+                    x.make_ascii_uppercase();\n+                    assert_eq!(x, $to);\n+                }\n+            }\n+        }\n+        test!(b'a', b'A');\n+        test!(b'A', b'A');\n+        test!(b'!', b'!');\n+        test!('a', 'A');\n+        test!('\u00e0', '\u00e0');\n+        test!('A', 'A');\n+        test!('!', '!');\n+        test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n+        test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n+\n+        let mut x = \"Hello\".to_string();\n+        x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+        assert_eq!(x, \"HELlo\")\n+    }\n+\n     #[test]\n     fn test_eq_ignore_ascii_case() {\n         assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));"}, {"sha": "aa05d7d5c54d7fabb81ef21796178eeb542d4d22", "filename": "src/test/compile-fail/str-mut-idx-2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72483f58e355c6ec9016cbaba4d9b8d3adbd3867/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72483f58e355c6ec9016cbaba4d9b8d3adbd3867/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx-2.rs?ref=72483f58e355c6ec9016cbaba4d9b8d3adbd3867", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn mutate(mut s: &mut str) {\n-    let _s: &mut str = &mut s[1..2];\n-    //~^ ERROR cannot borrow immutable indexed content as mutable\n-}\n-\n-pub fn main() {}"}, {"sha": "73abe6cb59db2669d006314aaa7686e18a384497", "filename": "src/test/compile-fail/str-mut-idx.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd46cf8b22c39a74b786361e00af22314a32b196/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx.rs?ref=dd46cf8b22c39a74b786361e00af22314a32b196", "patch": "@@ -13,10 +13,11 @@ fn bot<T>() -> T { loop {} }\n fn mutate(s: &mut str) {\n     s[1..2] = bot();\n     //~^ ERROR `core::marker::Sized` is not implemented for the type `str`\n-    //~^^ ERROR `core::marker::Sized` is not implemented for the type `str`\n+    //~| ERROR `core::marker::Sized` is not implemented for the type `str`\n     s[1usize] = bot();\n     //~^ ERROR `core::ops::Index<usize>` is not implemented for the type `str`\n-    //~^^ ERROR `core::ops::Index<usize>` is not implemented for the type `str`\n+    //~| ERROR `core::ops::IndexMut<usize>` is not implemented for the type `str`\n+    //~| ERROR `core::ops::Index<usize>` is not implemented for the type `str`\n }\n \n pub fn main() {}"}]}