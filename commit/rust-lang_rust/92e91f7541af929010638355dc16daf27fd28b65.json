{"sha": "92e91f7541af929010638355dc16daf27fd28b65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZTkxZjc1NDFhZjkyOTAxMDYzODM1NWRjMTZkYWYyN2ZkMjhiNjU=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2019-09-19T04:36:30Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2019-09-22T04:16:24Z"}, "message": "Remove manual unrolling from slice::Iter(Mut)::try_fold\n\nWhile this definitely helps sometimes (particularly for trivial closures), it's also a pessimization sometimes, so it's better to leave this to (hypothetical) future LLVM improvements instead of forcing this on everyone.\n\nI think it's better for the advice to be that sometimes you need to unroll manually than you sometimes need to not-unroll manually (like #64545).", "tree": {"sha": "6f454ae5299a2f7685619ce26d27a566c5023c0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f454ae5299a2f7685619ce26d27a566c5023c0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92e91f7541af929010638355dc16daf27fd28b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92e91f7541af929010638355dc16daf27fd28b65", "html_url": "https://github.com/rust-lang/rust/commit/92e91f7541af929010638355dc16daf27fd28b65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92e91f7541af929010638355dc16daf27fd28b65/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eceec57f72150dd548e05025a05a93381da41385", "url": "https://api.github.com/repos/rust-lang/rust/commits/eceec57f72150dd548e05025a05a93381da41385", "html_url": "https://github.com/rust-lang/rust/commit/eceec57f72150dd548e05025a05a93381da41385"}], "stats": {"total": 20, "additions": 7, "deletions": 13}, "files": [{"sha": "59f95cff5aee18ef14c39f7c6c080391597a5193", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92e91f7541af929010638355dc16daf27fd28b65/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e91f7541af929010638355dc16daf27fd28b65/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=92e91f7541af929010638355dc16daf27fd28b65", "patch": "@@ -3184,18 +3184,14 @@ macro_rules! iterator {\n             fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n                 Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n             {\n-                // manual unrolling is needed when there are conditional exits from the loop\n+                // This method historically was unrolled, for as of 2019-09 LLVM\n+                // is not capable of unrolling or vectorizing multiple-exit loops.\n+                // However, doing it always proved to often be a pessimization,\n+                // especially when called with large closures, so it was removed.\n+\n                 let mut accum = init;\n-                unsafe {\n-                    while len!(self) >= 4 {\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                    }\n-                    while !is_empty!(self) {\n-                        accum = f(accum, next_unchecked!(self))?;\n-                    }\n+                while let Some(x) = self.next() {\n+                    accum = f(accum, x)?;\n                 }\n                 Try::from_ok(accum)\n             }\n@@ -3204,8 +3200,6 @@ macro_rules! iterator {\n             fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n                 where Fold: FnMut(Acc, Self::Item) -> Acc,\n             {\n-                // Let LLVM unroll this, rather than using the default\n-                // impl that would force the manual unrolling above\n                 let mut accum = init;\n                 while let Some(x) = self.next() {\n                     accum = f(accum, x);"}]}