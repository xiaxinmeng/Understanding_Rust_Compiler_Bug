{"sha": "87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZWVjZDQwZTg3Y2Y3ZTc3Y2VlOWNmZGM3OTkwMGM4M2JhZjZkOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T09:32:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T09:32:38Z"}, "message": "Auto merge of #79261 - faern:deprecate-compare-and-swap, r=Amanieu\n\nDeprecate atomic compare_and_swap method\n\nFinish implementing [RFC 1443](https://github.com/rust-lang/rfcs/blob/master/text/1443-extended-compare-and-swap.md) (https://github.com/rust-lang/rfcs/pull/1443).\n\nIt was decided to deprecate `compare_and_swap` [back in Rust 1.12 already](https://github.com/rust-lang/rust/issues/31767#issuecomment-215903038). I can't find any info about that decision being reverted. My understanding is just that it has been forgotten. If there has been a decision on keeping `compare_and_swap` then it's hard to find, and even if this PR does not go through it can act as a place where people can find out about the decision being reverted.\n\nAtomic operations are hard to understand, very hard. And it does not help that there are multiple similar methods to do compare and swap with. They are so similar that for a reader it might be hard to understand the difference. This PR aims to make that simpler by finally deprecating `compare_and_swap` which is essentially just a more limited version of `compare_exchange`. The documentation is also updated (according to the RFC text) to explain the differences a bit better.\n\nEven if we decide to not deprecate `compare_and_swap`. I still think the documentation for the atomic operations should be improved to better describe their differences and similarities. And the documentation can be written nicer than the PR currently proposes, but I wanted to start somewhere. Most of it is just copied from the RFC.\n\nThe documentation for `compare_exchange` and `compare_exchange_weak` indeed describe how they work! The problem is that they are more complex and harder to understand than `compare_and_swap`. So for someone who does not fully grasp this they might fall back to using `compare_and_swap`. Making the documentation outline the similarities and differences might build a bridge for people so they can cross over to the more powerful and sometimes more efficient operations.\n\nThe conversions I do to avoid the `std` internal deprecation errors are very straight forward `compare_and_swap -> compare_exchange` changes where the orderings are just using the mapping in the new documentation. Only in one place did I use `compare_exchange_weak`. This can probably be improved further. But the goal here was not for those operations to be perfect. Just to not get worse and to allow the deprecation to happen.", "tree": {"sha": "3f126cf9050d360a96c3e4347d5da819742e1661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f126cf9050d360a96c3e4347d5da819742e1661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "html_url": "https://github.com/rust-lang/rust/commit/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "html_url": "https://github.com/rust-lang/rust/commit/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9"}, {"sha": "454f3ed9029dc407b59b714cb60c00036a253a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/454f3ed9029dc407b59b714cb60c00036a253a2b", "html_url": "https://github.com/rust-lang/rust/commit/454f3ed9029dc407b59b714cb60c00036a253a2b"}], "stats": {"total": 226, "additions": 170, "deletions": 56}, "files": [{"sha": "36857979af8c111d319d37210197ed7e83b8ef48", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 89, "deletions": 18, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -464,6 +464,23 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n+    /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n+    ///\n+    /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n+    /// memory orderings:\n+    ///\n+    /// Original | Success | Failure\n+    /// -------- | ------- | -------\n+    /// Relaxed  | Relaxed | Relaxed\n+    /// Acquire  | Acquire | Acquire\n+    /// Release  | Release | Relaxed\n+    /// AcqRel   | AcqRel  | Acquire\n+    /// SeqCst   | SeqCst  | SeqCst\n+    ///\n+    /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n+    /// which allows the compiler to generate better assembly code when the compare and swap\n+    /// is used in a loop.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -479,6 +496,10 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.50.0\",\n+        reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n+    )]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n@@ -493,9 +514,10 @@ impl AtomicBool {\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n     /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the\n-    /// operation succeeds while the second describes the required ordering when the\n-    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// ordering of this operation. `success` describes the required ordering for the\n+    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n+    /// `failure` describes the required ordering for the load operation that takes place when\n+    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n     /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n@@ -525,6 +547,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[doc(alias = \"compare_and_swap\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange(\n         &self,\n@@ -550,9 +573,10 @@ impl AtomicBool {\n     /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the\n-    /// operation succeeds while the second describes the required ordering when the\n-    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// ordering of this operation. `success` describes the required ordering for the\n+    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n+    /// `failure` describes the required ordering for the load operation that takes place when\n+    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n     /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n@@ -578,6 +602,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[doc(alias = \"compare_and_swap\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange_weak(\n         &self,\n@@ -1066,6 +1091,23 @@ impl<T> AtomicPtr<T> {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on pointers.\n     ///\n+    /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n+    ///\n+    /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n+    /// memory orderings:\n+    ///\n+    /// Original | Success | Failure\n+    /// -------- | ------- | -------\n+    /// Relaxed  | Relaxed | Relaxed\n+    /// Acquire  | Acquire | Acquire\n+    /// Release  | Release | Relaxed\n+    /// AcqRel   | AcqRel  | Acquire\n+    /// SeqCst   | SeqCst  | SeqCst\n+    ///\n+    /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n+    /// which allows the compiler to generate better assembly code when the compare and swap\n+    /// is used in a loop.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1080,6 +1122,10 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.50.0\",\n+        reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n+    )]\n     #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n@@ -1094,9 +1140,10 @@ impl<T> AtomicPtr<T> {\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n     /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the\n-    /// operation succeeds while the second describes the required ordering when the\n-    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// ordering of this operation. `success` describes the required ordering for the\n+    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n+    /// `failure` describes the required ordering for the load operation that takes place when\n+    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n     /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n@@ -1157,9 +1204,10 @@ impl<T> AtomicPtr<T> {\n     /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the\n-    /// operation succeeds while the second describes the required ordering when the\n-    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// ordering of this operation. `success` describes the required ordering for the\n+    /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n+    /// `failure` describes the required ordering for the load operation that takes place when\n+    /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n     /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n     /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n     /// and must be equivalent to or weaker than the success ordering.\n@@ -1604,6 +1652,23 @@ happens, and using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n+# Migrating to `compare_exchange` and `compare_exchange_weak`\n+\n+`compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n+memory orderings:\n+\n+Original | Success | Failure\n+-------- | ------- | -------\n+Relaxed  | Relaxed | Relaxed\n+Acquire  | Acquire | Acquire\n+Release  | Release | Relaxed\n+AcqRel   | AcqRel  | Acquire\n+SeqCst   | SeqCst  | SeqCst\n+\n+`compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n+which allows the compiler to generate better assembly code when the compare and swap\n+is used in a loop.\n+\n # Examples\n \n ```\n@@ -1619,6 +1684,10 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[rustc_deprecated(\n+                    since = \"1.50.0\",\n+                    reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n+                ]\n                 #[$cfg_cas]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n@@ -1643,9 +1712,10 @@ containing the previous value. On success this value is guaranteed to be equal t\n `current`.\n \n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering if the\n-operation succeeds while the second describes the required ordering when the\n-operation fails. Using [`Acquire`] as success ordering makes the store part\n+ordering of this operation. `success` describes the required ordering for the\n+read-modify-write operation that takes place if the comparison with `current` succeeds.\n+`failure` describes the required ordering for the load operation that takes place when\n+the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n and must be equivalent to or weaker than the success ordering.\n@@ -1695,9 +1765,10 @@ platforms. The return value is a result indicating whether the new value was\n written and containing the previous value.\n \n `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering if the\n-operation succeeds while the second describes the required ordering when the\n-operation fails. Using [`Acquire`] as success ordering makes the store part\n+ordering of this operation. `success` describes the required ordering for the\n+read-modify-write operation that takes place if the comparison with `current` succeeds.\n+`failure` describes the required ordering for the load operation that takes place when\n+the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n and must be equivalent to or weaker than the success ordering."}, {"sha": "2d1e4496aeef7496cad65c4b2c429ef348fa3306", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -4,11 +4,11 @@ use core::sync::atomic::*;\n #[test]\n fn bool_() {\n     let a = AtomicBool::new(false);\n-    assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-    assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n+    assert_eq!(a.compare_exchange(false, true, SeqCst, SeqCst), Ok(false));\n+    assert_eq!(a.compare_exchange(false, true, SeqCst, SeqCst), Err(true));\n \n     a.store(false, SeqCst);\n-    assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+    assert_eq!(a.compare_exchange(false, true, SeqCst, SeqCst), Ok(false));\n }\n \n #[test]"}, {"sha": "4c852b8ee812f1f7a6b25c36e12ea3f496a72c42", "filename": "library/std/src/sync/mpsc/blocking.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -36,7 +36,11 @@ pub fn tokens() -> (WaitToken, SignalToken) {\n \n impl SignalToken {\n     pub fn signal(&self) -> bool {\n-        let wake = !self.inner.woken.compare_and_swap(false, true, Ordering::SeqCst);\n+        let wake = self\n+            .inner\n+            .woken\n+            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)\n+            .is_ok();\n         if wake {\n             self.inner.thread.unpark();\n         }"}, {"sha": "3dcf03f579a0f32f0f5dd00ceba42b1057913f2c", "filename": "library/std/src/sync/mpsc/oneshot.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -129,7 +129,7 @@ impl<T> Packet<T> {\n             let ptr = unsafe { signal_token.cast_to_usize() };\n \n             // race with senders to enter the blocking state\n-            if self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) == EMPTY {\n+            if self.state.compare_exchange(EMPTY, ptr, Ordering::SeqCst, Ordering::SeqCst).is_ok() {\n                 if let Some(deadline) = deadline {\n                     let timed_out = !wait_token.wait_max_until(deadline);\n                     // Try to reset the state\n@@ -161,7 +161,12 @@ impl<T> Packet<T> {\n                 // the state changes under our feet we'd rather just see that state\n                 // change.\n                 DATA => {\n-                    self.state.compare_and_swap(DATA, EMPTY, Ordering::SeqCst);\n+                    let _ = self.state.compare_exchange(\n+                        DATA,\n+                        EMPTY,\n+                        Ordering::SeqCst,\n+                        Ordering::SeqCst,\n+                    );\n                     match (&mut *self.data.get()).take() {\n                         Some(data) => Ok(data),\n                         None => unreachable!(),\n@@ -264,7 +269,10 @@ impl<T> Packet<T> {\n \n             // If we've got a blocked thread, then use an atomic to gain ownership\n             // of it (may fail)\n-            ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst),\n+            ptr => self\n+                .state\n+                .compare_exchange(ptr, EMPTY, Ordering::SeqCst, Ordering::SeqCst)\n+                .unwrap_or_else(|x| x),\n         };\n \n         // Now that we've got ownership of our state, figure out what to do"}, {"sha": "0c32e636a563357ce39cac0f6313c422b4915c1c", "filename": "library/std/src/sync/mpsc/shared.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -385,8 +385,15 @@ impl<T> Packet<T> {\n         self.port_dropped.store(true, Ordering::SeqCst);\n         let mut steals = unsafe { *self.steals.get() };\n         while {\n-            let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, Ordering::SeqCst);\n-            cnt != DISCONNECTED && cnt != steals\n+            match self.cnt.compare_exchange(\n+                steals,\n+                DISCONNECTED,\n+                Ordering::SeqCst,\n+                Ordering::SeqCst,\n+            ) {\n+                Ok(_) => false,\n+                Err(old) => old != DISCONNECTED,\n+            }\n         } {\n             // See the discussion in 'try_recv' for why we yield\n             // control of this thread."}, {"sha": "a652f24c58a19cd986563a22b9d04b2ed2b681d9", "filename": "library/std/src/sync/mpsc/stream.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -322,12 +322,15 @@ impl<T> Packet<T> {\n         // (because there is a bounded number of senders).\n         let mut steals = unsafe { *self.queue.consumer_addition().steals.get() };\n         while {\n-            let cnt = self.queue.producer_addition().cnt.compare_and_swap(\n+            match self.queue.producer_addition().cnt.compare_exchange(\n                 steals,\n                 DISCONNECTED,\n                 Ordering::SeqCst,\n-            );\n-            cnt != DISCONNECTED && cnt != steals\n+                Ordering::SeqCst,\n+            ) {\n+                Ok(_) => false,\n+                Err(old) => old != DISCONNECTED,\n+            }\n         } {\n             while self.queue.pop().is_some() {\n                 steals += 1;"}, {"sha": "6a330834489df9ca1716b8b46f0c3fb4d7f4581f", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -65,7 +65,7 @@\n //       must do so with Release ordering to make the result available.\n //     - `wait` inserts `Waiter` nodes as a pointer in `state_and_queue`, and\n //       needs to make the nodes available with Release ordering. The load in\n-//       its `compare_and_swap` can be Relaxed because it only has to compare\n+//       its `compare_exchange` can be Relaxed because it only has to compare\n //       the atomic, not to read other data.\n //     - `WaiterQueue::Drop` must see the `Waiter` nodes, so it must load\n //       `state_and_queue` with Acquire ordering.\n@@ -110,7 +110,7 @@ use crate::thread::{self, Thread};\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n-    // `state_and_queue` is actually an a pointer to a `Waiter` with extra state\n+    // `state_and_queue` is actually a pointer to a `Waiter` with extra state\n     // bits, so we add the `PhantomData` appropriately.\n     state_and_queue: AtomicUsize,\n     _marker: marker::PhantomData<*const Waiter>,\n@@ -395,12 +395,13 @@ impl Once {\n                 }\n                 POISONED | INCOMPLETE => {\n                     // Try to register this thread as the one RUNNING.\n-                    let old = self.state_and_queue.compare_and_swap(\n+                    let exchange_result = self.state_and_queue.compare_exchange(\n                         state_and_queue,\n                         RUNNING,\n                         Ordering::Acquire,\n+                        Ordering::Acquire,\n                     );\n-                    if old != state_and_queue {\n+                    if let Err(old) = exchange_result {\n                         state_and_queue = old;\n                         continue;\n                     }\n@@ -452,8 +453,13 @@ fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n \n         // Try to slide in the node at the head of the linked list, making sure\n         // that another thread didn't just replace the head of the linked list.\n-        let old = state_and_queue.compare_and_swap(current_state, me | RUNNING, Ordering::Release);\n-        if old != current_state {\n+        let exchange_result = state_and_queue.compare_exchange(\n+            current_state,\n+            me | RUNNING,\n+            Ordering::Release,\n+            Ordering::Relaxed,\n+        );\n+        if let Err(old) = exchange_result {\n             current_state = old;\n             continue;\n         }"}, {"sha": "a5e453034762c16d5d9dac37d898f41319a8df92", "filename": "library/std/src/sys/sgx/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -36,20 +36,20 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n     }\n \n     // Try to atomically swap UNINIT with BUSY. The returned state can be:\n-    match RELOC_STATE.compare_and_swap(UNINIT, BUSY, Ordering::Acquire) {\n+    match RELOC_STATE.compare_exchange(UNINIT, BUSY, Ordering::Acquire, Ordering::Acquire) {\n         // This thread just obtained the lock and other threads will observe BUSY\n-        UNINIT => {\n+        Ok(_) => {\n             reloc::relocate_elf_rela();\n             RELOC_STATE.store(DONE, Ordering::Release);\n         }\n         // We need to wait until the initialization is done.\n-        BUSY => {\n+        Err(BUSY) => {\n             while RELOC_STATE.load(Ordering::Acquire) == BUSY {\n                 core::hint::spin_loop();\n             }\n         }\n         // Initialization is done.\n-        DONE => {}\n+        Err(DONE) => {}\n         _ => unreachable!(),\n     }\n }"}, {"sha": "9140041c58414754a8a6b245269584450070103a", "filename": "library/std/src/sys/sgx/waitqueue/spin_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -42,7 +42,7 @@ impl<T> SpinMutex<T> {\n \n     #[inline(always)]\n     pub fn try_lock(&self) -> Option<SpinMutexGuard<'_, T>> {\n-        if !self.lock.compare_and_swap(false, true, Ordering::Acquire) {\n+        if self.lock.compare_exchange(false, true, Ordering::Acquire, Ordering::Acquire).is_ok() {\n             Some(SpinMutexGuard { mutex: self })\n         } else {\n             None"}, {"sha": "d4cc56d4cb3efa244a259345495c3bd4d8e29f64", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -123,9 +123,9 @@ impl Mutex {\n         let inner = box Inner { remutex: ReentrantMutex::uninitialized(), held: Cell::new(false) };\n         inner.remutex.init();\n         let inner = Box::into_raw(inner);\n-        match self.lock.compare_and_swap(0, inner as usize, Ordering::SeqCst) {\n-            0 => inner,\n-            n => {\n+        match self.lock.compare_exchange(0, inner as usize, Ordering::SeqCst, Ordering::SeqCst) {\n+            Ok(_) => inner,\n+            Err(n) => {\n                 Box::from_raw(inner).remutex.destroy();\n                 n as *const _\n             }"}, {"sha": "9e4c9aa0a512c4fb6c211fa0b50d791eb1dd9b5d", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -113,7 +113,7 @@ impl Parker {\n                 // Wait for something to happen, assuming it's still set to PARKED.\n                 c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, c::INFINITE);\n                 // Change NOTIFIED=>EMPTY but leave PARKED alone.\n-                if self.state.compare_and_swap(NOTIFIED, EMPTY, Acquire) == NOTIFIED {\n+                if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {\n                     // Actually woken up by unpark().\n                     return;\n                 } else {"}, {"sha": "1578a2de60cefde982fc76f594b82a4a6c560bb0", "filename": "library/std/src/sys_common/condvar/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -23,9 +23,9 @@ impl SameMutexCheck {\n     }\n     pub fn verify(&self, mutex: &MovableMutex) {\n         let addr = mutex.raw() as *const mutex_imp::Mutex as usize;\n-        match self.addr.compare_and_swap(0, addr, Ordering::SeqCst) {\n-            0 => {}              // Stored the address\n-            n if n == addr => {} // Lost a race to store the same address\n+        match self.addr.compare_exchange(0, addr, Ordering::SeqCst, Ordering::SeqCst) {\n+            Ok(_) => {}               // Stored the address\n+            Err(n) if n == addr => {} // Lost a race to store the same address\n             _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n         }\n     }"}, {"sha": "32cd56416655f18a4157684ac35ab1a85c0acddd", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -168,7 +168,7 @@ impl StaticKey {\n             return key;\n         }\n \n-        // POSIX allows the key created here to be 0, but the compare_and_swap\n+        // POSIX allows the key created here to be 0, but the compare_exchange\n         // below relies on using 0 as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n         // guaranteed value that cannot be returned as a posix_key_create key,\n@@ -186,11 +186,11 @@ impl StaticKey {\n             key2\n         };\n         rtassert!(key != 0);\n-        match self.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n+        match self.key.compare_exchange(0, key as usize, Ordering::SeqCst, Ordering::SeqCst) {\n             // The CAS succeeded, so we've created the actual key\n-            0 => key as usize,\n+            Ok(_) => key as usize,\n             // If someone beat us to the punch, use their key instead\n-            n => {\n+            Err(n) => {\n                 imp::destroy(key);\n                 n\n             }"}, {"sha": "0132743b244048cfa48e8388e872ceac3e7c3edf", "filename": "library/std/src/sys_common/thread_parker/futex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -49,7 +49,7 @@ impl Parker {\n             // Wait for something to happen, assuming it's still set to PARKED.\n             futex_wait(&self.state, PARKED, None);\n             // Change NOTIFIED=>EMPTY and return in that case.\n-            if self.state.compare_and_swap(NOTIFIED, EMPTY, Acquire) == NOTIFIED {\n+            if self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Acquire).is_ok() {\n                 return;\n             } else {\n                 // Spurious wake up. We loop to try again."}, {"sha": "c8559d247282430981f82a7cdf39552f1b59792b", "filename": "src/test/ui/array-slice-vec/box-of-array-of-drop-1.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/src%2Ftest%2Fui%2Farray-slice-vec%2Fbox-of-array-of-drop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/src%2Ftest%2Fui%2Farray-slice-vec%2Fbox-of-array-of-drop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fbox-of-array-of-drop-1.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -17,7 +17,12 @@ impl Drop for D {\n     fn drop(&mut self) {\n         println!(\"Dropping {}\", self.0);\n         let old = LOG.load(Ordering::SeqCst);\n-        LOG.compare_and_swap(old, old << 4 | self.0 as usize, Ordering::SeqCst);\n+        let _ = LOG.compare_exchange(\n+            old,\n+            old << 4 | self.0 as usize,\n+            Ordering::SeqCst,\n+            Ordering::SeqCst\n+        );\n     }\n }\n "}, {"sha": "e75051caabcc32a69eccd57c3b66faa76c66bf51", "filename": "src/test/ui/array-slice-vec/box-of-array-of-drop-2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/src%2Ftest%2Fui%2Farray-slice-vec%2Fbox-of-array-of-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/src%2Ftest%2Fui%2Farray-slice-vec%2Fbox-of-array-of-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fbox-of-array-of-drop-2.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -17,7 +17,12 @@ impl Drop for D {\n     fn drop(&mut self) {\n         println!(\"Dropping {}\", self.0);\n         let old = LOG.load(Ordering::SeqCst);\n-        LOG.compare_and_swap(old, old << 4 | self.0 as usize, Ordering::SeqCst);\n+        let _ = LOG.compare_exchange(\n+            old,\n+            old << 4 | self.0 as usize,\n+            Ordering::SeqCst,\n+            Ordering::SeqCst\n+        );\n     }\n }\n "}, {"sha": "96497a53d308e4d66f36d1e4757e389e82b3e05a", "filename": "src/test/ui/array-slice-vec/nested-vec-3.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/src%2Ftest%2Fui%2Farray-slice-vec%2Fnested-vec-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eecd40e87cf7e77cee9cfdc79900c83baf6d8f/src%2Ftest%2Fui%2Farray-slice-vec%2Fnested-vec-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fnested-vec-3.rs?ref=87eecd40e87cf7e77cee9cfdc79900c83baf6d8f", "patch": "@@ -18,7 +18,12 @@ impl Drop for D {\n     fn drop(&mut self) {\n         println!(\"Dropping {}\", self.0);\n         let old = LOG.load(Ordering::SeqCst);\n-        LOG.compare_and_swap(old, old << 4 | self.0 as usize, Ordering::SeqCst);\n+        let _ = LOG.compare_exchange(\n+            old,\n+            old << 4 | self.0 as usize,\n+            Ordering::SeqCst,\n+            Ordering::SeqCst,\n+        );\n     }\n }\n "}]}