{"sha": "5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMGIwY2U2MWViZjBkYTE5ZDg5ZjFiZTdjY2VhNjdmNmNkMTI4YTc=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-10T23:21:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-10T23:21:19Z"}, "message": "Rollup merge of #55802 - wesleywiser:inlined_calls_2_electric_boogaloo, r=nagisa\n\nDon't inline virtual calls (take 2)\n\nWhen I fixed the previous mis-optimizations, I didn't realize there were\nactually two different places where we mutate `callsites` and both of\nthem should have the same behavior.\n\nAs a result, if a function was inlined and that function contained\nvirtual function calls, they were incorrectly being inlined. I also\nadded a test case which covers this.", "tree": {"sha": "3f040a23fb74bb89768b399b888e0d49749b84ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f040a23fb74bb89768b399b888e0d49749b84ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb52fvCRBK7hj4Ov3rIwAAdHIIAG2T2VjOVoj1UFjp4CGDknGZ\nd4xZ+uEr2xN1HX2O7SoAY8xInZ4Oqmg/3BkRevAM/NiOySY0hvXZnhCebxc8EYbf\noOLNYRmPoRr7tJS11yktxficNcxkZx5NcmuezdxuZWsOru88FAyznfxFQKp3qSIP\nltfWwIOQZK4Ojc3Mfl9pfOcJmlBxwMpl6v5IhOffMCuvqaw6Cyyu4YJla4SmhbbW\nOPnuoElpG9w91g/mULas8BmISK0mxdoACl5R0h4H0fzJGA+ELqwm3qGWm65+Hr8T\noON90W5gXitTLRlOQiCgp/8DXIiAr0Ov+FI8lAmJg//H0tFFFDL+gbRTvNdONPk=\n=cLpH\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f040a23fb74bb89768b399b888e0d49749b84ab\nparent 18195d413333d8d9ab5d1ed6a5af2993c0c8e5d8\nparent 3cce5c79778088a26f6099f293256d5d7834fdb3\nauthor Pietro Albini <pietro@pietroalbini.org> 1541892079 +0100\ncommitter GitHub <noreply@github.com> 1541892079 +0100\n\nRollup merge of #55802 - wesleywiser:inlined_calls_2_electric_boogaloo, r=nagisa\n\nDon't inline virtual calls (take 2)\n\nWhen I fixed the previous mis-optimizations, I didn't realize there were\nactually two different places where we mutate `callsites` and both of\nthem should have the same behavior.\n\nAs a result, if a function was inlined and that function contained\nvirtual function calls, they were incorrectly being inlined. I also\nadded a test case which covers this.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7", "html_url": "https://github.com/rust-lang/rust/commit/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18195d413333d8d9ab5d1ed6a5af2993c0c8e5d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/18195d413333d8d9ab5d1ed6a5af2993c0c8e5d8", "html_url": "https://github.com/rust-lang/rust/commit/18195d413333d8d9ab5d1ed6a5af2993c0c8e5d8"}, {"sha": "3cce5c79778088a26f6099f293256d5d7834fdb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cce5c79778088a26f6099f293256d5d7834fdb3", "html_url": "https://github.com/rust-lang/rust/commit/3cce5c79778088a26f6099f293256d5d7834fdb3"}], "stats": {"total": 130, "additions": 85, "deletions": 45}, "files": [{"sha": "1cce0de5152fda7bd649b1b92c80235f9a2958d6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Instance, InstanceDef, Ty, TyCtxt};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -85,39 +85,16 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir.as_local_node_id(self.source.def_id).unwrap();\n         let body_owner_kind = self.tcx.hir.body_owner_kind(id);\n+\n         if let (hir::BodyOwnerKind::Fn, None) = (body_owner_kind, self.source.promoted) {\n \n             for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n-                // Don't inline calls that are in cleanup blocks.\n-                if bb_data.is_cleanup { continue; }\n-\n-                // Only consider direct calls to functions\n-                let terminator = bb_data.terminator();\n-                if let TerminatorKind::Call {\n-                    func: ref op, .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n-                            if let Some(instance) = Instance::resolve(self.tcx,\n-                                                                      param_env,\n-                                                                      callee_def_id,\n-                                                                      substs) {\n-                                let is_virtual =\n-                                    if let InstanceDef::Virtual(..) = instance.def {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    };\n-\n-                                if !is_virtual {\n-                                    callsites.push_back(CallSite {\n-                                        callee: instance.def_id(),\n-                                        substs: instance.substs,\n-                                        bb,\n-                                        location: terminator.source_info\n-                                    });\n-                                }\n-                            }\n-                        }\n-                    }\n+                if let Some(callsite) = self.get_valid_function_call(bb,\n+                                                                     bb_data,\n+                                                                     caller_mir,\n+                                                                     param_env) {\n+                    callsites.push_back(callsite);\n+                }\n             }\n         } else {\n             return;\n@@ -163,20 +140,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n-                    // Only consider direct calls to functions\n-                    let terminator = bb_data.terminator();\n-                    if let TerminatorKind::Call {\n-                        func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n-                            // Don't inline the same function multiple times.\n-                            if callsite.callee != callee_def_id {\n-                                callsites.push_back(CallSite {\n-                                    callee: callee_def_id,\n-                                    substs,\n-                                    bb,\n-                                    location: terminator.source_info\n-                                });\n-                            }\n+                    if let Some(new_callsite) = self.get_valid_function_call(bb,\n+                                                                             bb_data,\n+                                                                             caller_mir,\n+                                                                             param_env) {\n+                        // Don't inline the same function multiple times.\n+                        if callsite.callee != new_callsite.callee {\n+                            callsites.push_back(new_callsite);\n                         }\n                     }\n                 }\n@@ -198,6 +168,40 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n+    fn get_valid_function_call(&self,\n+                               bb: BasicBlock,\n+                               bb_data: &BasicBlockData<'tcx>,\n+                               caller_mir: &Mir<'tcx>,\n+                               param_env: ParamEnv<'tcx>,\n+    ) -> Option<CallSite<'tcx>> {\n+        // Don't inline calls that are in cleanup blocks.\n+        if bb_data.is_cleanup { return None; }\n+\n+        // Only consider direct calls to functions\n+        let terminator = bb_data.terminator();\n+        if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n+            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n+                let instance = Instance::resolve(self.tcx,\n+                                                 param_env,\n+                                                 callee_def_id,\n+                                                 substs)?;\n+\n+                if let InstanceDef::Virtual(..) = instance.def {\n+                    return None;\n+                }\n+\n+                return Some(CallSite {\n+                    callee: instance.def_id(),\n+                    substs: instance.substs,\n+                    bb,\n+                    location: terminator.source_info\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn consider_optimizing(&self,\n                            callsite: CallSite<'tcx>,\n                            callee_mir: &Mir<'tcx>)"}, {"sha": "aa756f4a2337058da474c8484529e98fee5a653a", "filename": "src/test/mir-opt/inline-trait-method_2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method_2.rs?ref=5b0b0ce61ebf0da19d89f1be7ccea67f6cd128a7", "patch": "@@ -0,0 +1,36 @@\n+// compile-flags: -Z span_free_formats -Z mir-opt-level=3\n+\n+#[inline]\n+fn test(x: &dyn X) -> bool {\n+    x.y()\n+}\n+\n+fn test2(x: &dyn X) -> bool {\n+    test(x)\n+}\n+\n+trait X {\n+    fn y(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl X for () {\n+    fn y(&self) -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Should be true: {}\", test2(&()));\n+}\n+\n+// END RUST SOURCE\n+// START rustc.test2.Inline.after.mir\n+// ...\n+// bb0: {\n+// ...\n+//     _0 = const X::y(move _2) -> bb1;\n+// }\n+// ...\n+// END rustc.test2.Inline.after.mir"}]}