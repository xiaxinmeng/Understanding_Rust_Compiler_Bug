{"sha": "e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNTZiN2YwNDliNDRmYTY5N2I5ZjljNWU3NWI0NDMzYTdkOWZmZGY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-15T02:01:57Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-17T19:00:23Z"}, "message": "Replace TyDesc and its uses with trait vtables and a type_name intrinsic.", "tree": {"sha": "05ed074d9080f696cb047c6df587ceef976f6897", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05ed074d9080f696cb047c6df587ceef976f6897"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "html_url": "https://github.com/rust-lang/rust/commit/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "html_url": "https://github.com/rust-lang/rust/commit/3e98ab560a56492d70932066bb4d46f3a6a1bd4c"}], "stats": {"total": 393, "additions": 87, "deletions": 306}, "files": [{"sha": "fb858344b85d595c7f4746818df71e8217c8a9c7", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -42,8 +42,9 @@ extern crate alloc;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n+#[cfg(stage0)] // SNAP 270a677\n+use std::intrinsics::{get_tydesc, TyDesc};\n use std::marker;\n use std::mem;\n #[cfg(stage0)]\n@@ -186,6 +187,27 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n     ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n+// HACK(eddyb) TyDesc replacement using a trait object vtable.\n+// This could be replaced in the future with a custom DST layout,\n+// or `&'static (drop_glue, size, align)` created by a `const fn`.\n+#[cfg(not(stage0))] // SNAP 270a677\n+struct TyDesc {\n+    drop_glue: fn(*const i8),\n+    size: usize,\n+    align: usize\n+}\n+\n+#[cfg(not(stage0))] // SNAP 270a677\n+unsafe fn get_tydesc<T>() -> *const TyDesc {\n+    use std::raw::TraitObject;\n+\n+    let ptr = &*(1 as *const T);\n+\n+    // Can use any trait that is implemented for all types.\n+    let obj = mem::transmute::<&marker::MarkerTrait, TraitObject>(ptr);\n+    obj.vtable as *const TyDesc\n+}\n+\n impl<'longer_than_self> Arena<'longer_than_self> {\n     fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()"}, {"sha": "ead5da92bd90197b990e47bac0a11e2e613cbfaa", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -44,10 +44,12 @@\n \n use marker::Sized;\n \n+#[cfg(stage0)] // SNAP 270a677\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n #[derive(Copy)]\n+#[cfg(stage0)] // SNAP 270a677\n pub struct TyDesc {\n     // sizeof(T)\n     pub size: usize,\n@@ -197,8 +199,13 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> usize;\n \n     /// Get a static pointer to a type descriptor.\n+    #[cfg(stage0)] // SNAP 270a677\n     pub fn get_tydesc<T: ?Sized>() -> *const TyDesc;\n \n+    /// Gets a static string slice containing the name of a type.\n+    #[cfg(not(stage0))] // SNAP 270a677\n+    pub fn type_name<T: ?Sized>() -> &'static str;\n+\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in."}, {"sha": "73d31a1f6201d6c3a0baa006778cc13d89b8fdac", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -316,9 +316,6 @@ lets_do_this! {\n \n     StartFnLangItem,                 \"start\",                   start_fn;\n \n-    TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n-    OpaqueStructLangItem,            \"opaque\",                  opaque;\n-\n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n \n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;"}, {"sha": "3d70d95ef1476ff2bcd2b1c8bfb2a9614b625700", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -47,8 +47,7 @@ use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n-use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n-use middle::lang_items::{FnOnceTraitLangItem, TyDescStructLangItem};\n+use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -723,7 +722,6 @@ pub struct ctxt<'tcx> {\n     pub object_cast_map: ObjectCastMap<'tcx>,\n \n     pub map: ast_map::Map<'tcx>,\n-    pub intrinsic_defs: RefCell<DefIdMap<Ty<'tcx>>>,\n     pub freevars: RefCell<FreevarMap>,\n     pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n@@ -2575,7 +2573,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         super_predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n-        intrinsic_defs: RefCell::new(DefIdMap()),\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap()),\n         rcache: RefCell::new(FnvHashMap()),\n@@ -5951,13 +5948,6 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n         .collect()\n }\n \n-pub fn get_tydesc_ty<'tcx>(tcx: &ctxt<'tcx>) -> Result<Ty<'tcx>, String> {\n-    tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n-        tcx.intrinsic_defs.borrow().get(&tydesc_lang_item).cloned()\n-            .expect(\"Failed to resolve TyDesc\")\n-    })\n-}\n-\n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),"}, {"sha": "5f2803835d5d3b67d32af8d38adb910706f13ecd", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -57,8 +57,7 @@ use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n-use trans::common::{tydesc_info, type_is_immediate};\n-use trans::common::{type_is_zero_size, val_ty};\n+use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n use trans::consts;\n use trans::context::SharedCrateContext;\n@@ -90,7 +89,6 @@ use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::mem;\n-use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n@@ -392,22 +390,6 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-// Type descriptor and type glue stuff\n-\n-pub fn get_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            t: Ty<'tcx>) -> Rc<tydesc_info<'tcx>> {\n-    match ccx.tydescs().borrow().get(&t) {\n-        Some(inf) => return inf.clone(),\n-        _ => { }\n-    }\n-\n-    ccx.stats().n_static_tydescs.set(ccx.stats().n_static_tydescs.get() + 1);\n-    let inf = Rc::new(glue::declare_tydesc(ccx, t));\n-\n-    ccx.tydescs().borrow_mut().insert(t, inf.clone());\n-    inf\n-}\n-\n #[allow(dead_code)] // useful\n pub fn set_optimize_for_size(f: ValueRef) {\n     llvm::SetFunctionAttribute(f, llvm::OptimizeForSizeAttribute)\n@@ -3137,7 +3119,6 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     }\n \n     for ccx in shared_ccx.iter() {\n-        glue::emit_tydescs(&ccx);\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n@@ -3149,7 +3130,6 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n-        println!(\"n_static_tydescs: {}\", stats.n_static_tydescs.get());\n         println!(\"n_glues_created: {}\", stats.n_glues_created.get());\n         println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n         println!(\"n_real_glues: {}\", stats.n_real_glues.get());"}, {"sha": "941ac5d627f3b5a88ea6e0ff228151a8b8f092ee", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -316,15 +316,6 @@ pub fn gensym_name(name: &str) -> PathElem {\n     PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n }\n \n-#[derive(Copy)]\n-pub struct tydesc_info<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub tydesc: ValueRef,\n-    pub size: ValueRef,\n-    pub align: ValueRef,\n-    pub name: ValueRef,\n-}\n-\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *"}, {"sha": "6614d538971ddc1c7cc8a74bc9abff22841d24b1", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -18,7 +18,7 @@ use middle::traits;\n use trans::adt;\n use trans::base;\n use trans::builder::Builder;\n-use trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n+use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n@@ -38,7 +38,6 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct Stats {\n-    pub n_static_tydescs: Cell<uint>,\n     pub n_glues_created: Cell<uint>,\n     pub n_null_glues: Cell<uint>,\n     pub n_real_glues: Cell<uint>,\n@@ -89,10 +88,6 @@ pub struct LocalCrateContext<'tcx> {\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    tydescs: RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>>,\n-    /// Set when running emit_tydescs to enforce that no more tydescs are\n-    /// created.\n-    finished_tydescs: Cell<bool>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -264,7 +259,6 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             stats: Stats {\n-                n_static_tydescs: Cell::new(0),\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n                 n_real_glues: Cell::new(0),\n@@ -399,8 +393,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n-                tydescs: RefCell::new(FnvHashMap()),\n-                finished_tydescs: Cell::new(false),\n                 external: RefCell::new(DefIdMap()),\n                 external_srcs: RefCell::new(NodeMap()),\n                 monomorphized: RefCell::new(FnvHashMap()),\n@@ -442,8 +434,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 str_slice_ty.set_struct_body(&[Type::i8p(&ccx), ccx.int_type()], false);\n                 ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n \n-                ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n-\n                 if ccx.sess().count_llvm_insns() {\n                     base::init_insn_ctxt()\n                 }\n@@ -519,10 +509,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.builder.b\n     }\n \n-    pub fn tydesc_type(&self) -> Type {\n-        self.local.tn.find_type(\"tydesc\").unwrap()\n-    }\n-\n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n         if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n             return v;\n@@ -590,14 +576,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.drop_glues\n     }\n \n-    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>> {\n-        &self.local.tydescs\n-    }\n-\n-    pub fn finished_tydescs<'a>(&'a self) -> &'a Cell<bool> {\n-        &self.local.finished_tydescs\n-    }\n-\n     pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n         &self.local.external\n     }"}, {"sha": "b2de8435f641bd5c4e8d6340ba27379805ee4a43", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 39, "deletions": 148, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -10,12 +10,12 @@\n \n //!\n //\n-// Code relating to taking, dropping, etc as well as type descriptors.\n+// Code relating to drop glue.\n \n \n use back::abi;\n use back::link::*;\n-use llvm::{ValueRef, True, get_param};\n+use llvm::{ValueRef, get_param};\n use llvm;\n use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n@@ -26,23 +26,20 @@ use trans::build::*;\n use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n-use trans::consts;\n use trans::common::*;\n use trans::datum;\n use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::machine::*;\n use trans::type_::Type;\n-use trans::type_of::{self, type_of, sizing_type_of, align_of};\n+use trans::type_of::{type_of, sizing_type_of, align_of};\n use middle::ty::{self, Ty};\n use util::ppaux::{ty_to_short_str, Repr};\n use util::ppaux;\n \n use arena::TypedArena;\n use libc::c_uint;\n-use std::ffi::CString;\n use syntax::ast;\n-use syntax::parse::token;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n@@ -177,31 +174,46 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let llfnty = Type::glue_fn(ccx, llty);\n \n-    let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n-        Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, &old_sym[..], llfnty, ty::mk_nil(ccx.tcx()));\n-            (glue, None)\n-        },\n-        None => {\n-            let (sym, glue) = declare_generic_glue(ccx, t, llfnty, \"drop\");\n-            (glue, Some(sym))\n-        },\n+    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n+    // added the entry to the `drop_glues` cache.\n+    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n+        let llfn = decl_cdecl_fn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n+        ccx.drop_glues().borrow_mut().insert(t, llfn);\n+        return llfn;\n     };\n \n-    ccx.drop_glues().borrow_mut().insert(t, glue);\n+    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n+    let llfn = decl_cdecl_fn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx()));\n+    note_unique_llvm_symbol(ccx, fn_nm.clone());\n+    ccx.available_drop_glues().borrow_mut().insert(t, fn_nm);\n \n-    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n-    // added the entry to the `drop_glues` cache.\n-    match new_sym {\n-        Some(sym) => {\n-            ccx.available_drop_glues().borrow_mut().insert(t, sym);\n-            // We're creating a new drop glue, so also generate a body.\n-            make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n-        },\n-        None => {},\n-    }\n+    let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n+\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n+                      empty_substs, None, &arena);\n+\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+\n+    update_linkage(ccx, llfn, None, OriginalTranslation);\n+\n+    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n+    // All glue functions take values passed *by alias*; this is a\n+    // requirement since in many contexts glue is invoked indirectly and\n+    // the caller has no idea if it's dealing with something that can be\n+    // passed by value.\n+    //\n+    // llfn is expected be declared to take a parameter of the appropriate\n+    // type, so we don't need to explicitly cast the function parameter.\n+\n+    let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n+    let bcx = make_drop_glue(bcx, llrawptr0, t);\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n-    glue\n+    llfn\n }\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n@@ -467,124 +479,3 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n     }\n }\n-\n-// Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n-                                -> tydesc_info<'tcx> {\n-    // If emit_tydescs already ran, then we shouldn't be creating any new\n-    // tydescs.\n-    assert!(!ccx.finished_tydescs().get());\n-\n-    // This really shouldn't be like this, size/align will be wrong for\n-    // unsized types (i.e. [T] will have the size/align of T).\n-    // But we need it until we split this out into a \"type name\" intrinsic.\n-    let llty = type_of::in_memory_type_of(ccx, t);\n-\n-    if ccx.sess().count_type_sizes() {\n-        println!(\"{}\\t{}\", llsize_of_real(ccx, llty),\n-                 ppaux::ty_to_string(ccx.tcx(), t));\n-    }\n-\n-    let llsize = llsize_of(ccx, llty);\n-    let llalign = llalign_of(ccx, llty);\n-    let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n-    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let buf = CString::new(name.clone()).unwrap();\n-    let gvar = unsafe {\n-        llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(),\n-                            buf.as_ptr())\n-    };\n-    note_unique_llvm_symbol(ccx, name);\n-\n-    let ty_name = token::intern_and_get_ident(\n-        &ppaux::ty_to_string(ccx.tcx(), t));\n-    let ty_name = C_str_slice(ccx, ty_name);\n-\n-    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    tydesc_info {\n-        ty: t,\n-        tydesc: gvar,\n-        size: llsize,\n-        align: llalign,\n-        name: ty_name,\n-    }\n-}\n-\n-fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                                  llfnty: Type, name: &str) -> (String, ValueRef) {\n-    let _icx = push_ctxt(\"declare_generic_glue\");\n-    let fn_nm = mangle_internal_name_by_type_and_seq(\n-        ccx,\n-        t,\n-        &format!(\"glue_{}\", name));\n-    let llfn = decl_cdecl_fn(ccx, &fn_nm[..], llfnty, ty::mk_nil(ccx.tcx()));\n-    note_unique_llvm_symbol(ccx, fn_nm.clone());\n-    return (fn_nm, llfn);\n-}\n-\n-fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n-                                  t: Ty<'tcx>,\n-                                  llfn: ValueRef,\n-                                  helper: F,\n-                                  name: &str)\n-                                  -> ValueRef where\n-    F: for<'blk> FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n-{\n-    let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n-    let _s = StatRecorder::new(ccx, glue_name);\n-\n-    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n-                      empty_substs, None, &arena);\n-\n-    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n-\n-    update_linkage(ccx, llfn, None, OriginalTranslation);\n-\n-    ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n-    // All glue functions take values passed *by alias*; this is a\n-    // requirement since in many contexts glue is invoked indirectly and\n-    // the caller has no idea if it's dealing with something that can be\n-    // passed by value.\n-    //\n-    // llfn is expected be declared to take a parameter of the appropriate\n-    // type, so we don't need to explicitly cast the function parameter.\n-\n-    let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n-    let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n-\n-    llfn\n-}\n-\n-pub fn emit_tydescs(ccx: &CrateContext) {\n-    let _icx = push_ctxt(\"emit_tydescs\");\n-    // As of this point, allow no more tydescs to be created.\n-    ccx.finished_tydescs().set(true);\n-    let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    for (_, ti) in &*ccx.tydescs().borrow() {\n-        // Each of the glue functions needs to be cast to a generic type\n-        // before being put into the tydesc because we only have a singleton\n-        // tydesc type. Then we'll recast each function to its real type when\n-        // calling it.\n-        let drop_glue = consts::ptrcast(get_drop_glue(ccx, ti.ty), glue_fn_ty);\n-        ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n-\n-        let tydesc = C_named_struct(ccx.tydesc_type(),\n-                                    &[ti.size, // size\n-                                      ti.align, // align\n-                                      drop_glue, // drop_glue\n-                                      ti.name]); // name\n-\n-        unsafe {\n-            let gvar = ti.tydesc;\n-            llvm::LLVMSetInitializer(gvar, tydesc);\n-            llvm::LLVMSetGlobalConstant(gvar, True);\n-            llvm::SetLinkage(gvar, llvm::InternalLinkage);\n-        }\n-    };\n-}"}, {"sha": "69ca9a5e81cbc81b933e4ac5ed62022cdb261787", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -347,15 +347,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx = src.store_to(bcx, llargs[0]);\n             C_nil(ccx)\n         }\n-        (_, \"get_tydesc\") => {\n+        (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let static_ti = get_tydesc(ccx, tp_ty);\n-\n-            // FIXME (#3730): ideally this shouldn't need a cast,\n-            // but there's a circularity between translating rust types to llvm\n-            // types and having a tydesc type available. So I can't directly access\n-            // the llvm type of intrinsic::TyDesc struct.\n-            PointerCast(bcx, static_ti.tydesc, llret_ty)\n+            let ty_name = token::intern_and_get_ident(&ty_to_string(ccx.tcx(), tp_ty));\n+            C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n             let hash = ty::hash_crate_independent("}, {"sha": "9b17c4f8baac9818afe039966f0767c88757ed13", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -12,9 +12,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use llvm;\n-use llvm::{ValueRef};\n-use llvm::False;\n+use llvm::{self, ValueRef};\n use trans::common::*;\n \n use trans::type_::Type;\n@@ -101,16 +99,6 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n     }\n }\n \n-// Returns the \"default\" alignment of t, which is calculated by casting\n-// null to a record containing a single-bit followed by a t value, then\n-// doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n-pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n-    unsafe {\n-        return llvm::LLVMConstIntCast(\n-            llvm::LLVMAlignOf(ty.to_ref()), cx.int_type().to_ref(), False);\n-    }\n-}\n-\n pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n     unsafe {\n         return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),"}, {"sha": "dcb57fd9cdebd8ebd0406cac204ed6f70dad255b", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -175,41 +175,10 @@ impl Type {\n         Type::array(&Type::i8p(ccx).ptr_to(), 1)\n     }\n \n-    pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n-        match cx.tn().find_type(\"glue_fn\") {\n-            Some(ty) => return ty,\n-            None => ()\n-        }\n-\n-        let ty = Type::glue_fn(cx, Type::i8p(cx));\n-        cx.tn().associate_type(\"glue_fn\", &ty);\n-\n-        ty\n-    }\n-\n     pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n         Type::func(&[t], &Type::void(ccx))\n     }\n \n-    pub fn tydesc(ccx: &CrateContext, str_slice_ty: Type) -> Type {\n-        let mut tydesc = Type::named_struct(ccx, \"tydesc\");\n-        let glue_fn_ty = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to();\n-\n-        let int_ty = Type::int(ccx);\n-\n-        // Must mirror:\n-        //\n-        // std::unstable::intrinsics::TyDesc\n-\n-        let elems = [int_ty,     // size\n-                     int_ty,     // align\n-                     glue_fn_ty, // drop\n-                     str_slice_ty]; // name\n-        tydesc.set_struct_body(&elems, false);\n-\n-        tydesc\n-    }\n-\n     pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n     }"}, {"sha": "de0978bc40957d74847252720f644695a16d5294", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -5347,17 +5347,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n             \"owns_managed\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n-            \"get_tydesc\" => {\n-              let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n-                  Ok(t) => t,\n-                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[..]); }\n-              };\n-              let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n-                  ty: tydesc_ty,\n-                  mutbl: ast::MutImmutable\n-              });\n-              (1, Vec::new(), td_ptr)\n-            }\n+            \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),\n+                                                             ast::MutImmutable)),\n             \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n             \"offset\" => {\n               (1,"}, {"sha": "97cc3ac7c48a78aa2a79c1051be851fbf0e93b5e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -102,15 +102,6 @@ use syntax::visit;\n pub fn collect_item_types(tcx: &ty::ctxt) {\n     let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n \n-    match ccx.tcx.lang_items.ty_desc() {\n-        Some(id) => { collect_intrinsic_type(ccx, id); }\n-        None => {}\n-    }\n-    match ccx.tcx.lang_items.opaque() {\n-        Some(id) => { collect_intrinsic_type(ccx, id); }\n-        None => {}\n-    }\n-\n     let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n     visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n \n@@ -152,15 +143,6 @@ enum AstConvRequest {\n     GetTypeParameterBounds(ast::NodeId),\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Zeroth phase: collect types of intrinsics\n-\n-fn collect_intrinsic_type(ccx: &CrateCtxt,\n-                          lang_item: ast::DefId) {\n-    let ty::TypeScheme { ty, .. } = type_scheme_of_def_id(ccx, lang_item);\n-    ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // First phase: just collect *trait definitions* -- basically, the set\n // of type parameters and supertraits. This is information we need to"}, {"sha": "e53fe3c44a28e8dd3b3513690093a22a35494960", "filename": "src/test/run-pass/issue-21058.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -13,17 +13,17 @@ struct NT(str);\n struct DST { a: u32, b: str }\n \n fn main() {\n-    // get_tydesc should support unsized types\n+    // type_name should support unsized types\n     assert_eq!(unsafe {(\n         // Slice\n-        (*std::intrinsics::get_tydesc::<[u8]>()).name,\n+        std::intrinsics::type_name::<[u8]>(),\n         // str\n-        (*std::intrinsics::get_tydesc::<str>()).name,\n+        std::intrinsics::type_name::<str>(),\n         // Trait\n-        (*std::intrinsics::get_tydesc::<Copy>()).name,\n+        std::intrinsics::type_name::<Copy>(),\n         // Newtype\n-        (*std::intrinsics::get_tydesc::<NT>()).name,\n+        std::intrinsics::type_name::<NT>(),\n         // DST\n-        (*std::intrinsics::get_tydesc::<DST>()).name\n+        std::intrinsics::type_name::<DST>()\n     )}, (\"[u8]\", \"str\", \"core::marker::Copy\", \"NT\", \"DST\"));\n }"}, {"sha": "2e7717fcfe15463e2bce6f36b2570dfd184c95a2", "filename": "src/test/run-pass/tydesc-name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftydesc-name.rs?ref=e256b7f049b44fa697b9f9c5e75b4433a7d9ffdf", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n \n-use std::intrinsics::get_tydesc;\n+use std::intrinsics::type_name;\n \n struct Foo<T> {\n     x: T\n }\n \n pub fn main() {\n     unsafe {\n-        assert_eq!((*get_tydesc::<int>()).name, \"isize\");\n-        assert_eq!((*get_tydesc::<Foo<uint>>()).name, \"Foo<usize>\");\n+        assert_eq!(type_name::<int>(), \"isize\");\n+        assert_eq!(type_name::<Foo<uint>>(), \"Foo<usize>\");\n     }\n }"}]}