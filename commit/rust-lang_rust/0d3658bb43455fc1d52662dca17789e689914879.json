{"sha": "0d3658bb43455fc1d52662dca17789e689914879", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzY1OGJiNDM0NTVmYzFkNTI2NjJkY2ExNzc4OWU2ODk5MTQ4Nzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-20T22:46:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-23T15:02:58Z"}, "message": "rewrite the resolution infrastructure; but it's still grody", "tree": {"sha": "5c360a8c02b66922ee421104441fd6dfe96f79f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c360a8c02b66922ee421104441fd6dfe96f79f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d3658bb43455fc1d52662dca17789e689914879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3658bb43455fc1d52662dca17789e689914879", "html_url": "https://github.com/rust-lang/rust/commit/0d3658bb43455fc1d52662dca17789e689914879", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d3658bb43455fc1d52662dca17789e689914879/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68f88125115fb239c79efa655570fdcae821765c", "url": "https://api.github.com/repos/rust-lang/rust/commits/68f88125115fb239c79efa655570fdcae821765c", "html_url": "https://github.com/rust-lang/rust/commit/68f88125115fb239c79efa655570fdcae821765c"}], "stats": {"total": 383, "additions": 227, "deletions": 156}, "files": [{"sha": "a3a889d94dafda60694658342fe2c4813bda3c32", "filename": "src/libcore/result.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d3658bb43455fc1d52662dca17789e689914879/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3658bb43455fc1d52662dca17789e689914879/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0d3658bb43455fc1d52662dca17789e689914879", "patch": "@@ -142,7 +142,9 @@ checking for overflow:\n         assert incd == [2u, 3u, 4u];\n     }\n \"]\n-fn map<T,U:copy,V:copy>(ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n+fn map<T,U:copy,V:copy>(\n+    ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n+\n     let mut vs: [V] = [];\n     vec::reserve(vs, vec::len(ts));\n     for vec::each(ts) {|t|\n@@ -154,6 +156,20 @@ fn map<T,U:copy,V:copy>(ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n     ret ok(vs);\n }\n \n+fn map_opt<T,U:copy,V:copy>(\n+    o_t: option<T>, op: fn(T) -> result<V,U>) -> result<option<V>,U> {\n+\n+    alt o_t {\n+      none { ok(none) }\n+      some(t) {\n+        alt op(t) {\n+          ok(v) { ok(some(v)) }\n+          err(e) { err(e) }\n+        }\n+      }\n+    }\n+}\n+\n #[doc = \"Same as map, but it operates over two parallel vectors.\n \n A precondition is used here to ensure that the vectors are the same"}, {"sha": "9443cac0ea2a8f3ee94f379cfca8dda939eb7e3a", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 138, "deletions": 123, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/0d3658bb43455fc1d52662dca17789e689914879/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3658bb43455fc1d52662dca17789e689914879/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=0d3658bb43455fc1d52662dca17789e689914879", "patch": "@@ -17,9 +17,9 @@ export new_infer_ctxt;\n export mk_subty;\n export mk_eqty;\n export mk_assignty;\n-export resolve_type_structure;\n-export fixup_vars;\n-export resolve_var;\n+export resolve_shallow;\n+export resolve_deep;\n+export resolve_deep_var;\n export compare_tys;\n export fixup_err, fixup_err_to_str;\n \n@@ -92,16 +92,23 @@ fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     mk_eqty(infcx, a, b)\n }\n \n-fn resolve_type_structure(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n-    cx.resolve_ty(a)\n+// Resolves one level of type structure but not any type variables\n+// that may be nested within.\n+fn resolve_shallow(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n+    resolver(cx, false, false).resolve(a)\n }\n \n-fn resolve_var(cx: infer_ctxt, vid: ty_vid) -> fres<ty::t> {\n-    cx.fixup_ty(ty::mk_var(cx.tcx, vid))\n+// see resolve_deep()\n+fn resolve_deep_var(cx: infer_ctxt, vid: ty_vid,\n+                    force_vars: bool) -> fres<ty::t> {\n+    resolver(cx, true, force_vars).resolve(ty::mk_var(cx.tcx, vid))\n }\n \n-fn fixup_vars(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n-    cx.fixup_ty(a)\n+// Resolves all levels of type structure.  If `force_vars` is true,\n+// then we will resolve unconstrained type/region variables to\n+// something arbitrary.  Otherwise, we preserve them as variables.\n+fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: bool) -> fres<ty::t> {\n+    resolver(cx, true, force_vars).resolve(a)\n }\n \n impl methods for ures {\n@@ -555,141 +562,149 @@ impl unify_methods for infer_ctxt {\n     }\n }\n \n-impl resolve_methods for infer_ctxt {\n-    fn rok(t: ty::t) -> fres<ty::t> {\n-        #debug[\"Resolve OK: %s\", t.to_str(self)];\n-        ok(t)\n-    }\n-\n-    fn rerr<T>(v: fixup_err) -> fres<T> {\n-        #debug[\"Resolve error: %?\", v];\n-        err(v)\n-    }\n+// Resolution is the process of removing type variables and replacing\n+// them with their inferred values.  There are several \"modes\" for\n+// resolution.  The first is a shallow resolution: this only resolves\n+// one layer, but does not resolve any nested variables.  So, for\n+// example, if we have two variables A and B, and the constraint that\n+// A <: [B] and B <: int, then shallow resolution on A would yield\n+// [B].  Deep resolution, on the other hand, would yield [int].\n+//\n+// But there is one more knob: the force_vars variable controls the\n+// behavior in the face of unconstrained variables.  If we have A, B\n+// and only the constraint that A <: B, then the result is [_|_] if\n+// force_vars is true and [B] otherwise.  We use force_vars == true\n+// when resolving types after typeck, but false otherwise (for\n+// example, when pretty-printing them for errors).\n+\n+type resolve_state = @{\n+    infcx: infer_ctxt,\n+    deep: bool,\n+    force_vars: bool,\n+    mut err: option<fixup_err>,\n+    mut r_seen: [region_vid],\n+    mut v_seen: [ty_vid]\n+};\n \n-    fn resolve_var<V: copy vid, T:copy to_str>(\n-        vb: vals_and_bindings<V, T>, bot_guard: fn(T)->bool,\n-        vid: V, unbound: fn() -> fres<T>) -> fres<T> {\n+fn resolver(infcx: infer_ctxt, deep: bool, fvars: bool) -> resolve_state {\n+    @{infcx: infcx,\n+      deep: deep,\n+      force_vars: fvars,\n+      mut err: none,\n+      mut r_seen: [],\n+      mut v_seen: []}\n+}\n \n-        let {root:_, bounds} = self.get(vb, vid);\n+impl methods for resolve_state {\n+    fn resolve(typ: ty::t) -> fres<ty::t> {\n+        self.err = none;\n \n-        #debug[\"resolve_var(%s) bounds=%s\",\n-               vid.to_str(), bounds.to_str(self)];\n+        // n.b. This is a hokey mess because the current fold doesn't\n+        // allow us to pass back errors in any useful way.\n \n-        // Nonobvious: prefer the most specific type\n-        // (i.e., the lower bound) to the more general\n-        // one.  More general types in Rust (e.g., fn())\n-        // tend to carry more restrictions or higher\n-        // perf. penalties, so it pays to know more.\n-\n-        alt bounds {\n-          { ub:_, lb:some(t) } if !bot_guard(t) { ok(t) }\n-          { ub:some(t), lb:_ } { ok(t) }\n-          { ub:_, lb:some(t) } { ok(t) }\n-          { ub:none, lb:none } { unbound() }\n+        assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n+        let rty = self.resolve1(typ);\n+        assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n+        alt self.err {\n+          none {\n+            #debug[\"Resolved %s to %s (deep=%b, force_vars=%b)\",\n+                   ty_to_str(self.infcx.tcx, typ),\n+                   ty_to_str(self.infcx.tcx, rty),\n+                   self.deep,\n+                   self.force_vars];\n+            ret ok(rty);\n+          }\n+          some(e) { ret err(e); }\n         }\n     }\n \n-    fn resolve_ty_var(vid: ty_vid) -> fres<ty::t> {\n-        ret self.resolve_var(\n-            self.vb,\n-            {|t| type_is_bot(t) },\n-            vid,\n-            {|| ok(ty::mk_bot(self.tcx)) });\n-    }\n-\n-    fn resolve_region_var(rid: region_vid) -> fres<ty::region> {\n-        ret self.resolve_var(\n-            self.rb,\n-            {|_t| false },\n-            rid,\n-            {|| ok(ty::re_static) });\n-    }\n-\n-    fn resolve_ty(typ: ty::t) -> fres<ty::t> {\n-        alt ty::get(typ).struct {\n+    fn resolve1(typ: ty::t) -> ty::t {\n+        let tb = ty::get(typ);\n+        alt tb.struct {\n           ty::ty_var(vid) { self.resolve_ty_var(vid) }\n-          ty::ty_rptr(ty::re_var(rid), base_ty) {\n-            alt self.resolve_region_var(rid) {\n-              err(terr)  { err(terr) }\n-              ok(region) {\n-                self.rok(ty::mk_rptr(self.tcx, region, base_ty))\n-              }\n-            }\n+          _ if !tb.has_regions && !self.deep { typ }\n+          _ {\n+            ty::fold_regions_and_ty(\n+                self.infcx.tcx, typ,\n+                { |r| self.resolve_region(r) },\n+                { |t| self.resolve_if_deep(t) },\n+                { |t| self.resolve_if_deep(t) })\n           }\n-          _ { self.rok(typ) }\n         }\n     }\n \n-    fn fixup_region(r: ty::region,\n-                    &r_seen: [region_vid],\n-                    err: @mut option<fixup_err>) -> ty::region {\n-        alt r {\n-          ty::re_var(rid) if vec::contains(r_seen, rid) {\n-            *err = some(cyclic_region(rid)); r\n-          }\n+    fn resolve_if_deep(typ: ty::t) -> ty::t {\n+        if !self.deep {typ} else {self.resolve1(typ)}\n+    }\n \n-          ty::re_var(rid) {\n-            alt self.resolve_region_var(rid) {\n-              result::ok(r1) {\n-                vec::push(r_seen, rid);\n-                let r2 = self.fixup_region(r1, r_seen, err);\n-                vec::pop(r_seen);\n-                ret r2;\n-              }\n-              result::err(e) { *err = some(e); r }\n-            }\n-          }\n+    fn resolve_region(orig: ty::region) -> ty::region {\n+        alt orig {\n+          ty::re_var(rid) { self.resolve_region_var(rid) }\n+          _ { orig }\n+        }\n+    }\n \n-          _ { r }\n+    fn resolve_region_var(rid: region_vid) -> ty::region {\n+        if vec::contains(self.r_seen, rid) {\n+            self.err = some(cyclic_region(rid));\n+            ret ty::re_var(rid);\n+        } else {\n+            vec::push(self.r_seen, rid);\n+            let r = self.resolve_var(\n+                self.infcx.rb,\n+                {|_t| false },\n+                rid,\n+                {||\n+                    if self.force_vars {ty::re_static}\n+                    else {ty::re_var(rid)}\n+                });\n+            vec::pop(self.r_seen);\n+            ret r;\n+        }\n+    }\n+\n+    fn resolve_ty_var(vid: ty_vid) -> ty::t {\n+        if vec::contains(self.v_seen, vid) {\n+            self.err = some(cyclic_ty(vid));\n+            ret ty::mk_var(self.infcx.tcx, vid);\n+        } else {\n+            vec::push(self.v_seen, vid);\n+            let tcx = self.infcx.tcx;\n+            let t0 = self.resolve_var(\n+                self.infcx.vb,\n+                {|t| type_is_bot(t) },\n+                vid,\n+                {||\n+                    if self.force_vars {ty::mk_bot(tcx)}\n+                    else {ty::mk_var(tcx, vid)}\n+                });\n+            let t1 = self.resolve1(t0);\n+            vec::pop(self.v_seen);\n+            ret t1;\n         }\n     }\n \n-    fn fixup_ty1(ty: ty::t,\n-                 &ty_seen: [ty_vid],\n-                 &r_seen: [region_vid],\n-                 err: @mut option<fixup_err>) -> ty::t {\n-        let tb = ty::get(ty);\n-        if !tb.has_vars { ret ty; }\n-        alt tb.struct {\n-          ty::ty_var(vid) if vec::contains(ty_seen, vid) {\n-            *err = some(cyclic_ty(vid)); ty\n-          }\n+    fn resolve_var<V: copy vid, T:copy to_str>(\n+        vb: vals_and_bindings<V, T>, bot_guard: fn(T)->bool,\n+        vid: V, unbound: fn() -> T) -> T {\n \n-          ty::ty_var(vid) {\n-            alt self.resolve_ty_var(vid) {\n-              result::err(e) { *err = some(e); ty }\n-              result::ok(ty1) {\n-                vec::push(ty_seen, vid);\n-                let ty2 = self.fixup_ty1(ty1, ty_seen, r_seen, err);\n-                vec::pop(ty_seen);\n-                ret ty2;\n-              }\n-            }\n-          }\n+        let {root:_, bounds} = self.infcx.get(vb, vid);\n \n-          ty::ty_rptr(r, {ty: base_ty, mutbl: m}) {\n-            let base_ty1 = self.fixup_ty1(base_ty, ty_seen, r_seen, err);\n-            let r1 = self.fixup_region(r, r_seen, err);\n-            ret ty::mk_rptr(self.tcx, r1, {ty: base_ty1, mutbl: m});\n-          }\n+        #debug[\"resolve_var(%s) bounds=%s\",\n+               vid.to_str(),\n+               bounds.to_str(self.infcx)];\n \n-          sty {\n-            ty::fold_sty_to_ty(self.tcx, sty) {|t|\n-                self.fixup_ty1(t, ty_seen, r_seen, err)\n-            }\n-          }\n-        }\n-    }\n+        // Nonobvious: prefer the most specific type\n+        // (i.e., the lower bound) to the more general\n+        // one.  More general types in Rust (e.g., fn())\n+        // tend to carry more restrictions or higher\n+        // perf. penalties, so it pays to know more.\n \n-    fn fixup_ty(typ: ty::t) -> fres<ty::t> {\n-        #debug[\"fixup_ty(%s)\", ty_to_str(self.tcx, typ)];\n-        let mut ty_seen = [];\n-        let mut r_seen = [];\n-        let unresolved = @mut none;\n-        let rty = self.fixup_ty1(typ, ty_seen, r_seen, unresolved);\n-        alt *unresolved {\n-          none { ret self.rok(rty); }\n-          some(e) { ret self.rerr(e); }\n+        alt bounds {\n+          { ub:_, lb:some(t) } if !bot_guard(t) { t }\n+          { ub:some(t), lb:_ } { t }\n+          { ub:_, lb:some(t) } { t }\n+          { ub:none, lb:none } { unbound() }\n         }\n     }\n }"}, {"sha": "107ea65e1d9d083145d759e5f05b4f0a85a89cf1", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d3658bb43455fc1d52662dca17789e689914879/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3658bb43455fc1d52662dca17789e689914879/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0d3658bb43455fc1d52662dca17789e689914879", "patch": "@@ -37,6 +37,7 @@ export expr_ty_params_and_ty;\n export expr_is_lval;\n export field_ty;\n export fold_ty, fold_sty_to_ty, fold_region, fold_regions, fold_ty_var;\n+export fold_regions_and_ty;\n export field;\n export field_idx;\n export get_field;\n@@ -147,6 +148,7 @@ export item_path_str;\n export ast_ty_to_ty_cache_entry;\n export atttce_unresolved, atttce_resolved;\n export mach_sty;\n+export ty_sort_str;\n \n // Data types\n "}, {"sha": "3cfcb73e9ca903dfda3b6969b6f20ed11f9b8b6e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 70, "deletions": 32, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0d3658bb43455fc1d52662dca17789e689914879/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3658bb43455fc1d52662dca17789e689914879/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=0d3658bb43455fc1d52662dca17789e689914879", "patch": "@@ -12,7 +12,8 @@ import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import middle::ty::{ty_vid, region_vid, vid};\n-import util::ppaux::{ty_to_str, region_to_str};\n+import util::ppaux::{ty_to_str, region_to_str,\n+                     bound_region_to_str, vstore_to_str};\n import std::smallintmap;\n import std::smallintmap::map;\n import std::map;\n@@ -257,7 +258,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n // Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt infer::resolve_type_structure(fcx.infcx, tp) {\n+    alt infer::resolve_shallow(fcx.infcx, tp) {\n       // note: the bot type doesn't count as resolved; it's what we use when\n       // there is no information about a variable.\n       result::ok(t_s) if !ty::type_is_bot(t_s) { ret t_s; }\n@@ -274,17 +275,6 @@ fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n     ty::get(structurally_resolved_type(fcx, sp, typ)).struct\n }\n \n-// Returns the one-level-deep structure of the given type or none if it\n-// is not known yet.\n-fn structure_of_maybe(fcx: @fn_ctxt, _sp: span, typ: ty::t) ->\n-   option<ty::sty> {\n-    let r = infer::resolve_type_structure(fcx.infcx, typ);\n-    alt r {\n-      result::ok(typ_s) { some(ty::get(typ_s).struct) }\n-      result::err(_) { none }\n-    }\n-}\n-\n fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     ret ty::type_is_integral(typ_s);\n@@ -523,18 +513,60 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ret ty;\n     }\n \n-    fn mk_vstore<AC: ast_conv, RS: region_scope copy>(\n+    fn mk_bounded<AC: ast_conv, RS: region_scope copy>(\n         self: AC, rscope: RS, a_seq_ty: @ast::ty, vst: ty::vstore) -> ty::t {\n \n         let tcx = self.tcx();\n         let seq_ty = ast_ty_to_ty(self, rscope, a_seq_ty);\n+\n         alt ty::get(seq_ty).struct {\n-          ty::ty_vec(mt) { ty::mk_evec(tcx, mt, vst) }\n-          ty::ty_str { ty::mk_estr(tcx, vst) }\n+          ty::ty_vec(mt) {\n+            ret ty::mk_evec(tcx, mt, vst);\n+          }\n+\n+          ty::ty_str {\n+            ret ty::mk_estr(tcx, vst);\n+          }\n+\n+          ty::ty_enum(_, subst) |\n+          ty::ty_class(_, subst) |\n+          ty::ty_res(_, _, subst) {\n+            // n.b.: This is a hacky abuse of the vstore terminology to also\n+            // make it work for region bounds.  The idea is to allow a type\n+            // Id/&r where Id is an enum, class, or resource, but not Id/@\n+            // etc.  We also do not want to allow Id/&r if the given\n+            // enum/class/resource does not define a region parameter.\n+            //\n+            // Really, these \"/&r\" bounds ought to be part of the path, like\n+            // type parameters.  (In fact, we could generalize to allowing\n+            // multiple such bounds someday)\n+            alt (subst.self_r, vst) {\n+              (some(_), ty::vstore_slice(_)) { /* ok */ }\n+              (none, ty::vstore_slice(_)) {\n+                tcx.sess.span_err(\n+                    a_seq_ty.span,\n+                    #fmt[\"inappropriate bound for %s, \\\n+                          which is not declared as containing \\\n+                          region pointers\",\n+                         ty::ty_sort_str(tcx, seq_ty)]);\n+              }\n+              (_, _) {\n+                tcx.sess.span_err(\n+                    a_seq_ty.span,\n+                    #fmt[\"a %s bound is not appropriate for %s\",\n+                         vstore_to_str(tcx, vst),\n+                         ty::ty_sort_str(tcx, seq_ty)]);\n+              }\n+            }\n+            ret seq_ty;\n+          }\n+\n           _ {\n-            tcx.sess.span_bug(a_seq_ty.span,\n-                              \"found sequence storage modifier \\\n-                               on non-sequence type\")\n+            tcx.sess.span_err(\n+                a_seq_ty.span,\n+                #fmt[\"Bound not allowed on a %s.\",\n+                     ty::ty_sort_str(tcx, seq_ty)]);\n+            ret seq_ty;\n           }\n         }\n     }\n@@ -633,21 +665,21 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n       }\n       ast::ty_vstore(a_t, ast::vstore_slice(a_r)) {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, a_r);\n-        mk_vstore(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n+        mk_bounded(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n       }\n       ast::ty_vstore(a_t, ast::vstore_uniq) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_uniq)\n+        mk_bounded(self, rscope, a_t, ty::vstore_uniq)\n       }\n       ast::ty_vstore(a_t, ast::vstore_box) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_box)\n+        mk_bounded(self, rscope, a_t, ty::vstore_box)\n       }\n       ast::ty_vstore(a_t, ast::vstore_fixed(some(u))) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_fixed(u))\n+        mk_bounded(self, rscope, a_t, ty::vstore_fixed(u))\n       }\n       ast::ty_vstore(_, ast::vstore_fixed(none)) {\n         tcx.sess.span_bug(\n             ast_ty.span,\n-            \"implied fixed length in ast_ty_vstore_to_vstore\");\n+            \"implied fixed length for bound\");\n       }\n       ast::ty_constr(t, cs) {\n         let mut out_cs = [];\n@@ -1656,7 +1688,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n }\n \n fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n-    alt infer::fixup_vars(fcx.infcx, typ) {\n+    alt infer::resolve_deep(fcx.infcx, typ, false) {\n       result::ok(new_type) { ret new_type; }\n       result::err(_) { ret typ; }\n     }\n@@ -1731,7 +1763,7 @@ mod writeback {\n     fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n        option<ty::t> {\n         if !ty::type_has_vars(typ) { ret some(typ); }\n-        alt infer::fixup_vars(fcx.infcx, typ) {\n+        alt infer::resolve_deep(fcx.infcx, typ, true) {\n           result::ok(new_type) { ret some(new_type); }\n           result::err(e) {\n             if !fcx.ccx.tcx.sess.has_errors() {\n@@ -1852,7 +1884,7 @@ mod writeback {\n     fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n-        alt infer::resolve_var(wbcx.fcx.infcx, var_id) {\n+        alt infer::resolve_deep_var(wbcx.fcx.infcx, var_id, true) {\n           result::ok(lty) {\n             #debug[\"Type for local %s (id %d) resolved to %s\",\n                    pat_to_str(l.node.pat), l.node.id,\n@@ -1998,12 +2030,18 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n            bound_tys.map {|x| fcx.ty_to_str(x) }];\n     indent {||\n         let tcx = fcx.tcx();\n-        let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |_id|\n-            fcx.next_region_var()\n+        let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |br|\n+            let rvar = fcx.next_region_var();\n+            #debug[\"Bound region %s maps to %s\",\n+                   bound_region_to_str(fcx.ccx.tcx, br),\n+                   region_to_str(fcx.ccx.tcx, rvar)];\n+            rvar\n         };\n-        ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n+        let t_res = ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n             replace_bound_regions(tcx, span, isr, t)\n-        }\n+        };\n+        #debug[\"Result of universal quant. is %s\", fcx.ty_to_str(t_res)];\n+        t_res\n     }\n }\n \n@@ -4477,7 +4515,7 @@ mod vtable {\n \n     fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n-        alt infer::fixup_vars(fcx.infcx, ty) {\n+        alt infer::resolve_deep(fcx.infcx, ty, true) {\n           result::ok(new_type) { new_type }\n           result::err(e) {\n             tcx.sess.span_fatal("}]}