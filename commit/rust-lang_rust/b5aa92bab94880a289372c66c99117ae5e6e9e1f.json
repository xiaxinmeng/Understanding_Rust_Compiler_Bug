{"sha": "b5aa92bab94880a289372c66c99117ae5e6e9e1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YWE5MmJhYjk0ODgwYTI4OTM3MmM2NmM5OTExN2FlNWU2ZTllMWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T16:29:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T16:29:23Z"}, "message": "Merge #5064\n\n5064: Add NotificationDispatcher r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "70dc29d375136453569d35467a4ed31041727e30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70dc29d375136453569d35467a4ed31041727e30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5aa92bab94880a289372c66c99117ae5e6e9e1f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9NDjCRBK7hj4Ov3rIwAAdHIIAFZR8dPBLmq0fKkkqr3jBmkC\nnyNgqi+VhCHI7ClKQgXNtklwhWnFX+DGb9JaBW932SpbIDHezb52IQ4Gi7B1xjzO\nmGNwcl+lU6eo1CKyWB+IFaQKo5mlcr74ILD6K/+utEaDMVExXdy2fMsgrPCnAv1M\n9bG/HVqiA134HJoTgT1IPqcU7jQ9T4KHeyRbEu7SWurYD1ri7Gu4Mr8+43QlPwJ1\ndiF42s4UOiEVEkJFRtssDXW4MRygRAe/QRfqpKTE14U3Kfb3T9qaum0hxNEupPnH\nTpuDyf4S1+QFF1spYzgiCDvkqG+dEyKLcNYVy/0MDpCHc4U912u5fyW3qeAmXL8=\n=w68f\n-----END PGP SIGNATURE-----\n", "payload": "tree 70dc29d375136453569d35467a4ed31041727e30\nparent ba7286345256eb1140853dc0daa3c276e2ddcbbe\nparent f5ea35a2710c78e77c81f491cc6f8abd40e33981\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593102563 +0000\ncommitter GitHub <noreply@github.com> 1593102563 +0000\n\nMerge #5064\n\n5064: Add NotificationDispatcher r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5aa92bab94880a289372c66c99117ae5e6e9e1f", "html_url": "https://github.com/rust-lang/rust/commit/b5aa92bab94880a289372c66c99117ae5e6e9e1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5aa92bab94880a289372c66c99117ae5e6e9e1f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba7286345256eb1140853dc0daa3c276e2ddcbbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba7286345256eb1140853dc0daa3c276e2ddcbbe", "html_url": "https://github.com/rust-lang/rust/commit/ba7286345256eb1140853dc0daa3c276e2ddcbbe"}, {"sha": "f5ea35a2710c78e77c81f491cc6f8abd40e33981", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ea35a2710c78e77c81f491cc6f8abd40e33981", "html_url": "https://github.com/rust-lang/rust/commit/f5ea35a2710c78e77c81f491cc6f8abd40e33981"}], "stats": {"total": 1111, "additions": 560, "deletions": 551}, "files": [{"sha": "4dcab7a61f9007cafdf447907951e7011b80ed61", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -120,7 +120,13 @@ impl FlycheckActor {\n     ) -> FlycheckActor {\n         FlycheckActor { sender, config, workspace_root, last_update_req: None, check_process: None }\n     }\n-\n+    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n+        select! {\n+            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n+        }\n+    }\n     fn run(&mut self, inbox: Receiver<Restart>) {\n         // If we rerun the thread, we need to discard the previous check results first\n         self.send(Message::ClearDiagnostics);\n@@ -167,15 +173,6 @@ impl FlycheckActor {\n             }\n         }\n     }\n-\n-    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n-        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n-        select! {\n-            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n-            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n-        }\n-    }\n-\n     fn should_recheck(&mut self) -> bool {\n         if let Some(_last_update_req) = &self.last_update_req {\n             // We currently only request an update on save, as we need up to"}, {"sha": "5fdbed8ef395a6ddee41269bd8ff970e2f348b28", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -0,0 +1,176 @@\n+//! A visitor for downcasting arbitrary request (JSON) into a specific type.\n+use std::{panic, time::Instant};\n+\n+use serde::{de::DeserializeOwned, Serialize};\n+\n+use crate::{\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    lsp_utils::is_canceled,\n+    main_loop::Task,\n+    LspError, Result,\n+};\n+\n+pub(crate) struct RequestDispatcher<'a> {\n+    pub(crate) req: Option<lsp_server::Request>,\n+    pub(crate) global_state: &'a mut GlobalState,\n+    pub(crate) request_received: Instant,\n+}\n+\n+impl<'a> RequestDispatcher<'a> {\n+    /// Dispatches the request onto the current thread\n+    pub(crate) fn on_sync<R>(\n+        &mut self,\n+        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + 'static,\n+        R::Result: Serialize + 'static,\n+    {\n+        let (id, params) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => {\n+                return Ok(self);\n+            }\n+        };\n+        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n+        let task = panic::catch_unwind(move || {\n+            let result = f(world.0, params);\n+            result_to_task::<R>(id, result)\n+        })\n+        .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n+        self.global_state.on_task(task);\n+        Ok(self)\n+    }\n+\n+    /// Dispatches the request onto thread pool\n+    pub(crate) fn on<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + Send + 'static,\n+        R::Result: Serialize + 'static,\n+    {\n+        let (id, params) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => {\n+                return Ok(self);\n+            }\n+        };\n+\n+        self.global_state.task_pool.0.spawn({\n+            let world = self.global_state.snapshot();\n+            move || {\n+                let result = f(world, params);\n+                result_to_task::<R>(id, result)\n+            }\n+        });\n+\n+        Ok(self)\n+    }\n+\n+    pub(crate) fn finish(&mut self) {\n+        match self.req.take() {\n+            None => (),\n+            Some(req) => {\n+                log::error!(\"unknown request: {:?}\", req);\n+                let resp = lsp_server::Response::new_err(\n+                    req.id,\n+                    lsp_server::ErrorCode::MethodNotFound as i32,\n+                    \"unknown request\".to_string(),\n+                );\n+                self.global_state.send(resp.into());\n+            }\n+        }\n+    }\n+\n+    fn parse<R>(&mut self) -> Option<(lsp_server::RequestId, R::Params)>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + 'static,\n+    {\n+        let req = self.req.take()?;\n+        let (id, params) = match req.extract::<R::Params>(R::METHOD) {\n+            Ok(it) => it,\n+            Err(req) => {\n+                self.req = Some(req);\n+                return None;\n+            }\n+        };\n+        self.global_state\n+            .req_queue\n+            .incoming\n+            .register(id.clone(), (R::METHOD, self.request_received));\n+        Some((id, params))\n+    }\n+}\n+\n+fn result_to_task<R>(id: lsp_server::RequestId, result: Result<R::Result>) -> Task\n+where\n+    R: lsp_types::request::Request + 'static,\n+    R::Params: DeserializeOwned + 'static,\n+    R::Result: Serialize + 'static,\n+{\n+    let response = match result {\n+        Ok(resp) => lsp_server::Response::new_ok(id, &resp),\n+        Err(e) => match e.downcast::<LspError>() {\n+            Ok(lsp_error) => lsp_server::Response::new_err(id, lsp_error.code, lsp_error.message),\n+            Err(e) => {\n+                if is_canceled(&*e) {\n+                    lsp_server::Response::new_err(\n+                        id,\n+                        lsp_server::ErrorCode::ContentModified as i32,\n+                        \"content modified\".to_string(),\n+                    )\n+                } else {\n+                    lsp_server::Response::new_err(\n+                        id,\n+                        lsp_server::ErrorCode::InternalError as i32,\n+                        e.to_string(),\n+                    )\n+                }\n+            }\n+        },\n+    };\n+    Task::Respond(response)\n+}\n+\n+pub(crate) struct NotificationDispatcher<'a> {\n+    pub(crate) not: Option<lsp_server::Notification>,\n+    pub(crate) global_state: &'a mut GlobalState,\n+}\n+\n+impl<'a> NotificationDispatcher<'a> {\n+    pub(crate) fn on<N>(\n+        &mut self,\n+        f: fn(&mut GlobalState, N::Params) -> Result<()>,\n+    ) -> Result<&mut Self>\n+    where\n+        N: lsp_types::notification::Notification + 'static,\n+        N::Params: DeserializeOwned + Send + 'static,\n+    {\n+        let not = match self.not.take() {\n+            Some(it) => it,\n+            None => return Ok(self),\n+        };\n+        let params = match not.extract::<N::Params>(N::METHOD) {\n+            Ok(it) => it,\n+            Err(not) => {\n+                self.not = Some(not);\n+                return Ok(self);\n+            }\n+        };\n+        f(self.global_state, params)?;\n+        Ok(self)\n+    }\n+\n+    pub(crate) fn finish(&mut self) {\n+        if let Some(not) = &self.not {\n+            if !not.method.starts_with(\"$/\") {\n+                log::error!(\"unhandled notification: {:?}\", not);\n+            }\n+        }\n+    }\n+}"}, {"sha": "56d50c78997944fdeec759c2344f0ef866080d60", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -5,7 +5,7 @@\n \n use std::{convert::TryFrom, sync::Arc};\n \n-use crossbeam_channel::{unbounded, Receiver};\n+use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::{FlycheckConfig, FlycheckHandle};\n use lsp_types::Url;\n use parking_lot::RwLock;\n@@ -22,6 +22,7 @@ use crate::{\n     line_endings::LineEndings,\n     main_loop::{ReqQueue, Task},\n     request_metrics::{LatestRequests, RequestMetrics},\n+    show_message,\n     thread_pool::TaskPool,\n     to_proto::url_from_abs_path,\n     Result,\n@@ -66,6 +67,7 @@ impl Default for Status {\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n pub(crate) struct GlobalState {\n+    sender: Sender<lsp_server::Message>,\n     pub(crate) config: Config,\n     pub(crate) task_pool: (TaskPool<Task>, Receiver<Task>),\n     pub(crate) analysis_host: AnalysisHost,\n@@ -95,6 +97,7 @@ pub(crate) struct GlobalStateSnapshot {\n \n impl GlobalState {\n     pub(crate) fn new(\n+        sender: Sender<lsp_server::Message>,\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         config: Config,\n@@ -162,6 +165,7 @@ impl GlobalState {\n         };\n \n         let mut res = GlobalState {\n+            sender,\n             config,\n             task_pool,\n             analysis_host,\n@@ -252,6 +256,19 @@ impl GlobalState {\n     pub(crate) fn complete_request(&mut self, request: RequestMetrics) {\n         self.latest_requests.write().record(request)\n     }\n+\n+    pub(crate) fn send(&mut self, message: lsp_server::Message) {\n+        self.sender.send(message).unwrap()\n+    }\n+    pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n+        show_message(typ, message, &self.sender)\n+    }\n+}\n+\n+impl Drop for GlobalState {\n+    fn drop(&mut self) {\n+        self.analysis_host.request_cancellation()\n+    }\n }\n \n impl GlobalStateSnapshot {"}, {"sha": "d503fe96e2d0382caf77293974158ea371832d58", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -19,6 +19,7 @@ macro_rules! eprintln {\n \n mod global_state;\n mod main_loop;\n+mod dispatch;\n mod handlers;\n mod caps;\n mod cargo_target_spec;"}, {"sha": "35917030c8df6b9e31d6c4f5067c1edd8b6c191c", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -1,12 +1,13 @@\n //! Utilities for LSP-related boilerplate code.\n use std::{error::Error, ops::Range};\n \n-use crate::from_proto;\n use crossbeam_channel::Sender;\n use lsp_server::{Message, Notification};\n use ra_db::Canceled;\n use ra_ide::LineIndex;\n-use serde::{de::DeserializeOwned, Serialize};\n+use serde::Serialize;\n+\n+use crate::from_proto;\n \n pub fn show_message(\n     typ: lsp_types::MessageType,\n@@ -29,14 +30,6 @@ pub(crate) fn notification_is<N: lsp_types::notification::Notification>(\n     notification.method == N::METHOD\n }\n \n-pub(crate) fn notification_cast<N>(notification: Notification) -> Result<N::Params, Notification>\n-where\n-    N: lsp_types::notification::Notification,\n-    N::Params: DeserializeOwned,\n-{\n-    notification.extract(N::METHOD)\n-}\n-\n pub(crate) fn notification_new<N>(params: N::Params) -> Notification\n where\n     N: lsp_types::notification::Notification,"}, {"sha": "c2f43df1d0b75a73fd21ae42b594abdff3d0e4ad", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 349, "deletions": 523, "changes": 872, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -5,27 +5,26 @@ use std::{\n     time::{Duration, Instant},\n };\n \n-use crossbeam_channel::{never, select, RecvError, Sender};\n-use lsp_server::{Connection, ErrorCode, Notification, Request, RequestId, Response};\n-use lsp_types::{request::Request as _, NumberOrString};\n+use crossbeam_channel::{never, select, Receiver};\n+use lsp_server::{Connection, Notification, Request, Response};\n+use lsp_types::{notification::Notification as _, request::Request as _};\n use ra_db::VfsPath;\n use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n-use serde::{de::DeserializeOwned, Serialize};\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::DiagnosticTask,\n+    dispatch::{NotificationDispatcher, RequestDispatcher},\n     from_proto,\n-    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot, Status},\n+    global_state::{file_id_to_url, GlobalState, Status},\n     handlers, lsp_ext,\n     lsp_utils::{\n-        apply_document_changes, is_canceled, notification_cast, notification_is, notification_new,\n-        show_message,\n+        apply_document_changes, is_canceled, notification_is, notification_new, show_message,\n     },\n     request_metrics::RequestMetrics,\n-    LspError, Result,\n+    Result,\n };\n \n pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n@@ -50,7 +49,7 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         SetThreadPriority(thread, thread_priority_above_normal);\n     }\n \n-    let mut global_state = {\n+    let global_state = {\n         let workspaces = {\n             if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n@@ -113,40 +112,346 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        GlobalState::new(workspaces, config.lru_capacity, config, req_queue)\n+        GlobalState::new(\n+            connection.sender.clone(),\n+            workspaces,\n+            config.lru_capacity,\n+            config,\n+            req_queue,\n+        )\n     };\n \n     log::info!(\"server initialized, serving requests\");\n-    {\n-        loop {\n-            log::trace!(\"selecting\");\n-            let event = select! {\n-                recv(&connection.receiver) -> msg => match msg {\n-                    Ok(msg) => Event::Lsp(msg),\n-                    Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n-                },\n-                recv(&global_state.task_pool.1) -> task => Event::Task(task.unwrap()),\n-                recv(global_state.task_receiver) -> task => match task {\n-                    Ok(task) => Event::Vfs(task),\n-                    Err(RecvError) => return Err(\"vfs died\".into()),\n+    global_state.run(connection.receiver)?;\n+    Ok(())\n+}\n+\n+impl GlobalState {\n+    fn next_event(&self, inbox: &Receiver<lsp_server::Message>) -> Option<Event> {\n+        select! {\n+            recv(inbox) -> msg =>\n+                msg.ok().map(Event::Lsp),\n+\n+            recv(self.task_pool.1) -> task =>\n+                Some(Event::Task(task.unwrap())),\n+\n+            recv(self.task_receiver) -> task =>\n+                Some(Event::Vfs(task.unwrap())),\n+\n+            recv(self.flycheck.as_ref().map_or(&never(), |it| &it.1)) -> task =>\n+                Some(Event::Flycheck(task.unwrap())),\n+        }\n+    }\n+\n+    fn run(mut self, inbox: Receiver<lsp_server::Message>) -> Result<()> {\n+        while let Some(event) = self.next_event(&inbox) {\n+            let loop_start = Instant::now();\n+            // NOTE: don't count blocking select! call as a loop-turn time\n+            let _p = profile(\"main_loop_inner/loop-turn\");\n+\n+            log::info!(\"loop turn = {:?}\", event);\n+            let queue_count = self.task_pool.0.len();\n+            if queue_count > 0 {\n+                log::info!(\"queued count = {}\", queue_count);\n+            }\n+\n+            let mut became_ready = false;\n+            match event {\n+                Event::Lsp(msg) => match msg {\n+                    lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n+                    lsp_server::Message::Notification(not) => {\n+                        if not.method == lsp_types::notification::Exit::METHOD {\n+                            return Ok(());\n+                        }\n+                        self.on_notification(not)?;\n+                    }\n+                    lsp_server::Message::Response(resp) => {\n+                        let handler = self.req_queue.outgoing.complete(resp.id.clone());\n+                        handler(&mut self, resp)\n+                    }\n                 },\n-                recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.1)) -> task => match task {\n-                    Ok(task) => Event::Flycheck(task),\n-                    Err(RecvError) => return Err(\"check watcher died\".into()),\n+                Event::Task(task) => {\n+                    self.on_task(task);\n+                    self.maybe_collect_garbage();\n+                }\n+                Event::Vfs(task) => match task {\n+                    vfs::loader::Message::Loaded { files } => {\n+                        let vfs = &mut self.vfs.write().0;\n+                        for (path, contents) in files {\n+                            let path = VfsPath::from(path);\n+                            if !self.mem_docs.contains(&path) {\n+                                vfs.set_file_contents(path, contents)\n+                            }\n+                        }\n+                    }\n+                    vfs::loader::Message::Progress { n_total, n_done } => {\n+                        let state = if n_done == 0 {\n+                            Progress::Begin\n+                        } else if n_done < n_total {\n+                            Progress::Report\n+                        } else {\n+                            assert_eq!(n_done, n_total);\n+                            self.status = Status::Ready;\n+                            became_ready = true;\n+                            Progress::End\n+                        };\n+                        report_progress(\n+                            &mut self,\n+                            \"roots scanned\",\n+                            state,\n+                            Some(format!(\"{}/{}\", n_done, n_total)),\n+                            Some(percentage(n_done, n_total)),\n+                        )\n+                    }\n                 },\n-            };\n-            if let Event::Lsp(lsp_server::Message::Request(req)) = &event {\n-                if connection.handle_shutdown(&req)? {\n-                    break;\n+                Event::Flycheck(task) => on_check_task(task, &mut self)?,\n+            }\n+\n+            let state_changed = self.process_changes();\n+            if became_ready {\n+                if let Some(flycheck) = &self.flycheck {\n+                    flycheck.0.update();\n+                }\n+            }\n+\n+            if self.status == Status::Ready && (state_changed || became_ready) {\n+                let subscriptions = self\n+                    .mem_docs\n+                    .iter()\n+                    .map(|path| self.vfs.read().0.file_id(&path).unwrap())\n+                    .collect::<Vec<_>>();\n+\n+                self.update_file_notifications_on_threadpool(subscriptions);\n+            }\n+\n+            let loop_duration = loop_start.elapsed();\n+            if loop_duration > Duration::from_millis(100) {\n+                log::error!(\"overly long loop turn: {:?}\", loop_duration);\n+                if env::var(\"RA_PROFILE\").is_ok() {\n+                    self.show_message(\n+                        lsp_types::MessageType::Error,\n+                        format!(\"overly long loop turn: {:?}\", loop_duration),\n+                    )\n+                }\n+            }\n+        }\n+        Err(\"client exited without proper shutdown sequence\")?\n+    }\n+\n+    fn on_request(&mut self, request_received: Instant, req: Request) -> Result<()> {\n+        RequestDispatcher { req: Some(req), global_state: self, request_received }\n+            .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n+            .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n+            .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n+            .on_sync::<lsp_types::request::Shutdown>(|_, ()| Ok(()))?\n+            .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n+                handlers::handle_selection_range(s.snapshot(), p)\n+            })?\n+            .on_sync::<lsp_ext::MatchingBrace>(|s, p| {\n+                handlers::handle_matching_brace(s.snapshot(), p)\n+            })?\n+            .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)?\n+            .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)?\n+            .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)?\n+            .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)?\n+            .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n+            .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n+            .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n+            .on::<lsp_ext::ResolveCodeActionRequest>(handlers::handle_resolve_code_action)?\n+            .on::<lsp_ext::HoverRequest>(handlers::handle_hover)?\n+            .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n+            .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n+            .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n+            .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)?\n+            .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)?\n+            .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n+            .on::<lsp_types::request::Completion>(handlers::handle_completion)?\n+            .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)?\n+            .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n+            .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n+            .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n+            .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n+            .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n+            .on::<lsp_types::request::References>(handlers::handle_references)?\n+            .on::<lsp_types::request::Formatting>(handlers::handle_formatting)?\n+            .on::<lsp_types::request::DocumentHighlightRequest>(\n+                handlers::handle_document_highlight,\n+            )?\n+            .on::<lsp_types::request::CallHierarchyPrepare>(\n+                handlers::handle_call_hierarchy_prepare,\n+            )?\n+            .on::<lsp_types::request::CallHierarchyIncomingCalls>(\n+                handlers::handle_call_hierarchy_incoming,\n+            )?\n+            .on::<lsp_types::request::CallHierarchyOutgoingCalls>(\n+                handlers::handle_call_hierarchy_outgoing,\n+            )?\n+            .on::<lsp_types::request::SemanticTokensRequest>(handlers::handle_semantic_tokens)?\n+            .on::<lsp_types::request::SemanticTokensRangeRequest>(\n+                handlers::handle_semantic_tokens_range,\n+            )?\n+            .on::<lsp_ext::Ssr>(handlers::handle_ssr)?\n+            .finish();\n+        Ok(())\n+    }\n+    fn on_notification(&mut self, not: Notification) -> Result<()> {\n+        NotificationDispatcher { not: Some(not), global_state: self }\n+            .on::<lsp_types::notification::Cancel>(|this, params| {\n+                let id: lsp_server::RequestId = match params.id {\n+                    lsp_types::NumberOrString::Number(id) => id.into(),\n+                    lsp_types::NumberOrString::String(id) => id.into(),\n+                };\n+                if let Some(response) = this.req_queue.incoming.cancel(id) {\n+                    this.send(response.into());\n+                }\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidOpenTextDocument>(|this, params| {\n+                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    if !this.mem_docs.insert(path.clone()) {\n+                        log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n+                    }\n+                    this.vfs\n+                        .write()\n+                        .0\n+                        .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n+                }\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidChangeTextDocument>(|this, params| {\n+                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    assert!(this.mem_docs.contains(&path));\n+                    let vfs = &mut this.vfs.write().0;\n+                    let file_id = vfs.file_id(&path).unwrap();\n+                    let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n+                    apply_document_changes(&mut text, params.content_changes);\n+                    vfs.set_file_contents(path, Some(text.into_bytes()))\n+                }\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidCloseTextDocument>(|this, params| {\n+                if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    if !this.mem_docs.remove(&path) {\n+                        log::error!(\"orphan DidCloseTextDocument: {}\", path)\n+                    }\n+                    if let Some(path) = path.as_path() {\n+                        this.loader.invalidate(path.to_path_buf());\n+                    }\n+                }\n+                let params = lsp_types::PublishDiagnosticsParams {\n+                    uri: params.text_document.uri,\n+                    diagnostics: Vec::new(),\n+                    version: None,\n                 };\n+                let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n+                this.send(not.into());\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidSaveTextDocument>(|this, _params| {\n+                if let Some(flycheck) = &this.flycheck {\n+                    flycheck.0.update();\n+                }\n+                Ok(())\n+            })?\n+            .on::<lsp_types::notification::DidChangeConfiguration>(|this, _params| {\n+                // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n+                // this notification's parameters should be ignored and the actual config queried separately.\n+                let request = this.req_queue.outgoing.register(\n+                    lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n+                    lsp_types::ConfigurationParams {\n+                        items: vec![lsp_types::ConfigurationItem {\n+                            scope_uri: None,\n+                            section: Some(\"rust-analyzer\".to_string()),\n+                        }],\n+                    },\n+                    |this, resp| {\n+                        log::debug!(\"config update response: '{:?}\", resp);\n+                        let Response { error, result, .. } = resp;\n+\n+                        match (error, result) {\n+                            (Some(err), _) => {\n+                                log::error!(\"failed to fetch the server settings: {:?}\", err)\n+                            }\n+                            (None, Some(configs)) => {\n+                                if let Some(new_config) = configs.get(0) {\n+                                    let mut config = this.config.clone();\n+                                    config.update(&new_config);\n+                                    this.update_configuration(config);\n+                                }\n+                            }\n+                            (None, None) => log::error!(\n+                                \"received empty server settings response from the client\"\n+                            ),\n+                        }\n+                    },\n+                );\n+                this.send(request.into());\n+\n+                return Ok(());\n+            })?\n+            .on::<lsp_types::notification::DidChangeWatchedFiles>(|this, params| {\n+                for change in params.changes {\n+                    if let Ok(path) = from_proto::abs_path(&change.uri) {\n+                        this.loader.invalidate(path);\n+                    }\n+                }\n+                Ok(())\n+            })?\n+            .finish();\n+        Ok(())\n+    }\n+    pub(crate) fn on_task(&mut self, task: Task) {\n+        match task {\n+            Task::Respond(response) => {\n+                if let Some((method, start)) = self.req_queue.incoming.complete(response.id.clone())\n+                {\n+                    let duration = start.elapsed();\n+                    log::info!(\"handled req#{} in {:?}\", response.id, duration);\n+                    self.complete_request(RequestMetrics {\n+                        id: response.id.clone(),\n+                        method: method.to_string(),\n+                        duration,\n+                    });\n+                    self.send(response.into());\n+                }\n             }\n-            assert!(!global_state.vfs.read().0.has_changes());\n-            loop_turn(&connection, &mut global_state, event)?;\n-            assert!(!global_state.vfs.read().0.has_changes());\n+            Task::Diagnostics(tasks) => {\n+                tasks.into_iter().for_each(|task| on_diagnostic_task(task, self))\n+            }\n+            Task::Unit => (),\n         }\n     }\n-    global_state.analysis_host.request_cancellation();\n-    Ok(())\n+    fn update_file_notifications_on_threadpool(&mut self, subscriptions: Vec<FileId>) {\n+        log::trace!(\"updating notifications for {:?}\", subscriptions);\n+        if self.config.publish_diagnostics {\n+            let snapshot = self.snapshot();\n+            let subscriptions = subscriptions.clone();\n+            self.task_pool.0.spawn(move || {\n+                let diagnostics = subscriptions\n+                    .into_iter()\n+                    .filter_map(|file_id| {\n+                        handlers::publish_diagnostics(&snapshot, file_id)\n+                            .map_err(|err| {\n+                                if !is_canceled(&*err) {\n+                                    log::error!(\"failed to compute diagnostics: {:?}\", err);\n+                                }\n+                                ()\n+                            })\n+                            .ok()\n+                    })\n+                    .collect::<Vec<_>>();\n+                Task::Diagnostics(diagnostics)\n+            })\n+        }\n+        self.task_pool.0.spawn({\n+            let subs = subscriptions;\n+            let snap = self.snapshot();\n+            move || {\n+                snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ());\n+                Task::Unit\n+            }\n+        });\n+    }\n }\n \n #[derive(Debug)]\n@@ -199,333 +504,10 @@ pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n \n-fn loop_turn(connection: &Connection, global_state: &mut GlobalState, event: Event) -> Result<()> {\n-    let loop_start = Instant::now();\n-\n-    // NOTE: don't count blocking select! call as a loop-turn time\n-    let _p = profile(\"main_loop_inner/loop-turn\");\n-    log::info!(\"loop turn = {:?}\", event);\n-    let queue_count = global_state.task_pool.0.len();\n-    if queue_count > 0 {\n-        log::info!(\"queued count = {}\", queue_count);\n-    }\n-\n-    let mut became_ready = false;\n-    match event {\n-        Event::Task(task) => {\n-            on_task(task, &connection.sender, global_state);\n-            global_state.maybe_collect_garbage();\n-        }\n-        Event::Vfs(task) => match task {\n-            vfs::loader::Message::Loaded { files } => {\n-                let vfs = &mut global_state.vfs.write().0;\n-                for (path, contents) in files {\n-                    let path = VfsPath::from(path);\n-                    if !global_state.mem_docs.contains(&path) {\n-                        vfs.set_file_contents(path, contents)\n-                    }\n-                }\n-            }\n-            vfs::loader::Message::Progress { n_total, n_done } => {\n-                let state = if n_done == 0 {\n-                    Progress::Begin\n-                } else if n_done < n_total {\n-                    Progress::Report\n-                } else {\n-                    assert_eq!(n_done, n_total);\n-                    global_state.status = Status::Ready;\n-                    became_ready = true;\n-                    Progress::End\n-                };\n-                report_progress(\n-                    global_state,\n-                    &connection.sender,\n-                    \"roots scanned\",\n-                    state,\n-                    Some(format!(\"{}/{}\", n_done, n_total)),\n-                    Some(percentage(n_done, n_total)),\n-                )\n-            }\n-        },\n-        Event::Flycheck(task) => on_check_task(task, global_state, &connection.sender)?,\n-        Event::Lsp(msg) => match msg {\n-            lsp_server::Message::Request(req) => {\n-                on_request(global_state, &connection.sender, loop_start, req)?\n-            }\n-            lsp_server::Message::Notification(not) => {\n-                on_notification(&connection.sender, global_state, not)?;\n-            }\n-            lsp_server::Message::Response(resp) => {\n-                let handler = global_state.req_queue.outgoing.complete(resp.id.clone());\n-                handler(global_state, resp)\n-            }\n-        },\n-    };\n-\n-    let state_changed = global_state.process_changes();\n-\n-    if became_ready {\n-        if let Some(flycheck) = &global_state.flycheck {\n-            flycheck.0.update();\n-        }\n-    }\n-\n-    if global_state.status == Status::Ready && (state_changed || became_ready) {\n-        let subscriptions = global_state\n-            .mem_docs\n-            .iter()\n-            .map(|path| global_state.vfs.read().0.file_id(&path).unwrap())\n-            .collect::<Vec<_>>();\n-\n-        update_file_notifications_on_threadpool(global_state, subscriptions.clone());\n-        global_state.task_pool.0.spawn({\n-            let subs = subscriptions;\n-            let snap = global_state.snapshot();\n-            move || {\n-                snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ());\n-                Task::Unit\n-            }\n-        });\n-    }\n-\n-    let loop_duration = loop_start.elapsed();\n-    if loop_duration > Duration::from_millis(100) {\n-        log::error!(\"overly long loop turn: {:?}\", loop_duration);\n-        if env::var(\"RA_PROFILE\").is_ok() {\n-            show_message(\n-                lsp_types::MessageType::Error,\n-                format!(\"overly long loop turn: {:?}\", loop_duration),\n-                &connection.sender,\n-            );\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-fn on_task(task: Task, msg_sender: &Sender<lsp_server::Message>, global_state: &mut GlobalState) {\n-    match task {\n-        Task::Respond(response) => {\n-            if let Some((method, start)) =\n-                global_state.req_queue.incoming.complete(response.id.clone())\n-            {\n-                let duration = start.elapsed();\n-                log::info!(\"handled req#{} in {:?}\", response.id, duration);\n-                global_state.complete_request(RequestMetrics {\n-                    id: response.id.clone(),\n-                    method: method.to_string(),\n-                    duration,\n-                });\n-                msg_sender.send(response.into()).unwrap();\n-            }\n-        }\n-        Task::Diagnostics(tasks) => {\n-            tasks.into_iter().for_each(|task| on_diagnostic_task(task, msg_sender, global_state))\n-        }\n-        Task::Unit => (),\n-    }\n-}\n-\n-fn on_request(\n-    global_state: &mut GlobalState,\n-    msg_sender: &Sender<lsp_server::Message>,\n-    request_received: Instant,\n-    req: Request,\n-) -> Result<()> {\n-    let mut pool_dispatcher =\n-        PoolDispatcher { req: Some(req), global_state, msg_sender, request_received };\n-    pool_dispatcher\n-        .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n-        .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n-        .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n-        .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n-            handlers::handle_selection_range(s.snapshot(), p)\n-        })?\n-        .on_sync::<lsp_ext::MatchingBrace>(|s, p| handlers::handle_matching_brace(s.snapshot(), p))?\n-        .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)?\n-        .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)?\n-        .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)?\n-        .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)?\n-        .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n-        .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n-        .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n-        .on::<lsp_ext::ResolveCodeActionRequest>(handlers::handle_resolve_code_action)?\n-        .on::<lsp_ext::HoverRequest>(handlers::handle_hover)?\n-        .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n-        .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n-        .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n-        .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)?\n-        .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)?\n-        .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n-        .on::<lsp_types::request::Completion>(handlers::handle_completion)?\n-        .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)?\n-        .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n-        .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n-        .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n-        .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n-        .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n-        .on::<lsp_types::request::References>(handlers::handle_references)?\n-        .on::<lsp_types::request::Formatting>(handlers::handle_formatting)?\n-        .on::<lsp_types::request::DocumentHighlightRequest>(handlers::handle_document_highlight)?\n-        .on::<lsp_types::request::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)?\n-        .on::<lsp_types::request::CallHierarchyIncomingCalls>(\n-            handlers::handle_call_hierarchy_incoming,\n-        )?\n-        .on::<lsp_types::request::CallHierarchyOutgoingCalls>(\n-            handlers::handle_call_hierarchy_outgoing,\n-        )?\n-        .on::<lsp_types::request::SemanticTokensRequest>(handlers::handle_semantic_tokens)?\n-        .on::<lsp_types::request::SemanticTokensRangeRequest>(\n-            handlers::handle_semantic_tokens_range,\n-        )?\n-        .on::<lsp_ext::Ssr>(handlers::handle_ssr)?\n-        .finish();\n-    Ok(())\n-}\n-\n-fn on_notification(\n-    msg_sender: &Sender<lsp_server::Message>,\n-    global_state: &mut GlobalState,\n-    not: Notification,\n-) -> Result<()> {\n-    let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n-        Ok(params) => {\n-            let id: RequestId = match params.id {\n-                NumberOrString::Number(id) => id.into(),\n-                NumberOrString::String(id) => id.into(),\n-            };\n-            if let Some(response) = global_state.req_queue.incoming.cancel(id) {\n-                msg_sender.send(response.into()).unwrap()\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n-        Ok(params) => {\n-            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !global_state.mem_docs.insert(path.clone()) {\n-                    log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n-                }\n-                global_state\n-                    .vfs\n-                    .write()\n-                    .0\n-                    .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n-        Ok(params) => {\n-            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                assert!(global_state.mem_docs.contains(&path));\n-                let vfs = &mut global_state.vfs.write().0;\n-                let file_id = vfs.file_id(&path).unwrap();\n-                let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n-                apply_document_changes(&mut text, params.content_changes);\n-                vfs.set_file_contents(path, Some(text.into_bytes()))\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n-        Ok(params) => {\n-            if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                if !global_state.mem_docs.remove(&path) {\n-                    log::error!(\"orphan DidCloseTextDocument: {}\", path)\n-                }\n-                if let Some(path) = path.as_path() {\n-                    global_state.loader.invalidate(path.to_path_buf());\n-                }\n-            }\n-            let params = lsp_types::PublishDiagnosticsParams {\n-                uri: params.text_document.uri,\n-                diagnostics: Vec::new(),\n-                version: None,\n-            };\n-            let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n-            msg_sender.send(not.into()).unwrap();\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n-        Ok(_params) => {\n-            if let Some(flycheck) = &global_state.flycheck {\n-                flycheck.0.update();\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidChangeConfiguration>(not) {\n-        Ok(_) => {\n-            // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n-            // this notification's parameters should be ignored and the actual config queried separately.\n-            let request = global_state.req_queue.outgoing.register(\n-                lsp_types::request::WorkspaceConfiguration::METHOD.to_string(),\n-                lsp_types::ConfigurationParams {\n-                    items: vec![lsp_types::ConfigurationItem {\n-                        scope_uri: None,\n-                        section: Some(\"rust-analyzer\".to_string()),\n-                    }],\n-                },\n-                |global_state, resp| {\n-                    log::debug!(\"config update response: '{:?}\", resp);\n-                    let Response { error, result, .. } = resp;\n-\n-                    match (error, result) {\n-                        (Some(err), _) => {\n-                            log::error!(\"failed to fetch the server settings: {:?}\", err)\n-                        }\n-                        (None, Some(configs)) => {\n-                            if let Some(new_config) = configs.get(0) {\n-                                let mut config = global_state.config.clone();\n-                                config.update(&new_config);\n-                                global_state.update_configuration(config);\n-                            }\n-                        }\n-                        (None, None) => {\n-                            log::error!(\"received empty server settings response from the client\")\n-                        }\n-                    }\n-                },\n-            );\n-            msg_sender.send(request.into())?;\n-\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    let not = match notification_cast::<lsp_types::notification::DidChangeWatchedFiles>(not) {\n-        Ok(params) => {\n-            for change in params.changes {\n-                if let Ok(path) = from_proto::abs_path(&change.uri) {\n-                    global_state.loader.invalidate(path)\n-                }\n-            }\n-            return Ok(());\n-        }\n-        Err(not) => not,\n-    };\n-    if not.method.starts_with(\"$/\") {\n-        return Ok(());\n-    }\n-    log::error!(\"unhandled notification: {:?}\", not);\n-    Ok(())\n-}\n-\n-fn on_check_task(\n-    task: flycheck::Message,\n-    global_state: &mut GlobalState,\n-    msg_sender: &Sender<lsp_server::Message>,\n-) -> Result<()> {\n+fn on_check_task(task: flycheck::Message, global_state: &mut GlobalState) -> Result<()> {\n     match task {\n         flycheck::Message::ClearDiagnostics => {\n-            on_diagnostic_task(DiagnosticTask::ClearCheck, msg_sender, global_state)\n+            on_diagnostic_task(DiagnosticTask::ClearCheck, global_state)\n         }\n \n         flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n@@ -550,7 +532,6 @@ fn on_check_task(\n                         diag.diagnostic,\n                         diag.fixes.into_iter().map(|it| it.into()).collect(),\n                     ),\n-                    msg_sender,\n                     global_state,\n                 )\n             }\n@@ -563,26 +544,22 @@ fn on_check_task(\n                 flycheck::Progress::End => (Progress::End, None),\n             };\n \n-            report_progress(global_state, msg_sender, \"cargo check\", state, message, None);\n+            report_progress(global_state, \"cargo check\", state, message, None);\n         }\n     };\n \n     Ok(())\n }\n \n-fn on_diagnostic_task(\n-    task: DiagnosticTask,\n-    msg_sender: &Sender<lsp_server::Message>,\n-    state: &mut GlobalState,\n-) {\n-    let subscriptions = state.diagnostics.handle_task(task);\n+fn on_diagnostic_task(task: DiagnosticTask, global_state: &mut GlobalState) {\n+    let subscriptions = global_state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n-        let url = file_id_to_url(&state.vfs.read().0, file_id);\n-        let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n+        let url = file_id_to_url(&global_state.vfs.read().0, file_id);\n+        let diagnostics = global_state.diagnostics.diagnostics_for(file_id).cloned().collect();\n         let params = lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None };\n         let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n-        msg_sender.send(not.into()).unwrap();\n+        global_state.send(not.into());\n     }\n }\n \n@@ -599,7 +576,6 @@ fn percentage(done: usize, total: usize) -> f64 {\n \n fn report_progress(\n     global_state: &mut GlobalState,\n-    sender: &Sender<lsp_server::Message>,\n     title: &str,\n     state: Progress,\n     message: Option<String>,\n@@ -616,7 +592,7 @@ fn report_progress(\n                 lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n                 DO_NOTHING,\n             );\n-            sender.send(work_done_progress_create.into()).unwrap();\n+            global_state.send(work_done_progress_create.into());\n \n             lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n                 title: title.into(),\n@@ -641,155 +617,5 @@ fn report_progress(\n             token,\n             value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n         });\n-    sender.send(notification.into()).unwrap();\n-}\n-\n-struct PoolDispatcher<'a> {\n-    req: Option<Request>,\n-    global_state: &'a mut GlobalState,\n-    msg_sender: &'a Sender<lsp_server::Message>,\n-    request_received: Instant,\n-}\n-\n-impl<'a> PoolDispatcher<'a> {\n-    /// Dispatches the request onto the current thread\n-    fn on_sync<R>(\n-        &mut self,\n-        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n-    ) -> Result<&mut Self>\n-    where\n-        R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + panic::UnwindSafe + 'static,\n-        R::Result: Serialize + 'static,\n-    {\n-        let (id, params) = match self.parse::<R>() {\n-            Some(it) => it,\n-            None => {\n-                return Ok(self);\n-            }\n-        };\n-        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n-        let task = panic::catch_unwind(move || {\n-            let result = f(world.0, params);\n-            result_to_task::<R>(id, result)\n-        })\n-        .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.global_state);\n-        Ok(self)\n-    }\n-\n-    /// Dispatches the request onto thread pool\n-    fn on<R>(\n-        &mut self,\n-        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n-    ) -> Result<&mut Self>\n-    where\n-        R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + Send + 'static,\n-        R::Result: Serialize + 'static,\n-    {\n-        let (id, params) = match self.parse::<R>() {\n-            Some(it) => it,\n-            None => {\n-                return Ok(self);\n-            }\n-        };\n-\n-        self.global_state.task_pool.0.spawn({\n-            let world = self.global_state.snapshot();\n-            move || {\n-                let result = f(world, params);\n-                result_to_task::<R>(id, result)\n-            }\n-        });\n-\n-        Ok(self)\n-    }\n-\n-    fn parse<R>(&mut self) -> Option<(RequestId, R::Params)>\n-    where\n-        R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + 'static,\n-    {\n-        let req = self.req.take()?;\n-        let (id, params) = match req.extract::<R::Params>(R::METHOD) {\n-            Ok(it) => it,\n-            Err(req) => {\n-                self.req = Some(req);\n-                return None;\n-            }\n-        };\n-        self.global_state\n-            .req_queue\n-            .incoming\n-            .register(id.clone(), (R::METHOD, self.request_received));\n-        Some((id, params))\n-    }\n-\n-    fn finish(&mut self) {\n-        match self.req.take() {\n-            None => (),\n-            Some(req) => {\n-                log::error!(\"unknown request: {:?}\", req);\n-                let resp = Response::new_err(\n-                    req.id,\n-                    ErrorCode::MethodNotFound as i32,\n-                    \"unknown request\".to_string(),\n-                );\n-                self.msg_sender.send(resp.into()).unwrap();\n-            }\n-        }\n-    }\n-}\n-\n-fn result_to_task<R>(id: RequestId, result: Result<R::Result>) -> Task\n-where\n-    R: lsp_types::request::Request + 'static,\n-    R::Params: DeserializeOwned + 'static,\n-    R::Result: Serialize + 'static,\n-{\n-    let response = match result {\n-        Ok(resp) => Response::new_ok(id, &resp),\n-        Err(e) => match e.downcast::<LspError>() {\n-            Ok(lsp_error) => Response::new_err(id, lsp_error.code, lsp_error.message),\n-            Err(e) => {\n-                if is_canceled(&*e) {\n-                    Response::new_err(\n-                        id,\n-                        ErrorCode::ContentModified as i32,\n-                        \"content modified\".to_string(),\n-                    )\n-                } else {\n-                    Response::new_err(id, ErrorCode::InternalError as i32, e.to_string())\n-                }\n-            }\n-        },\n-    };\n-    Task::Respond(response)\n-}\n-\n-fn update_file_notifications_on_threadpool(\n-    global_state: &mut GlobalState,\n-    subscriptions: Vec<FileId>,\n-) {\n-    log::trace!(\"updating notifications for {:?}\", subscriptions);\n-    if global_state.config.publish_diagnostics {\n-        let snapshot = global_state.snapshot();\n-        global_state.task_pool.0.spawn(move || {\n-            let diagnostics = subscriptions\n-                .into_iter()\n-                .filter_map(|file_id| {\n-                    handlers::publish_diagnostics(&snapshot, file_id)\n-                        .map_err(|err| {\n-                            if !is_canceled(&*err) {\n-                                log::error!(\"failed to compute diagnostics: {:?}\", err);\n-                            }\n-                            ()\n-                        })\n-                        .ok()\n-                })\n-                .collect::<Vec<_>>();\n-            Task::Diagnostics(diagnostics)\n-        })\n-    }\n+    global_state.send(notification.into());\n }"}, {"sha": "25ba8d7982dd3fee97150198c4e2ea34d7d512f1", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5aa92bab94880a289372c66c99117ae5e6e9e1f/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=b5aa92bab94880a289372c66c99117ae5e6e9e1f", "patch": "@@ -82,7 +82,12 @@ impl NotifyActor {\n             watcher_receiver,\n         }\n     }\n-\n+    fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n+        select! {\n+            recv(receiver) -> it => it.ok().map(Event::Message),\n+            recv(&self.watcher_receiver) -> it => Some(Event::NotifyEvent(it.unwrap())),\n+        }\n+    }\n     fn run(mut self, inbox: Receiver<Message>) {\n         while let Some(event) = self.next_event(&inbox) {\n             log::debug!(\"vfs-notify event: {:?}\", event);\n@@ -154,12 +159,6 @@ impl NotifyActor {\n             }\n         }\n     }\n-    fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n-        select! {\n-            recv(receiver) -> it => it.ok().map(Event::Message),\n-            recv(&self.watcher_receiver) -> it => Some(Event::NotifyEvent(it.unwrap())),\n-        }\n-    }\n     fn load_entry(\n         &mut self,\n         entry: loader::Entry,"}]}