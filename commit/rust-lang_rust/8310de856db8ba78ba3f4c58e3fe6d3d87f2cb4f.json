{"sha": "8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMTBkZTg1NmRiOGJhNzhiYTNmNGM1OGUzZmU2ZDNkODdmMmNiNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-16T16:46:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-16T16:46:09Z"}, "message": "Auto merge of #33429 - ranma42:fix-x87-parsing, r=alexcrichton\n\nFix fast path of float parsing on x87\n\nThe fast path of the float parser relies on the rounding to happen\nexactly and directly to the correct number of bits. On x87, instead,\ndouble rounding would occour as the FPU stack defaults to 80 bits of\nprecision.\n\nThis can be fixed by setting the precision of the FPU stack before\nperforming the int to float conversion. This can be achieved by\nchanging the value of the x87 control word. This is a somewhat common\noperation that is in fact performed whenever a float needs to be\ntruncated to an integer, but it is undesirable to add its overhead for\ncode that does not rely on x87 for computations (i.e. on non-x86\narchitectures, or x86 architectures which perform FPU computations on\nusing SSE).\n\nFixes `num::dec2flt::fast_path_correct` (on x87).", "tree": {"sha": "52deea39bd5881872b1d8c2130d3a81f9b5e6b6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52deea39bd5881872b1d8c2130d3a81f9b5e6b6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f", "html_url": "https://github.com/rust-lang/rust/commit/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1ccf97e51ca22ccfa585aec85392cc059bc0e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ccf97e51ca22ccfa585aec85392cc059bc0e12", "html_url": "https://github.com/rust-lang/rust/commit/c1ccf97e51ca22ccfa585aec85392cc059bc0e12"}, {"sha": "4ec1f8de418a96dc2c5f3e70e4e344fc307569e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec1f8de418a96dc2c5f3e70e4e344fc307569e3", "html_url": "https://github.com/rust-lang/rust/commit/4ec1f8de418a96dc2c5f3e70e4e344fc307569e3"}], "stats": {"total": 91, "additions": 81, "deletions": 10}, "files": [{"sha": "a054e41b2084aa06abfa9736f0043e02aa31f39b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f", "patch": "@@ -61,7 +61,9 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(allow_internal_unstable)]\n+#![feature(asm)]\n #![feature(associated_type_defaults)]\n+#![feature(cfg_target_feature)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "c7af46a1e4f6ba62e5598baaf1800f7606654120", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=8310de856db8ba78ba3f4c58e3fe6d3d87f2cb4f", "patch": "@@ -32,19 +32,80 @@ fn power_of_ten(e: i16) -> Fp {\n     Fp { f: sig, e: exp }\n }\n \n+// In most architectures, floating point operations have an explicit bit size, therefore the\n+// precision of the computation is determined on a per-operation basis.\n+#[cfg(any(not(target_arch=\"x86\"), target_feature=\"sse2\"))]\n+mod fpu_precision {\n+    pub fn set_precision<T>() { }\n+}\n+\n+// On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n+// The x87 FPU operates with 80 bits of precision by default, which means that operations will\n+// round to 80 bits causing double rounding to happen when values are eventually represented as\n+// 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n+// computations are performed in the desired precision.\n+#[cfg(all(target_arch=\"x86\", not(target_feature=\"sse2\")))]\n+mod fpu_precision {\n+    use mem::size_of;\n+    use ops::Drop;\n+\n+    /// A structure used to preserve the original value of the FPU control word, so that it can be\n+    /// restored when the structure is dropped.\n+    ///\n+    /// The x87 FPU is a 16-bits register whose fields are as follows:\n+    ///\n+    /// | 12-15 | 10-11 | 8-9 | 6-7 |  5 |  4 |  3 |  2 |  1 |  0 |\n+    /// |------:|------:|----:|----:|---:|---:|---:|---:|---:|---:|\n+    /// |       | RC    | PC  |     | PM | UM | OM | ZM | DM | IM |\n+    ///\n+    /// The documentation for all of the fields is available in the IA-32 Architectures Software\n+    /// Developer's Manual (Volume 1).\n+    ///\n+    /// The only field which is relevant for the following code is PC, Precision Control. This\n+    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n+    ///  - 0b00, single precision i.e. 32-bits\n+    ///  - 0b10, double precision i.e. 64-bits\n+    ///  - 0b11, double extended precision i.e. 80-bits (default state)\n+    /// The 0b01 value is reserved and should not be used.\n+    pub struct FPUControlWord(u16);\n+\n+    fn set_cw(cw: u16) {\n+        unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n+    }\n+\n+    /// Set the precision field of the FPU to `T` and return a `FPUControlWord`\n+    pub fn set_precision<T>() -> FPUControlWord {\n+        let cw = 0u16;\n+\n+        // Compute the value for the Precision Control field that is appropriate for `T`.\n+        let cw_precision = match size_of::<T>() {\n+            4 => 0x0000, // 32 bits\n+            8 => 0x0200, // 64 bits\n+            _ => 0x0300, // default, 80 bits\n+        };\n+\n+        // Get the original value of the control word to restore it later, when the\n+        // `FPUControlWord` structure is dropped\n+        unsafe { asm!(\"fnstcw $0\" : \"=*m\" (&cw) ::: \"volatile\") }\n+\n+        // Set the control word to the desired precision. This is achieved by masking away the old\n+        // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.\n+        set_cw((cw & 0xFCFF) | cw_precision);\n+\n+        FPUControlWord(cw)\n+    }\n+\n+    impl Drop for FPUControlWord {\n+        fn drop(&mut self) {\n+            set_cw(self.0)\n+        }\n+    }\n+}\n+\n /// The fast path of Bellerophon using machine-sized integers and floats.\n ///\n /// This is extracted into a separate function so that it can be attempted before constructing\n /// a bignum.\n-///\n-/// The fast path crucially depends on arithmetic being correctly rounded, so on x86\n-/// without SSE or SSE2 it will be **wrong** (as in, off by one ULP occasionally), because the x87\n-/// FPU stack will round to 80 bit first before rounding to 64/32 bit. However, as such hardware\n-/// is extremely rare nowadays and in fact all in-tree target triples assume an SSE2-capable\n-/// microarchitecture, there is little incentive to deal with that. There's a test that will fail\n-/// when SSE or SSE2 is disabled, so people building their own non-SSE copy will get a heads up.\n-///\n-/// FIXME: It would nevertheless be nice if we had a good way to detect and deal with x87.\n pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n     let num_digits = integral.len() + fractional.len();\n     // log_10(f64::max_sig) ~ 15.95. We compare the exact value to max_sig near the end,\n@@ -60,9 +121,17 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n     if f > T::max_sig() {\n         return None;\n     }\n+\n+    // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n+    // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n+    // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n+    // The `set_precision` function takes care of setting the precision on architectures which\n+    // require setting it by changing the global state (like the control word of the x87 FPU).\n+    let _cw = fpu_precision::set_precision::<T>();\n+\n     // The case e < 0 cannot be folded into the other branch. Negative powers result in\n     // a repeating fractional part in binary, which are rounded, which causes real\n-    // (and occasioally quite significant!) errors in the final result.\n+    // (and occasionally quite significant!) errors in the final result.\n     if e >= 0 {\n         Some(T::from_int(f) * T::short_fast_pow10(e as usize))\n     } else {"}]}