{"sha": "1614d92f5179d3fd947fedc903bd13b0824a42de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MTRkOTJmNTE3OWQzZmQ5NDdmZWRjOTAzYmQxM2IwODI0YTQyZGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-19T07:13:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-20T05:28:47Z"}, "message": "rustc_resolve: move unused import checking into its own module.", "tree": {"sha": "4ef945abe461a6477e1c7c02006f5b847b50f6e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ef945abe461a6477e1c7c02006f5b847b50f6e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1614d92f5179d3fd947fedc903bd13b0824a42de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1614d92f5179d3fd947fedc903bd13b0824a42de", "html_url": "https://github.com/rust-lang/rust/commit/1614d92f5179d3fd947fedc903bd13b0824a42de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1614d92f5179d3fd947fedc903bd13b0824a42de/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c54fc980f3e9f50620a8335029bf644753f7c89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c54fc980f3e9f50620a8335029bf644753f7c89d", "html_url": "https://github.com/rust-lang/rust/commit/c54fc980f3e9f50620a8335029bf644753f7c89d"}], "stats": {"total": 319, "additions": 178, "deletions": 141}, "files": [{"sha": "39cdf6fc8f31828596e52a6ef1c31d5741f1e5b1", "filename": "src/librustc_resolve/check_unused.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/1614d92f5179d3fd947fedc903bd13b0824a42de/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1614d92f5179d3fd947fedc903bd13b0824a42de/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=1614d92f5179d3fd947fedc903bd13b0824a42de", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//\n+// Unused import checking\n+//\n+// Although this is mostly a lint pass, it lives in here because it depends on\n+// resolve data structures and because it finalises the privacy information for\n+// `use` directives.\n+//\n+\n+use Resolver;\n+use Namespace::{TypeNS, ValueNS};\n+\n+use rustc::lint;\n+use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n+use syntax::ast;\n+use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse};\n+use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::visit::{mod, Visitor};\n+\n+struct UnusedImportCheckVisitor<'a, 'b:'a> {\n+    resolver: &'a mut Resolver<'b>\n+}\n+\n+// Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n+impl<'a, 'b> Deref<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+        &*self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> DerefMut<Resolver<'b>> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+        &mut *self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n+    // We have information about whether `use` (import) directives are actually used now.\n+    // If an import is not used at all, we signal a lint error. If an import is only used\n+    // for a single namespace, we remove the other namespace from the recorded privacy\n+    // information. That means in privacy.rs, we will only check imports and namespaces\n+    // which are used. In particular, this means that if an import could name either a\n+    // public or private item, we will check the correct thing, dependent on how the import\n+    // is used.\n+    fn finalize_import(&mut self, id: ast::NodeId, span: Span) {\n+        debug!(\"finalizing import uses for {}\",\n+                self.session.codemap().span_to_snippet(span));\n+\n+        if !self.used_imports.contains(&(id, TypeNS)) &&\n+           !self.used_imports.contains(&(id, ValueNS)) {\n+            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n+                                  id,\n+                                  span,\n+                                  \"unused import\".to_string());\n+        }\n+\n+        let (v_priv, t_priv) = match self.last_private.get(&id) {\n+            Some(&LastImport {\n+                value_priv: v,\n+                value_used: _,\n+                type_priv: t,\n+                type_used: _\n+            }) => (v, t),\n+            Some(_) => {\n+                panic!(\"we should only have LastImport for `use` directives\")\n+            }\n+            _ => return,\n+        };\n+\n+        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n+            Used\n+        } else {\n+            Unused\n+        };\n+        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n+            Used\n+        } else {\n+            Unused\n+        };\n+\n+        match (v_priv, t_priv) {\n+            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n+            // we might have two LastPrivates pointing at the same thing. There is no point\n+            // checking both, so lets not check the value one.\n+            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n+            _ => {},\n+        }\n+\n+        self.last_private.insert(id, LastImport{value_priv: v_priv,\n+                                                value_used: v_used,\n+                                                type_priv: t_priv,\n+                                                type_used: t_used});\n+    }\n+}\n+\n+impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n+    fn visit_view_item(&mut self, vi: &ViewItem) {\n+        // Ignore is_public import statements because there's no way to be sure\n+        // whether they're used or not. Also ignore imports with a dummy span\n+        // because this means that they were generated in some fashion by the\n+        // compiler and we don't need to consider them.\n+        if vi.vis == ast::Public || vi.span == DUMMY_SP {\n+            visit::walk_view_item(self, vi);\n+            return;\n+        }\n+\n+        match vi.node {\n+            ViewItemExternCrate(_, _, id) => {\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+                    if !self.used_crates.contains(&crate_num) {\n+                        self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n+                                              id,\n+                                              vi.span,\n+                                              \"unused extern crate\".to_string());\n+                    }\n+                }\n+            },\n+            ViewItemUse(ref p) => {\n+                match p.node {\n+                    ViewPathSimple(_, _, id) => {\n+                        self.finalize_import(id, p.span)\n+                    }\n+\n+                    ViewPathList(_, ref list, _) => {\n+                        for i in list.iter() {\n+                            self.finalize_import(i.node.id(), i.span);\n+                        }\n+                    }\n+                    ViewPathGlob(_, id) => {\n+                        if !self.used_imports.contains(&(id, TypeNS)) &&\n+                           !self.used_imports.contains(&(id, ValueNS)) {\n+                            self.session\n+                                .add_lint(lint::builtin::UNUSED_IMPORTS,\n+                                          id,\n+                                          p.span,\n+                                          \"unused import\".to_string());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        visit::walk_view_item(self, vi);\n+    }\n+}\n+\n+pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n+    let mut visitor = UnusedImportCheckVisitor { resolver: resolver };\n+    visit::walk_crate(&mut visitor, krate);\n+}"}, {"sha": "d18e5d4ab08c0054607cbe5da37fb412bcd0c45e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 141, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/1614d92f5179d3fd947fedc903bd13b0824a42de/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1614d92f5179d3fd947fedc903bd13b0824a42de/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1614d92f5179d3fd947fedc903bd13b0824a42de", "patch": "@@ -96,6 +96,8 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n+mod check_unused;\n+\n #[deriving(Copy)]\n struct BindingInfo {\n     span: Span,\n@@ -935,17 +937,6 @@ impl<'a, 'b, 'v> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b> {\n \n }\n \n-struct UnusedImportCheckVisitor<'a, 'b:'a> {\n-    resolver: &'a mut Resolver<'b>\n-}\n-\n-impl<'a, 'b, 'v> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn visit_view_item(&mut self, vi: &ViewItem) {\n-        self.resolver.check_for_item_unused_imports(vi);\n-        visit::walk_view_item(self, vi);\n-    }\n-}\n-\n #[deriving(PartialEq)]\n enum FallbackChecks {\n     Everything,\n@@ -1006,22 +997,6 @@ impl<'a> Resolver<'a> {\n             emit_errors: true,\n         }\n     }\n-    /// The main name resolution procedure.\n-    fn resolve(&mut self, krate: &ast::Crate) {\n-        self.build_reduced_graph(krate);\n-        self.session.abort_if_errors();\n-\n-        self.resolve_imports();\n-        self.session.abort_if_errors();\n-\n-        self.record_exports();\n-        self.session.abort_if_errors();\n-\n-        self.resolve_crate(krate);\n-        self.session.abort_if_errors();\n-\n-        self.check_for_unused_imports(krate);\n-    }\n \n     //\n     // Reduced graph building\n@@ -6068,119 +6043,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    //\n-    // Unused import checking\n-    //\n-    // Although this is mostly a lint pass, it lives in here because it depends on\n-    // resolve data structures and because it finalises the privacy information for\n-    // `use` directives.\n-    //\n-\n-    fn check_for_unused_imports(&mut self, krate: &ast::Crate) {\n-        let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    fn check_for_item_unused_imports(&mut self, vi: &ViewItem) {\n-        // Ignore is_public import statements because there's no way to be sure\n-        // whether they're used or not. Also ignore imports with a dummy span\n-        // because this means that they were generated in some fashion by the\n-        // compiler and we don't need to consider them.\n-        if vi.vis == Public { return }\n-        if vi.span == DUMMY_SP { return }\n-\n-        match vi.node {\n-            ViewItemExternCrate(_, _, id) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n-                    if !self.used_crates.contains(&crate_num) {\n-                        self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                              id,\n-                                              vi.span,\n-                                              \"unused extern crate\".to_string());\n-                    }\n-                }\n-            },\n-            ViewItemUse(ref p) => {\n-                match p.node {\n-                    ViewPathSimple(_, _, id) => self.finalize_import(id, p.span),\n-\n-                    ViewPathList(_, ref list, _) => {\n-                        for i in list.iter() {\n-                            self.finalize_import(i.node.id(), i.span);\n-                        }\n-                    },\n-                    ViewPathGlob(_, id) => {\n-                        if !self.used_imports.contains(&(id, TypeNS)) &&\n-                           !self.used_imports.contains(&(id, ValueNS)) {\n-                            self.session\n-                                .add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                          id,\n-                                          p.span,\n-                                          \"unused import\".to_string());\n-                        }\n-                    },\n-                }\n-            }\n-        }\n-    }\n-\n-    // We have information about whether `use` (import) directives are actually used now.\n-    // If an import is not used at all, we signal a lint error. If an import is only used\n-    // for a single namespace, we remove the other namespace from the recorded privacy\n-    // information. That means in privacy.rs, we will only check imports and namespaces\n-    // which are used. In particular, this means that if an import could name either a\n-    // public or private item, we will check the correct thing, dependent on how the import\n-    // is used.\n-    fn finalize_import(&mut self, id: NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\",\n-               self.session.codemap().span_to_snippet(span));\n-\n-        if !self.used_imports.contains(&(id, TypeNS)) &&\n-           !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                  id,\n-                                  span,\n-                                  \"unused import\".to_string());\n-        }\n-\n-        let (v_priv, t_priv) = match self.last_private.get(&id) {\n-            Some(&LastImport {\n-                value_priv: v,\n-                value_used: _,\n-                type_priv: t,\n-                type_used: _\n-            }) => (v, t),\n-            Some(_) => {\n-                panic!(\"we should only have LastImport for `use` directives\")\n-            }\n-            _ => return,\n-        };\n-\n-        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n-            Used\n-        } else {\n-            Unused\n-        };\n-\n-        match (v_priv, t_priv) {\n-            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n-            // we might have two LastPrivates pointing at the same thing. There is no point\n-            // checking both, so lets not check the value one.\n-            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n-            _ => {},\n-        }\n-\n-        self.last_private.insert(id, LastImport{value_priv: v_priv,\n-                                                value_used: v_used,\n-                                                type_priv: t_priv,\n-                                                type_used: t_used});\n-    }\n-\n     //\n     // Diagnostics\n     //\n@@ -6268,7 +6130,21 @@ pub fn resolve_crate(session: &Session,\n                      krate: &Crate)\n                   -> CrateMap {\n     let mut resolver = Resolver::new(session, krate.span);\n-    resolver.resolve(krate);\n+\n+    resolver.build_reduced_graph(krate);\n+    session.abort_if_errors();\n+\n+    resolver.resolve_imports();\n+    session.abort_if_errors();\n+\n+    resolver.record_exports();\n+    session.abort_if_errors();\n+\n+    resolver.resolve_crate(krate);\n+    session.abort_if_errors();\n+\n+    check_unused::check_crate(&mut resolver, krate);\n+\n     CrateMap {\n         def_map: resolver.def_map,\n         freevars: resolver.freevars,"}]}