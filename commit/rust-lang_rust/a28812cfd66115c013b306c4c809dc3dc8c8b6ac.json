{"sha": "a28812cfd66115c013b306c4c809dc3dc8c8b6ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyODgxMmNmZDY2MTE1YzAxM2IzMDZjNGM4MDlkYzNkYzhjOGI2YWM=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-28T00:32:15Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-31T01:04:19Z"}, "message": "Improve some documentation.", "tree": {"sha": "0a278f1b82616928ed0d891be4b55189f6d2d995", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a278f1b82616928ed0d891be4b55189f6d2d995"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a28812cfd66115c013b306c4c809dc3dc8c8b6ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a28812cfd66115c013b306c4c809dc3dc8c8b6ac", "html_url": "https://github.com/rust-lang/rust/commit/a28812cfd66115c013b306c4c809dc3dc8c8b6ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a28812cfd66115c013b306c4c809dc3dc8c8b6ac/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19922fcd93bfeac123719e319b7166f50660f847", "url": "https://api.github.com/repos/rust-lang/rust/commits/19922fcd93bfeac123719e319b7166f50660f847", "html_url": "https://github.com/rust-lang/rust/commit/19922fcd93bfeac123719e319b7166f50660f847"}], "stats": {"total": 34, "additions": 20, "deletions": 14}, "files": [{"sha": "a5fc20c461b2217d27368d953a04183a3b30bdd0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a28812cfd66115c013b306c4c809dc3dc8c8b6ac/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28812cfd66115c013b306c4c809dc3dc8c8b6ac/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a28812cfd66115c013b306c4c809dc3dc8c8b6ac", "patch": "@@ -5,63 +5,69 @@ import ast::{ident, matcher_, matcher, match_tok,\n import parse::lexer::{new_tt_reader, tt_reader_as_reader, reader};\n import parse::token::{FAT_ARROW, SEMI, LBRACE, RBRACE, nt_matchers, nt_tt};\n import parse::parser::{parser, SOURCE_FILE};\n-import earley_parser::{parse, success, failure, named_match,\n+import earley_parser::{parse, parse_or_else, success, failure, named_match,\n                        matched_seq, matched_nonterminal};\n import std::map::hashmap;\n \n-\n-\n fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                      arg: ~[ast::token_tree]) -> base::mac_result {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n         {node: m, span: {lo: 0u, hi: 0u, expn_info: none}}\n     }\n \n+    // The grammar for macro_rules! is:\n+    // $( $lhs:mtcs => $rhs:tt );+\n+    // ...quasiquoting this would be nice.\n     let argument_gram = ~[\n         ms(match_seq(~[\n             ms(match_nonterminal(@~\"lhs\",@~\"matchers\", 0u)),\n             ms(match_tok(FAT_ARROW)),\n             ms(match_nonterminal(@~\"rhs\",@~\"tt\", 1u)),\n         ], some(SEMI), false, 0u, 2u))];\n \n+\n+    // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                    cx.parse_sess().interner, none, arg);\n-    let arguments = alt parse(cx.parse_sess(), cx.cfg(),\n-                              arg_reader as reader, argument_gram) {\n-      success(m) { m }\n-      failure(sp, msg) { cx.span_fatal(sp, msg); }\n-    };\n+    let argument_map = parse_or_else(cx.parse_sess(), cx.cfg(),\n+                                     arg_reader as reader, argument_gram);\n \n-    let lhses = alt arguments.get(@~\"lhs\") {\n+    // Extract the arguments:\n+    let lhses:~[@named_match] = alt argument_map.get(@~\"lhs\") {\n       @matched_seq(s, sp) { s }\n       _ { cx.span_bug(sp, ~\"wrong-structured lhs\") }\n     };\n-    let rhses = alt arguments.get(@~\"rhs\") {\n+    let rhses:~[@named_match] = alt argument_map.get(@~\"rhs\") {\n       @matched_seq(s, sp) { s }\n       _ { cx.span_bug(sp, ~\"wrong-structured rhs\") }\n     };\n \n+    // Given `lhses` and `rhses`, this is the new macro we create\n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree],\n                          lhses: ~[@named_match], rhses: ~[@named_match])\n     -> mac_result {\n+        // Which arm's failure should we report? (the one furthest along)\n         let mut best_fail_spot = {lo: 0u, hi: 0u, expn_info: none};\n         let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n         let s_d = cx.parse_sess().span_diagnostic;\n         let itr = cx.parse_sess().interner;\n \n-        for lhses.eachi() |i, lhs| {\n+        for lhses.eachi() |i, lhs| { // try each arm's matchers\n             alt lhs {\n               @matched_nonterminal(nt_matchers(mtcs)) {\n+                // `none` is because we're not interpolating\n                 let arg_rdr = new_tt_reader(s_d, itr, none, arg) as reader;\n                 alt parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs) {\n-                  success(m) {\n-                    let rhs = alt rhses[i] {\n+                  success(named_matches) {\n+                    let rhs = alt rhses[i] { // okay, what's your transcriber?\n                       @matched_nonterminal(nt_tt(@tt)) { tt }\n                       _ { cx.span_bug(sp, ~\"bad thing in rhs\") }\n                     };\n-                    let trncbr = new_tt_reader(s_d, itr, some(m), ~[rhs]);\n+                    // rhs has holes ( `$id` and `$(...)` that need filled)\n+                    let trncbr = new_tt_reader(s_d, itr, some(named_matches),\n+                                               ~[rhs]);\n                     let p = parser(cx.parse_sess(), cx.cfg(),\n                                    trncbr as reader, SOURCE_FILE);\n                     ret mr_expr(p.parse_expr());"}]}