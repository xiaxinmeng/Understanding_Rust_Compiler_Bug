{"sha": "53f54dda60a769fa6b3d325f5787134bc9d90c6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZjU0ZGRhNjBhNzY5ZmE2YjNkMzI1ZjU3ODcxMzRiYzlkOTBjNmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-02T20:41:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:53:33Z"}, "message": "librustc: Remove def_ids from types.", "tree": {"sha": "8fdbd1ef5b78826de51557510fbf08bd6bab5bef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fdbd1ef5b78826de51557510fbf08bd6bab5bef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53f54dda60a769fa6b3d325f5787134bc9d90c6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53f54dda60a769fa6b3d325f5787134bc9d90c6b", "html_url": "https://github.com/rust-lang/rust/commit/53f54dda60a769fa6b3d325f5787134bc9d90c6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53f54dda60a769fa6b3d325f5787134bc9d90c6b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04df19c5ca78d94e01dacbfb99471509128c6f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/04df19c5ca78d94e01dacbfb99471509128c6f8a", "html_url": "https://github.com/rust-lang/rust/commit/04df19c5ca78d94e01dacbfb99471509128c6f8a"}], "stats": {"total": 58, "additions": 8, "deletions": 50}, "files": [{"sha": "5b19834b31c0b315716b4077dbaaf7d0fbb69fe8", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=53f54dda60a769fa6b3d325f5787134bc9d90c6b", "patch": "@@ -249,12 +249,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n \n pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: cmd) -> ty::t {\n-    let t = doc_type(item, tcx, cdata);\n-    if family_names_type(item_family(item)) {\n-        ty::mk_with_id(tcx, t, item_id)\n-    } else {\n-        t\n-    }\n+    doc_type(item, tcx, cdata)\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {"}, {"sha": "709f1d4fc35d78df05e0f64dbbdef56cf0466e32", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=53f54dda60a769fa6b3d325f5787134bc9d90c6b", "patch": "@@ -381,9 +381,9 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         }\n       }\n       '\"' => {\n-        let def = parse_def(st, TypeWithId, conv);\n+        let _ = parse_def(st, TypeWithId, conv);\n         let inner = parse_ty(st, conv);\n-        ty::mk_with_id(st.tcx, inner, def)\n+        inner\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {"}, {"sha": "f6338f83ca61176f06ef39a15e88f177d0dc9f58", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=53f54dda60a769fa6b3d325f5787134bc9d90c6b", "patch": "@@ -78,19 +78,6 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n           Some(a) => { w.write_str(*a.s); return; }\n           None => {\n             let pos = w.tell();\n-            match ty::type_def_id(t) {\n-              Some(def_id) => {\n-                // Do not emit node ids that map to unexported names.  Those\n-                // are not helpful.\n-                if def_id.crate != local_crate ||\n-                    (cx.reachable)(def_id.node) {\n-                    w.write_char('\"');\n-                    w.write_str((cx.ds)(def_id));\n-                    w.write_char('|');\n-                }\n-              }\n-              _ => {}\n-            }\n             enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n             let end = w.tell();\n             let len = end - pos;"}, {"sha": "ff41f6f5ae125dd44fcf255359ba5089b78f74b0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=53f54dda60a769fa6b3d325f5787134bc9d90c6b", "patch": "@@ -133,7 +133,6 @@ impl to_bytes::IterBytes for creader_cache_key {\n \n struct intern_key {\n     sty: *sty,\n-    o_def_id: Option<ast::def_id>\n }\n \n // NB: Do not replace this with #[deriving(Eq)]. The automatically-derived\n@@ -142,7 +141,7 @@ struct intern_key {\n impl cmp::Eq for intern_key {\n     fn eq(&self, other: &intern_key) -> bool {\n         unsafe {\n-            *self.sty == *other.sty && self.o_def_id == other.o_def_id\n+            *self.sty == *other.sty\n         }\n     }\n     fn ne(&self, other: &intern_key) -> bool {\n@@ -153,7 +152,7 @@ impl cmp::Eq for intern_key {\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n-            to_bytes::iter_bytes_2(&*self.sty, &self.o_def_id, lsb0, f);\n+            (*self.sty).iter_bytes(lsb0, f);\n         }\n     }\n }\n@@ -326,7 +325,6 @@ pub struct t_box_ {\n     sty: sty,\n     id: uint,\n     flags: uint,\n-    o_def_id: Option<ast::def_id>\n }\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n@@ -359,7 +357,6 @@ pub fn type_needs_infer(t: t) -> bool {\n pub fn type_has_regions(t: t) -> bool {\n     tbox_has_flag(get(t), has_regions)\n }\n-pub fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Eq)]\n@@ -516,7 +513,6 @@ pub struct substs {\n mod primitives {\n     use super::{sty, t_box_};\n \n-    use core::option::None;\n     use syntax::ast;\n \n     macro_rules! def_prim_ty(\n@@ -525,7 +521,6 @@ mod primitives {\n                 sty: $sty,\n                 id: $id,\n                 flags: 0,\n-                o_def_id: None,\n             };\n         )\n     )\n@@ -551,14 +546,12 @@ mod primitives {\n         sty: super::ty_bot,\n         id: 16,\n         flags: super::has_ty_bot as uint,\n-        o_def_id: None,\n     };\n \n     pub static TY_ERR: t_box_ = t_box_ {\n         sty: super::ty_err,\n         id: 17,\n         flags: super::has_ty_err as uint,\n-        o_def_id: None,\n     };\n \n     pub static LAST_PRIMITIVE_ID: uint = 18;\n@@ -945,13 +938,11 @@ pub fn mk_ctxt(s: session::Session,\n      }\n }\n \n-\n // Type constructors\n-fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n+fn mk_t(cx: ctxt, +st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(cx),\n@@ -963,7 +954,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         _ => {}\n     };\n \n-    let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n+    let key = intern_key { sty: to_unsafe_ptr(&st) };\n     match cx.interner.find(&key) {\n       Some(t) => unsafe { return cast::transmute(&t.sty); },\n       _ => ()\n@@ -1039,14 +1030,12 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         sty: st,\n         id: *cx.next_id,\n         flags: flags,\n-        o_def_id: o_def_id\n     };\n \n     let sty_ptr = to_unsafe_ptr(&t.sty);\n \n     let key = intern_key {\n         sty: sty_ptr,\n-        o_def_id: o_def_id\n     };\n \n     cx.interner.insert(key, t);\n@@ -1263,10 +1252,6 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n-pub fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n-    mk_t_with_id(cx, /*bad*/copy get(base).sty, Some(def_id))\n-}\n-\n // Converts s to its machine type equivalent\n pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n     match get(t).sty {"}, {"sha": "36b46267316269029337b8427e5e41ca5c9f819b", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53f54dda60a769fa6b3d325f5787134bc9d90c6b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=53f54dda60a769fa6b3d325f5787134bc9d90c6b", "patch": "@@ -1085,16 +1085,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let tpt = {\n-            let ty = {\n-                let t0 = ccx.to_ty(&type_rscope(region_parameterization), t);\n-                // Do not associate a def id with a named, parameterized type\n-                // like \"foo<X>\".  This is because otherwise ty_to_str will\n-                // print the name as merely \"foo\", as it has no way to\n-                // reconstruct the value of X.\n-                if generics.is_parameterized() { t0 } else {\n-                    ty::mk_with_id(tcx, t0, def_id)\n-                }\n-            };\n+            let ty = ccx.to_ty(&type_rscope(region_parameterization), t);\n             ty_param_bounds_and_ty {\n                 generics: ty_generics(ccx, rp, generics, 0),\n                 ty: ty"}]}