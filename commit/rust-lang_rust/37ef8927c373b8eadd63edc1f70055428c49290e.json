{"sha": "37ef8927c373b8eadd63edc1f70055428c49290e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZWY4OTI3YzM3M2I4ZWFkZDYzZWRjMWY3MDA1NTQyOGM0OTI5MGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-16T23:06:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-16T23:06:14Z"}, "message": "split mbe expander code into two modules", "tree": {"sha": "b8bee4dd75c07f55b9f0d7e86380aba904557c3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8bee4dd75c07f55b9f0d7e86380aba904557c3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37ef8927c373b8eadd63edc1f70055428c49290e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37ef8927c373b8eadd63edc1f70055428c49290e", "html_url": "https://github.com/rust-lang/rust/commit/37ef8927c373b8eadd63edc1f70055428c49290e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37ef8927c373b8eadd63edc1f70055428c49290e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba583091e60553633dd3cc9ab37a1d9f64827a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba583091e60553633dd3cc9ab37a1d9f64827a1e", "html_url": "https://github.com/rust-lang/rust/commit/ba583091e60553633dd3cc9ab37a1d9f64827a1e"}], "stats": {"total": 866, "additions": 448, "deletions": 418}, "files": [{"sha": "15d9d83e25b61837885bee71fbe6106fc2ab3114", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 6, "deletions": 418, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=37ef8927c373b8eadd63edc1f70055428c49290e", "patch": "@@ -2,10 +2,11 @@\n //! `tt::TokenTree` representing an argument of macro invocation, and produces a\n //! `tt::TokenTree` for the result of the expansion.\n \n-use ra_parser::FragmentKind::*;\n+mod matcher;\n+mod transcriber;\n+\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n-use tt::TokenId;\n \n use crate::tt_cursor::TtCursor;\n use crate::ExpandError;\n@@ -19,14 +20,12 @@ pub(crate) fn expand(\n \n fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n     let mut input = TtCursor::new(input);\n-    let bindings = match_lhs(&rule.lhs, &mut input)?;\n+    let bindings = matcher::match_lhs(&rule.lhs, &mut input)?;\n     if !input.is_eof() {\n         return Err(ExpandError::UnexpectedToken);\n     }\n-\n-    let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new(), var_expanded: false };\n-\n-    expand_subtree(&rule.rhs, &mut ctx)\n+    let res = transcriber::transcribe(&bindings, &rule.rhs)?;\n+    Ok(res)\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -95,403 +94,6 @@ enum Fragment {\n     Ast(tt::TokenTree),\n }\n \n-impl Bindings {\n-    fn push_optional(&mut self, name: &SmolStr) {\n-        // FIXME: Do we have a better way to represent an empty token ?\n-        // Insert an empty subtree for empty token\n-        let tt = tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into();\n-        self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n-    }\n-\n-    fn push_empty(&mut self, name: &SmolStr) {\n-        self.inner.insert(name.clone(), Binding::Empty);\n-    }\n-\n-    fn contains(&self, name: &SmolStr) -> bool {\n-        self.inner.contains_key(name)\n-    }\n-\n-    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&Fragment, ExpandError> {\n-        let mut b = self.inner.get(name).ok_or_else(|| {\n-            ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n-        })?;\n-        for &idx in nesting.iter() {\n-            b = match b {\n-                Binding::Fragment(_) => break,\n-                Binding::Nested(bs) => bs.get(idx).ok_or_else(|| {\n-                    ExpandError::BindingError(format!(\"could not find nested binding `{}`\", name))\n-                })?,\n-                Binding::Empty => {\n-                    return Err(ExpandError::BindingError(format!(\n-                        \"could not find empty binding `{}`\",\n-                        name\n-                    )))\n-                }\n-            };\n-        }\n-        match b {\n-            Binding::Fragment(it) => Ok(it),\n-            Binding::Nested(_) => Err(ExpandError::BindingError(format!(\n-                \"expected simple binding, found nested binding `{}`\",\n-                name\n-            ))),\n-            Binding::Empty => Err(ExpandError::BindingError(format!(\n-                \"expected simple binding, found empty binding `{}`\",\n-                name\n-            ))),\n-        }\n-    }\n-\n-    fn push_nested(&mut self, idx: usize, nested: Bindings) -> Result<(), ExpandError> {\n-        for (key, value) in nested.inner {\n-            if !self.inner.contains_key(&key) {\n-                self.inner.insert(key.clone(), Binding::Nested(Vec::new()));\n-            }\n-            match self.inner.get_mut(&key) {\n-                Some(Binding::Nested(it)) => {\n-                    // insert empty nested bindings before this one\n-                    while it.len() < idx {\n-                        it.push(Binding::Nested(vec![]));\n-                    }\n-                    it.push(value);\n-                }\n-                _ => {\n-                    return Err(ExpandError::BindingError(format!(\n-                        \"could not find binding `{}`\",\n-                        key\n-                    )));\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn merge(&mut self, nested: Bindings) {\n-        self.inner.extend(nested.inner);\n-    }\n-}\n-\n-fn collect_vars(subtree: &crate::Subtree) -> Vec<SmolStr> {\n-    let mut res = vec![];\n-\n-    for tkn in subtree.token_trees.iter() {\n-        match tkn {\n-            crate::TokenTree::Leaf(crate::Leaf::Var(crate::Var { text, .. })) => {\n-                res.push(text.clone());\n-            }\n-            crate::TokenTree::Subtree(subtree) => {\n-                res.extend(collect_vars(subtree));\n-            }\n-            crate::TokenTree::Repeat(crate::Repeat { subtree, .. }) => {\n-                res.extend(collect_vars(subtree));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    res\n-}\n-\n-fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings, ExpandError> {\n-    let mut res = Bindings::default();\n-    for pat in pattern.token_trees.iter() {\n-        match pat {\n-            crate::TokenTree::Leaf(leaf) => match leaf {\n-                crate::Leaf::Var(crate::Var { text, kind }) => {\n-                    let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n-                    match match_meta_var(kind.as_str(), input)? {\n-                        Some(fragment) => {\n-                            res.inner.insert(text.clone(), Binding::Fragment(fragment));\n-                        }\n-                        None => res.push_optional(text),\n-                    }\n-                }\n-                crate::Leaf::Punct(punct) => {\n-                    if !input.eat_punct().map(|p| p.char == punct.char).unwrap_or(false) {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-                }\n-                crate::Leaf::Ident(ident) => {\n-                    if input.eat_ident().map(|i| &i.text) != Some(&ident.text) {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-                }\n-                crate::Leaf::Literal(literal) => {\n-                    if input.eat_literal().map(|i| &i.text) != Some(&literal.text) {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-                }\n-            },\n-            crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n-                // Dirty hack to make macro-expansion terminate.\n-                // This should be replaced by a propper macro-by-example implementation\n-                let mut limit = 65536;\n-                let mut counter = 0;\n-\n-                let mut memento = input.save();\n-\n-                loop {\n-                    match match_lhs(subtree, input) {\n-                        Ok(nested) => {\n-                            limit -= 1;\n-                            if limit == 0 {\n-                                log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", subtree, input, kind, separator);\n-                                break;\n-                            }\n-\n-                            memento = input.save();\n-                            res.push_nested(counter, nested)?;\n-                            counter += 1;\n-                            if counter == 1 {\n-                                if let crate::RepeatKind::ZeroOrOne = kind {\n-                                    break;\n-                                }\n-                            }\n-\n-                            if let Some(separator) = separator {\n-                                if !input\n-                                    .eat_seperator()\n-                                    .map(|sep| sep == *separator)\n-                                    .unwrap_or(false)\n-                                {\n-                                    input.rollback(memento);\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        Err(_) => {\n-                            input.rollback(memento);\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                match kind {\n-                    crate::RepeatKind::OneOrMore if counter == 0 => {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-                    _ if counter == 0 => {\n-                        // Collect all empty variables in subtrees\n-                        collect_vars(subtree).iter().for_each(|s| res.push_empty(s));\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            crate::TokenTree::Subtree(subtree) => {\n-                let input_subtree =\n-                    input.eat_subtree().map_err(|_| ExpandError::UnexpectedToken)?;\n-                if subtree.delimiter != input_subtree.delimiter {\n-                    return Err(ExpandError::UnexpectedToken);\n-                }\n-\n-                let mut input = TtCursor::new(input_subtree);\n-                let bindings = match_lhs(&subtree, &mut input)?;\n-                if !input.is_eof() {\n-                    return Err(ExpandError::UnexpectedToken);\n-                }\n-\n-                res.merge(bindings);\n-            }\n-        }\n-    }\n-    Ok(res)\n-}\n-\n-fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>, ExpandError> {\n-    let fragment = match kind {\n-        \"path\" => Path,\n-        \"expr\" => Expr,\n-        \"ty\" => Type,\n-        \"pat\" => Pattern,\n-        \"stmt\" => Statement,\n-        \"block\" => Block,\n-        \"meta\" => MetaItem,\n-        \"item\" => Item,\n-        _ => {\n-            let tt = match kind {\n-                \"ident\" => {\n-                    let ident = input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                    tt::Leaf::from(ident).into()\n-                }\n-                \"tt\" => input.eat().ok_or(ExpandError::UnexpectedToken)?.clone(),\n-                \"lifetime\" => input.eat_lifetime().ok_or(ExpandError::UnexpectedToken)?.clone(),\n-                \"literal\" => {\n-                    let literal = input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                    tt::Leaf::from(literal).into()\n-                }\n-                // `vis` is optional\n-                \"vis\" => match input.try_eat_vis() {\n-                    Some(vis) => vis,\n-                    None => return Ok(None),\n-                },\n-                _ => return Err(ExpandError::UnexpectedToken),\n-            };\n-            return Ok(Some(Fragment::Tokens(tt)));\n-        }\n-    };\n-    let tt = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n-    let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n-    Ok(Some(fragment))\n-}\n-\n-#[derive(Debug)]\n-struct ExpandCtx<'a> {\n-    bindings: &'a Bindings,\n-    nesting: Vec<usize>,\n-    var_expanded: bool,\n-}\n-\n-fn expand_subtree(\n-    template: &crate::Subtree,\n-    ctx: &mut ExpandCtx,\n-) -> Result<tt::Subtree, ExpandError> {\n-    let mut buf: Vec<tt::TokenTree> = Vec::new();\n-    for tt in template.token_trees.iter() {\n-        let tt = expand_tt(tt, ctx)?;\n-        push_fragment(&mut buf, tt);\n-    }\n-\n-    Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n-}\n-\n-fn expand_tt(template: &crate::TokenTree, ctx: &mut ExpandCtx) -> Result<Fragment, ExpandError> {\n-    let res: tt::TokenTree = match template {\n-        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n-        crate::TokenTree::Repeat(repeat) => {\n-            let mut buf: Vec<tt::TokenTree> = Vec::new();\n-            ctx.nesting.push(0);\n-            // Dirty hack to make macro-expansion terminate.\n-            // This should be replaced by a propper macro-by-example implementation\n-            let mut limit = 65536;\n-            let mut has_seps = 0;\n-            let mut counter = 0;\n-\n-            // We store the old var expanded value, and restore it later\n-            // It is because before this `$repeat`,\n-            // it is possible some variables already expanad in the same subtree\n-            //\n-            // `some_var_expanded` keep check if the deeper subtree has expanded variables\n-            let mut some_var_expanded = false;\n-            let old_var_expanded = ctx.var_expanded;\n-            ctx.var_expanded = false;\n-\n-            while let Ok(t) = expand_subtree(&repeat.subtree, ctx) {\n-                // if no var expanded in the child, we count it as a fail\n-                if !ctx.var_expanded {\n-                    break;\n-                }\n-\n-                // Reset `ctx.var_expandeded` to see if there is other expanded variable\n-                // in the next matching\n-                some_var_expanded = true;\n-                ctx.var_expanded = false;\n-\n-                counter += 1;\n-                limit -= 1;\n-                if limit == 0 {\n-                    log::warn!(\n-                        \"expand_tt excced in repeat pattern exceed limit => {:#?}\\n{:#?}\",\n-                        template,\n-                        ctx\n-                    );\n-                    break;\n-                }\n-\n-                let idx = ctx.nesting.pop().unwrap();\n-                ctx.nesting.push(idx + 1);\n-                push_subtree(&mut buf, t);\n-\n-                if let Some(ref sep) = repeat.separator {\n-                    match sep {\n-                        crate::Separator::Ident(ident) => {\n-                            has_seps = 1;\n-                            buf.push(tt::Leaf::from(ident.clone()).into());\n-                        }\n-                        crate::Separator::Literal(lit) => {\n-                            has_seps = 1;\n-                            buf.push(tt::Leaf::from(lit.clone()).into());\n-                        }\n-\n-                        crate::Separator::Puncts(puncts) => {\n-                            has_seps = puncts.len();\n-                            for punct in puncts {\n-                                buf.push(tt::Leaf::from(*punct).into());\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if let crate::RepeatKind::ZeroOrOne = repeat.kind {\n-                    break;\n-                }\n-            }\n-\n-            // Restore the `var_expanded` by combining old one and the new one\n-            ctx.var_expanded = some_var_expanded || old_var_expanded;\n-\n-            ctx.nesting.pop().unwrap();\n-            for _ in 0..has_seps {\n-                buf.pop();\n-            }\n-\n-            if crate::RepeatKind::OneOrMore == repeat.kind && counter == 0 {\n-                return Err(ExpandError::UnexpectedToken);\n-            }\n-\n-            // Check if it is a single token subtree without any delimiter\n-            // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n-            tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf }.into()\n-        }\n-        crate::TokenTree::Leaf(leaf) => match leaf {\n-            crate::Leaf::Ident(ident) => {\n-                tt::Leaf::from(tt::Ident { text: ident.text.clone(), id: TokenId::unspecified() })\n-                    .into()\n-            }\n-            crate::Leaf::Punct(punct) => tt::Leaf::from(*punct).into(),\n-            crate::Leaf::Var(v) => {\n-                if v.text == \"crate\" {\n-                    // FIXME: Properly handle $crate token\n-                    tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: TokenId::unspecified() })\n-                        .into()\n-                } else if !ctx.bindings.contains(&v.text) {\n-                    // Note that it is possible to have a `$var` inside a macro which is not bound.\n-                    // For example:\n-                    // ```\n-                    // macro_rules! foo {\n-                    //     ($a:ident, $b:ident, $c:tt) => {\n-                    //         macro_rules! bar {\n-                    //             ($bi:ident) => {\n-                    //                 fn $bi() -> u8 {$c}\n-                    //             }\n-                    //         }\n-                    //     }\n-                    // ```\n-                    // We just treat it a normal tokens\n-                    tt::Subtree {\n-                        delimiter: tt::Delimiter::None,\n-                        token_trees: vec![\n-                            tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone })\n-                                .into(),\n-                            tt::Leaf::from(tt::Ident {\n-                                text: v.text.clone(),\n-                                id: TokenId::unspecified(),\n-                            })\n-                            .into(),\n-                        ],\n-                    }\n-                    .into()\n-                } else {\n-                    let fragment = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n-                    ctx.var_expanded = true;\n-                    return Ok(fragment);\n-                }\n-            }\n-            crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n-        },\n-    };\n-    Ok(Fragment::Tokens(res))\n-}\n-\n #[cfg(test)]\n mod tests {\n     use ra_syntax::{ast, AstNode};\n@@ -562,17 +164,3 @@ mod tests {\n         expand_rule(&rules.rules[0], &invocation_tt)\n     }\n }\n-\n-fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n-    match fragment {\n-        Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n-        Fragment::Tokens(tt) | Fragment::Ast(tt) => buf.push(tt),\n-    }\n-}\n-\n-fn push_subtree(buf: &mut Vec<tt::TokenTree>, tt: tt::Subtree) {\n-    match tt.delimiter {\n-        tt::Delimiter::None => buf.extend(tt.token_trees),\n-        _ => buf.push(tt.into()),\n-    }\n-}"}, {"sha": "100a3b0e0ef8128e7743afae846d997b0e301737", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=37ef8927c373b8eadd63edc1f70055428c49290e", "patch": "@@ -0,0 +1,215 @@\n+use crate::{\n+    mbe_expander::{Binding, Bindings, Fragment},\n+    tt_cursor::TtCursor,\n+    ExpandError,\n+};\n+\n+use ra_parser::FragmentKind::*;\n+use ra_syntax::SmolStr;\n+\n+impl Bindings {\n+    fn push_optional(&mut self, name: &SmolStr) {\n+        // FIXME: Do we have a better way to represent an empty token ?\n+        // Insert an empty subtree for empty token\n+        let tt = tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into();\n+        self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n+    }\n+\n+    fn push_empty(&mut self, name: &SmolStr) {\n+        self.inner.insert(name.clone(), Binding::Empty);\n+    }\n+\n+    fn push_nested(&mut self, idx: usize, nested: Bindings) -> Result<(), ExpandError> {\n+        for (key, value) in nested.inner {\n+            if !self.inner.contains_key(&key) {\n+                self.inner.insert(key.clone(), Binding::Nested(Vec::new()));\n+            }\n+            match self.inner.get_mut(&key) {\n+                Some(Binding::Nested(it)) => {\n+                    // insert empty nested bindings before this one\n+                    while it.len() < idx {\n+                        it.push(Binding::Nested(vec![]));\n+                    }\n+                    it.push(value);\n+                }\n+                _ => {\n+                    return Err(ExpandError::BindingError(format!(\n+                        \"could not find binding `{}`\",\n+                        key\n+                    )));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn merge(&mut self, nested: Bindings) {\n+        self.inner.extend(nested.inner);\n+    }\n+}\n+\n+pub(super) fn match_lhs(\n+    pattern: &crate::Subtree,\n+    input: &mut TtCursor,\n+) -> Result<Bindings, ExpandError> {\n+    let mut res = Bindings::default();\n+    for pat in pattern.token_trees.iter() {\n+        match pat {\n+            crate::TokenTree::Leaf(leaf) => match leaf {\n+                crate::Leaf::Var(crate::Var { text, kind }) => {\n+                    let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n+                    match match_meta_var(kind.as_str(), input)? {\n+                        Some(fragment) => {\n+                            res.inner.insert(text.clone(), Binding::Fragment(fragment));\n+                        }\n+                        None => res.push_optional(text),\n+                    }\n+                }\n+                crate::Leaf::Punct(punct) => {\n+                    if !input.eat_punct().map(|p| p.char == punct.char).unwrap_or(false) {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+                }\n+                crate::Leaf::Ident(ident) => {\n+                    if input.eat_ident().map(|i| &i.text) != Some(&ident.text) {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+                }\n+                crate::Leaf::Literal(literal) => {\n+                    if input.eat_literal().map(|i| &i.text) != Some(&literal.text) {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+                }\n+            },\n+            crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n+                // Dirty hack to make macro-expansion terminate.\n+                // This should be replaced by a propper macro-by-example implementation\n+                let mut limit = 65536;\n+                let mut counter = 0;\n+\n+                let mut memento = input.save();\n+\n+                loop {\n+                    match match_lhs(subtree, input) {\n+                        Ok(nested) => {\n+                            limit -= 1;\n+                            if limit == 0 {\n+                                log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", subtree, input, kind, separator);\n+                                break;\n+                            }\n+\n+                            memento = input.save();\n+                            res.push_nested(counter, nested)?;\n+                            counter += 1;\n+                            if counter == 1 {\n+                                if let crate::RepeatKind::ZeroOrOne = kind {\n+                                    break;\n+                                }\n+                            }\n+\n+                            if let Some(separator) = separator {\n+                                if !input\n+                                    .eat_seperator()\n+                                    .map(|sep| sep == *separator)\n+                                    .unwrap_or(false)\n+                                {\n+                                    input.rollback(memento);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        Err(_) => {\n+                            input.rollback(memento);\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                match kind {\n+                    crate::RepeatKind::OneOrMore if counter == 0 => {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+                    _ if counter == 0 => {\n+                        // Collect all empty variables in subtrees\n+                        collect_vars(subtree).iter().for_each(|s| res.push_empty(s));\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            crate::TokenTree::Subtree(subtree) => {\n+                let input_subtree =\n+                    input.eat_subtree().map_err(|_| ExpandError::UnexpectedToken)?;\n+                if subtree.delimiter != input_subtree.delimiter {\n+                    return Err(ExpandError::UnexpectedToken);\n+                }\n+\n+                let mut input = TtCursor::new(input_subtree);\n+                let bindings = match_lhs(&subtree, &mut input)?;\n+                if !input.is_eof() {\n+                    return Err(ExpandError::UnexpectedToken);\n+                }\n+\n+                res.merge(bindings);\n+            }\n+        }\n+    }\n+    Ok(res)\n+}\n+\n+fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>, ExpandError> {\n+    let fragment = match kind {\n+        \"path\" => Path,\n+        \"expr\" => Expr,\n+        \"ty\" => Type,\n+        \"pat\" => Pattern,\n+        \"stmt\" => Statement,\n+        \"block\" => Block,\n+        \"meta\" => MetaItem,\n+        \"item\" => Item,\n+        _ => {\n+            let tt = match kind {\n+                \"ident\" => {\n+                    let ident = input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                    tt::Leaf::from(ident).into()\n+                }\n+                \"tt\" => input.eat().ok_or(ExpandError::UnexpectedToken)?.clone(),\n+                \"lifetime\" => input.eat_lifetime().ok_or(ExpandError::UnexpectedToken)?.clone(),\n+                \"literal\" => {\n+                    let literal = input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                    tt::Leaf::from(literal).into()\n+                }\n+                // `vis` is optional\n+                \"vis\" => match input.try_eat_vis() {\n+                    Some(vis) => vis,\n+                    None => return Ok(None),\n+                },\n+                _ => return Err(ExpandError::UnexpectedToken),\n+            };\n+            return Ok(Some(Fragment::Tokens(tt)));\n+        }\n+    };\n+    let tt = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n+    let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n+    Ok(Some(fragment))\n+}\n+\n+fn collect_vars(subtree: &crate::Subtree) -> Vec<SmolStr> {\n+    let mut res = Vec::new();\n+\n+    for tkn in subtree.token_trees.iter() {\n+        match tkn {\n+            crate::TokenTree::Leaf(crate::Leaf::Var(crate::Var { text, .. })) => {\n+                res.push(text.clone());\n+            }\n+            crate::TokenTree::Subtree(subtree) => {\n+                res.extend(collect_vars(subtree));\n+            }\n+            crate::TokenTree::Repeat(crate::Repeat { subtree, .. }) => {\n+                res.extend(collect_vars(subtree));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    res\n+}"}, {"sha": "a3df1b7de9005b0851f6c7c0dff745acdf93a030", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=37ef8927c373b8eadd63edc1f70055428c49290e", "patch": "@@ -0,0 +1,227 @@\n+use ra_syntax::SmolStr;\n+\n+use crate::{\n+    mbe_expander::{Binding, Bindings, Fragment},\n+    ExpandError,\n+};\n+\n+impl Bindings {\n+    fn contains(&self, name: &SmolStr) -> bool {\n+        self.inner.contains_key(name)\n+    }\n+\n+    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&Fragment, ExpandError> {\n+        let mut b = self.inner.get(name).ok_or_else(|| {\n+            ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n+        })?;\n+        for &idx in nesting.iter() {\n+            b = match b {\n+                Binding::Fragment(_) => break,\n+                Binding::Nested(bs) => bs.get(idx).ok_or_else(|| {\n+                    ExpandError::BindingError(format!(\"could not find nested binding `{}`\", name))\n+                })?,\n+                Binding::Empty => {\n+                    return Err(ExpandError::BindingError(format!(\n+                        \"could not find empty binding `{}`\",\n+                        name\n+                    )))\n+                }\n+            };\n+        }\n+        match b {\n+            Binding::Fragment(it) => Ok(it),\n+            Binding::Nested(_) => Err(ExpandError::BindingError(format!(\n+                \"expected simple binding, found nested binding `{}`\",\n+                name\n+            ))),\n+            Binding::Empty => Err(ExpandError::BindingError(format!(\n+                \"expected simple binding, found empty binding `{}`\",\n+                name\n+            ))),\n+        }\n+    }\n+}\n+\n+pub(super) fn transcribe(\n+    bindings: &Bindings,\n+    template: &crate::Subtree,\n+) -> Result<tt::Subtree, ExpandError> {\n+    let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new(), var_expanded: false };\n+    expand_subtree(template, &mut ctx)\n+}\n+\n+#[derive(Debug)]\n+struct ExpandCtx<'a> {\n+    bindings: &'a Bindings,\n+    nesting: Vec<usize>,\n+    var_expanded: bool,\n+}\n+\n+fn expand_subtree(\n+    template: &crate::Subtree,\n+    ctx: &mut ExpandCtx,\n+) -> Result<tt::Subtree, ExpandError> {\n+    let mut buf: Vec<tt::TokenTree> = Vec::new();\n+    for tt in template.token_trees.iter() {\n+        let tt = expand_tt(tt, ctx)?;\n+        push_fragment(&mut buf, tt);\n+    }\n+\n+    Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n+}\n+\n+fn expand_tt(template: &crate::TokenTree, ctx: &mut ExpandCtx) -> Result<Fragment, ExpandError> {\n+    let res: tt::TokenTree = match template {\n+        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n+        crate::TokenTree::Repeat(repeat) => {\n+            let mut buf: Vec<tt::TokenTree> = Vec::new();\n+            ctx.nesting.push(0);\n+            // Dirty hack to make macro-expansion terminate.\n+            // This should be replaced by a propper macro-by-example implementation\n+            let mut limit = 65536;\n+            let mut has_seps = 0;\n+            let mut counter = 0;\n+\n+            // We store the old var expanded value, and restore it later\n+            // It is because before this `$repeat`,\n+            // it is possible some variables already expanad in the same subtree\n+            //\n+            // `some_var_expanded` keep check if the deeper subtree has expanded variables\n+            let mut some_var_expanded = false;\n+            let old_var_expanded = ctx.var_expanded;\n+            ctx.var_expanded = false;\n+\n+            while let Ok(t) = expand_subtree(&repeat.subtree, ctx) {\n+                // if no var expanded in the child, we count it as a fail\n+                if !ctx.var_expanded {\n+                    break;\n+                }\n+\n+                // Reset `ctx.var_expandeded` to see if there is other expanded variable\n+                // in the next matching\n+                some_var_expanded = true;\n+                ctx.var_expanded = false;\n+\n+                counter += 1;\n+                limit -= 1;\n+                if limit == 0 {\n+                    log::warn!(\n+                        \"expand_tt excced in repeat pattern exceed limit => {:#?}\\n{:#?}\",\n+                        template,\n+                        ctx\n+                    );\n+                    break;\n+                }\n+\n+                let idx = ctx.nesting.pop().unwrap();\n+                ctx.nesting.push(idx + 1);\n+                push_subtree(&mut buf, t);\n+\n+                if let Some(ref sep) = repeat.separator {\n+                    match sep {\n+                        crate::Separator::Ident(ident) => {\n+                            has_seps = 1;\n+                            buf.push(tt::Leaf::from(ident.clone()).into());\n+                        }\n+                        crate::Separator::Literal(lit) => {\n+                            has_seps = 1;\n+                            buf.push(tt::Leaf::from(lit.clone()).into());\n+                        }\n+\n+                        crate::Separator::Puncts(puncts) => {\n+                            has_seps = puncts.len();\n+                            for punct in puncts {\n+                                buf.push(tt::Leaf::from(*punct).into());\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if let crate::RepeatKind::ZeroOrOne = repeat.kind {\n+                    break;\n+                }\n+            }\n+\n+            // Restore the `var_expanded` by combining old one and the new one\n+            ctx.var_expanded = some_var_expanded || old_var_expanded;\n+\n+            ctx.nesting.pop().unwrap();\n+            for _ in 0..has_seps {\n+                buf.pop();\n+            }\n+\n+            if crate::RepeatKind::OneOrMore == repeat.kind && counter == 0 {\n+                return Err(ExpandError::UnexpectedToken);\n+            }\n+\n+            // Check if it is a single token subtree without any delimiter\n+            // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n+            tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf }.into()\n+        }\n+        crate::TokenTree::Leaf(leaf) => match leaf {\n+            crate::Leaf::Ident(ident) => tt::Leaf::from(tt::Ident {\n+                text: ident.text.clone(),\n+                id: tt::TokenId::unspecified(),\n+            })\n+            .into(),\n+            crate::Leaf::Punct(punct) => tt::Leaf::from(*punct).into(),\n+            crate::Leaf::Var(v) => {\n+                if v.text == \"crate\" {\n+                    // FIXME: Properly handle $crate token\n+                    tt::Leaf::from(tt::Ident {\n+                        text: \"$crate\".into(),\n+                        id: tt::TokenId::unspecified(),\n+                    })\n+                    .into()\n+                } else if !ctx.bindings.contains(&v.text) {\n+                    // Note that it is possible to have a `$var` inside a macro which is not bound.\n+                    // For example:\n+                    // ```\n+                    // macro_rules! foo {\n+                    //     ($a:ident, $b:ident, $c:tt) => {\n+                    //         macro_rules! bar {\n+                    //             ($bi:ident) => {\n+                    //                 fn $bi() -> u8 {$c}\n+                    //             }\n+                    //         }\n+                    //     }\n+                    // ```\n+                    // We just treat it a normal tokens\n+                    tt::Subtree {\n+                        delimiter: tt::Delimiter::None,\n+                        token_trees: vec![\n+                            tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone })\n+                                .into(),\n+                            tt::Leaf::from(tt::Ident {\n+                                text: v.text.clone(),\n+                                id: tt::TokenId::unspecified(),\n+                            })\n+                            .into(),\n+                        ],\n+                    }\n+                    .into()\n+                } else {\n+                    let fragment = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n+                    ctx.var_expanded = true;\n+                    return Ok(fragment);\n+                }\n+            }\n+            crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n+        },\n+    };\n+    Ok(Fragment::Tokens(res))\n+}\n+\n+fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n+    match fragment {\n+        Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n+        Fragment::Tokens(tt) | Fragment::Ast(tt) => buf.push(tt),\n+    }\n+}\n+\n+fn push_subtree(buf: &mut Vec<tt::TokenTree>, tt: tt::Subtree) {\n+    match tt.delimiter {\n+        tt::Delimiter::None => buf.extend(tt.token_trees),\n+        _ => buf.push(tt.into()),\n+    }\n+}"}]}