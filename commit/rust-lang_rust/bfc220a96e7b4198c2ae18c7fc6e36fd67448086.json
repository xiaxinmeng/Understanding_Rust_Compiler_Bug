{"sha": "bfc220a96e7b4198c2ae18c7fc6e36fd67448086", "node_id": "C_kwDOAAsO6NoAKGJmYzIyMGE5NmU3YjQxOThjMmFlMThjN2ZjNmUzNmZkNjc0NDgwODY", "commit": {"author": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-02-07T16:59:51Z"}, "committer": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2023-03-04T15:37:40Z"}, "message": "Create BOLT build steps to avoid running BOLT multiple times on the same file", "tree": {"sha": "0e1820e82d22d2c28f6dc79ce9dd8154d3ae1856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e1820e82d22d2c28f6dc79ce9dd8154d3ae1856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfc220a96e7b4198c2ae18c7fc6e36fd67448086", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEzFQynJm4WzBnfhz8kJzQ0mSDUWsFAmQDZcQACgkQkJzQ0mSD\nUWtj5gwAyzGTzRjUnpGDH8eFgCN2AMSPrIXke/Ppduk8a6NsNt2QjuaO6Iop+vDf\nteGzqU6Jb3h+vcHcTB3U7qQb4Lo/FKzG/Q4xGncNw5DSTeN1rzLEGgjgW8WgtL3P\nvXoSI1JfI1JKnPeiMJkHtrt45Ekhe4KOgUy/c8t5HXrJceMxUi53i8r4Lbxuq5aB\nBiSAzA/NXw8fQR+ciighZQ2R6QNBybNZZhlq3wvO/UCOFQ9BxmlpetQeV4DJzubg\nLMjymE7DXG6ChMXOXc/8H48K8fNLk9ZSK1jG20A4cy06io/11QECwbwED6f+UKjt\n2g9dm1lNDIOYXrCi3YMTcMHaXX7aloAv6a6s383zlH8nwFq63DB0saNH2yFkKgDh\nanMn9AlWKlp+wcgbOb0cBoN4yB7F/doFhbdnOOVMVXAT6lPihAiajl6LTjbcaWO3\nhZLPn5te4pHlgXe8lwdX7pQeqCSWByrk+l0cYPom2F6s++zmSD+NK5IXBa5TTxYd\nNijzZZm2\n=dI00\n-----END PGP SIGNATURE-----", "payload": "tree 0e1820e82d22d2c28f6dc79ce9dd8154d3ae1856\nparent c5d65aa58043cc1eac76838319009fce9de1b019\nauthor Jakub Ber\u00e1nek <berykubik@gmail.com> 1675789191 +0100\ncommitter Jakub Ber\u00e1nek <berykubik@gmail.com> 1677944260 +0100\n\nCreate BOLT build steps to avoid running BOLT multiple times on the same file\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc220a96e7b4198c2ae18c7fc6e36fd67448086", "html_url": "https://github.com/rust-lang/rust/commit/bfc220a96e7b4198c2ae18c7fc6e36fd67448086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfc220a96e7b4198c2ae18c7fc6e36fd67448086/comments", "author": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5d65aa58043cc1eac76838319009fce9de1b019", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d65aa58043cc1eac76838319009fce9de1b019", "html_url": "https://github.com/rust-lang/rust/commit/c5d65aa58043cc1eac76838319009fce9de1b019"}], "stats": {"total": 146, "additions": 127, "deletions": 19}, "files": [{"sha": "973dc4f602b2af8b435495d15443f63c1601ee1d", "filename": "src/bootstrap/bolt.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bfc220a96e7b4198c2ae18c7fc6e36fd67448086/src%2Fbootstrap%2Fbolt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc220a96e7b4198c2ae18c7fc6e36fd67448086/src%2Fbootstrap%2Fbolt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbolt.rs?ref=bfc220a96e7b4198c2ae18c7fc6e36fd67448086", "patch": "@@ -1,47 +1,40 @@\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::Command;\n \n-/// Uses the `llvm-bolt` binary to instrument the binary/library at the given `path` with BOLT.\n+/// Uses the `llvm-bolt` binary to instrument the artifact at the given `path` with BOLT.\n /// When the instrumented artifact is executed, it will generate BOLT profiles into\n /// `/tmp/prof.fdata.<pid>.fdata`.\n-/// Returns a path to the instrumented artifact, created in a temporary directory.\n-pub fn instrument_with_bolt(path: &Path) -> PathBuf {\n-    let dir = std::env::temp_dir();\n-    let instrumented_path = dir.join(path.file_name().unwrap());\n-\n+/// Creates the instrumented artifact at `output_path`.\n+pub fn instrument_with_bolt(path: &Path, output_path: &Path) {\n     let status = Command::new(\"llvm-bolt\")\n         .arg(\"-instrument\")\n         .arg(&path)\n         // Make sure that each process will write its profiles into a separate file\n         .arg(\"--instrumentation-file-append-pid\")\n         .arg(\"-o\")\n-        .arg(&instrumented_path)\n+        .arg(output_path)\n         .status()\n         .expect(\"Could not instrument artifact using BOLT\");\n \n     if !status.success() {\n         panic!(\"Could not instrument {} with BOLT, exit code {:?}\", path.display(), status.code());\n     }\n-    instrumented_path\n }\n \n-/// Uses the `llvm-bolt` binary to optimize the binary/library at the given `path` with BOLT,\n+/// Uses the `llvm-bolt` binary to optimize the artifact at the given `path` with BOLT,\n /// using merged profiles from `profile_path`.\n ///\n /// The recorded profiles have to be merged using the `merge-fdata` tool from LLVM and the merged\n /// profile path should be then passed to this function.\n ///\n-/// Returns a path to the optimized artifact, created in a temporary directory.\n-pub fn optimize_with_bolt(path: &Path, profile_path: &Path) -> PathBuf {\n-    let dir = std::env::temp_dir();\n-    let optimized_path = dir.join(path.file_name().unwrap());\n-\n+/// Creates the optimized artifact at `output_path`.\n+pub fn optimize_with_bolt(path: &Path, profile_path: &Path, output_path: &Path) {\n     let status = Command::new(\"llvm-bolt\")\n         .arg(&path)\n         .arg(\"-data\")\n         .arg(&profile_path)\n         .arg(\"-o\")\n-        .arg(&optimized_path)\n+        .arg(output_path)\n         // Reorder basic blocks within functions\n         .arg(\"-reorder-blocks=ext-tsp\")\n         // Reorder functions within the binary\n@@ -66,5 +59,4 @@ pub fn optimize_with_bolt(path: &Path, profile_path: &Path) -> PathBuf {\n     if !status.success() {\n         panic!(\"Could not optimize {} with BOLT, exit code {:?}\", path.display(), status.code());\n     }\n-    optimized_path\n }"}, {"sha": "1c0957bc35e1959bb81df1ef36b32596a2463e6c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 118, "deletions": 2, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/bfc220a96e7b4198c2ae18c7fc6e36fd67448086/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc220a96e7b4198c2ae18c7fc6e36fd67448086/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=bfc220a96e7b4198c2ae18c7fc6e36fd67448086", "patch": "@@ -18,6 +18,7 @@ use std::process::Command;\n \n use object::read::archive::ArchiveFile;\n use object::BinaryFormat;\n+use sha2::Digest;\n \n use crate::bolt::{instrument_with_bolt, optimize_with_bolt};\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n@@ -1915,9 +1916,9 @@ fn install_llvm_file(builder: &Builder<'_>, source: &Path, destination: &Path) {\n     // We perform the instrumentation/optimization here, on the fly, just before they are being\n     // packaged into some destination directory.\n     let postprocessed = if builder.config.llvm_bolt_profile_generate {\n-        instrument_with_bolt(source)\n+        builder.ensure(BoltInstrument::new(source.to_path_buf()))\n     } else if let Some(path) = &builder.config.llvm_bolt_profile_use {\n-        optimize_with_bolt(source, &Path::new(&path))\n+        builder.ensure(BoltOptimize::new(source.to_path_buf(), path.into()))\n     } else {\n         source.to_path_buf()\n     };\n@@ -2007,6 +2008,121 @@ pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: TargetSelection\n     }\n }\n \n+/// Creates an output path to a BOLT-manipulated artifact for the given `file`.\n+/// The hash of the file is used to make sure that we don't mix BOLT artifacts amongst different\n+/// files with the same name.\n+///\n+/// We need to keep the file-name the same though, to make sure that copying the manipulated file\n+/// to a directory will not change the final file path.\n+fn create_bolt_output_path(builder: &Builder<'_>, file: &Path, hash: &str) -> PathBuf {\n+    let directory = builder.out.join(\"bolt\").join(hash);\n+    t!(fs::create_dir_all(&directory));\n+    directory.join(file.file_name().unwrap())\n+}\n+\n+/// Instrument the provided file with BOLT.\n+/// Returns a path to the instrumented artifact.\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct BoltInstrument {\n+    file: PathBuf,\n+    hash: String,\n+}\n+\n+impl BoltInstrument {\n+    fn new(file: PathBuf) -> Self {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(t!(fs::read(&file)));\n+        let hash = hex::encode(hasher.finalize().as_slice());\n+\n+        Self { file, hash }\n+    }\n+}\n+\n+impl Step for BoltInstrument {\n+    type Output = PathBuf;\n+\n+    const ONLY_HOSTS: bool = false;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.never()\n+    }\n+\n+    fn make_run(_run: RunConfig<'_>) {}\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        if builder.build.config.dry_run() {\n+            return self.file.clone();\n+        }\n+\n+        if builder.build.config.llvm_from_ci {\n+            println!(\"warning: trying to use BOLT with LLVM from CI, this will probably not work\");\n+        }\n+\n+        println!(\"Instrumenting {} with BOLT\", self.file.display());\n+\n+        let output_path = create_bolt_output_path(builder, &self.file, &self.hash);\n+        if !output_path.is_file() {\n+            instrument_with_bolt(&self.file, &output_path);\n+        }\n+        output_path\n+    }\n+}\n+\n+/// Optimize the provided file with BOLT.\n+/// Returns a path to the optimized artifact.\n+///\n+/// The hash is stored in the step to make sure that we don't optimize the same file\n+/// twice (even under  different file paths).\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct BoltOptimize {\n+    file: PathBuf,\n+    profile: PathBuf,\n+    hash: String,\n+}\n+\n+impl BoltOptimize {\n+    fn new(file: PathBuf, profile: PathBuf) -> Self {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(t!(fs::read(&file)));\n+        hasher.update(t!(fs::read(&profile)));\n+        let hash = hex::encode(hasher.finalize().as_slice());\n+\n+        Self { file, profile, hash }\n+    }\n+}\n+\n+impl Step for BoltOptimize {\n+    type Output = PathBuf;\n+\n+    const ONLY_HOSTS: bool = false;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.never()\n+    }\n+\n+    fn make_run(_run: RunConfig<'_>) {}\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        if builder.build.config.dry_run() {\n+            return self.file.clone();\n+        }\n+\n+        if builder.build.config.llvm_from_ci {\n+            println!(\"warning: trying to use BOLT with LLVM from CI, this will probably not work\");\n+        }\n+\n+        println!(\"Optimizing {} with BOLT\", self.file.display());\n+\n+        let output_path = create_bolt_output_path(builder, &self.file, &self.hash);\n+        if !output_path.is_file() {\n+            optimize_with_bolt(&self.file, &self.profile, &output_path);\n+        }\n+        output_path\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n     pub target: TargetSelection,"}]}