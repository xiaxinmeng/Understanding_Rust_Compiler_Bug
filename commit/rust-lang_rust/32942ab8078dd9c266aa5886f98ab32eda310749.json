{"sha": "32942ab8078dd9c266aa5886f98ab32eda310749", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTQyYWI4MDc4ZGQ5YzI2NmFhNTg4NmY5OGFiMzJlZGEzMTA3NDk=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-12T13:26:39Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-20T20:41:54Z"}, "message": "A non-minimal set of TraitRefBoundarys to work on removing from_poly_trait_ref", "tree": {"sha": "70ee537f2b2743b5c5563e65d910404b4e2cbd2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70ee537f2b2743b5c5563e65d910404b4e2cbd2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32942ab8078dd9c266aa5886f98ab32eda310749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32942ab8078dd9c266aa5886f98ab32eda310749", "html_url": "https://github.com/rust-lang/rust/commit/32942ab8078dd9c266aa5886f98ab32eda310749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32942ab8078dd9c266aa5886f98ab32eda310749/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba3d22ed6685f3ddbfda29edc20b93810a641db8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3d22ed6685f3ddbfda29edc20b93810a641db8", "html_url": "https://github.com/rust-lang/rust/commit/ba3d22ed6685f3ddbfda29edc20b93810a641db8"}], "stats": {"total": 177, "additions": 93, "deletions": 84}, "files": [{"sha": "4e3e4f2c2bcb55cf3f271e0b3c8ed812e330d6eb", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 93, "deletions": 84, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/32942ab8078dd9c266aa5886f98ab32eda310749/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32942ab8078dd9c266aa5886f98ab32eda310749/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=32942ab8078dd9c266aa5886f98ab32eda310749", "patch": "@@ -638,6 +638,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { binder_depth, from_poly_trait_ref, .. } => {\n+                    if concanetate && !passed_boundary && !from_poly_trait_ref {\n+                        bug!(\"{:?}\", self.scope);\n+                    }\n                     break if concanetate {\n                         if passed_boundary || !from_poly_trait_ref {\n                             binder_depth + 1\n@@ -850,7 +853,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n-                    intravisit::walk_item(this, item);\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |_, this| {\n+                        intravisit::walk_item(this, item);\n+                    });\n                 });\n                 self.missing_named_lifetime_spots.pop();\n             }\n@@ -985,9 +991,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                         // Elided lifetimes are not allowed in non-return\n                         // position impl Trait\n-                        let scope = Scope::Elision { elide: Elide::Forbid, s: self.scope };\n+                        let scope = Scope::TraitRefBoundary { s: self.scope };\n                         self.with(scope, |_, this| {\n-                            intravisit::walk_item(this, opaque_ty);\n+                            let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n+                            this.with(scope, |_, this| {\n+                                intravisit::walk_item(this, opaque_ty);\n+                            })\n                         });\n \n                         return;\n@@ -1320,93 +1329,93 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if !self.trait_definition_only {\n             check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n         }\n-        for param in generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => {}\n-                GenericParamKind::Type { ref default, .. } => {\n-                    walk_list!(self, visit_param_bound, param.bounds);\n-                    if let Some(ref ty) = default {\n-                        self.visit_ty(&ty);\n+        let scope = Scope::TraitRefBoundary { s: self.scope };\n+        self.with(scope, |_, this| {\n+            for param in generics.params {\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {}\n+                    GenericParamKind::Type { ref default, .. } => {\n+                        walk_list!(this, visit_param_bound, param.bounds);\n+                        if let Some(ref ty) = default {\n+                            this.visit_ty(&ty);\n+                        }\n+                    }\n+                    GenericParamKind::Const { ref ty, .. } => {\n+                        let was_in_const_generic = this.is_in_const_generic;\n+                        this.is_in_const_generic = true;\n+                        walk_list!(this, visit_param_bound, param.bounds);\n+                        this.visit_ty(&ty);\n+                        this.is_in_const_generic = was_in_const_generic;\n                     }\n                 }\n-                GenericParamKind::Const { ref ty, .. } => {\n-                    let was_in_const_generic = self.is_in_const_generic;\n-                    self.is_in_const_generic = true;\n-                    walk_list!(self, visit_param_bound, param.bounds);\n-                    self.visit_ty(&ty);\n-                    self.is_in_const_generic = was_in_const_generic;\n-                }\n-            }\n-        }\n-        for predicate in generics.where_clause.predicates {\n-            match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                    ref bounded_ty,\n-                    bounds,\n-                    ref bound_generic_params,\n-                    ..\n-                }) => {\n-                    let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n-                        bound_generic_params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => Some(param),\n-                                _ => None,\n-                            })\n-                            .enumerate()\n-                            .map(|(late_bound_idx, param)| {\n-                                let pair =\n-                                    Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n-                                let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                                (pair, r)\n-                            })\n-                            .unzip();\n-                    self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                    let scope = Scope::TraitRefBoundary { s: self.scope };\n-                    self.with(scope, |_, this| {\n-                        if !lifetimes.is_empty() {\n-                            let next_early_index = this.next_early_index();\n-                            let scope = Scope::Binder {\n-                                hir_id: bounded_ty.hir_id,\n-                                lifetimes,\n-                                s: this.scope,\n-                                next_early_index,\n-                                track_lifetime_uses: true,\n-                                opaque_type_parent: false,\n-                                from_poly_trait_ref: true,\n-                                binder_depth: this.depth(false),\n-                            };\n-                            this.with(scope, |old_scope, this| {\n-                                this.check_lifetime_params(old_scope, &bound_generic_params);\n+            }\n+            for predicate in generics.where_clause.predicates {\n+                match predicate {\n+                    &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                        ref bounded_ty,\n+                        bounds,\n+                        ref bound_generic_params,\n+                        ..\n+                    }) => {\n+                        let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n+                            bound_generic_params\n+                                .iter()\n+                                .filter_map(|param| match param.kind {\n+                                    GenericParamKind::Lifetime { .. } => Some(param),\n+                                    _ => None,\n+                                })\n+                                .enumerate()\n+                                .map(|(late_bound_idx, param)| {\n+                                    let pair =\n+                                        Region::late(late_bound_idx as u32, &this.tcx.hir(), param);\n+                                    let r = late_region_as_bound_region(this.tcx, &pair.1);\n+                                    (pair, r)\n+                                })\n+                                .unzip();\n+                        this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n+                            if !lifetimes.is_empty() {\n+                                let next_early_index = this.next_early_index();\n+                                let scope = Scope::Binder {\n+                                    hir_id: bounded_ty.hir_id,\n+                                    lifetimes,\n+                                    s: this.scope,\n+                                    next_early_index,\n+                                    track_lifetime_uses: true,\n+                                    opaque_type_parent: false,\n+                                    from_poly_trait_ref: true,\n+                                    binder_depth: this.depth(false),\n+                                };\n+                                this.with(scope, |old_scope, this| {\n+                                    this.check_lifetime_params(old_scope, &bound_generic_params);\n+                                    this.visit_ty(&bounded_ty);\n+                                    this.trait_ref_hack = Some(bounded_ty.hir_id);\n+                                    walk_list!(this, visit_param_bound, bounds);\n+                                    this.trait_ref_hack = None;\n+                                })\n+                            } else {\n                                 this.visit_ty(&bounded_ty);\n-                                this.trait_ref_hack = Some(bounded_ty.hir_id);\n                                 walk_list!(this, visit_param_bound, bounds);\n-                                this.trait_ref_hack = None;\n-                            })\n-                        } else {\n-                            this.visit_ty(&bounded_ty);\n-                            walk_list!(this, visit_param_bound, bounds);\n-                        }\n-                    })\n-                }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                    ref lifetime,\n-                    bounds,\n-                    ..\n-                }) => {\n-                    self.visit_lifetime(lifetime);\n-                    walk_list!(self, visit_param_bound, bounds);\n-                }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    ref lhs_ty,\n-                    ref rhs_ty,\n-                    ..\n-                }) => {\n-                    self.visit_ty(lhs_ty);\n-                    self.visit_ty(rhs_ty);\n+                            }\n+                    }\n+                    &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                        ref lifetime,\n+                        bounds,\n+                        ..\n+                    }) => {\n+                        this.visit_lifetime(lifetime);\n+                        walk_list!(this, visit_param_bound, bounds);\n+                    }\n+                    &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                        ref lhs_ty,\n+                        ref rhs_ty,\n+                        ..\n+                    }) => {\n+                        this.visit_ty(lhs_ty);\n+                        this.visit_ty(rhs_ty);\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {"}]}