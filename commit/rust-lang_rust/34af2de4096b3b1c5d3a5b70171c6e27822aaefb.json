{"sha": "34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YWYyZGU0MDk2YjNiMWM1ZDNhNWI3MDE3MWM2ZTI3ODIyYWFlZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-05T20:13:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-05T20:13:25Z"}, "message": "Auto merge of #31304 - nikomatsakis:incr-comp-read-from-hir-map, r=michaelwoerister\n\nThis change also modifies the dep graph infrastructure to keep track of the number of active tasks, so that even if we are not building the full dep-graph, we still get assertions when there is no active task and one does something that would add a read/write edge. This is particularly helpful since, if the assertions are *not* active, you wind up with the error happening in the message processing thread, which is too late to know the correct backtrace.\n\n~~Before landing, I need to do some performance measurements. Those are underway.~~\n\nSee measurements below. No real effect on time.\n\nr? @michaelwoerister", "tree": {"sha": "6ae88dacd42574033b3ebcf40de756a1c0a31b7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ae88dacd42574033b3ebcf40de756a1c0a31b7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "html_url": "https://github.com/rust-lang/rust/commit/34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "html_url": "https://github.com/rust-lang/rust/commit/6dc112dbb7dd2be0948eae816ec772ef92c69ca9"}, {"sha": "a0f96d631eafdec2605585f462376cd4d9209f05", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f96d631eafdec2605585f462376cd4d9209f05", "html_url": "https://github.com/rust-lang/rust/commit/a0f96d631eafdec2605585f462376cd4d9209f05"}], "stats": {"total": 358, "additions": 289, "deletions": 69}, "files": [{"sha": "faf97f5808e36b1b490431dfda73f633976e3e88", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -40,8 +40,21 @@ pub enum DepNode {\n     Hir(DefId),\n \n     // Represents different phases in the compiler.\n+    CrateReader,\n+    CollectLanguageItems,\n+    CheckStaticRecursion,\n+    ResolveLifetimes,\n+    RegionResolveCrate,\n+    CheckLoops,\n+    PluginRegistrar,\n+    StabilityIndex,\n     CollectItem(DefId),\n     Coherence,\n+    EffectCheck,\n+    Liveness,\n+    Resolve,\n+    EntryPoint,\n+    CheckEntryFn,\n     CoherenceCheckImpl(DefId),\n     CoherenceOverlapCheck(DefId),\n     CoherenceOverlapCheckSpecial(DefId),\n@@ -116,6 +129,13 @@ impl DepGraph {\n         }\n     }\n \n+    /// True if we are actually building a dep-graph. If this returns false,\n+    /// then the other methods on this `DepGraph` will have no net effect.\n+    #[inline]\n+    pub fn enabled(&self) -> bool {\n+        self.data.enabled()\n+    }\n+\n     pub fn query(&self) -> DepGraphQuery {\n         self.data.query()\n     }"}, {"sha": "c43b4b15b763b24fffdc322af8c0574d3428ef29", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -19,6 +19,7 @@\n //! allocated (and both have a fairly large capacity).\n \n use rustc_data_structures::veccell::VecCell;\n+use std::cell::Cell;\n use std::sync::mpsc::{self, Sender, Receiver};\n use std::thread;\n \n@@ -39,6 +40,13 @@ pub enum DepMessage {\n pub struct DepGraphThreadData {\n     enabled: bool,\n \n+    // Local counter that just tracks how many tasks are pushed onto the\n+    // stack, so that we still get an error in the case where one is\n+    // missing. If dep-graph construction is enabled, we'd get the same\n+    // error when processing tasks later on, but that's annoying because\n+    // it lacks precision about the source of the error.\n+    tasks_pushed: Cell<usize>,\n+\n     // current buffer, where we accumulate messages\n     messages: VecCell<DepMessage>,\n \n@@ -59,18 +67,26 @@ impl DepGraphThreadData {\n         let (tx1, rx1) = mpsc::channel();\n         let (tx2, rx2) = mpsc::channel();\n         let (txq, rxq) = mpsc::channel();\n+\n         if enabled {\n             thread::spawn(move || main(rx1, tx2, txq));\n         }\n+\n         DepGraphThreadData {\n             enabled: enabled,\n+            tasks_pushed: Cell::new(0),\n             messages: VecCell::with_capacity(INITIAL_CAPACITY),\n             swap_in: rx2,\n             swap_out: tx1,\n             query_in: rxq,\n         }\n     }\n \n+    #[inline]\n+    pub fn enabled(&self) -> bool {\n+        self.enabled\n+    }\n+\n     /// Sends the current batch of messages to the thread. Installs a\n     /// new vector of messages.\n     fn swap(&self) {\n@@ -100,13 +116,40 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n+        // Regardless of whether dep graph construction is enabled, we\n+        // still want to check that we always have a valid task on the\n+        // stack when a read/write/etc event occurs.\n+        match message {\n+            DepMessage::Read(_) | DepMessage::Write(_) =>\n+                if self.tasks_pushed.get() == 0 {\n+                    self.invalid_message(\"read/write but no current task\")\n+                },\n+            DepMessage::PushTask(_) | DepMessage::PushIgnore =>\n+                self.tasks_pushed.set(self.tasks_pushed.get() + 1),\n+            DepMessage::PopTask(_) | DepMessage::PopIgnore =>\n+                self.tasks_pushed.set(self.tasks_pushed.get() - 1),\n+            DepMessage::Query =>\n+                (),\n+        }\n+\n         if self.enabled {\n-            let len = self.messages.push(message);\n-            if len == INITIAL_CAPACITY {\n-                self.swap();\n-            }\n+            self.enqueue_enabled(message);\n         }\n     }\n+\n+    // Outline this fn since I expect it may want to be inlined\n+    // separately.\n+    fn enqueue_enabled(&self, message: DepMessage) {\n+        let len = self.messages.push(message);\n+        if len == INITIAL_CAPACITY {\n+            self.swap();\n+        }\n+    }\n+\n+    // Outline this too.\n+    fn invalid_message(&self, string: &str) {\n+        panic!(\"{}; see src/librustc/dep_graph/README.md for more information\", string)\n+    }\n }\n \n /// Definition of the depgraph thread."}, {"sha": "8ffc343c8f4bbb204ce9cee05fe4d32ec46ce365", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -79,6 +79,7 @@ impl<'ast> NodeCollector<'ast> {\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n         let parent_def = self.parent_def();\n+        debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions.create_def_with_parent(parent_def, node_id, data)\n     }\n \n@@ -115,10 +116,13 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n     fn visit_nested_item(&mut self, item: ItemId) {\n+        debug!(\"visit_nested_item: {:?}\", item);\n         self.visit_item(self.krate.item(item.id))\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+\n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into\n         let def_data = match i.node {"}, {"sha": "008229aca0bcf616b90fa6209f8c99997afaf04d", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 89, "deletions": 11, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -14,6 +14,8 @@ use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n \n+use dep_graph::{DepGraph, DepNode};\n+\n use middle::cstore::InlinedItem;\n use middle::cstore::InlinedItem as II;\n use middle::def_id::DefId;\n@@ -228,19 +230,22 @@ impl<'ast> MapEntry<'ast> {\n \n /// Stores a crate and any number of inlined items from other crates.\n pub struct Forest {\n-    pub krate: Crate,\n+    krate: Crate,\n+    pub dep_graph: DepGraph,\n     inlined_items: TypedArena<InlinedParent>\n }\n \n impl Forest {\n-    pub fn new(krate: Crate) -> Forest {\n+    pub fn new(krate: Crate, dep_graph: DepGraph) -> Forest {\n         Forest {\n             krate: krate,\n+            dep_graph: dep_graph,\n             inlined_items: TypedArena::new()\n         }\n     }\n \n     pub fn krate<'ast>(&'ast self) -> &'ast Crate {\n+        self.dep_graph.read(DepNode::Krate);\n         &self.krate\n     }\n }\n@@ -252,6 +257,10 @@ pub struct Map<'ast> {\n     /// The backing storage for all the AST nodes.\n     pub forest: &'ast Forest,\n \n+    /// Same as the dep_graph in forest, just available with one fewer\n+    /// deref. This is a gratuitious micro-optimization.\n+    pub dep_graph: DepGraph,\n+\n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n     /// a NodeId is in the map, but empirically the occupancy is about\n@@ -267,6 +276,60 @@ pub struct Map<'ast> {\n }\n \n impl<'ast> Map<'ast> {\n+    /// Registers a read in the dependency graph of the AST node with\n+    /// the given `id`. This needs to be called each time a public\n+    /// function returns the HIR for a node -- in other words, when it\n+    /// \"reveals\" the content of a node to the caller (who might not\n+    /// otherwise have had access to those contents, and hence needs a\n+    /// read recorded). If the function just returns a DefId or\n+    /// NodeId, no actual content was returned, so no read is needed.\n+    fn read(&self, id: NodeId) {\n+        self.dep_graph.read(self.dep_node(id));\n+    }\n+\n+    fn dep_node(&self, id0: NodeId) -> DepNode {\n+        let map = self.map.borrow();\n+        let mut id = id0;\n+        loop {\n+            match map[id as usize] {\n+                EntryItem(_, item) => {\n+                    let def_id = self.local_def_id(item.id);\n+                    // NB                          ^~~~~~~\n+                    //\n+                    // You would expect that `item.id == id`, but this\n+                    // is not always the case. In particular, for a\n+                    // ViewPath item like `use self::{mem, foo}`, we\n+                    // map the ids for `mem` and `foo` to the\n+                    // enclosing view path item. This seems mega super\n+                    // ultra wrong, but then who am I to judge?\n+                    // -nmatsakis\n+                    return DepNode::Hir(def_id);\n+                }\n+\n+                EntryForeignItem(p, _) |\n+                EntryTraitItem(p, _) |\n+                EntryImplItem(p, _) |\n+                EntryVariant(p, _) |\n+                EntryExpr(p, _) |\n+                EntryStmt(p, _) |\n+                EntryLocal(p, _) |\n+                EntryPat(p, _) |\n+                EntryBlock(p, _) |\n+                EntryStructCtor(p, _) |\n+                EntryLifetime(p, _) |\n+                EntryTyParam(p, _) =>\n+                    id = p,\n+\n+                RootCrate |\n+                RootInlinedParent(_) => // FIXME(#2369) clarify story about cross-crate dep tracking\n+                    return DepNode::Krate,\n+\n+                NotPresent =>\n+                    panic!(\"Walking parents from `{}` led to `NotPresent` at `{}`\", id0, id),\n+            }\n+        }\n+    }\n+\n     pub fn num_local_def_ids(&self) -> usize {\n         self.definitions.borrow().len()\n     }\n@@ -309,26 +372,30 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n-        &self.forest.krate\n+        self.forest.krate()\n     }\n \n     /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n     pub fn get(&self, id: NodeId) -> Node<'ast> {\n         match self.find(id) {\n-            Some(node) => node,\n+            Some(node) => node, // read recorded by `find`\n             None => panic!(\"couldn't find node id {} in the AST map\", id)\n         }\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'ast>> {\n-        self.as_local_node_id(id).map(|id| self.get(id))\n+        self.as_local_node_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'ast>> {\n-        self.find_entry(id).and_then(|x| x.to_node())\n+        let result = self.find_entry(id).and_then(|x| x.to_node());\n+        if result.is_some() {\n+            self.read(id);\n+        }\n+        result\n     }\n \n     /// Similar to get_parent, returns the parent node id or id if there is no\n@@ -459,22 +526,25 @@ impl<'ast> Map<'ast> {\n             _ => None\n         };\n         match abi {\n-            Some(abi) => abi,\n+            Some(abi) => {\n+                self.read(id); // reveals some of the content of a node\n+                abi\n+            }\n             None => panic!(\"expected foreign mod or inlined parent, found {}\",\n                           self.node_to_string(parent))\n         }\n     }\n \n     pub fn get_foreign_vis(&self, id: NodeId) -> Visibility {\n-        let vis = self.expect_foreign_item(id).vis;\n-        match self.find(self.get_parent(id)) {\n+        let vis = self.expect_foreign_item(id).vis; // read recorded by `expect_foreign_item`\n+        match self.find(self.get_parent(id)) { // read recorded by `find`\n             Some(NodeItem(i)) => vis.inherit_from(i.vis),\n             _ => vis\n         }\n     }\n \n     pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n-        match self.find(id) {\n+        match self.find(id) { // read recorded by `find`\n             Some(NodeItem(item)) => item,\n             _ => panic!(\"expected item, found {}\", self.node_to_string(id))\n         }\n@@ -521,7 +591,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'ast Expr {\n-        match self.find(id) {\n+        match self.find(id) { // read recorded by find\n             Some(NodeExpr(expr)) => expr,\n             _ => panic!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n@@ -571,6 +641,11 @@ impl<'ast> Map<'ast> {\n     fn with_path_next<T, F>(&self, id: NodeId, next: LinkedPath, f: F) -> T where\n         F: FnOnce(PathElems) -> T,\n     {\n+        // This function reveals the name of the item and hence is a\n+        // kind of read. This is inefficient, since it walks ancestors\n+        // and we are walking them anyhow, but whatever.\n+        self.read(id);\n+\n         let parent = self.get_parent(id);\n         let parent = match self.find_entry(id) {\n             Some(EntryForeignItem(..)) => {\n@@ -602,6 +677,7 @@ impl<'ast> Map<'ast> {\n     /// Given a node ID, get a list of attributes associated with the AST\n     /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'ast [ast::Attribute] {\n+        self.read(id); // reveals attributes on the node\n         let attrs = match self.find(id) {\n             Some(NodeItem(i)) => Some(&i.attrs[..]),\n             Some(NodeForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -655,6 +731,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn span(&self, id: NodeId) -> Span {\n+        self.read(id); // reveals span from node\n         self.opt_span(id)\n             .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {:?}\", id))\n     }\n@@ -833,6 +910,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n \n     Map {\n         forest: forest,\n+        dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n         definitions: RefCell::new(definitions),\n     }"}, {"sha": "c27d029374affc8ebb07a04ad0824c57537dcaba", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -12,6 +12,7 @@\n //! `unsafe`.\n use self::RootUnsafeContext::*;\n \n+use dep_graph::DepNode;\n use middle::def::Def;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n@@ -182,6 +183,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n+    let _task = tcx.dep_graph.in_task(DepNode::EffectCheck);\n+\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         unsafe_context: UnsafeContext::new(SafeContext),"}, {"sha": "67e96816abf96c49db7ed10f38de12a0c8298d02", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n \n+use dep_graph::DepNode;\n use front::map as ast_map;\n use middle::def_id::{CRATE_DEF_INDEX};\n use session::{config, Session};\n@@ -48,6 +49,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EntryContext<'a, 'tcx> {\n }\n \n pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n+    let _task = ast_map.dep_graph.in_task(DepNode::EntryPoint);\n+\n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeExecutable\n     });"}, {"sha": "f77ca10e88f0ed967350a7386ca8a82c0c58fa66", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -21,6 +21,7 @@\n \n pub use self::LangItem::*;\n \n+use dep_graph::DepNode;\n use front::map as hir_map;\n use session::Session;\n use middle::cstore::CrateStore;\n@@ -234,6 +235,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n pub fn collect_language_items(session: &Session,\n                               map: &hir_map::Map)\n                               -> LanguageItems {\n+    let _task = map.dep_graph.in_task(DepNode::CollectLanguageItems);\n     let krate: &hir::Crate = map.krate();\n     let mut collector = LanguageItemCollector::new(session, map);\n     collector.collect(krate);"}, {"sha": "5fa9d45934571105dbb43418fe0ac542e7877c4c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -109,6 +109,7 @@ use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n+use dep_graph::DepNode;\n use middle::def::*;\n use middle::pat_util;\n use middle::ty;\n@@ -192,6 +193,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n+    let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n     tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "bf21b607b778d7f57dab82347ca0742dc520db36", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -16,6 +16,7 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n+use dep_graph::DepNode;\n use front::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -1224,7 +1225,10 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     }\n }\n \n-pub fn resolve_crate(sess: &Session, krate: &hir::Crate) -> RegionMaps {\n+pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n+    let _task = map.dep_graph.in_task(DepNode::RegionResolveCrate);\n+    let krate = map.krate();\n+\n     let maps = RegionMaps {\n         code_extents: RefCell::new(vec![]),\n         code_extent_interner: RefCell::new(FnvHashMap()),"}, {"sha": "4bdf716e6370904dd4a01a9927e7650addbc848f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -18,6 +18,8 @@\n pub use self::DefRegion::*;\n use self::ScopeChain::*;\n \n+use dep_graph::DepNode;\n+use front::map::Map;\n use session::Session;\n use middle::def::{Def, DefMap};\n use middle::region;\n@@ -94,9 +96,11 @@ type Scope<'a> = &'a ScopeChain<'a>;\n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session,\n-             krate: &hir::Crate,\n+             hir_map: &Map,\n              def_map: &DefMap)\n              -> Result<NamedRegionMap, usize> {\n+    let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n+    let krate = hir_map.krate();\n     let mut named_region_map = NodeMap();\n     try!(sess.track_errors(|| {\n         krate.visit_all_items(&mut LifetimeContext {"}, {"sha": "7835f333f192e77efb8597f5a7c17d5e38358ca8", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -14,6 +14,7 @@\n pub use self::StabilityLevel::*;\n \n use dep_graph::DepNode;\n+use front::map as hir_map;\n use session::Session;\n use lint;\n use middle::cstore::{CrateStore, LOCAL_CRATE};\n@@ -30,7 +31,7 @@ use syntax::attr::{self, Stability, Deprecation, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n-use rustc_front::hir::{Crate, Item, Generics, StructField, Variant};\n+use rustc_front::hir::{Item, Generics, StructField, Variant};\n use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n@@ -278,7 +279,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n impl<'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &Crate, access_levels: &AccessLevels) {\n+    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, access_levels: &AccessLevels) {\n+        let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n+        let krate = tcx.map.krate();\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n@@ -291,7 +294,10 @@ impl<'tcx> Index<'tcx> {\n                            |v| intravisit::walk_crate(v, krate));\n     }\n \n-    pub fn new(krate: &Crate) -> Index<'tcx> {\n+    pub fn new(hir_map: &hir_map::Map) -> Index<'tcx> {\n+        let _task = hir_map.dep_graph.in_task(DepNode::StabilityIndex);\n+        let krate = hir_map.krate();\n+\n         let mut is_staged_api = false;\n         for attr in &krate.attrs {\n             if attr.name() == \"stable\" || attr.name() == \"unstable\" {"}, {"sha": "071cc0cbe3d637ecdedbb0044211972b77d2f2b9", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -509,7 +509,7 @@ impl<'tcx> ctxt<'tcx> {\n     {\n         let interner = RefCell::new(FnvHashMap());\n         let common_types = CommonTypes::new(&arenas.type_, &interner);\n-        let dep_graph = DepGraph::new(s.opts.incremental_compilation);\n+        let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         tls::enter(ctxt {\n             arenas: arenas,"}, {"sha": "68949863bfc0e6436accbfbfdcc77b3c03496b80", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -137,8 +137,13 @@ pub struct Options {\n     pub no_trans: bool,\n     pub error_format: ErrorOutputType,\n     pub treat_err_as_bug: bool,\n-    pub incremental_compilation: bool,\n+\n+    /// if true, build up the dep-graph\n+    pub build_dep_graph: bool,\n+\n+    /// if true, -Z dump-dep-graph was passed to dump out the dep-graph\n     pub dump_dep_graph: bool,\n+\n     pub no_analysis: bool,\n     pub debugging_opts: DebuggingOptions,\n     pub prints: Vec<PrintRequest>,\n@@ -246,7 +251,7 @@ pub fn basic_options() -> Options {\n         parse_only: false,\n         no_trans: false,\n         treat_err_as_bug: false,\n-        incremental_compilation: false,\n+        build_dep_graph: false,\n         dump_dep_graph: false,\n         no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n@@ -1145,7 +1150,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         parse_only: parse_only,\n         no_trans: no_trans,\n         treat_err_as_bug: treat_err_as_bug,\n-        incremental_compilation: incremental_compilation || dump_dep_graph,\n+        build_dep_graph: incremental_compilation || dump_dep_graph,\n         dump_dep_graph: dump_dep_graph,\n         no_analysis: no_analysis,\n         debugging_opts: debugging_opts,"}, {"sha": "e506639932324ab0dc334b832bcacb8fadf58cc0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::dep_graph::DepGraph;\n use rustc::front;\n use rustc::front::map as hir_map;\n use rustc_mir as mir;\n@@ -115,9 +116,11 @@ pub fn compile_input(sess: &Session,\n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n         // Lower ast -> hir.\n         let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n+        let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n         let mut hir_forest = time(sess.time_passes(),\n                                   \"lowering ast -> hir\",\n-                                  || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate)));\n+                                  || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n+                                                          dep_graph));\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n         if !sess.opts.debugging_opts.keep_mtwt_tables &&\n@@ -130,17 +133,20 @@ pub fn compile_input(sess: &Session,\n \n         write_out_deps(sess, &outputs, &id);\n \n-        controller_entry_point!(after_write_deps,\n-                                sess,\n-                                CompileState::state_after_write_deps(input,\n-                                                                     sess,\n-                                                                     outdir,\n-                                                                     &hir_map,\n-                                                                     &expanded_crate,\n-                                                                     &hir_map.krate(),\n-                                                                     &id[..],\n-                                                                     &lcx),\n-                                Ok(()));\n+        {\n+            let _ignore = hir_map.dep_graph.in_ignore();\n+            controller_entry_point!(after_write_deps,\n+                                    sess,\n+                                    CompileState::state_after_write_deps(input,\n+                                                                         sess,\n+                                                                         outdir,\n+                                                                         &hir_map,\n+                                                                         &expanded_crate,\n+                                                                         &hir_map.krate(),\n+                                                                         &id[..],\n+                                                                         &lcx),\n+                                    Ok(()));\n+        }\n \n         time(sess.time_passes(), \"attribute checking\", || {\n             front::check_attr::check_crate(sess, &expanded_crate);\n@@ -166,6 +172,9 @@ pub fn compile_input(sess: &Session,\n                                               control.make_glob_map,\n                                               |tcx, mir_map, analysis, result| {\n             {\n+                // Eventually, we will want to track plugins.\n+                let _ignore = tcx.dep_graph.in_ignore();\n+\n                 let state = CompileState::state_after_analysis(input,\n                                                                &tcx.sess,\n                                                                outdir,\n@@ -735,11 +744,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     }\n \n     let time_passes = sess.time_passes();\n-    let krate = hir_map.krate();\n \n     time(time_passes,\n          \"external crate/lib resolution\",\n-         || LocalCrateReader::new(sess, cstore, &hir_map).read_crates(krate));\n+         || LocalCrateReader::new(sess, cstore, &hir_map).read_crates());\n \n     let lang_items = try!(time(time_passes, \"language item collection\", || {\n         sess.track_errors(|| {\n@@ -769,28 +777,30 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let named_region_map = try!(time(time_passes,\n                                      \"lifetime resolution\",\n                                      || middle::resolve_lifetime::krate(sess,\n-                                                                        krate,\n+                                                                        &hir_map,\n                                                                         &def_map.borrow())));\n \n     time(time_passes,\n          \"looking for entry point\",\n          || middle::entry::find_entry_point(sess, &hir_map));\n \n     sess.plugin_registrar_fn.set(time(time_passes, \"looking for plugin registrar\", || {\n-        plugin::build::find_plugin_registrar(sess.diagnostic(), krate)\n+        plugin::build::find_plugin_registrar(sess.diagnostic(), &hir_map)\n     }));\n \n     let region_map = time(time_passes,\n                           \"region resolution\",\n-                          || middle::region::resolve_crate(sess, krate));\n+                          || middle::region::resolve_crate(sess, &hir_map));\n \n     time(time_passes,\n          \"loop checking\",\n-         || loops::check_crate(sess, krate));\n+         || loops::check_crate(sess, &hir_map));\n \n     try!(time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, krate, &def_map.borrow(), &hir_map)));\n+              || static_recursion::check_crate(sess, &def_map.borrow(), &hir_map)));\n+\n+    let index = stability::Index::new(&hir_map);\n \n     ty::ctxt::create_and_enter(sess,\n                                arenas,\n@@ -800,7 +810,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                freevars,\n                                region_map,\n                                lang_items,\n-                               stability::Index::new(krate),\n+                               index,\n                                |tcx| {\n         // passes are timed inside typeck\n         try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n@@ -818,7 +828,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         // Do not move this check past lint\n         time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx, krate, &analysis.access_levels)\n+            tcx.stability.borrow_mut().build(tcx, &analysis.access_levels)\n         });\n \n         time(time_passes,"}, {"sha": "58043f385fedf3ee716fa39bd2997179832b52cb", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -19,6 +19,7 @@ use rustc_trans::back::link;\n \n use {driver, abort_on_err};\n \n+use rustc::dep_graph::DepGraph;\n use rustc::middle::ty;\n use rustc::middle::cfg;\n use rustc::middle::cfg::graphviz::LabelledCFG;\n@@ -183,15 +184,15 @@ impl PpSourceMode {\n                     sess: sess,\n                     ast_map: Some(ast_map.clone()),\n                 };\n-                f(&annotation, payload, &ast_map.forest.krate)\n+                f(&annotation, payload, ast_map.forest.krate())\n             }\n \n             PpmIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n                     ast_map: Some(ast_map.clone()),\n                 };\n-                f(&annotation, payload, &ast_map.forest.krate)\n+                f(&annotation, payload, ast_map.forest.krate())\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n@@ -207,7 +208,7 @@ impl PpSourceMode {\n                     let _ignore = tcx.dep_graph.in_ignore();\n                     f(&annotation,\n                       payload,\n-                      &ast_map.forest.krate)\n+                      ast_map.forest.krate())\n                 }), sess)\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n@@ -706,8 +707,10 @@ pub fn pretty_print_input(sess: Session,\n     let mut hir_forest;\n     let lcx = LoweringContext::new(&sess, Some(&krate));\n     let arenas = ty::CtxtArenas::new();\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n     let ast_map = if compute_ast_map {\n-        hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n+        hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n         let map = driver::make_map(&sess, &mut hir_forest);\n         Some(map)\n     } else {"}, {"sha": "3736e045bd19a57420b8f454959024ad4816c24a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -11,6 +11,7 @@\n //! # Standalone Tests for the Inference Module\n \n use driver;\n+use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve as resolve;\n use rustc_typeck::middle::lang_items;\n@@ -118,17 +119,19 @@ fn test_env<F>(source_string: &str,\n \n     let krate = driver::assign_node_ids(&sess, krate);\n     let lcx = LoweringContext::new(&sess, Some(&krate));\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::make_map(&sess, &mut hir_forest);\n-    let krate = ast_map.krate();\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n     let resolve::CrateMap { def_map, freevars, .. } =\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n-    let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map.borrow());\n-    let region_map = region::resolve_crate(&sess, krate);\n+    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &def_map.borrow());\n+    let region_map = region::resolve_crate(&sess, &ast_map);\n+    let index = stability::Index::new(&ast_map);\n     ty::ctxt::create_and_enter(&sess,\n                                &arenas,\n                                def_map,\n@@ -137,7 +140,7 @@ fn test_env<F>(source_string: &str,\n                                freevars,\n                                region_map,\n                                lang_items,\n-                               stability::Index::new(krate),\n+                               index,\n                                |tcx| {\n                                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n                                    body(Env { infcx: &infcx });"}, {"sha": "7b094a5900a05e158dff0327361a13075c458f5c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -18,6 +18,7 @@ use decoder;\n use loader::{self, CratePaths};\n \n use rustc::back::svh::Svh;\n+use rustc::dep_graph::DepNode;\n use rustc::session::{config, Session};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name};\n@@ -723,7 +724,10 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     // Traverses an AST, reading all the information about use'd crates and\n     // extern libraries necessary for later resolving, typechecking, linking,\n     // etc.\n-    pub fn read_crates(&mut self, krate: &hir::Crate) {\n+    pub fn read_crates(&mut self) {\n+        let _task = self.ast_map.dep_graph.in_task(DepNode::CrateReader);\n+        let krate = self.ast_map.krate();\n+\n         self.process_crate(krate);\n         krate.visit_all_items(self);\n         self.creader.inject_allocator_crate();"}, {"sha": "bce18d3fe6eedfa72f3c14752c64d5d8b7beb57f", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -11,9 +11,11 @@ use self::Context::*;\n \n use rustc::session::Session;\n \n-use syntax::codemap::Span;\n+use rustc::dep_graph::DepNode;\n+use rustc::front::map::Map;\n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n+use syntax::codemap::Span;\n \n #[derive(Clone, Copy, PartialEq)]\n enum Context {\n@@ -26,7 +28,9 @@ struct CheckLoopVisitor<'a> {\n     cx: Context\n }\n \n-pub fn check_crate(sess: &Session, krate: &hir::Crate) {\n+pub fn check_crate(sess: &Session, map: &Map) {\n+    let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n+    let krate = map.krate();\n     krate.visit_all_items(&mut CheckLoopVisitor { sess: sess, cx: Normal });\n }\n "}, {"sha": "329ce21edbef40deaa2ed58ecb569641054c7e09", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -11,6 +11,7 @@\n // This compiler pass detects constants that refer to themselves\n // recursively.\n \n+use rustc::dep_graph::DepNode;\n use rustc::front::map as ast_map;\n use rustc::session::{Session, CompileResult};\n use rustc::middle::def::{Def, DefMap};\n@@ -90,17 +91,19 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         krate: &'ast hir::Crate,\n                          def_map: &DefMap,\n-                         ast_map: &ast_map::Map<'ast>) -> CompileResult {\n+                         ast_map: &ast_map::Map<'ast>)\n+                         -> CompileResult {\n+    let _task = ast_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n+\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         def_map: def_map,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n     sess.track_errors(|| {\n-        krate.visit_all_items(&mut visitor);\n+        ast_map.krate().visit_all_items(&mut visitor);\n     })\n }\n "}, {"sha": "fe83b609334497f1ff09e99382da95f897f21f7f", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -14,6 +14,8 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::errors;\n+use rustc::dep_graph::DepNode;\n+use rustc::front::map::Map;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n@@ -34,8 +36,11 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n-                             krate: &hir::Crate)\n+                             hir_map: &Map)\n                              -> Option<ast::NodeId> {\n+    let _task = hir_map.dep_graph.in_task(DepNode::PluginRegistrar);\n+    let krate = hir_map.krate();\n+\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n     krate.visit_all_items(&mut finder);\n "}, {"sha": "054aa1d5f555ba641cbbd703e5cf380c4c86ba5c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -47,6 +47,7 @@ use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n use self::FallbackChecks::*;\n \n+use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::lint;\n@@ -3596,6 +3597,15 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                ast_map: &'a hir_map::Map<'tcx>,\n                                make_glob_map: MakeGlobMap)\n                                -> CrateMap {\n+    // Currently, we ignore the name resolution data structures for\n+    // the purposes of dependency tracking. Instead we will run name\n+    // resolution and include its output in the hash of each item,\n+    // much like we do for macro expansion. In other words, the hash\n+    // reflects not just its contents but the results of name\n+    // resolution on those contents. Hopefully we'll push this back at\n+    // some point.\n+    let _task = ast_map.dep_graph.in_task(DepNode::Resolve);\n+\n     let krate = ast_map.krate();\n     let arenas = Resolver::arenas();\n     let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas, None);"}, {"sha": "035be02b0c30afecbb10b47f11995e6e887075fd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -99,9 +99,8 @@ use rustc_front::print::pprust;\n \n pub fn collect_item_types(tcx: &ty::ctxt) {\n     let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n-\n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n-    ccx.tcx.map.krate().visit_all_items(&mut visitor);\n+    ccx.tcx.visit_all_items_in_krate(DepNode::CollectItem, &mut visitor);\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -146,9 +145,6 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let tcx = self.ccx.tcx;\n-        let item_def_id = tcx.map.local_def_id(item.id);\n-        let _task = tcx.dep_graph.in_task(DepNode::CollectItem(item_def_id));\n         convert_item(self.ccx, item);\n     }\n }"}, {"sha": "083eeff9f90c125cfc995ffca869b64f7ec413cc", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -100,6 +100,7 @@ pub use rustc::middle;\n pub use rustc::session;\n pub use rustc::util;\n \n+use dep_graph::DepNode;\n use front::map as hir_map;\n use middle::def::Def;\n use middle::infer::{self, TypeOrigin};\n@@ -312,6 +313,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n+    let _task = tcx.dep_graph.in_task(DepNode::CheckEntryFn);\n     match *tcx.sess.entry_fn.borrow() {\n         Some((id, sp)) => match tcx.sess.entry_type.get() {\n             Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),"}, {"sha": "f0bd4dd83cb0ce227ec67ddcec092d2e30563f47", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -11,6 +11,7 @@ pub use self::MaybeTyped::*;\n \n use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n+use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n@@ -143,7 +144,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let krate = driver::assign_node_ids(&sess, krate);\n     // Lower ast -> hir.\n     let lcx = LoweringContext::new(&sess, Some(&krate));\n-    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n+    let mut hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), DepGraph::new(false));\n     let arenas = ty::CtxtArenas::new();\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n "}, {"sha": "490e54f4e3df96552fbdfbeae2b847a9fe9accca", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -25,6 +25,7 @@ use std::sync::{Arc, Mutex};\n \n use testing;\n use rustc_lint;\n+use rustc::dep_graph::DepGraph;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType};\n@@ -99,7 +100,9 @@ pub fn run(input: &str,\n \n     let opts = scrape_test_config(&krate);\n \n-    let mut forest = hir_map::Forest::new(krate);\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+    let mut forest = hir_map::Forest::new(krate, dep_graph.clone());\n     let map = hir_map::map_crate(&mut forest);\n \n     let ctx = core::DocContext {"}, {"sha": "13cbdfe24d6f33f3a04145b80e885f10f1580ab3", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34af2de4096b3b1c5d3a5b70171c6e27822aaefb/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "patch": "@@ -26,6 +26,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::thread::Builder;\n \n+use rustc::dep_graph::DepGraph;\n use rustc::front::map as ast_map;\n use rustc::llvm;\n use rustc::middle::cstore::{CrateStore, LinkagePreference};\n@@ -236,7 +237,8 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n         let krate = driver::assign_node_ids(&sess, krate);\n         let lcx = LoweringContext::new(&sess, Some(&krate));\n-        let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate));\n+        let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n+        let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n "}]}