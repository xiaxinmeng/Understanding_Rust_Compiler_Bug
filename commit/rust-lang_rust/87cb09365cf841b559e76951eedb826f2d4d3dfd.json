{"sha": "87cb09365cf841b559e76951eedb826f2d4d3dfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3Y2IwOTM2NWNmODQxYjU1OWU3Njk1MWVlZGI4MjZmMmQ0ZDNkZmQ=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-07-23T13:39:53Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-08-10T12:44:54Z"}, "message": "Remove merge backup", "tree": {"sha": "c56b182ad6346450d11e4451e92d638d0fe09b33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c56b182ad6346450d11e4451e92d638d0fe09b33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87cb09365cf841b559e76951eedb826f2d4d3dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87cb09365cf841b559e76951eedb826f2d4d3dfd", "html_url": "https://github.com/rust-lang/rust/commit/87cb09365cf841b559e76951eedb826f2d4d3dfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87cb09365cf841b559e76951eedb826f2d4d3dfd/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55633f34048434de18d54b4300bca186db052cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/55633f34048434de18d54b4300bca186db052cf5", "html_url": "https://github.com/rust-lang/rust/commit/55633f34048434de18d54b4300bca186db052cf5"}], "stats": {"total": 769, "additions": 0, "deletions": 769}, "files": [{"sha": "0e04c0b60769378fd683e565c9a09f6d6ef8a7d2", "filename": "crates/ra_ide/src/call_info.rs.orig", "status": "removed", "additions": 0, "deletions": 769, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/55633f34048434de18d54b4300bca186db052cf5/crates%2Fra_ide%2Fsrc%2Fcall_info.rs.orig", "raw_url": "https://github.com/rust-lang/rust/raw/55633f34048434de18d54b4300bca186db052cf5/crates%2Fra_ide%2Fsrc%2Fcall_info.rs.orig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs.orig?ref=55633f34048434de18d54b4300bca186db052cf5", "patch": "@@ -1,769 +0,0 @@\n-//! FIXME: write short doc here\n-use either::Either;\n-use hir::{Docs, HirDisplay, Semantics, Type};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    ast::{self, ArgListOwner},\n-    match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-};\n-use stdx::format_to;\n-use test_utils::mark;\n-\n-use crate::FilePosition;\n-\n-/// Contains information about a call site. Specifically the\n-/// `FunctionSignature`and current parameter.\n-#[derive(Debug)]\n-pub struct CallInfo {\n-    pub doc: Option<String>,\n-    pub signature: String,\n-    pub active_parameter: Option<usize>,\n-    parameters: Vec<TextRange>,\n-}\n-\n-impl CallInfo {\n-    pub fn parameter_labels(&self) -> impl Iterator<Item = &str> + '_ {\n-        self.parameters.iter().map(move |&it| &self.signature[it])\n-    }\n-    pub fn parameter_ranges(&self) -> &[TextRange] {\n-        &self.parameters\n-    }\n-    fn push_param(&mut self, param: &str) {\n-        if !self.signature.ends_with('(') {\n-            self.signature.push_str(\", \");\n-        }\n-        let start = TextSize::of(&self.signature);\n-        self.signature.push_str(param);\n-        let end = TextSize::of(&self.signature);\n-        self.parameters.push(TextRange::new(start, end))\n-    }\n-}\n-\n-/// Computes parameter information for the given call expression.\n-pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n-    let sema = Semantics::new(db);\n-    let file = sema.parse(position.file_id);\n-    let file = file.syntax();\n-    let token = file.token_at_offset(position.offset).next()?;\n-    let token = sema.descend_into_macros(token);\n-\n-    let (callable, active_parameter) = call_info_impl(&sema, token)?;\n-\n-    let mut res =\n-        CallInfo { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n-\n-    match callable.kind() {\n-        hir::CallableKind::Function(func) => {\n-            res.doc = func.docs(db).map(|it| it.as_str().to_string());\n-            format_to!(res.signature, \"fn {}\", func.name(db));\n-        }\n-        hir::CallableKind::TupleStruct(strukt) => {\n-            res.doc = strukt.docs(db).map(|it| it.as_str().to_string());\n-            format_to!(res.signature, \"struct {}\", strukt.name(db));\n-        }\n-        hir::CallableKind::TupleEnumVariant(variant) => {\n-            res.doc = variant.docs(db).map(|it| it.as_str().to_string());\n-            format_to!(\n-                res.signature,\n-                \"enum {}::{}\",\n-                variant.parent_enum(db).name(db),\n-                variant.name(db)\n-            );\n-        }\n-        hir::CallableKind::Closure => (),\n-    }\n-\n-    res.signature.push('(');\n-    {\n-        if let Some(self_param) = callable.receiver_param(db) {\n-            format_to!(res.signature, \"{}\", self_param)\n-        }\n-        let mut buf = String::new();\n-        for (pat, ty) in callable.params(db) {\n-            buf.clear();\n-            if let Some(pat) = pat {\n-                match pat {\n-                    Either::Left(_self) => format_to!(buf, \"self: \"),\n-                    Either::Right(pat) => format_to!(buf, \"{}: \", pat),\n-                }\n-            }\n-            format_to!(buf, \"{}\", ty.display(db));\n-            res.push_param(&buf);\n-        }\n-    }\n-    res.signature.push(')');\n-\n-    match callable.kind() {\n-        hir::CallableKind::Function(_) | hir::CallableKind::Closure => {\n-            let ret_type = callable.return_type();\n-            if !ret_type.is_unit() {\n-                format_to!(res.signature, \" -> {}\", ret_type.display(db));\n-            }\n-        }\n-        hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n-    }\n-    Some(res)\n-}\n-\n-fn call_info_impl(\n-    sema: &Semantics<RootDatabase>,\n-    token: SyntaxToken,\n-) -> Option<(hir::Callable, Option<usize>)> {\n-    // Find the calling expression and it's NameRef\n-    let calling_node = FnCallNode::with_node(&token.parent())?;\n-\n-<<<<<<< HEAD\n-    let callable = match &calling_node {\n-        FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.as_callable(sema.db)?,\n-        FnCallNode::MethodCallExpr(call) => sema.resolve_method_call_as_callable(call)?,\n-    };\n-    let active_param = if let Some(arg_list) = calling_node.arg_list() {\n-        // Number of arguments specified at the call site\n-        let num_args_at_callsite = arg_list.args().count();\n-\n-        let arg_list_range = arg_list.syntax().text_range();\n-        if !arg_list_range.contains_inclusive(token.text_range().start()) {\n-            mark::hit!(call_info_bad_offset);\n-            return None;\n-=======\n-    let (mut call_info, has_self) = match &calling_node {\n-        FnCallNode::CallExpr(call) => {\n-            //FIXME: Type::as_callable is broken\n-            let callable_def = sema.type_of_expr(&call.expr()?)?.as_callable()?;\n-            match callable_def {\n-                hir::CallableDef::FunctionId(it) => {\n-                    let fn_def = it.into();\n-                    (CallInfo::with_fn(sema.db, fn_def), fn_def.has_self_param(sema.db))\n-                }\n-                hir::CallableDef::StructId(it) => {\n-                    (CallInfo::with_struct(sema.db, it.into())?, false)\n-                }\n-                hir::CallableDef::EnumVariantId(it) => {\n-                    (CallInfo::with_enum_variant(sema.db, it.into())?, false)\n-                }\n-            }\n-        }\n-        FnCallNode::MethodCallExpr(method_call) => {\n-            let function = sema.resolve_method_call(&method_call)?;\n-            (CallInfo::with_fn(sema.db, function), function.has_self_param(sema.db))\n-        }\n-        FnCallNode::MacroCallExpr(macro_call) => {\n-            let macro_def = sema.resolve_macro_call(&macro_call)?;\n-            (CallInfo::with_macro(sema.db, macro_def)?, false)\n->>>>>>> Revert function structs back to using bool to track self param, use first param for self information in syntax highlighting instead\n-        }\n-        let param = std::cmp::min(\n-            num_args_at_callsite,\n-            arg_list\n-                .args()\n-                .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-                .count(),\n-        );\n-\n-        Some(param)\n-    } else {\n-        None\n-    };\n-    Some((callable, active_param))\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct ActiveParameter {\n-    pub(crate) ty: Type,\n-    pub(crate) name: String,\n-}\n-\n-impl ActiveParameter {\n-    pub(crate) fn at(db: &RootDatabase, position: FilePosition) -> Option<Self> {\n-        let sema = Semantics::new(db);\n-        let file = sema.parse(position.file_id);\n-        let file = file.syntax();\n-        let token = file.token_at_offset(position.offset).next()?;\n-        let token = sema.descend_into_macros(token);\n-        Self::at_token(&sema, token)\n-    }\n-\n-    pub(crate) fn at_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Self> {\n-        let (signature, active_parameter) = call_info_impl(&sema, token)?;\n-\n-        let idx = active_parameter?;\n-        let mut params = signature.params(sema.db);\n-        if !(idx < params.len()) {\n-            mark::hit!(too_many_arguments);\n-            return None;\n-        }\n-        let (pat, ty) = params.swap_remove(idx);\n-        let name = pat?.to_string();\n-        Some(ActiveParameter { ty, name })\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(crate) enum FnCallNode {\n-    CallExpr(ast::CallExpr),\n-    MethodCallExpr(ast::MethodCallExpr),\n-}\n-\n-impl FnCallNode {\n-    fn with_node(syntax: &SyntaxNode) -> Option<FnCallNode> {\n-        syntax.ancestors().find_map(|node| {\n-            match_ast! {\n-                match node {\n-                    ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n-                    ast::MethodCallExpr(it) => {\n-                        let arg_list = it.arg_list()?;\n-                        if !arg_list.syntax().text_range().contains_range(syntax.text_range()) {\n-                            return None;\n-                        }\n-                        Some(FnCallNode::MethodCallExpr(it))\n-                    },\n-                    _ => None,\n-                }\n-            }\n-        })\n-    }\n-\n-    pub(crate) fn with_node_exact(node: &SyntaxNode) -> Option<FnCallNode> {\n-        match_ast! {\n-            match node {\n-                ast::CallExpr(it) => Some(FnCallNode::CallExpr(it)),\n-                ast::MethodCallExpr(it) => Some(FnCallNode::MethodCallExpr(it)),\n-                _ => None,\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn name_ref(&self) -> Option<ast::NameRef> {\n-        match self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()? {\n-                ast::Expr::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n-                _ => return None,\n-            }),\n-\n-            FnCallNode::MethodCallExpr(call_expr) => {\n-                call_expr.syntax().children().filter_map(ast::NameRef::cast).next()\n-            }\n-        }\n-    }\n-\n-    fn arg_list(&self) -> Option<ast::ArgList> {\n-        match self {\n-            FnCallNode::CallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect::{expect, Expect};\n-    use test_utils::mark;\n-\n-    use crate::mock_analysis::analysis_and_position;\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let (analysis, position) = analysis_and_position(ra_fixture);\n-        let call_info = analysis.call_info(position).unwrap();\n-        let actual = match call_info {\n-            Some(call_info) => {\n-                let docs = match &call_info.doc {\n-                    None => \"\".to_string(),\n-                    Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n-                };\n-                let params = call_info\n-                    .parameter_labels()\n-                    .enumerate()\n-                    .map(|(i, param)| {\n-                        if Some(i) == call_info.active_parameter {\n-                            format!(\"<{}>\", param)\n-                        } else {\n-                            param.to_string()\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n-            }\n-            None => String::new(),\n-        };\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args() {\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3<|>, ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3,<|> ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (x: u32, <y: u32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_empty() {\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: u32, y: u32) -> u32\n-                (<x: u32>, y: u32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_first_generics() {\n-        check(\n-            r#\"\n-fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-    where T: Copy + Display, U: Debug\n-{ x + y }\n-\n-fn bar() { foo(<|>3, ); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(x: i32, y: {unknown}) -> u32\n-                (<x: i32>, y: {unknown})\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_no_params() {\n-        check(\n-            r#\"\n-fn foo<T>() -> T where T: Copy + Display {}\n-fn bar() { foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo() -> {unknown}\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_impl() {\n-        check(\n-            r#\"\n-struct F;\n-impl F { pub fn new() { } }\n-fn bar() {\n-    let _ : F = F::new(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                fn new()\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_self() {\n-        check(\n-            r#\"\n-struct S;\n-impl S { pub fn do_it(&self) {} }\n-\n-fn bar() {\n-    let s: S = S;\n-    s.do_it(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                fn do_it(&self)\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_with_arg() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-\n-fn main() { S.foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(&self, x: i32)\n-                (<x: i32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_with_arg_as_assoc_fn() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-\n-fn main() { S::foo(<|>); }\n-\"#,\n-            expect![[r#\"\n-                fn foo(self: &S, x: i32)\n-                (<self: &S>, x: i32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_simple() {\n-        check(\n-            r#\"\n-/// test\n-// non-doc-comment\n-fn foo(j: u32) -> u32 {\n-    j\n-}\n-\n-fn bar() {\n-    let _ = foo(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                test\n-                ------\n-                fn foo(j: u32) -> u32\n-                (<j: u32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs() {\n-        check(\n-            r#\"\n-/// Adds one to the number given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let five = 5;\n-///\n-/// assert_eq!(6, my_crate::add_one(5));\n-/// ```\n-pub fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-\n-pub fn do() {\n-    add_one(<|>\n-}\"#,\n-            expect![[r##\"\n-                Adds one to the number given.\n-\n-                # Examples\n-\n-                ```\n-                let five = 5;\n-\n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-                ------\n-                fn add_one(x: i32) -> i32\n-                (<x: i32>)\n-            \"##]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_impl() {\n-        check(\n-            r#\"\n-struct addr;\n-impl addr {\n-    /// Adds one to the number given.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let five = 5;\n-    ///\n-    /// assert_eq!(6, my_crate::add_one(5));\n-    /// ```\n-    pub fn add_one(x: i32) -> i32 {\n-        x + 1\n-    }\n-}\n-\n-pub fn do_it() {\n-    addr {};\n-    addr::add_one(<|>);\n-}\n-\"#,\n-            expect![[r##\"\n-                Adds one to the number given.\n-\n-                # Examples\n-\n-                ```\n-                let five = 5;\n-\n-                assert_eq!(6, my_crate::add_one(5));\n-                ```\n-                ------\n-                fn add_one(x: i32) -> i32\n-                (<x: i32>)\n-            \"##]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_from_actix() {\n-        check(\n-            r#\"\n-struct WriteHandler<E>;\n-\n-impl<E> WriteHandler<E> {\n-    /// Method is called when writer emits error.\n-    ///\n-    /// If this method returns `ErrorAction::Continue` writer processing\n-    /// continues otherwise stream processing stops.\n-    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n-        Running::Stop\n-    }\n-\n-    /// Method is called when writer finishes.\n-    ///\n-    /// By default this method stops actor's `Context`.\n-    fn finished(&mut self, ctx: &mut Self::Context) {\n-        ctx.stop()\n-    }\n-}\n-\n-pub fn foo(mut r: WriteHandler<()>) {\n-    r.finished(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                Method is called when writer finishes.\n-\n-                By default this method stops actor's `Context`.\n-                ------\n-                fn finished(&mut self, ctx: &mut {unknown})\n-                (<ctx: &mut {unknown}>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn call_info_bad_offset() {\n-        mark::check!(call_info_bad_offset);\n-        check(\n-            r#\"\n-fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo <|> (3, ); }\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_nested_method_in_lambda() {\n-        check(\n-            r#\"\n-struct Foo;\n-impl Foo { fn bar(&self, _: u32) { } }\n-\n-fn bar(_: u32) { }\n-\n-fn main() {\n-    let foo = Foo;\n-    std::thread::spawn(move || foo.bar(<|>));\n-}\n-\"#,\n-            expect![[r#\"\n-                fn bar(&self, _: u32)\n-                (<_: u32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn works_for_tuple_structs() {\n-        check(\n-            r#\"\n-/// A cool tuple struct\n-struct S(u32, i32);\n-fn main() {\n-    let s = S(0, <|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                A cool tuple struct\n-                ------\n-                struct S(u32, i32)\n-                (u32, <i32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn generic_struct() {\n-        check(\n-            r#\"\n-struct S<T>(T);\n-fn main() {\n-    let s = S(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                struct S({unknown})\n-                (<{unknown}>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn works_for_enum_variants() {\n-        check(\n-            r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n-fn main() {\n-    let a = E::A(<|>);\n-}\n-\"#,\n-            expect![[r#\"\n-                A Variant\n-                ------\n-                enum E::A(i32)\n-                (<i32>)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn cant_call_struct_record() {\n-        check(\n-            r#\"\n-struct S { x: u32, y: i32 }\n-fn main() {\n-    let s = S(<|>);\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn cant_call_enum_record() {\n-        check(\n-            r#\"\n-enum E {\n-    /// A Variant\n-    A(i32),\n-    /// Another\n-    B,\n-    /// And C\n-    C { a: i32, b: i32 }\n-}\n-\n-fn main() {\n-    let a = E::C(<|>);\n-}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn fn_signature_for_call_in_macro() {\n-        check(\n-            r#\"\n-macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n-fn foo() { }\n-id! {\n-    fn bar() { foo(<|>); }\n-}\n-\"#,\n-            expect![[r#\"\n-                fn foo()\n-                ()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn call_info_for_lambdas() {\n-        check(\n-            r#\"\n-struct S;\n-fn foo(s: S) -> i32 { 92 }\n-fn main() {\n-    (|s| foo(s))(<|>)\n-}\n-        \"#,\n-            expect![[r#\"\n-                (S) -> i32\n-                (<S>)\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn call_info_for_fn_ptr() {\n-        check(\n-            r#\"\n-fn main(f: fn(i32, f64) -> char) {\n-    f(0, <|>)\n-}\n-        \"#,\n-            expect![[r#\"\n-                (i32, f64) -> char\n-                (i32, <f64>)\n-            \"#]],\n-        )\n-    }\n-}"}]}