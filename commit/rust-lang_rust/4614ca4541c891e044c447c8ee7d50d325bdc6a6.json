{"sha": "4614ca4541c891e044c447c8ee7d50d325bdc6a6", "node_id": "C_kwDOAAsO6NoAKDQ2MTRjYTQ1NDFjODkxZTA0NGM0NDdjOGVlN2Q1MGQzMjViZGM2YTY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-10-01T15:12:39Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-10-25T09:30:09Z"}, "message": "Fix clippy lints in librustdoc", "tree": {"sha": "9adf8d625b3655377b339eb84ce5c8f9af03d061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9adf8d625b3655377b339eb84ce5c8f9af03d061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4614ca4541c891e044c447c8ee7d50d325bdc6a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4614ca4541c891e044c447c8ee7d50d325bdc6a6", "html_url": "https://github.com/rust-lang/rust/commit/4614ca4541c891e044c447c8ee7d50d325bdc6a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4614ca4541c891e044c447c8ee7d50d325bdc6a6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56694b04532cc0dec6e2f577135da3513e856923", "url": "https://api.github.com/repos/rust-lang/rust/commits/56694b04532cc0dec6e2f577135da3513e856923", "html_url": "https://github.com/rust-lang/rust/commit/56694b04532cc0dec6e2f577135da3513e856923"}], "stats": {"total": 415, "additions": 194, "deletions": 221}, "files": [{"sha": "ba701f42c660ba7606ada806d4e32c56910f3ddc", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let f = auto_trait::AutoTraitFinder::new(tcx);\n \n         debug!(\"get_auto_trait_impls({:?})\", ty);\n-        let auto_traits: Vec<_> = self.cx.auto_traits.iter().cloned().collect();\n+        let auto_traits: Vec<_> = self.cx.auto_traits.iter().copied().collect();\n         let mut auto_traits: Vec<Item> = auto_traits\n             .into_iter()\n             .filter_map(|trait_def_id| {\n@@ -193,8 +193,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         // to its smaller and larger regions. Note that 'larger' regions correspond\n         // to sub-regions in Rust code (e.g., in 'a: 'b, 'a is the larger region).\n         for constraint in regions.constraints.keys() {\n-            match constraint {\n-                &Constraint::VarSubVar(r1, r2) => {\n+            match *constraint {\n+                Constraint::VarSubVar(r1, r2) => {\n                     {\n                         let deps1 = vid_map.entry(RegionTarget::RegionVid(r1)).or_default();\n                         deps1.larger.insert(RegionTarget::RegionVid(r2));\n@@ -203,15 +203,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     let deps2 = vid_map.entry(RegionTarget::RegionVid(r2)).or_default();\n                     deps2.smaller.insert(RegionTarget::RegionVid(r1));\n                 }\n-                &Constraint::RegSubVar(region, vid) => {\n+                Constraint::RegSubVar(region, vid) => {\n                     let deps = vid_map.entry(RegionTarget::RegionVid(vid)).or_default();\n                     deps.smaller.insert(RegionTarget::Region(region));\n                 }\n-                &Constraint::VarSubReg(vid, region) => {\n+                Constraint::VarSubReg(vid, region) => {\n                     let deps = vid_map.entry(RegionTarget::RegionVid(vid)).or_default();\n                     deps.larger.insert(RegionTarget::Region(region));\n                 }\n-                &Constraint::RegSubReg(r1, r2) => {\n+                Constraint::RegSubReg(r1, r2) => {\n                     // The constraint is already in the form that we want, so we're done with it\n                     // Desired order is 'larger, smaller', so flip then\n                     if region_name(r1) != region_name(r2) {\n@@ -513,8 +513,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         // as we want to combine them with any 'Output' qpaths\n                         // later\n \n-                        let is_fn = match &mut b {\n-                            &mut GenericBound::TraitBound(ref mut p, _) => {\n+                        let is_fn = match b {\n+                            GenericBound::TraitBound(ref mut p, _) => {\n                                 // Insert regions into the for_generics hash map first, to ensure\n                                 // that we don't end up with duplicate bounds (e.g., for<'b, 'b>)\n                                 for_generics.extend(p.generic_params.clone());\n@@ -699,8 +699,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n }\n \n fn region_name(region: Region<'_>) -> Option<Symbol> {\n-    match region {\n-        &ty::ReEarlyBound(r) => Some(r.name),\n+    match *region {\n+        ty::ReEarlyBound(r) => Some(r.name),\n         _ => None,\n     }\n }\n@@ -717,8 +717,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match r {\n-            &ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n+        (match *r {\n+            ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n             _ => None,\n         })\n         .unwrap_or_else(|| r.super_fold_with(self))"}, {"sha": "d6bc870d3f9b03bd777186c44dc7665f765ca9f8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -216,17 +216,15 @@ impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n-        match def {\n-            Some(\n-                rl::Region::EarlyBound(_, node_id, _)\n-                | rl::Region::LateBound(_, _, node_id, _)\n-                | rl::Region::Free(_, node_id),\n-            ) => {\n-                if let Some(lt) = cx.lt_substs.get(&node_id).cloned() {\n-                    return lt;\n-                }\n+        if let Some(\n+            rl::Region::EarlyBound(_, node_id, _)\n+            | rl::Region::LateBound(_, _, node_id, _)\n+            | rl::Region::Free(_, node_id),\n+        ) = def\n+        {\n+            if let Some(lt) = cx.lt_substs.get(&node_id).cloned() {\n+                return lt;\n             }\n-            _ => {}\n         }\n         Lifetime(self.name.ident().name)\n     }\n@@ -828,7 +826,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n                 .iter()\n                 .enumerate()\n                 .map(|(i, ty)| Argument {\n-                    name: name_from_pat(&body.params[i].pat),\n+                    name: name_from_pat(body.params[i].pat),\n                     type_: ty.clean(cx),\n                 })\n                 .collect(),\n@@ -924,7 +922,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     }\n                     MethodItem(m, None)\n                 }\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n                         (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                     });\n@@ -936,7 +934,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     }\n                     TyMethodItem(t)\n                 }\n-                hir::TraitItemKind::Type(ref bounds, ref default) => {\n+                hir::TraitItemKind::Type(bounds, ref default) => {\n                     AssocTypeItem(bounds.clean(cx), default.clean(cx))\n                 }\n             };\n@@ -1260,7 +1258,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             let path = path.clean(cx);\n             resolve_type(cx, path)\n         }\n-        hir::QPath::Resolved(Some(ref qself), ref p) => {\n+        hir::QPath::Resolved(Some(ref qself), p) => {\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let Some(normalized_value) = normalize(cx, ty) {\n@@ -1281,7 +1279,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 trait_,\n             }\n         }\n-        hir::QPath::TypeRelative(ref qself, ref segment) => {\n+        hir::QPath::TypeRelative(ref qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             let res = match ty.kind() {\n                 ty::Projection(proj) => Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id),\n@@ -1337,7 +1335,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                 let length = print_const(cx, ct.eval(cx.tcx, param_env));\n                 Array(box ty.clean(cx), length)\n             }\n-            TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n+            TyKind::Tup(tys) => Tuple(tys.clean(cx)),\n             TyKind::OpaqueDef(item_id, _) => {\n                 let item = cx.tcx.hir().item(item_id);\n                 if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n@@ -1346,8 +1344,8 @@ impl Clean<Type> for hir::Ty<'_> {\n                     unreachable!()\n                 }\n             }\n-            TyKind::Path(_) => clean_qpath(&self, cx),\n-            TyKind::TraitObject(ref bounds, ref lifetime, _) => {\n+            TyKind::Path(_) => clean_qpath(self, cx),\n+            TyKind::TraitObject(bounds, ref lifetime, _) => {\n                 let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n                 let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n                 DynTrait(bounds, lifetime)\n@@ -1441,7 +1439,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n                 ResolvedPath { path, did }\n             }\n-            ty::Dynamic(ref obj, ref reg) => {\n+            ty::Dynamic(obj, ref reg) => {\n                 // HACK: pick the first `did` as the `did` of the trait object. Someone\n                 // might want to implement \"native\" support for marker-trait-only\n                 // trait objects.\n@@ -1481,9 +1479,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 DynTrait(bounds, lifetime)\n             }\n-            ty::Tuple(ref t) => {\n-                Tuple(t.iter().map(|t| t.expect_ty()).collect::<Vec<_>>().clean(cx))\n-            }\n+            ty::Tuple(t) => Tuple(t.iter().map(|t| t.expect_ty()).collect::<Vec<_>>().clean(cx)),\n \n             ty::Projection(ref data) => data.clean(cx),\n \n@@ -1821,9 +1817,9 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n                 ItemKind::Macro(ref macro_def) => MacroItem(Macro {\n-                    source: display_macro_source(cx, name, &macro_def, def_id, &item.vis),\n+                    source: display_macro_source(cx, name, macro_def, def_id, &item.vis),\n                 }),\n-                ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n                     let items = item_ids\n                         .iter()\n                         .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n@@ -2065,10 +2061,10 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n         let def_id = item.def_id.to_def_id();\n         cx.with_param_env(def_id, |cx| {\n             let kind = match item.kind {\n-                hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n+                hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n                     let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                        (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n+                        (generics.clean(cx), (&*decl, &names[..]).clean(cx))\n                     });\n                     ForeignFunctionItem(Function {\n                         decl,\n@@ -2113,7 +2109,7 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n             hir::TypeBindingKind::Equality { ref ty } => {\n                 TypeBindingKind::Equality { ty: ty.clean(cx) }\n             }\n-            hir::TypeBindingKind::Constraint { ref bounds } => {\n+            hir::TypeBindingKind::Constraint { bounds } => {\n                 TypeBindingKind::Constraint { bounds: bounds.iter().map(|b| b.clean(cx)).collect() }\n             }\n         }"}, {"sha": "0a6d5f97c4e6bc6d05c671d1f73558cfcf998330", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -204,7 +204,7 @@ impl ExternalCrate {\n             .filter_map(|a| a.value_str())\n             .map(to_remote)\n             .next()\n-            .or(extern_url.map(to_remote)) // NOTE: only matters if `extern_url_takes_precedence` is false\n+            .or_else(|| extern_url.map(to_remote)) // NOTE: only matters if `extern_url_takes_precedence` is false\n             .unwrap_or(Unknown) // Well, at least we tried.\n     }\n \n@@ -238,7 +238,7 @@ impl ExternalCrate {\n                         hir::ItemKind::Mod(_) => {\n                             as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n                         }\n-                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n+                        hir::ItemKind::Use(path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_keyword(path.res.expect_non_local())\n@@ -304,7 +304,7 @@ impl ExternalCrate {\n                         hir::ItemKind::Mod(_) => {\n                             as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n                         }\n-                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n+                        hir::ItemKind::Use(path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_primitive(path.res.expect_non_local()).map(|(_, prim)| {\n@@ -381,7 +381,7 @@ impl Item {\n         {\n             *span\n         } else {\n-            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(|| Span::dummy())\n+            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(Span::dummy)\n         }\n     }\n \n@@ -562,7 +562,7 @@ impl Item {\n     }\n \n     crate fn stability_class(&self, tcx: TyCtxt<'_>) -> Option<String> {\n-        self.stability(tcx).as_ref().and_then(|ref s| {\n+        self.stability(tcx).as_ref().and_then(|s| {\n             let mut classes = Vec::with_capacity(2);\n \n             if s.level.is_unstable() {\n@@ -820,9 +820,9 @@ impl AttributesExt for [ast::Attribute] {\n                         // #[doc(cfg(...))]\n                         if let Some(cfg_mi) = item\n                             .meta_item()\n-                            .and_then(|item| rustc_expand::config::parse_cfg(&item, sess))\n+                            .and_then(|item| rustc_expand::config::parse_cfg(item, sess))\n                         {\n-                            match Cfg::parse(&cfg_mi) {\n+                            match Cfg::parse(cfg_mi) {\n                                 Ok(new_cfg) => cfg &= new_cfg,\n                                 Err(e) => sess.span_err(e.span, e.msg),\n                             }\n@@ -934,7 +934,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n         T: IntoIterator<Item = &'a DocFragment>,\n     {\n         iter.into_iter().fold(String::new(), |mut acc, frag| {\n-            add_doc_fragment(&mut acc, &frag);\n+            add_doc_fragment(&mut acc, frag);\n             acc\n         })\n     }\n@@ -1061,12 +1061,12 @@ impl Attributes {\n \n         let ori = iter.next()?;\n         let mut out = String::new();\n-        add_doc_fragment(&mut out, &ori);\n-        while let Some(new_frag) = iter.next() {\n+        add_doc_fragment(&mut out, ori);\n+        for new_frag in iter {\n             if new_frag.kind != ori.kind || new_frag.parent_module != ori.parent_module {\n                 break;\n             }\n-            add_doc_fragment(&mut out, &new_frag);\n+            add_doc_fragment(&mut out, new_frag);\n         }\n         if out.is_empty() { None } else { Some(out) }\n     }\n@@ -1079,7 +1079,7 @@ impl Attributes {\n \n         for new_frag in self.doc_strings.iter() {\n             let out = ret.entry(new_frag.parent_module).or_default();\n-            add_doc_fragment(out, &new_frag);\n+            add_doc_fragment(out, new_frag);\n         }\n         ret\n     }"}, {"sha": "0573a1ada3a84080182a0198a8517524aca85b0d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -171,8 +171,8 @@ crate fn strip_path_generics(path: Path) -> Path {\n \n crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     let segments = match *p {\n-        hir::QPath::Resolved(_, ref path) => &path.segments,\n-        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n+        hir::QPath::Resolved(_, path) => &path.segments,\n+        hir::QPath::TypeRelative(_, segment) => return segment.ident.to_string(),\n         hir::QPath::LangItem(lang_item, ..) => return lang_item.name().to_string(),\n     };\n \n@@ -217,23 +217,23 @@ crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n         PatKind::Wild | PatKind::Struct(..) => return kw::Underscore,\n         PatKind::Binding(_, _, ident, _) => return ident.name,\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n-        PatKind::Or(ref pats) => {\n+        PatKind::Or(pats) => {\n             pats.iter().map(|p| name_from_pat(p).to_string()).collect::<Vec<String>>().join(\" | \")\n         }\n-        PatKind::Tuple(ref elts, _) => format!(\n+        PatKind::Tuple(elts, _) => format!(\n             \"({})\",\n             elts.iter().map(|p| name_from_pat(p).to_string()).collect::<Vec<String>>().join(\", \")\n         ),\n-        PatKind::Box(ref p) => return name_from_pat(&**p),\n-        PatKind::Ref(ref p, _) => return name_from_pat(&**p),\n+        PatKind::Box(p) => return name_from_pat(&*p),\n+        PatKind::Ref(p, _) => return name_from_pat(&*p),\n         PatKind::Lit(..) => {\n             warn!(\n                 \"tried to get argument name from PatKind::Lit, which is silly in function arguments\"\n             );\n             return Symbol::intern(\"()\");\n         }\n         PatKind::Range(..) => return kw::Underscore,\n-        PatKind::Slice(ref begin, ref mid, ref end) => {\n+        PatKind::Slice(begin, ref mid, end) => {\n             let begin = begin.iter().map(|p| name_from_pat(p).to_string());\n             let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n             let end = end.iter().map(|p| name_from_pat(p).to_string());\n@@ -507,7 +507,7 @@ crate fn has_doc_flag(attrs: ty::Attributes<'_>, flag: Symbol) -> bool {\n /// so that the channel is consistent.\n ///\n /// Set by `bootstrap::Builder::doc_rust_lang_org_channel` in order to keep tests passing on beta/stable.\n-crate const DOC_RUST_LANG_ORG_CHANNEL: &'static str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n+crate const DOC_RUST_LANG_ORG_CHANNEL: &str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n \n /// Render a sequence of macro arms in a format suitable for displaying to the user\n /// as part of an item declaration."}, {"sha": "493aa56fce6efe061a2b12ba673628625ba88731", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -321,13 +321,13 @@ impl Options {\n     /// been printed, returns `Err` with the exit code.\n     crate fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n         // Check for unstable options.\n-        nightly_options::check_nightly_options(&matches, &opts());\n+        nightly_options::check_nightly_options(matches, &opts());\n \n         if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n             crate::usage(\"rustdoc\");\n             return Err(0);\n         } else if matches.opt_present(\"version\") {\n-            rustc_driver::version(\"rustdoc\", &matches);\n+            rustc_driver::version(\"rustdoc\", matches);\n             return Err(0);\n         }\n \n@@ -363,18 +363,18 @@ impl Options {\n             return Err(0);\n         }\n \n-        let color = config::parse_color(&matches);\n+        let color = config::parse_color(matches);\n         let config::JsonConfig { json_rendered, json_unused_externs, .. } =\n-            config::parse_json(&matches);\n-        let error_format = config::parse_error_format(&matches, color, json_rendered);\n+            config::parse_json(matches);\n+        let error_format = config::parse_error_format(matches, color, json_rendered);\n \n         let codegen_options = CodegenOptions::build(matches, error_format);\n         let debugging_opts = DebuggingOptions::build(matches, error_format);\n \n         let diag = new_handler(error_format, None, &debugging_opts);\n \n         // check for deprecated options\n-        check_deprecated_options(&matches, &diag);\n+        check_deprecated_options(matches, &diag);\n \n         let mut emit = Vec::new();\n         for list in matches.opt_strs(\"emit\") {\n@@ -440,8 +440,8 @@ impl Options {\n             .iter()\n             .map(|s| SearchPath::from_cli_opt(s, error_format))\n             .collect();\n-        let externs = parse_externs(&matches, &debugging_opts, error_format);\n-        let extern_html_root_urls = match parse_extern_html_roots(&matches) {\n+        let externs = parse_externs(matches, &debugging_opts, error_format);\n+        let extern_html_root_urls = match parse_extern_html_roots(matches) {\n             Ok(ex) => ex,\n             Err(err) => {\n                 diag.struct_err(err).emit();\n@@ -560,7 +560,7 @@ impl Options {\n             }\n         }\n \n-        let edition = config::parse_crate_edition(&matches);\n+        let edition = config::parse_crate_edition(matches);\n \n         let mut id_map = html::markdown::IdMap::new();\n         let external_html = match ExternalHtml::load(\n@@ -569,7 +569,7 @@ impl Options {\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n             &matches.opt_strs(\"markdown-after-content\"),\n-            nightly_options::match_is_nightly_build(&matches),\n+            nightly_options::match_is_nightly_build(matches),\n             &diag,\n             &mut id_map,\n             edition,"}, {"sha": "b7251e8f57151cb3024ee2a40b77c2bb7dee9678", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -85,7 +85,7 @@ crate struct DocContext<'tcx> {\n \n impl<'tcx> DocContext<'tcx> {\n     crate fn sess(&self) -> &'tcx Session {\n-        &self.tcx.sess\n+        self.tcx.sess\n     }\n \n     crate fn with_param_env<T, F: FnOnce(&mut Self) -> T>(&mut self, def_id: DefId, f: F) -> T {\n@@ -464,7 +464,7 @@ crate fn run_global_ctxt(\n                 _ => continue,\n             };\n             for name in value.as_str().split_whitespace() {\n-                let span = attr.name_value_literal_span().unwrap_or(attr.span());\n+                let span = attr.name_value_literal_span().unwrap_or_else(|| attr.span());\n                 manual_passes.extend(parse_pass(name, Some(span)));\n             }\n         }"}, {"sha": "9b32ad979e385572cdd3878cdae54ff712b1b811", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -73,7 +73,7 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n         search_paths: options.libs.clone(),\n         crate_types,\n         lint_opts: if !options.display_doctest_warnings { lint_opts } else { vec![] },\n-        lint_cap: Some(options.lint_cap.unwrap_or_else(|| lint::Forbid)),\n+        lint_cap: Some(options.lint_cap.unwrap_or(lint::Forbid)),\n         cg: options.codegen_options.clone(),\n         externs: options.externs.clone(),\n         unstable_features: options.render_options.unstable_features,\n@@ -176,7 +176,7 @@ crate fn run(options: Options) -> Result<(), ErrorReported> {\n                 .iter()\n                 .map(|uexts| uexts.unused_extern_names.iter().collect::<FxHashSet<&String>>())\n                 .fold(extern_names, |uextsa, uextsb| {\n-                    uextsa.intersection(&uextsb).map(|v| *v).collect::<FxHashSet<&String>>()\n+                    uextsa.intersection(&uextsb).copied().collect::<FxHashSet<&String>>()\n                 })\n                 .iter()\n                 .map(|v| (*v).clone())\n@@ -423,7 +423,7 @@ fn run_test(\n \n     // Add a \\n to the end to properly terminate the last line,\n     // but only if there was output to be printed\n-    if out_lines.len() > 0 {\n+    if !out_lines.is_empty() {\n         out_lines.push(\"\");\n     }\n \n@@ -1124,7 +1124,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         let mut attrs = Attributes::from_ast(ast_attrs, None);\n \n         if let Some(ref cfg) = ast_attrs.cfg(self.tcx, &FxHashSet::default()) {\n-            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n+            if !cfg.matches(&self.sess.parse_sess, Some(self.sess.features_untracked())) {\n                 return;\n             }\n         }"}, {"sha": "c733b8fe0817bd6d1cfd7503c84c83b8922b3037", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n                         let desc = item.doc_value().map_or_else(String::new, |x| {\n-                            short_markdown_summary(&x.as_str(), &item.link_names(&self.cache))\n+                            short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n                         self.cache.search_index.push(IndexItem {\n                             ty: item.type_(),\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             let impl_item = Impl { impl_item: item };\n             if impl_item.trait_did().map_or(true, |d| self.cache.traits.contains_key(&d)) {\n                 for did in dids {\n-                    self.cache.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    self.cache.impls.entry(did).or_insert_with(Vec::new).push(impl_item.clone());\n                 }\n             } else {\n                 let trait_did = impl_item.trait_did().expect(\"no trait did\");"}, {"sha": "c51bda60b73853b1142e2766aa156159fe1c85b6", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -597,7 +597,7 @@ crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path<'a, 'cx: 'a>(\n+fn resolved_path<'cx>(\n     w: &mut fmt::Formatter<'_>,\n     did: DefId,\n     path: &clean::Path,\n@@ -696,7 +696,7 @@ fn primitive_link(\n \n /// Helper to render type parameters\n fn tybounds<'a, 'tcx: 'a>(\n-    bounds: &'a Vec<clean::PolyTrait>,\n+    bounds: &'a [clean::PolyTrait],\n     lt: &'a Option<clean::Lifetime>,\n     cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -886,7 +886,7 @@ fn fmt_type<'cx>(\n                     if bounds.len() > 1 || trait_lt.is_some() =>\n                 {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cx)?;\n+                    fmt_type(ty, f, use_absolute, cx)?;\n                     write!(f, \")\")\n                 }\n                 clean::Generic(..) => {\n@@ -896,11 +896,11 @@ fn fmt_type<'cx>(\n                         &format!(\"{}{}{}\", amp, lt, m),\n                         cx,\n                     )?;\n-                    fmt_type(&ty, f, use_absolute, cx)\n+                    fmt_type(ty, f, use_absolute, cx)\n                 }\n                 _ => {\n                     write!(f, \"{}{}{}\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cx)\n+                    fmt_type(ty, f, use_absolute, cx)\n                 }\n             }\n         }"}, {"sha": "66059ef65de6d6b038e892dec4598d692523e016", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -62,7 +62,7 @@ crate fn render_with_highlighting(\n     }\n \n     write_header(out, class, extra_content);\n-    write_code(out, &src, edition, context_info, decoration_info);\n+    write_code(out, src, edition, context_info, decoration_info);\n     write_footer(out, playground_button);\n }\n \n@@ -718,7 +718,7 @@ fn string<T: Display>(\n                             .map(|(url, _, _)| url)\n                     }\n                     LinkFromSrc::Primitive(prim) => format::href_with_root_path(\n-                        PrimitiveType::primitive_locations(context.tcx())[&prim],\n+                        PrimitiveType::primitive_locations(context.tcx())[prim],\n                         context,\n                         Some(context_info.root_path),\n                     )"}, {"sha": "71d7cc1a09dce5b9656d6e3c9556b5db38fd6776", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -68,10 +68,8 @@ crate fn render<T: Print, S: Print>(\n     let krate_with_trailing_slash = ensure_trailing_slash(&layout.krate).to_string();\n     let style_files = style_files\n         .iter()\n-        .filter_map(|t| {\n-            if let Some(stem) = t.path.file_stem() { Some((stem, t.disabled)) } else { None }\n-        })\n-        .filter_map(|t| if let Some(path) = t.0.to_str() { Some((path, t.1)) } else { None })\n+        .filter_map(|t| t.path.file_stem().map(|stem| (stem, t.disabled)))\n+        .filter_map(|t| t.0.to_str().map(|path| (path, t.1)))\n         .map(|t| {\n             format!(\n                 r#\"<link rel=\"stylesheet\" type=\"text/css\" href=\"{}.css\" {} {}>\"#,"}, {"sha": "47772651bf9b9e92defd25a9ea1d0b8e32504228", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -178,7 +178,7 @@ fn map_line(s: &str) -> Line<'_> {\n         Line::Shown(Cow::Owned(s.replacen(\"##\", \"#\", 1)))\n     } else if let Some(stripped) = trimmed.strip_prefix(\"# \") {\n         // # text\n-        Line::Hidden(&stripped)\n+        Line::Hidden(stripped)\n     } else if trimmed == \"#\" {\n         // We cannot handle '#text' because it could be #[attr].\n         Line::Hidden(\"\")\n@@ -258,7 +258,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n         let parse_result = match kind {\n             CodeBlockKind::Fenced(ref lang) => {\n                 let parse_result =\n-                    LangString::parse_without_check(&lang, self.check_error_codes, false);\n+                    LangString::parse_without_check(lang, self.check_error_codes, false);\n                 if !parse_result.rust {\n                     return Some(Event::Html(\n                         format!(\n@@ -669,7 +669,7 @@ impl<'a, I: Iterator<Item = SpannedEvent<'a>>> Iterator for Footnotes<'a, I> {\n         loop {\n             match self.inner.next() {\n                 Some((Event::FootnoteReference(ref reference), range)) => {\n-                    let entry = self.get_entry(&reference);\n+                    let entry = self.get_entry(reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n@@ -904,7 +904,7 @@ impl LangString {\n         string\n             .split(|c| c == ',' || c == ' ' || c == '\\t')\n             .map(str::trim)\n-            .map(|token| if token.chars().next() == Some('.') { &token[1..] } else { token })\n+            .map(|token| token.strip_prefix('.').unwrap_or(token))\n             .filter(|token| !token.is_empty())\n     }\n \n@@ -974,7 +974,10 @@ impl LangString {\n                 }\n                 x if extra.is_some() => {\n                     let s = x.to_lowercase();\n-                    match if s == \"compile-fail\" || s == \"compile_fail\" || s == \"compilefail\" {\n+                    if let Some((flag, help)) = if s == \"compile-fail\"\n+                        || s == \"compile_fail\"\n+                        || s == \"compilefail\"\n+                    {\n                         Some((\n                             \"compile_fail\",\n                             \"the code block will either not be tested if not marked as a rust one \\\n@@ -1007,15 +1010,12 @@ impl LangString {\n                     } else {\n                         None\n                     } {\n-                        Some((flag, help)) => {\n-                            if let Some(ref extra) = extra {\n-                                extra.error_invalid_codeblock_attr(\n-                                    &format!(\"unknown attribute `{}`. Did you mean `{}`?\", x, flag),\n-                                    help,\n-                                );\n-                            }\n+                        if let Some(extra) = extra {\n+                            extra.error_invalid_codeblock_attr(\n+                                &format!(\"unknown attribute `{}`. Did you mean `{}`?\", x, flag),\n+                                help,\n+                            );\n                         }\n-                        None => {}\n                     }\n                     seen_other_tags = true;\n                 }\n@@ -1051,13 +1051,10 @@ impl Markdown<'_> {\n             return String::new();\n         }\n         let mut replacer = |broken_link: BrokenLink<'_>| {\n-            if let Some(link) =\n-                links.iter().find(|link| &*link.original_text == broken_link.reference)\n-            {\n-                Some((link.href.as_str().into(), link.new_text.as_str().into()))\n-            } else {\n-                None\n-            }\n+            links\n+                .iter()\n+                .find(|link| &*link.original_text == broken_link.reference)\n+                .map(|link| (link.href.as_str().into(), link.new_text.as_str().into()))\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, main_body_opts(), Some(&mut replacer));\n@@ -1135,13 +1132,10 @@ impl MarkdownSummaryLine<'_> {\n         }\n \n         let mut replacer = |broken_link: BrokenLink<'_>| {\n-            if let Some(link) =\n-                links.iter().find(|link| &*link.original_text == broken_link.reference)\n-            {\n-                Some((link.href.as_str().into(), link.new_text.as_str().into()))\n-            } else {\n-                None\n-            }\n+            links\n+                .iter()\n+                .find(|link| &*link.original_text == broken_link.reference)\n+                .map(|link| (link.href.as_str().into(), link.new_text.as_str().into()))\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, summary_opts(), Some(&mut replacer));\n@@ -1172,13 +1166,10 @@ fn markdown_summary_with_limit(\n     }\n \n     let mut replacer = |broken_link: BrokenLink<'_>| {\n-        if let Some(link) =\n-            link_names.iter().find(|link| &*link.original_text == broken_link.reference)\n-        {\n-            Some((link.href.as_str().into(), link.new_text.as_str().into()))\n-        } else {\n-            None\n-        }\n+        link_names\n+            .iter()\n+            .find(|link| &*link.original_text == broken_link.reference)\n+            .map(|link| (link.href.as_str().into(), link.new_text.as_str().into()))\n     };\n \n     let p = Parser::new_with_broken_link_callback(md, summary_opts(), Some(&mut replacer));\n@@ -1413,7 +1404,7 @@ crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_>) -> Vec<RustCodeB\n                 CodeBlockKind::Indented => {\n                     // The ending of the offset goes too far sometime so we reduce it by one in\n                     // these cases.\n-                    if offset.end > offset.start && md.get(offset.end..=offset.end) == Some(&\"\\n\") {\n+                    if offset.end > offset.start && md.get(offset.end..=offset.end) == Some(\"\\n\") {\n                         (\n                             LangString::default(),\n                             offset.start,"}, {"sha": "7142a84d6b0179507c17b9757ea39f55b23f0f25", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -1,3 +1,4 @@\n+use std::collections::hash_map::Entry;\n use std::collections::BTreeMap;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -36,15 +37,15 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n         if let Some(&(ref fqp, _)) = cache.paths.get(&did) {\n             let desc = item\n                 .doc_value()\n-                .map_or_else(String::new, |s| short_markdown_summary(&s, &item.link_names(&cache)));\n+                .map_or_else(String::new, |s| short_markdown_summary(&s, &item.link_names(cache)));\n             cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n                 name: item.name.unwrap().to_string(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(&item, tcx),\n+                search_type: get_index_search_type(item, tcx),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -53,7 +54,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     let crate_doc = krate\n         .module\n         .doc_value()\n-        .map_or_else(String::new, |s| short_markdown_summary(&s, &krate.module.link_names(&cache)));\n+        .map_or_else(String::new, |s| short_markdown_summary(&s, &krate.module.link_names(cache)));\n \n     let Cache { ref mut search_index, ref paths, .. } = *cache;\n \n@@ -72,7 +73,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     // Set up alias indexes.\n     for (i, item) in search_index.iter().enumerate() {\n         for alias in &item.aliases[..] {\n-            aliases.entry(alias.to_lowercase()).or_insert(Vec::new()).push(i);\n+            aliases.entry(alias.to_lowercase()).or_insert_with(Vec::new).push(i);\n         }\n     }\n \n@@ -82,12 +83,11 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     let mut lastpathid = 0usize;\n \n     for item in search_index {\n-        item.parent_idx = item.parent.and_then(|defid| {\n-            if defid_to_pathid.contains_key(&defid) {\n-                defid_to_pathid.get(&defid).copied()\n-            } else {\n+        item.parent_idx = item.parent.and_then(|defid| match defid_to_pathid.entry(defid) {\n+            Entry::Occupied(entry) => Some(*entry.get()),\n+            Entry::Vacant(entry) => {\n                 let pathid = lastpathid;\n-                defid_to_pathid.insert(defid, pathid);\n+                entry.insert(pathid);\n                 lastpathid += 1;\n \n                 if let Some(&(ref fqp, short)) = paths.get(&defid) {\n@@ -203,12 +203,12 @@ crate fn get_index_search_type<'tcx>(\n \n     let inputs = all_types\n         .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(ty), *kind)))\n         .filter(|a| a.ty.name.is_some())\n         .collect();\n     let output = ret_types\n         .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(ty), *kind)))\n         .filter(|a| a.ty.name.is_some())\n         .collect::<Vec<_>>();\n     let output = if output.is_empty() { None } else { Some(output) };\n@@ -296,7 +296,7 @@ crate fn get_real_types<'tcx>(\n     }\n     let mut nb_added = 0;\n \n-    if let &Type::Generic(arg_s) = arg {\n+    if let Type::Generic(arg_s) = *arg {\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n             WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n             _ => false,\n@@ -374,7 +374,7 @@ crate fn get_all_types<'tcx>(\n     let ret_types = match decl.output {\n         FnRetTy::Return(ref return_type) => {\n             let mut ret = FxHashSet::default();\n-            get_real_types(generics, &return_type, tcx, 0, &mut ret);\n+            get_real_types(generics, return_type, tcx, 0, &mut ret);\n             if ret.is_empty() {\n                 if let Some(kind) = return_type.def_id().map(|did| tcx.def_kind(did).into()) {\n                     ret.insert((return_type.clone(), kind));"}, {"sha": "0e29cc85f9e758122438765ae59046471297b21c", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -160,7 +160,7 @@ impl<'tcx> Context<'tcx> {\n     }\n \n     pub(super) fn sess(&self) -> &'tcx Session {\n-        &self.shared.tcx.sess\n+        self.shared.tcx.sess\n     }\n \n     pub(super) fn derive_id(&self, id: String) -> String {\n@@ -188,7 +188,7 @@ impl<'tcx> Context<'tcx> {\n         };\n         title.push_str(\" - Rust\");\n         let tyname = it.type_();\n-        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(&doc));\n+        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(doc));\n         let desc = if let Some(desc) = desc {\n             desc\n         } else if it.is_crate() {"}, {"sha": "a5e62baca3816ef53287e0aeafbe87635257f58e", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -126,8 +126,8 @@ impl Serialize for IndexItemFunctionType {\n         // If we couldn't figure out a type, just write `null`.\n         let mut iter = self.inputs.iter();\n         if match self.output {\n-            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.ty.name.is_none()),\n-            None => iter.any(|ref i| i.ty.name.is_none()),\n+            Some(ref output) => iter.chain(output.iter()).any(|i| i.ty.name.is_none()),\n+            None => iter.any(|i| i.ty.name.is_none()),\n         } {\n             serializer.serialize_none()\n         } else {\n@@ -906,7 +906,7 @@ fn render_assoc_item(\n             AssocItemLink::GotoSource(did, provided_methods) => {\n                 // We're creating a link from an impl-item to the corresponding\n                 // trait-item and need to map the anchored type accordingly.\n-                let ty = if provided_methods.contains(&name) {\n+                let ty = if provided_methods.contains(name) {\n                     ItemType::Method\n                 } else {\n                     ItemType::TyMethod\n@@ -965,7 +965,7 @@ fn render_assoc_item(\n             name = name,\n             generics = g.print(cx),\n             decl = d.full_print(header_len, indent, header.asyncness, cx),\n-            notable_traits = notable_traits_decl(&d, cx),\n+            notable_traits = notable_traits_decl(d, cx),\n             where_clause = print_where_clause(g, cx, indent, end_newline),\n         )\n     }\n@@ -1008,7 +1008,7 @@ fn attributes(it: &clean::Item) -> Vec<String> {\n         .iter()\n         .filter_map(|attr| {\n             if ALLOWED_ATTRIBUTES.contains(&attr.name_or_empty()) {\n-                Some(pprust::attribute_to_string(&attr).replace(\"\\n\", \"\").replace(\"  \", \" \"))\n+                Some(pprust::attribute_to_string(attr).replace(\"\\n\", \"\").replace(\"  \", \" \"))\n             } else {\n                 None\n             }\n@@ -1041,7 +1041,7 @@ enum AssocItemLink<'a> {\n impl<'a> AssocItemLink<'a> {\n     fn anchor(&self, id: &'a str) -> Self {\n         match *self {\n-            AssocItemLink::Anchor(_) => AssocItemLink::Anchor(Some(&id)),\n+            AssocItemLink::Anchor(_) => AssocItemLink::Anchor(Some(id)),\n             ref other => *other,\n         }\n     }\n@@ -1120,7 +1120,7 @@ fn render_assoc_items(\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n             concrete.into_iter().partition(|t| t.inner_impl().blanket_impl.is_some());\n \n-        let mut impls = Buffer::empty_from(&w);\n+        let mut impls = Buffer::empty_from(w);\n         render_impls(cx, &mut impls, &concrete, containing_item);\n         let impls = impls.into_inner();\n         if !impls.is_empty() {\n@@ -1333,7 +1333,7 @@ fn render_impl(\n             && match render_mode {\n                 RenderMode::Normal => true,\n                 RenderMode::ForDeref { mut_: deref_mut_ } => {\n-                    should_render_item(&item, deref_mut_, cx.tcx())\n+                    should_render_item(item, deref_mut_, cx.tcx())\n                 }\n             };\n \n@@ -1566,7 +1566,7 @@ fn render_impl(\n                 &mut impl_items,\n                 cx,\n                 &t.trait_,\n-                &i.inner_impl(),\n+                i.inner_impl(),\n                 &i.impl_item,\n                 parent,\n                 render_mode,\n@@ -2060,7 +2060,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &Vec<Impl>) {\n+fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[Impl]) {\n     let c = cx.cache();\n \n     debug!(\"found Deref: {:?}\", impl_);\n@@ -2159,16 +2159,14 @@ fn get_id_for_impl_on_foreign_type(\n fn extract_for_impl_name(item: &clean::Item, cx: &Context<'_>) -> Option<(String, String)> {\n     match *item.kind {\n         clean::ItemKind::ImplItem(ref i) => {\n-            if let Some(ref trait_) = i.trait_ {\n+            i.trait_.as_ref().map(|trait_| {\n                 // Alternative format produces no URLs,\n                 // so this parameter does nothing.\n-                Some((\n+                (\n                     format!(\"{:#}\", i.for_.print(cx)),\n                     get_id_for_impl_on_foreign_type(&i.for_, trait_, cx),\n-                ))\n-            } else {\n-                None\n-            }\n+                )\n+            })\n         }\n         _ => None,\n     }\n@@ -2343,9 +2341,10 @@ fn sidebar_enum(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, e: &clean:\n     let mut variants = e\n         .variants\n         .iter()\n-        .filter_map(|v| match v.name {\n-            Some(ref name) => Some(format!(\"<a href=\\\"#variant.{name}\\\">{name}</a>\", name = name)),\n-            _ => None,\n+        .filter_map(|v| {\n+            v.name\n+                .as_ref()\n+                .map(|name| format!(\"<a href=\\\"#variant.{name}\\\">{name}</a>\", name = name))\n         })\n         .collect::<Vec<_>>();\n     if !variants.is_empty() {"}, {"sha": "12ea7b4f74bce0e71d823b1847ba3baaf65ddaff", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -34,10 +34,10 @@ use crate::html::markdown::{HeadingOffset, MarkdownSummaryLine};\n \n use serde::Serialize;\n \n-const ITEM_TABLE_OPEN: &'static str = \"<div class=\\\"item-table\\\">\";\n-const ITEM_TABLE_CLOSE: &'static str = \"</div>\";\n-const ITEM_TABLE_ROW_OPEN: &'static str = \"<div class=\\\"item-row\\\">\";\n-const ITEM_TABLE_ROW_CLOSE: &'static str = \"</div>\";\n+const ITEM_TABLE_OPEN: &str = \"<div class=\\\"item-table\\\">\";\n+const ITEM_TABLE_CLOSE: &str = \"</div>\";\n+const ITEM_TABLE_ROW_OPEN: &str = \"<div class=\\\"item-row\\\">\";\n+const ITEM_TABLE_ROW_CLOSE: &str = \"</div>\";\n \n // A component in a `use` path, like `string` in std::string::ToString\n #[derive(Serialize)]\n@@ -761,7 +761,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                 render_impl(\n                     w,\n                     cx,\n-                    &implementor,\n+                    implementor,\n                     it,\n                     assoc_link,\n                     RenderMode::Normal,\n@@ -1497,7 +1497,7 @@ fn render_union(\n     );\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx));\n-        write!(w, \"{}\", print_where_clause(&g, cx, 0, true));\n+        write!(w, \"{}\", print_where_clause(g, cx, 0, true));\n     }\n \n     write!(w, \" {{\\n{}\", tab);"}, {"sha": "1a8562d05eab7cb3b13cac8b7d964aedcd220151", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -105,7 +105,7 @@ impl Visitor<'tcx> for SpanMapVisitor<'tcx> {\n         }\n         for bound in p.bounds {\n             if let Some(trait_ref) = bound.trait_ref() {\n-                self.handle_path(&trait_ref.path, None);\n+                self.handle_path(trait_ref.path, None);\n             }\n         }\n     }\n@@ -121,42 +121,33 @@ impl Visitor<'tcx> for SpanMapVisitor<'tcx> {\n         if !span.overlaps(m.inner) {\n             // Now that we confirmed it's a file import, we want to get the span for the module\n             // name only and not all the \"mod foo;\".\n-            if let Some(node) = self.tcx.hir().find(id) {\n-                match node {\n-                    Node::Item(item) => {\n-                        self.matches\n-                            .insert(item.ident.span, LinkFromSrc::Local(clean::Span::new(m.inner)));\n-                    }\n-                    _ => {}\n-                }\n+            if let Some(Node::Item(item)) = self.tcx.hir().find(id) {\n+                self.matches.insert(item.ident.span, LinkFromSrc::Local(clean::Span::new(m.inner)));\n             }\n         }\n         intravisit::walk_mod(self, m, id);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx rustc_hir::Expr<'tcx>) {\n-        match expr.kind {\n-            ExprKind::MethodCall(segment, method_span, _, _) => {\n-                if let Some(hir_id) = segment.hir_id {\n-                    let hir = self.tcx.hir();\n-                    let body_id = hir.enclosing_body_owner(hir_id);\n-                    let typeck_results = self.tcx.sess.with_disabled_diagnostic(|| {\n-                        self.tcx.typeck_body(\n-                            hir.maybe_body_owned_by(body_id).expect(\"a body which isn't a body\"),\n-                        )\n-                    });\n-                    if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n-                        self.matches.insert(\n-                            method_span,\n-                            match hir.span_if_local(def_id) {\n-                                Some(span) => LinkFromSrc::Local(clean::Span::new(span)),\n-                                None => LinkFromSrc::External(def_id),\n-                            },\n-                        );\n-                    }\n+        if let ExprKind::MethodCall(segment, method_span, _, _) = expr.kind {\n+            if let Some(hir_id) = segment.hir_id {\n+                let hir = self.tcx.hir();\n+                let body_id = hir.enclosing_body_owner(hir_id);\n+                let typeck_results = self.tcx.sess.with_disabled_diagnostic(|| {\n+                    self.tcx.typeck_body(\n+                        hir.maybe_body_owned_by(body_id).expect(\"a body which isn't a body\"),\n+                    )\n+                });\n+                if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n+                    self.matches.insert(\n+                        method_span,\n+                        match hir.span_if_local(def_id) {\n+                            Some(span) => LinkFromSrc::Local(clean::Span::new(span)),\n+                            None => LinkFromSrc::External(def_id),\n+                        },\n+                    );\n                 }\n             }\n-            _ => {}\n         }\n         intravisit::walk_expr(self, expr);\n     }"}, {"sha": "3bb879b507afccd5fcdc0a778425beba3af415bb", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -128,7 +128,7 @@ impl Context<'_> {\n     ) -> Result<(), Error> {\n         if minify {\n             let contents = contents.as_ref();\n-            let contents = if resource.extension() == Some(&OsStr::new(\"css\")) {\n+            let contents = if resource.extension() == Some(OsStr::new(\"css\")) {\n                 minifier::css::minify(contents).map_err(|e| {\n                     Error::new(format!(\"failed to minify CSS file: {}\", e), resource.path(self))\n                 })?"}, {"sha": "667bbc24ba5edb5deac643d0514f3543e6ac99d0", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -67,7 +67,7 @@ impl LocalSourcesCollector<'_, '_> {\n         }\n \n         let mut href = String::new();\n-        clean_path(&self.src_root, &p, false, |component| {\n+        clean_path(self.src_root, &p, false, |component| {\n             href.push_str(&component.to_string_lossy());\n             href.push('/');\n         });\n@@ -168,7 +168,7 @@ impl SourceCollector<'_, 'tcx> {\n         };\n \n         // Remove the utf-8 BOM if any\n-        let contents = if contents.starts_with('\\u{feff}') { &contents[3..] } else { &contents };\n+        let contents = contents.strip_prefix('\\u{feff}').unwrap_or(&contents);\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n@@ -209,7 +209,7 @@ impl SourceCollector<'_, 'tcx> {\n                     contents,\n                     self.cx.shared.edition(),\n                     file_span,\n-                    &self.cx,\n+                    self.cx,\n                     &root_path,\n                     None,\n                     SourceContext::Standalone,"}, {"sha": "6fa0425c4956be0eaa8a7f3865e2f6bfec539255", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -412,7 +412,7 @@ impl FromWithTcx<clean::Type> for Type {\n                         .map(|t| {\n                             clean::GenericBound::TraitBound(t, rustc_hir::TraitBoundModifier::None)\n                         })\n-                        .chain(lt.into_iter().map(|lt| clean::GenericBound::Outlives(lt)))\n+                        .chain(lt.into_iter().map(clean::GenericBound::Outlives))\n                         .map(|bound| bound.into_tcx(tcx))\n                         .collect(),\n                 }"}, {"sha": "93dffc27659c23f8089dca0775e98bc11ee65c1f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -775,7 +775,7 @@ fn main_options(options: config::Options) -> MainResult {\n             // We need to hold on to the complete resolver, so we cause everything to be\n             // cloned for the analysis passes to use. Suboptimal, but necessary in the\n             // current architecture.\n-            let resolver = core::create_resolver(queries, &sess);\n+            let resolver = core::create_resolver(queries, sess);\n \n             if sess.has_errors() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");"}, {"sha": "4501914fe0c07e178ab681bbc00ce852ff4f888e", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> BareUrlsLinter<'a, 'tcx> {\n     ) {\n         trace!(\"looking for raw urls in {}\", text);\n         // For now, we only check \"full\" URLs (meaning, starting with \"http://\" or \"https://\").\n-        for match_ in URL_REGEX.find_iter(&text) {\n+        for match_ in URL_REGEX.find_iter(text) {\n             let url = match_.as_str();\n             let url_range = match_.range();\n             f("}, {"sha": "b18208d26e2c478d3088c04288e8e90ff502828a", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n         let source = dox[code_block.code].to_owned();\n         let sess = ParseSess::with_span_handler(handler, sm);\n \n-        let edition = code_block.lang_string.edition.unwrap_or(self.cx.tcx.sess.edition());\n+        let edition = code_block.lang_string.edition.unwrap_or_else(|| self.cx.tcx.sess.edition());\n         let expn_data = ExpnData::default(\n             ExpnKind::AstPass(AstPass::TestHarness),\n             DUMMY_SP,\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n         // The span and whether it is precise or not.\n         let (sp, precise_span) = match super::source_span_for_markdown_range(\n             self.cx.tcx,\n-            &dox,\n+            dox,\n             &code_block.range,\n             &item.attrs,\n         ) {\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n \n             // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n             for message in buffer.messages.iter() {\n-                diag.note(&message);\n+                diag.note(message);\n             }\n \n             diag.emit();\n@@ -150,8 +150,8 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n                 item.def_id.expect_def_id(),\n                 sp,\n             );\n-            for code_block in markdown::rust_code_blocks(&dox, &extra) {\n-                self.check_rust_syntax(&item, &dox, code_block);\n+            for code_block in markdown::rust_code_blocks(dox, &extra) {\n+                self.check_rust_syntax(&item, dox, code_block);\n             }\n         }\n "}, {"sha": "69a526d461810e99c421c27047a8e21b677a6d70", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -115,10 +115,10 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n \n     let mut tests = Tests { found_tests: 0 };\n \n-    find_testable_code(&dox, &mut tests, ErrorCodes::No, false, None);\n+    find_testable_code(dox, &mut tests, ErrorCodes::No, false, None);\n \n     if tests.found_tests == 0 && cx.tcx.sess.is_nightly_build() {\n-        if should_have_doc_example(cx, &item) {\n+        if should_have_doc_example(cx, item) {\n             debug!(\"reporting error for {:?} (hir_id={:?})\", item, hir_id);\n             let sp = item.attr_span(cx.tcx);\n             cx.tcx.struct_span_lint_hir("}, {"sha": "9b2fe0c77e6cfe71985687d3ab5ec3e4eeb27bb6", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n-            module_id: module_id,\n+            module_id,\n             partial_res: None,\n             unresolved: path_str.into(),\n         };\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n         let result = self.cx.enter_resolver(|resolver| {\n             resolver\n-                .resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+                .resolve_str_path_error(DUMMY_SP, path_str, ns, module_id)\n                 .and_then(|(_, res)| res.try_into())\n         });\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ty::Uint(uty) => Res::Primitive(uty.into()),\n             ty::Float(fty) => Res::Primitive(fty.into()),\n             ty::Str => Res::Primitive(Str),\n-            ty::Tuple(ref tys) if tys.is_empty() => Res::Primitive(Unit),\n+            ty::Tuple(tys) if tys.is_empty() => Res::Primitive(Unit),\n             ty::Tuple(_) => Res::Primitive(Tuple),\n             ty::Array(..) => Res::Primitive(Array),\n             ty::Slice(_) => Res::Primitive(Slice),\n@@ -978,13 +978,13 @@ fn preprocess_link<'a>(\n     }\n \n     // Parse and strip the disambiguator from the link, if present.\n-    let (disambiguator, path_str, link_text) = match Disambiguator::from_str(&link) {\n+    let (disambiguator, path_str, link_text) = match Disambiguator::from_str(link) {\n         Ok(Some((d, path, link_text))) => (Some(d), path.trim(), link_text.trim()),\n         Ok(None) => (None, link.trim(), link.trim()),\n         Err((err_msg, relative_range)) => {\n             // Only report error if we would not have ignored this link. See issue #83859.\n             if !should_ignore_link_with_disambiguators(link) {\n-                let no_backticks_range = range_between_backticks(&ori_link);\n+                let no_backticks_range = range_between_backticks(ori_link);\n                 let disambiguator_range = (no_backticks_range.start + relative_range.start)\n                     ..(no_backticks_range.start + relative_range.end);\n                 return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n@@ -1000,7 +1000,7 @@ fn preprocess_link<'a>(\n \n     // Strip generics from the path.\n     let path_str = if path_str.contains(['<', '>'].as_slice()) {\n-        match strip_generics_from_path(&path_str) {\n+        match strip_generics_from_path(path_str) {\n             Ok(path) => path,\n             Err(err_kind) => {\n                 debug!(\"link has malformed generics: {}\", path_str);\n@@ -1228,7 +1228,7 @@ impl LinkCollector<'_, '_> {\n                 if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n                     && !self.cx.tcx.privacy_access_levels(()).is_exported(dst_id)\n                 {\n-                    privacy_error(self.cx, &diag_info, &path_str);\n+                    privacy_error(self.cx, &diag_info, path_str);\n                 }\n             }\n \n@@ -1766,8 +1766,8 @@ fn report_diagnostic(\n \n         let span =\n             super::source_span_for_markdown_range(tcx, dox, link_range, &item.attrs).map(|sp| {\n-                if dox.bytes().nth(link_range.start) == Some(b'`')\n-                    && dox.bytes().nth(link_range.end - 1) == Some(b'`')\n+                if dox.as_bytes().get(link_range.start) == Some(&b'`')\n+                    && dox.as_bytes().get(link_range.end - 1) == Some(&b'`')\n                 {\n                     sp.with_lo(sp.lo() + BytePos(1)).with_hi(sp.hi() - BytePos(1))\n                 } else {\n@@ -1868,8 +1868,7 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Some(res) =\n-                                collector.check_full_res(ns, &start, module_id, &None)\n+                            if let Some(res) = collector.check_full_res(ns, start, module_id, &None)\n                             {\n                                 debug!(\"found partial_res={:?}\", res);\n                                 *partial_res = Some(res);"}, {"sha": "565bcb8bd1340c4763a24c33a800894f3c9f5f9a", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -34,7 +34,7 @@ impl IntraLinkCrateLoader {\n         let attrs = crate::clean::Attributes::from_ast(attrs, None);\n         for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n             debug!(?doc);\n-            for link in markdown_links(&doc.as_str()) {\n+            for link in markdown_links(doc.as_str()) {\n                 debug!(?link.link);\n                 let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n                     x.path_str\n@@ -46,7 +46,7 @@ impl IntraLinkCrateLoader {\n                         span,\n                         &path_str,\n                         TypeNS,\n-                        parent_module.unwrap_or(self.current_mod.to_def_id()),\n+                        parent_module.unwrap_or_else(|| self.current_mod.to_def_id()),\n                     );\n                 });\n             }"}, {"sha": "5d1f934240f037f0de0e2c18e8252a543f350957", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4614ca4541c891e044c447c8ee7d50d325bdc6a6/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4614ca4541c891e044c447c8ee7d50d325bdc6a6", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span;\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -277,7 +276,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             _ if self.inlining && !is_pub => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::Use(_, hir::UseKind::ListStem) => {}\n-            hir::ItemKind::Use(ref path, kind) => {\n+            hir::ItemKind::Use(path, kind) => {\n                 let is_glob = kind == hir::UseKind::Glob;\n \n                 // Struct and variant constructors and proc macro stubs always show up alongside"}]}