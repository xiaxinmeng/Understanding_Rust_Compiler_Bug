{"sha": "42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYTBiZDIwOTFiOWNhOGZlNTA1OWZkNWY0YTI2Mjc5YTM4OGYyNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-03T22:02:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-03T22:02:26Z"}, "message": "Auto merge of #67668 - matthewjasper:or-patterns, r=pnkfelix\n\nImplement MIR lowering for or-patterns\n\nThis is the last thing needed to get meaningful run-pass tests for or-patterns. There probably need to be more tests before stabilizing this, but the most important cases should have been covered.\n\nNote: we can generate exponentially large MIR CFGs when using or-patterns containing bindings, type ascriptions, or that are for a match arm with a guard. `src/test/mir-opt/exponential-or.rs` shows the best case for what we currently do.\n\ncc #54883\ncloses #60350\ncloses #67514\n\ncc @Centril\nr? @pnkfelix", "tree": {"sha": "3c70d4208ec24e0d6f5d92aebdfda8ca77371e7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c70d4208ec24e0d6f5d92aebdfda8ca77371e7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "html_url": "https://github.com/rust-lang/rust/commit/42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8417d68de5e063426ab6bb7f383df6117d1beeed", "url": "https://api.github.com/repos/rust-lang/rust/commits/8417d68de5e063426ab6bb7f383df6117d1beeed", "html_url": "https://github.com/rust-lang/rust/commit/8417d68de5e063426ab6bb7f383df6117d1beeed"}, {"sha": "8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "html_url": "https://github.com/rust-lang/rust/commit/8dbbe4d14467d95d89ca3dff9054522f32cc12e8"}], "stats": {"total": 2631, "additions": 1737, "deletions": 894}, "files": [{"sha": "0252d88e73889a51c75408f6acdbc7eef7193993", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -556,7 +556,6 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::impl_trait_in_bindings,\n     sym::generic_associated_types,\n     sym::const_generics,\n-    sym::or_patterns,\n     sym::let_chains,\n     sym::raw_dylib,\n     sym::const_trait_impl,"}, {"sha": "df5526ad762812cb2322277cd229a86dbb8367c4", "filename": "src/librustc_mir_build/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             &pattern,\n                             UserTypeProjections::none(),\n                             &mut |this, _, _, _, node, span, _, _| {\n-                                this.storage_live_binding(block, node, span, OutsideGuard);\n+                                this.storage_live_binding(block, node, span, OutsideGuard, true);\n                                 this.schedule_drop_for_binding(node, span, OutsideGuard);\n                             },\n                         )"}, {"sha": "f900ae45b94d6c8382acfeb98bef66f3dbb57a5e", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 588, "deletions": 262, "changes": 850, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -26,8 +26,9 @@ mod simplify;\n mod test;\n mod util;\n \n-use itertools::Itertools;\n+use std::borrow::Borrow;\n use std::convert::TryFrom;\n+use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Generates MIR for a `match` expression.\n@@ -66,12 +67,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// We generate MIR in the following steps:\n     ///\n     /// 1. Evaluate the scrutinee and add the fake read of it ([Builder::lower_scrutinee]).\n-    /// 2. Create the prebinding and otherwise blocks ([Builder::create_match_candidates]).\n-    /// 3. Create the decision tree ([Builder::lower_match_tree]).\n-    /// 4. Determine the fake borrows that are needed from the places that were\n+    /// 2. Create the decision tree ([Builder::lower_match_tree]).\n+    /// 3. Determine the fake borrows that are needed from the places that were\n     ///    matched against and create the required temporaries for them\n     ///    ([Builder::calculate_fake_borrows]).\n-    /// 5. Create everything else: the guards and the arms ([Builder::lower_match_arms]).\n+    /// 4. Create everything else: the guards and the arms ([Builder::lower_match_arms]).\n     ///\n     /// ## False edges\n     ///\n@@ -93,17 +93,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        let mut arm_candidates = self.create_match_candidates(&scrutinee_place, &arms);\n+        let mut arm_candidates = self.create_match_candidates(scrutinee_place, &arms);\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n-        let candidates =\n-            arm_candidates.iter_mut().flat_map(|(_, candidates)| candidates).collect::<Vec<_>>();\n+        let mut candidates =\n+            arm_candidates.iter_mut().map(|(_, candidate)| candidate).collect::<Vec<_>>();\n \n         let fake_borrow_temps =\n-            self.lower_match_tree(block, scrutinee_span, match_has_guard, candidates);\n+            self.lower_match_tree(block, scrutinee_span, match_has_guard, &mut candidates);\n \n         self.lower_match_arms(\n-            &destination,\n+            destination,\n             scrutinee_place,\n             scrutinee_span,\n             arm_candidates,\n@@ -137,50 +137,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // check safety.\n         let cause_matched_place = FakeReadCause::ForMatchedPlace;\n         let source_info = self.source_info(scrutinee_span);\n-        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place.clone());\n+        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n \n         block.and(scrutinee_place)\n     }\n \n     /// Create the initial `Candidate`s for a `match` expression.\n     fn create_match_candidates<'pat>(\n         &mut self,\n-        scrutinee: &Place<'tcx>,\n+        scrutinee: Place<'tcx>,\n         arms: &'pat [Arm<'tcx>],\n-    ) -> Vec<(&'pat Arm<'tcx>, Vec<Candidate<'pat, 'tcx>>)> {\n-        let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n-        let pre_binding_blocks: Vec<_> =\n-            (0..candidate_count).map(|_| self.cfg.start_new_block()).collect();\n-\n-        let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n-        let mut next_candidate_pre_binding_blocks = pre_binding_blocks.iter().skip(1);\n-\n+    ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidates: Vec<_> = arm\n-                    .top_pats_hack()\n-                    .iter()\n-                    .zip(candidate_pre_binding_blocks.by_ref())\n-                    .map(|(pattern, pre_binding_block)| Candidate {\n-                        span: pattern.span,\n-                        match_pairs: smallvec![MatchPair::new(*scrutinee, pattern)],\n-                        bindings: vec![],\n-                        ascriptions: vec![],\n-                        otherwise_block: if arm_has_guard {\n-                            Some(self.cfg.start_new_block())\n-                        } else {\n-                            None\n-                        },\n-                        pre_binding_block: *pre_binding_block,\n-                        next_candidate_pre_binding_block: next_candidate_pre_binding_blocks\n-                            .next()\n-                            .copied(),\n-                    })\n-                    .collect();\n-                (arm, arm_candidates)\n+                let arm_candidate = Candidate::new(scrutinee, &arm.pattern, arm_has_guard);\n+                (arm, arm_candidate)\n             })\n             .collect()\n     }\n@@ -196,22 +170,38 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         scrutinee_span: Span,\n         match_has_guard: bool,\n-        mut candidates: Vec<&mut Candidate<'pat, 'tcx>>,\n+        candidates: &mut [&mut Candidate<'pat, 'tcx>],\n     ) -> Vec<(Place<'tcx>, Local)> {\n         // The set of places that we are creating fake borrows of. If there are\n         // no match guards then we don't need any fake borrows, so don't track\n         // them.\n         let mut fake_borrows = if match_has_guard { Some(FxHashSet::default()) } else { None };\n \n+        let mut otherwise = None;\n+\n         // This will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n-        self.match_candidates(\n-            scrutinee_span,\n-            &mut Some(block),\n-            None,\n-            &mut candidates,\n-            &mut fake_borrows,\n-        );\n+        self.match_candidates(scrutinee_span, block, &mut otherwise, candidates, &mut fake_borrows);\n+\n+        if let Some(otherwise_block) = otherwise {\n+            // See the doc comment on `match_candidates` for why we may have an\n+            // otherwise block. Match checking will ensure this is actually\n+            // unreachable.\n+            let source_info = self.source_info(scrutinee_span);\n+            self.cfg.terminate(otherwise_block, source_info, TerminatorKind::Unreachable);\n+        }\n+\n+        // Link each leaf candidate to the `pre_binding_block` of the next one.\n+        let mut previous_candidate: Option<&mut Candidate<'_, '_>> = None;\n+\n+        for candidate in candidates {\n+            candidate.visit_leaves(|leaf_candidate| {\n+                if let Some(ref mut prev) = previous_candidate {\n+                    prev.next_candidate_pre_binding_block = leaf_candidate.pre_binding_block;\n+                }\n+                previous_candidate = Some(leaf_candidate);\n+            });\n+        }\n \n         if let Some(ref borrows) = fake_borrows {\n             self.calculate_fake_borrows(borrows, scrutinee_span)\n@@ -231,16 +221,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: &Place<'tcx>,\n         scrutinee_place: Place<'tcx>,\n         scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'tcx>, Vec<Candidate<'_, 'tcx>>)>,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n         fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n     ) -> BlockAnd<()> {\n         let match_scope = self.scopes.topmost();\n \n         let arm_end_blocks: Vec<_> = arm_candidates\n             .into_iter()\n-            .map(|(arm, candidates)| {\n-                debug!(\"lowering arm {:?}\\ncanidates = {:?}\", arm, candidates);\n+            .map(|(arm, candidate)| {\n+                debug!(\"lowering arm {:?}\\ncanidate = {:?}\", arm, candidate);\n \n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n@@ -249,18 +239,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n-                        &arm.top_pats_hack()[0],\n+                        &arm.pattern,\n                         ArmHasGuard(arm.guard.is_some()),\n                         Some((Some(&scrutinee_place), scrutinee_span)),\n                     );\n \n                     let arm_block = this.bind_pattern(\n                         outer_source_info,\n-                        candidates,\n+                        candidate,\n                         arm.guard.as_ref().map(|g| (g, match_scope)),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n-                        arm.scope,\n+                        Some(arm.scope),\n                     );\n \n                     if let Some(source_scope) = scope {\n@@ -284,41 +274,82 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         end_block.unit()\n     }\n \n-    /// Binds the variables and ascribes types for a given `match` arm.\n+    /// Binds the variables and ascribes types for a given `match` arm or\n+    /// `let` binding.\n     ///\n     /// Also check if the guard matches, if it's provided.\n+    /// `arm_scope` should be `Some` if and only if this is called for a\n+    /// `match` arm.\n     fn bind_pattern(\n         &mut self,\n         outer_source_info: SourceInfo,\n-        mut candidates: Vec<Candidate<'_, 'tcx>>,\n+        candidate: Candidate<'_, 'tcx>,\n         guard: Option<(&Guard<'tcx>, region::Scope)>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n-        arm_scope: region::Scope,\n+        arm_scope: Option<region::Scope>,\n     ) -> BasicBlock {\n-        if candidates.len() == 1 {\n+        if candidate.subcandidates.is_empty() {\n             // Avoid generating another `BasicBlock` when we only have one\n             // candidate.\n             self.bind_and_guard_matched_candidate(\n-                candidates.pop().unwrap(),\n+                candidate,\n+                &[],\n                 guard,\n                 fake_borrow_temps,\n                 scrutinee_span,\n+                true,\n             )\n         } else {\n-            let arm_block = self.cfg.start_new_block();\n-            for candidate in candidates {\n-                // Avoid scheduling drops multiple times.\n-                self.clear_top_scope(arm_scope);\n-                let binding_end = self.bind_and_guard_matched_candidate(\n-                    candidate,\n-                    guard,\n-                    fake_borrow_temps,\n-                    scrutinee_span,\n-                );\n-                self.cfg.goto(binding_end, outer_source_info, arm_block);\n-            }\n-            arm_block\n+            // It's helpful to avoid scheduling drops multiple times to save\n+            // drop elaboration from having to clean up the extra drops.\n+            //\n+            // If we are in a `let` then we only schedule drops for the first\n+            // candidate.\n+            //\n+            // If we're in a `match` arm then we could have a case like so:\n+            //\n+            // Ok(x) | Err(x) if return => { /* ... */ }\n+            //\n+            // In this case we don't want a drop of `x` scheduled when we\n+            // return: it isn't bound by move until right before enter the arm.\n+            // To handle this we instead unschedule it's drop after each time\n+            // we lower the guard.\n+            let target_block = self.cfg.start_new_block();\n+            let mut schedule_drops = true;\n+            // We keep a stack of all of the bindings and type asciptions\n+            // from the the parent candidates that we visit, that also need to\n+            // be bound for each candidate.\n+            traverse_candidate(\n+                candidate,\n+                &mut Vec::new(),\n+                &mut |leaf_candidate, parent_bindings| {\n+                    if let Some(arm_scope) = arm_scope {\n+                        self.clear_top_scope(arm_scope);\n+                    }\n+                    let binding_end = self.bind_and_guard_matched_candidate(\n+                        leaf_candidate,\n+                        parent_bindings,\n+                        guard,\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                        schedule_drops,\n+                    );\n+                    if arm_scope.is_none() {\n+                        schedule_drops = false;\n+                    }\n+                    self.cfg.goto(binding_end, outer_source_info, target_block);\n+                },\n+                |inner_candidate, parent_bindings| {\n+                    parent_bindings.push((inner_candidate.bindings, inner_candidate.ascriptions));\n+                    inner_candidate.subcandidates.into_iter()\n+                },\n+                |parent_bindings| {\n+                    parent_bindings.pop();\n+                },\n+            );\n+\n+            target_block\n         }\n     }\n \n@@ -332,7 +363,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Optimize the case of `let x = ...` to write directly into `x`\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n-                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n                 unpack!(block = self.into(&place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n@@ -367,13 +398,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     hair::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n                 let place =\n-                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n                 unpack!(block = self.into(&place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n                 let cause_let = FakeReadCause::ForLet;\n-                self.cfg.push_fake_read(block, pattern_source_info, cause_let, place.clone());\n+                self.cfg.push_fake_read(block, pattern_source_info, cause_let, place);\n \n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = pat_ascription_ty.user_ty(\n@@ -412,7 +443,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             _ => {\n                 let place = unpack!(block = self.as_place(block, initializer));\n-                self.place_into_pattern(block, irrefutable_pat, &place, true)\n+                self.place_into_pattern(block, irrefutable_pat, place, true)\n             }\n         }\n     }\n@@ -421,67 +452,50 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: &Place<'tcx>,\n+        initializer: Place<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n-        // create a dummy candidate\n-        let mut candidate = Candidate {\n-            span: irrefutable_pat.span,\n-            match_pairs: smallvec![MatchPair::new(*initializer, &irrefutable_pat)],\n-            bindings: vec![],\n-            ascriptions: vec![],\n-\n-            // since we don't call `match_candidates`, next fields are unused\n-            otherwise_block: None,\n-            pre_binding_block: block,\n-            next_candidate_pre_binding_block: None,\n-        };\n+        let mut candidate = Candidate::new(initializer, &irrefutable_pat, false);\n \n-        // Simplify the candidate. Since the pattern is irrefutable, this should\n-        // always convert all match-pairs into bindings.\n-        self.simplify_candidate(&mut candidate);\n-\n-        if !candidate.match_pairs.is_empty() {\n-            // ICE if no other errors have been emitted. This used to be a hard error that wouldn't\n-            // be reached because `hair::pattern::check_match::check_match` wouldn't have let the\n-            // compiler continue. In our tests this is only ever hit by\n-            // `ui/consts/const-match-check.rs` with `--cfg eval1`, and that file already generates\n-            // a different error before hand.\n-            self.hir.tcx().sess.delay_span_bug(\n-                candidate.match_pairs[0].pattern.span,\n-                &format!(\n-                    \"match pairs {:?} remaining after simplifying irrefutable pattern\",\n-                    candidate.match_pairs,\n-                ),\n-            );\n-        }\n+        let fake_borrow_temps =\n+            self.lower_match_tree(block, irrefutable_pat.span, false, &mut [&mut candidate]);\n \n-        // for matches and function arguments, the place that is being matched\n+        // For matches and function arguments, the place that is being matched\n         // can be set when creating the variables. But the place for\n         // let PATTERN = ... might not even exist until we do the assignment.\n-        // so we set it here instead\n+        // so we set it here instead.\n         if set_match_place {\n-            for binding in &candidate.bindings {\n-                let local = self.var_local_id(binding.var_id, OutsideGuard);\n-\n-                if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                    opt_match_place: Some((ref mut match_place, _)),\n-                    ..\n-                }))) = self.local_decls[local].local_info\n-                {\n-                    *match_place = Some(*initializer);\n-                } else {\n-                    bug!(\"Let binding to non-user variable.\")\n+            let mut candidate_ref = &candidate;\n+            while let Some(next) = {\n+                for binding in &candidate_ref.bindings {\n+                    let local = self.var_local_id(binding.var_id, OutsideGuard);\n+\n+                    if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                        VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n+                    ))) = self.local_decls[local].local_info\n+                    {\n+                        *match_place = Some(initializer);\n+                    } else {\n+                        bug!(\"Let binding to non-user variable.\")\n+                    }\n                 }\n+                // All of the subcandidates should bind the same locals, so we\n+                // only visit the first one.\n+                candidate_ref.subcandidates.get(0)\n+            } {\n+                candidate_ref = next;\n             }\n         }\n \n-        self.ascribe_types(block, &candidate.ascriptions);\n-\n-        // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-\n-        block.unit()\n+        self.bind_pattern(\n+            self.source_info(irrefutable_pat.span),\n+            candidate,\n+            None,\n+            &fake_borrow_temps,\n+            irrefutable_pat.span,\n+            None,\n+        )\n+        .unit()\n     }\n \n     /// Declares the bindings of the given patterns and returns the visibility\n@@ -531,12 +545,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         var: HirId,\n         span: Span,\n         for_guard: ForGuard,\n+        schedule_drop: bool,\n     ) -> Place<'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n+        if schedule_drop {\n+            self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n+        }\n         Place::from(local_id)\n     }\n \n@@ -632,36 +649,90 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n             PatKind::Or { ref pats } => {\n-                for pat in pats {\n-                    self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n-                }\n+                self.visit_bindings(&pats[0], pattern_user_ty.clone(), f);\n             }\n         }\n     }\n }\n \n #[derive(Debug)]\n-crate struct Candidate<'pat, 'tcx> {\n-    // span of the original pattern that gave rise to this candidate\n+struct Candidate<'pat, 'tcx> {\n+    /// `Span` of the original pattern that gave rise to this candidate\n     span: Span,\n \n-    // all of these must be satisfied...\n+    /// This `Candidate` has a guard.\n+    has_guard: bool,\n+\n+    /// All of these must be satisfied...\n     match_pairs: SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n \n-    // ...these bindings established...\n+    /// ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n \n-    // ...and these types asserted...\n+    /// ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    // ...and the guard must be evaluated, if false branch to Block...\n+    /// ... and if this is non-empty, one of these subcandidates also has to match ...\n+    subcandidates: Vec<Candidate<'pat, 'tcx>>,\n+\n+    /// ...and the guard must be evaluated, if false branch to Block...\n     otherwise_block: Option<BasicBlock>,\n \n-    // ...and the blocks for add false edges between candidates\n-    pre_binding_block: BasicBlock,\n+    /// ...and the blocks for add false edges between candidates\n+    pre_binding_block: Option<BasicBlock>,\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n+impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n+    fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n+        Candidate {\n+            span: pattern.span,\n+            has_guard,\n+            match_pairs: smallvec![MatchPair { place, pattern }],\n+            bindings: Vec::new(),\n+            ascriptions: Vec::new(),\n+            subcandidates: Vec::new(),\n+            otherwise_block: None,\n+            pre_binding_block: None,\n+            next_candidate_pre_binding_block: None,\n+        }\n+    }\n+\n+    /// Visit the leaf candidates (those with no subcandidates) contained in\n+    /// this candidate.\n+    fn visit_leaves<'a>(&'a mut self, mut visit_leaf: impl FnMut(&'a mut Self)) {\n+        traverse_candidate(\n+            self,\n+            &mut (),\n+            &mut move |c, _| visit_leaf(c),\n+            move |c, _| c.subcandidates.iter_mut(),\n+            |_| {},\n+        );\n+    }\n+}\n+\n+/// A depth-first traversal of the `Candidate` and all of its recursive\n+/// subcandidates.\n+fn traverse_candidate<'pat, 'tcx: 'pat, C, T, I>(\n+    candidate: C,\n+    context: &mut T,\n+    visit_leaf: &mut impl FnMut(C, &mut T),\n+    get_children: impl Copy + Fn(C, &mut T) -> I,\n+    complete_children: impl Copy + Fn(&mut T),\n+) where\n+    C: Borrow<Candidate<'pat, 'tcx>>,\n+    I: Iterator<Item = C>,\n+{\n+    if candidate.borrow().subcandidates.is_empty() {\n+        visit_leaf(candidate, context)\n+    } else {\n+        for child in get_children(candidate, context) {\n+            traverse_candidate(child, context, visit_leaf, get_children, complete_children);\n+        }\n+        complete_children(context)\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n struct Binding<'tcx> {\n     span: Span,\n@@ -758,13 +829,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// which of these candidates, if any, is the correct one. The\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n-    /// the value, we will generate a branch to the appropriate\n+    /// the value, we will set and generate a branch to the appropriate\n     /// prebinding block.\n     ///\n     /// If we find that *NONE* of the candidates apply, we branch to the\n-    /// `otherwise_block`. In principle, this means that the input list was not\n-    /// exhaustive, though at present we sometimes are not smart enough to\n-    /// recognize all exhaustive inputs.\n+    /// `otherwise_block`, setting it to `Some` if required. In principle, this\n+    /// means that the input list was not exhaustive, though at present we\n+    /// sometimes are not smart enough to recognize all exhaustive inputs.\n     ///\n     /// It might be surprising that the input can be inexhaustive.\n     /// Indeed, initially, it is not, because all matches are\n@@ -775,11 +846,26 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// If `fake_borrows` is Some, then places which need fake borrows\n     /// will be added to it.\n+    ///\n+    /// For an example of a case where we set `otherwise_block`, even for an\n+    /// exhaustive match consider:\n+    ///\n+    /// match x {\n+    ///     (true, true) => (),\n+    ///     (_, false) => (),\n+    ///     (false, true) => (),\n+    /// }\n+    ///\n+    /// For this match, we check if `x.0` matches `true` (for the first\n+    /// arm). If that's false, we check `x.1`. If it's `true` we check if\n+    /// `x.0` matches `false` (for the third arm). In the (impossible at\n+    /// runtime) case when `x.0` is now `true`, we branch to\n+    /// `otherwise_block`.\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n-        start_block: &mut Option<BasicBlock>,\n-        otherwise_block: Option<BasicBlock>,\n+        start_block: BasicBlock,\n+        otherwise_block: &mut Option<BasicBlock>,\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n@@ -791,18 +877,53 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Start by simplifying candidates. Once this process is complete, all\n         // the match pairs which remain require some form of test, whether it\n         // be a switch or pattern comparison.\n+        let mut split_or_candidate = false;\n         for candidate in &mut *candidates {\n-            self.simplify_candidate(candidate);\n+            split_or_candidate |= self.simplify_candidate(candidate);\n         }\n \n+        if split_or_candidate {\n+            // At least one of the candidates has been split into subcandidates.\n+            // We need to change the candidate list to include those.\n+            let mut new_candidates = Vec::new();\n+\n+            for candidate in candidates {\n+                candidate.visit_leaves(|leaf_candidate| new_candidates.push(leaf_candidate));\n+            }\n+            self.match_simplified_candidates(\n+                span,\n+                start_block,\n+                otherwise_block,\n+                &mut *new_candidates,\n+                fake_borrows,\n+            );\n+        } else {\n+            self.match_simplified_candidates(\n+                span,\n+                start_block,\n+                otherwise_block,\n+                candidates,\n+                fake_borrows,\n+            );\n+        };\n+    }\n+\n+    fn match_simplified_candidates(\n+        &mut self,\n+        span: Span,\n+        start_block: BasicBlock,\n+        otherwise_block: &mut Option<BasicBlock>,\n+        candidates: &mut [&mut Candidate<'_, 'tcx>],\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) {\n         // The candidates are sorted by priority. Check to see whether the\n         // higher priority candidates (and hence at the front of the slice)\n         // have satisfied all their match pairs.\n         let fully_matched = candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n         debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n         let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n \n-        let block: BasicBlock = if !matched_candidates.is_empty() {\n+        let block = if !matched_candidates.is_empty() {\n             let otherwise_block =\n                 self.select_matched_candidates(matched_candidates, start_block, fake_borrows);\n \n@@ -816,23 +937,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.start_new_block()\n             }\n         } else {\n-            *start_block.get_or_insert_with(|| self.cfg.start_new_block())\n+            start_block\n         };\n \n         // If there are no candidates that still need testing, we're\n         // done. Since all matches are exhaustive, execution should\n         // never reach this point.\n         if unmatched_candidates.is_empty() {\n             let source_info = self.source_info(span);\n-            match otherwise_block {\n-                Some(otherwise) => self.cfg.goto(block, source_info, otherwise),\n-                None => self.cfg.terminate(block, source_info, TerminatorKind::Unreachable),\n+            if let Some(otherwise) = *otherwise_block {\n+                self.cfg.goto(block, source_info, otherwise);\n+            } else {\n+                *otherwise_block = Some(block);\n             }\n             return;\n         }\n \n         // Test for the remaining candidates.\n-        self.test_candidates(span, unmatched_candidates, block, otherwise_block, fake_borrows);\n+        self.test_candidates_with_or(\n+            span,\n+            unmatched_candidates,\n+            block,\n+            otherwise_block,\n+            fake_borrows,\n+        );\n     }\n \n     /// Link up matched candidates. For example, if we have something like\n@@ -856,13 +984,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n-        start_block: &mut Option<BasicBlock>,\n+        start_block: BasicBlock,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Option<BasicBlock> {\n         debug_assert!(\n             !matched_candidates.is_empty(),\n             \"select_matched_candidates called with no candidates\",\n         );\n+        debug_assert!(\n+            matched_candidates.iter().all(|c| c.subcandidates.is_empty()),\n+            \"subcandidates should be empty in select_matched_candidates\",\n+        );\n \n         // Insert a borrows of prefixes of places that are bound and are\n         // behind a dereference projection.\n@@ -899,65 +1031,206 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let fully_matched_with_guard = matched_candidates\n             .iter()\n-            .position(|c| c.otherwise_block.is_none())\n+            .position(|c| !c.has_guard)\n             .unwrap_or(matched_candidates.len() - 1);\n \n         let (reachable_candidates, unreachable_candidates) =\n             matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n \n-        let first_candidate = &reachable_candidates[0];\n-        let first_prebinding_block = first_candidate.pre_binding_block;\n+        let mut next_prebinding = start_block;\n \n-        // `goto -> first_prebinding_block` from the `start_block` if there is one.\n-        if let Some(start_block) = *start_block {\n-            let source_info = self.source_info(first_candidate.span);\n-            self.cfg.goto(start_block, source_info, first_prebinding_block);\n-        } else {\n-            *start_block = Some(first_prebinding_block);\n+        for candidate in reachable_candidates.iter_mut() {\n+            assert!(candidate.otherwise_block.is_none());\n+            assert!(candidate.pre_binding_block.is_none());\n+            candidate.pre_binding_block = Some(next_prebinding);\n+            if candidate.has_guard {\n+                // Create the otherwise block for this candidate, which is the\n+                // pre-binding block for the next candidate.\n+                next_prebinding = self.cfg.start_new_block();\n+                candidate.otherwise_block = Some(next_prebinding);\n+            }\n         }\n \n-        for (first_candidate, second_candidate) in reachable_candidates.iter().tuple_windows() {\n-            let source_info = self.source_info(first_candidate.span);\n-            if let Some(otherwise_block) = first_candidate.otherwise_block {\n-                self.false_edges(\n-                    otherwise_block,\n-                    second_candidate.pre_binding_block,\n-                    first_candidate.next_candidate_pre_binding_block,\n-                    source_info,\n-                );\n-            } else {\n-                bug!(\"candidate other than the last has no guard\");\n+        debug!(\n+            \"match_candidates: add pre_binding_blocks for unreachable {:?}\",\n+            unreachable_candidates,\n+        );\n+        for candidate in unreachable_candidates {\n+            assert!(candidate.pre_binding_block.is_none());\n+            candidate.pre_binding_block = Some(self.cfg.start_new_block());\n+        }\n+\n+        reachable_candidates.last_mut().unwrap().otherwise_block\n+    }\n+\n+    /// Tests a candidate where there are only or-patterns left to test, or\n+    /// forwards to [Builder::test_candidates].\n+    ///\n+    /// Given a pattern `(P | Q, R | S)` we (in principle) generate a CFG like\n+    /// so\n+    ///\n+    /// ```text\n+    /// [ start ]\n+    ///      |\n+    /// [ match P, Q ]\n+    ///      |\n+    ///      +----------------------------------------+------------------------------------+\n+    ///      |                                        |                                    |\n+    ///      V                                        V                                    V\n+    /// [ P matches ]                           [ Q matches ]                        [ otherwise ]\n+    ///      |                                        |                                    |\n+    ///      V                                        V                                    |\n+    /// [ match R, S ]                          [ match R, S ]                             |\n+    ///      |                                        |                                    |\n+    ///      +--------------+------------+            +--------------+------------+        |\n+    ///      |              |            |            |              |            |        |\n+    ///      V              V            V            V              V            V        |\n+    /// [ R matches ] [ S matches ] [otherwise ] [ R matches ] [ S matches ] [otherwise ]  |\n+    ///      |              |            |            |              |            |        |\n+    ///      +--------------+------------|------------+--------------+            |        |\n+    ///      |                           |                                        |        |\n+    ///      |                           +----------------------------------------+--------+\n+    ///      |                           |\n+    ///      V                           V\n+    /// [ Success ]                 [ Failure ]\n+    /// ```\n+    ///\n+    /// In practice there are some complications:\n+    ///\n+    /// * If there's a guard, then the otherwise branch of the first match on\n+    ///   `R | S` goes to a test for whether `Q` matches, and the control flow\n+    ///   doesn't merge into a single success block until after the guard is\n+    ///   tested.\n+    /// * If neither `P` or `Q` has any bindings or type ascriptions and there\n+    ///   isn't a match guard, then we create a smaller CFG like:\n+    ///\n+    /// ```text\n+    ///     ...\n+    ///      +---------------+------------+\n+    ///      |               |            |\n+    /// [ P matches ] [ Q matches ] [ otherwise ]\n+    ///      |               |            |\n+    ///      +---------------+            |\n+    ///      |                           ...\n+    /// [ match R, S ]\n+    ///      |\n+    ///     ...\n+    /// ```\n+    fn test_candidates_with_or(\n+        &mut self,\n+        span: Span,\n+        candidates: &mut [&mut Candidate<'_, 'tcx>],\n+        block: BasicBlock,\n+        otherwise_block: &mut Option<BasicBlock>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) {\n+        let (first_candidate, remaining_candidates) = candidates.split_first_mut().unwrap();\n+\n+        // All of the or-patterns have been sorted to the end, so if the first\n+        // pattern is an or-pattern we only have or-patterns.\n+        match *first_candidate.match_pairs[0].pattern.kind {\n+            PatKind::Or { .. } => (),\n+            _ => {\n+                self.test_candidates(span, candidates, block, otherwise_block, fake_borrows);\n+                return;\n             }\n         }\n \n-        debug!(\"match_candidates: add false edges for unreachable {:?}\", unreachable_candidates);\n-        for candidate in unreachable_candidates {\n-            if let Some(otherwise) = candidate.otherwise_block {\n-                let source_info = self.source_info(candidate.span);\n-                let unreachable = self.cfg.start_new_block();\n-                self.false_edges(\n-                    otherwise,\n-                    unreachable,\n-                    candidate.next_candidate_pre_binding_block,\n-                    source_info,\n-                );\n-                self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n+        let match_pairs = mem::take(&mut first_candidate.match_pairs);\n+        first_candidate.pre_binding_block = Some(block);\n+\n+        let mut otherwise = None;\n+        for match_pair in match_pairs {\n+            if let PatKind::Or { ref pats } = *match_pair.pattern.kind {\n+                let or_span = match_pair.pattern.span;\n+                let place = match_pair.place;\n+\n+                first_candidate.visit_leaves(|leaf_candidate| {\n+                    self.test_or_pattern(\n+                        leaf_candidate,\n+                        &mut otherwise,\n+                        pats,\n+                        or_span,\n+                        place,\n+                        fake_borrows,\n+                    );\n+                });\n+            } else {\n+                bug!(\"Or-patterns should have been sorted to the end\");\n             }\n         }\n \n-        let last_candidate = reachable_candidates.last().unwrap();\n-        if let Some(otherwise) = last_candidate.otherwise_block {\n-            let source_info = self.source_info(last_candidate.span);\n-            let block = self.cfg.start_new_block();\n-            self.false_edges(\n-                otherwise,\n-                block,\n-                last_candidate.next_candidate_pre_binding_block,\n-                source_info,\n-            );\n-            Some(block)\n+        let remainder_start = otherwise.unwrap_or_else(|| self.cfg.start_new_block());\n+\n+        self.match_candidates(\n+            span,\n+            remainder_start,\n+            otherwise_block,\n+            remaining_candidates,\n+            fake_borrows,\n+        )\n+    }\n+\n+    fn test_or_pattern<'pat>(\n+        &mut self,\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+        otherwise: &mut Option<BasicBlock>,\n+        pats: &'pat [Pat<'tcx>],\n+        or_span: Span,\n+        place: Place<'tcx>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) {\n+        debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n+        let mut or_candidates: Vec<_> =\n+            pats.iter().map(|pat| Candidate::new(place, pat, candidate.has_guard)).collect();\n+        let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n+        let otherwise = if candidate.otherwise_block.is_some() {\n+            &mut candidate.otherwise_block\n         } else {\n-            None\n+            otherwise\n+        };\n+        self.match_candidates(\n+            or_span,\n+            candidate.pre_binding_block.unwrap(),\n+            otherwise,\n+            &mut or_candidate_refs,\n+            fake_borrows,\n+        );\n+        candidate.subcandidates = or_candidates;\n+        self.merge_trivial_subcandidates(candidate, self.source_info(or_span));\n+    }\n+\n+    /// Try to merge all of the subcandidates of the given candidate into one.\n+    /// This avoids exponentially large CFGs in cases like `(1 | 2, 3 | 4, ...)`.\n+    fn merge_trivial_subcandidates(\n+        &mut self,\n+        candidate: &mut Candidate<'_, 'tcx>,\n+        source_info: SourceInfo,\n+    ) {\n+        if candidate.subcandidates.is_empty() || candidate.has_guard {\n+            // FIXME(or_patterns; matthewjasper) Don't give up if we have a guard.\n+            return;\n+        }\n+\n+        let mut can_merge = true;\n+\n+        // Not `Iterator::all` because we don't want to short-circuit.\n+        for subcandidate in &mut candidate.subcandidates {\n+            self.merge_trivial_subcandidates(subcandidate, source_info);\n+\n+            // FIXME(or_patterns; matthewjasper) Try to be more aggressive here.\n+            can_merge &= subcandidate.subcandidates.is_empty()\n+                && subcandidate.bindings.is_empty()\n+                && subcandidate.ascriptions.is_empty();\n+        }\n+\n+        if can_merge {\n+            let any_matches = self.cfg.start_new_block();\n+            for subcandidate in mem::take(&mut candidate.subcandidates) {\n+                let or_block = subcandidate.pre_binding_block.unwrap();\n+                self.cfg.goto(or_block, source_info, any_matches);\n+            }\n+            candidate.pre_binding_block = Some(any_matches);\n         }\n     }\n \n@@ -1078,7 +1351,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n-        mut otherwise_block: Option<BasicBlock>,\n+        otherwise_block: &mut Option<BasicBlock>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n         // extract the match-pair from the highest priority candidate\n@@ -1115,7 +1388,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Insert a Shallow borrow of any places that is switched on.\n-        fake_borrows.as_mut().map(|fb| fb.insert(match_place.clone()));\n+        fake_borrows.as_mut().map(|fb| fb.insert(match_place));\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n@@ -1150,52 +1423,52 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // improves the speed of llvm when optimizing long string literal\n         // matches\n         let make_target_blocks = move |this: &mut Self| -> Vec<BasicBlock> {\n+            // The block that we should branch to if none of the\n+            // `target_candidates` match. This is either the block where we\n+            // start matching the untested candidates if there are any,\n+            // otherwise it's the `otherwise_block`.\n+            let remainder_start = &mut None;\n+            let remainder_start =\n+                if candidates.is_empty() { &mut *otherwise_block } else { remainder_start };\n+\n             // For each outcome of test, process the candidates that still\n             // apply. Collect a list of blocks where control flow will\n             // branch if one of the `target_candidate` sets is not\n             // exhaustive.\n-            if !candidates.is_empty() {\n-                let remainder_start = &mut None;\n-                this.match_candidates(\n-                    span,\n-                    remainder_start,\n-                    otherwise_block,\n-                    candidates,\n-                    fake_borrows,\n-                );\n-                otherwise_block = Some(remainder_start.unwrap());\n-            };\n-\n-            target_candidates\n+            let target_blocks: Vec<_> = target_candidates\n                 .into_iter()\n                 .map(|mut candidates| {\n                     if candidates.len() != 0 {\n-                        let candidate_start = &mut None;\n+                        let candidate_start = this.cfg.start_new_block();\n                         this.match_candidates(\n                             span,\n                             candidate_start,\n-                            otherwise_block,\n+                            remainder_start,\n                             &mut *candidates,\n                             fake_borrows,\n                         );\n-                        candidate_start.unwrap()\n+                        candidate_start\n                     } else {\n-                        *otherwise_block.get_or_insert_with(|| {\n-                            let unreachable = this.cfg.start_new_block();\n-                            let source_info = this.source_info(span);\n-                            this.cfg.terminate(\n-                                unreachable,\n-                                source_info,\n-                                TerminatorKind::Unreachable,\n-                            );\n-                            unreachable\n-                        })\n+                        *remainder_start.get_or_insert_with(|| this.cfg.start_new_block())\n                     }\n                 })\n-                .collect()\n+                .collect();\n+\n+            if !candidates.is_empty() {\n+                let remainder_start = remainder_start.unwrap_or_else(|| this.cfg.start_new_block());\n+                this.match_candidates(\n+                    span,\n+                    remainder_start,\n+                    otherwise_block,\n+                    candidates,\n+                    fake_borrows,\n+                );\n+            };\n+\n+            target_blocks\n         };\n \n-        self.perform_test(block, &match_place, &test, make_target_blocks);\n+        self.perform_test(block, match_place, &test, make_target_blocks);\n     }\n \n     /// Determine the fake borrows that are needed from a set of places that\n@@ -1287,25 +1560,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_and_guard_matched_candidate<'pat>(\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n+        parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n         guard: Option<(&Guard<'tcx>, region::Scope)>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n+        schedule_drops: bool,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n         let candidate_source_info = self.source_info(candidate.span);\n \n-        let mut block = candidate.pre_binding_block;\n+        let mut block = candidate.pre_binding_block.unwrap();\n \n-        // If we are adding our own statements, then we need a fresh block.\n-        let create_fresh_block = candidate.next_candidate_pre_binding_block.is_some()\n-            || !candidate.bindings.is_empty()\n-            || !candidate.ascriptions.is_empty()\n-            || guard.is_some();\n-\n-        if create_fresh_block {\n+        if candidate.next_candidate_pre_binding_block.is_some() {\n             let fresh_block = self.cfg.start_new_block();\n             self.false_edges(\n                 block,\n@@ -1314,11 +1583,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 candidate_source_info,\n             );\n             block = fresh_block;\n-            self.ascribe_types(block, &candidate.ascriptions);\n-        } else {\n-            return block;\n         }\n \n+        self.ascribe_types(\n+            block,\n+            parent_bindings\n+                .iter()\n+                .flat_map(|(_, ascriptions)| ascriptions)\n+                .chain(&candidate.ascriptions),\n+        );\n+\n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n         //\n@@ -1401,23 +1675,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //      reference to that.\n         if let Some((guard, region_scope)) = guard {\n             let tcx = self.hir.tcx();\n+            let bindings = parent_bindings\n+                .iter()\n+                .flat_map(|(bindings, _)| bindings)\n+                .chain(&candidate.bindings);\n \n-            self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+            self.bind_matched_candidate_for_guard(block, schedule_drops, bindings.clone());\n             let guard_frame = GuardFrame {\n-                locals: candidate\n-                    .bindings\n-                    .iter()\n-                    .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n-                    .collect(),\n+                locals: bindings.map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode)).collect(),\n             };\n             debug!(\"entering guard building context: {:?}\", guard_frame);\n             self.guard_context.push(guard_frame);\n \n             let re_erased = tcx.lifetimes.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n-            for (place, temp) in fake_borrows {\n-                let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, *place);\n-                self.cfg.push_assign(block, scrutinee_source_info, &Place::from(*temp), borrow);\n+            for &(place, temp) in fake_borrows {\n+                let borrow = Rvalue::Ref(re_erased, BorrowKind::Shallow, place);\n+                self.cfg.push_assign(block, scrutinee_source_info, &Place::from(temp), borrow);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n@@ -1437,11 +1711,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(temp));\n             }\n \n+            let otherwise_block = candidate.otherwise_block.unwrap_or_else(|| {\n+                let unreachable = self.cfg.start_new_block();\n+                self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n+                unreachable\n+            });\n+            let outside_scope = self.cfg.start_new_block();\n             self.exit_scope(\n                 source_info.span,\n                 region_scope,\n                 otherwise_post_guard_block,\n-                candidate.otherwise_block.unwrap(),\n+                outside_scope,\n+            );\n+            self.false_edges(\n+                outside_scope,\n+                otherwise_block,\n+                candidate.next_candidate_pre_binding_block,\n+                source_info,\n             );\n \n             // We want to ensure that the matched candidates are bound\n@@ -1470,32 +1756,50 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // ```\n             //\n             // and that is clearly not correct.\n-            let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n-                if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n-            });\n+            let by_value_bindings =\n+                parent_bindings\n+                    .iter()\n+                    .flat_map(|(bindings, _)| bindings)\n+                    .chain(&candidate.bindings)\n+                    .filter(|binding| {\n+                        if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n+                    });\n             // Read all of the by reference bindings to ensure that the\n             // place they refer to can't be modified by the guard.\n             for binding in by_value_bindings.clone() {\n                 let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n                 let cause = FakeReadCause::ForGuardBinding;\n                 self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(local_id));\n             }\n-            self.bind_matched_candidate_for_arm_body(post_guard_block, by_value_bindings);\n+            assert!(schedule_drops, \"patterns with guards must schedule drops\");\n+            self.bind_matched_candidate_for_arm_body(post_guard_block, true, by_value_bindings);\n \n             post_guard_block\n         } else {\n-            assert!(candidate.otherwise_block.is_none());\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n-            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n+            self.bind_matched_candidate_for_arm_body(\n+                block,\n+                schedule_drops,\n+                parent_bindings\n+                    .iter()\n+                    .flat_map(|(bindings, _)| bindings)\n+                    .chain(&candidate.bindings),\n+            );\n             block\n         }\n     }\n \n     /// Append `AscribeUserType` statements onto the end of `block`\n     /// for each ascription\n-    fn ascribe_types(&mut self, block: BasicBlock, ascriptions: &[Ascription<'tcx>]) {\n+    fn ascribe_types<'b>(\n+        &mut self,\n+        block: BasicBlock,\n+        ascriptions: impl IntoIterator<Item = &'b Ascription<'tcx>>,\n+    ) where\n+        'tcx: 'b,\n+    {\n         for ascription in ascriptions {\n             let source_info = self.source_info(ascription.span);\n \n@@ -1522,22 +1826,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    fn bind_matched_candidate_for_guard(&mut self, block: BasicBlock, bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\", block, bindings);\n+    fn bind_matched_candidate_for_guard<'b>(\n+        &mut self,\n+        block: BasicBlock,\n+        schedule_drops: bool,\n+        bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n+    ) where\n+        'tcx: 'b,\n+    {\n+        debug!(\"bind_matched_candidate_for_guard(block={:?})\", block);\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n         // candidate.\n         let re_erased = self.hir.tcx().lifetimes.re_erased;\n         for binding in bindings {\n+            debug!(\"bind_matched_candidate_for_guard(binding={:?})\", binding);\n             let source_info = self.source_info(binding.span);\n \n             // For each pattern ident P of type T, `ref_for_guard` is\n             // a reference R: &T pointing to the location matched by\n             // the pattern, and every occurrence of P within a guard\n             // denotes *R.\n-            let ref_for_guard =\n-                self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n+            let ref_for_guard = self.storage_live_binding(\n+                block,\n+                binding.var_id,\n+                binding.span,\n+                RefWithinGuard,\n+                schedule_drops,\n+            );\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, binding.source);\n@@ -1549,6 +1866,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         binding.var_id,\n                         binding.span,\n                         OutsideGuard,\n+                        schedule_drops,\n                     );\n \n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source);\n@@ -1563,6 +1881,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_matched_candidate_for_arm_body<'b>(\n         &mut self,\n         block: BasicBlock,\n+        schedule_drops: bool,\n         bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n     ) where\n         'tcx: 'b,\n@@ -1573,9 +1892,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local =\n-                self.storage_live_binding(block, binding.var_id, binding.span, OutsideGuard);\n-            self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+            let local = self.storage_live_binding(\n+                block,\n+                binding.var_id,\n+                binding.span,\n+                OutsideGuard,\n+                schedule_drops,\n+            );\n+            if schedule_drops {\n+                self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+            }\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     Rvalue::Use(self.consume_by_copy_or_move(binding.source.clone()))"}, {"sha": "56aa150dd37d2f46db86dc8337dc4aa8f0107673", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -16,6 +16,7 @@ use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n use crate::hair::{self, *};\n use rustc::mir::interpret::truncate;\n+use rustc::mir::Place;\n use rustc::ty;\n use rustc::ty::layout::{Integer, IntegerExt, Size};\n use rustc_attr::{SignedInt, UnsignedInt};\n@@ -24,10 +25,33 @@ use rustc_hir::RangeEnd;\n use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn simplify_candidate<'pat>(&mut self, candidate: &mut Candidate<'pat, 'tcx>) {\n+    /// Simplify a candidate so that all match pairs require a test.\n+    ///\n+    /// This method will also split a candidate where the only match-pair is an\n+    /// or-pattern into multiple candidates. This is so that\n+    ///\n+    /// match x {\n+    ///     0 | 1 => { ... },\n+    ///     2 | 3 => { ... },\n+    /// }\n+    ///\n+    /// only generates a single switch. If this happens this method returns\n+    /// `true`.\n+    pub(super) fn simplify_candidate<'pat>(\n+        &mut self,\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+    ) -> bool {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n+\n+            if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n+                *match_pairs\n+            {\n+                candidate.subcandidates = self.create_or_subcandidates(candidate, place, pats);\n+                return true;\n+            }\n+\n             let mut changed = false;\n             for match_pair in match_pairs {\n                 match self.simplify_match_pair(match_pair, candidate) {\n@@ -40,11 +64,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n             if !changed {\n-                return; // if we were not able to simplify any, done.\n+                // Move or-patterns to the end, because they can result in us\n+                // creating additional candidates, so we want to test them as\n+                // late as possible.\n+                candidate\n+                    .match_pairs\n+                    .sort_by_key(|pair| matches!(*pair.pattern.kind, PatKind::Or { .. }));\n+                return false; // if we were not able to simplify any, done.\n             }\n         }\n     }\n \n+    /// Given `candidate` that has a single or-pattern for its match-pairs,\n+    /// creates a fresh candidate for each of its input subpatterns passed via\n+    /// `pats`.\n+    fn create_or_subcandidates<'pat>(\n+        &mut self,\n+        candidate: &Candidate<'pat, 'tcx>,\n+        place: Place<'tcx>,\n+        pats: &'pat [Pat<'tcx>],\n+    ) -> Vec<Candidate<'pat, 'tcx>> {\n+        pats.iter()\n+            .map(|pat| {\n+                let mut candidate = Candidate::new(place, pat, candidate.has_guard);\n+                self.simplify_candidate(&mut candidate);\n+                candidate\n+            })\n+            .collect()\n+    }\n+\n     /// Tries to simplify `match_pair`, returning `Ok(())` if\n     /// successful. If successful, new match pairs and bindings will\n     /// have been pushed into the candidate. If no simplification is"}, {"sha": "1acfa7dddbe1f7822729c6d1b58021a6b68f8bfb", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifiable pattern.\n-    crate fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n+    pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {\n                 span: match_pair.pattern.span,\n@@ -70,11 +70,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Or { .. } => self\n-                .hir\n-                .tcx()\n-                .sess\n-                .span_fatal(match_pair.pattern.span, \"or-patterns are not fully implemented yet\"),\n+            PatKind::Or { .. } => bug!(\"or-patterns should have already been handled\"),\n \n             PatKind::AscribeUserType { .. }\n             | PatKind::Array { .. }\n@@ -85,7 +81,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn add_cases_to_switch<'pat>(\n+    pub(super) fn add_cases_to_switch<'pat>(\n         &mut self,\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n@@ -129,7 +125,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn add_variants_to_switch<'pat>(\n+    pub(super) fn add_variants_to_switch<'pat>(\n         &mut self,\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n@@ -156,10 +152,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn perform_test(\n+    pub(super) fn perform_test(\n         &mut self,\n         block: BasicBlock,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n@@ -209,7 +205,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n-                self.cfg.push_assign(block, source_info, &discr, Rvalue::Discriminant(*place));\n+                self.cfg.push_assign(block, source_info, &discr, Rvalue::Discriminant(place));\n                 assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(\n                     block,\n@@ -233,20 +229,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             0 => (second_bb, first_bb),\n                             v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n                         };\n-                        TerminatorKind::if_(\n-                            self.hir.tcx(),\n-                            Operand::Copy(*place),\n-                            true_bb,\n-                            false_bb,\n-                        )\n+                        TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place), true_bb, false_bb)\n                     } else {\n                         bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n                     }\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n                     TerminatorKind::SwitchInt {\n-                        discr: Operand::Copy(*place),\n+                        discr: Operand::Copy(place),\n                         switch_ty,\n                         values: options.clone().into(),\n                         targets: target_blocks,\n@@ -271,7 +262,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     if let [success, fail] = *make_target_blocks(self) {\n                         assert_eq!(value.ty, ty);\n                         let expect = self.literal_operand(test.span, value);\n-                        let val = Operand::Copy(*place);\n+                        let val = Operand::Copy(place);\n                         self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n                     } else {\n                         bug!(\"`TestKind::Eq` should have two target blocks\");\n@@ -286,7 +277,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, lo);\n                 let hi = self.literal_operand(test.span, hi);\n-                let val = Operand::Copy(*place);\n+                let val = Operand::Copy(place);\n \n                 if let [success, fail] = *target_blocks {\n                     self.compare(\n@@ -315,7 +306,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n-                self.cfg.push_assign(block, source_info, &actual, Rvalue::Len(*place));\n+                self.cfg.push_assign(block, source_info, &actual, Rvalue::Len(place));\n \n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n@@ -371,13 +362,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n         value: &'tcx ty::Const<'tcx>,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n         use rustc::middle::lang_items::EqTraitLangItem;\n \n         let mut expect = self.literal_operand(source_info.span, value);\n-        let mut val = Operand::Copy(*place);\n+        let mut val = Operand::Copy(place);\n \n         // If we're using `b\"...\"` as a pattern, we need to insert an\n         // unsizing coercion, as the byte string has the type `&[u8; N]`.\n@@ -502,7 +493,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// that it *doesn't* apply. For now, we return false, indicate that the\n     /// test does not apply to this candidate, but it might be we can get\n     /// tighter match code if we do something a bit different.\n-    crate fn sort_candidate<'pat>(\n+    pub(super) fn sort_candidate<'pat>(\n         &mut self,\n         test_place: &Place<'tcx>,\n         test: &Test<'tcx>,\n@@ -755,8 +746,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place =\n-                tcx.mk_place_field(downcast_place.clone(), subpattern.field, subpattern.pattern.ty);\n+            let place = tcx.mk_place_field(downcast_place, subpattern.field, subpattern.pattern.ty);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern)\n         });"}, {"sha": "7e51f7aafe4b336fb3ba63ce335e21eceec2c600", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -899,7 +899,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             matches::ArmHasGuard(false),\n                             Some((Some(&place), span)),\n                         );\n-                        unpack!(block = self.place_into_pattern(block, pattern, &place, false));\n+                        unpack!(block = self.place_into_pattern(block, pattern, place, false));\n                     }\n                 }\n                 self.source_scope = original_source_scope;"}, {"sha": "cb93ba7c9250f3b31c216b6f48f3d71f972aaca5", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -315,17 +315,6 @@ crate struct Arm<'tcx> {\n     crate span: Span,\n }\n \n-impl<'tcx> Arm<'tcx> {\n-    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-    // correctly handle each case in which this method is used.\n-    crate fn top_pats_hack(&self) -> &[Pat<'tcx>] {\n-        match &*self.pattern.kind {\n-            PatKind::Or { pats } => pats,\n-            _ => std::slice::from_ref(&self.pattern),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n crate enum Guard<'tcx> {\n     If(ExprRef<'tcx>),"}, {"sha": "667d21fc14ee4034295e5e7b2a7ccd6bc13afa05", "filename": "src/test/mir-opt/const_prop/discriminant.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -10,18 +10,18 @@ fn main() {\n //      ...\n //      _3 = std::option::Option::<bool>::Some(const true,);\n //      _4 = discriminant(_3);\n-//      switchInt(move _4) -> [1isize: bb3, otherwise: bb2];\n+//      switchInt(move _4) -> [1isize: bb2, otherwise: bb1];\n //  }\n //  bb1: {\n-//      _2 = const 42i32;\n+//      _2 = const 10i32;\n //      goto -> bb4;\n //  }\n //  bb2: {\n-//      _2 = const 10i32;\n-//      goto -> bb4;\n+//      switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3];\n //  }\n //  bb3: {\n-//      switchInt(((_3 as Some).0: bool)) -> [false: bb2, otherwise: bb1];\n+//      _2 = const 42i32;\n+//      goto -> bb4;\n //  }\n //  bb4: {\n //      _1 = Add(move _2, const 0i32);\n@@ -33,18 +33,18 @@ fn main() {\n //      ...\n //      _3 = const Scalar(0x01) : std::option::Option<bool>;\n //      _4 = const 1isize;\n-//      switchInt(const 1isize) -> [1isize: bb3, otherwise: bb2];\n+//      switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1];\n //  }\n //  bb1: {\n-//      _2 = const 42i32;\n+//      _2 = const 10i32;\n //      goto -> bb4;\n //  }\n //  bb2: {\n-//      _2 = const 10i32;\n-//      goto -> bb4;\n+//      switchInt(const true) -> [false: bb1, otherwise: bb3];\n //  }\n //  bb3: {\n-//      switchInt(const true) -> [false: bb2, otherwise: bb1];\n+//      _2 = const 42i32;\n+//      goto -> bb4;\n //  }\n //  bb4: {\n //      _1 = Add(move _2, const 0i32);"}, {"sha": "4c23582e1f8949498a5943a2fb68541b33a868a9", "filename": "src/test/mir-opt/exponential-or.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fexponential-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fexponential-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fexponential-or.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,76 @@\n+// Test that simple or-patterns don't get expanded to exponentially large CFGs\n+\n+// ignore-tidy-linelength\n+\n+#![feature(or_patterns)]\n+\n+fn match_tuple(x: (u32, bool, Option<i32>, u32)) -> u32 {\n+    match x {\n+        (y @ (1 | 4), true | false, Some(1 | 8) | None, z @ (6..=9 | 13..=16)) => y ^ z,\n+        _ => 0,\n+    }\n+}\n+\n+fn main() {}\n+\n+// END RUST SOURCE\n+\n+// START rustc.match_tuple.SimplifyCfg-initial.after.mir\n+// scope 1 {\n+//     debug y => _7;\n+//     debug z => _8;\n+// }\n+// bb0: {\n+//     FakeRead(ForMatchedPlace, _1);\n+//     switchInt((_1.0: u32)) -> [1u32: bb2, 4u32: bb2, otherwise: bb1];\n+// }\n+// bb1: {\n+//     _0 = const 0u32;\n+//     goto -> bb10;\n+// }\n+// bb2: {\n+//     _2 = discriminant((_1.2: std::option::Option<i32>));\n+//     switchInt(move _2) -> [0isize: bb4, 1isize: bb3, otherwise: bb1];\n+// }\n+// bb3: {\n+//     switchInt((((_1.2: std::option::Option<i32>) as Some).0: i32)) -> [1i32: bb4, 8i32: bb4, otherwise: bb1];\n+// }\n+// bb4: {\n+//     _5 = Le(const 6u32, (_1.3: u32));\n+//     switchInt(move _5) -> [false: bb6, otherwise: bb5];\n+// }\n+// bb5: {\n+//     _6 = Le((_1.3: u32), const 9u32);\n+//     switchInt(move _6) -> [false: bb6, otherwise: bb8];\n+// }\n+// bb6: {\n+//     _3 = Le(const 13u32, (_1.3: u32));\n+//     switchInt(move _3) -> [false: bb1, otherwise: bb7];\n+// }\n+// bb7: {\n+//     _4 = Le((_1.3: u32), const 16u32);\n+//     switchInt(move _4) -> [false: bb1, otherwise: bb8];\n+// }\n+// bb8: {\n+//     falseEdges -> [real: bb9, imaginary: bb1];\n+// }\n+// bb9: {\n+//     StorageLive(_7);\n+//     _7 = (_1.0: u32);\n+//     StorageLive(_8);\n+//     _8 = (_1.3: u32);\n+//     StorageLive(_9);\n+//     _9 = _7;\n+//     StorageLive(_10);\n+//     _10 = _8;\n+//     _0 = BitXor(move _9, move _10);\n+//     StorageDead(_10);\n+//     StorageDead(_9);\n+//     StorageDead(_8);\n+//     StorageDead(_7);\n+//     goto -> bb10;\n+// }\n+// bb10: {\n+//     return;\n+// }\n+// END rustc.match_tuple.SimplifyCfg-initial.after.mir"}, {"sha": "8e619ffdf8b96c14c174750fbe758f174fb7e990", "filename": "src/test/mir-opt/issue-62289.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fissue-62289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fissue-62289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-62289.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -32,47 +32,47 @@ fn main() {\n //     bb2: {\n //         StorageDead(_4);\n //         _5 = discriminant(_3);\n-//         switchInt(move _5) -> [0isize: bb10, 1isize: bb5, otherwise: bb4];\n+//         switchInt(move _5) -> [0isize: bb4, 1isize: bb6, otherwise: bb5];\n //     }\n //     bb3 (cleanup): {\n //         drop(_2) -> bb1;\n //     }\n //     bb4: {\n-//         unreachable;\n+//         StorageLive(_10);\n+//         _10 = ((_3 as Ok).0: u32);\n+//         (*_2) = _10;\n+//         StorageDead(_10);\n+//         _1 = move _2;\n+//         drop(_2) -> [return: bb12, unwind: bb11];\n //     }\n //     bb5: {\n+//         unreachable;\n+//     }\n+//     bb6: {\n //         StorageLive(_6);\n //         _6 = ((_3 as Err).0: std::option::NoneError);\n //         StorageLive(_8);\n //         StorageLive(_9);\n //         _9 = _6;\n-//         _8 = const <std::option::NoneError as std::convert::From<std::option::NoneError>>::from(move _9) -> [return: bb7, unwind: bb3];\n+//         _8 = const <std::option::NoneError as std::convert::From<std::option::NoneError>>::from(move _9) -> [return: bb8, unwind: bb3];\n //     }\n-//     bb6: {\n+//     bb7: {\n //         return;\n //     }\n-//     bb7: {\n+//     bb8: {\n //         StorageDead(_9);\n-//         _0 = const <std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error(move _8) -> [return: bb8, unwind: bb3];\n+//         _0 = const <std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error(move _8) -> [return: bb9, unwind: bb3];\n //     }\n-//     bb8: {\n+//     bb9: {\n //         StorageDead(_8);\n //         StorageDead(_6);\n-//         drop(_2) -> bb9;\n+//         drop(_2) -> bb10;\n //     }\n-//     bb9: {\n+//     bb10: {\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         StorageDead(_3);\n-//         goto -> bb6;\n-//     }\n-//     bb10: {\n-//         StorageLive(_10);\n-//         _10 = ((_3 as Ok).0: u32);\n-//         (*_2) = _10;\n-//         StorageDead(_10);\n-//         _1 = move _2;\n-//         drop(_2) -> [return: bb12, unwind: bb11];\n+//         goto -> bb7;\n //     }\n //     bb11 (cleanup): {\n //         drop(_1) -> bb1;\n@@ -85,7 +85,7 @@ fn main() {\n //     bb13: {\n //         StorageDead(_1);\n //         StorageDead(_3);\n-//         goto -> bb6;\n+//         goto -> bb7;\n //     }\n // }\n // END rustc.test.ElaborateDrops.before.mir"}, {"sha": "7afc3bbd6fae86c035f57a1de1eafb39848717df", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -28,10 +28,7 @@ const CASES: &[(bool, bool, bool, i32)] = &[\n \n fn main() {\n     for &(cond, items_1, items_2, result) in CASES {\n-        assert_eq!(\n-            complicated_match(cond, (items_1, items_2, String::new())),\n-            result,\n-        );\n+        assert_eq!(complicated_match(cond, (items_1, items_2, String::new())), result,);\n     }\n }\n \n@@ -64,31 +61,38 @@ fn main() {\n // }\n // bb0: {\n //     FakeRead(ForMatchedPlace, _2);\n-//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb5];\n+//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb3];\n // }\n // bb1 (cleanup): {\n //     resume;\n // }\n-// bb2: {\n-//     falseEdges -> [real: bb8, imaginary: bb3];\n+// bb2: {                               // pre-binding for arm 1 first pattern\n+//     falseEdges -> [real: bb9, imaginary: bb4];\n // }\n // bb3: {\n-//     falseEdges -> [real: bb17, imaginary: bb4];\n+//     switchInt((_2.1: bool)) -> [false: bb4, otherwise: bb5];\n // }\n-// bb4: {\n-//     falseEdges -> [real: bb25, imaginary: bb26];\n+// bb4: {                               // pre-binding for arm 1 second pattern\n+//     falseEdges -> [real: bb18, imaginary: bb6];\n // }\n // bb5: {\n-//     switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb6];\n+//     switchInt((_2.0: bool)) -> [false: bb7, otherwise: bb6];\n // }\n-// bb6: {\n-//     switchInt((_2.0: bool)) -> [false: bb26, otherwise: bb4];\n+// bb6: {                               // pre-binding for arm 2 first pattern\n+//     falseEdges -> [real: bb26, imaginary: bb7];\n // }\n-// bb7: {                               // arm 1\n+// bb7: {                               // bindings for arm 2 - second pattern\n+//     StorageLive(_15);\n+//     _15 = (_2.1: bool);\n+//     StorageLive(_16);\n+//     _16 = move (_2.2: std::string::String);\n+//     goto -> bb25;\n+// }\n+// bb8: {                               // arm 1\n //     _0 = const 1i32;\n-//     drop(_7) -> [return: bb23, unwind: bb13];\n+//     drop(_7) -> [return: bb24, unwind: bb14];\n // }\n-// bb8: {                               // guard - first time\n+// bb9: {                               // guard - first time\n //     StorageLive(_6);\n //     _6 = &(_2.1: bool);\n //     StorageLive(_8);\n@@ -99,34 +103,34 @@ fn main() {\n //     StorageLive(_10);\n //     _10 = _1;\n //     FakeRead(ForMatchedPlace, _10);\n-//     switchInt(_10) -> [false: bb10, otherwise: bb9];\n+//     switchInt(_10) -> [false: bb11, otherwise: bb10];\n // }\n-// bb9: {\n-//     falseEdges -> [real: bb11, imaginary: bb10];\n+// bb10: {\n+//     falseEdges -> [real: bb12, imaginary: bb11];\n // }\n-// bb10: {                              // `else` block - first time\n+// bb11: {                              // `else` block - first time\n //     _9 = (*_6);\n //     StorageDead(_10);\n-//     switchInt(move _9) -> [false: bb16, otherwise: bb15];\n+//     switchInt(move _9) -> [false: bb17, otherwise: bb16];\n // }\n-// bb11: {                              // `return 3` - first time\n+// bb12: {                              // `return 3` - first time\n //     _0 = const 3i32;\n //     StorageDead(_10);\n //     StorageDead(_9);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     goto -> bb14;\n+//     goto -> bb15;\n // }\n-// bb12: {\n+// bb13: {\n //     return;\n // }\n-// bb13 (cleanup): {\n+// bb14 (cleanup): {\n //     drop(_2) -> bb1;\n // }\n-// bb14: {\n-//     drop(_2) -> [return: bb12, unwind: bb1];\n-// }\n // bb15: {\n+//     drop(_2) -> [return: bb13, unwind: bb1];\n+// }\n+// bb16: {\n //     StorageDead(_9);\n //     FakeRead(ForMatchGuard, _3);\n //     FakeRead(ForMatchGuard, _4);\n@@ -136,15 +140,15 @@ fn main() {\n //     _5 = (_2.1: bool);\n //     StorageLive(_7);\n //     _7 = move (_2.2: std::string::String);\n-//     goto -> bb7;\n+//     goto -> bb8;\n // }\n-// bb16: {                              // guard otherwise case - first time\n+// bb17: {                              // guard otherwise case - first time\n //     StorageDead(_9);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     falseEdges -> [real: bb5, imaginary: bb3];\n+//     falseEdges -> [real: bb3, imaginary: bb4];\n // }\n-// bb17: {                              // guard - second time\n+// bb18: {                              // guard - second time\n //     StorageLive(_6);\n //     _6 = &(_2.0: bool);\n //     StorageLive(_8);\n@@ -155,25 +159,25 @@ fn main() {\n //     StorageLive(_13);\n //     _13 = _1;\n //     FakeRead(ForMatchedPlace, _13);\n-//     switchInt(_13) -> [false: bb19, otherwise: bb18];\n+//     switchInt(_13) -> [false: bb20, otherwise: bb19];\n // }\n-// bb18: {\n-//     falseEdges -> [real: bb20, imaginary: bb19];\n+// bb19: {\n+//     falseEdges -> [real: bb21, imaginary: bb20];\n // }\n-// bb19: {                              // `else` block - second time\n+// bb20: {                              // `else` block - second time\n //     _12 = (*_6);\n //     StorageDead(_13);\n-//     switchInt(move _12) -> [false: bb22, otherwise: bb21];\n+//     switchInt(move _12) -> [false: bb23, otherwise: bb22];\n // }\n-// bb20: {\n+// bb21: {\n //     _0 = const 3i32;\n //     StorageDead(_13);\n //     StorageDead(_12);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     goto -> bb14;\n+//     goto -> bb15;\n // }\n-// bb21: {                              // bindings for arm 1\n+// bb22: {                              // bindings for arm 1\n //     StorageDead(_12);\n //     FakeRead(ForMatchGuard, _3);\n //     FakeRead(ForMatchGuard, _4);\n@@ -183,46 +187,40 @@ fn main() {\n //     _5 = (_2.0: bool);\n //     StorageLive(_7);\n //     _7 = move (_2.2: std::string::String);\n-//     goto -> bb7;\n+//     goto -> bb8;\n // }\n-// bb22: {                              // Guard otherwise case - second time\n+// bb23: {                              // Guard otherwise case - second time\n //     StorageDead(_12);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     falseEdges -> [real: bb6, imaginary: bb4];\n+//     falseEdges -> [real: bb5, imaginary: bb6];\n // }\n-// bb23: {                              // rest of arm 1\n+// bb24: {                              // rest of arm 1\n //     StorageDead(_7);\n //     StorageDead(_5);\n //     StorageDead(_8);\n //     StorageDead(_6);\n //     goto -> bb28;\n // }\n-// bb24: {                              // arm 2\n+// bb25: {                              // arm 2\n //     _0 = const 2i32;\n-//     drop(_16) -> [return: bb27, unwind: bb13];\n+//     drop(_16) -> [return: bb27, unwind: bb14];\n // }\n-// bb25: {                              // bindings for arm 2 - first pattern\n+// bb26: {                              // bindings for arm 2 - first pattern\n //     StorageLive(_15);\n //     _15 = (_2.1: bool);\n //     StorageLive(_16);\n //     _16 = move (_2.2: std::string::String);\n-//     goto -> bb24;\n-// }\n-// bb26: {                              // bindings for arm 2 - second pattern\n-//     StorageLive(_15);\n-//     _15 = (_2.1: bool);\n-//     StorageLive(_16);\n-//     _16 = move (_2.2: std::string::String);\n-//     goto -> bb24;\n+//     goto -> bb25;\n // }\n+\n // bb27: {                              // rest of arm 2\n //     StorageDead(_16);\n //     StorageDead(_15);\n //     goto -> bb28;\n // }\n // bb28: {\n-//     drop(_2) -> [return: bb12, unwind: bb1];\n+//     drop(_2) -> [return: bb13, unwind: bb1];\n // }\n // END rustc.complicated_match.SimplifyCfg-initial.after.mir\n // START rustc.complicated_match.ElaborateDrops.after.mir"}, {"sha": "237828d9020dbd25efef8d5317e7238e4a3577b5", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -4,7 +4,7 @@ fn guard() -> bool {\n     false\n }\n \n-fn guard2(_:i32) -> bool {\n+fn guard2(_: i32) -> bool {\n     true\n }\n \n@@ -45,20 +45,20 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb5];\n+//      switchInt(move _3) -> [0isize: bb2, 1isize: bb3, otherwise: bb5];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n-//  bb2: {\n-//      falseEdges -> [real: bb6, imaginary: bb3]; //pre_binding1\n+//  bb2: {  // pre_binding3 and arm3\n+//      _1 = (const 3i32, const 3i32);\n+//      goto -> bb11;\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb10, imaginary: bb4]; //pre_binding2\n+//      falseEdges -> [real: bb6, imaginary: bb4]; //pre_binding1\n //  }\n-//  bb4: { //pre_binding3 and arm3\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb11;\n+//  bb4: {\n+//      falseEdges -> [real: bb10, imaginary: bb2]; //pre_binding2\n //  }\n //  bb5: {\n //      unreachable;\n@@ -91,7 +91,7 @@ fn main() {\n //  bb9: { // to pre_binding2\n //      StorageDead(_7);\n //      StorageDead(_6);\n-//      goto -> bb3;\n+//      goto -> bb4;\n //  }\n //  bb10: { // arm2\n //      StorageLive(_9);\n@@ -103,7 +103,7 @@ fn main() {\n //      StorageDead(_9);\n //      goto -> bb11;\n //  }\n-//  bb11: { // arm3\n+//  bb11: {\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();\n@@ -117,31 +117,41 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb4];\n+//      switchInt(move _3) -> [0isize: bb2, 1isize: bb3, otherwise: bb5];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n-//  bb2: {\n-//      falseEdges -> [real: bb5, imaginary: bb3];\n+//  bb2: { // pre_binding2\n+//      falseEdges -> [real: bb10, imaginary: bb4];\n //  }\n-//  bb3: {\n-//      falseEdges -> [real: bb9, imaginary: bb10];\n+//  bb3: { // pre_binding1\n+//      falseEdges -> [real: bb6, imaginary: bb2];\n //  }\n-//  bb4: { // to arm3 (can skip 2 since this is `Some`)\n+//  bb4: { // binding3 and arm3\n+//      StorageLive(_9);\n+//      _9 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _9;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n+//      StorageDead(_9);\n+//      goto -> bb11;\n+//  }\n+//  bb5: {\n //      unreachable;\n //  }\n-//  bb5: { // binding1 and guard\n+//  bb6: {\n //      StorageLive(_6);\n //      _6 = &((_2 as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb6, unwind: bb1];\n+//      _7 = const guard() -> [return: bb7, unwind: bb1];\n //  }\n-//  bb6: { // end of guard\n-//      switchInt(move _7) -> [false: bb8, otherwise: bb7];\n+//  bb7: { // end of guard\n+//      switchInt(move _7) -> [false: bb9, otherwise: bb8];\n //  }\n-//  bb7: {\n+//  bb8: {\n //      StorageDead(_7);\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n@@ -155,25 +165,15 @@ fn main() {\n //      StorageDead(_6);\n //      goto -> bb11;\n //  }\n-//  bb8: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//  bb9: { // to pre_binding3 (can skip 2 since this is `Some`)\n //      StorageDead(_7);\n //      StorageDead(_6);\n-//      falseEdges -> [real: bb10, imaginary: bb3];\n+//      falseEdges -> [real: bb4, imaginary: bb2];\n //  }\n-//  bb9: { // arm2\n+//  bb10: { // arm2\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb11;\n //  }\n-//  bb10: { // binding3 and arm3\n-//      StorageLive(_9);\n-//      _9 = ((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = _9;\n-//      _1 = (const 2i32, move _10);\n-//      StorageDead(_10);\n-//      StorageDead(_9);\n-//      goto -> bb11;\n-//  }\n //  bb11: {\n //      StorageDead(_2);\n //      StorageDead(_1);\n@@ -188,31 +188,38 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _4 = discriminant(_2);\n-//      switchInt(move _4) -> [1isize: bb2, otherwise: bb3];\n+//      switchInt(move _4) -> [1isize: bb3, otherwise: bb2];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb5, imaginary: bb3];\n+//      falseEdges -> [real: bb10, imaginary: bb5];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb9, imaginary: bb4];\n+//      falseEdges -> [real: bb6, imaginary: bb2];\n //  }\n //  bb4: {\n-//      falseEdges -> [real: bb10, imaginary: bb14];\n+//      StorageLive(_14);\n+//      _14 = _2;\n+//      _1 = const 4i32;\n+//      StorageDead(_14);\n+//      goto -> bb15;\n //  }\n //  bb5: {\n+//      falseEdges -> [real: bb11, imaginary: bb4];\n+//  }\n+//  bb6: { //end of guard1\n //      StorageLive(_7);\n //      _7 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb6, unwind: bb1];\n-//  }\n-//  bb6: { //end of guard1\n-//      switchInt(move _8) -> [false: bb8, otherwise: bb7];\n+//      _8 = const guard() -> [return: bb7, unwind: bb1];\n //  }\n //  bb7: {\n+//      switchInt(move _8) -> [false: bb9, otherwise: bb8];\n+//  }\n+//  bb8: {\n //      StorageDead(_8);\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _7);\n@@ -223,32 +230,32 @@ fn main() {\n //      StorageDead(_7);\n //      goto -> bb15;\n //  }\n-//  bb8: {\n+//  bb9: {\n //      StorageDead(_8);\n //      StorageDead(_7);\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n+//      falseEdges -> [real: bb2, imaginary: bb2];\n //  }\n-//  bb9: { // binding2 & arm2\n+//  bb10: {  // binding2 & arm2\n //      StorageLive(_9);\n //      _9 = _2;\n //      _1 = const 2i32;\n //      StorageDead(_9);\n //      goto -> bb15;\n //  }\n-//  bb10: { // binding3: Some(y) if guard2(y)\n+//  bb11: { // binding3: Some(y) if guard2(y)\n //      StorageLive(_11);\n //      _11 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_12);\n //      StorageLive(_13);\n //      _13 = (*_11);\n-//      _12 = const guard2(move _13) -> [return: bb11, unwind: bb1];\n+//      _12 = const guard2(move _13) -> [return: bb12, unwind: bb1];\n //  }\n-//  bb11: { // end of guard2\n+//  bb12: { // end of guard2\n //      StorageDead(_13);\n-//      switchInt(move _12) -> [false: bb13, otherwise: bb12];\n+//      switchInt(move _12) -> [false: bb14, otherwise: bb13];\n //  }\n-//  bb12: { // binding4 & arm4\n+//  bb13: { // binding4 & arm4\n //      StorageDead(_12);\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _11);\n@@ -259,17 +266,10 @@ fn main() {\n //      StorageDead(_11);\n //      goto -> bb15;\n //  }\n-//  bb13: {\n+//  bb14: {\n //      StorageDead(_12);\n //      StorageDead(_11);\n-//      falseEdges -> [real: bb14, imaginary: bb14];\n-//  }\n-//  bb14: {\n-//      StorageLive(_14);\n-//      _14 = _2;\n-//      _1 = const 4i32;\n-//      StorageDead(_14);\n-//      goto -> bb15;\n+//      falseEdges -> [real: bb4, imaginary: bb4];\n //  }\n //  bb15: {\n //      StorageDead(_2);"}, {"sha": "5ee3e1447d832d2ee62c08345fb4537a0fe20d75", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -20,35 +20,35 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        switchInt(move _6) -> [false: bb6, otherwise: bb5];\n+//        switchInt(move _6) -> [false: bb4, otherwise: bb1];\n //    }\n //    bb1: {\n-//        falseEdges -> [real: bb9, imaginary: bb2];\n+//        _7 = Lt(_1, const 10i32);\n+//        switchInt(move _7) -> [false: bb4, otherwise: bb2];\n //    }\n //    bb2: {\n-//        falseEdges -> [real: bb12, imaginary: bb3];\n+//        falseEdges -> [real: bb9, imaginary: bb6];\n //    }\n //    bb3: {\n-//        falseEdges -> [real: bb13, imaginary: bb4];\n-//    }\n-//    bb4: {\n //        _3 = const 3i32;\n //        goto -> bb14;\n //    }\n+//    bb4: {\n+//        _4 = Le(const 10i32, _1);\n+//        switchInt(move _4) -> [false: bb7, otherwise: bb5];\n+//    }\n //    bb5: {\n-//        _7 = Lt(_1, const 10i32);\n-//        switchInt(move _7) -> [false: bb6, otherwise: bb1];\n+//        _5 = Le(_1, const 20i32);\n+//        switchInt(move _5) -> [false: bb7, otherwise: bb6];\n //    }\n //    bb6: {\n-//        _4 = Le(const 10i32, _1);\n-//        switchInt(move _4) -> [false: bb8, otherwise: bb7];\n+//        falseEdges -> [real: bb12, imaginary: bb8];\n //    }\n //    bb7: {\n-//        _5 = Le(_1, const 20i32);\n-//        switchInt(move _5) -> [false: bb8, otherwise: bb2];\n+//        switchInt(_1) -> [-1i32: bb8, otherwise: bb3];\n //    }\n //    bb8: {\n-//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n+//        falseEdges -> [real: bb13, imaginary: bb3];\n //    }\n //    bb9: {\n //        _8 = &shallow _1;\n@@ -64,7 +64,7 @@ fn main() {\n //    }\n //    bb11: {\n //        StorageDead(_9);\n-//        falseEdges -> [real: bb4, imaginary: bb2];\n+//        falseEdges -> [real: bb3, imaginary: bb6];\n //    }\n //    bb12: {\n //        _3 = const 1i32;"}, {"sha": "294fe247c38be3de5d909f32a8c4f88a0c609252", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -19,17 +19,17 @@ fn main() {\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb3, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb2, otherwise: bb1];\n // }\n // bb1: {\n-//     goto -> bb4;\n-// }\n-// bb2: {\n //     _0 = const 1i32;\n //     goto -> bb7;\n // }\n+// bb2: {\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb1];\n+// }\n // bb3: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n+//     goto -> bb4;\n // }\n // bb4: {\n //     _4 = &shallow _1;\n@@ -51,7 +51,7 @@ fn main() {\n // }\n // bb6: {\n //     StorageDead(_8);\n-//     goto -> bb2;\n+//     goto -> bb1;\n // }\n // bb7: {\n //     return;\n@@ -65,17 +65,17 @@ fn main() {\n // bb0: {\n //     nop;\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb3, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb2, otherwise: bb1];\n // }\n // bb1: {\n-//     goto -> bb4;\n-// }\n-// bb2: {\n //     _0 = const 1i32;\n //     goto -> bb7;\n // }\n+// bb2: {\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb1];\n+// }\n // bb3: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n+//     goto -> bb4;\n // }\n // bb4: {\n //     nop;\n@@ -97,7 +97,7 @@ fn main() {\n // }\n // bb6: {\n //     StorageDead(_8);\n-//     goto -> bb2;\n+//     goto -> bb1;\n // }\n // bb7: {\n //     return;"}, {"sha": "abac66d95c5484b466d8635a887f5ebf13e99b0e", "filename": "src/test/mir-opt/simplify_try.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -47,22 +47,22 @@ fn main() {\n //     }\n //     bb0: {\n //         _5 = discriminant(_1);\n-//         switchInt(move _5) -> [0isize: bb3, otherwise: bb1];\n+//         switchInt(move _5) -> [0isize: bb1, otherwise: bb2];\n //     }\n //     bb1: {\n+//         _10 = ((_1 as Ok).0: u32);\n+//         ((_0 as Ok).0: u32) = move _10;\n+//         discriminant(_0) = 0;\n+//         goto -> bb3;\n+//     }\n+//     bb2: {\n //         _6 = ((_1 as Err).0: i32);\n //         ((_0 as Err).0: i32) = move _6;\n //         discriminant(_0) = 1;\n-//         goto -> bb2;\n-//     }\n-//     bb2: {\n-//         return;\n+//         goto -> bb3;\n //     }\n //     bb3: {\n-//         _10 = ((_1 as Ok).0: u32);\n-//         ((_0 as Ok).0: u32) = move _10;\n-//         discriminant(_0) = 0;\n-//         goto -> bb2;\n+//         return;\n //     }\n // }\n // END rustc.try_identity.SimplifyArmIdentity.before.mir\n@@ -106,22 +106,22 @@ fn main() {\n //     }\n //     bb0: {\n //         _5 = discriminant(_1);\n-//         switchInt(move _5) -> [0isize: bb3, otherwise: bb1];\n+//         switchInt(move _5) -> [0isize: bb1, otherwise: bb2];\n //     }\n //     bb1: {\n //         _0 = move _1;\n //         nop;\n //         nop;\n-//         goto -> bb2;\n+//         goto -> bb3;\n //     }\n //     bb2: {\n-//         return;\n-//     }\n-//     bb3: {\n //         _0 = move _1;\n //         nop;\n //         nop;\n-//         goto -> bb2;\n+//         goto -> bb3;\n+//     }\n+//     bb3: {\n+//         return;\n //     }\n // }\n // END rustc.try_identity.SimplifyArmIdentity.after.mir\n@@ -165,16 +165,16 @@ fn main() {\n //     }\n //     bb0: {\n //         _5 = discriminant(_1);\n-//         goto -> bb2;\n+//         goto -> bb1;\n //     }\n //     bb1: {\n-//         return;\n-//     }\n-//     bb2: {\n //         _0 = move _1;\n //         nop;\n //         nop;\n-//         goto -> bb1;\n+//         goto -> bb2;\n+//     }\n+//     bb2: {\n+//         return;\n //     }\n // }\n // END rustc.try_identity.SimplifyBranchSame.after.mir"}, {"sha": "5b31e2d76a05b8c11e771b882a71cc9a880c4c0e", "filename": "src/test/ui/borrowck/or-patterns.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fborrowck%2For-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fborrowck%2For-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2For-patterns.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,64 @@\n+// Test that borrow check considers all choices in an or pattern, even the\n+// unreachable ones.\n+\n+#![feature(or_patterns)]\n+\n+fn or_pattern_moves_all(x: ((String, String),)) {\n+    match x {\n+        ((y, _) | (_, y),) => (),\n+    }\n+    &x.0 .0;\n+    //~^ ERROR borrow of moved value\n+    &x.0 .1;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn or_pattern_borrows_all(mut x: ((String, String),)) {\n+    let r = match x {\n+        ((ref y, _) | (_, ref y),) => y,\n+    };\n+    &mut x.0 .0;\n+    //~^ ERROR cannot borrow\n+    &mut x.0 .1;\n+    //~^ ERROR cannot borrow\n+    drop(r);\n+}\n+\n+fn or_pattern_borrows_all_mut(mut x: ((String, String),)) {\n+    let r = match x {\n+        ((ref mut y, _) | (_, ref mut y),) => y,\n+    };\n+    &x.0 .0;\n+    //~^ ERROR cannot borrow\n+    &x.0 .1;\n+    //~^ ERROR cannot borrow\n+    drop(r);\n+}\n+\n+fn let_or_pattern_moves_all(x: ((String, String),)) {\n+    let ((y, _) | (_, y),) = x;\n+    &x.0 .0;\n+    //~^ ERROR borrow of moved value\n+    &x.0 .1;\n+    //~^ ERROR borrow of moved value\n+}\n+\n+fn let_or_pattern_borrows_all(mut x: ((String, String),)) {\n+    let ((ref r, _) | (_, ref r),) = x;\n+    &mut x.0 .0;\n+    //~^ ERROR cannot borrow\n+    &mut x.0 .1;\n+    //~^ ERROR cannot borrow\n+    drop(r);\n+}\n+\n+fn let_or_pattern_borrows_all_mut(mut x: ((String, String),)) {\n+    let ((ref mut r, _) | (_, ref mut r),) = x;\n+    &x.0 .0;\n+    //~^ ERROR cannot borrow\n+    &x.0 .1;\n+    //~^ ERROR cannot borrow\n+    drop(r);\n+}\n+\n+fn main() {}"}, {"sha": "d3f3544426aade1192c47f064079a28d1533420f", "filename": "src/test/ui/borrowck/or-patterns.stderr", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fborrowck%2For-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fborrowck%2For-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2For-patterns.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,141 @@\n+error[E0382]: borrow of moved value: `x.0.0`\n+  --> $DIR/or-patterns.rs:10:5\n+   |\n+LL |         ((y, _) | (_, y),) => (),\n+   |           - value moved here\n+LL |     }\n+LL |     &x.0 .0;\n+   |     ^^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `x.0.0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `x.0.1`\n+  --> $DIR/or-patterns.rs:12:5\n+   |\n+LL |         ((y, _) | (_, y),) => (),\n+   |                       - value moved here\n+...\n+LL |     &x.0 .1;\n+   |     ^^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `x.0.1` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0502]: cannot borrow `x.0.0` as mutable because it is also borrowed as immutable\n+  --> $DIR/or-patterns.rs:20:5\n+   |\n+LL |         ((ref y, _) | (_, ref y),) => y,\n+   |           ----- immutable borrow occurs here\n+LL |     };\n+LL |     &mut x.0 .0;\n+   |     ^^^^^^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x.0.1` as mutable because it is also borrowed as immutable\n+  --> $DIR/or-patterns.rs:22:5\n+   |\n+LL |         ((ref y, _) | (_, ref y),) => y,\n+   |                           ----- immutable borrow occurs here\n+...\n+LL |     &mut x.0 .1;\n+   |     ^^^^^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x.0.0` as immutable because it is also borrowed as mutable\n+  --> $DIR/or-patterns.rs:31:5\n+   |\n+LL |         ((ref mut y, _) | (_, ref mut y),) => y,\n+   |           --------- mutable borrow occurs here\n+LL |     };\n+LL |     &x.0 .0;\n+   |     ^^^^^^^ immutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error[E0502]: cannot borrow `x.0.1` as immutable because it is also borrowed as mutable\n+  --> $DIR/or-patterns.rs:33:5\n+   |\n+LL |         ((ref mut y, _) | (_, ref mut y),) => y,\n+   |                               --------- mutable borrow occurs here\n+...\n+LL |     &x.0 .1;\n+   |     ^^^^^^^ immutable borrow occurs here\n+LL |\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error[E0382]: borrow of moved value: `x.0.0`\n+  --> $DIR/or-patterns.rs:40:5\n+   |\n+LL |     let ((y, _) | (_, y),) = x;\n+   |           - value moved here\n+LL |     &x.0 .0;\n+   |     ^^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `x.0.0` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `x.0.1`\n+  --> $DIR/or-patterns.rs:42:5\n+   |\n+LL |     let ((y, _) | (_, y),) = x;\n+   |                       - value moved here\n+...\n+LL |     &x.0 .1;\n+   |     ^^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `x.0.1` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0502]: cannot borrow `x.0.0` as mutable because it is also borrowed as immutable\n+  --> $DIR/or-patterns.rs:48:5\n+   |\n+LL |     let ((ref r, _) | (_, ref r),) = x;\n+   |           ----- immutable borrow occurs here\n+LL |     &mut x.0 .0;\n+   |     ^^^^^^^^^^^ mutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x.0.1` as mutable because it is also borrowed as immutable\n+  --> $DIR/or-patterns.rs:50:5\n+   |\n+LL |     let ((ref r, _) | (_, ref r),) = x;\n+   |                           ----- immutable borrow occurs here\n+...\n+LL |     &mut x.0 .1;\n+   |     ^^^^^^^^^^^ mutable borrow occurs here\n+LL |\n+LL |     drop(r);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `x.0.0` as immutable because it is also borrowed as mutable\n+  --> $DIR/or-patterns.rs:57:5\n+   |\n+LL |     let ((ref mut r, _) | (_, ref mut r),) = x;\n+   |           --------- mutable borrow occurs here\n+LL |     &x.0 .0;\n+   |     ^^^^^^^ immutable borrow occurs here\n+...\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error[E0502]: cannot borrow `x.0.1` as immutable because it is also borrowed as mutable\n+  --> $DIR/or-patterns.rs:59:5\n+   |\n+LL |     let ((ref mut r, _) | (_, ref mut r),) = x;\n+   |                               --------- mutable borrow occurs here\n+...\n+LL |     &x.0 .1;\n+   |     ^^^^^^^ immutable borrow occurs here\n+LL |\n+LL |     drop(r);\n+   |          - mutable borrow later used here\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors have detailed explanations: E0382, E0502.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "e49d47673912a29c8f678d936ecfb5f85f78ae26", "filename": "src/test/ui/consts/const_let_refutable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,7 +1,7 @@\n fn main() {}\n \n-const fn slice([a, b]: &[i32]) -> i32 { //~ ERROR refutable pattern in function argument\n-    a + b //~ ERROR can only call other `const fn` within a `const fn`\n-    //~^ ERROR use of possibly-uninitialized variable: `a`\n-    //~| ERROR use of possibly-uninitialized variable: `b`\n+const fn slice(&[a, b]: &[i32]) -> i32 {\n+    //~^ ERROR refutable pattern in function argument\n+    //~| ERROR loops and conditional expressions are not stable in const fn\n+    a + b\n }"}, {"sha": "719e14005ffa424d303c699e7bc871f0ec161a1a", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,31 +1,19 @@\n error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n-LL | const fn slice([a, b]: &[i32]) -> i32 {\n-   |                ^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n+LL | const fn slice(&[a, b]: &[i32]) -> i32 {\n+   |                ^^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n \n-error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n-  --> $DIR/const_let_refutable.rs:4:5\n+error[E0723]: loops and conditional expressions are not stable in const fn\n+  --> $DIR/const_let_refutable.rs:3:17\n    |\n-LL |     a + b\n-   |     ^^^^^\n+LL | const fn slice(&[a, b]: &[i32]) -> i32 {\n+   |                 ^^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0381]: use of possibly-uninitialized variable: `a`\n-  --> $DIR/const_let_refutable.rs:4:5\n-   |\n-LL |     a + b\n-   |     ^ use of possibly-uninitialized `a`\n-\n-error[E0381]: use of possibly-uninitialized variable: `b`\n-  --> $DIR/const_let_refutable.rs:4:9\n-   |\n-LL |     a + b\n-   |         ^ use of possibly-uninitialized `b`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0005, E0381, E0723.\n+Some errors have detailed explanations: E0005, E0723.\n For more information about an error, try `rustc --explain E0005`."}, {"sha": "01b99134a445f37ad72ceb92f3b0a3d0eab28814", "filename": "src/test/ui/empty/empty-never-array.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -10,7 +10,6 @@ fn transmute<T, U>(t: T) -> U {\n     let Helper::U(u) = Helper::T(t, []);\n     //~^ ERROR refutable pattern in local binding: `T(_, _)` not covered\n     u\n-    //~^ ERROR use of possibly-uninitialized variable: `u`\n }\n \n fn main() {"}, {"sha": "a4ffceea4c97fc1a6c358a0e4a2e64741d18d895", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -19,13 +19,6 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL |     if let Helper::U(u) = Helper::T(t, []) { /* */ }\n    |\n \n-error[E0381]: use of possibly-uninitialized variable: `u`\n-  --> $DIR/empty-never-array.rs:12:5\n-   |\n-LL |     u\n-   |     ^ use of possibly-uninitialized `u`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0005, E0381.\n-For more information about an error, try `rustc --explain E0005`.\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "3ce659ccd14da3ec29b531edb83eac3fb776910e", "filename": "src/test/ui/issues/issue-12567.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fissues%2Fissue-12567.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fissues%2Fissue-12567.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12567.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -8,7 +8,7 @@ LL |         (&[], &[hd, ..]) | (&[hd, ..], &[])\n    |                 -- data moved here\n LL |             => println!(\"one empty\"),\n LL |         (&[hd1, ..], &[hd2, ..])\n-   |                        --- ...and here\n+   |            --- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n \n@@ -22,7 +22,7 @@ LL |         (&[], &[hd, ..]) | (&[hd, ..], &[])\n    |                 -- data moved here\n LL |             => println!(\"one empty\"),\n LL |         (&[hd1, ..], &[hd2, ..])\n-   |            --- ...and here\n+   |                        --- ...and here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n "}, {"sha": "392fb1b24ddc4b30533439d83a8ab6475c332313", "filename": "src/test/ui/issues/issue-15381.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -4,6 +4,5 @@ fn main() {\n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n         //~^ ERROR refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not\n         println!(\"y={}\", y);\n-        //~^ ERROR borrow of possibly-uninitialized variable: `y`\n     }\n }"}, {"sha": "35f46ab57279cb5c035838001ac9f8bb1d7b11b8", "filename": "src/test/ui/issues/issue-15381.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -4,13 +4,6 @@ error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]`\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n    |         ^^^^^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n \n-error[E0381]: borrow of possibly-uninitialized variable: `y`\n-  --> $DIR/issue-15381.rs:6:26\n-   |\n-LL |         println!(\"y={}\", y);\n-   |                          ^ use of possibly-uninitialized `y`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0005, E0381.\n-For more information about an error, try `rustc --explain E0005`.\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "f3d2d1bb58d8f67984d3096f1c6b8bc7b4385536", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,7 +1,6 @@\n #![feature(box_patterns, stmt_expr_attributes)]\n \n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete\n \n #![allow(ellipsis_inclusive_range_patterns)]\n #![allow(unreachable_patterns)]"}, {"sha": "b31ad95b191c986c1e1711764113b4a97a062587", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.stderr", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,157 +1,149 @@\n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/issue-54538-unused-parens-lint.rs:3:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:12:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:11:9\n    |\n LL |     let (a) = 0;\n    |         ^^^ help: remove these parentheses\n    |\n note: the lint level is defined here\n-  --> $DIR/issue-54538-unused-parens-lint.rs:9:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:8:9\n    |\n LL | #![deny(unused_parens)]\n    |         ^^^^^^^^^^^^^\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:13:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:12:9\n    |\n LL |     for (a) in 0..1 {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:14:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:13:12\n    |\n LL |     if let (a) = 0 {}\n    |            ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:15:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:14:15\n    |\n LL |     while let (a) = 0 {}\n    |               ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:16:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:15:12\n    |\n LL |     fn foo((a): u8) {}\n    |            ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:17:14\n+  --> $DIR/issue-54538-unused-parens-lint.rs:16:14\n    |\n LL |     let _ = |(a): u8| 0;\n    |              ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:45:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:44:12\n    |\n LL |     if let (0 | 1) = 0 {}\n    |            ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:46:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:45:13\n    |\n LL |     if let ((0 | 1),) = (0,) {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:47:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:46:13\n    |\n LL |     if let [(0 | 1)] = [0] {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:48:16\n+  --> $DIR/issue-54538-unused-parens-lint.rs:47:16\n    |\n LL |     if let 0 | (1 | 2) = 0 {}\n    |                ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:50:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:49:15\n    |\n LL |     if let TS((0 | 1)) = TS(0) {}\n    |               ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:52:20\n+  --> $DIR/issue-54538-unused-parens-lint.rs:51:20\n    |\n LL |     if let NS { f: (0 | 1) } = (NS { f: 0 }) {}\n    |                    ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:62:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:61:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:63:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:62:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:64:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:63:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:65:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:64:9\n    |\n LL |         (e @ 1...2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:71:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:70:9\n    |\n LL |         (e @ &(1...2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:72:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:71:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:83:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:84:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:83:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:85:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:84:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:86:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:85:9\n    |\n LL |         (e @ 1..=2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:92:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:91:9\n    |\n LL |         (e @ &(1..=2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:93:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:92:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses"}, {"sha": "726e17b7ec226f310b50afda782baf8b4fad1d08", "filename": "src/test/ui/or-patterns/already-bound-name.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -2,7 +2,6 @@\n // correctly accounts for or-patterns.\n \n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete\n \n enum E<T> { A(T, T), B(T) }\n "}, {"sha": "9924b0d7f72eb806ed447413ba4d3ea217eb0430", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,97 +1,89 @@\n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:12:13\n+  --> $DIR/already-bound-name.rs:11:13\n    |\n LL |     let (a, a) = (0, 1); // Standard duplication without an or-pattern.\n    |             ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:15:15\n+  --> $DIR/already-bound-name.rs:14:15\n    |\n LL |     let (a, A(a, _) | B(a)) = (0, A(1, 2));\n    |               ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:15:25\n+  --> $DIR/already-bound-name.rs:14:25\n    |\n LL |     let (a, A(a, _) | B(a)) = (0, A(1, 2));\n    |                         ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:19:26\n+  --> $DIR/already-bound-name.rs:18:26\n    |\n LL |     let (A(a, _) | B(a), a) = (A(0, 1), 2);\n    |                          ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:22:14\n+  --> $DIR/already-bound-name.rs:21:14\n    |\n LL |     let A(a, a) | B(a) = A(0, 1);\n    |              ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:25:21\n+  --> $DIR/already-bound-name.rs:24:21\n    |\n LL |     let B(a) | A(a, a) = A(0, 1);\n    |                     ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:29:21\n+  --> $DIR/already-bound-name.rs:28:21\n    |\n LL |         B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n    |                     ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:33:36\n+  --> $DIR/already-bound-name.rs:32:36\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n    |                                    ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:33:46\n+  --> $DIR/already-bound-name.rs:32:46\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n    |                                              ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:38:36\n+  --> $DIR/already-bound-name.rs:37:36\n    |\n LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                    ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:38:46\n+  --> $DIR/already-bound-name.rs:37:46\n    |\n LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                              ^ used in a pattern more than once\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/already-bound-name.rs:38:9\n+  --> $DIR/already-bound-name.rs:37:9\n    |\n LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |         ^^^^ pattern doesn't bind `a`        - variable not in all patterns\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:43:49\n+  --> $DIR/already-bound-name.rs:42:49\n    |\n LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                                 ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:43:59\n+  --> $DIR/already-bound-name.rs:42:59\n    |\n LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                                           ^ used in a pattern more than once\n \n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/already-bound-name.rs:4:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error[E0308]: mismatched types\n-  --> $DIR/already-bound-name.rs:33:31\n+  --> $DIR/already-bound-name.rs:32:31\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n    |                               ^                    ------- this expression has type `E<E<{integer}>>`"}, {"sha": "6daa9d9255b804a06e82be630a1e997bce771089", "filename": "src/test/ui/or-patterns/basic-switch.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbasic-switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbasic-switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fbasic-switch.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,33 @@\n+// Test basic or-patterns when the target pattern type will be lowered to a\n+// `Switch` (an `enum`).\n+\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+#[derive(Debug)]\n+enum Test {\n+    Foo,\n+    Bar,\n+    Baz,\n+    Qux,\n+}\n+\n+fn test(x: Option<Test>) -> bool {\n+    match x {\n+        // most simple case\n+        Some(Test::Bar | Test::Qux) => true,\n+        // wild case\n+        Some(_) => false,\n+        // empty case\n+        None => false,\n+    }\n+}\n+\n+fn main() {\n+    assert!(!test(Some(Test::Foo)));\n+    assert!(test(Some(Test::Bar)));\n+    assert!(!test(Some(Test::Baz)));\n+    assert!(test(Some(Test::Qux)));\n+    assert!(!test(None))\n+}"}, {"sha": "c5a6d894eacecd5033a18279940174b00ed6cd76", "filename": "src/test/ui/or-patterns/basic-switchint.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbasic-switchint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbasic-switchint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fbasic-switchint.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,54 @@\n+// Test basic or-patterns when the target pattern type will be lowered to\n+// a `SwitchInt`. This will happen when the target type is an integer.\n+\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+#[derive(Debug, PartialEq)]\n+enum MatchArm {\n+    Arm(usize),\n+    Wild,\n+}\n+\n+#[derive(Debug)]\n+enum Foo {\n+    One(usize),\n+    Two(usize, usize),\n+}\n+\n+fn test_foo(x: Foo) -> MatchArm {\n+    match x {\n+        // normal pattern.\n+        Foo::One(0) | Foo::One(1) | Foo::One(2) => MatchArm::Arm(0),\n+        // most simple or-pattern.\n+        Foo::One(42 | 255) => MatchArm::Arm(1),\n+        // multiple or-patterns for one structure.\n+        Foo::Two(42 | 255, 1024 | 2048) => MatchArm::Arm(2),\n+        // mix of pattern types in one or-pattern (range).\n+        Foo::One(100 | 110..=120 | 210..=220) => MatchArm::Arm(3),\n+        // multiple or-patterns with wild.\n+        Foo::Two(0..=10 | 100..=110, 0 | _) => MatchArm::Arm(4),\n+        // wild\n+        _ => MatchArm::Wild,\n+    }\n+}\n+\n+fn main() {\n+    // `Foo` tests.\n+    assert_eq!(test_foo(Foo::One(0)), MatchArm::Arm(0));\n+    assert_eq!(test_foo(Foo::One(42)), MatchArm::Arm(1));\n+    assert_eq!(test_foo(Foo::One(43)), MatchArm::Wild);\n+    assert_eq!(test_foo(Foo::One(255)), MatchArm::Arm(1));\n+    assert_eq!(test_foo(Foo::One(256)), MatchArm::Wild);\n+    assert_eq!(test_foo(Foo::Two(42, 1023)), MatchArm::Wild);\n+    assert_eq!(test_foo(Foo::Two(255, 2048)), MatchArm::Arm(2));\n+    assert_eq!(test_foo(Foo::One(100)), MatchArm::Arm(3));\n+    assert_eq!(test_foo(Foo::One(115)), MatchArm::Arm(3));\n+    assert_eq!(test_foo(Foo::One(105)), MatchArm::Wild);\n+    assert_eq!(test_foo(Foo::One(215)), MatchArm::Arm(3));\n+    assert_eq!(test_foo(Foo::One(121)), MatchArm::Wild);\n+    assert_eq!(test_foo(Foo::Two(0, 42)), MatchArm::Arm(4));\n+    assert_eq!(test_foo(Foo::Two(100, 0)), MatchArm::Arm(4));\n+    assert_eq!(test_foo(Foo::Two(42, 0)), MatchArm::Wild);\n+}"}, {"sha": "0087167af7eccd1ed0ddf8370b7dd327de96a710", "filename": "src/test/ui/or-patterns/bindings-runpass-1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbindings-runpass-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbindings-runpass-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fbindings-runpass-1.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+fn two_bindings(x: &((bool, bool), u8)) -> u8 {\n+    match x {\n+        &((true, y) | (y, true), z @ (0 | 4)) => (y as u8) + z,\n+        _ => 20,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(two_bindings(&((false, false), 0)), 20);\n+    assert_eq!(two_bindings(&((false, true), 0)), 0);\n+    assert_eq!(two_bindings(&((true, false), 0)), 0);\n+    assert_eq!(two_bindings(&((true, true), 0)), 1);\n+    assert_eq!(two_bindings(&((false, false), 4)), 20);\n+    assert_eq!(two_bindings(&((false, true), 4)), 4);\n+    assert_eq!(two_bindings(&((true, false), 4)), 4);\n+    assert_eq!(two_bindings(&((true, true), 4)), 5);\n+    assert_eq!(two_bindings(&((false, false), 3)), 20);\n+    assert_eq!(two_bindings(&((false, true), 3)), 20);\n+    assert_eq!(two_bindings(&((true, false), 3)), 20);\n+    assert_eq!(two_bindings(&((true, true), 3)), 20);\n+}"}, {"sha": "0e1eb7b2e030bd9022e27aa6b5721ed719d14a94", "filename": "src/test/ui/or-patterns/bindings-runpass-2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbindings-runpass-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fbindings-runpass-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fbindings-runpass-2.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,32 @@\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+fn or_at(x: Result<u32, u32>) -> u32 {\n+    match x {\n+        Ok(x @ 4) | Err(x @ (6 | 8)) => x,\n+        Ok(x @ 1 | x @ 2) => x,\n+        Err(x @ (0..=10 | 30..=40)) if x % 2 == 0 => x + 100,\n+        Err(x @ 0..=40) => x + 200,\n+        _ => 500,\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(or_at(Ok(1)), 1);\n+    assert_eq!(or_at(Ok(2)), 2);\n+    assert_eq!(or_at(Ok(3)), 500);\n+    assert_eq!(or_at(Ok(4)), 4);\n+    assert_eq!(or_at(Ok(5)), 500);\n+    assert_eq!(or_at(Ok(6)), 500);\n+    assert_eq!(or_at(Err(1)), 201);\n+    assert_eq!(or_at(Err(2)), 102);\n+    assert_eq!(or_at(Err(3)), 203);\n+    assert_eq!(or_at(Err(4)), 104);\n+    assert_eq!(or_at(Err(5)), 205);\n+    assert_eq!(or_at(Err(6)), 6);\n+    assert_eq!(or_at(Err(7)), 207);\n+    assert_eq!(or_at(Err(8)), 8);\n+    assert_eq!(or_at(Err(20)), 220);\n+    assert_eq!(or_at(Err(50)), 500);\n+}"}, {"sha": "3ee57978bb009fd01680d859f6edae99d2e356c7", "filename": "src/test/ui/or-patterns/consistent-bindings.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -2,8 +2,9 @@\n \n // edition:2018\n \n+// check-pass\n+\n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete\n \n fn main() {\n     // One level:\n@@ -12,35 +13,29 @@ fn main() {\n     let Ok(ref mut a) | Err(ref mut a) = Ok(0);\n \n     // Two levels:\n-    enum Tri<S, T, U> { V1(S), V2(T), V3(U) }\n+    enum Tri<S, T, U> {\n+        V1(S),\n+        V2(T),\n+        V3(U),\n+    }\n     use Tri::*;\n \n-    let Ok((V1(a) | V2(a) | V3(a), b)) | Err(Ok((a, b)) | Err((a, b)))\n-        : Result<_, Result<_, _>>\n-        = Ok((V1(1), 1));\n+    let Ok((V1(a) | V2(a) | V3(a), b)) | Err(Ok((a, b)) | Err((a, b))): Result<_, Result<_, _>> =\n+        Ok((V1(1), 1));\n \n-    let Ok((V1(a) | V2(a) | V3(a), ref b)) | Err(Ok((a, ref b)) | Err((a, ref b)))\n-        : Result<_, Result<_, _>>\n-        = Ok((V1(1), 1));\n+    let Ok((V1(a) | V2(a) | V3(a), ref b)) | Err(Ok((a, ref b)) | Err((a, ref b))): Result<\n+        _,\n+        Result<_, _>,\n+    > = Ok((V1(1), 1));\n \n     // Three levels:\n     let (\n-            a,\n-            Err((ref mut b, ref c, d)) |\n-            Ok((\n-                Ok(\n-                    V1((ref c, d)) |\n-                    V2((d, ref c)) |\n-                    V3((ref c, Ok((_, d)) | Err((d, _))))\n-                ) |\n-                Err((ref c, d)),\n-                ref mut b\n-            ))\n-        ) =\n-        (1, Ok((Ok(V3((1, Ok((1, 1))))), 1)));\n-\n-    // FIXME(or_patterns; Centril | dlrobertson): remove this line below and\n-    // change this test to check-pass once MIR can handle or-patterns with bindings.\n-    let () = 0;\n-    //~^ ERROR mismatched types\n+        a,\n+        Err((ref mut b, ref c, d))\n+        | Ok((\n+            Ok(V1((ref c, d)) | V2((d, ref c)) | V3((ref c, Ok((_, d)) | Err((d, _)))))\n+            | Err((ref c, d)),\n+            ref mut b,\n+        )),\n+    ): (_, Result<_, _>) = (1, Ok((Ok(V3((1, Ok::<_, (i32, i32)>((1, 1))))), 1)));\n }"}, {"sha": "433a02dfb3139a1bbaa7be4f049ac8eb47e757cd", "filename": "src/test/ui/or-patterns/consistent-bindings.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8417d68de5e063426ab6bb7f383df6117d1beeed/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8417d68de5e063426ab6bb7f383df6117d1beeed/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr?ref=8417d68de5e063426ab6bb7f383df6117d1beeed", "patch": "@@ -1,17 +0,0 @@\n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/consistent-bindings.rs:5:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n-error[E0308]: mismatched types\n-  --> $DIR/consistent-bindings.rs:44:9\n-   |\n-LL |     let () = 0;\n-   |         ^^ expected integer, found `()`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c8bc4a2a8d51b189e922f3543b8616e5aa7d3302", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,23 +1,15 @@\n #![feature(or_patterns)]\n-\n-#![allow(incomplete_features)]\n #![deny(unreachable_patterns)]\n \n-// We wrap patterns in a tuple because top-level or-patterns are special-cased for now.\n+// We wrap patterns in a tuple because top-level or-patterns were special-cased.\n fn main() {\n-    // Get the fatal error out of the way\n-    match (0u8,) {\n-        (0 | _,) => {}\n-        //~^ ERROR or-patterns are not fully implemented yet\n-    }\n-\n     match (0u8, 0u8) {\n         //~^ ERROR non-exhaustive patterns: `(2u8..=std::u8::MAX, _)`\n         (0 | 1, 2 | 3) => {}\n     }\n     match ((0u8,),) {\n         //~^ ERROR non-exhaustive patterns: `((4u8..=std::u8::MAX))`\n-        ((0 | 1,) | (2 | 3,),) => {},\n+        ((0 | 1,) | (2 | 3,),) => {}\n     }\n     match (Some(0u8),) {\n         //~^ ERROR non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))`"}, {"sha": "3ba26de10d3d5a8ab1c5fde816d93d4e51ce37d3", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,33 +1,27 @@\n error[E0004]: non-exhaustive patterns: `(2u8..=std::u8::MAX, _)` not covered\n-  --> $DIR/exhaustiveness-non-exhaustive.rs:14:11\n+  --> $DIR/exhaustiveness-non-exhaustive.rs:6:11\n    |\n LL |     match (0u8, 0u8) {\n    |           ^^^^^^^^^^ pattern `(2u8..=std::u8::MAX, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `((4u8..=std::u8::MAX))` not covered\n-  --> $DIR/exhaustiveness-non-exhaustive.rs:18:11\n+  --> $DIR/exhaustiveness-non-exhaustive.rs:10:11\n    |\n LL |     match ((0u8,),) {\n    |           ^^^^^^^^^ pattern `((4u8..=std::u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))` not covered\n-  --> $DIR/exhaustiveness-non-exhaustive.rs:22:11\n+  --> $DIR/exhaustiveness-non-exhaustive.rs:14:11\n    |\n LL |     match (Some(0u8),) {\n    |           ^^^^^^^^^^^^ pattern `(Some(2u8..=std::u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: or-patterns are not fully implemented yet\n-  --> $DIR/exhaustiveness-non-exhaustive.rs:10:10\n-   |\n-LL |         (0 | _,) => {}\n-   |          ^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "8dcf8792f6f961eb0db3868921ce63c3162bac32", "filename": "src/test/ui/or-patterns/exhaustiveness-pass.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,16 +1,10 @@\n #![feature(or_patterns)]\n-\n-#![allow(incomplete_features)]\n #![deny(unreachable_patterns)]\n \n-// We wrap patterns in a tuple because top-level or-patterns are special-cased for now.\n-fn main() {\n-    // Get the fatal error out of the way\n-    match (0,) {\n-        (0 | _,) => {}\n-        //~^ ERROR or-patterns are not fully implemented yet\n-    }\n+// check-pass\n \n+// We wrap patterns in a tuple because top-level or-patterns were special-cased.\n+fn main() {\n     match (0,) {\n         (1 | 2,) => {}\n         _ => {}\n@@ -27,11 +21,11 @@ fn main() {\n         (Some(2..=255),) => {}\n     }\n     match ((0,),) {\n-        ((0 | 1,) | (2 | 3,),) => {},\n-        ((_,),) => {},\n+        ((0 | 1,) | (2 | 3,),) => {}\n+        ((_,),) => {}\n     }\n     match (&[0u8][..],) {\n-        ([] | [0 | 1..=255] | [_, ..],) => {},\n+        ([] | [0 | 1..=255] | [_, ..],) => {}\n     }\n \n     match ((0, 0),) {"}, {"sha": "1f4278c4b8098c2070287ff91ba86f1d05341659", "filename": "src/test/ui/or-patterns/exhaustiveness-pass.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8417d68de5e063426ab6bb7f383df6117d1beeed/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8417d68de5e063426ab6bb7f383df6117d1beeed/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.stderr?ref=8417d68de5e063426ab6bb7f383df6117d1beeed", "patch": "@@ -1,8 +0,0 @@\n-error: or-patterns are not fully implemented yet\n-  --> $DIR/exhaustiveness-pass.rs:10:10\n-   |\n-LL |         (0 | _,) => {}\n-   |          ^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "44bae282d8857070c65d45faf7fafd03669b8c9c", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,16 +1,8 @@\n #![feature(or_patterns)]\n-\n-#![allow(incomplete_features)]\n #![deny(unreachable_patterns)]\n \n-// We wrap patterns in a tuple because top-level or-patterns are special-cased for now.\n+// We wrap patterns in a tuple because top-level or-patterns were special-cased.\n fn main() {\n-    // Get the fatal error out of the way\n-    match (0u8,) {\n-        (0 | _,) => {}\n-        //~^ ERROR or-patterns are not fully implemented yet\n-    }\n-\n     match (0u8,) {\n         (1 | 2,) => {}\n         (1,) => {} //~ ERROR unreachable pattern\n@@ -29,9 +21,9 @@ fn main() {\n     }\n     match (0u8, 0u8) {\n         (1 | 2, 3 | 4) => {}\n-        (1, 3) => {} //~ ERROR unreachable pattern\n-        (1, 4) => {} //~ ERROR unreachable pattern\n-        (2, 4) => {} //~ ERROR unreachable pattern\n+        (1, 3) => {}     //~ ERROR unreachable pattern\n+        (1, 4) => {}     //~ ERROR unreachable pattern\n+        (2, 4) => {}     //~ ERROR unreachable pattern\n         (2 | 1, 4) => {} //~ ERROR unreachable pattern\n         (1, 5 | 6) => {}\n         (1, 4 | 5) => {} //~ ERROR unreachable pattern\n@@ -40,18 +32,17 @@ fn main() {\n     match (Some(0u8),) {\n         (None | Some(1 | 2),) => {}\n         (Some(1),) => {} //~ ERROR unreachable pattern\n-        (None,) => {} //~ ERROR unreachable pattern\n+        (None,) => {}    //~ ERROR unreachable pattern\n         _ => {}\n     }\n     match ((0u8,),) {\n-        ((1 | 2,) | (3 | 4,),) => {},\n-        ((1..=4,),) => {}, //~ ERROR unreachable pattern\n-        _ => {},\n+        ((1 | 2,) | (3 | 4,),) => {}\n+        ((1..=4,),) => {} //~ ERROR unreachable pattern\n+        _ => {}\n     }\n \n     match (0,) {\n-        (1\n-         | 1,) => {} //~ ERROR unreachable\n+        (1 | 1,) => {} //~ ERROR unreachable\n         _ => {}\n     }\n     match [0; 2] {"}, {"sha": "bef6f8270bc54ef028a8172b5f2a40c089bd05cf", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,110 +1,104 @@\n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:16:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:8:9\n    |\n LL |         (1,) => {}\n    |         ^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:4:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:2:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:21:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:13:9\n    |\n LL |         (2,) => {}\n    |         ^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:27:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:19:9\n    |\n LL |         (1 | 2,) => {}\n    |         ^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:32:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:24:9\n    |\n LL |         (1, 3) => {}\n    |         ^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:33:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:25:9\n    |\n LL |         (1, 4) => {}\n    |         ^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:34:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:26:9\n    |\n LL |         (2, 4) => {}\n    |         ^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:35:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:27:9\n    |\n LL |         (2 | 1, 4) => {}\n    |         ^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:37:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:29:9\n    |\n LL |         (1, 4 | 5) => {}\n    |         ^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:42:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:34:9\n    |\n LL |         (Some(1),) => {}\n    |         ^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:43:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:35:9\n    |\n LL |         (None,) => {}\n    |         ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:48:9\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:40:9\n    |\n-LL |         ((1..=4,),) => {},\n+LL |         ((1..=4,),) => {}\n    |         ^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:54:12\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:45:14\n    |\n-LL |          | 1,) => {}\n-   |            ^\n+LL |         (1 | 1,) => {}\n+   |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:61:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:52:15\n    |\n LL |             | 0] => {}\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:59:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:50:15\n    |\n LL |             | 0\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:69:10\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:60:10\n    |\n LL |         [1\n    |          ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:75:14\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:66:14\n    |\n LL |         Some(0\n    |              ^\n \n-error: or-patterns are not fully implemented yet\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:10:10\n-   |\n-LL |         (0 | _,) => {}\n-   |          ^^^^^\n-\n-error: aborting due to 17 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "2ef5537db60ad84776675f15b930770ea429f155", "filename": "src/test/ui/or-patterns/feature-gate-const-fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,5 +1,4 @@\n #![feature(or_patterns)]\n-#![allow(incomplete_features)]\n \n const fn foo((Ok(a) | Err(a)): Result<i32, i32>) {\n     //~^ ERROR or-pattern is not allowed in a `const fn`\n@@ -31,6 +30,8 @@ fn main() {\n         let x = Ok(3);\n         let Ok(y) | Err(y) = x;\n         //~^ ERROR or-pattern is not allowed in a `const`\n+        //~| ERROR constant contains unimplemented expression type\n+        //~| ERROR constant contains unimplemented expression type\n         2\n     }];\n }"}, {"sha": "9284e2d442dfac76396a567abaab2703028ed3fb", "filename": "src/test/ui/or-patterns/feature-gate-const-fn.stderr", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-const-fn.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: or-pattern is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-fn.rs:4:15\n+  --> $DIR/feature-gate-const-fn.rs:3:15\n    |\n LL | const fn foo((Ok(a) | Err(a)): Result<i32, i32>) {\n    |               ^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL | const fn foo((Ok(a) | Err(a)): Result<i32, i32>) {\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: or-pattern is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-fn.rs:7:9\n+  --> $DIR/feature-gate-const-fn.rs:6:9\n    |\n LL |     let Ok(y) | Err(y) = x;\n    |         ^^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     let Ok(y) | Err(y) = x;\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: or-pattern is not allowed in a `const`\n-  --> $DIR/feature-gate-const-fn.rs:13:9\n+  --> $DIR/feature-gate-const-fn.rs:12:9\n    |\n LL |     let Ok(y) | Err(y) = x;\n    |         ^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |     let Ok(y) | Err(y) = x;\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: or-pattern is not allowed in a `static`\n-  --> $DIR/feature-gate-const-fn.rs:19:9\n+  --> $DIR/feature-gate-const-fn.rs:18:9\n    |\n LL |     let Ok(y) | Err(y) = x;\n    |         ^^^^^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL |     let Ok(y) | Err(y) = x;\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: or-pattern is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-fn.rs:25:9\n+  --> $DIR/feature-gate-const-fn.rs:24:9\n    |\n LL |     let Ok(y) | Err(y) = x;\n    |         ^^^^^^^^^^^^^^\n@@ -44,14 +44,27 @@ LL |     let Ok(y) | Err(y) = x;\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: or-pattern is not allowed in a `const`\n-  --> $DIR/feature-gate-const-fn.rs:32:13\n+  --> $DIR/feature-gate-const-fn.rs:31:13\n    |\n LL |         let Ok(y) | Err(y) = x;\n    |             ^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n-error: aborting due to 6 previous errors\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/feature-gate-const-fn.rs:31:25\n+   |\n+LL |         let Ok(y) | Err(y) = x;\n+   |                         ^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/feature-gate-const-fn.rs:31:16\n+   |\n+LL |         let Ok(y) | Err(y) = x;\n+   |                ^\n+\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors have detailed explanations: E0019, E0658.\n+For more information about an error, try `rustc --explain E0019`."}, {"sha": "b79af6c402ec5a6c90d8a44e9dfd7b3c135e35e0", "filename": "src/test/ui/or-patterns/for-loop.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Ffor-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Ffor-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffor-loop.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,18 @@\n+// Check that or patterns are lowered correctly in `for` loops.\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+fn main() {\n+    let v = vec![Ok(2), Err(3), Ok(5)];\n+    let mut w = Vec::new();\n+    for &(Ok(i) | Err(i)) in &v {\n+        w.push(i);\n+    }\n+    let mut u = Vec::new();\n+    for Ok(i) | Err(i) in v {\n+        u.push(i);\n+    }\n+    assert_eq!(w, [2, 3, 5]);\n+    assert_eq!(u, [2, 3, 5]);\n+}"}, {"sha": "9256360b29db93290c36b5bdc264d2a388ebdba6", "filename": "src/test/ui/or-patterns/if-let-while-let.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fif-let-while-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fif-let-while-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fif-let-while-let.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,22 @@\n+// Check that or patterns are lowered correctly in `if let` and `while let` expressions.\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+fn main() {\n+    let mut opt = Some(3);\n+    let mut w = Vec::new();\n+    while let Some(ref mut val @ (3 | 4 | 6)) = opt {\n+        w.push(*val);\n+        *val += 1;\n+    }\n+    assert_eq!(w, [3, 4]);\n+    if let &(None | Some(6 | 7)) = &opt {\n+        unreachable!();\n+    }\n+    if let Some(x @ (4 | 5 | 6)) = opt {\n+        assert_eq!(x, 5);\n+    } else {\n+        unreachable!();\n+    }\n+}"}, {"sha": "28b5f0c02fef4beeea20a54676eb00f065462eb4", "filename": "src/test/ui/or-patterns/inconsistent-modes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,8 +1,6 @@\n // This test ensures that or patterns require binding mode consistency across arms.\n \n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete\n-\n #![allow(non_camel_case_types)]\n fn main() {\n     // One level:"}, {"sha": "c329f90596091a32bdfb405e0101ea41e03196ba", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,63 +1,55 @@\n error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:9:25\n+  --> $DIR/inconsistent-modes.rs:7:25\n    |\n LL |     let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n    |            -            ^ bound in different ways\n    |            |\n    |            first binding\n \n error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:11:29\n+  --> $DIR/inconsistent-modes.rs:9:29\n    |\n LL |     let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n    |                    -        ^ bound in different ways\n    |                    |\n    |                    first binding\n \n error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:13:33\n+  --> $DIR/inconsistent-modes.rs:11:33\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n    |                - first binding  ^ bound in different ways\n \n error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:16:39\n+  --> $DIR/inconsistent-modes.rs:14:39\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n    |                 - first binding       ^ bound in different ways\n \n error[E0409]: variable `b` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:16:46\n+  --> $DIR/inconsistent-modes.rs:14:46\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n    |                    - first binding           ^ bound in different ways\n \n error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:22:38\n+  --> $DIR/inconsistent-modes.rs:20:38\n    |\n LL |     let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n    |                        -             ^ bound in different ways\n    |                        |\n    |                        first binding\n \n error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n-  --> $DIR/inconsistent-modes.rs:26:34\n+  --> $DIR/inconsistent-modes.rs:24:34\n    |\n LL |     let Ok([ Ok((Ok(ref a) | Err(a),)) | Err(a) ]) | Err(a) = Err(&1);\n    |                         -        ^ bound in different ways\n    |                         |\n    |                         first binding\n \n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/inconsistent-modes.rs:3:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error[E0308]: mismatched types\n-  --> $DIR/inconsistent-modes.rs:13:25\n+  --> $DIR/inconsistent-modes.rs:11:25\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n    |                         ^^^^^^^^^   -------------------- expected due to this\n@@ -68,7 +60,7 @@ LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n               found type `&mut &mut u8`\n \n error[E0308]: mismatched types\n-  --> $DIR/inconsistent-modes.rs:16:31\n+  --> $DIR/inconsistent-modes.rs:14:31\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n    |                               ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`"}, {"sha": "0c2ae44e546d9b9b89ce822566172117f412ab83", "filename": "src/test/ui/or-patterns/issue-67514-irrefutable-param.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fissue-67514-irrefutable-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fissue-67514-irrefutable-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-67514-irrefutable-param.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,11 @@\n+// Check that we don't ICE for irrefutable or-patterns in function parameters\n+\n+// check-pass\n+\n+#![feature(or_patterns)]\n+\n+fn foo((Some(_) | None): Option<u32>) {}\n+\n+fn main() {\n+    foo(None);\n+}"}, {"sha": "07e37412ce842173b4d4545b744455045e81babb", "filename": "src/test/ui/or-patterns/let-pattern.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Flet-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Flet-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Flet-pattern.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,19 @@\n+#![feature(or_patterns)]\n+\n+// run-pass\n+\n+fn or_pat_let(x: Result<u32, u32>) -> u32 {\n+    let Ok(y) | Err(y) = x;\n+    y\n+}\n+\n+fn or_pat_arg((Ok(y) | Err(y)): Result<u32, u32>) -> u32 {\n+    y\n+}\n+\n+fn main() {\n+    assert_eq!(or_pat_let(Ok(3)), 3);\n+    assert_eq!(or_pat_let(Err(5)), 5);\n+    assert_eq!(or_pat_arg(Ok(7)), 7);\n+    assert_eq!(or_pat_arg(Err(9)), 9);\n+}"}, {"sha": "67cf52fa8c4187bd570b9fdd97325d47d2909965", "filename": "src/test/ui/or-patterns/missing-bindings.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -3,8 +3,6 @@\n // edition:2018\n \n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete\n-\n #![allow(non_camel_case_types)]\n \n fn main() {}"}, {"sha": "57270e4412351c654b3f15fa55935646b5222cea", "filename": "src/test/ui/or-patterns/missing-bindings.stderr", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,5 +1,5 @@\n error[E0408]: variable `beta` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:22:9\n+  --> $DIR/missing-bindings.rs:20:9\n    |\n LL |     let alpha | beta | charlie = alpha;\n    |         ^^^^^   ----   ^^^^^^^ pattern doesn't bind `beta`\n@@ -8,167 +8,167 @@ LL |     let alpha | beta | charlie = alpha;\n    |         pattern doesn't bind `beta`\n \n error[E0408]: variable `beta` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:24:14\n+  --> $DIR/missing-bindings.rs:22:14\n    |\n LL |         Some(alpha | beta) => {}\n    |              ^^^^^   ---- variable not in all patterns\n    |              |\n    |              pattern doesn't bind `beta`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:36:19\n+  --> $DIR/missing-bindings.rs:34:19\n    |\n LL |     let A(a, _) | _ = X;\n    |           -       ^ pattern doesn't bind `a`\n    |           |\n    |           variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:37:9\n+  --> $DIR/missing-bindings.rs:35:9\n    |\n LL |     let _ | B(a) = X;\n    |         ^     - variable not in all patterns\n    |         |\n    |         pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:38:9\n+  --> $DIR/missing-bindings.rs:36:9\n    |\n LL |     let A(..) | B(a) = X;\n    |         ^^^^^     - variable not in all patterns\n    |         |\n    |         pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:39:19\n+  --> $DIR/missing-bindings.rs:37:19\n    |\n LL |     let A(a, _) | B(_) = X;\n    |           -       ^^^^ pattern doesn't bind `a`\n    |           |\n    |           variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:40:19\n+  --> $DIR/missing-bindings.rs:38:19\n    |\n LL |     let A(_, a) | B(_) = X;\n    |              -    ^^^^ pattern doesn't bind `a`\n    |              |\n    |              variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:41:19\n+  --> $DIR/missing-bindings.rs:39:19\n    |\n LL |     let A(a, b) | B(a) = X;\n    |              -    ^^^^ pattern doesn't bind `b`\n    |              |\n    |              variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:45:9\n+  --> $DIR/missing-bindings.rs:43:9\n    |\n LL |     let A(A(..) | B(_), _) | B(a) = Y;\n    |         ^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n    |         |\n    |         pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:46:11\n+  --> $DIR/missing-bindings.rs:44:11\n    |\n LL |     let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n    |           ^^^^^     - variable not in all patterns\n    |           |\n    |           pattern doesn't bind `a`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:21\n+  --> $DIR/missing-bindings.rs:46:21\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |             -       ^^^^ pattern doesn't bind `a`\n    |             |\n    |             variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:21\n+  --> $DIR/missing-bindings.rs:46:21\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |                -    ^^^^ pattern doesn't bind `b`\n    |                |\n    |                variable not in all patterns\n \n error[E0408]: variable `c` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:11\n+  --> $DIR/missing-bindings.rs:46:11\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |           ^^^^^^^     - variable not in all patterns\n    |           |\n    |           pattern doesn't bind `c`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:32\n+  --> $DIR/missing-bindings.rs:46:32\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |             -                  ^^^^ pattern doesn't bind `a`\n    |             |\n    |             variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:32\n+  --> $DIR/missing-bindings.rs:46:32\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |                -               ^^^^ pattern doesn't bind `b`\n    |                |\n    |                variable not in all patterns\n \n error[E0408]: variable `c` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:32\n+  --> $DIR/missing-bindings.rs:46:32\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |                       -        ^^^^ pattern doesn't bind `c`\n    |                       |\n    |                       variable not in all patterns\n \n error[E0408]: variable `d` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:32\n+  --> $DIR/missing-bindings.rs:46:32\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |                           -    ^^^^ pattern doesn't bind `d`\n    |                           |\n    |                           variable not in all patterns\n \n error[E0408]: variable `e` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:48:9\n+  --> $DIR/missing-bindings.rs:46:9\n    |\n LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n    |         ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n    |         |\n    |         pattern doesn't bind `e`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:64:29\n+  --> $DIR/missing-bindings.rs:62:29\n    |\n LL |                     Ok(a) | Err(_),\n    |                        -    ^^^^^^ pattern doesn't bind `a`\n    |                        |\n    |                        variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:72:21\n+  --> $DIR/missing-bindings.rs:70:21\n    |\n LL |                     A(_, a) |\n    |                          - variable not in all patterns\n LL |                     B(b),\n    |                     ^^^^ pattern doesn't bind `a`\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:71:21\n+  --> $DIR/missing-bindings.rs:69:21\n    |\n LL |                     A(_, a) |\n    |                     ^^^^^^^ pattern doesn't bind `b`\n LL |                     B(b),\n    |                       - variable not in all patterns\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:75:17\n+  --> $DIR/missing-bindings.rs:73:17\n    |\n LL |                     A(_, a) |\n    |                          - variable not in all patterns\n@@ -177,7 +177,7 @@ LL |                 B(_)\n    |                 ^^^^ pattern doesn't bind `a`\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:75:17\n+  --> $DIR/missing-bindings.rs:73:17\n    |\n LL |                     B(b),\n    |                       - variable not in all patterns\n@@ -186,7 +186,7 @@ LL |                 B(_)\n    |                 ^^^^ pattern doesn't bind `b`\n \n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:79:13\n+  --> $DIR/missing-bindings.rs:77:13\n    |\n LL |                 B(Ok(a) | Err(a))\n    |                               - variable not in all patterns\n@@ -198,7 +198,7 @@ LL |             V3(c),\n    |             ^^^^^ pattern doesn't bind `a`\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:60:13\n+  --> $DIR/missing-bindings.rs:58:13\n    |\n LL | /             V1(\n LL | |\n@@ -216,7 +216,7 @@ LL |               V3(c),\n    |               ^^^^^ pattern doesn't bind `b`\n \n error[E0408]: variable `c` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:60:13\n+  --> $DIR/missing-bindings.rs:58:13\n    |\n LL | /             V1(\n LL | |\n@@ -237,14 +237,6 @@ LL | |             ) |\n LL |               V3(c),\n    |                  - variable not in all patterns\n \n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/missing-bindings.rs:5:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error: aborting due to 26 previous errors\n \n For more information about this error, try `rustc --explain E0408`."}, {"sha": "37f20df1b312d38eb85e264ed882082f7f619f0d", "filename": "src/test/ui/or-patterns/mix-with-wild.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmix-with-wild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmix-with-wild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmix-with-wild.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,19 @@\n+// Test that an or-pattern works with a wild pattern. This tests two things:\n+//\n+//  1) The Wild pattern should cause the pattern to always succeed.\n+//  2) or-patterns should work with simplifyable patterns.\n+\n+// run-pass\n+#![feature(or_patterns)]\n+\n+pub fn test(x: Option<usize>) -> bool {\n+    match x {\n+        Some(0 | _) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn main() {\n+    assert!(test(Some(42)));\n+    assert!(!test(None));\n+}"}, {"sha": "702c9573741e764f1eb6b488e12355669e66d995", "filename": "src/test/ui/or-patterns/multiple-pattern-typo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,5 +1,4 @@\n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete and may cause the compiler to crash\n \n fn main() {\n     let x = 3;"}, {"sha": "cb32068ec0d5eb61ac2af8af6d91253877d47c47", "filename": "src/test/ui/or-patterns/multiple-pattern-typo.stderr", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,64 +1,56 @@\n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:8:15\n+  --> $DIR/multiple-pattern-typo.rs:7:15\n    |\n LL |         1 | 2 || 3 => (),\n    |         -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |         |\n    |         while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:13:16\n+  --> $DIR/multiple-pattern-typo.rs:12:16\n    |\n LL |         (1 | 2 || 3) => (),\n    |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |          |\n    |          while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:18:16\n+  --> $DIR/multiple-pattern-typo.rs:17:16\n    |\n LL |         (1 | 2 || 3,) => (),\n    |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |          |\n    |          while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:25:18\n+  --> $DIR/multiple-pattern-typo.rs:24:18\n    |\n LL |         TS(1 | 2 || 3) => (),\n    |            -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |            |\n    |            while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:32:23\n+  --> $DIR/multiple-pattern-typo.rs:31:23\n    |\n LL |         NS { f: 1 | 2 || 3 } => (),\n    |                 -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |                 |\n    |                 while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:37:16\n+  --> $DIR/multiple-pattern-typo.rs:36:16\n    |\n LL |         [1 | 2 || 3] => (),\n    |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |          |\n    |          while parsing this or-pattern starting here\n \n error: unexpected token `||` after pattern\n-  --> $DIR/multiple-pattern-typo.rs:42:9\n+  --> $DIR/multiple-pattern-typo.rs:41:9\n    |\n LL |         || 1 | 2 | 3 => (),\n    |         ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n \n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/multiple-pattern-typo.rs:1:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error: aborting due to 7 previous errors\n "}, {"sha": "d23220056524b5b2a08df386a166dcca8a833f17", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -2,7 +2,6 @@\n // This is not a semantic test. We only test parsing.\n \n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete and may cause the compiler to crash\n \n fn main() {}\n "}, {"sha": "6cbb59dc22031309d916f87fcb1b7a964e6fca1b", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,85 +1,85 @@\n error: an or-pattern parameter must be wrapped in parenthesis\n-  --> $DIR/or-patterns-syntactic-fail.rs:28:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:27:13\n    |\n LL |     fn fun1(A | B: E) {}\n    |             ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n \n error: a leading `|` is not allowed in a parameter pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:30:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:29:13\n    |\n LL |     fn fun2(| A | B: E) {}\n    |             ^ help: remove the `|`\n \n error: an or-pattern parameter must be wrapped in parenthesis\n-  --> $DIR/or-patterns-syntactic-fail.rs:30:15\n+  --> $DIR/or-patterns-syntactic-fail.rs:29:15\n    |\n LL |     fn fun2(| A | B: E) {}\n    |               ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:41:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:40:11\n    |\n LL |     let ( | A | B) = E::A;\n    |           ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:42:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:41:11\n    |\n LL |     let ( | A | B,) = (E::B,);\n    |           ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:43:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:42:11\n    |\n LL |     let [ | A | B ] = [E::A];\n    |           ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:44:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:43:13\n    |\n LL |     let TS( | A | B );\n    |             ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:45:17\n+  --> $DIR/or-patterns-syntactic-fail.rs:44:17\n    |\n LL |     let NS { f: | A | B };\n    |                 ^ help: remove the `|`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:47:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:46:11\n    |\n LL |     let ( || A | B) = E::A;\n    |           ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:48:11\n+  --> $DIR/or-patterns-syntactic-fail.rs:47:11\n    |\n LL |     let [ || A | B ] = [E::A];\n    |           ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:49:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:48:13\n    |\n LL |     let TS( || A | B );\n    |             ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:50:17\n+  --> $DIR/or-patterns-syntactic-fail.rs:49:17\n    |\n LL |     let NS { f: || A | B };\n    |                 ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n error: no rules expected the token `|`\n-  --> $DIR/or-patterns-syntactic-fail.rs:14:15\n+  --> $DIR/or-patterns-syntactic-fail.rs:13:15\n    |\n LL | macro_rules! accept_pat {\n    | ----------------------- when calling this macro\n@@ -88,24 +88,16 @@ LL | accept_pat!(p | q);\n    |               ^ no rules expected this token in macro call\n \n error: no rules expected the token `|`\n-  --> $DIR/or-patterns-syntactic-fail.rs:15:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:14:13\n    |\n LL | macro_rules! accept_pat {\n    | ----------------------- when calling this macro\n ...\n LL | accept_pat!(| p | q);\n    |             ^ no rules expected this token in macro call\n \n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/or-patterns-syntactic-fail.rs:4:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error[E0369]: no implementation for `E | ()`\n-  --> $DIR/or-patterns-syntactic-fail.rs:24:22\n+  --> $DIR/or-patterns-syntactic-fail.rs:23:22\n    |\n LL |     let _ = |A | B: E| ();\n    |                  ----^ -- ()\n@@ -115,7 +107,7 @@ LL |     let _ = |A | B: E| ();\n    = note: an implementation of `std::ops::BitOr` might be missing for `E`\n \n error[E0308]: mismatched types\n-  --> $DIR/or-patterns-syntactic-fail.rs:52:36\n+  --> $DIR/or-patterns-syntactic-fail.rs:51:36\n    |\n LL |     let recovery_witness: String = 0;\n    |                           ------   ^"}, {"sha": "5fe72caf9c1ff7a9c3ee401a76dd4f6ab8e86761", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -3,7 +3,7 @@\n \n // check-pass\n \n-#![feature(or_patterns)] //~ WARNING the feature `or_patterns` is incomplete\n+#![feature(or_patterns)]\n \n fn main() {}\n "}, {"sha": "3145a2e9f2a6edef9a25352ee7645a346a5c1e84", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8417d68de5e063426ab6bb7f383df6117d1beeed/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8417d68de5e063426ab6bb7f383df6117d1beeed/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.stderr?ref=8417d68de5e063426ab6bb7f383df6117d1beeed", "patch": "@@ -1,8 +0,0 @@\n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/or-patterns-syntactic-pass.rs:6:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-"}, {"sha": "eb127b881cd37832f17b0906ba96bb3cb86f1a48", "filename": "src/test/ui/or-patterns/search-via-bindings.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fsearch-via-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fsearch-via-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fsearch-via-bindings.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,66 @@\n+// Check that we expand multiple or-patterns from left to right.\n+\n+// run-pass\n+\n+#![feature(or_patterns)]\n+#![allow(unreachable_patterns)] // FIXME(or-patterns) this shouldn't trigger\n+\n+fn search(target: (bool, bool, bool)) -> u32 {\n+    let x = ((false, true), (false, true), (false, true));\n+    let mut guard_count = 0;\n+    match x {\n+        ((a, _) | (_, a), (b @ _, _) | (_, b @ _), (c @ false, _) | (_, c @ true))\n+            if {\n+                guard_count += 1;\n+                (a, b, c) == target\n+            } =>\n+        {\n+            guard_count\n+        }\n+        _ => unreachable!(),\n+    }\n+}\n+\n+// Equivalent to the above code, but hopefully easier to understand.\n+fn search_old_style(target: (bool, bool, bool)) -> u32 {\n+    let x = ((false, true), (false, true), (false, true));\n+    let mut guard_count = 0;\n+    match x {\n+        ((a, _), (b @ _, _), (c @ false, _))\n+        | ((a, _), (b @ _, _), (_, c @ true))\n+        | ((a, _), (_, b @ _), (c @ false, _))\n+        | ((a, _), (_, b @ _), (_, c @ true))\n+        | ((_, a), (b @ _, _), (c @ false, _))\n+        | ((_, a), (b @ _, _), (_, c @ true))\n+        | ((_, a), (_, b @ _), (c @ false, _))\n+        | ((_, a), (_, b @ _), (_, c @ true))\n+            if {\n+                guard_count += 1;\n+                (a, b, c) == target\n+            } =>\n+        {\n+            guard_count\n+        }\n+        _ => unreachable!(),\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(search((false, false, false)), 1);\n+    assert_eq!(search((false, false, true)), 2);\n+    assert_eq!(search((false, true, false)), 3);\n+    assert_eq!(search((false, true, true)), 4);\n+    assert_eq!(search((true, false, false)), 5);\n+    assert_eq!(search((true, false, true)), 6);\n+    assert_eq!(search((true, true, false)), 7);\n+    assert_eq!(search((true, true, true)), 8);\n+\n+    assert_eq!(search_old_style((false, false, false)), 1);\n+    assert_eq!(search_old_style((false, false, true)), 2);\n+    assert_eq!(search_old_style((false, true, false)), 3);\n+    assert_eq!(search_old_style((false, true, true)), 4);\n+    assert_eq!(search_old_style((true, false, false)), 5);\n+    assert_eq!(search_old_style((true, false, true)), 6);\n+    assert_eq!(search_old_style((true, true, false)), 7);\n+    assert_eq!(search_old_style((true, true, true)), 8);\n+}"}, {"sha": "3794a8b6c1510d085a4b02a42b411059b917bc58", "filename": "src/test/ui/or-patterns/struct-like.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fstruct-like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2For-patterns%2Fstruct-like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fstruct-like.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -0,0 +1,42 @@\n+// run-pass\n+\n+#![feature(or_patterns)]\n+\n+#[derive(Debug)]\n+enum Other {\n+    One,\n+    Two,\n+    Three,\n+}\n+\n+#[derive(Debug)]\n+enum Test {\n+    Foo { first: usize, second: usize },\n+    Bar { other: Option<Other> },\n+    Baz,\n+}\n+\n+fn test(x: Option<Test>) -> bool {\n+    match x {\n+        Some(\n+            Test::Foo { first: 1024 | 2048, second: 2048 | 4096 }\n+            | Test::Bar { other: Some(Other::One | Other::Two) },\n+        ) => true,\n+        // wild case\n+        Some(_) => false,\n+        // empty case\n+        None => false,\n+    }\n+}\n+\n+fn main() {\n+    assert!(test(Some(Test::Foo { first: 1024, second: 4096 })));\n+    assert!(!test(Some(Test::Foo { first: 2048, second: 8192 })));\n+    assert!(!test(Some(Test::Foo { first: 42, second: 2048 })));\n+    assert!(test(Some(Test::Bar { other: Some(Other::One) })));\n+    assert!(test(Some(Test::Bar { other: Some(Other::Two) })));\n+    assert!(!test(Some(Test::Bar { other: Some(Other::Three) })));\n+    assert!(!test(Some(Test::Bar { other: None })));\n+    assert!(!test(Some(Test::Baz)));\n+    assert!(!test(None));\n+}"}, {"sha": "e8b5b492b7738faec1d77cc5465d79930d3bb174", "filename": "src/test/ui/pattern/bindings-after-at/pat-at-same-name-both.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -3,7 +3,6 @@\n \n #![feature(bindings_after_at)]\n #![feature(or_patterns)]\n-//~^ WARN the feature `or_patterns` is incomplete and may cause the compiler to crash\n \n fn main() {\n     fn f(a @ a @ a: ()) {}"}, {"sha": "cba17d82e93c53654807aad9d53eabf7e30a2b7c", "filename": "src/test/ui/pattern/bindings-after-at/pat-at-same-name-both.stderr", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -1,71 +1,63 @@\n error[E0415]: identifier `a` is bound more than once in this parameter list\n-  --> $DIR/pat-at-same-name-both.rs:9:14\n+  --> $DIR/pat-at-same-name-both.rs:8:14\n    |\n LL |     fn f(a @ a @ a: ()) {}\n    |              ^ used as parameter more than once\n \n error[E0415]: identifier `a` is bound more than once in this parameter list\n-  --> $DIR/pat-at-same-name-both.rs:9:18\n+  --> $DIR/pat-at-same-name-both.rs:8:18\n    |\n LL |     fn f(a @ a @ a: ()) {}\n    |                  ^ used as parameter more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:14:20\n+  --> $DIR/pat-at-same-name-both.rs:13:20\n    |\n LL |         Ok(a @ b @ a)\n    |                    ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:16:23\n+  --> $DIR/pat-at-same-name-both.rs:15:23\n    |\n LL |         | Err(a @ b @ a)\n    |                       ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:21:13\n+  --> $DIR/pat-at-same-name-both.rs:20:13\n    |\n LL |     let a @ a @ a = ();\n    |             ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:21:17\n+  --> $DIR/pat-at-same-name-both.rs:20:17\n    |\n LL |     let a @ a @ a = ();\n    |                 ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:24:21\n+  --> $DIR/pat-at-same-name-both.rs:23:21\n    |\n LL |     let ref a @ ref a = ();\n    |                     ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:26:29\n+  --> $DIR/pat-at-same-name-both.rs:25:29\n    |\n LL |     let ref mut a @ ref mut a = ();\n    |                             ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:29:17\n+  --> $DIR/pat-at-same-name-both.rs:28:17\n    |\n LL |     let a @ (Ok(a) | Err(a)) = Ok(());\n    |                 ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/pat-at-same-name-both.rs:29:26\n+  --> $DIR/pat-at-same-name-both.rs:28:26\n    |\n LL |     let a @ (Ok(a) | Err(a)) = Ok(());\n    |                          ^ used in a pattern more than once\n \n-warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n-  --> $DIR/pat-at-same-name-both.rs:5:12\n-   |\n-LL | #![feature(or_patterns)]\n-   |            ^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-\n error: aborting due to 10 previous errors\n \n Some errors have detailed explanations: E0415, E0416."}, {"sha": "44893036383587118d8826f0507a2693560e2d3d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -6,7 +6,6 @@ fn foo(res: Result<u32, &R>) -> u32 {\n     let Ok(x) = res;\n     //~^ ERROR refutable pattern\n     x\n-    //~^ ERROR use of possibly-uninitialized variable: `x`\n }\n \n fn main() {"}, {"sha": "aa23aed4b425a581658218fa2335948f50612c97", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -11,13 +11,6 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL |     if let Ok(x) = res { /* */ }\n    |\n \n-error[E0381]: use of possibly-uninitialized variable: `x`\n-  --> $DIR/recursive-types-are-not-uninhabited.rs:8:5\n-   |\n-LL |     x\n-   |     ^ use of possibly-uninitialized `x`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0005, E0381.\n-For more information about an error, try `rustc --explain E0005`.\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "612fae208cc9d8e18fa80a56720ee7f48cc6833c", "filename": "src/test/ui/suggestions/dont-suggest-ref/duplicate-suggestions.stderr", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fduplicate-suggestions.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -65,13 +65,18 @@ LL |     match &(e.clone(), e.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &(Either::One(_t), Either::Two(_u))\n-   |         -----------------------------------\n-   |         |             |                |\n-   |         |             |                ...and here\n-   |         |             data moved here\n-   |         help: consider removing the `&`: `(Either::One(_t), Either::Two(_u))`\n+   |                       --               -- ...and here\n+   |                       |\n+   |                       data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the `&`\n+   |\n+LL |         (Either::One(_t), Either::Two(_u))\n+LL |\n+LL |\n+LL |         | &(Either::Two(_t), Either::One(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/duplicate-suggestions.rs:70:11\n@@ -170,13 +175,18 @@ LL |     match &mut (em.clone(), em.clone()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |         &mut (Either::One(_t), Either::Two(_u))\n-   |         ---------------------------------------\n-   |         |                 |                |\n-   |         |                 |                ...and here\n-   |         |                 data moved here\n-   |         help: consider removing the `&mut`: `(Either::One(_t), Either::Two(_u))`\n+   |                           --               -- ...and here\n+   |                           |\n+   |                           data moved here\n    |\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n+help: consider removing the `&mut`\n+   |\n+LL |         (Either::One(_t), Either::Two(_u))\n+LL |\n+LL |\n+LL |         | &mut (Either::Two(_t), Either::One(_u)) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n   --> $DIR/duplicate-suggestions.rs:122:11"}, {"sha": "5550e097cf55461d2f78159b426e009fcb918f06", "filename": "src/test/ui/suggestions/dont-suggest-ref/simple.stderr", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a0bd2091b9ca8fe5059fd5f4a26279a388f278/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ref%2Fsimple.stderr?ref=42a0bd2091b9ca8fe5059fd5f4a26279a388f278", "patch": "@@ -263,11 +263,18 @@ LL |     match r {\n    |           ^\n LL |\n LL |         &Either::One(_t)\n-   |         ----------------\n-   |         |            |\n-   |         |            data moved here\n-   |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Either::One(_t)`\n+   |                      --\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the `&`\n+   |\n+LL |         Either::One(_t)\n+LL |\n+LL |\n+LL |         | &Either::Two(_t) => (),\n+   |\n \n error[E0507]: cannot move out of `r.0` which is behind a shared reference\n   --> $DIR/simple.rs:188:11\n@@ -502,11 +509,18 @@ LL |     match &e {\n    |           ^^\n LL |\n LL |         &Either::One(_t)\n-   |         ----------------\n-   |         |            |\n-   |         |            data moved here\n-   |         |            move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&`: `Either::One(_t)`\n+   |                      --\n+   |                      |\n+   |                      data moved here\n+   |                      move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the `&`\n+   |\n+LL |         Either::One(_t)\n+LL |\n+LL |\n+LL |         | &Either::Two(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/simple.rs:308:11\n@@ -571,11 +585,18 @@ LL |     match &mut em {\n    |           ^^^^^^^\n LL |\n LL |         &mut Either::One(_t)\n-   |         --------------------\n-   |         |                |\n-   |         |                data moved here\n-   |         |                move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n-   |         help: consider removing the `&mut`: `Either::One(_t)`\n+   |                          --\n+   |                          |\n+   |                          data moved here\n+   |                          move occurs because `_t` has type `X`, which does not implement the `Copy` trait\n+   |\n+help: consider removing the `&mut`\n+   |\n+LL |         Either::One(_t)\n+LL |\n+LL |\n+LL |         | &mut Either::Two(_t) => (),\n+   |\n \n error[E0507]: cannot move out of a mutable reference\n   --> $DIR/simple.rs:343:11"}]}