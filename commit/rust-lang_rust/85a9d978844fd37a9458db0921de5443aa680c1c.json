{"sha": "85a9d978844fd37a9458db0921de5443aa680c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YTlkOTc4ODQ0ZmQzN2E5NDU4ZGIwOTIxZGU1NDQzYWE2ODBjMWM=", "commit": {"author": {"name": "Frank Rehberger", "email": "frehberg@gmail.com", "date": "2017-09-06T22:54:28Z"}, "committer": {"name": "Frank Rehberger", "email": "frehberg@gmail.com", "date": "2017-09-11T23:50:32Z"}, "message": "rustdoc: extend UdpSocket API doc (#657)\n\nrustdoc: type-fixes", "tree": {"sha": "1ec627bd67a81405997c771dd7fbceeab7380483", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ec627bd67a81405997c771dd7fbceeab7380483"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85a9d978844fd37a9458db0921de5443aa680c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85a9d978844fd37a9458db0921de5443aa680c1c", "html_url": "https://github.com/rust-lang/rust/commit/85a9d978844fd37a9458db0921de5443aa680c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85a9d978844fd37a9458db0921de5443aa680c1c/comments", "author": {"login": "frehberg", "id": 4435830, "node_id": "MDQ6VXNlcjQ0MzU4MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/4435830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frehberg", "html_url": "https://github.com/frehberg", "followers_url": "https://api.github.com/users/frehberg/followers", "following_url": "https://api.github.com/users/frehberg/following{/other_user}", "gists_url": "https://api.github.com/users/frehberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/frehberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frehberg/subscriptions", "organizations_url": "https://api.github.com/users/frehberg/orgs", "repos_url": "https://api.github.com/users/frehberg/repos", "events_url": "https://api.github.com/users/frehberg/events{/privacy}", "received_events_url": "https://api.github.com/users/frehberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frehberg", "id": 4435830, "node_id": "MDQ6VXNlcjQ0MzU4MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/4435830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frehberg", "html_url": "https://github.com/frehberg", "followers_url": "https://api.github.com/users/frehberg/followers", "following_url": "https://api.github.com/users/frehberg/following{/other_user}", "gists_url": "https://api.github.com/users/frehberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/frehberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frehberg/subscriptions", "organizations_url": "https://api.github.com/users/frehberg/orgs", "repos_url": "https://api.github.com/users/frehberg/repos", "events_url": "https://api.github.com/users/frehberg/events{/privacy}", "received_events_url": "https://api.github.com/users/frehberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a20953906056f85f71896795e762ac242e1891aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/a20953906056f85f71896795e762ac242e1891aa", "html_url": "https://github.com/rust-lang/rust/commit/a20953906056f85f71896795e762ac242e1891aa"}], "stats": {"total": 54, "additions": 41, "deletions": 13}, "files": [{"sha": "cefe7af8ff3219700d65bcfee3b4314c1ec3fdde", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/85a9d978844fd37a9458db0921de5443aa680c1c/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a9d978844fd37a9458db0921de5443aa680c1c/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=85a9d978844fd37a9458db0921de5443aa680c1c", "patch": "@@ -48,11 +48,12 @@ use time::Duration;\n /// {\n ///     let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n ///\n-///     // read from the socket\n+///     // Receives a single datagram message on the socket. If `buf` is too small to hold\n+///     // the message, it will be cut off.\n ///     let mut buf = [0; 10];\n ///     let (amt, src) = socket.recv_from(&mut buf)?;\n ///\n-///     // send a reply to the socket we received data from\n+///     // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n ///     let buf = &mut buf[..amt];\n ///     buf.reverse();\n ///     socket.send_to(buf, &src)?;\n@@ -103,8 +104,12 @@ impl UdpSocket {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n     }\n \n-    /// Receives data from the socket. On success, returns the number of bytes\n-    /// read and the address from whence the data came.\n+    /// Receives a single datagram message on the socket. On success, returns the number\n+    /// of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// # Examples\n     ///\n@@ -115,19 +120,25 @@ impl UdpSocket {\n     /// let mut buf = [0; 10];\n     /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n     ///                                         .expect(\"Didn't receive data\");\n+    /// let filled_buf = &mut buf[..number_of_bytes];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.0.recv_from(buf)\n     }\n \n-    /// Receives data from the socket, without removing it from the queue.\n+    /// Receives a single datagram message on the socket, without removing it from the\n+    /// queue. On success, returns the number of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// Successive calls return the same data. This is accomplished by passing\n     /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n     ///\n-    /// On success, returns the number of bytes peeked and the address from\n-    /// whence the data came.\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n     ///\n     /// # Examples\n     ///\n@@ -138,6 +149,7 @@ impl UdpSocket {\n     /// let mut buf = [0; 10];\n     /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n     ///                                         .expect(\"Didn't receive data\");\n+    /// let filled_buf = &mut buf[..number_of_bytes];\n     /// ```\n     #[stable(feature = \"peek\", since = \"1.18.0\")]\n     pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n@@ -642,8 +654,12 @@ impl UdpSocket {\n         self.0.send(buf)\n     }\n \n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected.\n+    /// Receives a single datagram message on the socket from the remote address to\n+    /// which it is connected. On success, returns the number of bytes read.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// The [`connect`] method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n@@ -659,7 +675,7 @@ impl UdpSocket {\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// let mut buf = [0; 10];\n     /// match socket.recv(&mut buf) {\n-    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Ok(received) => println!(\"received {} bytes {:?}\", received, &buf[..received]),\n     ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n     /// }\n     /// ```\n@@ -668,13 +684,25 @@ impl UdpSocket {\n         self.0.recv(buf)\n     }\n \n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n+    /// Receives single datagram on the socket from the remote address to which it is\n+    /// connected, without removing the message from input queue. On success, returns\n+    /// the number of bytes peeked.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n     ///\n     /// Successive calls return the same data. This is accomplished by passing\n     /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n     ///\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n+    ///\n+    /// The [`connect`] method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    ///\n+    /// [`connect`]: #method.connect\n+    ///\n     /// # Errors\n     ///\n     /// This method will fail if the socket is not connected. The `connect` method"}]}