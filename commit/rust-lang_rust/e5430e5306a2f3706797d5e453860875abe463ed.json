{"sha": "e5430e5306a2f3706797d5e453860875abe463ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NDMwZTUzMDZhMmYzNzA2Nzk3ZDVlNDUzODYwODc1YWJlNDYzZWQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-24T20:01:46Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-24T20:01:46Z"}, "message": "the two hardest things in programming, names and...", "tree": {"sha": "9be708153dacd5720a9279a2f2e47eff699232f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9be708153dacd5720a9279a2f2e47eff699232f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5430e5306a2f3706797d5e453860875abe463ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5430e5306a2f3706797d5e453860875abe463ed", "html_url": "https://github.com/rust-lang/rust/commit/e5430e5306a2f3706797d5e453860875abe463ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5430e5306a2f3706797d5e453860875abe463ed/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e84b6105376742072e85ae2b85a6a1fd9a9045d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e84b6105376742072e85ae2b85a6a1fd9a9045d", "html_url": "https://github.com/rust-lang/rust/commit/0e84b6105376742072e85ae2b85a6a1fd9a9045d"}], "stats": {"total": 200, "additions": 118, "deletions": 82}, "files": [{"sha": "ce249404e8ead6f495d2cfda15d3fc5a53431ab0", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 115, "deletions": 79, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e5430e5306a2f3706797d5e453860875abe463ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5430e5306a2f3706797d5e453860875abe463ed/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e5430e5306a2f3706797d5e453860875abe463ed", "patch": "@@ -178,7 +178,7 @@ fn closure_return_type_suggestion(\n     );\n     err.span_label(\n         span,\n-        InferCtxt::missing_type_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+        InferCtxt::cannot_infer_msg(\"type\", &name, &descr, parent_name, parent_descr),\n     );\n }\n \n@@ -220,12 +220,23 @@ impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n     }\n }\n \n+/// Information about a constant or a type containing inference variables.\n+pub struct InferDiagnosticsData {\n+    pub name: String,\n+    pub span: Option<Span>,\n+    pub description: Cow<'static, str>,\n+    pub parent_name: Option<String>,\n+    pub parent_description: Option<&'static str>,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn extract_type_name(\n+    /// Extracts data used by diagnostic for either types or constants\n+    /// which were stuck during inference.\n+    pub fn extract_infer_data(\n         &self,\n         arg: GenericArg<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n+    ) -> InferDiagnosticsData {\n         match arg.unpack() {\n             GenericArgKind::Type(ty) => {\n                 if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n@@ -236,32 +247,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         var_origin.kind\n                     {\n                         let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n-                        let (parent_name, parent_desc) = if let Some(parent_def_id) = parent_def_id\n-                        {\n-                            let parent_name = self\n-                                .tcx\n-                                .def_key(parent_def_id)\n-                                .disambiguated_data\n-                                .data\n-                                .get_opt_name()\n-                                .map(|parent_symbol| parent_symbol.to_string());\n-\n-                            (\n-                                parent_name,\n-                                Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n-                            )\n-                        } else {\n-                            (None, None)\n-                        };\n+                        let (parent_name, parent_description) =\n+                            if let Some(parent_def_id) = parent_def_id {\n+                                let parent_name = self\n+                                    .tcx\n+                                    .def_key(parent_def_id)\n+                                    .disambiguated_data\n+                                    .data\n+                                    .get_opt_name()\n+                                    .map(|parent_symbol| parent_symbol.to_string());\n+\n+                                (\n+                                    parent_name,\n+                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                                )\n+                            } else {\n+                                (None, None)\n+                            };\n \n                         if name != kw::SelfUpper {\n-                            return (\n-                                name.to_string(),\n-                                Some(var_origin.span),\n-                                \"type parameter\".into(),\n+                            return InferDiagnosticsData {\n+                                name: name.to_string(),\n+                                span: Some(var_origin.span),\n+                                description: \"type parameter\".into(),\n                                 parent_name,\n-                                parent_desc,\n-                            );\n+                                parent_description,\n+                            };\n                         }\n                     }\n                 }\n@@ -272,56 +283,67 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     printer.region_highlight_mode = highlight;\n                 }\n                 let _ = ty.print(printer);\n-                (s, None, ty.prefix_string(), None, None)\n+                InferDiagnosticsData {\n+                    name: s,\n+                    span: None,\n+                    description: ty.prefix_string(),\n+                    parent_name: None,\n+                    parent_description: None,\n+                }\n             }\n             GenericArgKind::Const(ct) => {\n-                let span = if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n+                if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n                     let origin =\n                         self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n                     if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n                         origin.kind\n                     {\n                         let parent_def_id = self.tcx.parent(def_id);\n-                        let (parent_name, parent_descr) = if let Some(parent_def_id) = parent_def_id\n-                        {\n-                            let parent_name = self\n-                                .tcx\n-                                .def_key(parent_def_id)\n-                                .disambiguated_data\n-                                .data\n-                                .get_opt_name()\n-                                .map(|parent_symbol| parent_symbol.to_string());\n-\n-                            (\n-                                parent_name,\n-                                Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n-                            )\n-                        } else {\n-                            (None, None)\n-                        };\n-\n-                        return (\n-                            name.to_string(),\n-                            Some(origin.span),\n-                            \"const parameter\".into(),\n+                        let (parent_name, parent_description) =\n+                            if let Some(parent_def_id) = parent_def_id {\n+                                let parent_name = self\n+                                    .tcx\n+                                    .def_key(parent_def_id)\n+                                    .disambiguated_data\n+                                    .data\n+                                    .get_opt_name()\n+                                    .map(|parent_symbol| parent_symbol.to_string());\n+\n+                                (\n+                                    parent_name,\n+                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n+                                )\n+                            } else {\n+                                (None, None)\n+                            };\n+\n+                        return InferDiagnosticsData {\n+                            name: name.to_string(),\n+                            span: Some(origin.span),\n+                            description: \"const parameter\".into(),\n                             parent_name,\n-                            parent_descr,\n-                        );\n+                            parent_description,\n+                        };\n                     }\n \n                     debug_assert!(!origin.span.is_dummy());\n-                    Some(origin.span)\n+                    let mut s = String::new();\n+                    let mut printer =\n+                        ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::ValueNS);\n+                    if let Some(highlight) = highlight {\n+                        printer.region_highlight_mode = highlight;\n+                    }\n+                    let _ = ct.print(printer);\n+                    InferDiagnosticsData {\n+                        name: s,\n+                        span: Some(origin.span),\n+                        description: \"the constant\".into(),\n+                        parent_name: None,\n+                        parent_description: None,\n+                    }\n                 } else {\n                     bug!(\"unexpect const: {:?}\", ct);\n-                };\n-\n-                let mut s = String::new();\n-                let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::ValueNS);\n-                if let Some(highlight) = highlight {\n-                    printer.region_highlight_mode = highlight;\n                 }\n-                let _ = ct.print(printer);\n-                (s, span, \"the constant\".into(), None, None)\n             }\n             GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n         }\n@@ -331,18 +353,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n-        ty: GenericArg<'tcx>,\n+        arg: GenericArg<'tcx>,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(ty, None);\n+        let ty = self.resolve_vars_if_possible(&arg);\n+        let arg_data = self.extract_infer_data(arg, None);\n         let kind_str = match ty.unpack() {\n             GenericArgKind::Type(_) => \"type\",\n             GenericArgKind::Const(_) => \"the value\",\n             GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n         };\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, arg.into(), span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -372,7 +394,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n             pattern.span\n-        } else if let Some(span) = name_sp {\n+        } else if let Some(span) = arg_data.span {\n             // `span` here lets us point at `sum` instead of the entire right hand side expr:\n             // error[E0282]: type annotations needed\n             //  --> file2.rs:3:15\n@@ -419,7 +441,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => String::new(),\n         };\n \n-        // When `name` corresponds to a type argument, show the path of the full type we're\n+        // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n         // \" in `std::result::Result<i32, E>`\":\n         // ```\n@@ -458,11 +480,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         &mut err,\n                         &decl.output,\n                         self.tcx.hir().body(body_id),\n-                        &descr,\n-                        &name,\n+                        &arg_data.description,\n+                        &arg_data.name,\n                         &ret,\n-                        parent_name,\n-                        parent_descr,\n+                        arg_data.parent_name,\n+                        arg_data.parent_description,\n                     );\n                     // We don't want to give the other suggestions when the problem is the\n                     // closure return type.\n@@ -476,15 +498,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // nudge them in the right direction.\n                 format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n                 let ty = ty_to_string(ty);\n                 format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n                 let ty = ty_to_string(ty);\n                 format!(\n                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty, name,\n+                    ty, arg_data.name,\n                 )\n             }\n             _ => \"a type\".to_string(),\n@@ -601,7 +623,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |               ^^^ cannot infer type for `S`\n         //   |\n         //   = note: type must be known at this point\n-        let span = name_sp.unwrap_or(err_span);\n+        let span = arg_data.span.unwrap_or(err_span);\n         if !err\n             .span\n             .span_labels()\n@@ -612,7 +634,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,\n-                InferCtxt::missing_type_msg(kind_str, &name, &descr, parent_name, parent_descr),\n+                InferCtxt::cannot_infer_msg(\n+                    kind_str,\n+                    &arg_data.name,\n+                    &arg_data.description,\n+                    arg_data.parent_name,\n+                    arg_data.parent_description,\n+                ),\n             );\n         }\n \n@@ -672,7 +700,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, _, descr, parent_name, parent_descr) = self.extract_type_name(ty.into(), None);\n+        let data = self.extract_infer_data(ty.into(), None);\n \n         let mut err = struct_span_err!(\n             self.tcx.sess,\n@@ -683,12 +711,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n         err.span_label(\n             span,\n-            InferCtxt::missing_type_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+            InferCtxt::cannot_infer_msg(\n+                \"type\",\n+                &data.name,\n+                &data.description,\n+                data.parent_name,\n+                data.parent_description,\n+            ),\n         );\n         err\n     }\n \n-    fn missing_type_msg(\n+    fn cannot_infer_msg(\n         kind_str: &str,\n         type_name: &str,\n         descr: &str,\n@@ -710,6 +744,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 \"\".to_string()\n             };\n \n+            // FIXME: We really shouldn't be dealing with strings here\n+            // but instead use a sensible enum for cases like this.\n             let preposition = if \"the value\" == kind_str { \"of\" } else { \"for\" };\n             // For example: \"cannot infer type for type parameter `T`\"\n             format!("}, {"sha": "e7ab97515b668ab0225b851d451b45f313d6a29d", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5430e5306a2f3706797d5e453860875abe463ed/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5430e5306a2f3706797d5e453860875abe463ed/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=e5430e5306a2f3706797d5e453860875abe463ed", "patch": "@@ -396,7 +396,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionNameHighlight> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = self.infcx.extract_type_name(ty.into(), Some(highlight)).0;\n+        let type_name = self.infcx.extract_infer_data(ty.into(), Some(highlight)).name;\n \n         debug!(\n             \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n@@ -646,7 +646,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(return_ty.into(), Some(highlight)).0;\n+        let type_name = self.infcx.extract_infer_data(return_ty.into(), Some(highlight)).name;\n \n         let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n \n@@ -698,7 +698,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name = self.infcx.extract_type_name(yield_ty.into(), Some(highlight)).0;\n+        let type_name = self.infcx.extract_infer_data(yield_ty.into(), Some(highlight)).name;\n \n         let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n "}]}