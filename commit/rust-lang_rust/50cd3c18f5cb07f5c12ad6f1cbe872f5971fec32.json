{"sha": "50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwY2QzYzE4ZjVjYjA3ZjVjMTJhZDZmMWNiZTg3MmY1OTcxZmVjMzI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-13T22:15:25Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-13T22:15:25Z"}, "message": "Merge pull request #4467 from gifnksm/inlining-core\n\nInlining methods/functions in core.", "tree": {"sha": "e28385d9921b70836e8032a90da4103568e1c102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e28385d9921b70836e8032a90da4103568e1c102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "html_url": "https://github.com/rust-lang/rust/commit/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38315fb007939e0fcaad825a5e08b9ab729cd5bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/38315fb007939e0fcaad825a5e08b9ab729cd5bd", "html_url": "https://github.com/rust-lang/rust/commit/38315fb007939e0fcaad825a5e08b9ab729cd5bd"}, {"sha": "62f27497752389b14218986e68cd886da684fc7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/62f27497752389b14218986e68cd886da684fc7f", "html_url": "https://github.com/rust-lang/rust/commit/62f27497752389b14218986e68cd886da684fc7f"}], "stats": {"total": 338, "additions": 338, "deletions": 0}, "files": [{"sha": "b656879e7a422657bb70501fea89a573f7842074", "filename": "src/libcore/char.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -64,6 +64,7 @@ pub use is_XID_continue = unicode::derived_property::XID_Continue;\n  * Indicates whether a character is in lower case, defined\n  * in terms of the Unicode General Category 'Ll'\n  */\n+#[inline(always)]\n pub pure fn is_lowercase(c: char) -> bool {\n     return unicode::general_category::Ll(c);\n }\n@@ -72,6 +73,7 @@ pub pure fn is_lowercase(c: char) -> bool {\n  * Indicates whether a character is in upper case, defined\n  * in terms of the Unicode General Category 'Lu'.\n  */\n+#[inline(always)]\n pub pure fn is_uppercase(c: char) -> bool {\n     return unicode::general_category::Lu(c);\n }\n@@ -81,6 +83,7 @@ pub pure fn is_uppercase(c: char) -> bool {\n  * terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n  * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n  */\n+#[inline(always)]\n pub pure fn is_whitespace(c: char) -> bool {\n     return ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n@@ -93,6 +96,7 @@ pub pure fn is_whitespace(c: char) -> bool {\n  * defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n  * and the Derived Core Property 'Alphabetic'.\n  */\n+#[inline(always)]\n pub pure fn is_alphanumeric(c: char) -> bool {\n     return unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n@@ -101,11 +105,13 @@ pub pure fn is_alphanumeric(c: char) -> bool {\n }\n \n /// Indicates whether the character is an ASCII character\n+#[inline(always)]\n pub pure fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n+#[inline(always)]\n pub pure fn is_digit(c: char) -> bool {\n     return unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n@@ -122,6 +128,7 @@ pub pure fn is_digit(c: char) -> bool {\n  * 'b' or 'B', 11, etc. Returns none if the char does not\n  * refer to a digit in the given radix.\n  */\n+#[inline]\n pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n@@ -190,6 +197,7 @@ pub pure fn escape_default(c: char) -> ~str {\n  *\n  * -1 if a < b, 0 if a == b, +1 if a > b\n  */\n+#[inline(always)]\n pub pure fn cmp(a: char, b: char) -> int {\n     return  if b > a { -1 }\n     else if b < a { 1 }"}, {"sha": "6fbcf2df454069723405f150c167175520eebeae", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -16,5 +16,6 @@ pub trait Clone {\n }\n \n impl (): Clone {\n+    #[inline(always)]\n     fn clone(&self) -> () { () }\n }"}, {"sha": "141b6f19ab436ca1c907523d01c5981029059c07", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -53,26 +53,32 @@ pub trait Ord {\n     pure fn gt(&self, other: &self) -> bool;\n }\n \n+#[inline(always)]\n pub pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2)\n }\n \n+#[inline(always)]\n pub pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2) || (*v1).eq(v2)\n }\n \n+#[inline(always)]\n pub pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).eq(v2)\n }\n \n+#[inline(always)]\n pub pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).ne(v2)\n }\n \n+#[inline(always)]\n pub pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).ge(v2)\n }\n \n+#[inline(always)]\n pub pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }"}, {"sha": "c4f07db662180fd531119d73905b0f19ed412366", "filename": "src/libcore/either.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -28,6 +28,7 @@ pub enum Either<T, U> {\n     Right(U)\n }\n \n+#[inline(always)]\n pub fn either<T, U, V>(f_left: fn(&T) -> V,\n                        f_right: fn(&U) -> V, value: &Either<T, U>) -> V {\n     /*!\n@@ -90,6 +91,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>])\n     return (move lefts, move rights);\n }\n \n+#[inline(always)]\n pub pure fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n     //! Flips between left and right of a given either\n \n@@ -99,6 +101,7 @@ pub pure fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n     }\n }\n \n+#[inline(always)]\n pub pure fn to_result<T, U>(eith: Either<T, U>)\n     -> Result<U, T> {\n     /*!\n@@ -114,18 +117,21 @@ pub pure fn to_result<T, U>(eith: Either<T, U>)\n     }\n }\n \n+#[inline(always)]\n pub pure fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n     match *eith { Left(_) => true, _ => false }\n }\n \n+#[inline(always)]\n pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n     match *eith { Right(_) => true, _ => false }\n }\n \n+#[inline(always)]\n pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n@@ -134,6 +140,7 @@ pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     }\n }\n \n+#[inline(always)]\n pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n "}, {"sha": "4c1cc890de9e449c29a2bd8350a2879e3e1f0dcc", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -105,38 +105,52 @@ pub const infinity: f32 = 1.0_f32/0.0_f32;\n \n pub const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n+#[inline(always)]\n pub pure fn is_NaN(f: f32) -> bool { f != f }\n \n+#[inline(always)]\n pub pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n+#[inline(always)]\n pub pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n+#[inline(always)]\n pub pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n+#[inline(always)]\n pub pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n+#[inline(always)]\n pub pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n+#[inline(always)]\n pub pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n+#[inline(always)]\n pub pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n+#[inline(always)]\n pub pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n+#[inline(always)]\n pub pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n+#[inline(always)]\n pub pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n+#[inline(always)]\n pub pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n /// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n+#[inline(always)]\n pub pure fn is_positive(x: f32) -> bool\n     { return x > 0.0f32 || (1.0f32/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n+#[inline(always)]\n pub pure fn is_negative(x: f32) -> bool\n     { return x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n@@ -145,6 +159,7 @@ pub pure fn is_negative(x: f32) -> bool\n  *\n  * This is the same as `f32::is_negative`.\n  */\n+#[inline(always)]\n pub pure fn is_nonpositive(x: f32) -> bool {\n   return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n@@ -154,21 +169,25 @@ pub pure fn is_nonpositive(x: f32) -> bool {\n  *\n  * This is the same as `f32::is_positive`.)\n  */\n+#[inline(always)]\n pub pure fn is_nonnegative(x: f32) -> bool {\n   return x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n+#[inline(always)]\n pub pure fn is_zero(x: f32) -> bool {\n     return x == 0.0f32 || x == -0.0f32;\n }\n \n /// Returns true if `x`is an infinite number\n+#[inline(always)]\n pub pure fn is_infinite(x: f32) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n+#[inline(always)]\n pub pure fn is_finite(x: f32) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n@@ -219,45 +238,63 @@ pub mod consts {\n     pub const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n+#[inline(always)]\n pub pure fn signbit(x: f32) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n+#[inline(always)]\n pub pure fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n }\n \n #[cfg(notest)]\n impl f32 : cmp::Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n+    #[inline(always)]\n     pure fn ne(&self, other: &f32) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl f32 : cmp::Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n+    #[inline(always)]\n     pure fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n }\n \n impl f32: num::Num {\n+    #[inline(always)]\n     pure fn add(&self, other: &f32) -> f32 { return *self + *other; }\n+    #[inline(always)]\n     pure fn sub(&self, other: &f32) -> f32 { return *self - *other; }\n+    #[inline(always)]\n     pure fn mul(&self, other: &f32) -> f32 { return *self * *other; }\n+    #[inline(always)]\n     pure fn div(&self, other: &f32) -> f32 { return *self / *other; }\n+    #[inline(always)]\n     pure fn modulo(&self, other: &f32) -> f32 { return *self % *other; }\n+    #[inline(always)]\n     pure fn neg(&self)                -> f32 { return -*self;        }\n \n+    #[inline(always)]\n     pure fn to_int(&self)         -> int { return *self as int; }\n+    #[inline(always)]\n     static pure fn from_int(n: int) -> f32 { return n as f32;    }\n }\n \n impl f32: num::Zero {\n+    #[inline(always)]\n     static pure fn zero() -> f32 { 0.0 }\n }\n \n impl f32: num::One {\n+    #[inline(always)]\n     static pure fn one() -> f32 { 1.0 }\n }\n "}, {"sha": "cbcdc2e81e6ec8f514833a5d5c24182e6acc224f", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -132,35 +132,49 @@ pub const infinity: f64 = 1.0_f64/0.0_f64;\n \n pub const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n+#[inline(always)]\n pub pure fn is_NaN(f: f64) -> bool { f != f }\n \n+#[inline(always)]\n pub pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n+#[inline(always)]\n pub pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n+#[inline(always)]\n pub pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n+#[inline(always)]\n pub pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n+#[inline(always)]\n pub pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n+#[inline(always)]\n pub pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n+#[inline(always)]\n pub pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n+#[inline(always)]\n pub pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n+#[inline(always)]\n pub pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n+#[inline(always)]\n pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n+#[inline(always)]\n pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n+#[inline(always)]\n pub pure fn is_positive(x: f64) -> bool\n     { return x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n+#[inline(always)]\n pub pure fn is_negative(x: f64) -> bool\n     { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n@@ -169,6 +183,7 @@ pub pure fn is_negative(x: f64) -> bool\n  *\n  * This is the same as `f64::is_negative`.\n  */\n+#[inline(always)]\n pub pure fn is_nonpositive(x: f64) -> bool {\n   return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n@@ -178,21 +193,25 @@ pub pure fn is_nonpositive(x: f64) -> bool {\n  *\n  * This is the same as `f64::positive`.\n  */\n+#[inline(always)]\n pub pure fn is_nonnegative(x: f64) -> bool {\n   return x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n+#[inline(always)]\n pub pure fn is_zero(x: f64) -> bool {\n     return x == 0.0f64 || x == -0.0f64;\n }\n \n /// Returns true if `x`is an infinite number\n+#[inline(always)]\n pub pure fn is_infinite(x: f64) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n+#[inline(always)]\n pub pure fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n@@ -243,45 +262,63 @@ pub mod consts {\n     pub const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n+#[inline(always)]\n pub pure fn signbit(x: f64) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n+#[inline(always)]\n pub pure fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n }\n \n #[cfg(notest)]\n impl f64 : cmp::Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n+    #[inline(always)]\n     pure fn ne(&self, other: &f64) -> bool { (*self) != (*other) }\n }\n \n #[cfg(notest)]\n impl f64 : cmp::Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n+    #[inline(always)]\n     pure fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n impl f64: num::Num {\n+    #[inline(always)]\n     pure fn add(&self, other: &f64)    -> f64 { return *self + *other; }\n+    #[inline(always)]\n     pure fn sub(&self, other: &f64)    -> f64 { return *self - *other; }\n+    #[inline(always)]\n     pure fn mul(&self, other: &f64)    -> f64 { return *self * *other; }\n+    #[inline(always)]\n     pure fn div(&self, other: &f64)    -> f64 { return *self / *other; }\n+    #[inline(always)]\n     pure fn modulo(&self, other: &f64) -> f64 { return *self % *other; }\n+    #[inline(always)]\n     pure fn neg(&self)                -> f64 { return -*self;        }\n \n+    #[inline(always)]\n     pure fn to_int(&self)         -> int { return *self as int; }\n+    #[inline(always)]\n     static pure fn from_int(n: int) -> f64 { return n as f64;    }\n }\n \n impl f64: num::Zero {\n+    #[inline(always)]\n     static pure fn zero() -> f64 { 0.0 }\n }\n \n impl f64: num::One {\n+    #[inline(always)]\n     static pure fn one() -> f64 { 1.0 }\n }\n "}, {"sha": "4c79069ad0921f211be026a48d043afbfb013e71", "filename": "src/libcore/float.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -195,6 +195,7 @@ pub pure fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n+#[inline(always)]\n pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, true)\n }\n@@ -215,6 +216,7 @@ pub fn test_to_str_exact_do_decimal() {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n+#[inline(always)]\n pub pure fn to_str(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, false)\n }\n@@ -400,30 +402,44 @@ pub pure fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n+#[inline(always)]\n pub pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+#[inline(always)]\n pub pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+#[inline(always)]\n pub pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+#[inline(always)]\n pub pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+#[inline(always)]\n pub pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+#[inline(always)]\n pub pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+#[inline(always)]\n pub pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+#[inline(always)]\n pub pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n \n+#[inline(always)]\n pub pure fn abs(x: float) -> float {\n     unsafe { f64::abs(x as f64) as float }\n }\n+#[inline(always)]\n pub pure fn sqrt(x: float) -> float {\n     unsafe { f64::sqrt(x as f64) as float }\n }\n+#[inline(always)]\n pub pure fn atan(x: float) -> float {\n     unsafe { f64::atan(x as f64) as float }\n }\n+#[inline(always)]\n pub pure fn sin(x: float) -> float {\n     unsafe { f64::sin(x as f64) as float }\n }\n+#[inline(always)]\n pub pure fn cos(x: float) -> float {\n     unsafe { f64::cos(x as f64) as float }\n }\n+#[inline(always)]\n pub pure fn tan(x: float) -> float {\n     unsafe { f64::tan(x as f64) as float }\n }\n@@ -463,10 +479,12 @@ impl float: num::Num {\n }\n \n impl float: num::Zero {\n+    #[inline(always)]\n     static pure fn zero() -> float { 0.0 }\n }\n \n impl float: num::One {\n+    #[inline(always)]\n     static pure fn one() -> float { 1.0 }\n }\n "}, {"sha": "a04610d199520273d13678c4f4ec513c0187add6", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -32,25 +32,42 @@ pub const bytes : uint = (inst::bits / 8);\n pub const min_value: T = (-1 as T) << (bits - 1);\n pub const max_value: T = min_value - 1 as T;\n \n+#[inline(always)]\n pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+#[inline(always)]\n pub pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n \n+#[inline(always)]\n pub pure fn add(x: T, y: T) -> T { x + y }\n+#[inline(always)]\n pub pure fn sub(x: T, y: T) -> T { x - y }\n+#[inline(always)]\n pub pure fn mul(x: T, y: T) -> T { x * y }\n+#[inline(always)]\n pub pure fn div(x: T, y: T) -> T { x / y }\n+#[inline(always)]\n pub pure fn rem(x: T, y: T) -> T { x % y }\n \n+#[inline(always)]\n pub pure fn lt(x: T, y: T) -> bool { x < y }\n+#[inline(always)]\n pub pure fn le(x: T, y: T) -> bool { x <= y }\n+#[inline(always)]\n pub pure fn eq(x: T, y: T) -> bool { x == y }\n+#[inline(always)]\n pub pure fn ne(x: T, y: T) -> bool { x != y }\n+#[inline(always)]\n pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+#[inline(always)]\n pub pure fn gt(x: T, y: T) -> bool { x > y }\n \n+#[inline(always)]\n pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+#[inline(always)]\n pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+#[inline(always)]\n pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+#[inline(always)]\n pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n@@ -64,46 +81,64 @@ pub fn range(lo: T, hi: T, it: fn(T) -> bool) {\n }\n \n /// Computes the bitwise complement\n+#[inline(always)]\n pub pure fn compl(i: T) -> T {\n     -1 as T ^ i\n }\n \n /// Computes the absolute value\n+#[inline(always)]\n pub pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n #[cfg(notest)]\n impl T : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n+    #[inline(always)]\n     pure fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n+    #[inline(always)]\n     pure fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n+    #[inline(always)]\n     pure fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n }\n \n #[cfg(notest)]\n impl T : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    #[inline(always)]\n     pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl T: num::Num {\n+    #[inline(always)]\n     pure fn add(&self, other: &T)    -> T { return *self + *other; }\n+    #[inline(always)]\n     pure fn sub(&self, other: &T)    -> T { return *self - *other; }\n+    #[inline(always)]\n     pure fn mul(&self, other: &T)    -> T { return *self * *other; }\n+    #[inline(always)]\n     pure fn div(&self, other: &T)    -> T { return *self / *other; }\n+    #[inline(always)]\n     pure fn modulo(&self, other: &T) -> T { return *self % *other; }\n+    #[inline(always)]\n     pure fn neg(&self)              -> T { return -*self;        }\n \n+    #[inline(always)]\n     pure fn to_int(&self)         -> int { return *self as int; }\n+    #[inline(always)]\n     static pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n impl T: num::Zero {\n+    #[inline(always)]\n     static pure fn zero() -> T { 0 }\n }\n \n impl T: num::One {\n+    #[inline(always)]\n     static pure fn one() -> T { 1 }\n }\n \n@@ -158,16 +193,19 @@ pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n }\n \n /// Parse a string to an int\n+#[inline(always)]\n pub pure fn from_str(s: &str) -> Option<T>\n {\n     parse_bytes(str::to_bytes(s), 10u)\n }\n \n impl T : FromStr {\n+    #[inline(always)]\n     static pure fn from_str(s: &str) -> Option<T> { from_str(s) }\n }\n \n /// Convert to a string in a given base\n+#[inline(always)]\n pub pure fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n@@ -176,6 +214,7 @@ pub pure fn to_str(n: T, radix: uint) -> ~str {\n     }\n }\n \n+#[inline(always)]\n pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n     if n < 0 as T {\n         uint::to_str_bytes(true, -n as uint, radix, f)\n@@ -185,6 +224,7 @@ pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n }\n \n /// Convert to a string\n+#[inline(always)]\n pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n #[test]"}, {"sha": "942db1c5f292673815c422ff905471ede8d6153c", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -24,29 +24,38 @@ use option::Option;\n use self::inst::{IMPL_T, EACH, SIZE_HINT};\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n+    #[inline(always)]\n     pure fn each(&self, blk: fn(v: &A) -> bool) { EACH(self, blk) }\n+    #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { SIZE_HINT(self) }\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n+    #[inline(always)]\n     pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n+    #[inline(always)]\n     pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n+    #[inline(always)]\n     pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n+    #[inline(always)]\n     pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n         iter::foldl(self, move b0, blk)\n     }\n+    #[inline(always)]\n     pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n+    #[inline(always)]\n     pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n+    #[inline(always)]\n     pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n@@ -55,22 +64,29 @@ impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n }\n \n impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n+    #[inline(always)]\n     pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    #[inline(always)]\n     pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n+    #[inline(always)]\n     pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n+    #[inline(always)]\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    #[inline(always)]\n     pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n impl<A: Copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n+    #[inline(always)]\n     pure fn min(&self) -> A { iter::min(self) }\n+    #[inline(always)]\n     pure fn max(&self) -> A { iter::max(self) }\n }\n "}, {"sha": "754b8f8b72fc8b3dec87c88a9017360c7fa05821", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -47,6 +47,7 @@ mod inst {\n         }\n     }\n \n+    #[inline(always)]\n     pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n         Some(self.len())\n     }"}, {"sha": "af788989e9c0f03d222b12abf908243869a11e79", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -20,6 +20,7 @@ mod inst {\n     *\n     * Attempts to access this dvec during iteration will fail.\n     */\n+    #[inline(always)]\n     pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n         unsafe {\n             do self.swap |v| {\n@@ -29,6 +30,7 @@ mod inst {\n         }\n     }\n \n+    #[inline(always)]\n     pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n         Some(self.len())\n     }"}, {"sha": "986dbf7f3d1862693fbb02a4e9dd41c3c7dec9c8", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -14,13 +14,15 @@ mod inst {\n     #[allow(non_camel_case_types)]\n     pub type IMPL_T<A> = Option<A>;\n \n+    #[inline(always)]\n     pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n         match *self {\n             None => (),\n             Some(ref a) => { f(a); }\n         }\n     }\n \n+    #[inline(always)]\n     pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n         match *self {\n             None => Some(0),"}, {"sha": "4ea845543d1acc27cef1e42c6936c6f06077fa2a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -88,6 +88,7 @@ pub trait Buildable<A> {\n                                 builder: fn(push: pure fn(A))) -> self;\n }\n \n+#[inline(always)]\n pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n                                     blk: fn(uint, &A) -> bool) {\n     let mut i = 0;\n@@ -97,6 +98,7 @@ pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n     }\n }\n \n+#[inline(always)]\n pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n                                   blk: fn(&A) -> bool) -> bool {\n     for self.each |a| {\n@@ -105,6 +107,7 @@ pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n     return true;\n }\n \n+#[inline(always)]\n pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n                                   blk: fn(&A) -> bool) -> bool {\n     for self.each |a| {\n@@ -113,6 +116,7 @@ pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n     return false;\n }\n \n+#[inline(always)]\n pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n     self: &IA, prd: fn(&A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n@@ -122,6 +126,7 @@ pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n     }\n }\n \n+#[inline(always)]\n pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n                                            op: fn(&A) -> B)\n     -> ~[B] {\n@@ -132,6 +137,7 @@ pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n     }\n }\n \n+#[inline(always)]\n pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n     self: &IA, op: fn(&A) -> IB) -> ~[B] {\n     do vec::build |push| {\n@@ -143,6 +149,7 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n     }\n }\n \n+#[inline(always)]\n pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n                                       blk: fn(&B, &A) -> B)\n     -> B {\n@@ -153,17 +160,20 @@ pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n     move b\n }\n \n+#[inline(always)]\n pub pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy (*r), ~[*a]))\n }\n \n+#[inline(always)]\n pub pure fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n     for self.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n+#[inline(always)]\n pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n     do foldl(self, 0) |count, value| {\n         if *value == *x {\n@@ -174,6 +184,7 @@ pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n     }\n }\n \n+#[inline(always)]\n pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n     -> Option<uint>\n {\n@@ -189,6 +200,7 @@ pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n // iter interface, such as would provide \"reach\" in addition to \"each\". as is,\n // it would have to be implemented with foldr, which is too inefficient.\n \n+#[inline(always)]\n pub pure fn repeat(times: uint, blk: fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n@@ -197,6 +209,7 @@ pub pure fn repeat(times: uint, blk: fn() -> bool) {\n     }\n }\n \n+#[inline(always)]\n pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n@@ -211,6 +224,7 @@ pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     }\n }\n \n+#[inline(always)]\n pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n@@ -225,6 +239,7 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     }\n }\n \n+#[inline(always)]\n pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n                                    f: fn(&A) -> bool) -> Option<A> {\n     for self.each |i| {\n@@ -275,6 +290,7 @@ pub pure fn build_sized_opt<A,B: Buildable<A>>(\n // Functions that combine iteration and building\n \n /// Apply a function to each element of an iterable and return the results\n+#[inline(always)]\n pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U)\n     -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n@@ -290,6 +306,7 @@ pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U)\n  * Creates a generic sequence of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n+#[inline(always)]\n pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n                                         op: InitOp<T>) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n@@ -304,6 +321,7 @@ pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n+#[inline(always)]\n pub pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint,\n                                                 t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {"}, {"sha": "8395526276c8ee73bd56fe76416fcc2eeb636149", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -35,22 +35,29 @@ pub mod raw {\n \n }\n \n+#[inline(always)]\n pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n     unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n #[cfg(notest)]\n impl<T:Eq> @const T : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &@const T) -> bool { *(*self) == *(*other) }\n+    #[inline(always)]\n     pure fn ne(&self, other: &@const T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> @const T : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &@const T) -> bool { *(*self) < *(*other) }\n+    #[inline(always)]\n     pure fn le(&self, other: &@const T) -> bool { *(*self) <= *(*other) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &@const T) -> bool { *(*self) >= *(*other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &@const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "f3eb62a3a3ad03758c36a692e7e5c48ec0a22c6d", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -22,15 +22,21 @@ use cmp::{Eq, Ord};\n \n #[cfg(notest)]\n impl () : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, _other: &()) -> bool { true }\n+    #[inline(always)]\n     pure fn ne(&self, _other: &()) -> bool { false }\n }\n \n #[cfg(notest)]\n impl () : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, _other: &()) -> bool { false }\n+    #[inline(always)]\n     pure fn le(&self, _other: &()) -> bool { true }\n+    #[inline(always)]\n     pure fn ge(&self, _other: &()) -> bool { true }\n+    #[inline(always)]\n     pure fn gt(&self, _other: &()) -> bool { false }\n }\n "}, {"sha": "414027bb77e6a904c22dec51446379d99473d776", "filename": "src/libcore/option.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -59,6 +59,7 @@ pub enum Option<T> {\n     Some(T),\n }\n \n+#[inline(always)]\n pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n     /*!\n     Gets the value out of an option\n@@ -81,6 +82,7 @@ pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n     }\n }\n \n+#[inline(always)]\n pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     /*!\n     Gets an immutable reference to the value inside an option.\n@@ -102,12 +104,14 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n+#[inline(always)]\n pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n+#[inline(always)]\n pub pure fn map_consume<T, U>(opt: Option<T>,\n                               f: fn(v: T) -> U) -> Option<U> {\n     /*!\n@@ -117,6 +121,7 @@ pub pure fn map_consume<T, U>(opt: Option<T>,\n     if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n+#[inline(always)]\n pub pure fn chain<T, U>(opt: Option<T>,\n                         f: fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n@@ -130,6 +135,7 @@ pub pure fn chain<T, U>(opt: Option<T>,\n     }\n }\n \n+#[inline(always)]\n pub pure fn chain_ref<T, U>(opt: &Option<T>,\n                             f: fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n@@ -140,6 +146,7 @@ pub pure fn chain_ref<T, U>(opt: &Option<T>,\n     match *opt { Some(ref x) => f(x), None => None }\n }\n \n+#[inline(always)]\n pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost some() value, or none if both are none.\n@@ -160,37 +167,43 @@ pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n     }\n }\n \n+#[inline(always)]\n pub pure fn is_none<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n     match *opt { None => true, Some(_) => false }\n }\n \n+#[inline(always)]\n pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n+#[inline(always)]\n pub pure fn get_or_zero<T: Copy Zero>(opt: Option<T>) -> T {\n     //! Returns the contained value or zero (for this type)\n \n     match opt { Some(copy x) => x, None => Zero::zero() }\n }\n \n+#[inline(always)]\n pub pure fn get_or_default<T: Copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n     match opt { Some(copy x) => x, None => def }\n }\n \n+#[inline(always)]\n pub pure fn map_default<T, U>(opt: &Option<T>, def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => move def, Some(ref t) => f(t) }\n }\n \n+#[inline(always)]\n pub pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n     //! Performs an operation on the contained value by reference\n     match *opt { None => (), Some(ref t) => f(t) }\n@@ -234,6 +247,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n     unwrap(util::replace(opt, None))\n }\n \n+#[inline(always)]\n pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     match move opt {"}, {"sha": "fb14820113e00b92eaae7d620c99627b5a11930e", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -18,15 +18,21 @@ use cmp::{Eq, Ord};\n \n #[cfg(notest)]\n impl<T:Eq> ~const T : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &~const T) -> bool { *(*self) == *(*other) }\n+    #[inline(always)]\n     pure fn ne(&self, other: &~const T) -> bool { *(*self) != *(*other) }\n }\n \n #[cfg(notest)]\n impl<T:Ord> ~const T : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &~const T) -> bool { *(*self) < *(*other) }\n+    #[inline(always)]\n     pure fn le(&self, other: &~const T) -> bool { *(*self) <= *(*other) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &~const T) -> bool { *(*self) >= *(*other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &~const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "33770d727f929f2d803652d635f908e5d65f0f80", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -108,9 +108,11 @@ pub pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n pub pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Returns true if the pointer is equal to the null pointer.\n+#[inline(always)]\n pub pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n+#[inline(always)]\n pub pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n@@ -231,32 +233,38 @@ impl<T> *mut T: Ptr<T> {\n // Equality for pointers\n #[cfg(notest)]\n impl<T> *const T : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a == b;\n     }\n+    #[inline(always)]\n     pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n }\n \n // Comparison for pointers\n #[cfg(notest)]\n impl<T> *const T : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a < b;\n     }\n+    #[inline(always)]\n     pure fn le(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a <= b;\n     }\n+    #[inline(always)]\n     pure fn ge(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a >= b;\n     }\n+    #[inline(always)]\n     pure fn gt(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n@@ -267,9 +275,11 @@ impl<T> *const T : Ord {\n // Equality for region pointers\n #[cfg(notest)]\n impl<T:Eq> &const T : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: & &self/const T) -> bool {\n         return *(*self) == *(*other);\n     }\n+    #[inline(always)]\n     pure fn ne(&self, other: & &self/const T) -> bool {\n         return *(*self) != *(*other);\n     }\n@@ -278,15 +288,19 @@ impl<T:Eq> &const T : Eq {\n // Comparison for region pointers\n #[cfg(notest)]\n impl<T:Ord> &const T : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: & &self/const T) -> bool {\n         *(*self) < *(*other)\n     }\n+    #[inline(always)]\n     pure fn le(&self, other: & &self/const T) -> bool {\n         *(*self) <= *(*other)\n     }\n+    #[inline(always)]\n     pure fn ge(&self, other: & &self/const T) -> bool {\n         *(*self) >= *(*other)\n     }\n+    #[inline(always)]\n     pure fn gt(&self, other: & &self/const T) -> bool {\n         *(*self) > *(*other)\n     }"}, {"sha": "9a09f1901ff7c355bb0fcb09f1344d8d685e7ed7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -39,6 +39,7 @@ pub enum Result<T, U> {\n  *\n  * If the result is an error\n  */\n+#[inline(always)]\n pub pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n@@ -55,6 +56,7 @@ pub pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n  *\n  * If the result is an error\n  */\n+#[inline(always)]\n pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n     match *res {\n         Ok(ref t) => t,\n@@ -71,6 +73,7 @@ pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n  *\n  * If the result is not an error\n  */\n+#[inline(always)]\n pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(copy u) => u,\n@@ -79,6 +82,7 @@ pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n }\n \n /// Returns true if the result is `ok`\n+#[inline(always)]\n pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n     match *res {\n       Ok(_) => true,\n@@ -87,6 +91,7 @@ pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n }\n \n /// Returns true if the result is `err`\n+#[inline(always)]\n pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n@@ -97,6 +102,7 @@ pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n+#[inline(always)]\n pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n@@ -119,6 +125,7 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n+#[inline(always)]\n pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match move res {\n@@ -135,6 +142,7 @@ pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n+#[inline(always)]\n pub pure fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: fn(t: V) -> Result<T, U>)\n@@ -159,6 +167,7 @@ pub pure fn chain_err<T, U, V>(\n  *         print_buf(buf)\n  *     }\n  */\n+#[inline(always)]\n pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n@@ -174,6 +183,7 @@ pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n+#[inline(always)]\n pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n     match *res {\n       Ok(_) => (),\n@@ -195,6 +205,7 @@ pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n  *         parse_bytes(buf)\n  *     }\n  */\n+#[inline(always)]\n pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n@@ -211,6 +222,7 @@ pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n+#[inline(always)]\n pub pure fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n@@ -289,6 +301,7 @@ impl<T, E: Copy> Result<T, E> {\n  *         assert incd == ~[2u, 3u, 4u];\n  *     }\n  */\n+#[inline(always)]\n pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n@@ -302,6 +315,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n     return Ok(move vs);\n }\n \n+#[inline(always)]\n pub fn map_opt<T,U:Copy,V:Copy>(\n     o_t: &Option<T>, op: fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n \n@@ -323,6 +337,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n+#[inline(always)]\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n@@ -345,6 +360,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * error.  This could be implemented using `map2()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n+#[inline(always)]\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n "}, {"sha": "22e187d7768e628ba8170a0094b05f07e819afa4", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -25,74 +25,95 @@ use vec;\n pub trait ToStr { pub pure fn to_str() -> ~str; }\n \n impl int: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::int::str(self) }\n }\n impl i8: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::i8::str(self) }\n }\n impl i16: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::i16::str(self) }\n }\n impl i32: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::i32::str(self) }\n }\n impl i64: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::i64::str(self) }\n }\n impl uint: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::uint::str(self) }\n }\n impl u8: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::u8::str(self) }\n }\n impl u16: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::u16::str(self) }\n }\n impl u32: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::u32::str(self) }\n }\n impl u64: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::u64::str(self) }\n }\n impl float: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::float::to_str(self, 4u) }\n }\n impl f32: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::float::to_str(self as float, 4u) }\n }\n impl f64: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::float::to_str(self as float, 4u) }\n }\n impl bool: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::bool::to_str(self) }\n }\n impl (): ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ~\"()\" }\n }\n impl ~str: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { copy self }\n }\n impl &str: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::str::from_slice(self) }\n }\n impl @str: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ::str::from_slice(self) }\n }\n \n impl<A: ToStr Copy, B: ToStr Copy> (A, B): ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str {\n         let (a, b) = self;\n         ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\")\"\n     }\n }\n impl<A: ToStr Copy, B: ToStr Copy, C: ToStr Copy> (A, B, C): ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str {\n         let (a, b, c) = self;\n         ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\", \" + c.to_str() + ~\")\"\n     }\n }\n \n impl<A: ToStr> ~[A]: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str unsafe {\n         // Bleh -- not really unsafe\n         // push_str and push_char\n@@ -108,9 +129,11 @@ impl<A: ToStr> ~[A]: ToStr {\n }\n \n impl<A: ToStr> @A: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ~\"@\" + (*self).to_str() }\n }\n impl<A: ToStr> ~A: ToStr {\n+    #[inline(always)]\n     pure fn to_str() -> ~str { ~\"~\" + (*self).to_str() }\n }\n "}, {"sha": "c497a2f3c7f14365a3b60c043aa6e04518b429ed", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -27,18 +27,21 @@ pub trait CopyableTuple<T, U> {\n impl<T: Copy, U: Copy> (T, U): CopyableTuple<T, U> {\n \n     /// Return the first element of self\n+    #[inline(always)]\n     pure fn first() -> T {\n         let (t, _) = self;\n         return t;\n     }\n \n     /// Return the second element of self\n+    #[inline(always)]\n     pure fn second() -> U {\n         let (_, u) = self;\n         return u;\n     }\n \n     /// Return the results of swapping the two elements of self\n+    #[inline(always)]\n     pure fn swap() -> (U, T) {\n         let (t, u) = self;\n         return (u, t);\n@@ -52,11 +55,13 @@ pub trait ImmutableTuple<T, U> {\n }\n \n impl<T, U> (T, U): ImmutableTuple<T, U> {\n+    #[inline(always)]\n     pure fn first_ref(&self) -> &self/T {\n         match *self {\n             (ref t, _) => t,\n         }\n     }\n+    #[inline(always)]\n     pure fn second_ref(&self) -> &self/U {\n         match *self {\n             (_, ref u) => u,\n@@ -70,6 +75,7 @@ pub trait ExtendedTupleOps<A,B> {\n }\n \n impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n+    #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n             (ref a, ref b) => {\n@@ -78,6 +84,7 @@ impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n         }\n     }\n \n+    #[inline(always)]\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n@@ -89,6 +96,7 @@ impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n \n impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n \n+    #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n             (ref a, ref b) => {\n@@ -97,6 +105,7 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n         }\n     }\n \n+    #[inline(always)]\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n@@ -108,6 +117,7 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n \n #[cfg(notest)]\n impl<A: Eq, B: Eq> (A, B) : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => match other {\n@@ -117,11 +127,13 @@ impl<A: Eq, B: Eq> (A, B) : Eq {\n             }\n         }\n     }\n+    #[inline(always)]\n     pure fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<A: Ord, B: Ord> (A, B) : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => {\n@@ -136,13 +148,17 @@ impl<A: Ord, B: Ord> (A, B) : Ord {\n             }\n         }\n     }\n+    #[inline(always)]\n     pure fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n }\n \n #[cfg(notest)]\n impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => match other {\n@@ -153,11 +169,13 @@ impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n             }\n         }\n     }\n+    #[inline(always)]\n     pure fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => {\n@@ -174,8 +192,11 @@ impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n             }\n         }\n     }\n+    #[inline(always)]\n     pure fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n "}, {"sha": "a7eb2f80725532dfc65466e7d36e31ea948abbec", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=50cd3c18f5cb07f5c12ad6f1cbe872f5971fec32", "patch": "@@ -30,25 +30,42 @@ pub const bytes : uint = (inst::bits / 8);\n pub const min_value: T = 0 as T;\n pub const max_value: T = 0 as T - 1 as T;\n \n+#[inline(always)]\n pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+#[inline(always)]\n pub pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n \n+#[inline(always)]\n pub pure fn add(x: T, y: T) -> T { x + y }\n+#[inline(always)]\n pub pure fn sub(x: T, y: T) -> T { x - y }\n+#[inline(always)]\n pub pure fn mul(x: T, y: T) -> T { x * y }\n+#[inline(always)]\n pub pure fn div(x: T, y: T) -> T { x / y }\n+#[inline(always)]\n pub pure fn rem(x: T, y: T) -> T { x % y }\n \n+#[inline(always)]\n pub pure fn lt(x: T, y: T) -> bool { x < y }\n+#[inline(always)]\n pub pure fn le(x: T, y: T) -> bool { x <= y }\n+#[inline(always)]\n pub pure fn eq(x: T, y: T) -> bool { x == y }\n+#[inline(always)]\n pub pure fn ne(x: T, y: T) -> bool { x != y }\n+#[inline(always)]\n pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+#[inline(always)]\n pub pure fn gt(x: T, y: T) -> bool { x > y }\n \n+#[inline(always)]\n pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+#[inline(always)]\n pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+#[inline(always)]\n pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+#[inline(always)]\n pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n@@ -62,41 +79,58 @@ pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n }\n \n /// Computes the bitwise complement\n+#[inline(always)]\n pub pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n #[cfg(notest)]\n impl T : Ord {\n+    #[inline(always)]\n     pure fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n+    #[inline(always)]\n     pure fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n+    #[inline(always)]\n     pure fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n+    #[inline(always)]\n     pure fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n }\n \n #[cfg(notest)]\n impl T : Eq {\n+    #[inline(always)]\n     pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n+    #[inline(always)]\n     pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n \n impl T: num::Num {\n+    #[inline(always)]\n     pure fn add(&self, other: &T)    -> T { return *self + *other; }\n+    #[inline(always)]\n     pure fn sub(&self, other: &T)    -> T { return *self - *other; }\n+    #[inline(always)]\n     pure fn mul(&self, other: &T)    -> T { return *self * *other; }\n+    #[inline(always)]\n     pure fn div(&self, other: &T)    -> T { return *self / *other; }\n+    #[inline(always)]\n     pure fn modulo(&self, other: &T) -> T { return *self % *other; }\n+    #[inline(always)]\n     pure fn neg(&self)              -> T { return -*self;        }\n \n+    #[inline(always)]\n     pure fn to_int(&self)         -> int { return *self as int; }\n+    #[inline(always)]\n     static pure fn from_int(n: int) -> T   { return n as T;      }\n }\n \n impl T: num::Zero {\n+    #[inline(always)]\n     static pure fn zero() -> T { 0 }\n }\n \n impl T: num::One {\n+    #[inline(always)]\n     static pure fn one() -> T { 1 }\n }\n \n@@ -145,12 +179,14 @@ pub pure fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n }\n \n /// Parse a string to an int\n+#[inline(always)]\n pub pure fn from_str(s: &str) -> Option<T>\n {\n     parse_bytes(str::to_bytes(s), 10u)\n }\n \n impl T : FromStr {\n+    #[inline(always)]\n     static pure fn from_str(s: &str) -> Option<T> { from_str(s) }\n }\n \n@@ -177,6 +213,7 @@ pub fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n  *\n  * Fails if `radix` < 2 or `radix` > 16\n  */\n+#[inline(always)]\n pub pure fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n@@ -230,6 +267,7 @@ pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n }\n \n /// Convert to a string\n+#[inline(always)]\n pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n #[test]"}]}