{"sha": "ccfb3ebf0310444804542c93e079a78c20bf5415", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZmIzZWJmMDMxMDQ0NDgwNDU0MmM5M2UwNzlhNzhjMjBiZjU0MTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-12T06:41:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-14T16:25:18Z"}, "message": "rusti: Remove #[allow(vecs_implicitly_copyable)]", "tree": {"sha": "c40f9f7b05e48dc25efa745f675479c7e6f8d882", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c40f9f7b05e48dc25efa745f675479c7e6f8d882"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccfb3ebf0310444804542c93e079a78c20bf5415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccfb3ebf0310444804542c93e079a78c20bf5415", "html_url": "https://github.com/rust-lang/rust/commit/ccfb3ebf0310444804542c93e079a78c20bf5415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccfb3ebf0310444804542c93e079a78c20bf5415/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "html_url": "https://github.com/rust-lang/rust/commit/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "a8fa9d0c0a72012cafd02b86dee6713267030d37", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=ccfb3ebf0310444804542c93e079a78c20bf5415", "patch": "@@ -125,7 +125,7 @@ fn fold_enum(\n                             }.get();\n \n                             pprust::variant_to_str(\n-                                ast_variant, extract::interner())\n+                                &ast_variant, extract::interner())\n                         }\n                         _ => fail!(\"enum variant not bound to an enum item\")\n                     }"}, {"sha": "7e2ad69c88e5b8ebe0f2ef995c5cc72ced9d7ede", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=ccfb3ebf0310444804542c93e079a78c20bf5415", "patch": "@@ -18,14 +18,12 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[allow(vecs_implicitly_copyable,\n-        non_implicitly_copyable_typarams)];\n-\n extern mod std(vers = \"0.7-pre\");\n extern mod rustc(vers = \"0.7-pre\");\n extern mod syntax(vers = \"0.7-pre\");\n \n use core::*;\n+use core::cell::Cell;\n use rustc::driver::{driver, session};\n use syntax::{ast, diagnostic};\n use syntax::ast_util::*;\n@@ -71,8 +69,8 @@ fn with_pp(intr: @token::ident_interner,\n  * because it has to parse the statements and view_items on each\n  * input.\n  */\n-fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n-    let view_items = if blk.node.view_items.len() > 0 {\n+fn record(mut repl: Repl, blk: &ast::blk, intr: @token::ident_interner) -> Repl {\n+    if blk.node.view_items.len() > 0 {\n         let new_view_items = do with_pp(intr) |pp, writer| {\n             for blk.node.view_items.each |view_item| {\n                 pprust::print_view_item(pp, *view_item);\n@@ -82,9 +80,9 @@ fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n \n         debug!(\"new view items %s\", new_view_items);\n \n-        repl.view_items + \"\\n\" + new_view_items\n-    } else { repl.view_items };\n-    let stmts = if blk.node.stmts.len() > 0 {\n+        repl.view_items = repl.view_items + \"\\n\" + new_view_items\n+    }\n+    if blk.node.stmts.len() > 0 {\n         let new_stmts = do with_pp(intr) |pp, writer| {\n             for blk.node.stmts.each |stmt| {\n                 match stmt.node {\n@@ -105,24 +103,21 @@ fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n \n         debug!(\"new stmts %s\", new_stmts);\n \n-        repl.stmts + \"\\n\" + new_stmts\n-    } else { repl.stmts };\n-\n-    Repl{\n-        view_items: view_items,\n-        stmts: stmts,\n-        .. repl\n+        repl.stmts = repl.stmts + \"\\n\" + new_stmts\n     }\n+\n+    return repl;\n }\n \n /// Run an input string in a Repl, returning the new Repl.\n fn run(repl: Repl, input: ~str) -> Repl {\n+    let binary = @copy repl.binary;\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n-        binary: @repl.binary,\n+        binary: binary,\n         addl_lib_search_paths: repl.lib_search_paths.map(|p| Path(*p)),\n         jit: true,\n-        .. *session::basic_options()\n+        .. copy *session::basic_options()\n     };\n \n     debug!(\"building driver input\");\n@@ -138,7 +133,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     debug!(\"building driver configuration\");\n     let cfg = driver::build_configuration(sess,\n-                                          @repl.binary,\n+                                          binary,\n                                           &wrapped);\n \n     let outputs = driver::build_output_filenames(&wrapped, &None, &None, sess);\n@@ -151,7 +146,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     for crate.node.module.items.each |item| {\n         match item.node {\n-            ast::item_fn(_, _, _, _, blk) => {\n+            ast::item_fn(_, _, _, _, ref blk) => {\n                 if item.ident == sess.ident_of(\"main\") {\n                     opt = blk.node.expr;\n                 }\n@@ -160,10 +155,11 @@ fn run(repl: Repl, input: ~str) -> Repl {\n         }\n     }\n \n-    let blk = match opt.get().node {\n-        ast::expr_call(_, exprs, _) => {\n+    let e = opt.unwrap();\n+    let blk = match e.node {\n+        ast::expr_call(_, ref exprs, _) => {\n             match exprs[0].node {\n-                ast::expr_block(blk) => @blk,\n+                ast::expr_block(ref blk) => blk,\n                 _ => fail!()\n             }\n         }\n@@ -182,15 +178,16 @@ fn run(repl: Repl, input: ~str) -> Repl {\n fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n     match do task::try {\n         let src_path = Path(src_filename);\n+        let binary = @copy binary;\n         let options = @session::options {\n-            binary: @binary,\n+            binary: binary,\n             addl_lib_search_paths: ~[os::getcwd()],\n-            .. *session::basic_options()\n+            .. copy *session::basic_options()\n         };\n-        let input = driver::file_input(src_path);\n+        let input = driver::file_input(copy src_path);\n         let sess = driver::build_session(options, diagnostic::emit);\n         *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess, @binary, &input);\n+        let cfg = driver::build_configuration(sess, binary, &input);\n         let outputs = driver::build_output_filenames(\n             &input, &None, &None, sess);\n         // If the library already exists and is newer than the source\n@@ -233,7 +230,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n \n /// Tries to get a line from rl after outputting a prompt. Returns\n /// None if no input was read (e.g. EOF was reached).\n-fn get_line(use_rl: bool, prompt: ~str) -> Option<~str> {\n+fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n     if use_rl {\n         let result = unsafe { rl::read(prompt) };\n \n@@ -280,11 +277,11 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for args.each |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.substr(0, arg.len() - 3).to_owned(), *arg)\n+                    (arg.substr(0, arg.len() - 3).to_owned(), copy *arg)\n                 } else {\n-                    (*arg, arg + ~\".rs\")\n+                    (copy *arg, arg + \".rs\")\n                 };\n-                match compile_crate(filename, repl.binary) {\n+                match compile_crate(filename, copy repl.binary) {\n                     Some(_) => loaded_crates.push(crate),\n                     None => { }\n                 }\n@@ -311,7 +308,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             let mut multiline_cmd = ~\"\";\n             let mut end_multiline = false;\n             while (!end_multiline) {\n-                match get_line(use_rl, ~\"rusti| \") {\n+                match get_line(use_rl, \"rusti| \") {\n                     None => fail!(\"unterminated multiline command :{ .. :}\"),\n                     Some(line) => {\n                         if str::trim(line) == ~\":}\" {\n@@ -334,14 +331,14 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n             use_rl: bool)\n     -> Option<Repl> {\n-    if line.starts_with(~\":\") {\n+    if line.starts_with(\":\") {\n         let full = line.substr(1, line.len() - 1);\n         let mut split = ~[];\n         for str::each_word(full) |word| { split.push(word.to_owned()) }\n         let len = split.len();\n \n         if len > 0 {\n-            let cmd = split[0];\n+            let cmd = copy split[0];\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n@@ -361,9 +358,10 @@ fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n         }\n     }\n \n-    let r = *repl;\n+    let line = Cell(line);\n+    let r = Cell(copy *repl);\n     let result = do task::try {\n-        run(r, line)\n+        run(r.take(), line.take())\n     };\n \n     if result.is_ok() {\n@@ -378,7 +376,7 @@ pub fn main() {\n     let out = io::stdout();\n     let mut repl = Repl {\n         prompt: ~\"rusti> \",\n-        binary: args[0],\n+        binary: copy args[0],\n         running: true,\n         view_items: ~\"\",\n         lib_search_paths: ~[],"}, {"sha": "a47d4ba5329ca31ce45f54b2b04e7bbe61f84724", "filename": "src/librusti/wrapper.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibrusti%2Fwrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibrusti%2Fwrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fwrapper.rs?ref=ccfb3ebf0310444804542c93e079a78c20bf5415", "patch": "@@ -13,13 +13,15 @@\n #[allow(implicit_copies)];\n #[allow(managed_heap_memory)];\n #[allow(non_camel_case_types)];\n-#[allow(non_implicitly_copyable_typarams)];\n #[allow(owned_heap_memory)];\n #[allow(path_statement)];\n #[allow(unrecognized_lint)];\n #[allow(unused_imports)];\n-#[allow(vecs_implicitly_copyable)];\n #[allow(while_true)];\n+#[allow(dead_assignment)];\n+#[allow(unused_variable)];\n+#[allow(unused_unsafe)];\n+#[allow(unused_mut)];\n \n extern mod std;\n "}, {"sha": "d15a8fc0136d49be9b03cf602b5503bd62a31f89", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfb3ebf0310444804542c93e079a78c20bf5415/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=ccfb3ebf0310444804542c93e079a78c20bf5415", "patch": "@@ -28,7 +28,7 @@ pub mod rustrt {\n }\n \n /// Add a line to history\n-pub unsafe fn add_history(line: ~str) -> bool {\n+pub unsafe fn add_history(line: &str) -> bool {\n     do str::as_c_str(line) |buf| {\n         rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n     }\n@@ -40,21 +40,21 @@ pub unsafe fn set_history_max_len(len: int) -> bool {\n }\n \n /// Save line history to a file\n-pub unsafe fn save_history(file: ~str) -> bool {\n+pub unsafe fn save_history(file: &str) -> bool {\n     do str::as_c_str(file) |buf| {\n         rustrt::linenoiseHistorySave(buf) == 1 as c_int\n     }\n }\n \n /// Load line history from a file\n-pub unsafe fn load_history(file: ~str) -> bool {\n+pub unsafe fn load_history(file: &str) -> bool {\n     do str::as_c_str(file) |buf| {\n         rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n-pub unsafe fn read(prompt: ~str) -> Option<~str> {\n+pub unsafe fn read(prompt: &str) -> Option<~str> {\n     do str::as_c_str(prompt) |buf| {\n         let line = rustrt::linenoise(buf);\n "}]}