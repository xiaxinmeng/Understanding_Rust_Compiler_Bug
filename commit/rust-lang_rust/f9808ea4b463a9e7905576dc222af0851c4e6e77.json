{"sha": "f9808ea4b463a9e7905576dc222af0851c4e6e77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ODA4ZWE0YjQ2M2E5ZTc5MDU1NzZkYzIyMmFmMDg1MWM0ZTZlNzc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-18T09:38:57Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-07T00:40:18Z"}, "message": "Create a visitor for `TypeFoldable`s and use it to implement RegionEscape and HasTypeFlags (fixes #20298)", "tree": {"sha": "bab2a002d7a8596d9fc05c3d9dc96959a9fb4d6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bab2a002d7a8596d9fc05c3d9dc96959a9fb4d6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9808ea4b463a9e7905576dc222af0851c4e6e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9808ea4b463a9e7905576dc222af0851c4e6e77", "html_url": "https://github.com/rust-lang/rust/commit/f9808ea4b463a9e7905576dc222af0851c4e6e77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9808ea4b463a9e7905576dc222af0851c4e6e77/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5daa75373d870f255923aed37d99db73a661bd51", "url": "https://api.github.com/repos/rust-lang/rust/commits/5daa75373d870f255923aed37d99db73a661bd51", "html_url": "https://github.com/rust-lang/rust/commit/5daa75373d870f255923aed37d99db73a661bd51"}], "stats": {"total": 1224, "additions": 534, "deletions": 690}, "files": [{"sha": "a16e1c48330861f92ba5c97400d0ad3e880e0dca", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -404,7 +404,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         let value =\n             traits::fully_normalize(self.infcx,"}, {"sha": "a526586802cac6f23775f2dffe6b051cdb5c58cf", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -318,7 +318,7 @@ impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 }\n             }\n             _ => {\n-                ty::fold::super_fold_ty(self, t)\n+                t.fold_subitems_with(self)\n             }\n         }\n     }"}, {"sha": "7202c0a8052ed540418dea1dd8ec7ba71dfb90b3", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |\n             ty::TyParam(..) => {\n-                ty::fold::super_fold_ty(self, t)\n+                t.fold_subitems_with(self)\n             }\n         }\n     }"}, {"sha": "941fb05c3d01d9b8fda83de75224df03743a8bb6", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -512,7 +512,7 @@ pub struct CombinedSnapshot {\n }\n \n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     debug!(\"normalize_associated_type(t={:?})\", value);\n \n@@ -546,7 +546,7 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                                 result: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n@@ -570,7 +570,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     debug!(\"drain_fulfillment_cx(result={:?})\",\n            result);\n@@ -929,7 +929,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                          snapshot: &CombinedSnapshot,\n                          value: &T)\n                          -> T\n-        where T : TypeFoldable<'tcx> + HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         /*! See `higher_ranked::plug_leaks` */\n \n@@ -1201,7 +1201,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx> + HasTypeFlags\n+        where T: TypeFoldable<'tcx>\n     {\n         /*!\n          * Where possible, replaces type/int/float variables in"}, {"sha": "d89036faef945996f85d6338a41129d71104e446", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t0 = self.infcx.shallow_resolve(t);\n-            ty::fold::super_fold_ty(self, t0)\n+            t0.fold_subitems_with(self)\n         }\n     }\n }\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t0 = self.infcx.shallow_resolve(t);\n-            ty::fold::super_fold_ty(self, t0)\n+            t0.fold_subitems_with(self)\n         }\n     }\n \n@@ -133,7 +133,7 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                                 t));\n                 }\n                 _ => {\n-                    ty::fold::super_fold_ty(self, t)\n+                    t.fold_subitems_with(self)\n                 }\n             }\n         }"}, {"sha": "d935b51813a5b0d9b99f4a79bc805863e2c64975", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -674,7 +674,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 self.ty_for_param(p, t)\n             }\n             _ => {\n-                ty::fold::super_fold_ty(self, t)\n+                t.fold_subitems_with(self)\n             }\n         };\n "}, {"sha": "464b4dfb83bddeec0b751d0d17b00561d42fd2d4", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -185,7 +185,7 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                           obligation: &Obligation<'tcx, T>)\n                                           -> !\n-    where T: fmt::Display + TypeFoldable<'tcx> + HasTypeFlags\n+    where T: fmt::Display + TypeFoldable<'tcx>\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);"}, {"sha": "01c2f56123501e44d9f65383dde4bcabb12ff5b2", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -470,7 +470,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     debug!(\"normalize_param_env(value={:?})\", value);\n "}, {"sha": "9c317895c36657dad4b76ab28dbda4969743f377", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -202,7 +202,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n@@ -213,7 +213,7 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n                                           depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n@@ -245,7 +245,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n         }\n     }\n \n-    fn fold<T:TypeFoldable<'tcx> + HasTypeFlags>(&mut self, value: &T) -> T {\n+    fn fold<T:TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n         if !value.has_projection_types() {\n@@ -273,7 +273,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n         // normalize it when we instantiate those bound regions (which\n         // should occur eventually).\n \n-        let ty = ty::fold::super_fold_ty(self, ty);\n+        let ty = ty.fold_subitems_with(self);\n         match ty.sty {\n             ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n "}, {"sha": "a31fccbb3f71ee72c552997186ed12adc65fa2fb", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -965,7 +965,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match *candidate {\n             Ok(Some(_)) | Err(_) => true,\n             Ok(None) => {\n-                cache_fresh_trait_pred.0.input_types().has_infer_types()\n+                cache_fresh_trait_pred.0.trait_ref.substs.types.has_infer_types()\n             }\n         }\n     }"}, {"sha": "ea1657180657b9cdb025b0b4e857626c65e9e202", "filename": "src/librustc/middle/traits/structural_impls.rs", "status": "modified", "additions": 41, "deletions": 67, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -10,8 +10,7 @@\n \n use middle::traits;\n use middle::traits::project::Normalized;\n-use middle::ty::{HasTypeFlags, TypeFlags, RegionEscape};\n-use middle::ty::fold::{TypeFoldable, TypeFolder};\n+use middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n \n@@ -131,71 +130,6 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n-impl<'tcx, P: RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.predicate.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx, T: HasTypeFlags> HasTypeFlags for traits::Obligation<'tcx, T> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.predicate.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, T: HasTypeFlags> HasTypeFlags for Normalized<'tcx, T> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.value.has_type_flags(flags) ||\n-            self.obligations.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableImplData<'tcx, N> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.substs.has_type_flags(flags) ||\n-            self.nested.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableClosureData<'tcx, N> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.substs.has_type_flags(flags) ||\n-            self.nested.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableDefaultImplData<N> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.nested.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableBuiltinData<N> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.nested.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for traits::VtableObjectData<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.upcast_trait_ref.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::Vtable<'tcx, N> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        match *self {\n-            traits::VtableImpl(ref v) => v.has_type_flags(flags),\n-            traits::VtableDefaultImpl(ref t) => t.has_type_flags(flags),\n-            traits::VtableClosure(ref d) => d.has_type_flags(flags),\n-            traits::VtableFnPointer(ref d) => d.has_type_flags(flags),\n-            traits::VtableParam(ref n) => n.has_type_flags(flags),\n-            traits::VtableBuiltin(ref d) => d.has_type_flags(flags),\n-            traits::VtableObject(ref d) => d.has_type_flags(flags)\n-        }\n-    }\n-}\n-\n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n@@ -205,6 +139,10 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n             predicate: self.predicate.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicate.visit_with(visitor)\n+    }\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n@@ -215,6 +153,10 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n             nested: self.nested.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n+    }\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n@@ -225,6 +167,10 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureDa\n             nested: self.nested.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n+    }\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n@@ -234,6 +180,10 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultIm\n             nested: self.nested.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.nested.visit_with(visitor)\n+    }\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n@@ -242,6 +192,10 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinDa\n             nested: self.nested.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.nested.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n@@ -251,6 +205,10 @@ impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n             vtable_base: self.vtable_base\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.upcast_trait_ref.visit_with(visitor)\n+    }\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n@@ -269,6 +227,18 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            traits::VtableImpl(ref v) => v.visit_with(visitor),\n+            traits::VtableDefaultImpl(ref t) => t.visit_with(visitor),\n+            traits::VtableClosure(ref d) => d.visit_with(visitor),\n+            traits::VtableFnPointer(ref d) => d.visit_with(visitor),\n+            traits::VtableParam(ref n) => n.visit_with(visitor),\n+            traits::VtableBuiltin(ref d) => d.visit_with(visitor),\n+            traits::VtableObject(ref d) => d.visit_with(visitor),\n+        }\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n@@ -278,4 +248,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n             obligations: self.obligations.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.value.visit_with(visitor) || self.obligations.visit_with(visitor)\n+    }\n }"}, {"sha": "8d68c1da7f84e144a855a9487df30b6a4291332b", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 109, "deletions": 208, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -14,41 +14,51 @@\n //! instance of a \"folder\" (a type which implements `TypeFolder`). Then\n //! the setup is intended to be:\n //!\n-//!     T.fold_with(F) --calls--> F.fold_T(T) --calls--> super_fold_T(F, T)\n+//!   T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.fold_subitems_with(F)\n //!\n //! This way, when you define a new folder F, you can override\n-//! `fold_T()` to customize the behavior, and invoke `super_fold_T()`\n+//! `fold_T()` to customize the behavior, and invoke `T.fold_subitems_with()`\n //! to get the original behavior. Meanwhile, to actually fold\n //! something, you can just write `T.fold_with(F)`, which is\n //! convenient. (Note that `fold_with` will also transparently handle\n //! things like a `Vec<T>` where T is foldable and so on.)\n //!\n //! In this ideal setup, the only function that actually *does*\n-//! anything is `super_fold_T`, which traverses the type `T`. Moreover,\n-//! `super_fold_T` should only ever call `T.fold_with()`.\n+//! anything is `T.fold_subitems_with()`, which traverses the type `T`.\n+//! Moreover, `T.fold_subitems_with()` should only ever call `T.fold_with()`.\n //!\n //! In some cases, we follow a degenerate pattern where we do not have\n-//! a `fold_T` nor `super_fold_T` method. Instead, `T.fold_with`\n-//! traverses the structure directly. This is suboptimal because the\n-//! behavior cannot be overridden, but it's much less work to implement.\n-//! If you ever *do* need an override that doesn't exist, it's not hard\n-//! to convert the degenerate pattern into the proper thing.\n+//! a `fold_T` method. Instead, `T.fold_with` traverses the structure directly.\n+//! This is suboptimal because the behavior cannot be overridden, but it's\n+//! much less work to implement. If you ever *do* need an override that\n+//! doesn't exist, it's not hard to convert the degenerate pattern into the\n+//! proper thing.\n+//!\n+//! A `TypeFoldable` T can also be visited by a `TypeVisitor` V using similar setup:\n+//!   T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.visit_subitems_with(V).\n+//! These methods return true to indicate that the visitor has found what it is looking for\n+//! and does not need to visit anything else.\n \n use middle::region;\n use middle::subst;\n use middle::ty::adjustment;\n-use middle::ty::{self, Binder, Ty, RegionEscape};\n+use middle::ty::{self, Binder, Ty, RegionEscape, HasTypeFlags};\n \n use std::fmt;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n-///////////////////////////////////////////////////////////////////////////\n-// Two generic traits\n-\n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.fold_with(folder)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool;\n+    fn visit_subitems_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.visit_with(visitor)\n+    }\n }\n \n /// The TypeFolder trait defines the actual *folding*. There is a\n@@ -74,248 +84,77 @@ pub trait TypeFolder<'tcx> : Sized {\n         where T : TypeFoldable<'tcx>\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n-        super_fold_binder(self, t)\n+        t.fold_subitems_with(self)\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        super_fold_ty(self, t)\n+        t.fold_subitems_with(self)\n     }\n \n     fn fold_mt(&mut self, t: &ty::TypeAndMut<'tcx>) -> ty::TypeAndMut<'tcx> {\n-        super_fold_mt(self, t)\n+        t.fold_subitems_with(self)\n     }\n \n     fn fold_trait_ref(&mut self, t: &ty::TraitRef<'tcx>) -> ty::TraitRef<'tcx> {\n-        super_fold_trait_ref(self, t)\n+        t.fold_subitems_with(self)\n     }\n \n     fn fold_substs(&mut self,\n                    substs: &subst::Substs<'tcx>)\n                    -> subst::Substs<'tcx> {\n-        super_fold_substs(self, substs)\n+        substs.fold_subitems_with(self)\n     }\n \n     fn fold_fn_sig(&mut self,\n                    sig: &ty::FnSig<'tcx>)\n                    -> ty::FnSig<'tcx> {\n-        super_fold_fn_sig(self, sig)\n+        sig.fold_subitems_with(self)\n     }\n \n     fn fold_output(&mut self,\n                       output: &ty::FnOutput<'tcx>)\n                       -> ty::FnOutput<'tcx> {\n-        super_fold_output(self, output)\n+        output.fold_subitems_with(self)\n     }\n \n     fn fold_bare_fn_ty(&mut self,\n                        fty: &ty::BareFnTy<'tcx>)\n                        -> ty::BareFnTy<'tcx>\n     {\n-        super_fold_bare_fn_ty(self, fty)\n+        fty.fold_subitems_with(self)\n     }\n \n     fn fold_closure_ty(&mut self,\n                        fty: &ty::ClosureTy<'tcx>)\n                        -> ty::ClosureTy<'tcx> {\n-        super_fold_closure_ty(self, fty)\n+        fty.fold_subitems_with(self)\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        r\n+        r.fold_subitems_with(self)\n     }\n \n     fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n                                -> ty::ExistentialBounds<'tcx> {\n-        super_fold_existential_bounds(self, s)\n+        s.fold_subitems_with(self)\n     }\n \n     fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n                     -> adjustment::AutoRef<'tcx> {\n-        super_fold_autoref(self, ar)\n-    }\n-\n-    fn fold_item_substs(&mut self, i: ty::ItemSubsts<'tcx>) -> ty::ItemSubsts<'tcx> {\n-        super_fold_item_substs(self, i)\n+        ar.fold_subitems_with(self)\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// \"super\" routines: these are the default implementations for TypeFolder.\n-//\n-// They should invoke `foo.fold_with()` to do recursive folding.\n-\n-pub fn super_fold_binder<'tcx, T, U>(this: &mut T,\n-                                     binder: &Binder<U>)\n-                                     -> Binder<U>\n-    where T : TypeFolder<'tcx>, U : TypeFoldable<'tcx>\n-{\n-    this.enter_region_binder();\n-    let result = Binder(binder.0.fold_with(this));\n-    this.exit_region_binder();\n-    result\n-}\n-\n-pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                ty: Ty<'tcx>)\n-                                                -> Ty<'tcx> {\n-    let sty = match ty.sty {\n-        ty::TyBox(typ) => {\n-            ty::TyBox(typ.fold_with(this))\n-        }\n-        ty::TyRawPtr(ref tm) => {\n-            ty::TyRawPtr(tm.fold_with(this))\n-        }\n-        ty::TyArray(typ, sz) => {\n-            ty::TyArray(typ.fold_with(this), sz)\n-        }\n-        ty::TySlice(typ) => {\n-            ty::TySlice(typ.fold_with(this))\n-        }\n-        ty::TyEnum(tid, ref substs) => {\n-            let substs = substs.fold_with(this);\n-            ty::TyEnum(tid, this.tcx().mk_substs(substs))\n-        }\n-        ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n-            ty::TyTrait(box ty::TraitTy {\n-                principal: principal.fold_with(this),\n-                bounds: bounds.fold_with(this),\n-            })\n-        }\n-        ty::TyTuple(ref ts) => {\n-            ty::TyTuple(ts.fold_with(this))\n-        }\n-        ty::TyBareFn(opt_def_id, ref f) => {\n-            let bfn = f.fold_with(this);\n-            ty::TyBareFn(opt_def_id, this.tcx().mk_bare_fn(bfn))\n-        }\n-        ty::TyRef(r, ref tm) => {\n-            let r = r.fold_with(this);\n-            ty::TyRef(this.tcx().mk_region(r), tm.fold_with(this))\n-        }\n-        ty::TyStruct(did, ref substs) => {\n-            let substs = substs.fold_with(this);\n-            ty::TyStruct(did, this.tcx().mk_substs(substs))\n-        }\n-        ty::TyClosure(did, ref substs) => {\n-            let s = substs.fold_with(this);\n-            ty::TyClosure(did, s)\n-        }\n-        ty::TyProjection(ref data) => {\n-            ty::TyProjection(data.fold_with(this))\n-        }\n-        ty::TyBool | ty::TyChar | ty::TyStr |\n-        ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-        ty::TyError | ty::TyInfer(_) |\n-        ty::TyParam(..) => {\n-            ty.sty.clone()\n-        }\n-    };\n-    this.tcx().mk_ty(sty)\n-}\n-\n-pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    substs: &subst::Substs<'tcx>)\n-                                                    -> subst::Substs<'tcx> {\n-    let regions = match substs.regions {\n-        subst::ErasedRegions => {\n-            subst::ErasedRegions\n-        }\n-        subst::NonerasedRegions(ref regions) => {\n-            subst::NonerasedRegions(regions.fold_with(this))\n-        }\n-    };\n-\n-    subst::Substs { regions: regions,\n-                    types: substs.types.fold_with(this) }\n-}\n-\n-pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    sig: &ty::FnSig<'tcx>)\n-                                                    -> ty::FnSig<'tcx>\n-{\n-    ty::FnSig { inputs: sig.inputs.fold_with(this),\n-                output: sig.output.fold_with(this),\n-                variadic: sig.variadic }\n-}\n-\n-pub fn super_fold_output<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    output: &ty::FnOutput<'tcx>)\n-                                                    -> ty::FnOutput<'tcx> {\n-    match *output {\n-        ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(this)),\n-        ty::FnDiverging => ty::FnDiverging\n-    }\n-}\n-\n-pub fn super_fold_bare_fn_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                        fty: &ty::BareFnTy<'tcx>)\n-                                                        -> ty::BareFnTy<'tcx>\n-{\n-    ty::BareFnTy { sig: fty.sig.fold_with(this),\n-                   abi: fty.abi,\n-                   unsafety: fty.unsafety }\n-}\n-\n-pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                        fty: &ty::ClosureTy<'tcx>)\n-                                                        -> ty::ClosureTy<'tcx>\n-{\n-    ty::ClosureTy {\n-        sig: fty.sig.fold_with(this),\n-        unsafety: fty.unsafety,\n-        abi: fty.abi,\n-    }\n-}\n-\n-pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                       t: &ty::TraitRef<'tcx>)\n-                                                       -> ty::TraitRef<'tcx>\n-{\n-    let substs = t.substs.fold_with(this);\n-    ty::TraitRef {\n-        def_id: t.def_id,\n-        substs: this.tcx().mk_substs(substs),\n-    }\n-}\n-\n-pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                mt: &ty::TypeAndMut<'tcx>)\n-                                                -> ty::TypeAndMut<'tcx> {\n-    ty::TypeAndMut {ty: mt.ty.fold_with(this),\n-            mutbl: mt.mutbl}\n-}\n-\n-pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n-    this: &mut T,\n-    bounds: &ty::ExistentialBounds<'tcx>)\n-    -> ty::ExistentialBounds<'tcx>\n-{\n-    ty::ExistentialBounds {\n-        region_bound: bounds.region_bound.fold_with(this),\n-        builtin_bounds: bounds.builtin_bounds,\n-        projection_bounds: bounds.projection_bounds.fold_with(this),\n-    }\n-}\n+pub trait TypeVisitor<'tcx> : Sized {\n+    fn enter_region_binder(&mut self) { }\n+    fn exit_region_binder(&mut self) { }\n \n-pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                     autoref: &adjustment::AutoRef<'tcx>)\n-                                                     -> adjustment::AutoRef<'tcx>\n-{\n-    match *autoref {\n-        adjustment::AutoPtr(r, m) => {\n-            let r = r.fold_with(this);\n-            adjustment::AutoPtr(this.tcx().mk_region(r), m)\n-        }\n-        adjustment::AutoUnsafe(m) => adjustment::AutoUnsafe(m)\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        t.visit_subitems_with(self)\n     }\n-}\n \n-pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                         substs: ty::ItemSubsts<'tcx>)\n-                                                         -> ty::ItemSubsts<'tcx>\n-{\n-    ty::ItemSubsts {\n-        substs: substs.substs.fold_with(this),\n+    fn visit_region(&mut self, r: ty::Region) -> bool {\n+        r.visit_subitems_with(self)\n     }\n }\n \n@@ -333,7 +172,7 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let t1 = super_fold_ty(self, ty);\n+        let t1 = ty.fold_subitems_with(self);\n         (self.fldop)(t1)\n     }\n }\n@@ -495,7 +334,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n     }\n \n     pub fn no_late_bound_regions<T>(&self, value: &Binder<T>) -> Option<T>\n-        where T : TypeFoldable<'tcx> + RegionEscape\n+        where T : TypeFoldable<'tcx>\n     {\n         if value.0.has_escaping_regions() {\n             None\n@@ -561,7 +400,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n             return t;\n         }\n \n-        super_fold_ty(self, t)\n+        t.fold_subitems_with(self)\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n@@ -612,7 +451,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     Some(u) => return u\n                 }\n \n-                let t_norm = ty::fold::super_fold_ty(self, ty);\n+                let t_norm = ty.fold_subitems_with(self);\n                 self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n                 return t_norm;\n             }\n@@ -621,7 +460,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                 where T : TypeFoldable<'tcx>\n             {\n                 let u = self.tcx().anonymize_late_bound_regions(t);\n-                ty::fold::super_fold_binder(self, &u)\n+                u.fold_subitems_with(self)\n             }\n \n             fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n@@ -678,3 +517,65 @@ pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>,\n         shift_region(region, amount)\n     }))\n }\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> RegionEscape for T {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        struct RegionEscapeVisitor {\n+            depth: u32,\n+        }\n+\n+        impl<'tcx> TypeVisitor<'tcx> for RegionEscapeVisitor {\n+            fn enter_region_binder(&mut self) {\n+                self.depth += 1;\n+            }\n+\n+            fn exit_region_binder(&mut self) {\n+                self.depth -= 1;\n+            }\n+\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                t.region_depth > self.depth\n+            }\n+\n+            fn visit_region(&mut self, r: ty::Region) -> bool {\n+                r.escapes_depth(self.depth)\n+            }\n+        }\n+\n+        self.visit_with(&mut RegionEscapeVisitor { depth: depth })\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> HasTypeFlags for T {\n+    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n+        struct HasTypeFlagsVisitor {\n+            flags: ty::TypeFlags,\n+        }\n+\n+        impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n+            fn visit_ty(&mut self, t: Ty) -> bool {\n+                t.flags.get().intersects(self.flags)\n+            }\n+\n+            fn visit_region(&mut self, r: ty::Region) -> bool {\n+                if self.flags.intersects(ty::TypeFlags::HAS_LOCAL_NAMES) {\n+                    // does this represent a region that cannot be named\n+                    // in a global way? used in fulfillment caching.\n+                    match r {\n+                        ty::ReStatic | ty::ReEmpty => {}\n+                        _ => return true,\n+                    }\n+                }\n+                if self.flags.intersects(ty::TypeFlags::HAS_RE_INFER) {\n+                    match r {\n+                        ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n+                        _ => {}\n+                    }\n+                }\n+                false\n+            }\n+        }\n+\n+        self.visit_with(&mut HasTypeFlagsVisitor { flags: flags })\n+    }\n+}"}, {"sha": "137f60572bb45b75f81181febe0f060e77f388d6", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -15,7 +15,7 @@\n \n use middle::def_id::DefId;\n use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n-use middle::ty::{self, HasTypeFlags, Ty};\n+use middle::ty::{self, Ty};\n use middle::ty::error::{ExpectedFound, TypeError};\n use middle::ty::fold::TypeFoldable;\n use std::rc::Rc;\n@@ -80,7 +80,7 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n         where T: Relate<'a,'tcx>;\n }\n \n-pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> + HasTypeFlags {\n+pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n     fn relate<R:TypeRelation<'a,'tcx>>(relation: &mut R,\n                                        a: &Self,\n                                        b: &Self)"}, {"sha": "8d3a93e72f5423d6ec08f0a4caf8719c9b5cf5c1", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 352, "deletions": 386, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -11,399 +11,15 @@\n use middle::subst::{self, VecPerParamSpace};\n use middle::traits;\n use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n-use middle::ty::{HasTypeFlags, Lift, TypeFlags, RegionEscape};\n-use middle::ty::fold::{TypeFoldable, TypeFolder};\n+use middle::ty::Lift;\n+use middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::rc::Rc;\n use syntax::abi;\n use syntax::ptr::P;\n \n use rustc_front::hir;\n \n-// FIXME(#20298) -- all of these traits basically walk various\n-// structures to test whether types/regions are reachable with various\n-// properties. It should be possible to express them in terms of one\n-// common \"walker\" trait or something.\n-\n-impl<'tcx> RegionEscape for Ty<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.region_depth > depth\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::TraitTy<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.principal.has_regions_escaping_depth(depth) ||\n-            self.bounds.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::ExistentialBounds<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.region_bound.has_regions_escaping_depth(depth) ||\n-            self.projection_bounds.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::InstantiatedPredicates<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.predicates.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for subst::Substs<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.types.has_regions_escaping_depth(depth) ||\n-            self.regions.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::ClosureSubsts<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.func_substs.has_regions_escaping_depth(depth) ||\n-            self.upvar_tys.iter().any(|t| t.has_regions_escaping_depth(depth))\n-    }\n-}\n-\n-impl<T:RegionEscape> RegionEscape for Vec<T> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.iter().any(|t| t.has_regions_escaping_depth(depth))\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::FnSig<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.inputs.has_regions_escaping_depth(depth) ||\n-            self.output.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.iter_enumerated().any(|(space, _, t)| {\n-            if space == subst::FnSpace {\n-                t.has_regions_escaping_depth(depth+1)\n-            } else {\n-                t.has_regions_escaping_depth(depth)\n-            }\n-        })\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::TypeScheme<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.ty.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl RegionEscape for ty::Region {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.escapes_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::GenericPredicates<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.predicates.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::Predicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => data.has_regions_escaping_depth(depth),\n-            ty::Predicate::Equate(ref data) => data.has_regions_escaping_depth(depth),\n-            ty::Predicate::RegionOutlives(ref data) => data.has_regions_escaping_depth(depth),\n-            ty::Predicate::TypeOutlives(ref data) => data.has_regions_escaping_depth(depth),\n-            ty::Predicate::Projection(ref data) => data.has_regions_escaping_depth(depth),\n-            ty::Predicate::WellFormed(ty) => ty.has_regions_escaping_depth(depth),\n-            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for TraitRef<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||\n-            self.substs.regions.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for subst::RegionSubsts {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        match *self {\n-            subst::ErasedRegions => false,\n-            subst::NonerasedRegions(ref r) => {\n-                r.iter().any(|t| t.has_regions_escaping_depth(depth))\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx,T:RegionEscape> RegionEscape for ty::Binder<T> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.0.has_regions_escaping_depth(depth + 1)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::FnOutput<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        match *self {\n-            ty::FnConverging(t) => t.has_regions_escaping_depth(depth),\n-            ty::FnDiverging => false\n-        }\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::EquatePredicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::TraitPredicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.trait_ref.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<T:RegionEscape,U:RegionEscape> RegionEscape for ty::OutlivesPredicate<T,U> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::ProjectionPredicate<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.projection_ty.has_regions_escaping_depth(depth) ||\n-            self.ty.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl<'tcx> RegionEscape for ty::ProjectionTy<'tcx> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.trait_ref.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n-impl HasTypeFlags for () {\n-    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx,T:HasTypeFlags> HasTypeFlags for Vec<T> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self[..].has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx,T:HasTypeFlags> HasTypeFlags for [T] {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.iter().any(|p| p.has_type_flags(flags))\n-    }\n-}\n-\n-impl<'tcx,T:HasTypeFlags> HasTypeFlags for VecPerParamSpace<T> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.iter().any(|p| p.has_type_flags(flags))\n-    }\n-}\n-\n-impl HasTypeFlags for abi::Abi {\n-    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n-        false\n-    }\n-}\n-\n-impl HasTypeFlags for hir::Unsafety {\n-    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n-        false\n-    }\n-}\n-\n-impl HasTypeFlags for ty::BuiltinBounds {\n-    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::ClosureTy<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.sig.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::ClosureUpvar<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.ty.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::ExistentialBounds<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.projection_bounds.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::InstantiatedPredicates<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.predicates.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::Predicate<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => data.has_type_flags(flags),\n-            ty::Predicate::Equate(ref data) => data.has_type_flags(flags),\n-            ty::Predicate::RegionOutlives(ref data) => data.has_type_flags(flags),\n-            ty::Predicate::TypeOutlives(ref data) => data.has_type_flags(flags),\n-            ty::Predicate::Projection(ref data) => data.has_type_flags(flags),\n-            ty::Predicate::WellFormed(data) => data.has_type_flags(flags),\n-            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::TraitPredicate<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.trait_ref.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::EquatePredicate<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n-    }\n-}\n-\n-impl HasTypeFlags for ty::Region {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        if flags.intersects(TypeFlags::HAS_LOCAL_NAMES) {\n-            // does this represent a region that cannot be named in a global\n-            // way? used in fulfillment caching.\n-            match *self {\n-                ty::ReStatic | ty::ReEmpty => {}\n-                _ => return true\n-            }\n-        }\n-        if flags.intersects(TypeFlags::HAS_RE_INFER) {\n-            match *self {\n-                ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n-                _ => {}\n-            }\n-        }\n-        false\n-    }\n-}\n-\n-impl<T:HasTypeFlags,U:HasTypeFlags> HasTypeFlags for ty::OutlivesPredicate<T,U> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::ProjectionPredicate<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.projection_ty.has_type_flags(flags) || self.ty.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::ProjectionTy<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.trait_ref.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for Ty<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.flags.get().intersects(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for TypeAndMut<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.ty.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for TraitRef<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.substs.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for subst::Substs<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.types.has_type_flags(flags) || match self.regions {\n-            subst::ErasedRegions => false,\n-            subst::NonerasedRegions(ref r) => r.has_type_flags(flags)\n-        }\n-    }\n-}\n-\n-impl<'tcx,T> HasTypeFlags for Option<T>\n-    where T : HasTypeFlags\n-{\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.iter().any(|t| t.has_type_flags(flags))\n-    }\n-}\n-\n-impl<'tcx,T> HasTypeFlags for Rc<T>\n-    where T : HasTypeFlags\n-{\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        (**self).has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx,T> HasTypeFlags for Box<T>\n-    where T : HasTypeFlags\n-{\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        (**self).has_type_flags(flags)\n-    }\n-}\n-\n-impl<T> HasTypeFlags for ty::Binder<T>\n-    where T : HasTypeFlags\n-{\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.0.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::FnOutput<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        match *self {\n-            ty::FnConverging(t) => t.has_type_flags(flags),\n-            ty::FnDiverging => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::FnSig<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.inputs.iter().any(|t| t.has_type_flags(flags)) ||\n-            self.output.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::BareFnTy<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.sig.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx> HasTypeFlags for ty::ClosureSubsts<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.func_substs.has_type_flags(flags) ||\n-            self.upvar_tys.iter().any(|t| t.has_type_flags(flags))\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n@@ -511,6 +127,10 @@ macro_rules! CopyImpls {\n                 fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n                     *self\n                 }\n+\n+                fn visit_with<F: TypeVisitor<'tcx>>(&self, _: &mut F) -> bool {\n+                    false\n+                }\n             }\n         )+\n     }\n@@ -522,43 +142,81 @@ impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_with(folder))\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n         let content: T = (**self).fold_with(folder);\n         box content\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.enter_region_binder();\n+        let result = ty::Binder(self.0.fold_with(folder));\n+        folder.exit_region_binder();\n+        result\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.enter_region_binder();\n+        if self.0.visit_with(visitor) { return true }\n+        visitor.exit_region_binder();\n+        false\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> P<[T]> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n@@ -582,60 +240,244 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n         }\n         result\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let mut entered_region_binder = false;\n+        let result = self.iter_enumerated().any(|(space, index, t)| {\n+            if space == subst::FnSpace && index == 0 {\n+                visitor.enter_region_binder();\n+                entered_region_binder = true;\n+            }\n+            t.visit_with(visitor)\n+        });\n+        if entered_region_binder {\n+            visitor.exit_region_binder();\n+        }\n+        result\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::TraitTy {\n+            principal: self.principal.fold_with(folder),\n+            bounds: self.bounds.fold_with(folder),\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.principal.visit_with(visitor) || self.bounds.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n         folder.fold_ty(*self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let sty = match self.sty {\n+            ty::TyBox(typ) => ty::TyBox(typ.fold_with(folder)),\n+            ty::TyRawPtr(ref tm) => ty::TyRawPtr(tm.fold_with(folder)),\n+            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n+            ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n+            ty::TyEnum(tid, ref substs) => {\n+                let substs = substs.fold_with(folder);\n+                ty::TyEnum(tid, folder.tcx().mk_substs(substs))\n+            }\n+            ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n+            ty::TyTuple(ref ts) => ty::TyTuple(ts.fold_with(folder)),\n+            ty::TyBareFn(opt_def_id, ref f) => {\n+                let bfn = f.fold_with(folder);\n+                ty::TyBareFn(opt_def_id, folder.tcx().mk_bare_fn(bfn))\n+            }\n+            ty::TyRef(r, ref tm) => {\n+                let r = r.fold_with(folder);\n+                ty::TyRef(folder.tcx().mk_region(r), tm.fold_with(folder))\n+            }\n+            ty::TyStruct(did, ref substs) => {\n+                let substs = substs.fold_with(folder);\n+                ty::TyStruct(did, folder.tcx().mk_substs(substs))\n+            }\n+            ty::TyClosure(did, ref substs) => {\n+                ty::TyClosure(did, substs.fold_with(folder))\n+            }\n+            ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n+            ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n+            ty::TyParam(..) => self.sty.clone(),\n+        };\n+        folder.tcx().mk_ty(sty)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_ty(self)\n+    }\n+\n+    fn visit_subitems_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self.sty {\n+            ty::TyBox(typ) => typ.visit_with(visitor),\n+            ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n+            ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n+            ty::TySlice(typ) => typ.visit_with(visitor),\n+            ty::TyEnum(_tid, ref substs) => substs.visit_with(visitor),\n+            ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n+            ty::TyTuple(ref ts) => ts.visit_with(visitor),\n+            ty::TyBareFn(_opt_def_id, ref f) => f.visit_with(visitor),\n+            ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n+            ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n+            ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n+            ty::TyProjection(ref data) => data.visit_with(visitor),\n+            ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n+            ty::TyParam(..) => false,\n+        }\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n         folder.fold_bare_fn_ty(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::BareFnTy { sig: self.sig.fold_with(folder),\n+                       abi: self.abi,\n+                       unsafety: self.unsafety }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.sig.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n         folder.fold_closure_ty(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+       ty::ClosureTy {\n+            sig: self.sig.fold_with(folder),\n+            unsafety: self.unsafety,\n+            abi: self.abi,\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.sig.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeAndMut<'tcx> {\n         folder.fold_mt(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n         folder.fold_output(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(folder)),\n+            ty::FnDiverging => ty::FnDiverging\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::FnConverging(ref ty) => ty.visit_with(visitor),\n+            ty::FnDiverging => false,\n+        }\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n         folder.fold_fn_sig(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::FnSig { inputs: self.inputs.fold_with(folder),\n+                    output: self.output.fold_with(folder),\n+                    variadic: self.variadic }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.inputs.visit_with(visitor) || self.output.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         folder.fold_trait_ref(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let substs = self.substs.fold_with(folder);\n+        ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: folder.tcx().mk_substs(substs),\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_region(*self)\n+    }\n+\n+    fn visit_subitems_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n         folder.fold_substs(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let regions = match self.regions {\n+            subst::ErasedRegions => subst::ErasedRegions,\n+            subst::NonerasedRegions(ref regions) => {\n+                subst::NonerasedRegions(regions.fold_with(folder))\n+            }\n+        };\n+\n+        subst::Substs { regions: regions,\n+                        types: self.types.fold_with(folder) }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.types.visit_with(visitor) || match self.regions {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref regions) => regions.visit_with(visitor),\n+        }\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n@@ -646,6 +488,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n             upvar_tys: self.upvar_tys.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.func_substs.visit_with(visitor) || self.upvar_tys.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n@@ -654,24 +500,61 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n             substs: self.substs.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::adjustment::AutoRef<'tcx> {\n         folder.fold_autoref(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ty::adjustment::AutoPtr(r, m) => {\n+                let r = r.fold_with(folder);\n+                ty::adjustment::AutoPtr(folder.tcx().mk_region(r), m)\n+            }\n+            ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::adjustment::AutoPtr(r, _m) => r.visit_with(visitor),\n+            ty::adjustment::AutoUnsafe(_m) => false,\n+        }\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n         folder.fold_existential_bounds(self)\n     }\n+\n+    fn fold_subitems_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ExistentialBounds {\n+            region_bound: self.region_bound.fold_with(folder),\n+            builtin_bounds: self.builtin_bounds,\n+            projection_bounds: self.projection_bounds.fold_with(folder),\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.region_bound.visit_with(visitor) || self.projection_bounds.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n@@ -686,6 +569,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.default.visit_with(visitor) ||\n+            self.object_lifetime_default.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n@@ -701,6 +589,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n                 ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::ObjectLifetimeDefault::Specific(r) => r.visit_with(visitor),\n+            _ => false,\n+        }\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n@@ -713,6 +608,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n             bounds: self.bounds.fold_with(folder)\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.bounds.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n@@ -722,6 +621,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n             regions: self.regions.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n@@ -730,6 +633,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n             predicates: self.predicates.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicates.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n@@ -751,6 +658,18 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::ObjectSafe(trait_def_id),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n+            ty::Predicate::Equate(ref binder) => binder.visit_with(visitor),\n+            ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n+            ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),\n+            ty::Predicate::Projection(ref binder) => binder.visit_with(visitor),\n+            ty::Predicate::WellFormed(data) => data.visit_with(visitor),\n+            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+        }\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n@@ -760,6 +679,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n             ty: self.ty.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.projection_ty.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n@@ -769,6 +692,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n             item_name: self.item_name,\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.trait_ref.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n@@ -777,13 +704,21 @@ impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n             predicates: self.predicates.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicates.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n         ty::EquatePredicate(self.0.fold_with(folder),\n                             self.1.fold_with(folder))\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n@@ -792,6 +727,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n             trait_ref: self.trait_ref.fold_with(folder)\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.trait_ref.visit_with(visitor)\n+    }\n }\n \n impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n@@ -802,6 +741,10 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n         ty::OutlivesPredicate(self.0.fold_with(folder),\n                               self.1.fold_with(folder))\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n@@ -812,6 +755,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n             ty: self.ty.fold_with(folder),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor)\n+    }\n }\n \n impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n@@ -826,4 +773,23 @@ impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where '\n             free_id_outlive: self.free_id_outlive,\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.free_substs.visit_with(visitor) ||\n+            self.implicit_region_bound.visit_with(visitor) ||\n+            self.caller_bounds.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::TypeScheme {\n+            generics: self.generics.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.generics.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n }"}, {"sha": "423cd62a13f81f1a3d1fc2bf8ff55646c2d2c9c9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -256,6 +256,10 @@ impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n                                               -> TraitAndProjections<'tcx> {\n         TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n+\n+    fn visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+    }\n }\n \n impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {"}, {"sha": "31b5839bd2167eccc80f701b5a2fc7999b730abc", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -469,7 +469,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -650,7 +650,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,"}, {"sha": "0eaab6b3dbb98ea8c0f678d01ea07b1446d459b9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -299,7 +299,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   param_substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)"}, {"sha": "91916efa882778226c992ec971cc40d6f8c50eaa", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -11,7 +11,6 @@\n use middle::infer::InferCtxt;\n use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n                      SelectionContext, ObligationCause};\n-use middle::ty::HasTypeFlags;\n use middle::ty::fold::TypeFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -23,7 +22,7 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n+    where T : TypeFoldable<'tcx>\n {\n     debug!(\"normalize_associated_types_in(value={:?})\", value);\n     let mut selcx = SelectionContext::new(infcx);"}, {"sha": "f99124664bbcd56bc2166e9d65816d765eb575f5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9808ea4b463a9e7905576dc222af0851c4e6e77/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f9808ea4b463a9e7905576dc222af0851c4e6e77", "patch": "@@ -318,7 +318,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n-        where T : TypeFoldable<'tcx> + HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         let mut fulfillment_cx = self.infcx.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n@@ -1334,7 +1334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-        where T : TypeFoldable<'tcx> + HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n@@ -1360,7 +1360,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + HasTypeFlags\n+        where T : TypeFoldable<'tcx>\n     {\n         self.inh.normalize_associated_types_in(span, self.body_id, value)\n     }"}]}