{"sha": "8deeac153fcca97f6a5185b322f8d65d59fab5f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZWVhYzE1M2ZjY2E5N2Y2YTUxODViMzIyZjhkNjVkNTlmYWI1ZjQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-21T12:06:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-21T12:06:36Z"}, "message": "Rollup merge of #69910 - cjgillot:polym, r=Zoxc\n\nAvoid query type in generics\n\nThere are at the moment roughly 170 queries in librustc.\nThe way ty::query is structured, a lot of code is duplicated for each query.\nI suspect this to be responsible for a part of librustc'c compile time.\n\nThis PR reduces the amount of code generic on the query,\nreplacing it by code generic on the key-value types.\n\nThis is split out of #69808,\nand should not contain the perf regression.\n\ncc #65031", "tree": {"sha": "530da7556bd6026c5cdfb00735c465b28e43fd82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/530da7556bd6026c5cdfb00735c465b28e43fd82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8deeac153fcca97f6a5185b322f8d65d59fab5f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedgNNCRBK7hj4Ov3rIwAAdHIIAAiL7eJl1dy/vXb7FUftXVon\nC2PuP7QQPQhsVh7Qp0chFE2X8JOwmtB2bIUGn4wtQza/zYuGWGwjDaZ9jW72uGBN\nYWqa5FLhka4XeJdiGJNIJfkVOSqXD+Wj6dqG3wekJ9q3r9U1capTgLVM4fMQkaoZ\npBlH8AqhK3U2w3qYosqSFXJVcw2YlL7O1F7s7eUKwbzYL0FLVEbN+wVg5P3jY+j0\npq96KtXajplm4DzvC16qnodC7ajNsjML7GwipoKHWWTPGUhSh1LPRmOFoeRaB69f\nraAVfEj8mn37baWGPO8rVf7VAWTRc875ynlu1l9SY0Ehg5OIbWY+J4bSKFMeh7c=\n=VJrl\n-----END PGP SIGNATURE-----\n", "payload": "tree 530da7556bd6026c5cdfb00735c465b28e43fd82\nparent fd3f9176c35f7918c46066af57078a96696e59c7\nparent 8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22\nauthor Dylan DPC <dylan.dpc@gmail.com> 1584792396 +0100\ncommitter GitHub <noreply@github.com> 1584792396 +0100\n\nRollup merge of #69910 - cjgillot:polym, r=Zoxc\n\nAvoid query type in generics\n\nThere are at the moment roughly 170 queries in librustc.\nThe way ty::query is structured, a lot of code is duplicated for each query.\nI suspect this to be responsible for a part of librustc'c compile time.\n\nThis PR reduces the amount of code generic on the query,\nreplacing it by code generic on the key-value types.\n\nThis is split out of #69808,\nand should not contain the perf regression.\n\ncc #65031\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8deeac153fcca97f6a5185b322f8d65d59fab5f4", "html_url": "https://github.com/rust-lang/rust/commit/8deeac153fcca97f6a5185b322f8d65d59fab5f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8deeac153fcca97f6a5185b322f8d65d59fab5f4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd3f9176c35f7918c46066af57078a96696e59c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd3f9176c35f7918c46066af57078a96696e59c7", "html_url": "https://github.com/rust-lang/rust/commit/fd3f9176c35f7918c46066af57078a96696e59c7"}, {"sha": "8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "url": "https://api.github.com/repos/rust-lang/rust/commits/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22", "html_url": "https://github.com/rust-lang/rust/commit/8aa13289b5fbfcbdf5afb19d15a41a15d8f8aa22"}], "stats": {"total": 427, "additions": 226, "deletions": 201}, "files": [{"sha": "a11b3bcba3ed30dc7e8774f8e200e3db01ca1e9c", "filename": "src/librustc/ty/query/caches.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs?ref=8deeac153fcca97f6a5185b322f8d65d59fab5f4", "patch": "@@ -1,82 +1,94 @@\n use crate::dep_graph::DepNodeIndex;\n-use crate::ty::query::config::QueryAccessors;\n use crate::ty::query::plumbing::{QueryLookup, QueryState, QueryStateShard};\n use crate::ty::TyCtxt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n use std::default::Default;\n use std::hash::Hash;\n+use std::marker::PhantomData;\n \n pub(crate) trait CacheSelector<K, V> {\n-    type Cache: QueryCache<K, V>;\n+    type Cache: QueryCache<Key = K, Value = V>;\n }\n \n-pub(crate) trait QueryCache<K, V>: Default {\n+pub(crate) trait QueryCache: Default {\n+    type Key;\n+    type Value;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryState<'tcx, Q>,\n+        state: &'tcx QueryState<'tcx, Self>,\n         get_cache: GetCache,\n-        key: K,\n+        key: Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        Q: QueryAccessors<'tcx>,\n-        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R;\n+        GetCache: for<'a> Fn(\n+            &'a mut QueryStateShard<'tcx, Self::Key, Self::Sharded>,\n+        ) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&Self::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(Self::Key, QueryLookup<'tcx, Self::Key, Self::Sharded>) -> R;\n \n     fn complete(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         lock_sharded_storage: &mut Self::Sharded,\n-        key: K,\n-        value: V,\n+        key: Self::Key,\n+        value: Self::Value,\n         index: DepNodeIndex,\n     );\n \n     fn iter<R, L>(\n         &self,\n         shards: &Sharded<L>,\n         get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n-        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a Self::Key, &'a Self::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n     ) -> R;\n }\n \n pub struct DefaultCacheSelector;\n \n impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n-    type Cache = DefaultCache;\n+    type Cache = DefaultCache<K, V>;\n }\n \n-#[derive(Default)]\n-pub struct DefaultCache;\n+pub struct DefaultCache<K, V>(PhantomData<(K, V)>);\n+\n+impl<K, V> Default for DefaultCache<K, V> {\n+    fn default() -> Self {\n+        DefaultCache(PhantomData)\n+    }\n+}\n \n-impl<K: Eq + Hash, V: Clone> QueryCache<K, V> for DefaultCache {\n+impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n+    type Key = K;\n+    type Value = V;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryState<'tcx, Q>,\n+        state: &'tcx QueryState<'tcx, Self>,\n         get_cache: GetCache,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        Q: QueryAccessors<'tcx>,\n-        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n+        GetCache:\n+            for<'a> Fn(&'a mut QueryStateShard<'tcx, K, Self::Sharded>) -> &'a mut Self::Sharded,\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;"}, {"sha": "72a0fdf1567268f03338dbd0db6afc97ad70fb85", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=8deeac153fcca97f6a5185b322f8d65d59fab5f4", "patch": "@@ -2,7 +2,7 @@ use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::{DepKind, DepNode};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n-use crate::ty::query::{Query, QueryState};\n+use crate::ty::query::QueryState;\n use crate::ty::TyCtxt;\n use rustc_data_structures::profiling::ProfileCategory;\n use rustc_hir::def_id::DefId;\n@@ -28,18 +28,15 @@ pub trait QueryConfig<'tcx> {\n pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n+    const DEP_KIND: DepKind;\n \n-    type Cache: QueryCache<Self::Key, Self::Value>;\n-\n-    fn query(key: Self::Key) -> Query<'tcx>;\n+    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self>;\n+    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self::Cache>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n \n-    fn dep_kind() -> DepKind;\n-\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value;\n \n@@ -62,10 +59,7 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M\n-where\n-    <M as QueryAccessors<'tcx>>::Cache: QueryCache<DefId, <M as QueryConfig<'tcx>>::Value>,\n-{\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "32ba13b1dbe9a5cfe2740383518400befde1ad28", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=8deeac153fcca97f6a5185b322f8d65d59fab5f4", "patch": "@@ -56,13 +56,12 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n-use std::convert::TryFrom;\n use std::ops::Deref;\n use std::sync::Arc;\n \n #[macro_use]\n mod plumbing;\n-pub use self::plumbing::CycleError;\n+pub(crate) use self::plumbing::CycleError;\n use self::plumbing::*;\n \n mod stats;"}, {"sha": "0bfcae5fa2e6692a54857b30abf9d4f8eb5710ee", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 172, "deletions": 153, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=8deeac153fcca97f6a5185b322f8d65d59fab5f4", "patch": "@@ -2,10 +2,10 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::{QueryAccessors, QueryDescription};\n-use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n+use crate::ty::query::config::QueryDescription;\n+use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n use crate::ty::{self, TyCtxt};\n@@ -20,44 +20,47 @@ use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, FatalError, H\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n+use std::convert::TryFrom;\n+use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::num::NonZeroU32;\n use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(crate) struct QueryStateShard<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n-    pub(super) cache: <<D as QueryAccessors<'tcx>>::Cache as QueryCache<D::Key, D::Value>>::Sharded,\n-    pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n+pub(crate) struct QueryStateShard<'tcx, K, C> {\n+    cache: C,\n+    active: FxHashMap<K, QueryResult<'tcx>>,\n \n     /// Used to generate unique ids for active jobs.\n-    pub(super) jobs: u32,\n+    jobs: u32,\n }\n \n-impl<'tcx, Q: QueryAccessors<'tcx>> QueryStateShard<'tcx, Q> {\n-    fn get_cache(\n-        &mut self,\n-    ) -> &mut <<Q as QueryAccessors<'tcx>>::Cache as QueryCache<Q::Key, Q::Value>>::Sharded {\n+impl<'tcx, K, C> QueryStateShard<'tcx, K, C> {\n+    fn get_cache(&mut self) -> &mut C {\n         &mut self.cache\n     }\n }\n \n-impl<'tcx, Q: QueryAccessors<'tcx>> Default for QueryStateShard<'tcx, Q> {\n-    fn default() -> QueryStateShard<'tcx, Q> {\n+impl<'tcx, K, C: Default> Default for QueryStateShard<'tcx, K, C> {\n+    fn default() -> QueryStateShard<'tcx, K, C> {\n         QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n     }\n }\n \n-pub(crate) struct QueryState<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n-    pub(super) cache: D::Cache,\n-    pub(super) shards: Sharded<QueryStateShard<'tcx, D>>,\n+pub(crate) struct QueryState<'tcx, C: QueryCache> {\n+    cache: C,\n+    shards: Sharded<QueryStateShard<'tcx, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub(super) cache_hits: AtomicUsize,\n }\n \n-impl<'tcx, Q: QueryAccessors<'tcx>> QueryState<'tcx, Q> {\n-    pub(super) fn get_lookup<K: Hash>(&'tcx self, key: &K) -> QueryLookup<'tcx, Q> {\n+impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n+    pub(super) fn get_lookup<K2: Hash>(\n+        &'tcx self,\n+        key: &K2,\n+    ) -> QueryLookup<'tcx, C::Key, C::Sharded> {\n         // We compute the key's hash once and then use it for both the\n         // shard lookup and the hashmap lookup. This relies on the fact\n         // that both of them use `FxHasher`.\n@@ -72,7 +75,7 @@ impl<'tcx, Q: QueryAccessors<'tcx>> QueryState<'tcx, Q> {\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-pub(super) enum QueryResult<'tcx> {\n+enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion.\n     Started(QueryJob<'tcx>),\n \n@@ -81,25 +84,54 @@ pub(super) enum QueryResult<'tcx> {\n     Poisoned,\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx>> QueryState<'tcx, M> {\n-    pub fn iter_results<R>(\n+impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n+    pub(super) fn iter_results<R>(\n         &self,\n         f: impl for<'a> FnOnce(\n-            Box<dyn Iterator<Item = (&'a M::Key, &'a M::Value, DepNodeIndex)> + 'a>,\n+            Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n         ) -> R,\n     ) -> R {\n         self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n     }\n-    pub fn all_inactive(&self) -> bool {\n+    pub(super) fn all_inactive(&self) -> bool {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n     }\n+\n+    pub(super) fn try_collect_active_jobs(\n+        &self,\n+        kind: DepKind,\n+        make_query: fn(C::Key) -> Query<'tcx>,\n+        jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<'tcx>>,\n+    ) -> Option<()>\n+    where\n+        C::Key: Clone,\n+    {\n+        // We use try_lock_shards here since we are called from the\n+        // deadlock handler, and this shouldn't be locked.\n+        let shards = self.shards.try_lock_shards()?;\n+        let shards = shards.iter().enumerate();\n+        jobs.extend(shards.flat_map(|(shard_id, shard)| {\n+            shard.active.iter().filter_map(move |(k, v)| {\n+                if let QueryResult::Started(ref job) = *v {\n+                    let id =\n+                        QueryJobId { job: job.id, shard: u16::try_from(shard_id).unwrap(), kind };\n+                    let info = QueryInfo { span: job.span, query: make_query(k.clone()) };\n+                    Some((id, QueryJobInfo { info, job: job.clone() }))\n+                } else {\n+                    None\n+                }\n+            })\n+        }));\n+\n+        Some(())\n+    }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx>> Default for QueryState<'tcx, M> {\n-    fn default() -> QueryState<'tcx, M> {\n+impl<'tcx, C: QueryCache> Default for QueryState<'tcx, C> {\n+    fn default() -> QueryState<'tcx, C> {\n         QueryState {\n-            cache: M::Cache::default(),\n+            cache: C::default(),\n             shards: Default::default(),\n             #[cfg(debug_assertions)]\n             cache_hits: AtomicUsize::new(0),\n@@ -108,21 +140,31 @@ impl<'tcx, M: QueryAccessors<'tcx>> Default for QueryState<'tcx, M> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub(crate) struct QueryLookup<'tcx, Q: QueryAccessors<'tcx>> {\n+pub(crate) struct QueryLookup<'tcx, K, C> {\n     pub(super) key_hash: u64,\n-    pub(super) shard: usize,\n-    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, Q>>,\n+    shard: usize,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, K, C>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) struct JobOwner<'tcx, Q: QueryDescription<'tcx>> {\n-    tcx: TyCtxt<'tcx>,\n-    key: Q::Key,\n+struct JobOwner<'tcx, C>\n+where\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n+    state: &'tcx QueryState<'tcx, C>,\n+    key: C::Key,\n     id: QueryJobId,\n }\n \n-impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n+impl<'tcx, C: QueryCache> JobOwner<'tcx, C>\n+where\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n     /// This function assumes that `try_get_cached` is already called and returned `lookup`.\n@@ -132,12 +174,15 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    pub(super) fn try_start(\n+    fn try_start<Q>(\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n-        key: &Q::Key,\n-        mut lookup: QueryLookup<'tcx, Q>,\n-    ) -> TryGetJob<'tcx, Q> {\n+        key: &C::Key,\n+        mut lookup: QueryLookup<'tcx, C::Key, C::Sharded>,\n+    ) -> TryGetJob<'tcx, C>\n+    where\n+        Q: QueryDescription<'tcx, Key = C::Key, Value = C::Value, Cache = C>,\n+    {\n         let lock = &mut *lookup.lock;\n \n         let (latch, mut _query_blocked_prof_timer) = match lock.active.entry((*key).clone()) {\n@@ -154,7 +199,7 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n                         };\n \n                         // Create the id of the job we're waiting for\n-                        let id = QueryJobId::new(job.id, lookup.shard, Q::dep_kind());\n+                        let id = QueryJobId::new(job.id, lookup.shard, Q::DEP_KIND);\n \n                         (job.latch(id), _query_blocked_prof_timer)\n                     }\n@@ -169,13 +214,14 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n                 lock.jobs = id;\n                 let id = QueryShardJobId(NonZeroU32::new(id).unwrap());\n \n-                let global_id = QueryJobId::new(id, lookup.shard, Q::dep_kind());\n+                let global_id = QueryJobId::new(id, lookup.shard, Q::DEP_KIND);\n \n                 let job = tls::with_related_context(tcx, |icx| QueryJob::new(id, span, icx.query));\n \n                 entry.insert(QueryResult::Started(job));\n \n-                let owner = JobOwner { tcx, id: global_id, key: (*key).clone() };\n+                let owner =\n+                    JobOwner { state: Q::query_state(tcx), id: global_id, key: (*key).clone() };\n                 return TryGetJob::NotYetStarted(owner);\n             }\n         };\n@@ -198,7 +244,8 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n                 return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n             }\n \n-            let cached = tcx.try_get_cached::<Q, _, _, _>(\n+            let cached = tcx.try_get_cached(\n+                Q::query_state(tcx),\n                 (*key).clone(),\n                 |value, index| (value.clone(), index),\n                 |_, _| panic!(\"value must be in cache after waiting\"),\n@@ -215,16 +262,15 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n+    fn complete(self, tcx: TyCtxt<'tcx>, result: &C::Value, dep_node_index: DepNodeIndex) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n-        let tcx = self.tcx;\n+        let state = self.state;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n         let job = {\n-            let state = Q::query_state(tcx);\n             let result = result.clone();\n             let mut lock = state.shards.get_shard_by_value(&key).lock();\n             let job = match lock.active.remove(&key).unwrap() {\n@@ -249,12 +295,16 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'tcx, Q> {\n+impl<'tcx, C: QueryCache> Drop for JobOwner<'tcx, C>\n+where\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic.\n-        let state = Q::query_state(self.tcx);\n+        let state = self.state;\n         let shard = state.shards.get_shard_by_value(&self.key);\n         let job = {\n             let mut shard = shard.lock();\n@@ -272,33 +322,37 @@ impl<'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'tcx, Q> {\n }\n \n #[derive(Clone)]\n-pub struct CycleError<'tcx> {\n+pub(crate) struct CycleError<'tcx> {\n     /// The query and related span that uses the cycle.\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n /// The result of `try_start`.\n-pub(super) enum TryGetJob<'tcx, D: QueryDescription<'tcx>> {\n+enum TryGetJob<'tcx, C: QueryCache>\n+where\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, D>),\n+    NotYetStarted(JobOwner<'tcx, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n     /// if it succeeded or a cycle error if it failed.\n     #[cfg(parallel_compiler)]\n-    JobCompleted((D::Value, DepNodeIndex)),\n+    JobCompleted((C::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(D::Value),\n+    Cycle(C::Value),\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n-    pub(super) fn start_query<F, R>(\n+    fn start_query<F, R>(\n         self,\n         token: QueryJobId,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n@@ -419,23 +473,22 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n     #[inline(always)]\n-    fn try_get_cached<Q, R, OnHit, OnMiss>(\n+    fn try_get_cached<C, R, OnHit, OnMiss>(\n         self,\n-        key: Q::Key,\n+        state: &'tcx QueryState<'tcx, C>,\n+        key: C::Key,\n         // `on_hit` can be called while holding a lock to the query cache\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        Q: QueryDescription<'tcx> + 'tcx,\n-        OnHit: FnOnce(&Q::Value, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(Q::Key, QueryLookup<'tcx, Q>) -> R,\n+        C: QueryCache,\n+        OnHit: FnOnce(&C::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(C::Key, QueryLookup<'tcx, C::Key, C::Sharded>) -> R,\n     {\n-        let state = Q::query_state(self);\n-\n         state.cache.lookup(\n             state,\n-            QueryStateShard::<Q>::get_cache,\n+            QueryStateShard::<C::Key, C::Sharded>::get_cache,\n             key,\n             |value, index| {\n                 if unlikely!(self.prof.enabled()) {\n@@ -459,7 +512,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n \n-        self.try_get_cached::<Q, _, _, _>(\n+        self.try_get_cached(\n+            Q::query_state(self),\n             key,\n             |value, index| {\n                 self.dep_graph.read_index(index);\n@@ -470,13 +524,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    pub(super) fn try_execute_query<Q: QueryDescription<'tcx>>(\n+    fn try_execute_query<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         span: Span,\n         key: Q::Key,\n-        lookup: QueryLookup<'tcx, Q>,\n+        lookup: QueryLookup<'tcx, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n     ) -> Q::Value {\n-        let job = match JobOwner::try_start(self, span, &key, lookup) {\n+        let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n             #[cfg(parallel_compiler)]\n@@ -498,7 +552,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.id, diagnostics, |tcx| {\n-                    tcx.dep_graph.with_anon_task(Q::dep_kind(), || Q::compute(tcx, key))\n+                    tcx.dep_graph.with_anon_task(Q::DEP_KIND, || Q::compute(tcx, key))\n                 })\n             });\n \n@@ -512,7 +566,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n             }\n \n-            job.complete(&result, dep_node_index);\n+            job.complete(self, &result, dep_node_index);\n \n             return result;\n         }\n@@ -538,7 +592,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 })\n             });\n             if let Some((result, dep_node_index)) = loaded {\n-                job.complete(&result, dep_node_index);\n+                job.complete(self, &result, dep_node_index);\n                 return result;\n             }\n         }\n@@ -634,10 +688,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn force_query_with_job<Q: QueryDescription<'tcx>>(\n+    fn force_query_with_job<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'tcx, Q>,\n+        job: JobOwner<'tcx, Q::Cache>,\n         dep_node: DepNode,\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n@@ -680,7 +734,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        job.complete(&result, dep_node_index);\n+        job.complete(self, &result, dep_node_index);\n \n         (result, dep_node_index)\n     }\n@@ -729,13 +783,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n \n-        self.try_get_cached::<Q, _, _, _>(\n+        self.try_get_cached(\n+            Q::query_state(self),\n             key,\n             |_, _| {\n                 // Cache hit, do nothing\n             },\n             |key, lookup| {\n-                let job = match JobOwner::try_start(self, span, &key, lookup) {\n+                let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n                     TryGetJob::NotYetStarted(job) => job,\n                     TryGetJob::Cycle(_) => return,\n                     #[cfg(parallel_compiler)]\n@@ -842,55 +897,6 @@ macro_rules! define_queries_inner {\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n-        impl<$tcx> Queries<$tcx> {\n-            pub fn new(\n-                providers: IndexVec<CrateNum, Providers<$tcx>>,\n-                fallback_extern_providers: Providers<$tcx>,\n-                on_disk_cache: OnDiskCache<'tcx>,\n-            ) -> Self {\n-                Queries {\n-                    providers,\n-                    fallback_extern_providers: Box::new(fallback_extern_providers),\n-                    on_disk_cache,\n-                    $($name: Default::default()),*\n-                }\n-            }\n-\n-            pub fn try_collect_active_jobs(\n-                &self\n-            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n-                let mut jobs = FxHashMap::default();\n-\n-                $(\n-                    // We use try_lock_shards here since we are called from the\n-                    // deadlock handler, and this shouldn't be locked.\n-                    let shards = self.$name.shards.try_lock_shards()?;\n-                    let shards = shards.iter().enumerate();\n-                    jobs.extend(shards.flat_map(|(shard_id, shard)| {\n-                        shard.active.iter().filter_map(move |(k, v)| {\n-                        if let QueryResult::Started(ref job) = *v {\n-                                let id = QueryJobId {\n-                                    job: job.id,\n-                                    shard:  u16::try_from(shard_id).unwrap(),\n-                                    kind:\n-                                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::dep_kind(),\n-                                };\n-                                let info = QueryInfo {\n-                                    span: job.span,\n-                                    query: queries::$name::query(k.clone())\n-                                };\n-                                Some((id, QueryJobInfo { info,  job: job.clone() }))\n-                        } else {\n-                            None\n-                        }\n-                        })\n-                    }));\n-                )*\n-\n-                Some(jobs)\n-            }\n-        }\n-\n         #[allow(nonstandard_style)]\n         #[derive(Clone, Debug)]\n         pub enum Query<$tcx> {\n@@ -951,16 +957,6 @@ macro_rules! define_queries_inner {\n             })*\n         }\n \n-        // This module and the functions in it exist only to provide a\n-        // predictable symbol name prefix for query providers. This is helpful\n-        // for analyzing queries in profilers.\n-        pub(super) mod __query_compute {\n-            $(#[inline(never)]\n-            pub fn $name<F: FnOnce() -> R, R>(f: F) -> R {\n-                f()\n-            })*\n-        }\n-\n         $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n@@ -971,16 +967,12 @@ macro_rules! define_queries_inner {\n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n \n             type Cache = query_storage!([$($modifiers)*][$K, $V]);\n \n             #[inline(always)]\n-            fn query(key: Self::Key) -> Query<'tcx> {\n-                Query::$name(key)\n-            }\n-\n-            #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self::Cache> {\n                 &tcx.queries.$name\n             }\n \n@@ -990,23 +982,16 @@ macro_rules! define_queries_inner {\n                 DepConstructor::$node(tcx, *key)\n             }\n \n-            #[inline(always)]\n-            fn dep_kind() -> dep_graph::DepKind {\n-                dep_graph::DepKind::$node\n-            }\n-\n             #[inline]\n             fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                __query_compute::$name(move || {\n-                    let provider = tcx.queries.providers.get(key.query_crate())\n-                        // HACK(eddyb) it's possible crates may be loaded after\n-                        // the query engine is created, and because crate loading\n-                        // is not yet integrated with the query engine, such crates\n-                        // would be missing appropriate entries in `providers`.\n-                        .unwrap_or(&tcx.queries.fallback_extern_providers)\n-                        .$name;\n-                    provider(tcx, key)\n-                })\n+                let provider = tcx.queries.providers.get(key.query_crate())\n+                    // HACK(eddyb) it's possible crates may be loaded after\n+                    // the query engine is created, and because crate loading\n+                    // is not yet integrated with the query engine, such crates\n+                    // would be missing appropriate entries in `providers`.\n+                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n+                    .$name;\n+                provider(tcx, key)\n             }\n \n             fn hash_result(\n@@ -1139,7 +1124,41 @@ macro_rules! define_queries_struct {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n-            $($(#[$attr])*  $name: QueryState<$tcx, queries::$name<$tcx>>,)*\n+            $($(#[$attr])*  $name: QueryState<\n+                $tcx,\n+                <queries::$name<$tcx> as QueryAccessors<'tcx>>::Cache,\n+            >,)*\n+        }\n+\n+        impl<$tcx> Queries<$tcx> {\n+            pub(crate) fn new(\n+                providers: IndexVec<CrateNum, Providers<$tcx>>,\n+                fallback_extern_providers: Providers<$tcx>,\n+                on_disk_cache: OnDiskCache<'tcx>,\n+            ) -> Self {\n+                Queries {\n+                    providers,\n+                    fallback_extern_providers: Box::new(fallback_extern_providers),\n+                    on_disk_cache,\n+                    $($name: Default::default()),*\n+                }\n+            }\n+\n+            pub(crate) fn try_collect_active_jobs(\n+                &self\n+            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n+                let mut jobs = FxHashMap::default();\n+\n+                $(\n+                    self.$name.try_collect_active_jobs(\n+                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n+                        Query::$name,\n+                        &mut jobs,\n+                    )?;\n+                )*\n+\n+                Some(jobs)\n+            }\n         }\n     };\n }"}, {"sha": "58ace917786cf15d70342ddea66c30ee596c65dd", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=8deeac153fcca97f6a5185b322f8d65d59fab5f4", "patch": "@@ -1,6 +1,6 @@\n use crate::hir::map::definitions::DefPathData;\n use crate::ty::context::TyCtxt;\n-use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::QueryState;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n@@ -157,13 +157,14 @@ where\n /// Allocate the self-profiling query strings for a single query cache. This\n /// method is called from `alloc_self_profile_query_strings` which knows all\n /// the queries via macro magic.\n-pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n+pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryState<'tcx, Q>,\n+    query_state: &QueryState<'tcx, C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n-    Q: QueryAccessors<'tcx>,\n+    C: QueryCache,\n+    C::Key: Debug + Clone,\n {\n     tcx.prof.with_profiler(|profiler| {\n         let event_id_builder = profiler.event_id_builder();"}, {"sha": "527bb46c908882ff6d387558b083a267a353a533", "filename": "src/librustc/ty/query/stats.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8deeac153fcca97f6a5185b322f8d65d59fab5f4/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs?ref=8deeac153fcca97f6a5185b322f8d65d59fab5f4", "patch": "@@ -1,3 +1,4 @@\n+use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::QueryAccessors;\n use crate::ty::query::plumbing::QueryState;\n use crate::ty::query::queries;\n@@ -37,20 +38,17 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<'tcx, Q: QueryAccessors<'tcx>>(\n-    name: &'static str,\n-    map: &QueryState<'tcx, Q>,\n-) -> QueryStats {\n+fn stats<'tcx, C: QueryCache>(name: &'static str, map: &QueryState<'tcx, C>) -> QueryStats {\n     let mut stats = QueryStats {\n         name,\n         #[cfg(debug_assertions)]\n         cache_hits: map.cache_hits.load(Ordering::Relaxed),\n         #[cfg(not(debug_assertions))]\n         cache_hits: 0,\n-        key_size: mem::size_of::<Q::Key>(),\n-        key_type: type_name::<Q::Key>(),\n-        value_size: mem::size_of::<Q::Value>(),\n-        value_type: type_name::<Q::Value>(),\n+        key_size: mem::size_of::<C::Key>(),\n+        key_type: type_name::<C::Key>(),\n+        value_size: mem::size_of::<C::Value>(),\n+        value_type: type_name::<C::Value>(),\n         entry_count: map.iter_results(|results| results.count()),\n         local_def_id_keys: None,\n     };\n@@ -125,7 +123,9 @@ macro_rules! print_stats {\n             let mut queries = Vec::new();\n \n             $($(\n-                queries.push(stats::<queries::$name<'_>>(\n+                queries.push(stats::<\n+                    <queries::$name<'_> as QueryAccessors<'_>>::Cache,\n+                >(\n                     stringify!($name),\n                     &tcx.queries.$name,\n                 ));"}]}