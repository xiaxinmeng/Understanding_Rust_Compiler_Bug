{"sha": "49c0861ed0fa1d95186d88df0cd4310103e70957", "node_id": "C_kwDOAAsO6NoAKDQ5YzA4NjFlZDBmYTFkOTUxODZkODhkZjBjZDQzMTAxMDNlNzA5NTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-21T07:52:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-21T07:52:15Z"}, "message": "Auto merge of #87234 - cjgillot:lower-mono, r=petrochenkov\n\nLower only one HIR owner at a time\n\nBased on https://github.com/rust-lang/rust/pull/83723\nAdditional diff is here: https://github.com/cjgillot/rust/compare/ownernode...lower-mono\n\nLowering is very tangled and has a tendency to intertwine the transformation of different items. This PR aims at simplifying the logic by:\n- moving global analyses to the resolver (item_generics_num_lifetimes, proc_macros, trait_impls);\n- removing a few special cases (non-exported macros and use statements);\n- restricting the amount of available information at any one time;\n- avoiding back-and-forth between different owners: an item must now be lowered all at once, and its parent cannot refer to its nodes.\n\nI also removed the sorting of bodies by span.  The diagnostic ordering changes marginally, since definitions are pretty much sorted already according to the AST. This uncovered a subtlety in thir-unsafeck.\n\n(While these items could logically be in different PRs, the dependency between commits and the amount of conflicts force a monolithic PR.)", "tree": {"sha": "fb23da19572256bcb13815197398368a8b862baf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb23da19572256bcb13815197398368a8b862baf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49c0861ed0fa1d95186d88df0cd4310103e70957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49c0861ed0fa1d95186d88df0cd4310103e70957", "html_url": "https://github.com/rust-lang/rust/commit/49c0861ed0fa1d95186d88df0cd4310103e70957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49c0861ed0fa1d95186d88df0cd4310103e70957/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7958d35ca2c898a223efe402481e0ecb854310a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7958d35ca2c898a223efe402481e0ecb854310a", "html_url": "https://github.com/rust-lang/rust/commit/e7958d35ca2c898a223efe402481e0ecb854310a"}, {"sha": "11024b26bfc0930548ee717fb6d743d80a8e56f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/11024b26bfc0930548ee717fb6d743d80a8e56f2", "html_url": "https://github.com/rust-lang/rust/commit/11024b26bfc0930548ee717fb6d743d80a8e56f2"}], "stats": {"total": 421, "additions": 163, "deletions": 258}, "files": [{"sha": "a6ea4aa8923cfad252d7a96bdb11359f5c8256d3", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -55,7 +55,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         0,\n                         ParenthesizedGenericArgs::Err,\n                         ImplTraitContext::disallowed(),\n-                        None,\n                     ));\n                     let args = self.lower_exprs(args);\n                     hir::ExprKind::MethodCall(\n@@ -328,7 +327,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut generic_args = vec![];\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n-                let parent_def_id = self.current_hir_id_owner.0;\n+                let parent_def_id = self.current_hir_id_owner;\n                 let node_id = self.resolver.next_node_id();\n \n                 // Add a definition for the in-band const def."}, {"sha": "25e6fed68b566fcf5192cd88d81ea488d9a7fa5e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 54, "deletions": 66, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -40,12 +40,9 @@ impl ItemLowerer<'_, '_, '_> {\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_item(&mut self, item: &'a Item) {\n-        self.lctx.allocate_hir_id_counter(item.id);\n         let hir_id = self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            lctx.without_in_scope_lifetime_defs(|lctx| {\n-                let hir_item = lctx.lower_item(item);\n-                lctx.insert_item(hir_item)\n-            })\n+            let node = lctx.without_in_scope_lifetime_defs(|lctx| lctx.lower_item(item));\n+            hir::OwnerNode::Item(node)\n         });\n \n         self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n@@ -72,26 +69,17 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n-            AssocCtxt::Trait => {\n-                let hir_item = lctx.lower_trait_item(item);\n-                lctx.insert_trait_item(hir_item);\n-            }\n-            AssocCtxt::Impl => {\n-                let hir_item = lctx.lower_impl_item(item);\n-                lctx.insert_impl_item(hir_item);\n-            }\n+            AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n+            AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n         });\n \n         visit::walk_assoc_item(self, item, ctxt);\n     }\n \n     fn visit_foreign_item(&mut self, item: &'a ForeignItem) {\n-        self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n-            let hir_item = lctx.lower_foreign_item(item);\n-            lctx.insert_foreign_item(hir_item);\n+            hir::OwnerNode::ForeignItem(lctx.lower_foreign_item(item))\n         });\n \n         visit::walk_foreign_item(self, item);\n@@ -106,12 +94,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // only used when lowering a child item of a trait or impl.\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n-        parent_hir_id: hir::ItemId,\n+        parent_hir_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics = match self.owners[parent_hir_id.def_id].unwrap().expect_item().kind {\n+        let parent_generics = match self.owners[parent_hir_id].unwrap().expect_item().kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n             _ => &[],\n@@ -186,19 +174,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    pub fn lower_item(&mut self, i: &Item) -> hir::Item<'hir> {\n+    fn lower_item(&mut self, i: &Item) -> &'hir hir::Item<'hir> {\n         let mut ident = i.ident;\n-        let mut vis = self.lower_visibility(&i.vis, None);\n+        let mut vis = self.lower_visibility(&i.vis);\n         let hir_id = self.lower_node_id(i.id);\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n-        hir::Item {\n+        let item = hir::Item {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis,\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n     fn lower_item_kind(\n@@ -480,10 +469,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n                 for new_node_id in [id1, id2] {\n-                    // Associate an HirId to both ids even if there is no resolution.\n-                    let new_id = self.allocate_hir_id_counter(new_node_id);\n-\n-                    let res = if let Some(res) = resolutions.next() { res } else { continue };\n+                    let new_id = self.resolver.local_def_id(new_node_id);\n+                    let res = if let Some(res) = resolutions.next() {\n+                        res\n+                    } else {\n+                        // Associate an HirId to both ids even if there is no resolution.\n+                        self.node_id_to_hir_id.ensure_contains_elem(new_node_id, || None);\n+                        debug_assert!(self.node_id_to_hir_id[new_node_id].is_none());\n+                        self.node_id_to_hir_id[new_node_id] = Some(hir::HirId::make_owner(new_id));\n+                        continue;\n+                    };\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n@@ -493,24 +488,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let res = this.lower_res(res);\n-                        let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n+                        let path = this.lower_path_extra(res, &path, ParamMode::Explicit);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n                         if let Some(attrs) = attrs {\n                             this.attrs.insert(hir::HirId::make_owner(new_id), attrs);\n                         }\n \n-                        this.insert_item(hir::Item {\n+                        let item = hir::Item {\n                             def_id: new_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n                             span: this.lower_span(span),\n-                        });\n+                        };\n+                        hir::OwnerNode::Item(this.arena.alloc(item))\n                     });\n                 }\n \n-                let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None);\n+                let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -550,7 +546,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.allocate_hir_id_counter(id);\n+                    let new_hir_id = self.resolver.local_def_id(id);\n \n                     let mut prefix = prefix.clone();\n \n@@ -574,13 +570,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             this.attrs.insert(hir::HirId::make_owner(new_hir_id), attrs);\n                         }\n \n-                        this.insert_item(hir::Item {\n+                        let item = hir::Item {\n                             def_id: new_hir_id,\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis,\n                             span: this.lower_span(use_tree.span),\n-                        });\n+                        };\n+                        hir::OwnerNode::Item(this.arena.alloc(item))\n                     });\n                 }\n \n@@ -610,7 +607,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n                 let res = self.lower_res(res);\n-                let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit, None);\n+                let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n@@ -647,11 +644,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         respan(self.lower_span(vis.span), vis_kind)\n     }\n \n-    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n+    fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let def_id = hir_id.expect_owner();\n         self.lower_attrs(hir_id, &i.attrs);\n-        hir::ForeignItem {\n+        let item = hir::ForeignItem {\n             def_id,\n             ident: self.lower_ident(i.ident),\n             kind: match i.kind {\n@@ -679,17 +676,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n             },\n-            vis: self.lower_visibility(&i.vis, None),\n+            vis: self.lower_visibility(&i.vis),\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n-    fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef<'hir> {\n+    fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.allocate_hir_id_counter(i.id) },\n+            id: hir::ForeignItemId { def_id: self.resolver.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n-            vis: self.lower_visibility(&i.vis, Some(i.id)),\n         }\n     }\n \n@@ -757,12 +754,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), self.lower_span(f.span)),\n             },\n-            vis: self.lower_visibility(&f.vis, None),\n+            vis: self.lower_visibility(&f.vis),\n             ty,\n         }\n     }\n \n-    fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n+    fn lower_trait_item(&mut self, i: &AssocItem) -> &'hir hir::TraitItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let trait_item_def_id = hir_id.expect_owner();\n \n@@ -805,13 +802,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         self.lower_attrs(hir_id, &i.attrs);\n-        hir::TraitItem {\n+        let item = hir::TraitItem {\n             def_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n@@ -841,7 +839,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n-    fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n+    fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n         let impl_item_def_id = self.resolver.local_def_id(i.id);\n \n         let (generics, kind) = match &i.kind {\n@@ -895,26 +893,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         let hir_id = self.lower_node_id(i.id);\n         self.lower_attrs(hir_id, &i.attrs);\n-        hir::ImplItem {\n+        let item = hir::ImplItem {\n             def_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n-            vis: self.lower_visibility(&i.vis, None),\n+            vis: self.lower_visibility(&i.vis),\n             defaultness,\n             kind,\n             span: self.lower_span(i.span),\n-        }\n+        };\n+        self.arena.alloc(item)\n     }\n \n-    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef<'hir> {\n+    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.allocate_hir_id_counter(i.id) },\n+            id: hir::ImplItemId { def_id: self.resolver.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n-            vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness,\n             kind: match &i.kind {\n                 AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n@@ -932,25 +930,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// lowered. This can happen during `lower_impl_item_ref()` where we need to\n     /// lower a `Visibility` value although we haven't lowered the owning\n     /// `ImplItem` in question yet.\n-    fn lower_visibility(\n-        &mut self,\n-        v: &Visibility,\n-        explicit_owner: Option<NodeId>,\n-    ) -> hir::Visibility<'hir> {\n+    fn lower_visibility(&mut self, v: &Visibility) -> hir::Visibility<'hir> {\n         let node = match v.kind {\n             VisibilityKind::Public => hir::VisibilityKind::Public,\n             VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n             VisibilityKind::Restricted { ref path, id } => {\n                 debug!(\"lower_visibility: restricted path id = {:?}\", id);\n-                let lowered_id = if let Some(owner) = explicit_owner {\n-                    self.lower_node_id_with_owner(id, owner)\n-                } else {\n-                    self.lower_node_id(id)\n-                };\n-                let res = self.expect_full_res(id);\n-                let res = self.lower_res(res);\n+                let lowered_id = self.lower_node_id(id);\n                 hir::VisibilityKind::Restricted {\n-                    path: self.lower_path_extra(res, path, ParamMode::Explicit, explicit_owner),\n+                    path: self.lower_path(id, path, ParamMode::Explicit),\n                     hir_id: lowered_id,\n                 }\n             }"}, {"sha": "5ec060f654090b5297dbafac9ae91fe14617acf7", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 60, "deletions": 138, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -80,8 +80,6 @@ mod item;\n mod pat;\n mod path;\n \n-const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n-\n rustc_hir::arena_types!(rustc_arena::declare_arena, 'tcx);\n \n struct LoweringContext<'a, 'hir: 'a> {\n@@ -150,8 +148,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n-    current_hir_id_owner: (LocalDefId, u32),\n-    item_local_id_counters: NodeMap<u32>,\n+    current_hir_id_owner: LocalDefId,\n+    item_local_id_counter: hir::ItemLocalId,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n@@ -330,8 +328,8 @@ pub fn lower_crate<'a, 'hir>(\n         is_in_trait_impl: false,\n         is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n-        current_hir_id_owner: (CRATE_DEF_ID, 0),\n-        item_local_id_counters: Default::default(),\n+        current_hir_id_owner: CRATE_DEF_ID,\n+        item_local_id_counter: hir::ItemLocalId::new(0),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n         task_context: None,\n@@ -412,15 +410,15 @@ enum AnonymousLifetimeMode {\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_crate(mut self, c: &Crate) -> &'hir hir::Crate<'hir> {\n-        self.lower_node_id(CRATE_NODE_ID);\n-        debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == Some(hir::CRATE_HIR_ID));\n+        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n-        let module = self.arena.alloc(self.lower_mod(&c.items, c.span));\n-        self.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n-        self.owners.ensure_contains_elem(CRATE_DEF_ID, || None);\n-        self.owners[CRATE_DEF_ID] = Some(hir::OwnerNode::Crate(module));\n+        self.with_hir_id_owner(CRATE_NODE_ID, |lctx| {\n+            let module = lctx.lower_mod(&c.items, c.span);\n+            lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n+            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n+        });\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in self.resolver.take_trait_map().into_iter() {\n@@ -456,95 +454,40 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(krate)\n     }\n \n-    fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n-        let id = item.item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::Item(item));\n-        id\n-    }\n-\n-    fn insert_foreign_item(&mut self, item: hir::ForeignItem<'hir>) -> hir::ForeignItemId {\n-        let id = item.foreign_item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::ForeignItem(item));\n-        id\n-    }\n-\n-    fn insert_impl_item(&mut self, item: hir::ImplItem<'hir>) -> hir::ImplItemId {\n-        let id = item.impl_item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::ImplItem(item));\n-        id\n-    }\n-\n-    fn insert_trait_item(&mut self, item: hir::TraitItem<'hir>) -> hir::TraitItemId {\n-        let id = item.trait_item_id();\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(id.def_id, || None);\n-        self.owners[id.def_id] = Some(hir::OwnerNode::TraitItem(item));\n-        id\n-    }\n-\n-    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LocalDefId {\n-        // Set up the counter if needed.\n-        self.item_local_id_counters.entry(owner).or_insert(0);\n-        // Always allocate the first `HirId` for the owner itself.\n-        let lowered = self.lower_node_id_with_owner(owner, owner);\n-        debug_assert_eq!(lowered.local_id.as_u32(), 0);\n-        lowered.owner\n-    }\n-\n     fn create_stable_hashing_context(&self) -> LoweringHasher<'_> {\n         LoweringHasher {\n             source_map: CachingSourceMapView::new(self.sess.source_map()),\n             resolver: self.resolver,\n         }\n     }\n \n-    fn lower_node_id_generic(\n+    fn with_hir_id_owner(\n         &mut self,\n-        ast_node_id: NodeId,\n-        alloc_hir_id: impl FnOnce(&mut Self) -> hir::HirId,\n-    ) -> hir::HirId {\n-        assert_ne!(ast_node_id, DUMMY_NODE_ID);\n-\n-        let min_size = ast_node_id.as_usize() + 1;\n+        owner: NodeId,\n+        f: impl FnOnce(&mut Self) -> hir::OwnerNode<'hir>,\n+    ) -> LocalDefId {\n+        let def_id = self.resolver.local_def_id(owner);\n \n-        if min_size > self.node_id_to_hir_id.len() {\n-            self.node_id_to_hir_id.resize(min_size, None);\n+        // Always allocate the first `HirId` for the owner itself.\n+        self.node_id_to_hir_id.ensure_contains_elem(owner, || None);\n+        if let Some(_lowered) = self.node_id_to_hir_id[owner] {\n+            panic!(\"with_hir_id_owner must not be called multiple times on owner {:?}\", def_id);\n         }\n+        self.node_id_to_hir_id[owner] = Some(hir::HirId::make_owner(def_id));\n \n-        if let Some(existing_hir_id) = self.node_id_to_hir_id[ast_node_id] {\n-            existing_hir_id\n-        } else {\n-            // Generate a new `HirId`.\n-            let hir_id = alloc_hir_id(self);\n-            self.node_id_to_hir_id[ast_node_id] = Some(hir_id);\n+        let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n+        let current_local_counter =\n+            std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n \n-            hir_id\n-        }\n-    }\n+        let item = f(self);\n \n-    fn with_hir_id_owner<T>(&mut self, owner: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let counter = self\n-            .item_local_id_counters\n-            .insert(owner, HIR_ID_COUNTER_LOCKED)\n-            .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n-        let def_id = self.resolver.local_def_id(owner);\n-        let old_owner = std::mem::replace(&mut self.current_hir_id_owner, (def_id, counter));\n-        let ret = f(self);\n-        let (new_def_id, new_counter) =\n-            std::mem::replace(&mut self.current_hir_id_owner, old_owner);\n+        self.current_hir_id_owner = current_owner;\n+        self.item_local_id_counter = current_local_counter;\n \n-        debug_assert!(def_id == new_def_id);\n-        debug_assert!(new_counter >= counter);\n+        self.owners.ensure_contains_elem(def_id, || None);\n+        self.owners[def_id] = Some(item);\n \n-        let prev = self.item_local_id_counters.insert(owner, new_counter).unwrap();\n-        debug_assert!(prev == HIR_ID_COUNTER_LOCKED);\n-        ret\n+        def_id\n     }\n \n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n@@ -554,35 +497,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// `HirIdValidator` later on, which makes sure that all `NodeId`s got mapped\n     /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n-        self.lower_node_id_generic(ast_node_id, |this| {\n-            let &mut (owner, ref mut local_id_counter) = &mut this.current_hir_id_owner;\n-            let local_id = *local_id_counter;\n-            *local_id_counter += 1;\n-            hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n-        })\n-    }\n-\n-    fn lower_node_id_with_owner(&mut self, ast_node_id: NodeId, owner: NodeId) -> hir::HirId {\n-        self.lower_node_id_generic(ast_node_id, |this| {\n-            let local_id_counter = this\n-                .item_local_id_counters\n-                .get_mut(&owner)\n-                .expect(\"called `lower_node_id_with_owner` before `allocate_hir_id_counter`\");\n-            let local_id = *local_id_counter;\n-\n-            // We want to be sure not to modify the counter in the map while it\n-            // is also on the stack. Otherwise we'll get lost updates when writing\n-            // back from the stack to the map.\n-            debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n-\n-            *local_id_counter += 1;\n-            let owner = this.resolver.opt_local_def_id(owner).expect(\n-                \"you forgot to call `create_def` or are lowering node-IDs \\\n-                 that do not belong to the current owner\",\n-            );\n+        assert_ne!(ast_node_id, DUMMY_NODE_ID);\n \n-            hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n-        })\n+        self.node_id_to_hir_id.ensure_contains_elem(ast_node_id, || None);\n+        if let Some(existing_hir_id) = self.node_id_to_hir_id[ast_node_id] {\n+            existing_hir_id\n+        } else {\n+            // Generate a new `HirId`.\n+            let owner = self.current_hir_id_owner;\n+            let local_id = self.item_local_id_counter;\n+            self.item_local_id_counter.increment_by(1);\n+            let hir_id = hir::HirId { owner, local_id };\n+            self.node_id_to_hir_id[ast_node_id] = Some(hir_id);\n+            hir_id\n+        }\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n@@ -592,7 +520,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n         res.map_id(|id| {\n-            self.lower_node_id_generic(id, |_| {\n+            self.node_id_to_hir_id.get(id).copied().flatten().unwrap_or_else(|| {\n                 panic!(\"expected `NodeId` to be lowered already for res {:#?}\", res);\n             })\n         })\n@@ -655,7 +583,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n         if self.sess.opts.debugging_opts.incremental_relative_spans {\n-            span.with_parent(Some(self.current_hir_id_owner.0))\n+            span.with_parent(Some(self.current_hir_id_owner))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n             span\n@@ -828,7 +756,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // wouldn't have been added yet.\n                     let generics = this.lower_generics_mut(\n                         generics,\n-                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner.0),\n+                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner),\n                     );\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n@@ -1034,7 +962,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n-                let mut parent_def_id = self.current_hir_id_owner.0;\n+                let mut parent_def_id = self.current_hir_id_owner;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1162,7 +1090,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                                 // Construct an AnonConst where the expr is the \"ty\"'s path.\n \n-                                let parent_def_id = self.current_hir_id_owner.0;\n+                                let parent_def_id = self.current_hir_id_owner;\n                                 let node_id = self.resolver.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n@@ -1428,12 +1356,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.allocate_hir_id_counter(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n-        let collected_lifetimes = self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n+        let mut collected_lifetimes = Vec::new();\n+        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let hir_bounds = lower_bounds(lctx);\n \n-            let collected_lifetimes = lifetimes_from_impl_trait_bounds(\n+            collected_lifetimes = lifetimes_from_impl_trait_bounds(\n                 opaque_ty_node_id,\n                 &hir_bounds,\n                 capturable_lifetimes,\n@@ -1486,9 +1415,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n-\n-            collected_lifetimes\n+            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n         });\n \n         let lifetimes =\n@@ -1510,7 +1437,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n-    ) {\n+    ) -> hir::OwnerNode<'hir> {\n         let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n@@ -1521,11 +1448,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             vis: respan(self.lower_span(span.shrink_to_lo()), hir::VisibilityKind::Inherited),\n             span: self.lower_span(opaque_ty_span),\n         };\n-\n-        // Insert the item into the global item list. This usually happens\n-        // automatically for all AST items. But this opaque type item\n-        // does not actually exist in the AST.\n-        self.insert_item(opaque_ty_item);\n+        hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n@@ -1594,7 +1517,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if let Some((_, ibty)) = &mut in_band_ty_params {\n                     this.lower_ty_direct(\n                         &param.ty,\n-                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner.0),\n+                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner),\n                     )\n                 } else {\n                     this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n@@ -1685,7 +1608,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.allocate_hir_id_counter(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n@@ -1735,7 +1658,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // grow.\n         let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n \n-        let lifetime_params = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+        let mut lifetime_params = Vec::new();\n+        self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -1757,7 +1681,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Note: this must be done after lowering the output type,\n             // as the output type may introduce new in-band lifetimes.\n-            let lifetime_params: Vec<(Span, ParamName)> = this\n+            lifetime_params = this\n                 .in_scope_lifetimes\n                 .iter()\n                 .cloned()\n@@ -1786,9 +1710,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n-\n-            lifetime_params\n+            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n         });\n \n         // As documented above on the variable"}, {"sha": "929f427484dba4ac28ba65fd7bf931c067c46376", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -99,7 +99,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         num_lifetimes,\n                         parenthesized_generic_args,\n                         itctx.reborrow(),\n-                        None,\n                     )\n                 },\n             )),\n@@ -147,7 +146,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 0,\n                 ParenthesizedGenericArgs::Err,\n                 itctx.reborrow(),\n-                None,\n             ));\n             let qpath = hir::QPath::TypeRelative(ty, hir_segment);\n \n@@ -178,7 +176,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         res: Res,\n         p: &Path,\n         param_mode: ParamMode,\n-        explicit_owner: Option<NodeId>,\n     ) -> &'hir hir::Path<'hir> {\n         self.arena.alloc(hir::Path {\n             res,\n@@ -190,7 +187,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     0,\n                     ParenthesizedGenericArgs::Err,\n                     ImplTraitContext::disallowed(),\n-                    explicit_owner,\n                 )\n             })),\n             span: self.lower_span(p.span),\n@@ -205,7 +201,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> &'hir hir::Path<'hir> {\n         let res = self.expect_full_res(id);\n         let res = self.lower_res(res);\n-        self.lower_path_extra(res, p, param_mode, None)\n+        self.lower_path_extra(res, p, param_mode)\n     }\n \n     crate fn lower_path_segment(\n@@ -216,7 +212,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         expected_lifetimes: usize,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n         itctx: ImplTraitContext<'_, 'hir>,\n-        explicit_owner: Option<NodeId>,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\n             \"path_span: {:?}, lower_path_segment(segment: {:?}, expected_lifetimes: {:?})\",\n@@ -354,11 +349,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         let res = self.expect_full_res(segment.id);\n-        let id = if let Some(owner) = explicit_owner {\n-            self.lower_node_id_with_owner(segment.id, owner)\n-        } else {\n-            self.lower_node_id(segment.id)\n-        };\n+        let id = self.lower_node_id(segment.id);\n         debug!(\n             \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n             segment.ident, segment.id, id,"}, {"sha": "f07e52e04daa9d8020ee9b6ee58c2d6f72de845f", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -28,9 +28,9 @@ macro_rules! arena_types {\n             [] pat_field: rustc_hir::PatField<$tcx>,\n             [] fn_decl: rustc_hir::FnDecl<$tcx>,\n             [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n-            [few] foreign_item_ref: rustc_hir::ForeignItemRef<$tcx>,\n+            [few] foreign_item_ref: rustc_hir::ForeignItemRef,\n             [] impl_item: rustc_hir::ImplItem<$tcx>,\n-            [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n+            [] impl_item_ref: rustc_hir::ImplItemRef,\n             [] item: rustc_hir::Item<$tcx>,\n             [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n             [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,"}, {"sha": "05b652fd5af2c4245dd6d727e7b9c4ef0a941abc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -2745,7 +2745,7 @@ pub enum ItemKind<'hir> {\n     /// A module.\n     Mod(Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n-    ForeignMod { abi: Abi, items: &'hir [ForeignItemRef<'hir>] },\n+    ForeignMod { abi: Abi, items: &'hir [ForeignItemRef] },\n     /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(&'hir InlineAsm<'hir>),\n     /// A type alias, e.g., `type Foo = Bar<u8>`.\n@@ -2782,7 +2782,7 @@ pub struct Impl<'hir> {\n     pub of_trait: Option<TraitRef<'hir>>,\n \n     pub self_ty: &'hir Ty<'hir>,\n-    pub items: &'hir [ImplItemRef<'hir>],\n+    pub items: &'hir [ImplItemRef],\n }\n \n impl ItemKind<'_> {\n@@ -2846,13 +2846,12 @@ pub struct TraitItemRef {\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Debug, HashStable_Generic)]\n-pub struct ImplItemRef<'hir> {\n+pub struct ImplItemRef {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssocItemKind,\n     pub span: Span,\n-    pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n }\n \n@@ -2886,12 +2885,11 @@ impl ForeignItemId {\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Debug, HashStable_Generic)]\n-pub struct ForeignItemRef<'hir> {\n+pub struct ForeignItemRef {\n     pub id: ForeignItemId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub span: Span,\n-    pub vis: Visibility<'hir>,\n }\n \n #[derive(Debug)]"}, {"sha": "1ac2625dd475483edce4e66030a81f5f222eb741", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -392,10 +392,10 @@ pub trait Visitor<'v>: Sized {\n     fn visit_impl_item(&mut self, ii: &'v ImplItem<'v>) {\n         walk_impl_item(self, ii)\n     }\n-    fn visit_foreign_item_ref(&mut self, ii: &'v ForeignItemRef<'v>) {\n+    fn visit_foreign_item_ref(&mut self, ii: &'v ForeignItemRef) {\n         walk_foreign_item_ref(self, ii)\n     }\n-    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef<'v>) {\n+    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n         walk_impl_item_ref(self, ii)\n     }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef<'v>) {\n@@ -1042,22 +1042,20 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_foreign_item_ref<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n-    foreign_item_ref: &'v ForeignItemRef<'v>,\n+    foreign_item_ref: &'v ForeignItemRef,\n ) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let ForeignItemRef { id, ident, span: _, ref vis } = *foreign_item_ref;\n+    let ForeignItemRef { id, ident, span: _ } = *foreign_item_ref;\n     visitor.visit_nested_foreign_item(id);\n     visitor.visit_ident(ident);\n-    visitor.visit_vis(vis);\n }\n \n-pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef<'v>) {\n+pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n+    let ImplItemRef { id, ident, ref kind, span: _, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n     visitor.visit_ident(ident);\n     visitor.visit_associated_item_kind(kind);\n-    visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);\n }\n "}, {"sha": "5ad55dbf5c80d38ba9415413204d6aa34a9f3aea", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -382,7 +382,7 @@ impl Collector<'tcx> {\n         }\n     }\n \n-    fn i686_arg_list_size(&self, item: &hir::ForeignItemRef<'_>) -> usize {\n+    fn i686_arg_list_size(&self, item: &hir::ForeignItemRef) -> usize {\n         let argument_types: &List<Ty<'_>> = self.tcx.erase_late_bound_regions(\n             self.tcx\n                 .type_of(item.id.def_id)\n@@ -406,7 +406,7 @@ impl Collector<'tcx> {\n             .sum()\n     }\n \n-    fn build_dll_import(&self, abi: Abi, item: &hir::ForeignItemRef<'_>) -> DllImport {\n+    fn build_dll_import(&self, abi: Abi, item: &hir::ForeignItemRef) -> DllImport {\n         let calling_convention = if self.tcx.sess.target.arch == \"x86\" {\n             match abi {\n                 Abi::C { .. } | Abi::Cdecl => DllCallingConvention::C,"}, {"sha": "5ecb1c9b0ffcc3b62cf49b960178704dab9ea131", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -413,18 +413,18 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_trait_item(id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef<'hir>) {\n+    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n         // Do not visit the duplicate information in ImplItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n-        let ImplItemRef { id, ident: _, kind: _, span: _, vis: _, defaultness: _ } = *ii;\n+        let ImplItemRef { id, ident: _, kind: _, span: _, defaultness: _ } = *ii;\n \n         self.visit_nested_impl_item(id);\n     }\n \n-    fn visit_foreign_item_ref(&mut self, fi: &'hir ForeignItemRef<'hir>) {\n+    fn visit_foreign_item_ref(&mut self, fi: &'hir ForeignItemRef) {\n         // Do not visit the duplicate information in ForeignItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n-        let ForeignItemRef { id, ident: _, span: _, vis: _ } = *fi;\n+        let ForeignItemRef { id, ident: _, span: _ } = *fi;\n \n         self.visit_nested_foreign_item(id);\n     }"}, {"sha": "0e60ca9f900107a011ecfaa229c220b298de45b1", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -163,14 +163,14 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         self.hir_ids_seen.insert(hir_id.local_id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef<'hir>) {\n+    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n         // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n         // values that actually belong to an ImplItem instead of the ItemKind::Impl\n         // we are currently in. So for those it's correct that they have a\n         // different owner.\n     }\n \n-    fn visit_foreign_item_ref(&mut self, _: &'hir hir::ForeignItemRef<'hir>) {\n+    fn visit_foreign_item_ref(&mut self, _: &'hir hir::ForeignItemRef) {\n         // Explicitly do nothing here. ForeignItemRefs contain hir::Visibility\n         // values that actually belong to an ForeignItem instead of the ItemKind::ForeignMod\n         // we are currently in. So for those it's correct that they have a"}, {"sha": "e14f758ddae79662db51d039b80d2cff40985112", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -743,7 +743,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n-                    if impl_.of_trait.is_some() || impl_item_ref.vis.node.is_pub() {\n+                    if impl_.of_trait.is_some()\n+                        || self.tcx.visibility(impl_item_ref.id.def_id) == ty::Visibility::Public\n+                    {\n                         self.update(impl_item_ref.id.def_id, item_level);\n                     }\n                 }\n@@ -768,7 +770,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    if foreign_item.vis.node.is_pub() {\n+                    if self.tcx.visibility(foreign_item.id.def_id) == ty::Visibility::Public {\n                         self.update(foreign_item.id.def_id, item_level);\n                     }\n                 }\n@@ -1678,7 +1680,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.item_is_public(impl_item_ref.id.def_id, &impl_item_ref.vis) {\n+                        if self.access_levels.is_reachable(impl_item_ref.id.def_id)\n+                            || self.tcx.visibility(impl_item_ref.id.def_id)\n+                                == ty::Visibility::Public\n+                        {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 AssocItemKind::Const => {"}, {"sha": "611ff26d652277ebfc3ef482faff31a4624af93f", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -209,7 +209,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n         _ => return,\n     };\n     let fix_span =\n-        |impl_item_ref: &hir::ImplItemRef<'_>| match tcx.hir().impl_item(impl_item_ref.id).kind {\n+        |impl_item_ref: &hir::ImplItemRef| match tcx.hir().impl_item(impl_item_ref.id).kind {\n             hir::ImplItemKind::Const(ty, _) | hir::ImplItemKind::TyAlias(ty) => ty.span,\n             _ => impl_item_ref.span,\n         };"}, {"sha": "3d3b2743700917090e208f651426d5b3d5d3e79a", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -100,7 +100,7 @@ fn associated_item_from_trait_item_ref(\n fn associated_item_from_impl_item_ref(\n     tcx: TyCtxt<'_>,\n     parent_def_id: LocalDefId,\n-    impl_item_ref: &hir::ImplItemRef<'_>,\n+    impl_item_ref: &hir::ImplItemRef,\n ) -> ty::AssocItem {\n     let def_id = impl_item_ref.id.def_id;\n     let (kind, has_self) = match impl_item_ref.kind {"}, {"sha": "d6c59312c0bc8d558ae68866b7299df470649eac", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -906,7 +906,7 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n     full_impl_span: Span,\n     impl_id: LocalDefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item_refs: &[hir::ImplItemRef<'_>],\n+    impl_item_refs: &[hir::ImplItemRef],\n ) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`"}, {"sha": "f3fe09ac0033d4802b8d1797d40fb91c57b343b2", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -401,7 +401,7 @@ impl InherentCollect<'tcx> {\n         lang: &str,\n         ty: &str,\n         span: Span,\n-        assoc_items: &[hir::ImplItemRef<'_>],\n+        assoc_items: &[hir::ImplItemRef],\n     ) {\n         match (lang_def_id, lang_def_id2) {\n             (Some(lang_def_id), _) if lang_def_id == impl_def_id.to_def_id() => {"}, {"sha": "5d2f8fc4242756b798c1c9485cf999603f78fce3", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -97,7 +97,7 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n fn enforce_impl_params_are_constrained(\n     tcx: TyCtxt<'_>,\n     impl_def_id: LocalDefId,\n-    impl_item_refs: &[hir::ImplItemRef<'_>],\n+    impl_item_refs: &[hir::ImplItemRef],\n ) {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_self_ty = tcx.type_of(impl_def_id);\n@@ -228,7 +228,7 @@ fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str)\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef<'_>]) {\n+fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplItemRef]) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "4bc98fd7cd08291f2e424120389383817d4882e3", "filename": "src/test/incremental/hashes/extern_mods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -143,13 +143,13 @@ extern \"rust-call\" {\n // Make function public --------------------------------------------------------\n #[cfg(any(cfail1,cfail4))]\n extern \"C\" {\n-    fn make_function_public(c: i32);\n+    fn     make_function_public(c: i32);\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner\")]\n+#[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n-#[rustc_clean(cfg = \"cfail5\", except = \"hir_owner\")]\n+#[rustc_clean(cfg = \"cfail5\")]\n #[rustc_clean(cfg = \"cfail6\")]\n extern \"C\" {\n     pub fn make_function_public(c: i32);"}, {"sha": "3a59377e819694d12d946cbfd1d64a0d99b6e6e0", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -116,20 +116,24 @@ impl Foo {\n // Change Method Privacy -------------------------------------------------------\n #[cfg(any(cfail1,cfail4))]\n impl Foo {\n+    //------------------------------------------------------------------------------\n+    //--------------------------\n+    //------------------------------------------------------------------------------\n+    //--------------------------\n     pub fn method_privacy() { }\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner\")]\n+#[rustc_clean(cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n impl Foo {\n     #[rustc_clean(cfg=\"cfail2\", except=\"associated_item,hir_owner,hir_owner_nodes\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n-    #[rustc_clean(cfg=\"cfail5\", except=\"associated_item,hir_owner,hir_owner_nodes,optimized_mir\")]\n+    #[rustc_clean(cfg=\"cfail5\", except=\"associated_item,hir_owner,hir_owner_nodes\")]\n     #[rustc_clean(cfg=\"cfail6\")]\n-    fn method_privacy() { }\n+    fn     method_privacy() { }\n }\n \n // Change Method Selfness -----------------------------------------------------------"}, {"sha": "f22f52b949e1a8609bb55be59bac866544a02758", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c0861ed0fa1d95186d88df0cd4310103e70957/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c0861ed0fa1d95186d88df0cd4310103e70957/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=49c0861ed0fa1d95186d88df0cd4310103e70957", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n     }\n }\n \n-fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef<'_>]) {\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef]) {\n     use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n     use rustc_hir::{Expr, ExprKind, ImplItemKind, QPath};\n "}]}