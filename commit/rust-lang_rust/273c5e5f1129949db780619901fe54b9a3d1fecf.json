{"sha": "273c5e5f1129949db780619901fe54b9a3d1fecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3M2M1ZTVmMTEyOTk0OWRiNzgwNjE5OTAxZmU1NGI5YTNkMWZlY2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-15T00:31:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-15T00:31:16Z"}, "message": "rustc: Lift the @ from the type definition of crate_ctxt into its uses\n\nThis will make it easier to convert crate_ctxt into a region pointer, since\nthere are functions that return crate contexts. There would be no way to type\nthese functions if crate_ctxt had to be an inferred region pointer.", "tree": {"sha": "aa31a01f4af7fee308d06e6889e479f31505f49f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa31a01f4af7fee308d06e6889e479f31505f49f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/273c5e5f1129949db780619901fe54b9a3d1fecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/273c5e5f1129949db780619901fe54b9a3d1fecf", "html_url": "https://github.com/rust-lang/rust/commit/273c5e5f1129949db780619901fe54b9a3d1fecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/273c5e5f1129949db780619901fe54b9a3d1fecf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e0e089185226217a71f50684c11c2e129f12c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e0e089185226217a71f50684c11c2e129f12c2e", "html_url": "https://github.com/rust-lang/rust/commit/1e0e089185226217a71f50684c11c2e129f12c2e"}], "stats": {"total": 291, "additions": 146, "deletions": 145}, "files": [{"sha": "769a79f2aca7d5dcece7eaad1ff471b459938437", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -493,7 +493,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: link_meta) ->\n     ret \"_\" + hash;\n }\n \n-fn get_symbol_hash(ccx: crate_ctxt, t: ty::t) -> str {\n+fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n     let hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n@@ -525,28 +525,28 @@ fn exported_name(path: path, hash: str, _vers: str) -> str {\n \n }\n \n-fn mangle_exported_name(ccx: crate_ctxt, path: path, t: ty::t) -> str {\n+fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: crate_ctxt, t: ty::t, name: str) ->\n+fn mangle_internal_name_by_type_only(ccx: @crate_ctxt, t: ty::t, name: str) ->\n    str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     ret mangle([path_name(name), path_name(s), path_name(hash)]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: crate_ctxt, path: path,\n+fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n                                         flav: str) -> str {\n     ret mangle(path + [path_name(ccx.names(flav))]);\n }\n \n-fn mangle_internal_name_by_path(_ccx: crate_ctxt, path: path) -> str {\n+fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: crate_ctxt, flav: str) -> str {\n+fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: str) -> str {\n     ret ccx.names(flav);\n }\n "}, {"sha": "4eb2cf0a83a9659d183f6c0cb5fc4dbd17a23539", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -28,7 +28,7 @@ export encode_def_id;\n \n type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n-type encode_ctxt = {ccx: crate_ctxt,\n+type encode_ctxt = {ccx: @crate_ctxt,\n                     type_abbrevs: abbrev_map,\n                     reachable: reachable::map};\n \n@@ -737,7 +737,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml_w.end_tag();\n }\n \n-fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n+fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n \n     let reachable = reachable::find_reachable(cx, crate.node.module);\n     let abbrevs = ty::new_ty_hash();"}, {"sha": "d0f144171be0c79293698932211440f8bc26417f", "filename": "src/rustc/metadata/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmetadata%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmetadata%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Freachable.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -16,10 +16,10 @@ export map, find_reachable;\n \n type map = std::map::hashmap<node_id, ()>;\n \n-type ctx = {ccx: middle::trans::common::crate_ctxt,\n+type ctx = {ccx: @middle::trans::common::crate_ctxt,\n             rmap: map};\n \n-fn find_reachable(ccx: middle::trans::common::crate_ctxt, crate_mod: _mod)\n+fn find_reachable(ccx: @middle::trans::common::crate_ctxt, crate_mod: _mod)\n     -> map {\n     let rmap = std::map::new_int_hash();\n     traverse_public_mod({ccx: ccx, rmap: rmap}, crate_mod);"}, {"sha": "004cb32132bf906bd1cbde41526a97e0e287b5c6", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -231,7 +231,7 @@ fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n     }\n }\n \n-fn get_options(ccx: crate_ctxt, m: match, col: uint) -> [opt] {\n+fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n     fn add_to_set(tcx: ty::ctxt, &set: [opt], val: opt) {\n         for l in set { if opt_eq(tcx, l, val) { ret; } }\n         set += [val];"}, {"sha": "33ea22617d549bfb03d81932e29bb404944857ce", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -61,7 +61,7 @@ enum dest {\n     ignore,\n }\n \n-fn dest_str(ccx: crate_ctxt, d: dest) -> str {\n+fn dest_str(ccx: @crate_ctxt, d: dest) -> str {\n     alt d {\n       by_val(v) { #fmt[\"by_val(%s)\", val_str(ccx.tn, *v)] }\n       save_in(v) { #fmt[\"save_in(%s)\", val_str(ccx.tn, v)] }\n@@ -156,7 +156,7 @@ fn sanitize(s: str) -> str {\n }\n \n \n-fn log_fn_time(ccx: crate_ctxt, name: str, start: time::timeval,\n+fn log_fn_time(ccx: @crate_ctxt, name: str, start: time::timeval,\n                end: time::timeval) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.usec as int) - (start.usec as int)) / 1000;\n@@ -276,7 +276,7 @@ fn dynastack_alloca(cx: block, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     ret PointerCast(dy_cx, llresult, T_ptr(t));\n }\n \n-fn mk_obstack_token(ccx: crate_ctxt, fcx: fn_ctxt) ->\n+fn mk_obstack_token(ccx: @crate_ctxt, fcx: fn_ctxt) ->\n    ValueRef {\n     let cx = raw_block(fcx, fcx.lldynamicallocas);\n     ret Call(cx, ccx.upcalls.dynastack_mark, []);\n@@ -620,7 +620,7 @@ fn get_tydesc(cx: block, t: ty::t, escapes: bool,\n     ret rslt(cx, info.tydesc);\n }\n \n-fn get_static_tydesc(ccx: crate_ctxt, t: ty::t, ty_params: [uint])\n+fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n     alt ccx.tydescs.find(t) {\n       some(info) { ret info; }\n@@ -677,7 +677,7 @@ fn set_glue_inlining(f: ValueRef, t: ty::t) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(ccx: crate_ctxt, t: ty::t, ty_params: [uint])\n+fn declare_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     let llsize;\n@@ -716,7 +716,7 @@ fn declare_tydesc(ccx: crate_ctxt, t: ty::t, ty_params: [uint])\n \n type glue_helper = fn@(block, ValueRef, ty::t);\n \n-fn declare_generic_glue(ccx: crate_ctxt, t: ty::t, llfnty: TypeRef,\n+fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: str) -> ValueRef {\n     let name = name;\n     let fn_nm;\n@@ -729,7 +729,7 @@ fn declare_generic_glue(ccx: crate_ctxt, t: ty::t, llfnty: TypeRef,\n     ret llfn;\n }\n \n-fn make_generic_glue_inner(ccx: crate_ctxt, t: ty::t,\n+fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n     let fcx = new_fn_ctxt(ccx, [], llfn, none);\n@@ -769,7 +769,7 @@ fn make_generic_glue_inner(ccx: crate_ctxt, t: ty::t,\n     ret llfn;\n }\n \n-fn make_generic_glue(ccx: crate_ctxt, t: ty::t, llfn: ValueRef,\n+fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, ty_params: [uint], name: str)\n     -> ValueRef {\n     if !ccx.sess.opts.stats {\n@@ -784,7 +784,7 @@ fn make_generic_glue(ccx: crate_ctxt, t: ty::t, llfn: ValueRef,\n     ret llval;\n }\n \n-fn emit_tydescs(ccx: crate_ctxt) {\n+fn emit_tydescs(ccx: @crate_ctxt) {\n     ccx.tydescs.items {|key, val|\n         let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n         let ti = val;\n@@ -1026,7 +1026,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n }\n \n // Structural comparison: a rather involved form of glue.\n-fn maybe_name_value(cx: crate_ctxt, v: ValueRef, s: str) {\n+fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n     if cx.sess.opts.save_temps {\n         let _: () = str::as_buf(s, {|buf| llvm::LLVMSetValueName(v, buf) });\n     }\n@@ -1237,21 +1237,21 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     ret cx;\n }\n \n-fn lazily_emit_all_tydesc_glue(ccx: crate_ctxt,\n+fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n                                static_ti: option<@tydesc_info>) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n }\n \n-fn lazily_emit_all_generic_info_tydesc_glues(ccx: crate_ctxt,\n+fn lazily_emit_all_generic_info_tydesc_glues(ccx: @crate_ctxt,\n                                              gi: generic_info) {\n     for ti: option<@tydesc_info> in gi.static_tis {\n         lazily_emit_all_tydesc_glue(ccx, ti);\n     }\n }\n \n-fn lazily_emit_tydesc_glue(ccx: crate_ctxt, field: int,\n+fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n                            static_ti: option<@tydesc_info>) {\n     alt static_ti {\n       none { }\n@@ -1571,7 +1571,7 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n     ret move_val(cx, action, dst, src, t);\n }\n \n-fn trans_crate_lit(cx: crate_ctxt, lit: ast::lit) -> ValueRef {\n+fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n     alt lit.node {\n       ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n       ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n@@ -2107,7 +2107,7 @@ fn trans_external_path(cx: block, did: ast::def_id,\n                          type_of_ty_param_bounds_and_ty(ccx, tpt));\n }\n \n-fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n+fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n                   dicts: option<typeck::dict_res>)\n     -> option<{llfn: ValueRef, fty: ty::t}> {\n     let substs = vec::map(substs, {|t|\n@@ -2171,7 +2171,7 @@ fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n }\n \n // FIXME[mono] Only actually translate things that are not generic\n-fn maybe_instantiate_inline(ccx: crate_ctxt, fn_id: ast::def_id)\n+fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n     alt ccx.external.find(fn_id) {\n       some(some(node_id)) {\n@@ -2300,7 +2300,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n \n-fn lookup_discriminant(ccx: crate_ctxt, vid: ast::def_id) -> ValueRef {\n+fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     alt ccx.discrims.find(vid) {\n       none {\n         // It's an external discriminant that we haven't seen yet.\n@@ -3947,7 +3947,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn new_fn_ctxt_w_id(ccx: crate_ctxt, path: path,\n+fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n                     llfndecl: ValueRef, id: ast::node_id,\n                     maybe_self_id: option<@ast::expr>,\n                     param_substs: option<param_substs>,\n@@ -3978,7 +3978,7 @@ fn new_fn_ctxt_w_id(ccx: crate_ctxt, path: path,\n           ccx: ccx};\n }\n \n-fn new_fn_ctxt(ccx: crate_ctxt, path: path, llfndecl: ValueRef,\n+fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n                sp: option<span>) -> fn_ctxt {\n     ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, none, none, sp);\n }\n@@ -4098,7 +4098,7 @@ enum self_arg { impl_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n+fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg,\n                  tps_bounds: [ty::param_bounds],\n@@ -4147,7 +4147,7 @@ fn trans_closure(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(ccx: crate_ctxt,\n+fn trans_fn(ccx: @crate_ctxt,\n             path: path,\n             decl: ast::fn_decl,\n             body: ast::blk,\n@@ -4172,7 +4172,7 @@ fn trans_fn(ccx: crate_ctxt,\n     }\n }\n \n-fn trans_res_ctor(ccx: crate_ctxt, path: path, dtor: ast::fn_decl,\n+fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, tps_bounds: [ty::param_bounds],\n                   param_substs: option<param_substs>, llfndecl: ValueRef) {\n     // Create a function for the constructor\n@@ -4206,7 +4206,7 @@ fn trans_res_ctor(ccx: crate_ctxt, path: path, dtor: ast::fn_decl,\n }\n \n \n-fn trans_enum_variant(ccx: crate_ctxt, enum_id: ast::node_id,\n+fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n                       ty_params: [ast::ty_param],\n                       param_substs: option<param_substs>,\n@@ -4275,7 +4275,7 @@ fn trans_enum_variant(ccx: crate_ctxt, enum_id: ast::node_id,\n // FIXME: this should do some structural hash-consing to avoid\n // duplicate constants. I think. Maybe LLVM has a magical mode\n // that does so later on?\n-fn trans_const_expr(cx: crate_ctxt, e: @ast::expr) -> ValueRef {\n+fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n       ast::expr_binary(b, e1, e2) {\n@@ -4369,7 +4369,7 @@ fn trans_const_expr(cx: crate_ctxt, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-fn trans_const(ccx: crate_ctxt, e: @ast::expr, id: ast::node_id) {\n+fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     let v = trans_const_expr(ccx, e);\n \n     // The scalars come back as 1st class LLVM vals\n@@ -4379,7 +4379,7 @@ fn trans_const(ccx: crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     llvm::LLVMSetGlobalConstant(g, True);\n }\n \n-fn trans_item(ccx: crate_ctxt, item: ast::item) {\n+fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let path = alt check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) { p }\n     };\n@@ -4513,11 +4513,11 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-fn trans_mod(ccx: crate_ctxt, m: ast::_mod) {\n+fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n     for item in m.items { trans_item(ccx, *item); }\n }\n \n-fn compute_ii_method_info(ccx: crate_ctxt,\n+fn compute_ii_method_info(ccx: @crate_ctxt,\n                           impl_did: ast::def_id,\n                           m: @ast::method,\n                           f: fn(ty::t, [ty::param_bounds], ast_map::path)) {\n@@ -4534,27 +4534,28 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn register_fn(ccx: crate_ctxt, sp: span, path: path, flav: str,\n+fn register_fn(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                ty_params: [ast::ty_param], node_id: ast::node_id)\n     -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let bnds = param_bounds(ccx, ty_params);\n     register_fn_full(ccx, sp, path, flav, bnds, node_id, t)\n }\n \n-fn param_bounds(ccx: crate_ctxt, tps: [ast::ty_param]) -> [ty::param_bounds] {\n+fn param_bounds(ccx: @crate_ctxt, tps: [ast::ty_param])\n+        -> [ty::param_bounds] {\n     vec::map(tps) {|tp| ccx.tcx.ty_param_bounds.get(tp.id) }\n }\n \n-fn register_fn_full(ccx: crate_ctxt, sp: span, path: path, flav: str,\n+fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                     bnds: [ty::param_bounds], node_id: ast::node_id,\n                     node_type: ty::t) -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type, bnds);\n     register_fn_fuller(ccx, sp, path, flav, node_id, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n \n-fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n+fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n                       node_id: ast::node_id, node_type: ty::t,\n                       cc: lib::llvm::CallConv, llfty: TypeRef) -> ValueRef {\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n@@ -4571,7 +4572,7 @@ fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n \n // Create a _rust_main(args: [str]) function which will be called from the\n // runtime rust_start function\n-fn create_main_wrapper(ccx: crate_ctxt, sp: span, main_llfn: ValueRef,\n+fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n                        main_node_type: ty::t) {\n \n     if ccx.main_fn != none::<ValueRef> {\n@@ -4589,7 +4590,7 @@ fn create_main_wrapper(ccx: crate_ctxt, sp: span, main_llfn: ValueRef,\n     ccx.main_fn = some(llfn);\n     create_entry_fn(ccx, llfn);\n \n-    fn create_main(ccx: crate_ctxt, main_llfn: ValueRef,\n+    fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef,\n                    takes_argv: bool) -> ValueRef {\n         let unit_ty = ty::mk_str(ccx.tcx);\n         let vecarg_ty: ty::arg =\n@@ -4617,7 +4618,7 @@ fn create_main_wrapper(ccx: crate_ctxt, sp: span, main_llfn: ValueRef,\n         ret llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: crate_ctxt, rust_main: ValueRef) {\n+    fn create_entry_fn(ccx: @crate_ctxt, rust_main: ValueRef) {\n         #[cfg(target_os = \"win32\")]\n         fn main_name() -> str { ret \"WinMain@16\"; }\n         #[cfg(target_os = \"macos\")]\n@@ -4669,13 +4670,13 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-fn item_path(ccx: crate_ctxt, i: @ast::item) -> path {\n+fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     *alt check ccx.tcx.items.get(i.id) {\n       ast_map::node_item(_, p) { p }\n     } + [path_name(i.ident)]\n }\n \n-fn get_item_val(ccx: crate_ctxt, id: ast::node_id) -> ValueRef {\n+fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     alt ccx.item_vals.find(id) {\n       some(v) { v }\n       none {\n@@ -4760,7 +4761,7 @@ fn get_item_val(ccx: crate_ctxt, id: ast::node_id) -> ValueRef {\n }\n \n // The constant translation pass.\n-fn trans_constant(ccx: crate_ctxt, it: @ast::item) {\n+fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_enum(variants, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n@@ -4796,7 +4797,7 @@ fn trans_constant(ccx: crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn trans_constants(ccx: crate_ctxt, crate: @ast::crate) {\n+fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_item: bind trans_constant(ccx, _)\n         with *visit::default_simple_visitor()\n@@ -4808,7 +4809,7 @@ fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     ret PtrToInt(cx, v, ccx.int_type);\n }\n \n-fn p2i(ccx: crate_ctxt, v: ValueRef) -> ValueRef {\n+fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     ret llvm::LLVMConstPtrToInt(v, ccx.int_type);\n }\n \n@@ -4872,7 +4873,7 @@ fn trap(bcx: block) {\n     }\n }\n \n-fn create_module_map(ccx: crate_ctxt) -> ValueRef {\n+fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct([ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     let map = str::as_buf(\"_rust_mod_map\", {|buf|\n@@ -4911,7 +4912,7 @@ fn decl_crate_map(sess: session::session, mapname: str,\n }\n \n // FIXME use hashed metadata instead of crate names once we have that\n-fn fill_crate_map(ccx: crate_ctxt, map: ValueRef) {\n+fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     let subcrates: [ValueRef] = [];\n     let i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -4929,7 +4930,7 @@ fn fill_crate_map(ccx: crate_ctxt, map: ValueRef) {\n          C_array(ccx.int_type, subcrates)]));\n }\n \n-fn write_metadata(cx: crate_ctxt, crate: @ast::crate) {\n+fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n     let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = C_struct([llmeta]);\n@@ -4952,7 +4953,7 @@ fn write_metadata(cx: crate_ctxt, crate: @ast::crate) {\n }\n \n // Writes the current ABI version into the crate.\n-fn write_abi_version(ccx: crate_ctxt) {\n+fn write_abi_version(ccx: @crate_ctxt) {\n     mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }"}, {"sha": "e40fc17221529e31d51e481032c78170582559c8", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -103,7 +103,7 @@ enum environment_value {\n     env_ref(ValueRef, ty::t, lval_kind),\n }\n \n-fn ev_to_str(ccx: crate_ctxt, ev: environment_value) -> str {\n+fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n     alt ev {\n       env_expr(ex, _) { expr_to_str(ex) }\n       env_copy(v, t, lk) { #fmt(\"copy(%s,%s)\", val_str(ccx.tn, v),\n@@ -720,7 +720,7 @@ enum target_info {\n }\n \n // pth is cx.path\n-fn trans_bind_thunk(ccx: crate_ctxt,\n+fn trans_bind_thunk(ccx: @crate_ctxt,\n                     path: path,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,"}, {"sha": "7b70647fa670d5a9d5d6b3640d1840203a95f814", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -74,7 +74,7 @@ type maps = {\n };\n \n // Crate context.  Every crate we compile has one of these.\n-type crate_ctxt = @{\n+type crate_ctxt = {\n      sess: session::session,\n      llmod: ModuleRef,\n      td: target_data,\n@@ -210,10 +210,10 @@ type fn_ctxt = @{\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: crate_ctxt\n+    ccx: @crate_ctxt\n };\n \n-fn warn_not_to_commit(ccx: crate_ctxt, msg: str) {\n+fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n     if !ccx.do_not_commit_warning_issued {\n         ccx.do_not_commit_warning_issued = true;\n         ccx.sess.warn(msg + \" -- do not commit like this!\");\n@@ -296,7 +296,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n     }\n }\n \n-fn get_res_dtor(ccx: crate_ctxt, did: ast::def_id, inner_t: ty::t)\n+fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n    -> ValueRef {\n     if did.crate == ast::local_crate {\n         ret base::get_item_val(ccx, did.node);\n@@ -414,7 +414,7 @@ fn block_parent(cx: block) -> block {\n // Accessors\n \n impl bxc_cxs for block {\n-    fn ccx() -> crate_ctxt { self.fcx.ccx }\n+    fn ccx() -> @crate_ctxt { self.fcx.ccx }\n     fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     fn sess() -> session { self.fcx.ccx.sess }\n }\n@@ -467,7 +467,7 @@ fn T_int(targ_cfg: @session::config) -> TypeRef {\n     };\n }\n \n-fn T_int_ty(cx: crate_ctxt, t: ast::int_ty) -> TypeRef {\n+fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n     alt t {\n       ast::ty_i { cx.int_type }\n       ast::ty_char { T_char() }\n@@ -478,7 +478,7 @@ fn T_int_ty(cx: crate_ctxt, t: ast::int_ty) -> TypeRef {\n     }\n }\n \n-fn T_uint_ty(cx: crate_ctxt, t: ast::uint_ty) -> TypeRef {\n+fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     alt t {\n       ast::ty_u { cx.int_type }\n       ast::ty_u8 { T_i8() }\n@@ -488,7 +488,7 @@ fn T_uint_ty(cx: crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     }\n }\n \n-fn T_float_ty(cx: crate_ctxt, t: ast::float_ty) -> TypeRef {\n+fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n     alt t {\n       ast::ty_f { cx.float_type }\n       ast::ty_f32 { T_f32() }\n@@ -516,7 +516,7 @@ fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n                                False);\n }\n \n-fn T_fn_pair(cx: crate_ctxt, tfn: TypeRef) -> TypeRef {\n+fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n     ret T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n@@ -568,7 +568,7 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(cx: crate_ctxt, field: int) -> TypeRef unsafe {\n+fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n@@ -580,7 +580,7 @@ fn T_tydesc_field(cx: crate_ctxt, field: int) -> TypeRef unsafe {\n     ret t;\n }\n \n-fn T_glue_fn(cx: crate_ctxt) -> TypeRef {\n+fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = \"glue_fn\";\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n@@ -619,7 +619,7 @@ fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n                   T_array(t, 0u)]); // elements\n }\n \n-fn T_vec(ccx: crate_ctxt, t: TypeRef) -> TypeRef {\n+fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n     ret T_vec2(ccx.sess.targ_cfg, t);\n }\n \n@@ -645,38 +645,38 @@ fn tuplify_cbox_ty(tcx: ty::ctxt, t: ty::t, tydesc_t: ty::t) -> ty::t {\n                          t]);\n }\n \n-fn T_box_header_fields(cx: crate_ctxt) -> [TypeRef] {\n+fn T_box_header_fields(cx: @crate_ctxt) -> [TypeRef] {\n     let ptr = T_ptr(T_i8());\n     ret [cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n }\n \n-fn T_box_header(cx: crate_ctxt) -> TypeRef {\n+fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n     ret T_struct(T_box_header_fields(cx));\n }\n \n-fn T_box(cx: crate_ctxt, t: TypeRef) -> TypeRef {\n+fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n     ret T_struct(T_box_header_fields(cx) + [t]);\n }\n \n-fn T_opaque_box(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n     ret T_box(cx, T_i8());\n }\n \n-fn T_opaque_box_ptr(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n     ret T_ptr(T_opaque_box(cx));\n }\n \n-fn T_port(cx: crate_ctxt, _t: TypeRef) -> TypeRef {\n+fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n     ret T_struct([cx.int_type]); // Refcount\n \n }\n \n-fn T_chan(cx: crate_ctxt, _t: TypeRef) -> TypeRef {\n+fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n     ret T_struct([cx.int_type]); // Refcount\n \n }\n \n-fn T_taskptr(cx: crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n+fn T_taskptr(cx: @crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n@@ -690,17 +690,17 @@ fn T_typaram(tn: type_names) -> TypeRef {\n \n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_opaque_cbox_ptr(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n     // closures look like boxes (even when they are fn~ or fn&)\n     // see trans_closure.rs\n     ret T_opaque_box_ptr(cx);\n }\n \n-fn T_enum_variant(cx: crate_ctxt) -> TypeRef {\n+fn T_enum_variant(cx: @crate_ctxt) -> TypeRef {\n     ret cx.int_type;\n }\n \n-fn T_enum(cx: crate_ctxt, size: uint) -> TypeRef {\n+fn T_enum(cx: @crate_ctxt, size: uint) -> TypeRef {\n     let s = \"enum_\" + uint::to_str(size, 10u);\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t =\n@@ -711,23 +711,23 @@ fn T_enum(cx: crate_ctxt, size: uint) -> TypeRef {\n     ret t;\n }\n \n-fn T_opaque_enum(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     let s = \"opaque_enum\";\n     alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_struct([T_enum_variant(cx), T_i8()]);\n     associate_type(cx.tn, s, t);\n     ret t;\n }\n \n-fn T_opaque_enum_ptr(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n     ret T_ptr(T_opaque_enum(cx));\n }\n \n-fn T_captured_tydescs(cx: crate_ctxt, n: uint) -> TypeRef {\n+fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_iface(cx: crate_ctxt) -> TypeRef {\n+fn T_opaque_iface(cx: @crate_ctxt) -> TypeRef {\n     T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n }\n \n@@ -769,11 +769,11 @@ fn C_i64(i: i64) -> ValueRef {\n     ret C_integral(T_i64(), i as u64, True);\n }\n \n-fn C_int(cx: crate_ctxt, i: int) -> ValueRef {\n+fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n     ret C_integral(cx.int_type, i as u64, True);\n }\n \n-fn C_uint(cx: crate_ctxt, i: uint) -> ValueRef {\n+fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n     ret C_integral(cx.int_type, i as u64, False);\n }\n \n@@ -782,7 +782,7 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: crate_ctxt, s: str) -> ValueRef {\n+fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n     let sc = str::as_buf(s) {|buf|\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n@@ -831,7 +831,7 @@ fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n         bytes.len() as c_uint, False);\n }\n \n-fn C_shape(ccx: crate_ctxt, bytes: [u8]) -> ValueRef {\n+fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n     let llglobal = str::as_buf(ccx.names(\"shape\"), {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n@@ -842,7 +842,7 @@ fn C_shape(ccx: crate_ctxt, bytes: [u8]) -> ValueRef {\n     ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n }\n \n-pure fn type_has_static_size(cx: crate_ctxt, t: ty::t) -> bool {\n+pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n     !ty::type_has_dynamic_size(cx.tcx, t)\n }\n "}, {"sha": "0bb9645c43f76b19507349b4f4b16d38d49d2357", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -73,7 +73,7 @@ fn llnull() -> ValueRef unsafe {\n     unsafe::reinterpret_cast(ptr::null::<ValueRef>())\n }\n \n-fn add_named_metadata(cx: crate_ctxt, name: str, val: ValueRef) {\n+fn add_named_metadata(cx: @crate_ctxt, name: str, val: ValueRef) {\n     str::as_buf(name, {|sbuf|\n         llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf,\n                                           val)\n@@ -154,7 +154,7 @@ fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n     ret option::none;\n }\n \n-fn create_compile_unit(cx: crate_ctxt, full_path: str)\n+fn create_compile_unit(cx: @crate_ctxt, full_path: str)\n     -> @metadata<compile_unit_md> unsafe {\n     let cache = get_cache(cx);\n     let tg = CompileUnitTag;\n@@ -192,11 +192,11 @@ fn create_compile_unit(cx: crate_ctxt, full_path: str)\n     ret mdval;\n }\n \n-fn get_cache(cx: crate_ctxt) -> metadata_cache {\n+fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n     option::get(cx.dbg_cx).llmetadata\n }\n \n-fn create_file(cx: crate_ctxt, full_path: str) -> @metadata<file_md> {\n+fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n     alt cached_metadata::<@metadata<file_md>>(\n@@ -268,13 +268,13 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     ret mdval;\n }\n \n-fn size_and_align_of(cx: crate_ctxt, t: ty::t) -> (int, int) {\n+fn size_and_align_of(cx: @crate_ctxt, t: ty::t) -> (int, int) {\n     let llty = type_of::type_of(cx, t);\n     (shape::llsize_of_real(cx, llty) as int,\n      shape::llalign_of_real(cx, llty) as int)\n }\n \n-fn create_basic_type(cx: crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n+fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     -> @metadata<tydesc_md> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n@@ -329,7 +329,7 @@ fn create_basic_type(cx: crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     ret mdval;\n }\n \n-fn create_pointer_type(cx: crate_ctxt, t: ty::t, span: span,\n+fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n                        pointee: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     let tg = PointerTypeTag;\n@@ -402,7 +402,7 @@ fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n     cx.total_size += size * 8;\n }\n \n-fn create_record(cx: crate_ctxt, t: ty::t, fields: [ast::ty_field],\n+fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n                  span: span) -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n@@ -422,7 +422,7 @@ fn create_record(cx: crate_ctxt, t: ty::t, fields: [ast::ty_field],\n     ret mdval;\n }\n \n-fn create_boxed_type(cx: crate_ctxt, outer: ty::t, _inner: ty::t,\n+fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n                      span: span, boxed: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     //let tg = StructureTypeTag;\n@@ -481,7 +481,7 @@ fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n     ret llmdnode(lldata);\n }\n \n-fn create_vec(cx: crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n+fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n               vec_ty_span: codemap::span, elem_ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, vec_ty_span);\n@@ -506,7 +506,7 @@ fn create_vec(cx: crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     ret @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n }\n \n-fn create_ty(_cx: crate_ctxt, _t: ty::t, _ty: @ast::ty)\n+fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<tydesc_md>>(\n@@ -610,7 +610,7 @@ fn create_ty(_cx: crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     */\n }\n \n-fn filename_from_span(cx: crate_ctxt, sp: codemap::span) -> str {\n+fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> str {\n     codemap::lookup_char_pos(cx.sess.codemap, sp.lo).file.name\n }\n "}, {"sha": "9dd4b2c6c3effe31111bdf9893fbb19b8a03a47b", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -43,7 +43,7 @@ import std::map::hashmap;\n // annotates nodes with information about the methods and dicts that\n // are referenced (ccx.method_map and ccx.dict_map).\n \n-fn trans_impl(ccx: crate_ctxt, path: path, name: ast::ident,\n+fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: [@ast::method], tps: [ast::ty_param]) {\n     let sub_path = path + [path_name(name)];\n     for m in methods {\n@@ -104,7 +104,7 @@ fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n      with lval_static_fn(bcx, did, callee_id, substs)}\n }\n \n-fn wrapper_fn_ty(ccx: crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n+fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n                  tps: @[ty::param_bounds]) -> {ty: ty::t, llty: TypeRef} {\n     let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *tps);\n     let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n@@ -207,7 +207,7 @@ fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     {inputs: args, output: out_ty}\n }\n \n-fn trans_vtable(ccx: crate_ctxt, id: ast::node_id, name: str,\n+fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n                 ptrs: [ValueRef]) {\n     let tbl = C_struct(ptrs);\n     let vt_gvar = str::as_buf(name, {|buf|\n@@ -269,7 +269,7 @@ fn resolve_dicts_in_fn_ctxt(fcx: fn_ctxt, dicts: typeck::dict_res)\n     some(@result)\n }\n \n-fn trans_wrapper(ccx: crate_ctxt, pt: path, llfty: TypeRef,\n+fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n                  fill: fn(ValueRef, block) -> block)\n     -> ValueRef {\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n@@ -282,7 +282,7 @@ fn trans_wrapper(ccx: crate_ctxt, pt: path, llfty: TypeRef,\n     ret llfn;\n }\n \n-fn trans_impl_wrapper(ccx: crate_ctxt, pt: path,\n+fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n                       extra_tps: [ty::param_bounds], real_fn: ValueRef)\n     -> ValueRef {\n     let {inputs: real_args, output: real_ret} =\n@@ -327,7 +327,7 @@ fn trans_impl_wrapper(ccx: crate_ctxt, pt: path,\n     })\n }\n \n-fn trans_impl_vtable(ccx: crate_ctxt, pt: path,\n+fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n                      iface_id: ast::def_id, ms: [@ast::method],\n                      tps: [ast::ty_param], it: @ast::item) {\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id)),\n@@ -350,7 +350,7 @@ fn trans_impl_vtable(ccx: crate_ctxt, pt: path,\n     trans_vtable(ccx, it.id, s, ptrs);\n }\n \n-fn trans_iface_wrapper(ccx: crate_ctxt, pt: path, m: ty::method,\n+fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n                        n: uint) -> ValueRef {\n     let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()),\n                                          ty::mk_fn(ccx.tcx, m.fty), m.tps);\n@@ -376,7 +376,7 @@ fn trans_iface_wrapper(ccx: crate_ctxt, pt: path, m: ty::method,\n     })\n }\n \n-fn trans_iface_vtable(ccx: crate_ctxt, pt: path, it: @ast::item) {\n+fn trans_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id))];\n     let i_did = ast_util::local_def(it.id), i = 0u;\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, i_did), {|m|\n@@ -481,7 +481,7 @@ fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n     -> {bcx: block, ptrs: [ValueRef]} {\n     let ccx = bcx.ccx();\n-    fn get_vtable(ccx: crate_ctxt, did: ast::def_id) -> ValueRef {\n+    fn get_vtable(ccx: @crate_ctxt, did: ast::def_id) -> ValueRef {\n         if did.crate == ast::local_crate {\n             get_item_val(ccx, did.node)\n         } else {"}, {"sha": "20637e32c9a6b1f49227e656af5f020dc2fabcc1", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -29,7 +29,7 @@ type c_stack_tys = {\n     shim_fn_ty: TypeRef\n };\n \n-fn c_arg_and_ret_lltys(ccx: crate_ctxt,\n+fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> ([TypeRef], TypeRef, ty::t) {\n     alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n@@ -41,7 +41,7 @@ fn c_arg_and_ret_lltys(ccx: crate_ctxt,\n     }\n }\n \n-fn c_stack_tys(ccx: crate_ctxt,\n+fn c_stack_tys(ccx: @crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n     let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n@@ -60,7 +60,7 @@ type shim_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef, llretval: ValueRef);\n \n-fn build_shim_fn_(ccx: crate_ctxt,\n+fn build_shim_fn_(ccx: @crate_ctxt,\n                   shim_name: str,\n                   llbasefn: ValueRef,\n                   tys: @c_stack_tys,\n@@ -97,7 +97,7 @@ type wrap_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n type wrap_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef);\n \n-fn build_wrap_fn_(ccx: crate_ctxt,\n+fn build_wrap_fn_(ccx: @crate_ctxt,\n                   tys: @c_stack_tys,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n@@ -161,9 +161,9 @@ fn build_wrap_fn_(ccx: crate_ctxt,\n // stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n-fn trans_native_mod(ccx: crate_ctxt,\n+fn trans_native_mod(ccx: @crate_ctxt,\n                     native_mod: ast::native_mod, abi: ast::native_abi) {\n-    fn build_shim_fn(ccx: crate_ctxt,\n+    fn build_shim_fn(ccx: @crate_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n@@ -204,7 +204,7 @@ fn trans_native_mod(ccx: crate_ctxt,\n                            build_args, build_ret);\n     }\n \n-    fn build_wrap_fn(ccx: crate_ctxt,\n+    fn build_wrap_fn(ccx: @crate_ctxt,\n                      tys: @c_stack_tys,\n                      num_tps: uint,\n                      llshimfn: ValueRef,\n@@ -260,10 +260,10 @@ fn trans_native_mod(ccx: crate_ctxt,\n     }\n }\n \n-fn trans_crust_fn(ccx: crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n+fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                   body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n \n-    fn build_rust_fn(ccx: crate_ctxt, path: ast_map::path,\n+    fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      decl: ast::fn_decl, body: ast::blk,\n                      id: ast::node_id) -> ValueRef {\n         let t = ty::node_id_to_type(ccx.tcx, id);\n@@ -276,7 +276,7 @@ fn trans_crust_fn(ccx: crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         ret llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: crate_ctxt, path: ast_map::path,\n+    fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n@@ -309,7 +309,7 @@ fn trans_crust_fn(ccx: crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                            build_args, build_ret);\n     }\n \n-    fn build_wrap_fn(ccx: crate_ctxt, llshimfn: ValueRef,\n+    fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n@@ -347,7 +347,7 @@ fn trans_crust_fn(ccx: crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n }\n \n-fn register_crust_fn(ccx: crate_ctxt, sp: span,\n+fn register_crust_fn(ccx: @crate_ctxt, sp: span,\n                      path: ast_map::path, node_id: ast::node_id)\n     -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n@@ -357,7 +357,7 @@ fn register_crust_fn(ccx: crate_ctxt, sp: span,\n                        t, lib::llvm::CCallConv, llfty)\n }\n \n-fn abi_of_native_fn(ccx: crate_ctxt, i: @ast::native_item)\n+fn abi_of_native_fn(ccx: @crate_ctxt, i: @ast::native_item)\n     -> ast::native_abi {\n     alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n       none {\n@@ -374,7 +374,7 @@ fn abi_of_native_fn(ccx: crate_ctxt, i: @ast::native_item)\n     }\n }\n \n-fn decl_native_fn(ccx: crate_ctxt, i: @ast::native_item,\n+fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n                   pth: ast_map::path) -> ValueRef {\n     alt i.node {\n       ast::native_item_fn(_, tps) {"}, {"sha": "a0afd1c7c7c7157b93de40d34837fe2dd0f1c37c", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -76,7 +76,7 @@ fn eq_res_info(a: res_info, b: res_info) -> bool {\n     ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n }\n \n-fn mk_global(ccx: crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n+fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n     let llglobal =\n         str::as_buf(name,\n@@ -101,7 +101,7 @@ fn mk_global(ccx: crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n //\n // FIXME: Use this in dynamic_size_of() as well.\n \n-fn largest_variants(ccx: crate_ctxt, tag_id: ast::def_id) -> [uint] {\n+fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n     //\n     // FIXME: We could do better here; e.g. we know that any variant that\n@@ -180,7 +180,7 @@ fn round_up(size: u16, align: u8) -> u16 {\n \n type size_align = {size: u16, align: u8};\n \n-fn compute_static_enum_size(ccx: crate_ctxt, largest_variants: [uint],\n+fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n                            did: ast::def_id) -> size_align {\n     let max_size = 0u16;\n     let max_align = 1u8;\n@@ -220,7 +220,7 @@ enum enum_kind {\n     tk_complex  // N variants, no data\n }\n \n-fn enum_kind(ccx: crate_ctxt, did: ast::def_id) -> enum_kind {\n+fn enum_kind(ccx: @crate_ctxt, did: ast::def_id) -> enum_kind {\n     let variants = ty::enum_variants(ccx.tcx, did);\n     if vec::any(*variants) {|v| vec::len(v.args) > 0u} {\n         if vec::len(*variants) == 1u { tk_newtype }\n@@ -294,7 +294,7 @@ fn add_substr(&dest: [u8], src: [u8]) {\n     dest += src;\n }\n \n-fn shape_of(ccx: crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n+fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n     let s = [];\n \n     alt ty::get(t).struct {\n@@ -438,7 +438,7 @@ fn shape_of(ccx: crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx: crate_ctxt, v: ty::variant_info,\n+fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n                     ty_param_count: uint) -> [u8] {\n     let ty_param_map = [];\n     let i = 0u;\n@@ -449,7 +449,7 @@ fn shape_of_variant(ccx: crate_ctxt, v: ty::variant_info,\n     ret s;\n }\n \n-fn gen_enum_shapes(ccx: crate_ctxt) -> ValueRef {\n+fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // Loop over all the enum variants and write their shapes into a\n     // data buffer. As we do this, it's possible for us to discover\n     // new enums, so we must do this first.\n@@ -547,7 +547,7 @@ fn gen_enum_shapes(ccx: crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"tag_shapes\", C_bytes(header), true);\n }\n \n-fn gen_resource_shapes(ccx: crate_ctxt) -> ValueRef {\n+fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let dtors = [];\n     let i = 0u;\n     let len = interner::len(ccx.shape_cx.resources);\n@@ -560,7 +560,7 @@ fn gen_resource_shapes(ccx: crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }\n \n-fn gen_shape_tables(ccx: crate_ctxt) {\n+fn gen_shape_tables(ccx: @crate_ctxt) {\n     let lltagstable = gen_enum_shapes(ccx);\n     let llresourcestable = gen_resource_shapes(ccx);\n     trans::common::set_struct_body(ccx.shape_cx.llshapetablesty,\n@@ -623,21 +623,21 @@ fn metrics(bcx: block, t: ty::t) -> metrics {\n }\n \n // Returns the real size of the given type for the current target.\n-fn llsize_of_real(cx: crate_ctxt, t: TypeRef) -> uint {\n+fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the real alignment of the given type for the current target.\n-fn llalign_of_real(cx: crate_ctxt, t: TypeRef) -> uint {\n+fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n-fn llsize_of(cx: crate_ctxt, t: TypeRef) -> ValueRef {\n+fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n                                False);\n }\n \n-fn llalign_of(cx: crate_ctxt, t: TypeRef) -> ValueRef {\n+fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n                                False);\n }\n@@ -648,7 +648,7 @@ fn llalign_of(cx: crate_ctxt, t: TypeRef) -> ValueRef {\n // FIXME: Migrate trans over to use this.\n \n // Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_enum(cx: crate_ctxt, t: ty::t) -> uint {\n+fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::get(t).struct {\n       ty::ty_enum(tid, subtys) {"}, {"sha": "234b8e8ebda0eea3f48526a5317ed6000ffc5ec9", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/273c5e5f1129949db780619901fe54b9a3d1fecf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=273c5e5f1129949db780619901fe54b9a3d1fecf", "patch": "@@ -7,7 +7,7 @@ import std::map::hashmap;\n \n import ty::*;\n \n-fn type_of_explicit_args(cx: crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n+fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n         let llty = type_of(cx, arg_ty);\n@@ -18,7 +18,7 @@ fn type_of_explicit_args(cx: crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     }\n }\n \n-fn type_of_fn(cx: crate_ctxt, inputs: [ty::arg],\n+fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n               output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n@@ -44,12 +44,12 @@ fn type_of_fn(cx: crate_ctxt, inputs: [ty::arg],\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: crate_ctxt, fty: ty::t,\n+fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n                       param_bounds: [ty::param_bounds]) -> TypeRef {\n     type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n }\n \n-fn type_of(cx: crate_ctxt, t: ty::t) -> TypeRef {\n+fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     assert !ty::type_has_vars(t);\n     // Check the cache.\n \n@@ -135,7 +135,7 @@ fn type_of(cx: crate_ctxt, t: ty::t) -> TypeRef {\n     ret llty;\n }\n \n-fn type_of_enum(cx: crate_ctxt, did: ast::def_id, t: ty::t)\n+fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n     let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n     if check type_has_static_size(cx, t) {\n@@ -151,7 +151,7 @@ fn type_of_enum(cx: crate_ctxt, did: ast::def_id, t: ty::t)\n }\n \n fn type_of_ty_param_bounds_and_ty\n-    (ccx: crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n+    (ccx: @crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n     let t = tpt.ty;\n     alt ty::get(t).struct {\n       ty::ty_fn(_) {\n@@ -164,7 +164,7 @@ fn type_of_ty_param_bounds_and_ty\n     type_of(ccx, t)\n }\n \n-fn type_of_or_i8(ccx: crate_ctxt, typ: ty::t) -> TypeRef {\n+fn type_of_or_i8(ccx: @crate_ctxt, typ: ty::t) -> TypeRef {\n     if check type_has_static_size(ccx, typ) {\n         type_of(ccx, typ)\n     } else { T_i8() }"}]}