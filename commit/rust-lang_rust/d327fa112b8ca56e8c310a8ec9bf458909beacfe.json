{"sha": "d327fa112b8ca56e8c310a8ec9bf458909beacfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjdmYTExMmI4Y2E1NmU4YzMxMGE4ZWM5YmY0NTg5MDliZWFjZmU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-10T07:06:30Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-18T14:25:25Z"}, "message": "initial working state", "tree": {"sha": "f5c79a107ae23b1402641c81726e07e27d8e59ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5c79a107ae23b1402641c81726e07e27d8e59ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d327fa112b8ca56e8c310a8ec9bf458909beacfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d327fa112b8ca56e8c310a8ec9bf458909beacfe", "html_url": "https://github.com/rust-lang/rust/commit/d327fa112b8ca56e8c310a8ec9bf458909beacfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d327fa112b8ca56e8c310a8ec9bf458909beacfe/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c69266c0697b0c0b34abea62cba1a1d3c59c90c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c69266c0697b0c0b34abea62cba1a1d3c59c90c", "html_url": "https://github.com/rust-lang/rust/commit/2c69266c0697b0c0b34abea62cba1a1d3c59c90c"}], "stats": {"total": 326, "additions": 313, "deletions": 13}, "files": [{"sha": "48fe8dafd534360146754ae486366e04e3667b99", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -0,0 +1,15 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty;\n+\n+/// An index into an `AbstractConst`.\n+pub type NodeId = usize;\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable)]\n+pub enum Node<'tcx> {\n+    Leaf(&'tcx ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+}"}, {"sha": "be61b67680750a642317481051e183c23a00e82b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -40,6 +40,7 @@ use std::{iter, mem, option};\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n+pub mod abstract_const;\n pub mod coverage;\n pub mod interpret;\n pub mod mono;"}, {"sha": "41b8bb60ef5eaf6c28b2fb19b775b9484c10d063", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -244,6 +244,25 @@ rustc_queries! {\n             no_hash\n         }\n \n+        /// Try to build an abstract representation of the given constant.\n+        query mir_abstract_const(\n+            key: DefId\n+        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+            desc {\n+                |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n+            }\n+        }\n+        /// Try to build an abstract representation of the given constant.\n+        query mir_abstract_const_of_const_arg(\n+            key: (LocalDefId, DefId)\n+        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+            desc {\n+                |tcx|\n+                \"building an abstract representation for the const argument {}\",\n+                tcx.def_path_str(key.0.to_def_id()),\n+            }\n+        }\n+\n         query mir_drops_elaborated_and_const_checked(\n             key: ty::WithOptConstParam<LocalDefId>\n         ) -> &'tcx Steal<mir::Body<'tcx>> {"}, {"sha": "226282fe4263c065d267a7f27e07352dd2df128b", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -329,7 +329,11 @@ fn mir_promoted(\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n-\n+    let _ = if let Some(param_did) = def.const_param_did {\n+        tcx.mir_abstract_const_of_const_arg((def.did, param_did))\n+    } else {\n+        tcx.mir_abstract_const(def.did.to_def_id())\n+    };\n     let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();"}, {"sha": "da1996b92a60b520f4fab62e38031a9f3bc266f9", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -12,6 +12,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n+#![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "9d74de44d171c8f1be90d671e81ce38df1675962", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 244, "deletions": 12, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -1,10 +1,17 @@\n+#![allow(warnings)]\n use rustc_hir::def::DefKind;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::mir::abstract_const::{Node, NodeId};\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{self, Rvalue, StatementKind, TerminatorKind};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, TypeFoldable};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -16,18 +23,23 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        // FIXME(const_evaluatable_checked): Actually look into generic constants to\n-        // implement const equality.\n-        for pred in param_env.caller_bounds() {\n-            match pred.skip_binders() {\n-                ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n-                    debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n-                    if b_def == def && b_substs == substs {\n-                        debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n-                        return Ok(());\n+        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs) {\n+            for pred in param_env.caller_bounds() {\n+                match pred.skip_binders() {\n+                    ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n+                        debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n+                        if b_def == def && b_substs == substs {\n+                            debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n+                            return Ok(());\n+                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)\n+                            .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n+                        {\n+                            debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                            return Ok(());\n+                        }\n                     }\n+                    _ => {} // don't care\n                 }\n-                _ => {} // don't care\n             }\n         }\n     }\n@@ -76,3 +88,223 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     debug!(?concrete, \"is_const_evaluatable\");\n     concrete.map(drop)\n }\n+\n+/// A tree representing an anonymous constant.\n+///\n+/// This is only able to represent a subset of `MIR`,\n+/// and should not leak any information about desugarings.\n+#[derive(Clone, Copy)]\n+pub struct AbstractConst<'tcx> {\n+    pub inner: &'tcx [Node<'tcx>],\n+    pub substs: SubstsRef<'tcx>,\n+}\n+\n+impl AbstractConst<'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        def: ty::WithOptConstParam<DefId>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        let inner = match (def.did.as_local(), def.const_param_did) {\n+            (Some(did), Some(param_did)) => {\n+                tcx.mir_abstract_const_of_const_arg((did, param_did))?\n+            }\n+            _ => tcx.mir_abstract_const(def.did)?,\n+        };\n+\n+        Some(AbstractConst { inner, substs })\n+    }\n+\n+    #[inline]\n+    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n+        AbstractConst { inner: &self.inner[..=node], substs: self.substs }\n+    }\n+\n+    #[inline]\n+    pub fn root(self) -> Node<'tcx> {\n+        self.inner.last().copied().unwrap()\n+    }\n+}\n+\n+struct AbstractConstBuilder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a mir::Body<'tcx>,\n+    nodes: Vec<Node<'tcx>>,\n+    locals: IndexVec<mir::Local, NodeId>,\n+    checked_op_locals: BitSet<mir::Local>,\n+}\n+\n+impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>) -> Option<AbstractConstBuilder<'a, 'tcx>> {\n+        if body.is_cfg_cyclic() {\n+            return None;\n+        }\n+\n+        Some(AbstractConstBuilder {\n+            tcx,\n+            body,\n+            nodes: vec![],\n+            locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n+            checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n+        })\n+    }\n+\n+    fn add_node(&mut self, n: Node<'tcx>) -> NodeId {\n+        let len = self.nodes.len();\n+        self.nodes.push(n);\n+        len\n+    }\n+\n+    fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n+        debug!(\"operand_to_node: op={:?}\", op);\n+        const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n+        match op {\n+            mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                if let Some(p) = p.as_local() {\n+                    debug_assert!(!self.checked_op_locals.contains(p));\n+                    Some(self.locals[p])\n+                } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n+                    // Only allow field accesses on the result of checked operations.\n+                    if self.checked_op_locals.contains(p.local) {\n+                        Some(self.locals[p.local])\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            }\n+            mir::Operand::Constant(ct) => Some(self.add_node(Node::Leaf(ct.literal))),\n+        }\n+    }\n+\n+    fn check_binop(op: mir::BinOp) -> bool {\n+        use mir::BinOp::*;\n+        match op {\n+            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n+            | Ne | Ge | Gt => true,\n+            Offset => false,\n+        }\n+    }\n+\n+    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n+        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n+        loop {\n+            debug!(\"AbstractConstBuilder: block={:?}\", block);\n+            for stmt in block.statements.iter() {\n+                debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+                match stmt.kind {\n+                    StatementKind::Assign(box (ref place, ref rvalue)) => {\n+                        let local = place.as_local()?;\n+                        match *rvalue {\n+                            Rvalue::Use(ref operand) => {\n+                                self.locals[local] = self.operand_to_node(operand)?;\n+                            }\n+                            Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n+                                let lhs = self.operand_to_node(lhs)?;\n+                                let rhs = self.operand_to_node(rhs)?;\n+                                self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                                if op.is_checkable() {\n+                                    bug!(\"unexpected unchecked checkable binary operation\");\n+                                }\n+                            }\n+                            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs)\n+                                if Self::check_binop(op) =>\n+                            {\n+                                let lhs = self.operand_to_node(lhs)?;\n+                                let rhs = self.operand_to_node(rhs)?;\n+                                self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                                self.checked_op_locals.insert(local);\n+                            }\n+                            _ => return None,\n+                        }\n+                    }\n+                    _ => return None,\n+                }\n+            }\n+\n+            debug!(\"AbstractConstBuilder: terminator={:?}\", block.terminator());\n+            match block.terminator().kind {\n+                TerminatorKind::Goto { target } => {\n+                    block = &self.body.basic_blocks()[target];\n+                }\n+                TerminatorKind::Return => {\n+                    warn!(?self.nodes);\n+                    return { Some(self.tcx.arena.alloc_from_iter(self.nodes)) };\n+                }\n+                TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n+                    let p = match cond {\n+                        mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n+                        mir::Operand::Constant(_) => bug!(\"Unexpected assert\"),\n+                    };\n+\n+                    const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n+                    debug!(\"proj: {:?}\", p.projection);\n+                    if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                        // Only allow asserts checking the result of a checked operation.\n+                        if self.checked_op_locals.contains(p.local) {\n+                            block = &self.body.basic_blocks()[target];\n+                            continue;\n+                        }\n+                    }\n+\n+                    return None;\n+                }\n+                _ => return None,\n+            }\n+        }\n+    }\n+}\n+\n+/// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n+pub(super) fn mir_abstract_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+) -> Option<&'tcx [Node<'tcx>]> {\n+    if !tcx.features().const_evaluatable_checked {\n+        None\n+    } else {\n+        let body = tcx.mir_const(def).borrow();\n+        AbstractConstBuilder::new(tcx, &body)?.build()\n+    }\n+}\n+\n+pub fn try_unify<'tcx>(tcx: TyCtxt<'tcx>, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+    match (a.root(), b.root()) {\n+        (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+            let a_ct = a_ct.subst(tcx, a.substs);\n+            let b_ct = b_ct.subst(tcx, b.substs);\n+            match (a_ct.val, b_ct.val) {\n+                (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                    a_param == b_param\n+                }\n+                (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                // means that we can't do anything with inference variables here.\n+                (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => false,\n+                // FIXME(const_evaluatable_checked): We may want to either actually try\n+                // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                // this, for now we just return false here.\n+                _ => false,\n+            }\n+        }\n+        (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+            try_unify(tcx, a.subtree(al), b.subtree(bl))\n+                && try_unify(tcx, a.subtree(ar), b.subtree(br))\n+        }\n+        (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+            try_unify(tcx, a.subtree(av), b.subtree(bv))\n+        }\n+        (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+            if a_args.len() == b_args.len() =>\n+        {\n+            try_unify(tcx, a.subtree(a_f), b.subtree(b_f))\n+                && a_args\n+                    .iter()\n+                    .zip(b_args)\n+                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "2f0b66ec8c941f1006b5f9bd4d910f06123c1b67", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -552,6 +552,20 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_methods,\n         type_implements_trait,\n         subst_and_check_impossible_predicates,\n+        mir_abstract_const: |tcx, def_id| {\n+            let def_id = def_id.as_local()?; // We do not store failed AbstractConst's.\n+            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n+                tcx.mir_abstract_const_of_const_arg(def)\n+            } else {\n+                const_evaluatable::mir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+            }\n+        },\n+        mir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            const_evaluatable::mir_abstract_const(\n+                tcx,\n+                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n+            )\n+        },\n         ..*providers\n     };\n }"}, {"sha": "907ea255abb0836ef10e37eec6d5aed852e4d2af", "filename": "src/test/ui/const-generics/const_evaluatable_checked/less_than.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d327fa112b8ca56e8c310a8ec9bf458909beacfe/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fless_than.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327fa112b8ca56e8c310a8ec9bf458909beacfe/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fless_than.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fless_than.rs?ref=d327fa112b8ca56e8c310a8ec9bf458909beacfe", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<const B: bool>;\n+\n+fn test<const N: usize>() -> Foo<{ N > 10 }> where Foo<{ N > 10 }>: Sized {\n+    Foo\n+}\n+\n+fn main() {\n+    let _: Foo<true> = test::<12>();\n+    let _: Foo<false> = test::<9>();\n+}"}]}