{"sha": "92dcae47425a9084b97680bc0327ac88353b8a68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZGNhZTQ3NDI1YTkwODRiOTc2ODBiYzAzMjdhYzg4MzUzYjhhNjg=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-02-01T11:43:29Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-02-12T08:55:20Z"}, "message": "Add internal impl_fn_for_zst macro for \"named closure types\"", "tree": {"sha": "749a35073c0079522982002ef09487a9d0fdf7ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/749a35073c0079522982002ef09487a9d0fdf7ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92dcae47425a9084b97680bc0327ac88353b8a68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92dcae47425a9084b97680bc0327ac88353b8a68", "html_url": "https://github.com/rust-lang/rust/commit/92dcae47425a9084b97680bc0327ac88353b8a68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92dcae47425a9084b97680bc0327ac88353b8a68/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d", "html_url": "https://github.com/rust-lang/rust/commit/75f9159009cd0814bd6b5c3bf6a5406de7c4fe8d"}], "stats": {"total": 188, "additions": 75, "deletions": 113}, "files": [{"sha": "419980225c3358840380b0b4fd2e2cc5775a0862", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92dcae47425a9084b97680bc0327ac88353b8a68/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dcae47425a9084b97680bc0327ac88353b8a68/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=92dcae47425a9084b97680bc0327ac88353b8a68", "patch": "@@ -95,6 +95,7 @@\n #![feature(simd_ffi)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]"}, {"sha": "bc5d35f71911428fbbca49bbf41d9b5c2a388bdd", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/92dcae47425a9084b97680bc0327ac88353b8a68/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dcae47425a9084b97680bc0327ac88353b8a68/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=92dcae47425a9084b97680bc0327ac88353b8a68", "patch": "@@ -749,3 +749,49 @@ mod builtin {\n         ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n     }\n }\n+\n+/// Create a named zero-size type similar to a closure.\n+#[doc(hidden)]\n+#[macro_export]\n+#[unstable(feature = \"std_internals\", issue = \"0\")]\n+macro_rules! impl_fn_for_zst {\n+    ($(\n+        $( #[$attr: meta] )*\n+        // FIXME: when libcore is in the 2018 edition, use `?` repetition in\n+        // $( <$( $li : lifetime ),+> )?\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )* Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+            $body: block;\n+    )+) => {\n+        $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )* Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+    }\n+}"}, {"sha": "eefed5173300108285e961141869ed5c4e285674", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 28, "deletions": 113, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/92dcae47425a9084b97680bc0327ac88353b8a68/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dcae47425a9084b97680bc0327ac88353b8a68/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=92dcae47425a9084b97680bc0327ac88353b8a68", "patch": "@@ -1345,33 +1345,14 @@ impl FusedIterator for Lines<'_> {}\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n-/// A nameable, cloneable fn type\n-#[derive(Clone)]\n-struct LinesAnyMap;\n-\n-impl<'a> Fn<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (line,): (&'a str,)) -> &'a str {\n+impl_fn_for_zst! {\n+    /// A nameable, cloneable fn type\n+    #[derive(Clone)]\n+    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n         let l = line.len();\n         if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n         else { line }\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&*self, (line,))\n-    }\n-}\n-\n-impl<'a> FnOnce<(&'a str,)> for LinesAnyMap {\n-    type Output = &'a str;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&self, (line,))\n-    }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2727,7 +2708,7 @@ impl str {\n         let inner = self\n             .as_bytes()\n             .split(IsAsciiWhitespace)\n-            .filter(IsNotEmpty)\n+            .filter(BytesIsNotEmpty)\n             .map(UnsafeBytesToStr);\n         SplitAsciiWhitespace { inner }\n     }\n@@ -4011,102 +3992,36 @@ pub struct SplitWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct SplitAsciiWhitespace<'a> {\n-    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, IsNotEmpty>, UnsafeBytesToStr>,\n-}\n-\n-#[derive(Clone)]\n-struct IsWhitespace;\n-\n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n-    }\n+    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n-impl FnMut<(char, )> for IsWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsAsciiWhitespace;\n-\n-impl<'a> FnOnce<(&'a u8, )> for IsAsciiWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&u8, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a u8, )> for IsAsciiWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&u8, )) -> bool {\n-        arg.0.is_ascii_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b str, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b str, )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n-\n-impl<'a, 'b> FnOnce<(&'a &'b [u8], )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u8], )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b [u8], )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u8], )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct IsWhitespace impl Fn = |c: char| -> bool {\n+        c.is_whitespace()\n+    };\n \n-#[derive(Clone)]\n-struct UnsafeBytesToStr;\n+    #[derive(Clone)]\n+    struct IsAsciiWhitespace impl Fn = |byte: &u8| -> bool {\n+        byte.is_ascii_whitespace()\n+    };\n \n-impl<'a> FnOnce<(&'a [u8], )> for UnsafeBytesToStr {\n-    type Output = &'a str;\n+    #[derive(Clone)]\n+    struct IsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b str| -> bool {\n+        !s.is_empty()\n+    };\n \n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a [u8], )) -> &'a str {\n-        self.call_mut(arg)\n-    }\n-}\n+    #[derive(Clone)]\n+    struct BytesIsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b [u8]| -> bool {\n+        !s.is_empty()\n+    };\n \n-impl<'a> FnMut<(&'a [u8], )> for UnsafeBytesToStr {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a [u8], )) -> &'a str {\n-        unsafe { from_utf8_unchecked(arg.0) }\n-    }\n+    #[derive(Clone)]\n+    struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        unsafe { from_utf8_unchecked(bytes) }\n+    };\n }\n \n-\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;"}]}