{"sha": "cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOWEyYzBiNTRlZTUwMTM1ZmJlYjRkODNjMDBmNzEzMTE0ZjdmNjc=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-13T23:39:56Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-18T19:44:51Z"}, "message": "Refactor `GenericArgs` to include const generics\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "4b84212b1155378d33a3a190c95faddd939dbc4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b84212b1155378d33a3a190c95faddd939dbc4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "html_url": "https://github.com/rust-lang/rust/commit/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ed491743df4dbab25fec6f725e6f3b3ace860b", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ed491743df4dbab25fec6f725e6f3b3ace860b", "html_url": "https://github.com/rust-lang/rust/commit/29ed491743df4dbab25fec6f725e6f3b3ace860b"}], "stats": {"total": 143, "additions": 70, "deletions": 73}, "files": [{"sha": "adbe73b165ef4b812901be583e908b104929ab90", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "patch": "@@ -444,7 +444,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                                                 .expect(\"segments were empty\");\n \n                             let (old_input, old_output) = match last_segment.args {\n-                                GenericArgs::AngleBracketed { types, .. } => (types, None),\n+                                GenericArgs::AngleBracketed { args, .. } => {\n+                                    let types = args.iter().filter_map(|arg| match arg {\n+                                        GenericArg::Type(ty) => Some(ty.clone()),\n+                                        _ => None,\n+                                    }).collect();\n+                                    (types, None)\n+                                }\n                                 GenericArgs::Parenthesized { inputs, output, .. } => {\n                                     (inputs, output)\n                                 }"}, {"sha": "50210bcb85d56575016bb828ce6c9b4ae50f1a12", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::map::DisambiguatedDefPathData;\n-use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n@@ -1089,42 +1089,48 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(cx: &DocContext<'_>, trait_did: Option<DefId>, has_self: bool,\n-                        bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> GenericArgs {\n-    let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n-    let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n+fn external_generic_args(\n+    cx: &DocContext<'_>,\n+    trait_did: Option<DefId>,\n+    has_self: bool,\n+    bindings: Vec<TypeBinding>,\n+    substs: SubstsRef<'_>,\n+) -> GenericArgs {\n+    let mut skip_self = has_self;\n+    let mut first_ty_sty = None;\n+    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n+        UnpackedKind::Lifetime(lt) => {\n+            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n+        }\n+        UnpackedKind::Type(_) if skip_self => {\n+            skip_self = false;\n+            None\n+        }\n+        UnpackedKind::Type(ty) => {\n+            first_ty_sty = Some(&ty.sty);\n+            Some(GenericArg::Type(ty.clean(cx)))\n+        }\n+        UnpackedKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+    }).collect();\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n         Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n-            assert_eq!(types.len(), 1);\n-            let inputs = match types[0].sty {\n-                ty::Tuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n-                _ => {\n-                    return GenericArgs::AngleBracketed {\n-                        lifetimes,\n-                        types: types.clean(cx),\n-                        bindings,\n-                    }\n-                }\n+            assert!(first_ty_sty.is_some());\n+            let inputs = match first_ty_sty {\n+                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                _ => return GenericArgs::AngleBracketed { args, bindings },\n             };\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n             // match types[1].sty {\n             //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n-            GenericArgs::Parenthesized {\n-                inputs,\n-                output,\n-            }\n+            GenericArgs::Parenthesized { inputs, output }\n         },\n         _ => {\n-            GenericArgs::AngleBracketed {\n-                lifetimes,\n-                types: types.clean(cx),\n-                bindings,\n-            }\n+            GenericArgs::AngleBracketed { args, bindings }\n         }\n     }\n }\n@@ -1462,7 +1468,7 @@ impl GenericParamDef {\n     }\n }\n \n-impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n+impl Clean<GenericParamDef> for ty::GenericParamDef {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n@@ -1484,7 +1490,10 @@ impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n                 })\n             }\n             ty::GenericParamDefKind::Const { .. } => {\n-                unimplemented!() // FIXME(const_generics)\n+                (self.name.clean(cx), GenericParamDefKind::Const {\n+                    did: self.def_id,\n+                    ty: cx.tcx.type_of(self.def_id).clean(cx),\n+                })\n             }\n         };\n \n@@ -1685,9 +1694,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                         .flat_map(|param| match param.kind {\n                             ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n                             ty::GenericParamDefKind::Type { .. } => None,\n-                            ty::GenericParamDefKind::Const { .. } => {\n-                                unimplemented!() // FIXME(const_generics)\n-                            }\n+                            ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n                         }).chain(simplify::ty_params(stripped_typarams).into_iter())\n                         .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n@@ -2365,12 +2372,15 @@ impl Type {\n         }\n     }\n \n-    pub fn generics(&self) -> Option<&[Type]> {\n+    pub fn generics(&self) -> Option<Vec<Type>> {\n         match *self {\n             ResolvedPath { ref path, .. } => {\n                 path.segments.last().and_then(|seg| {\n-                    if let GenericArgs::AngleBracketed { ref types, .. } = seg.args {\n-                        Some(&**types)\n+                    if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n+                        Some(args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty.clone()),\n+                            _ => None,\n+                        }).collect())\n                     } else {\n                         None\n                     }\n@@ -3267,8 +3277,7 @@ impl fmt::Display for GenericArg {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n-        lifetimes: Vec<Lifetime>,\n-        types: Vec<Type>,\n+        args: Vec<GenericArg>,\n         bindings: Vec<TypeBinding>,\n     },\n     Parenthesized {\n@@ -3286,27 +3295,19 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n             }\n         } else {\n-            let (mut lifetimes, mut types) = (vec![], vec![]);\n-            let mut elided_lifetimes = true;\n-            for arg in &self.args {\n-                match arg {\n-                    GenericArg::Lifetime(lt) => {\n-                        if !lt.is_elided() {\n-                            elided_lifetimes = false;\n-                        }\n-                        lifetimes.push(lt.clean(cx));\n-                    }\n-                    GenericArg::Type(ty) => {\n-                        types.push(ty.clean(cx));\n-                    }\n-                    GenericArg::Const(..) => {\n-                        unimplemented!() // FIXME(const_generics)\n-                    }\n-                }\n-            }\n+            let elide_lifetimes = self.args.iter().all(|arg| match arg {\n+                hir::GenericArg::Lifetime(lt) => lt.is_elided(),\n+                _ => true,\n+            });\n             GenericArgs::AngleBracketed {\n-                lifetimes: if elided_lifetimes { vec![] } else { lifetimes },\n-                types,\n+                args: self.args.iter().filter_map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) if !elide_lifetimes => {\n+                        Some(GenericArg::Lifetime(lt.clean(cx)))\n+                    }\n+                    hir::GenericArg::Lifetime(_) => None,\n+                    hir::GenericArg::Type(ty) => Some(GenericArg::Type(ty.clean(cx))),\n+                    hir::GenericArg::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+                }).collect(),\n                 bindings: self.bindings.clean(cx),\n             }\n         }\n@@ -3358,9 +3359,8 @@ fn strip_path(path: &Path) -> Path {\n         PathSegment {\n             name: s.name.clone(),\n             args: GenericArgs::AngleBracketed {\n-                lifetimes: Vec::new(),\n-                types: Vec::new(),\n-                bindings: Vec::new(),\n+                args: vec![],\n+                bindings: vec![],\n             }\n         }\n     }).collect();\n@@ -3511,7 +3511,7 @@ impl Clean<Item> for doctree::Static {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct Constant {\n     pub type_: Type,\n     pub expr: String,"}, {"sha": "116839edc2f80f032534068aa2c6c97db2ad4064", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9a2c0b54ee50135fbeb4d83c00f713114f7f67/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=cd9a2c0b54ee50135fbeb4d83c00f713114f7f67", "patch": "@@ -306,32 +306,23 @@ impl fmt::Display for clean::GenericBound {\n impl fmt::Display for clean::GenericArgs {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            clean::GenericArgs::AngleBracketed {\n-                ref lifetimes, ref types, ref bindings\n-            } => {\n-                if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n+            clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n+            if !args.is_empty() || !bindings.is_empty() {\n                     if f.alternate() {\n                         f.write_str(\"<\")?;\n                     } else {\n                         f.write_str(\"&lt;\")?;\n                     }\n                     let mut comma = false;\n-                    for lifetime in lifetimes {\n-                        if comma {\n-                            f.write_str(\", \")?;\n-                        }\n-                        comma = true;\n-                        write!(f, \"{}\", *lifetime)?;\n-                    }\n-                    for ty in types {\n+                    for arg in args {\n                         if comma {\n                             f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *ty)?;\n+                            write!(f, \"{:#}\", *arg)?;\n                         } else {\n-                            write!(f, \"{}\", *ty)?;\n+                            write!(f, \"{}\", *arg)?;\n                         }\n                     }\n                     for binding in bindings {"}]}