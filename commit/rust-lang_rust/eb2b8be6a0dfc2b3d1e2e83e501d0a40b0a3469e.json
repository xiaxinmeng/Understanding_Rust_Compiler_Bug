{"sha": "eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMmI4YmU2YTBkZmMyYjNkMWUyZTgzZTUwMWQwYTQwYjBhMzQ2OWU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-02-20T01:17:35Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-05T22:17:41Z"}, "message": "Implement collect for const parameters\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "09055217e2814281817cab148e442624826d1e39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09055217e2814281817cab148e442624826d1e39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e", "html_url": "https://github.com/rust-lang/rust/commit/eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3001ae7f94672064ca5db1a9f425644e98c3ecc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3001ae7f94672064ca5db1a9f425644e98c3ecc6", "html_url": "https://github.com/rust-lang/rust/commit/3001ae7f94672064ca5db1a9f425644e98c3ecc6"}], "stats": {"total": 235, "additions": 150, "deletions": 85}, "files": [{"sha": "20b1ab4478a7c47ec3abcc7ea10f4387c7596715", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 150, "deletions": 85, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=eb2b8be6a0dfc2b3d1e2e83e501d0a40b0a3469e", "patch": "@@ -1004,67 +1004,65 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n         ast_generics\n             .params\n             .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Type {\n-                    ref default,\n-                    synthetic,\n-                    ..\n-                } => {\n-                    if param.name.ident().name == keywords::SelfUpper.name() {\n-                        span_bug!(\n-                            param.span,\n-                            \"`Self` should not be the name of a regular parameter\"\n-                        );\n-                    }\n-\n-                    if !allow_defaults && default.is_some() {\n-                        if !tcx.features().default_type_parameter_fallback {\n-                            tcx.lint_hir(\n-                                lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                                param.hir_id,\n+            .filter_map(|param| {\n+                let kind = match param.kind {\n+                    GenericParamKind::Type {\n+                        ref default,\n+                        synthetic,\n+                        ..\n+                    } => {\n+                        if param.name.ident().name == keywords::SelfUpper.name() {\n+                            span_bug!(\n                                 param.span,\n-                                &format!(\n-                                    \"defaults for type parameters are only allowed in \\\n-                                     `struct`, `enum`, `type`, or `trait` definitions.\"\n-                                ),\n+                                \"`Self` should not be the name of a regular parameter\"\n                             );\n                         }\n-                    }\n \n-                    let ty_param = ty::GenericParamDef {\n-                        index: type_start + i as u32,\n-                        name: param.name.ident().as_interned_str(),\n-                        def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n-                        pure_wrt_drop: param.pure_wrt_drop,\n-                        kind: ty::GenericParamDefKind::Type {\n+                        if !allow_defaults && default.is_some() {\n+                            if !tcx.features().default_type_parameter_fallback {\n+                                tcx.lint_node(\n+                                    lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                                    param.hir_id,\n+                                    param.span,\n+                                    &format!(\n+                                        \"defaults for type parameters are only allowed in \\\n+                                        `struct`, `enum`, `type`, or `trait` definitions.\"\n+                                    ),\n+                                );\n+                            }\n+                        }\n+\n+                        ty::GenericParamDefKind::Type {\n                             has_default: default.is_some(),\n                             object_lifetime_default: object_lifetime_defaults\n                                 .as_ref()\n                                 .map_or(rl::Set1::Empty, |o| o[i]),\n                             synthetic,\n-                        },\n-                    };\n-                    i += 1;\n-                    Some(ty_param)\n-                }\n-                GenericParamKind::Const { .. } => {\n-                    if param.name.ident().name == keywords::SelfUpper.name() {\n-                        span_bug!(\n-                            param.span,\n-                            \"`Self` should not be the name of a regular parameter\",\n-                        );\n+                        }\n                     }\n+                    GenericParamKind::Const { .. } => {\n+                        if param.name.ident().name == keywords::SelfUpper.name() {\n+                            span_bug!(\n+                                param.span,\n+                                \"`Self` should not be the name of a regular parameter\",\n+                            );\n+                        }\n \n-                    // Emit an error, but skip the parameter rather than aborting to\n-                    // continue to get other errors.\n-                    tcx.sess.struct_span_err(\n-                        param.span,\n-                        \"const generics in any position are currently unsupported\",\n-                    ).emit();\n-                    None\n-                }\n-                _ => None,\n-            }),\n+                        ty::GenericParamDefKind::Const\n+                    }\n+                    _ => return None,\n+                };\n+\n+                let param_def = ty::GenericParamDef {\n+                    index: type_start + i as u32,\n+                    name: param.name.ident().as_interned_str(),\n+                    def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+                    pure_wrt_drop: param.pure_wrt_drop,\n+                    kind,\n+                };\n+                i += 1;\n+                Some(param_def)\n+            })\n     );\n \n     // provide junk type parameter defs - the only place that\n@@ -1284,44 +1282,111 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        Node::AnonConst(_) => match tcx.hir().get_by_hir_id(\n-            tcx.hir().get_parent_node_by_hir_id(hir_id))\n-        {\n-            Node::Ty(&hir::Ty {\n-                node: hir::TyKind::Array(_, ref constant),\n-                ..\n-            })\n-            | Node::Ty(&hir::Ty {\n-                node: hir::TyKind::Typeof(ref constant),\n-                ..\n-            })\n-            | Node::Expr(&hir::Expr {\n-                node: ExprKind::Repeat(_, ref constant),\n-                ..\n-            }) if constant.hir_id == hir_id =>\n-            {\n-                tcx.types.usize\n-            }\n+        Node::AnonConst(_) => {\n+            let parent_node = tcx.hir().get_by_hir_id(tcx.hir().get_parent_node_by_hir_id(hir_id));\n+            match parent_node {\n+                Node::Ty(&hir::Ty {\n+                    node: hir::TyKind::Array(_, ref constant),\n+                    ..\n+                })\n+                | Node::Ty(&hir::Ty {\n+                    node: hir::TyKind::Typeof(ref constant),\n+                    ..\n+                })\n+                | Node::Expr(&hir::Expr {\n+                    node: ExprKind::Repeat(_, ref constant),\n+                    ..\n+                }) if constant.hir_id == hir_id =>\n+                {\n+                    tcx.types.usize\n+                }\n \n-            Node::Variant(&Spanned {\n-                node:\n-                    VariantKind {\n-                        disr_expr: Some(ref e),\n-                        ..\n-                    },\n-                ..\n-            }) if e.hir_id == hir_id =>\n-            {\n-                tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n-                    .repr\n-                    .discr_type()\n-                    .to_ty(tcx)\n-            }\n+                Node::Variant(&Spanned {\n+                    node:\n+                        VariantKind {\n+                            disr_expr: Some(ref e),\n+                            ..\n+                        },\n+                    ..\n+                }) if e.hir_id == hir_id =>\n+                {\n+                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                        .repr\n+                        .discr_type()\n+                        .to_ty(tcx)\n+                }\n \n-            x => {\n-                bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n+                Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n+                Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n+                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) => {\n+                    let path = match parent_node {\n+                        Node::Ty(&hir::Ty { node: hir::TyKind::Path(ref path), .. }) |\n+                        Node::Expr(&hir::Expr { node: ExprKind::Path(ref path), .. }) => {\n+                            path\n+                        }\n+                        Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n+                            &*path\n+                        }\n+                        _ => unreachable!(),\n+                    };\n+\n+                    match path {\n+                        QPath::Resolved(_, ref path) => {\n+                            let mut arg_index = 0;\n+                            let mut found_const = false;\n+                            for seg in &path.segments {\n+                                if let Some(generic_args) = &seg.args {\n+                                    let args = &generic_args.args;\n+                                    for arg in args {\n+                                        if let GenericArg::Const(ct) = arg {\n+                                            if ct.value.id == node_id {\n+                                                found_const = true;\n+                                                break;\n+                                            }\n+                                            arg_index += 1;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            // Sanity check to make sure everything is as expected.\n+                            if !found_const {\n+                                bug!(\"no arg matching AnonConst in path\")\n+                            }\n+                            match path.def {\n+                                // We've encountered an `AnonConst` in some path, so we need to\n+                                // figure out which generic parameter it corresponds to and return\n+                                // the relevant type.\n+                                Def::Struct(def_id)\n+                                | Def::Union(def_id)\n+                                | Def::Enum(def_id)\n+                                | Def::Fn(def_id) => {\n+                                    let generics = tcx.generics_of(def_id);\n+                                    let mut param_index = 0;\n+                                    for param in &generics.params {\n+                                        if let ty::GenericParamDefKind::Const = param.kind {\n+                                            if param_index == arg_index {\n+                                                return tcx.type_of(param.def_id);\n+                                            }\n+                                            param_index += 1;\n+                                        }\n+                                    }\n+                                    // This is no generic parameter associated with the arg. This is\n+                                    // probably from an extra arg where one is not needed.\n+                                    return tcx.types.err;\n+                                }\n+                                Def::Err => tcx.types.err,\n+                                x => bug!(\"unexpected const parent path def {:?}\", x),\n+                            }\n+                        }\n+                        x => bug!(\"unexpected const parent path {:?}\", x),\n+                    }\n+                }\n+\n+                x => {\n+                    bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n+                }\n             }\n-        },\n+        }\n \n         Node::GenericParam(param) => match &param.kind {\n             hir::GenericParamKind::Type { default: Some(ref ty), .. } |"}]}