{"sha": "4f6516969eb3f488f360a67af4d72f17ab312975", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNjUxNjk2OWViM2Y0ODhmMzYwYTY3YWY0ZDcyZjE3YWIzMTI5NzU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-02T02:50:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-02T05:22:49Z"}, "message": "rt: Remove ports", "tree": {"sha": "fb97b73456953c2a3a1e5547971c1c9d3ebfadec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb97b73456953c2a3a1e5547971c1c9d3ebfadec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f6516969eb3f488f360a67af4d72f17ab312975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6516969eb3f488f360a67af4d72f17ab312975", "html_url": "https://github.com/rust-lang/rust/commit/4f6516969eb3f488f360a67af4d72f17ab312975", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f6516969eb3f488f360a67af4d72f17ab312975/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "542bf20414551638886ef6e79e2b7c1a69df97c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/542bf20414551638886ef6e79e2b7c1a69df97c2", "html_url": "https://github.com/rust-lang/rust/commit/542bf20414551638886ef6e79e2b7c1a69df97c2"}], "stats": {"total": 541, "additions": 2, "deletions": 539}, "files": [{"sha": "a07abece731ed799f1c9f068e69f5d0726d1e873", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -57,13 +57,11 @@ RUNTIME_CXXS_$(1) := \\\n               rt/rust_sched_reaper.cpp \\\n               rt/rust_task.cpp \\\n               rt/rust_stack.cpp \\\n-              rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n               rt/rust_crate_map.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_gc_metadata.cpp \\\n-              rt/rust_port_selector.cpp \\\n               rt/rust_util.cpp \\\n               rt/circular_buffer.cpp \\\n               rt/isaac/randport.cpp \\"}, {"sha": "1967f1771bea97935e1cf88dabf86729c1856917", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -88,7 +88,6 @@ struct Task {\n     kernel: *Kernel,                    // 112\n     name: *c_char,                      // 116\n     list_index: i32,                    // 120\n-    rendezvous_ptr: *uintptr_t,         // 124\n     boxed_region: BoxedRegion           // 128\n }\n \n@@ -107,7 +106,6 @@ struct Task {\n     kernel: *Kernel,\n     name: *c_char,\n     list_index: i32,\n-    rendezvous_ptr: *uintptr_t,\n     boxed_region: BoxedRegion\n }\n "}, {"sha": "32f2c4ebde2acddf1dc5769e7b86ce9d06447bd4", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -17,7 +17,6 @@\n #include \"sync/timer.h\"\n #include \"sync/rust_thread.h\"\n #include \"rust_abi.h\"\n-#include \"rust_port.h\"\n \n #include <time.h>\n \n@@ -694,88 +693,13 @@ rust_sched_threads() {\n     return task->sched->max_number_of_threads();\n }\n \n-extern \"C\" CDECL rust_port*\n-rust_port_take(rust_port_id id) {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->get_port_by_id(id);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_drop(rust_port *p) {\n-    assert(p != NULL);\n-    p->deref();\n-}\n-\n-extern \"C\" CDECL rust_task_id\n-rust_port_task(rust_port *p) {\n-    assert(p != NULL);\n-    return p->task->id;\n-}\n-\n-extern \"C\" CDECL rust_port*\n-new_port(size_t unit_sz) {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, comm, \"new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n-        (uintptr_t) task, task->name, unit_sz);\n-    // port starts with refcount == 1\n-    return new (task->kernel, \"rust_port\") rust_port(task, unit_sz);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_begin_detach(rust_port *port, uintptr_t *yield) {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, comm, \"rust_port_detach(0x%\" PRIxPTR \")\", (uintptr_t) port);\n-    port->begin_detach(yield);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_end_detach(rust_port *port) {\n-    port->end_detach();\n-}\n-\n-extern \"C\" CDECL void\n-del_port(rust_port *port) {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, comm, \"del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n-    delete port;\n-}\n-\n-extern \"C\" CDECL size_t\n-rust_port_size(rust_port *port) {\n-    return port->size();\n-}\n-\n-extern \"C\" CDECL rust_port_id\n-get_port_id(rust_port *port) {\n-    return port->id;\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-rust_port_id_send(rust_port_id target_port_id, void *sptr) {\n-    rust_task *task = rust_get_current_task();\n-    return (uintptr_t)task->kernel->send_to_port(target_port_id, sptr);\n-}\n-\n // This is called by an intrinsic on the Rust stack and must run\n // entirely in the red zone. Do not call on the C stack.\n extern \"C\" CDECL MUST_CHECK bool\n rust_task_yield(rust_task *task, bool *killed) {\n     return task->yield();\n }\n \n-extern \"C\" CDECL void\n-port_recv(uintptr_t *dptr, rust_port *port, uintptr_t *yield) {\n-    port->receive(dptr, yield);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_select(rust_port **dptr, rust_port **ports,\n-                 size_t n_ports, uintptr_t *yield) {\n-    rust_task *task = rust_get_current_task();\n-    rust_port_selector *selector = task->get_port_selector();\n-    selector->select(task, dptr, ports, n_ports, yield);\n-}\n-\n extern \"C\" CDECL void\n rust_set_exit_status(intptr_t code) {\n     rust_task *task = rust_get_current_task();"}, {"sha": "99a6ed94944703a79c0de5cf095b273d9afbf199", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -11,7 +11,6 @@\n \n \n #include \"rust_kernel.h\"\n-#include \"rust_port.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n #include \"rust_sched_launcher.h\"\n@@ -26,7 +25,6 @@ rust_kernel::rust_kernel(rust_env *env) :\n     _region(env, true),\n     _log(NULL),\n     max_task_id(INIT_TASK_ID-1), // sync_add_and_fetch increments first\n-    max_port_id(1),\n     rval(0),\n     max_sched_id(1),\n     killed(false),\n@@ -264,47 +262,6 @@ rust_kernel::generate_task_id() {\n     return id;\n }\n \n-rust_port_id\n-rust_kernel::register_port(rust_port *port) {\n-    uintptr_t new_live_ports;\n-    rust_port_id new_port_id;\n-    {\n-        scoped_lock with(port_lock);\n-        new_port_id = max_port_id++;\n-        port_table.put(new_port_id, port);\n-        new_live_ports = port_table.count();\n-    }\n-    assert(new_port_id != INTPTR_MAX && \"Hit the maximum port id\");\n-    KLOG_(\"Registered port %\" PRIdPTR, new_port_id);\n-    KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n-    return new_port_id;\n-}\n-\n-void\n-rust_kernel::release_port_id(rust_port_id id) {\n-    KLOG_(\"Releasing port %\" PRIdPTR, id);\n-    uintptr_t new_live_ports;\n-    {\n-        scoped_lock with(port_lock);\n-        port_table.remove(id);\n-        new_live_ports = port_table.count();\n-    }\n-    KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n-}\n-\n-rust_port *\n-rust_kernel::get_port_by_id(rust_port_id id) {\n-    assert(id != 0 && \"invalid port id\");\n-    scoped_lock with(port_lock);\n-    rust_port *port = NULL;\n-    // get leaves port unchanged if not found.\n-    port_table.get(id, &port);\n-    if(port) {\n-        port->ref();\n-    }\n-    return port;\n-}\n-\n #ifdef __WIN32__\n void\n rust_kernel::win32_require(LPCTSTR fn, BOOL ok) {\n@@ -400,21 +357,6 @@ rust_kernel::begin_shutdown() {\n     allow_scheduler_exit();\n }\n \n-bool\n-rust_kernel::send_to_port(rust_port_id chan, void *sptr) {\n-    KLOG_(\"rust_port_id*_send port: 0x%\" PRIxPTR, (uintptr_t) chan);\n-\n-    rust_port *port = get_port_by_id(chan);\n-    if(port) {\n-        port->send(sptr);\n-        port->deref();\n-        return true;\n-    } else {\n-        KLOG_(\"didn't get the port\");\n-        return false;\n-    }\n-}\n-\n void\n rust_kernel::register_exit_function(spawn_fn runner, fn_env_pair *f) {\n     scoped_lock with(at_exit_lock);"}, {"sha": "c3d5a5a19bb4fe22d3f4d4fab97f1fedb9495447", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -15,8 +15,7 @@\n    The kernel is primarily responsible for managing the lifetime of\n    schedulers, which in turn run rust tasks. It provides a memory\n    allocator and logging service for use by other runtime components,\n-   it creates unique task and port ids and provides global access\n-   to ports by id.\n+   it creates unique task ids.\n \n    The kernel runs until there are no live schedulers.\n \n@@ -56,13 +55,11 @@ class rust_scheduler;\n class rust_sched_driver;\n class rust_sched_launcher_factory;\n struct rust_task_thread;\n-class rust_port;\n \n-// Scheduler, task, and port handles. These uniquely identify within a\n+// Scheduler, task handles. These uniquely identify within a\n // single kernel instance the objects they represent.\n typedef intptr_t rust_sched_id;\n typedef intptr_t rust_task_id;\n-typedef intptr_t rust_port_id;\n \n typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n \n@@ -80,12 +77,6 @@ class rust_kernel {\n     // The next task id\n     rust_task_id max_task_id;\n \n-    // Protects max_port_id and port_table\n-    lock_and_signal port_lock;\n-    // The next port id\n-    rust_task_id max_port_id;\n-    hash_map<rust_port_id, rust_port *> port_table;\n-\n     lock_and_signal rval_lock;\n     int rval;\n \n@@ -163,10 +154,6 @@ class rust_kernel {\n \n     rust_task_id generate_task_id();\n \n-    rust_port_id register_port(rust_port *port);\n-    rust_port *get_port_by_id(rust_port_id id);\n-    void release_port_id(rust_port_id tid);\n-\n     void set_exit_status(int code);\n \n     rust_sched_id main_sched_id() { return main_scheduler; }\n@@ -177,8 +164,6 @@ class rust_kernel {\n     void inc_weak_task_count();\n     void dec_weak_task_count();\n \n-    bool send_to_port(rust_port_id chan, void *sptr);\n-\n     void register_exit_function(spawn_fn runner, fn_env_pair *f);\n };\n "}, {"sha": "befa209d62fd475ebf40f478efd1f467748be692", "filename": "src/rt/rust_port.cpp", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -1,153 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_port.h\"\n-#include \"rust_task.h\"\n-\n-rust_port::rust_port(rust_task *task, size_t unit_sz)\n-    : ref_count(1), kernel(task->kernel), task(task),\n-      unit_sz(unit_sz), buffer(kernel, unit_sz) {\n-\n-    LOG(task, comm,\n-        \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n-        PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n-\n-    id = kernel->register_port(this);\n-}\n-\n-rust_port::~rust_port() {\n-    LOG(task, comm, \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n-}\n-\n-void rust_port::ref() {\n-    scoped_lock with(ref_lock);\n-    ref_count++;\n-}\n-\n-void rust_port::deref() {\n-    scoped_lock with(ref_lock);\n-    ref_count--;\n-    if (!ref_count) {\n-        // The port owner is waiting for the port to be detached (if it\n-        // hasn't already been killed)\n-        scoped_lock with(task->lifecycle_lock);\n-        if (task->blocked_on(&detach_cond)) {\n-            task->wakeup_inner(&detach_cond);\n-        }\n-    }\n-}\n-\n-void rust_port::begin_detach(uintptr_t *yield) {\n-    *yield = false;\n-\n-    kernel->release_port_id(id);\n-\n-    scoped_lock with(ref_lock);\n-    ref_count--;\n-\n-    if (ref_count != 0) {\n-        task->block(&detach_cond, \"waiting for port detach\");\n-        *yield = true;\n-    }\n-}\n-\n-void rust_port::end_detach() {\n-    // Just take the lock to make sure that the thread that signaled\n-    // the detach_cond isn't still holding it\n-    scoped_lock with(ref_lock);\n-    assert(ref_count == 0);\n-}\n-\n-void rust_port::send(void *sptr) {\n-    bool did_rendezvous = false;\n-    {\n-        scoped_lock with(lock);\n-\n-        buffer.enqueue(sptr);\n-\n-        assert(!buffer.is_empty() &&\n-               \"rust_chan::transmit with nothing to send.\");\n-\n-        {\n-            scoped_lock with(task->lifecycle_lock);\n-            if (task->blocked_on(this)) {\n-                KLOG(kernel, comm, \"dequeued in rendezvous_ptr\");\n-                buffer.dequeue(task->rendezvous_ptr);\n-                task->rendezvous_ptr = 0;\n-                task->wakeup_inner(this);\n-                did_rendezvous = true;\n-            }\n-        }\n-    }\n-\n-    if (!did_rendezvous) {\n-        // If the task wasn't waiting specifically on this port,\n-        // it may be waiting on a group of ports\n-\n-        rust_port_selector *port_selector = task->get_port_selector();\n-        // The port selector will check if the task is blocked, not us.\n-        port_selector->msg_sent_on(this);\n-    }\n-}\n-\n-void rust_port::receive(void *dptr, uintptr_t *yield) {\n-    LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n-        \", size: 0x%\" PRIxPTR,\n-        (uintptr_t) this, (uintptr_t) dptr, unit_sz);\n-\n-    scoped_lock with(lock);\n-\n-    *yield = false;\n-\n-    if (buffer.is_empty() == false) {\n-        buffer.dequeue(dptr);\n-        LOG(task, comm, \"<=== read data ===\");\n-        return;\n-    }\n-    memset(dptr, 0, buffer.unit_sz);\n-\n-    // No data was buffered on any incoming channel, so block this task on\n-    // the port. Remember the rendezvous location so that any sender task\n-    // can write to it before waking up this task.\n-\n-    LOG(task, comm, \"<=== waiting for rendezvous data ===\");\n-    task->rendezvous_ptr = (uintptr_t*) dptr;\n-    task->block(this, \"waiting for rendezvous data\");\n-\n-    // Blocking the task might fail if the task has already been killed, but\n-    // in the event of both failure and success the task needs to yield. On\n-    // success, it yields and waits to be unblocked. On failure it yields and\n-    // is then fails the task.\n-\n-    *yield = true;\n-}\n-\n-size_t rust_port::size() {\n-    scoped_lock with(lock);\n-    return buffer.size();\n-}\n-\n-void rust_port::log_state() {\n-    LOG(task, comm,\n-        \"port size: %d\",\n-        buffer.size());\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "3bbc3cfaa32c98535337c9897510bbf52fc15a18", "filename": "src/rt/rust_port.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port.h", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.h?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_PORT_H\n-#define RUST_PORT_H\n-\n-#include \"rust_globals.h\"\n-#include \"circular_buffer.h\"\n-\n-class port_detach_cond : public rust_cond { };\n-\n-class rust_port : public kernel_owned<rust_port>, public rust_cond {\n-private:\n-    // Protects ref_count and detach_cond\n-    lock_and_signal ref_lock;\n-    intptr_t ref_count;\n-    port_detach_cond detach_cond;\n-\n-public:\n-    void ref();\n-    void deref();\n-\n-public:\n-    rust_port_id id;\n-\n-    rust_kernel *kernel;\n-    rust_task *task;\n-    size_t unit_sz;\n-    circular_buffer buffer;\n-\n-    lock_and_signal lock;\n-\n-public:\n-    rust_port(rust_task *task, size_t unit_sz);\n-    ~rust_port();\n-\n-    void log_state();\n-    void send(void *sptr);\n-    void receive(void *dptr, uintptr_t *yield);\n-    size_t size();\n-\n-    void begin_detach(uintptr_t *yield);\n-    void end_detach();\n-};\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//\n-\n-#endif /* RUST_PORT_H */"}, {"sha": "19745ffc7a186e32bd765bdefd7af1807133ce7c", "filename": "src/rt/rust_port_selector.cpp", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -1,103 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_port.h\"\n-#include \"rust_port_selector.h\"\n-#include \"rust_task.h\"\n-\n-rust_port_selector::rust_port_selector()\n-    : ports(NULL), n_ports(0) {\n-}\n-\n-void\n-rust_port_selector::select(rust_task *task, rust_port **dptr,\n-                           rust_port **ports,\n-                           size_t n_ports, uintptr_t *yield) {\n-\n-    assert(this->ports == NULL);\n-    assert(this->n_ports == 0);\n-    assert(dptr != NULL);\n-    assert(ports != NULL);\n-    assert(n_ports != 0);\n-    assert(yield != NULL);\n-\n-    *yield = false;\n-    size_t locks_taken = 0;\n-    bool found_msg = false;\n-\n-    // Take each port's lock as we iterate through them because\n-    // if none of them contain a usable message then we need to\n-    // block the task before any of them can try to send another\n-    // message.\n-\n-    // Start looking for ports from a different index each time.\n-    size_t j = isaac_rand(&task->sched_loop->rctx);\n-    for (size_t i = 0; i < n_ports; i++) {\n-        size_t k = (i + j) % n_ports;\n-        rust_port *port = ports[k];\n-        assert(port != NULL);\n-\n-        port->lock.lock();\n-        locks_taken++;\n-\n-        if (port->buffer.size() > 0) {\n-            *dptr = port;\n-            found_msg = true;\n-            break;\n-        }\n-    }\n-\n-    if (!found_msg) {\n-        this->ports = ports;\n-        this->n_ports = n_ports;\n-        assert(task->rendezvous_ptr == NULL);\n-        task->rendezvous_ptr = (uintptr_t*)dptr;\n-        task->block(this, \"waiting for select rendezvous\");\n-\n-        // Blocking the task might fail if the task has already been\n-        // killed, but in the event of both failure and success the\n-        // task needs to yield. On success, it yields and waits to be\n-        // unblocked. On failure it yields and is then fails the task.\n-\n-        *yield = true;\n-    }\n-\n-    for (size_t i = 0; i < locks_taken; i++) {\n-        size_t k = (i + j) % n_ports;\n-        rust_port *port = ports[k];\n-        port->lock.unlock();\n-    }\n-}\n-\n-void\n-rust_port_selector::msg_sent_on(rust_port *port) {\n-    rust_task *task = port->task;\n-\n-    port->lock.must_not_have_lock();\n-\n-    // Prevent two ports from trying to wake up the task\n-    // simultaneously\n-    scoped_lock with(task->lifecycle_lock);\n-\n-    if (task->blocked_on(this)) {\n-        for (size_t i = 0; i < n_ports; i++) {\n-            if (port == ports[i]) {\n-                // This was one of the ports we were waiting on\n-                ports = NULL;\n-                n_ports = 0;\n-                *task->rendezvous_ptr = (uintptr_t) port;\n-                task->rendezvous_ptr = NULL;\n-                task->wakeup_inner(this);\n-                return;\n-            }\n-        }\n-    }\n-}"}, {"sha": "919d61f7cee6067aa033cb059b4d3a85e364cee7", "filename": "src/rt/rust_port_selector.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port_selector.h", "raw_url": "https://github.com/rust-lang/rust/raw/542bf20414551638886ef6e79e2b7c1a69df97c2/src%2Frt%2Frust_port_selector.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.h?ref=542bf20414551638886ef6e79e2b7c1a69df97c2", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_PORT_SELECTOR_H\n-#define RUST_PORT_SELECTOR_H\n-\n-#include \"rust_globals.h\"\n-\n-class rust_port;\n-\n-class rust_port_selector : public rust_cond {\n- private:\n-    rust_port **ports;\n-    size_t n_ports;\n-\n- public:\n-    rust_port_selector();\n-\n-    void select(rust_task *task,\n-                rust_port **dptr,\n-                rust_port **ports,\n-                size_t n_ports,\n-                uintptr_t *yield);\n-\n-    void msg_sent_on(rust_port *port);\n-};\n-\n-#endif /* RUST_PORT_SELECTOR_H */"}, {"sha": "e370181a2d47155a5f2365916a5ae862bc3c35e9", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -21,7 +21,6 @@\n \n #include \"rust_task.h\"\n #include \"rust_env.h\"\n-#include \"rust_port.h\"\n #include \"rust_globals.h\"\n #include \"rust_crate_map.h\"\n \n@@ -37,7 +36,6 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     kernel(sched_loop->kernel),\n     name(name),\n     list_index(-1),\n-    rendezvous_ptr(0),\n     boxed(sched_loop->kernel->env, &local_region),\n     local_region(&sched_loop->local_region),\n     unwinding(false),"}, {"sha": "928c8ffdf21bf5c6ab290b00d835b5da836dd45a", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -116,7 +116,6 @@\n #include \"rust_kernel.h\"\n #include \"boxed_region.h\"\n #include \"rust_stack.h\"\n-#include \"rust_port_selector.h\"\n #include \"rust_type.h\"\n #include \"rust_sched_loop.h\"\n \n@@ -219,14 +218,6 @@ rust_task : public kernel_owned<rust_task>\n     const char *const name;\n     int32_t list_index;\n \n-    // Rendezvous pointer for receiving data when blocked on a port. If we're\n-    // trying to read data and no data is available on any incoming channel,\n-    // we block on the port, and yield control to the scheduler. Since, we\n-    // were not able to read anything, we remember the location where the\n-    // result should go in the rendezvous_ptr, and let the sender write to\n-    // that location before waking us up.\n-    uintptr_t* rendezvous_ptr;\n-\n     boxed_region boxed;\n     memory_region local_region;\n \n@@ -270,8 +261,6 @@ rust_task : public kernel_owned<rust_task>\n     uintptr_t next_c_sp;\n     uintptr_t next_rust_sp;\n \n-    rust_port_selector port_selector;\n-\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n \n@@ -302,8 +291,6 @@ rust_task : public kernel_owned<rust_task>\n                                char const *file,\n                                size_t line);\n \n-    friend class rust_port;\n-    friend class rust_port_selector;\n     bool block_inner(rust_cond *on, const char* name);\n     void wakeup_inner(rust_cond *from);\n     bool blocked_on(rust_cond *cond);\n@@ -381,8 +368,6 @@ rust_task : public kernel_owned<rust_task>\n     void call_on_rust_stack(void *args, void *fn_ptr);\n     bool have_c_stack() { return c_stack != NULL; }\n \n-    rust_port_selector *get_port_selector() { return &port_selector; }\n-\n     rust_task_state get_state() { return state; }\n     rust_cond *get_cond() { return cond; }\n     const char *get_cond_name() { return cond_name; }"}, {"sha": "17f245192858c89ff3ca62ccbca52085a879a658", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4f6516969eb3f488f360a67af4d72f17ab312975/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=4f6516969eb3f488f360a67af4d72f17ab312975", "patch": "@@ -1,14 +1,12 @@\n debug_box\n debug_fn\n debug_opaque\n-del_port\n debug_ptrcast\n debug_tag\n debug_tydesc\n debug_get_stk_seg\n debug_abi_1\n debug_abi_2\n-get_port_id\n get_task_id\n get_time\n rust_tzset\n@@ -17,12 +15,8 @@ rust_localtime\n rust_timegm\n rust_mktime\n last_os_error\n-new_port\n new_task\n-port_recv\n precise_time_ns\n-rust_port_id_send\n-rust_port_select\n rand_free\n rand_new\n rand_new_seeded\n@@ -45,9 +39,6 @@ rust_list_files\n rust_list_files2\n rust_log_console_on\n rust_log_console_off\n-rust_port_begin_detach\n-rust_port_end_detach\n-rust_port_size\n rust_process_wait\n rust_ptr_eq\n rust_run_program\n@@ -171,9 +162,6 @@ rust_dbg_do_nothing\n rust_dbg_breakpoint\n rust_osmain_sched_id\n rust_compare_and_swap_ptr\n-rust_port_take\n-rust_port_drop\n-rust_port_task\n rust_task_inhibit_kill\n rust_task_allow_kill\n rust_task_inhibit_yield"}]}