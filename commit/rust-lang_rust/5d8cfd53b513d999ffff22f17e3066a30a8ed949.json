{"sha": "5d8cfd53b513d999ffff22f17e3066a30a8ed949", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOGNmZDUzYjUxM2Q5OTlmZmZmMjJmMTdlMzA2NmEzMGE4ZWQ5NDk=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-08-25T01:04:29Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-30T16:54:02Z"}, "message": "Teach libsyntax about `if let`", "tree": {"sha": "b4eb0d6572d11b9e33959534f3389366011b8327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4eb0d6572d11b9e33959534f3389366011b8327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d8cfd53b513d999ffff22f17e3066a30a8ed949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8cfd53b513d999ffff22f17e3066a30a8ed949", "html_url": "https://github.com/rust-lang/rust/commit/5d8cfd53b513d999ffff22f17e3066a30a8ed949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d8cfd53b513d999ffff22f17e3066a30a8ed949/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38015eeb7010e5954a1bc60fddc1214a5f359627", "url": "https://api.github.com/repos/rust-lang/rust/commits/38015eeb7010e5954a1bc60fddc1214a5f359627", "html_url": "https://github.com/rust-lang/rust/commit/38015eeb7010e5954a1bc60fddc1214a5f359627"}], "stats": {"total": 84, "additions": 71, "deletions": 13}, "files": [{"sha": "02922fe3655ba34794b1d9655a0e106fdc0a39ba", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d8cfd53b513d999ffff22f17e3066a30a8ed949", "patch": "@@ -521,6 +521,7 @@ pub enum Expr_ {\n     ExprLit(P<Lit>),\n     ExprCast(P<Expr>, P<Ty>),\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic."}, {"sha": "8bdc64a926df8d99dad043e827b686b6610fc789", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5d8cfd53b513d999ffff22f17e3066a30a8ed949", "patch": "@@ -1205,6 +1205,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n+            ExprIfLet(pat, expr, tr, fl) => {\n+                ExprIfLet(folder.fold_pat(pat),\n+                          folder.fold_expr(expr),\n+                          folder.fold_block(tr),\n+                          fl.map(|x| folder.fold_expr(x)))\n+            }\n             ExprWhile(cond, body, opt_ident) => {\n                 ExprWhile(folder.fold_expr(cond),\n                           folder.fold_block(body),"}, {"sha": "cb57318445e4164c600d512ec01c5af24a8a9436", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=5d8cfd53b513d999ffff22f17e3066a30a8ed949", "patch": "@@ -24,6 +24,7 @@ use ast;\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n         ast::ExprIf(..)\n+        | ast::ExprIfLet(..)\n         | ast::ExprMatch(..)\n         | ast::ExprBlock(_)\n         | ast::ExprWhile(..)"}, {"sha": "d4ba81c737bce301e5e85500546a47e60dfa1f99", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d8cfd53b513d999ffff22f17e3066a30a8ed949", "patch": "@@ -23,7 +23,7 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIndex, ExprSlice};\n+use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n@@ -576,13 +576,10 @@ impl<'a> Parser<'a> {\n     /// If the next token is the given keyword, eat it and return\n     /// true. Otherwise, return false.\n     pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n-        match self.token {\n-            token::IDENT(sid, false) if kw.to_name() == sid.name => {\n-                self.bump();\n-                true\n-            }\n-            _ => false\n-        }\n+        if self.is_keyword(kw) {\n+            self.bump();\n+            true\n+        } else { false }\n     }\n \n     /// If the given word is not a keyword, signal an error.\n@@ -2860,8 +2857,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse an 'if' expression ('if' token already eaten)\n+    /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n     pub fn parse_if_expr(&mut self) -> P<Expr> {\n+        if self.is_keyword(keywords::Let) {\n+            return self.parse_if_let_expr();\n+        }\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n         let thn = self.parse_block();\n@@ -2875,6 +2875,23 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprIf(cond, thn, els))\n     }\n \n+    /// Parse an 'if let' expression ('if' token already eaten)\n+    pub fn parse_if_let_expr(&mut self) -> P<Expr> {\n+        let lo = self.last_span.lo;\n+        self.expect_keyword(keywords::Let);\n+        let pat = self.parse_pat();\n+        self.expect(&token::EQ);\n+        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let thn = self.parse_block();\n+        let (hi, els) = if self.eat_keyword(keywords::Else) {\n+            let expr = self.parse_else_expr();\n+            (expr.span.hi, Some(expr))\n+        } else {\n+            (thn.span.hi, None)\n+        };\n+        self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els))\n+    }\n+\n     // `|args| expr`\n     pub fn parse_lambda_expr(&mut self, capture_clause: CaptureClause)\n                              -> P<Expr> {"}, {"sha": "1e5810fb311d9eb76aec78ef4ab66c6883581537", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5d8cfd53b513d999ffff22f17e3066a30a8ed949", "patch": "@@ -1307,6 +1307,19 @@ impl<'a> State<'a> {\n                         try!(self.print_block(&**then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n+                    // \"another else-if-let\"\n+                    ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n+                        try!(self.cbox(indent_unit - 1u));\n+                        try!(self.ibox(0u));\n+                        try!(word(&mut self.s, \" else if let \"));\n+                        try!(self.print_pat(&**pat));\n+                        try!(space(&mut self.s));\n+                        try!(self.word_space(\"=\"));\n+                        try!(self.print_expr(&**expr));\n+                        try!(space(&mut self.s));\n+                        try!(self.print_block(&**then));\n+                        self.print_else(e.as_ref().map(|e| &**e))\n+                    }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n                         try!(self.cbox(indent_unit - 1u));\n@@ -1325,15 +1338,26 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n-                    elseopt: Option<&ast::Expr>, chk: bool) -> IoResult<()> {\n+                    elseopt: Option<&ast::Expr>) -> IoResult<()> {\n         try!(self.head(\"if\"));\n-        if chk { try!(self.word_nbsp(\"check\")); }\n         try!(self.print_expr(test));\n         try!(space(&mut self.s));\n         try!(self.print_block(blk));\n         self.print_else(elseopt)\n     }\n \n+    pub fn print_if_let(&mut self, pat: &ast::Pat, expr: &ast::Expr, blk: &ast::Block,\n+                        elseopt: Option<&ast::Expr>) -> IoResult<()> {\n+        try!(self.head(\"if let\"));\n+        try!(self.print_pat(pat));\n+        try!(space(&mut self.s));\n+        try!(self.word_space(\"=\"));\n+        try!(self.print_expr(expr));\n+        try!(space(&mut self.s));\n+        try!(self.print_block(blk));\n+        self.print_else(elseopt)\n+    }\n+\n     pub fn print_mac(&mut self, m: &ast::Mac) -> IoResult<()> {\n         match m.node {\n             // I think it's reasonable to hide the ctxt here:\n@@ -1474,7 +1498,10 @@ impl<'a> State<'a> {\n                 try!(self.print_type(&**ty));\n             }\n             ast::ExprIf(ref test, ref blk, ref elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e), false));\n+                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n+            }\n+            ast::ExprIfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n+                try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprWhile(ref test, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {"}, {"sha": "6fc79e2c42ab9f2bff799a8e5fbabe2c96c5bd4d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8cfd53b513d999ffff22f17e3066a30a8ed949/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5d8cfd53b513d999ffff22f17e3066a30a8ed949", "patch": "@@ -730,13 +730,19 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**subexpression);\n             visitor.visit_block(&**block)\n         }\n+        ExprIfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+            visitor.visit_pat(&**pattern);\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_block(&**if_block);\n+            walk_expr_opt(visitor, optional_else);\n+        }\n         ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n             visitor.visit_pat(&**pattern);\n             visitor.visit_expr(&**subexpression);\n             visitor.visit_block(&**block)\n         }\n         ExprLoop(ref block, _) => visitor.visit_block(&**block),\n-        ExprMatch(ref subexpression, ref arms) => {\n+        ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(&**subexpression);\n             for arm in arms.iter() {\n                 visitor.visit_arm(arm)"}]}