{"sha": "f3682b56392bc255ca572f75dd9eb59cb0730add", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNjgyYjU2MzkyYmMyNTVjYTU3MmY3NWRkOWViNTljYjA3MzBhZGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-20T22:05:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T15:48:20Z"}, "message": "syntax: Fix fallout of removing get()", "tree": {"sha": "81d693c1b6968aeddeb126f3decbf4359abc923c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81d693c1b6968aeddeb126f3decbf4359abc923c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3682b56392bc255ca572f75dd9eb59cb0730add", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3682b56392bc255ca572f75dd9eb59cb0730add", "html_url": "https://github.com/rust-lang/rust/commit/f3682b56392bc255ca572f75dd9eb59cb0730add", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3682b56392bc255ca572f75dd9eb59cb0730add/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd510b33821a0b3e7ae7dd576c0d22d3531ddb0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd510b33821a0b3e7ae7dd576c0d22d3531ddb0b", "html_url": "https://github.com/rust-lang/rust/commit/cd510b33821a0b3e7ae7dd576c0d22d3531ddb0b"}], "stats": {"total": 368, "additions": 159, "deletions": 209}, "files": [{"sha": "90c23a54426c12e7dc438e8a3679b457228c68d1", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -40,7 +40,7 @@ impl PathElem {\n impl fmt::Show for PathElem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let slot = token::get_name(self.name());\n-        write!(f.buf, \"{}\", slot.get())\n+        write!(f.buf, \"{}\", slot)\n     }\n }\n \n@@ -190,8 +190,8 @@ pub struct Map {\n impl Map {\n     fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n         let map = self.map.borrow();\n-        if map.get().len() > id as uint {\n-            Some(*map.get().get(id as uint))\n+        if map.len() > id as uint {\n+            Some(*map.get(id as uint))\n         } else {\n             None\n         }\n@@ -395,8 +395,7 @@ pub struct Ctx<'a, F> {\n \n impl<'a, F> Ctx<'a, F> {\n     fn insert(&self, id: NodeId, entry: MapEntry) {\n-        let mut map = self.map.map.borrow_mut();\n-        map.get().grow_set(id as uint, &NotPresent, entry);\n+        (*self.map.map.borrow_mut()).grow_set(id as uint, &NotPresent, entry);\n     }\n }\n \n@@ -540,15 +539,15 @@ pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n         let map = map.map.borrow();\n         // This only makes sense for ordered stores; note the\n         // enumerate to count the number of entries.\n-        let (entries_less_1, _) = map.get().iter().filter(|&x| {\n+        let (entries_less_1, _) = (*map).iter().filter(|&x| {\n             match *x {\n                 NotPresent => false,\n                 _ => true\n             }\n         }).enumerate().last().expect(\"AST map was empty after folding?\");\n \n         let entries = entries_less_1 + 1;\n-        let vector_length = map.get().len();\n+        let vector_length = (*map).len();\n         debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }"}, {"sha": "4ba7921c431947d2810f08743bcfc0692e3d31f0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -228,15 +228,15 @@ impl FileMap {\n     pub fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let mut lines = self.lines.borrow_mut();;\n-        let line_len = lines.get().len();\n-        assert!(line_len == 0 || (*lines.get().get(line_len - 1) < pos))\n-        lines.get().push(pos);\n+        let line_len = lines.len();\n+        assert!(line_len == 0 || (*lines.get(line_len - 1) < pos))\n+        lines.push(pos);\n     }\n \n     // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n         let mut lines = self.lines.borrow_mut();\n-        let begin: BytePos = *lines.get().get(line as uint) - self.start_pos;\n+        let begin: BytePos = *lines.get(line as uint) - self.start_pos;\n         let begin = begin.to_uint();\n         let slice = self.src.slice_from(begin);\n         match slice.find('\\n') {\n@@ -251,7 +251,7 @@ impl FileMap {\n             pos: pos,\n             bytes: bytes,\n         };\n-        self.multibyte_chars.borrow_mut().get().push(mbc);\n+        self.multibyte_chars.borrow_mut().push(mbc);\n     }\n \n     pub fn is_real_file(&self) -> bool {\n@@ -272,9 +272,9 @@ impl CodeMap {\n \n     pub fn new_filemap(&self, filename: FileName, src: ~str) -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n-        let start_pos = match files.get().last() {\n+        let start_pos = match files.last() {\n             None => 0,\n-            Some(last) => last.deref().start_pos.to_uint() + last.deref().src.len(),\n+            Some(last) => last.start_pos.to_uint() + last.src.len(),\n         };\n \n         // Remove utf-8 BOM if any.\n@@ -302,14 +302,14 @@ impl CodeMap {\n             multibyte_chars: RefCell::new(Vec::new()),\n         });\n \n-        files.get().push(filemap.clone());\n+        files.push(filemap.clone());\n \n         filemap\n     }\n \n     pub fn mk_substr_filename(&self, sp: Span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n-        format!(\"<{}:{}:{}>\", pos.file.deref().name, pos.line, pos.col.to_uint() + 1)\n+        format!(\"<{}:{}:{}>\", pos.file.name, pos.line, pos.col.to_uint() + 1)\n     }\n \n     /// Lookup source information about a BytePos\n@@ -320,15 +320,15 @@ impl CodeMap {\n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         LocWithOpt {\n-            filename: loc.file.deref().name.to_str(),\n+            filename: loc.file.name.to_str(),\n             line: loc.line,\n             col: loc.col,\n             file: Some(loc.file)\n         }\n     }\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {\n-        if self.files.borrow().get().len() == 0 && sp == DUMMY_SP {\n+        if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n             return ~\"no-location\";\n         }\n \n@@ -339,7 +339,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n-        self.lookup_char_pos(sp.lo).file.deref().name.to_str()\n+        self.lookup_char_pos(sp.lo).file.name.to_str()\n     }\n \n     pub fn span_to_lines(&self, sp: Span) -> FileLines {\n@@ -360,16 +360,16 @@ impl CodeMap {\n         // it's testing isn't true for all spans in the AST, so to allow the\n         // caller to not have to fail (and it can't catch it since the CodeMap\n         // isn't sendable), return None\n-        if begin.fm.deref().start_pos != end.fm.deref().start_pos {\n+        if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some(begin.fm.deref().src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n+            Some(begin.fm.src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n         }\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n-        for fm in self.files.borrow().get().iter() {\n-            if filename == fm.deref().name {\n+        for fm in self.files.borrow().iter() {\n+            if filename == fm.name {\n                 return fm.clone();\n             }\n         }\n@@ -378,13 +378,13 @@ impl CodeMap {\n \n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = self.files.borrow();\n-        let files = files.get();\n+        let files = files;\n         let len = files.len();\n         let mut a = 0u;\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if files.get(m).deref().start_pos > pos {\n+            if files.get(m).start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n@@ -394,8 +394,8 @@ impl CodeMap {\n         // filemap, but are not the filemaps we want (because they are length 0, they cannot\n         // contain what we are looking for). So, rewind until we find a useful filemap.\n         loop {\n-            let lines = files.get(a).deref().lines.borrow();\n-            let lines = lines.get();\n+            let lines = files.get(a).lines.borrow();\n+            let lines = lines;\n             if lines.len() > 0 {\n                 break;\n             }\n@@ -415,14 +415,14 @@ impl CodeMap {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n-        let f = files.get().get(idx).clone();\n+        let f = files.get(idx).clone();\n         let mut a = 0u;\n         {\n-            let mut lines = f.deref().lines.borrow_mut();\n-            let mut b = lines.get().len();\n+            let mut lines = f.lines.borrow_mut();\n+            let mut b = lines.len();\n             while b - a > 1u {\n                 let m = (a + b) / 2u;\n-                if *lines.get().get(m) > pos { b = m; } else { a = m; }\n+                if *lines.get(m) > pos { b = m; } else { a = m; }\n             }\n         }\n         FileMapAndLine {fm: f, line: a}\n@@ -432,7 +432,7 @@ impl CodeMap {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let linebpos = *f.deref().lines.borrow().get().get(a);\n+        let linebpos = *f.lines.borrow().get(a);\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n@@ -449,8 +449,8 @@ impl CodeMap {\n \n     fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let fm = self.files.borrow().get().get(idx).clone();\n-        let offset = bpos - fm.deref().start_pos;\n+        let fm = self.files.borrow().get(idx).clone();\n+        let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n \n@@ -459,12 +459,12 @@ impl CodeMap {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n-        let map = files.get().get(idx);\n+        let map = files.get(idx);\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for mbc in map.deref().multibyte_chars.borrow().get().iter() {\n+        for mbc in map.multibyte_chars.borrow().iter() {\n             debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only\n@@ -478,8 +478,8 @@ impl CodeMap {\n             }\n         }\n \n-        assert!(map.deref().start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n-        CharPos(bpos.to_uint() - map.deref().start_pos.to_uint() - total_extra_bytes)\n+        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n+        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n     }\n }\n "}, {"sha": "e19c4c3026a5d1de8b0bf7aa7613b98b3b0dd9cb", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -84,11 +84,11 @@ pub struct Handler {\n \n impl Handler {\n     pub fn fatal(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().get().emit(None, msg, Fatal);\n+        self.emit.borrow_mut().emit(None, msg, Fatal);\n         fail!(FatalError);\n     }\n     pub fn err(&self, msg: &str) {\n-        self.emit.borrow_mut().get().emit(None, msg, Error);\n+        self.emit.borrow_mut().emit(None, msg, Error);\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n@@ -113,13 +113,13 @@ impl Handler {\n         self.fatal(s);\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().get().emit(None, msg, Warning);\n+        self.emit.borrow_mut().emit(None, msg, Warning);\n     }\n     pub fn note(&self, msg: &str) {\n-        self.emit.borrow_mut().get().emit(None, msg, Note);\n+        self.emit.borrow_mut().emit(None, msg, Note);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().get().emit(None, msg, Bug);\n+        self.emit.borrow_mut().emit(None, msg, Bug);\n         fail!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -129,11 +129,11 @@ impl Handler {\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n                 msg: &str,\n                 lvl: Level) {\n-        self.emit.borrow_mut().get().emit(cmsp, msg, lvl);\n+        self.emit.borrow_mut().emit(cmsp, msg, lvl);\n     }\n     pub fn custom_emit(&self, cm: &codemap::CodeMap,\n                        sp: Span, msg: &str, lvl: Level) {\n-        self.emit.borrow_mut().get().custom_emit(cm, sp, msg, lvl);\n+        self.emit.borrow_mut().custom_emit(cm, sp, msg, lvl);\n     }\n }\n \n@@ -301,7 +301,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    sp: Span,\n                    lvl: Level,\n                    lines: codemap::FileLines) -> io::IoResult<()> {\n-    let fm = lines.file.deref();\n+    let fm = &*lines.file;\n \n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n@@ -374,7 +374,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           sp: Span,\n                           lvl: Level,\n                           lines: codemap::FileLines) -> io::IoResult<()> {\n-    let fm = lines.file.deref();\n+    let fm = &*lines.file;\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {"}, {"sha": "bdb16f176c0812544d35f11733a718e563f1eaac", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -628,7 +628,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             vec!(\n                 self.expr_str(span, msg),\n                 self.expr_str(span,\n-                              token::intern_and_get_ident(loc.file.deref().name)),\n+                              token::intern_and_get_ident(loc.file.name)),\n                 self.expr_uint(span, loc.line)))\n     }\n "}, {"sha": "4ae9d43697218a2650d6a2254a53334b0506671e", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -63,11 +63,10 @@ pub fn new_mark(m: Mrk, tail: SyntaxContext) -> SyntaxContext {\n // Extend a syntax context with a given mark and table\n fn new_mark_internal(m: Mrk, tail: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (tail, m);\n-    let mut mark_memo = table.mark_memo.borrow_mut();\n     let new_ctxt = |_: &(SyntaxContext, Mrk)|\n-                   idx_push(table.table.borrow_mut().get(), Mark(m, tail));\n+                   idx_push(&mut *table.table.borrow_mut(), Mark(m, tail));\n \n-    *mark_memo.get().find_or_insert_with(key, new_ctxt)\n+    *table.mark_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n }\n \n /// Extend a syntax context with a given rename\n@@ -82,11 +81,10 @@ fn new_rename_internal(id: Ident,\n                        tail: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n     let key = (tail,id,to);\n-    let mut rename_memo = table.rename_memo.borrow_mut();\n     let new_ctxt = |_: &(SyntaxContext, Ident, Mrk)|\n-                   idx_push(table.table.borrow_mut().get(), Rename(id, to, tail));\n+                   idx_push(&mut *table.table.borrow_mut(), Rename(id, to, tail));\n \n-    *rename_memo.get().find_or_insert_with(key, new_ctxt)\n+    *table.rename_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n }\n \n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n@@ -102,7 +100,7 @@ pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n             }\n             Some(ts) => ts.clone()\n         };\n-        op(table.deref())\n+        op(&*table)\n     })\n }\n \n@@ -119,18 +117,17 @@ fn new_sctable_internal() -> SCTable {\n /// Print out an SCTable for debugging\n pub fn display_sctable(table: &SCTable) {\n     error!(\"SC table:\");\n-    let table = table.table.borrow();\n-    for (idx,val) in table.get().iter().enumerate() {\n+    for (idx,val) in table.table.borrow().iter().enumerate() {\n         error!(\"{:4u} : {:?}\",idx,val);\n     }\n }\n \n /// Clear the tables from TLD to reclaim memory.\n pub fn clear_tables() {\n     with_sctable(|table| {\n-        *table.table.borrow_mut().get() = Vec::new();\n-        *table.mark_memo.borrow_mut().get() = HashMap::new();\n-        *table.rename_memo.borrow_mut().get() = HashMap::new();\n+        *table.table.borrow_mut() = Vec::new();\n+        *table.mark_memo.borrow_mut() = HashMap::new();\n+        *table.rename_memo.borrow_mut() = HashMap::new();\n     });\n     with_resolve_table_mut(|table| *table = HashMap::new());\n }\n@@ -166,7 +163,7 @@ fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n             }\n             Some(ts) => ts.clone()\n         };\n-        op(table.deref().borrow_mut().get())\n+        op(&mut *table.borrow_mut())\n     })\n }\n \n@@ -183,7 +180,7 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = *table.table.borrow().get().get(id.ctxt as uint);\n+        let result = *table.table.borrow().get(id.ctxt as uint);\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n@@ -227,10 +224,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = {\n-            let table = table.table.borrow();\n-            *table.get().get(loopvar as uint)\n-        };\n+        let table_entry = *table.table.borrow().get(loopvar as uint);\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -257,7 +251,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match *sctable.table.borrow().get().get(ctxt as uint) {\n+        match *sctable.table.borrow().get(ctxt as uint) {\n             Mark(mrk, _) => mrk,\n             _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -327,7 +321,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match *table.get().get(sc as uint) {\n+            match *table.get(sc as uint) {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -351,9 +345,9 @@ mod tests {\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n-            assert!(*table.get().get(2) == Mark(9,0));\n-            assert!(*table.get().get(3) == Rename(id(101,0),14,2));\n-            assert!(*table.get().get(4) == Mark(3,3));\n+            assert!(*table.get(2) == Mark(9,0));\n+            assert!(*table.get(3) == Rename(id(101,0),14,2));\n+            assert!(*table.get(4) == Mark(3,3));\n         }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n@@ -372,8 +366,8 @@ mod tests {\n         assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n         {\n             let table = t.table.borrow();\n-            assert!(*table.get().get(2) == Mark(7,0));\n-            assert!(*table.get().get(3) == Mark(3,2));\n+            assert!(*table.get(2) == Mark(7,0));\n+            assert!(*table.get(3) == Mark(3,2));\n         }\n     }\n "}, {"sha": "8931fb0f443aa50474cac9635819ff8bb90d6374", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -57,7 +57,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    let filename = token::intern_and_get_ident(loc.file.deref().name);\n+    let filename = token::intern_and_get_ident(loc.file.name);\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n "}, {"sha": "b3e3023388b94c02e7218d8e662cddf76dc3260f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -42,35 +42,32 @@ impl<'a> ParserAnyMacro<'a> {\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();\n-        if allow_semi && parser.get().token == SEMI {\n-            parser.get().bump()\n+        if allow_semi && parser.token == SEMI {\n+            parser.bump()\n         }\n-        if parser.get().token != EOF {\n-            let token_str = parser.get().this_token_to_str();\n+        if parser.token != EOF {\n+            let token_str = parser.this_token_to_str();\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n                                following\",\n                               token_str);\n-            let span = parser.get().span;\n-            parser.get().span_err(span, msg);\n+            let span = parser.span;\n+            parser.span_err(span, msg);\n         }\n     }\n }\n \n impl<'a> AnyMacro for ParserAnyMacro<'a> {\n     fn make_expr(&self) -> @ast::Expr {\n-        let ret = {\n-            let mut parser = self.parser.borrow_mut();\n-            parser.get().parse_expr()\n-        };\n+        let ret = self.parser.borrow_mut().parse_expr();\n         self.ensure_complete_parse(true);\n         ret\n     }\n     fn make_items(&self) -> SmallVector<@ast::Item> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n-            let attrs = parser.get().parse_outer_attributes();\n-            match parser.get().parse_item(attrs) {\n+            let attrs = parser.parse_outer_attributes();\n+            match parser.parse_item(attrs) {\n                 Some(item) => ret.push(item),\n                 None => break\n             }\n@@ -79,11 +76,8 @@ impl<'a> AnyMacro for ParserAnyMacro<'a> {\n         ret\n     }\n     fn make_stmt(&self) -> @ast::Stmt {\n-        let ret = {\n-            let mut parser = self.parser.borrow_mut();\n-            let attrs = parser.get().parse_outer_attributes();\n-            parser.get().parse_stmt(attrs)\n-        };\n+        let attrs = self.parser.borrow_mut().parse_outer_attributes();\n+        let ret = self.parser.borrow_mut().parse_stmt(attrs);\n         self.ensure_complete_parse(true);\n         ret\n     }\n@@ -242,7 +236,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     };\n \n     return MRDef(MacroDef {\n-        name: token::get_ident(name).get().to_str(),\n+        name: token::get_ident(name).to_str(),\n         ext: NormalTT(exp, Some(sp))\n     });\n }"}, {"sha": "933fbe3d5662486da0176183c3d0ac460e216c4b", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -109,15 +109,11 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: @NamedMatch)\n             MatchedSeq(ref ads, _) => *ads.get(*idx)\n         }\n     }\n-    let repeat_idx = r.repeat_idx.borrow();\n-    repeat_idx.get().iter().fold(start, red)\n+    r.repeat_idx.borrow().iter().fold(start, red)\n }\n \n fn lookup_cur_matched(r: &TtReader, name: Ident) -> @NamedMatch {\n-    let matched_opt = {\n-        let interpolations = r.interpolations.borrow();\n-        interpolations.get().find_copy(&name)\n-    };\n+    let matched_opt = r.interpolations.borrow().find_copy(&name);\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n@@ -178,19 +174,14 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n         sp: r.cur_span.get(),\n     };\n     loop {\n-        {\n-            let mut stack = r.stack.borrow_mut();\n-            if stack.get().idx.get() < stack.get().forest.len() {\n-                break;\n-            }\n+        if r.stack.borrow().idx.get() < r.stack.borrow().forest.len() {\n+            break;\n         }\n \n         /* done with this set; pop or repeat? */\n         if !r.stack.get().dotdotdoted || {\n-                let repeat_idx = r.repeat_idx.borrow();\n-                let repeat_len = r.repeat_len.borrow();\n-                *repeat_idx.get().last().unwrap() ==\n-                *repeat_len.get().last().unwrap() - 1\n+                *r.repeat_idx.borrow().last().unwrap() ==\n+                *r.repeat_len.borrow().last().unwrap() - 1\n             } {\n \n             match r.stack.get().up {\n@@ -200,12 +191,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n               }\n               Some(tt_f) => {\n                 if r.stack.get().dotdotdoted {\n-                    {\n-                        let mut repeat_idx = r.repeat_idx.borrow_mut();\n-                        let mut repeat_len = r.repeat_len.borrow_mut();\n-                        repeat_idx.get().pop().unwrap();\n-                        repeat_len.get().pop().unwrap();\n-                    }\n+                    r.repeat_idx.borrow_mut().pop().unwrap();\n+                    r.repeat_len.borrow_mut().pop().unwrap();\n                 }\n \n                 r.stack.set(tt_f);\n@@ -217,8 +204,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n             r.stack.get().idx.set(0u);\n             {\n                 let mut repeat_idx = r.repeat_idx.borrow_mut();\n-                let last_repeat_idx = repeat_idx.get().len() - 1u;\n-                *repeat_idx.get().get_mut(last_repeat_idx) += 1u;\n+                let last_repeat_idx = repeat_idx.len() - 1u;\n+                *repeat_idx.get_mut(last_repeat_idx) += 1u;\n             }\n             match r.stack.get().sep.clone() {\n               Some(tk) => {\n@@ -276,19 +263,15 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                     r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                     return tt_next_token(r);\n                 } else {\n-                    {\n-                        let mut repeat_idx = r.repeat_idx.borrow_mut();\n-                        let mut repeat_len = r.repeat_len.borrow_mut();\n-                        repeat_len.get().push(len);\n-                        repeat_idx.get().push(0u);\n-                        r.stack.set(@TtFrame {\n-                            forest: tts,\n-                            idx: Cell::new(0u),\n-                            dotdotdoted: true,\n-                            sep: sep,\n-                            up: Some(r.stack.get())\n-                        });\n-                    }\n+                    r.repeat_len.borrow_mut().push(len);\n+                    r.repeat_idx.borrow_mut().push(0u);\n+                    r.stack.set(@TtFrame {\n+                        forest: tts,\n+                        idx: Cell::new(0u),\n+                        dotdotdoted: true,\n+                        sep: sep,\n+                        up: Some(r.stack.get())\n+                    });\n                 }\n               }\n             }"}, {"sha": "ccee21f62816a94376fb2d6983fd86522c5a5a2b", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -78,8 +78,8 @@ pub fn new_low_level_string_reader<'a>(span_diagnostic: &'a SpanHandler,\n     let initial_char = '\\n';\n     let r = StringReader {\n         span_diagnostic: span_diagnostic,\n-        pos: Cell::new(filemap.deref().start_pos),\n-        last_pos: Cell::new(filemap.deref().start_pos),\n+        pos: Cell::new(filemap.start_pos),\n+        last_pos: Cell::new(filemap.start_pos),\n         col: Cell::new(CharPos(0)),\n         curr: Cell::new(Some(initial_char)),\n         filemap: filemap,\n@@ -111,12 +111,9 @@ impl<'a> Reader for StringReader<'a> {\n     fn is_eof(&self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(&self) -> TokenAndSpan {\n-        let ret_val = {\n-            let mut peek_tok = self.peek_tok.borrow_mut();\n-            TokenAndSpan {\n-                tok: replace(peek_tok.get(), token::UNDERSCORE),\n-                sp: self.peek_span.get(),\n-            }\n+        let ret_val = TokenAndSpan {\n+            tok: replace(&mut *self.peek_tok.borrow_mut(), token::UNDERSCORE),\n+            sp: self.peek_span.get(),\n         };\n         string_advance_token(self);\n         ret_val\n@@ -137,8 +134,7 @@ impl<'a> Reader for StringReader<'a> {\n \n impl<'a> Reader for TtReader<'a> {\n     fn is_eof(&self) -> bool {\n-        let cur_tok = self.cur_tok.borrow();\n-        *cur_tok.get() == token::EOF\n+        *self.cur_tok.borrow() == token::EOF\n     }\n     fn next_token(&self) -> TokenAndSpan {\n         let r = tt_next_token(self);\n@@ -191,7 +187,7 @@ fn fatal_span_verbose(rdr: &StringReader,\n                    -> ! {\n     let mut m = m;\n     m.push_str(\": \");\n-    let s = rdr.filemap.deref().src.slice(\n+    let s = rdr.filemap.src.slice(\n                   byte_offset(rdr, from_pos).to_uint(),\n                   byte_offset(rdr, to_pos).to_uint());\n     m.push_str(s);\n@@ -220,7 +216,7 @@ fn string_advance_token(r: &StringReader) {\n }\n \n fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n-    (pos - rdr.filemap.deref().start_pos)\n+    (pos - rdr.filemap.start_pos)\n }\n \n /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -242,7 +238,7 @@ fn with_str_from_to<T>(\n                     end: BytePos,\n                     f: |s: &str| -> T)\n                     -> T {\n-    f(rdr.filemap.deref().src.slice(\n+    f(rdr.filemap.src.slice(\n             byte_offset(rdr, start).to_uint(),\n             byte_offset(rdr, end).to_uint()))\n }\n@@ -252,21 +248,21 @@ fn with_str_from_to<T>(\n pub fn bump(rdr: &StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if current_byte_offset < rdr.filemap.deref().src.len() {\n+    if current_byte_offset < rdr.filemap.src.len() {\n         assert!(rdr.curr.get().is_some());\n         let last_char = rdr.curr.get().unwrap();\n-        let next = rdr.filemap.deref().src.char_range_at(current_byte_offset);\n+        let next = rdr.filemap.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n         rdr.curr.set(Some(next.ch));\n         rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n-            rdr.filemap.deref().next_line(rdr.last_pos.get());\n+            rdr.filemap.next_line(rdr.last_pos.get());\n             rdr.col.set(CharPos(0u));\n         }\n \n         if byte_offset_diff > 1 {\n-            rdr.filemap.deref().record_multibyte_char(rdr.last_pos.get(), byte_offset_diff);\n+            rdr.filemap.record_multibyte_char(rdr.last_pos.get(), byte_offset_diff);\n         }\n     } else {\n         rdr.curr.set(None);\n@@ -279,8 +275,8 @@ pub fn is_eof(rdr: &StringReader) -> bool {\n \n pub fn nextch(rdr: &StringReader) -> Option<char> {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if offset < rdr.filemap.deref().src.len() {\n-        Some(rdr.filemap.deref().src.char_at(offset))\n+    if offset < rdr.filemap.src.len() {\n+        Some(rdr.filemap.src.char_at(offset))\n     } else {\n         None\n     }\n@@ -397,7 +393,7 @@ fn consume_any_line_comment(rdr: &StringReader)\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n             let cmap = CodeMap::new();\n-            cmap.files.borrow_mut().get().push(rdr.filemap.clone());\n+            cmap.files.borrow_mut().push(rdr.filemap.clone());\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n                 while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }"}, {"sha": "1313225e22bb9bad7599d3452050626772e65e27", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -4203,28 +4203,22 @@ impl<'a> Parser<'a> {\n                               path: Path,\n                               outer_attrs: Vec<ast::Attribute> ,\n                               id_sp: Span) -> (ast::Item_, Vec<ast::Attribute> ) {\n-        {\n-            let mut included_mod_stack = self.sess\n-                                             .included_mod_stack\n-                                             .borrow_mut();\n-            let maybe_i = included_mod_stack.get()\n-                                            .iter()\n-                                            .position(|p| *p == path);\n-            match maybe_i {\n-                Some(i) => {\n-                    let mut err = ~\"circular modules: \";\n-                    let len = included_mod_stack.get().len();\n-                    for p in included_mod_stack.get().slice(i, len).iter() {\n-                        err.push_str(p.display().as_maybe_owned().as_slice());\n-                        err.push_str(\" -> \");\n-                    }\n-                    err.push_str(path.display().as_maybe_owned().as_slice());\n-                    self.span_fatal(id_sp, err);\n+        let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n+        match included_mod_stack.iter().position(|p| *p == path) {\n+            Some(i) => {\n+                let mut err = ~\"circular modules: \";\n+                let len = included_mod_stack.len();\n+                for p in included_mod_stack.slice(i, len).iter() {\n+                    err.push_str(p.display().as_maybe_owned().as_slice());\n+                    err.push_str(\" -> \");\n                 }\n-                None => ()\n+                err.push_str(path.display().as_maybe_owned().as_slice());\n+                self.span_fatal(id_sp, err);\n             }\n-            included_mod_stack.get().push(path.clone());\n+            None => ()\n         }\n+        included_mod_stack.push(path.clone());\n+        drop(included_mod_stack);\n \n         let mut p0 =\n             new_sub_parser_from_file(self.sess,\n@@ -4235,12 +4229,7 @@ impl<'a> Parser<'a> {\n         let mod_attrs = vec::append(outer_attrs, inner.as_slice());\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n-        {\n-            let mut included_mod_stack = self.sess\n-                                             .included_mod_stack\n-                                             .borrow_mut();\n-            included_mod_stack.get().pop();\n-        }\n+        self.sess.included_mod_stack.borrow_mut().pop();\n         return (ast::ItemMod(m0), mod_attrs);\n     }\n "}, {"sha": "a9ab596b300d5a97f93422c9ca4a8a7b627bd039", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -238,23 +238,23 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> ~str {\n \n impl<'a> State<'a> {\n     pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.borrow_mut().get().push(pp::Inconsistent);\n+        self.boxes.borrow_mut().push(pp::Inconsistent);\n         pp::ibox(&mut self.s, u)\n     }\n \n     pub fn end(&mut self) -> IoResult<()> {\n-        self.boxes.borrow_mut().get().pop().unwrap();\n+        self.boxes.borrow_mut().pop().unwrap();\n         pp::end(&mut self.s)\n     }\n \n     pub fn cbox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.borrow_mut().get().push(pp::Consistent);\n+        self.boxes.borrow_mut().push(pp::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n     // \"raw box\"\n     pub fn rbox(&mut self, u: uint, b: pp::Breaks) -> IoResult<()> {\n-        self.boxes.borrow_mut().get().push(b);\n+        self.boxes.borrow_mut().push(b);\n         pp::rbox(&mut self.s, u, b)\n     }\n \n@@ -322,7 +322,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn in_cbox(&mut self) -> bool {\n-        match self.boxes.borrow().get().last() {\n+        match self.boxes.borrow().last() {\n             Some(&last_box) => last_box == pp::Consistent,\n             None => false\n         }\n@@ -2186,7 +2186,7 @@ impl<'a> State<'a> {\n             ast::LitBinary(ref arr) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_cmnt(Inconsistent, arr.deref().as_slice(),\n+                try!(self.commasep_cmnt(Inconsistent, arr.as_slice(),\n                                         |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                                         |_| lit.span));\n                 try!(word(&mut self.s, \"]\"));"}, {"sha": "d6f8f1067aecc0f60acdc16e9e2a050afb6983af", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3682b56392bc255ca572f75dd9eb59cb0730add/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=f3682b56392bc255ca572f75dd9eb59cb0730add", "patch": "@@ -46,47 +46,47 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn intern(&self, val: T) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match map.get().find(&val) {\n+        match (*map).find(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n         let mut vect = self.vect.borrow_mut();\n-        let new_idx = vect.get().len() as Name;\n-        map.get().insert(val.clone(), new_idx);\n-        vect.get().push(val);\n+        let new_idx = (*vect).len() as Name;\n+        (*map).insert(val.clone(), new_idx);\n+        (*vect).push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: T) -> Name {\n         let mut vect = self.vect.borrow_mut();\n-        let new_idx = vect.get().len() as Name;\n+        let new_idx = (*vect).len() as Name;\n         // leave out of .map to avoid colliding\n-        vect.get().push(val);\n+        (*vect).push(val);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        (*vect.get().get(idx as uint)).clone()\n+        (*(*vect).get(idx as uint)).clone()\n     }\n \n     pub fn len(&self) -> uint {\n         let vect = self.vect.borrow();\n-        vect.get().len()\n+        (*vect).len()\n     }\n \n     pub fn find_equiv<Q:Hash + Equiv<T>>(&self, val: &Q) -> Option<Name> {\n         let map = self.map.borrow();\n-        match map.get().find_equiv(val) {\n+        match (*map).find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }\n     }\n \n     pub fn clear(&self) {\n-        *self.map.borrow_mut().get() = HashMap::new();\n-        *self.vect.borrow_mut().get() = Vec::new();\n+        *self.map.borrow_mut() = HashMap::new();\n+        *self.vect.borrow_mut() = Vec::new();\n     }\n }\n \n@@ -110,13 +110,13 @@ impl TotalOrd for RcStr {\n impl Str for RcStr {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n-        let s: &'a str = *self.string.deref();\n+        let s: &'a str = *self.string;\n         s\n     }\n \n     #[inline]\n     fn into_owned(self) -> ~str {\n-        self.string.deref().to_owned()\n+        self.string.to_owned()\n     }\n }\n \n@@ -159,24 +159,22 @@ impl StrInterner {\n \n     pub fn intern(&self, val: &str) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match map.get().find_equiv(&val) {\n+        match map.find_equiv(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n         let new_idx = self.len() as Name;\n         let val = RcStr::new(val);\n-        map.get().insert(val.clone(), new_idx);\n-        let mut vect = self.vect.borrow_mut();\n-        vect.get().push(val);\n+        map.insert(val.clone(), new_idx);\n+        self.vect.borrow_mut().push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: &str) -> Name {\n         let new_idx = self.len() as Name;\n         // leave out of .map to avoid colliding\n-        let mut vect = self.vect.borrow_mut();\n-        vect.get().push(RcStr::new(val));\n+        self.vect.borrow_mut().push(RcStr::new(val));\n         new_idx\n     }\n \n@@ -194,42 +192,39 @@ impl StrInterner {\n         let new_idx = self.len() as Name;\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect.get().get(idx as uint)).clone();\n-        vect.get().push(existing);\n+        let existing = (*vect.get(idx as uint)).clone();\n+        vect.push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n-        let vect = self.vect.borrow();\n-        (*vect.get().get(idx as uint)).clone()\n+        (*self.vect.borrow().get(idx as uint)).clone()\n     }\n \n     /// Returns this string with lifetime tied to the interner. Since\n     /// strings may never be removed from the interner, this is safe.\n     pub fn get_ref<'a>(&'a self, idx: Name) -> &'a str {\n         let vect = self.vect.borrow();\n-        let s: &str = vect.get().get(idx as uint).as_slice();\n+        let s: &str = vect.get(idx as uint).as_slice();\n         unsafe {\n             cast::transmute(s)\n         }\n     }\n \n     pub fn len(&self) -> uint {\n-        let vect = self.vect.borrow();\n-        vect.get().len()\n+        self.vect.borrow().len()\n     }\n \n     pub fn find_equiv<Q:Hash + Equiv<RcStr>>(&self, val: &Q) -> Option<Name> {\n-        let map = self.map.borrow();\n-        match map.get().find_equiv(val) {\n+        match (*self.map.borrow()).find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }\n     }\n \n     pub fn clear(&self) {\n-        *self.map.borrow_mut().get() = HashMap::new();\n-        *self.vect.borrow_mut().get() = Vec::new();\n+        *self.map.borrow_mut() = HashMap::new();\n+        *self.vect.borrow_mut() = Vec::new();\n     }\n }\n "}]}