{"sha": "db9689333a2b52af4dffde750e7055cf6badb576", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiOTY4OTMzM2EyYjUyYWY0ZGZmZGU3NTBlNzA1NWNmNmJhZGI1NzY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-01T21:56:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-01T21:56:21Z"}, "message": "Rollup merge of #64910 - Centril:params-cleanup, r=petrochenkov\n\nsyntax: cleanup param, method, and misc parsing\n\nDo some misc cleanup of the parser:\n- Method and parameter parsing is refactored.\n- A parser for `const | mut` is introduced that https://github.com/rust-lang/rust/pull/64588 can reuse.\n- Some other misc parsing.\n\nNext up in a different PR:\n- ~Implementing https://github.com/rust-lang/rust/issues/64252.~ -- maybe some other time...\n- Heavily restructuring up `item.rs` which is a mess (hopefully, no promises ^^).\n\nr? @petrochenkov", "tree": {"sha": "916b33335ca0556181b2081f44f02d0b9c2cb69f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/916b33335ca0556181b2081f44f02d0b9c2cb69f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db9689333a2b52af4dffde750e7055cf6badb576", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdk8uFCRBK7hj4Ov3rIwAAdHIIAFziBd03yXDglSrjOYxzku2i\nBgppR/jyGc5RRPOz+dwvCFTHsf39eJh8Q3RuVYdYOORSD3StytfFgWwGVhEO1jQl\nf60sX/MT3PgSnlhMnUa01KjikssmCLz5SDW1w1KGsWM1j9l0pDNaVM1dt4DLKWNc\naXy7otPYOETCptr2Tw++HsK15vC9YxRlg8BUrDrShyvheAzCYawMumkMTzlfeS6a\nDEpYHEpqA6q0VU6UXh57CXzcX+gPZcq1RXpExJnaTUk/Y8ciHYk4EF/WG1t/ZZt6\n7DVSFmc5b9kyG3leNEgB0iqHVxkNNMK9Pia/RgzO39o/4alSW01yM+d7XC+EV60=\n=jo8v\n-----END PGP SIGNATURE-----\n", "payload": "tree 916b33335ca0556181b2081f44f02d0b9c2cb69f\nparent 69028ae85bd6f54fed4c6e97f430db1138b986eb\nparent 5c5dd8069d0aeeb97ef6b6099767f97aec1edee4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569966981 +0200\ncommitter GitHub <noreply@github.com> 1569966981 +0200\n\nRollup merge of #64910 - Centril:params-cleanup, r=petrochenkov\n\nsyntax: cleanup param, method, and misc parsing\n\nDo some misc cleanup of the parser:\n- Method and parameter parsing is refactored.\n- A parser for `const | mut` is introduced that https://github.com/rust-lang/rust/pull/64588 can reuse.\n- Some other misc parsing.\n\nNext up in a different PR:\n- ~Implementing https://github.com/rust-lang/rust/issues/64252.~ -- maybe some other time...\n- Heavily restructuring up `item.rs` which is a mess (hopefully, no promises ^^).\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db9689333a2b52af4dffde750e7055cf6badb576", "html_url": "https://github.com/rust-lang/rust/commit/db9689333a2b52af4dffde750e7055cf6badb576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db9689333a2b52af4dffde750e7055cf6badb576/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69028ae85bd6f54fed4c6e97f430db1138b986eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/69028ae85bd6f54fed4c6e97f430db1138b986eb", "html_url": "https://github.com/rust-lang/rust/commit/69028ae85bd6f54fed4c6e97f430db1138b986eb"}, {"sha": "5c5dd8069d0aeeb97ef6b6099767f97aec1edee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c5dd8069d0aeeb97ef6b6099767f97aec1edee4", "html_url": "https://github.com/rust-lang/rust/commit/5c5dd8069d0aeeb97ef6b6099767f97aec1edee4"}], "stats": {"total": 1070, "additions": 501, "deletions": 569}, "files": [{"sha": "e8d7b7663ed5211a99390aa9826006f3acfaa589", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=db9689333a2b52af4dffde750e7055cf6badb576", "patch": "@@ -1180,7 +1180,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn expected_semi_or_open_brace(&mut self) -> PResult<'a, ast::TraitItem> {\n+    crate fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n         let token_str = self.this_token_descr();\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n         err.span_label(self.token.span, \"expected `;` or `{`\");"}, {"sha": "95f84d5cb3314ebe2120ccb8c7bca5d369938cfc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 330, "deletions": 325, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=db9689333a2b52af4dffde750e7055cf6badb576", "patch": "@@ -511,13 +511,15 @@ impl<'a> Parser<'a> {\n         is_present\n     }\n \n+    /// If the next token is the given keyword, returns `true` without eating it.\n+    /// An expectation is also added for diagnostics purposes.\n     fn check_keyword(&mut self, kw: Symbol) -> bool {\n         self.expected_tokens.push(TokenType::Keyword(kw));\n         self.token.is_keyword(kw)\n     }\n \n-    /// If the next token is the given keyword, eats it and returns\n-    /// `true`. Otherwise, returns `false`.\n+    /// If the next token is the given keyword, eats it and returns `true`.\n+    /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.\n     pub fn eat_keyword(&mut self, kw: Symbol) -> bool {\n         if self.check_keyword(kw) {\n             self.bump();\n@@ -547,40 +549,38 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn check_ident(&mut self) -> bool {\n-        if self.token.is_ident() {\n+    fn check_or_expected(&mut self, ok: bool, typ: TokenType) -> bool {\n+        if ok {\n             true\n         } else {\n-            self.expected_tokens.push(TokenType::Ident);\n+            self.expected_tokens.push(typ);\n             false\n         }\n     }\n \n+    crate fn check_ident(&mut self) -> bool {\n+        self.check_or_expected(self.token.is_ident(), TokenType::Ident)\n+    }\n+\n     fn check_path(&mut self) -> bool {\n-        if self.token.is_path_start() {\n-            true\n-        } else {\n-            self.expected_tokens.push(TokenType::Path);\n-            false\n-        }\n+        self.check_or_expected(self.token.is_path_start(), TokenType::Path)\n     }\n \n     fn check_type(&mut self) -> bool {\n-        if self.token.can_begin_type() {\n-            true\n-        } else {\n-            self.expected_tokens.push(TokenType::Type);\n-            false\n-        }\n+        self.check_or_expected(self.token.can_begin_type(), TokenType::Type)\n     }\n \n     fn check_const_arg(&mut self) -> bool {\n-        if self.token.can_begin_const_arg() {\n-            true\n-        } else {\n-            self.expected_tokens.push(TokenType::Const);\n-            false\n-        }\n+        self.check_or_expected(self.token.can_begin_const_arg(), TokenType::Const)\n+    }\n+\n+    /// Checks to see if the next token is either `+` or `+=`.\n+    /// Otherwise returns `false`.\n+    fn check_plus(&mut self) -> bool {\n+        self.check_or_expected(\n+            self.token.is_like_plus(),\n+            TokenType::Token(token::BinOp(token::Plus)),\n+        )\n     }\n \n     /// Expects and consumes a `+`. if `+=` is seen, replaces it with a `=`\n@@ -604,18 +604,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Checks to see if the next token is either `+` or `+=`.\n-    /// Otherwise returns `false`.\n-    fn check_plus(&mut self) -> bool {\n-        if self.token.is_like_plus() {\n-            true\n-        }\n-        else {\n-            self.expected_tokens.push(TokenType::Token(token::BinOp(token::Plus)));\n-            false\n-        }\n-    }\n-\n     /// Expects and consumes an `&`. If `&&` is seen, replaces it with a single\n     /// `&` and continues. If an `&` is not seen, signals an error.\n     fn expect_and(&mut self) -> PResult<'a, ()> {\n@@ -910,15 +898,15 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.clear();\n     }\n \n-    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where\n-        F: FnOnce(&Token) -> R,\n-    {\n+    /// Look-ahead `dist` tokens of `self.token` and get access to that token there.\n+    /// When `dist == 0` then the current token is looked at.\n+    pub fn look_ahead<R>(&self, dist: usize, looker: impl FnOnce(&Token) -> R) -> R {\n         if dist == 0 {\n-            return f(&self.token);\n+            return looker(&self.token);\n         }\n \n         let frame = &self.token_cursor.frame;\n-        f(&match frame.tree_cursor.look_ahead(dist - 1) {\n+        looker(&match frame.tree_cursor.look_ahead(dist - 1) {\n             Some(tree) => match tree {\n                 TokenTree::Token(token) => token,\n                 TokenTree::Delimited(dspan, delim, _) =>\n@@ -954,109 +942,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_named_argument(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n-                _ => 0,\n-            }\n-            token::BinOp(token::And) | token::AndAnd => 1,\n-            _ if self.token.is_keyword(kw::Mut) => 1,\n-            _ => 0,\n-        };\n-\n-        self.look_ahead(offset, |t| t.is_ident()) &&\n-        self.look_ahead(offset + 1, |t| t == &token::Colon)\n-    }\n-\n-    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n-    /// error.\n-    /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(\n-        &mut self,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n-        allow_c_variadic: bool,\n-        is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Param> {\n-        let lo = self.token.span;\n-        let attrs = self.parse_outer_attributes()?;\n-\n-        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n-        if let Some(mut param) = self.parse_self_param()? {\n-            param.attrs = attrs.into();\n-            return if is_self_allowed {\n-                Ok(param)\n-            } else {\n-                self.recover_bad_self_param(param, is_trait_item)\n-            };\n-        }\n-\n-        let is_name_required = is_name_required(&self.token);\n-        let (pat, ty) = if is_name_required || self.is_named_argument() {\n-            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n-\n-            let pat = self.parse_fn_param_pat()?;\n-            if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.parameter_without_type(\n-                    &mut err,\n-                    pat,\n-                    is_name_required,\n-                    is_trait_item,\n-                ) {\n-                    err.emit();\n-                    return Ok(dummy_arg(ident));\n-                } else {\n-                    return Err(err);\n-                }\n-            }\n-\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n-        } else {\n-            debug!(\"parse_param_general ident_to_pat\");\n-            let parser_snapshot_before_ty = self.clone();\n-            self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n-            if ty.is_ok() && self.token != token::Comma &&\n-               self.token != token::CloseDelim(token::Paren) {\n-                // This wasn't actually a type, but a pattern looking like a type,\n-                // so we are going to rollback and re-parse for recovery.\n-                ty = self.unexpected();\n-            }\n-            match ty {\n-                Ok(ty) => {\n-                    let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n-                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n-                    (pat, ty)\n-                }\n-                Err(mut err) => {\n-                    // If this is a C-variadic argument and we hit an error, return the\n-                    // error.\n-                    if self.token == token::DotDotDot {\n-                        return Err(err);\n-                    }\n-                    // Recover from attempting to parse the argument as a type without pattern.\n-                    err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n-                    self.recover_arg_parse()?\n-                }\n-            }\n-        };\n-\n-        let span = lo.to(self.token.span);\n-\n-        Ok(Param {\n-            attrs: attrs.into(),\n-            id: ast::DUMMY_NODE_ID,\n-            is_placeholder: false,\n-            pat,\n-            span,\n-            ty,\n-        })\n-    }\n-\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) {\n@@ -1066,6 +951,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Possibly parses mutability (`const` or `mut`).\n+    fn parse_const_or_mut(&mut self) -> Option<Mutability> {\n+        if self.eat_keyword(kw::Mut) {\n+            Some(Mutability::Mutable)\n+        } else if self.eat_keyword(kw::Const) {\n+            Some(Mutability::Immutable)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n         if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) =\n                 self.token.kind {\n@@ -1100,9 +996,10 @@ impl<'a> Parser<'a> {\n         Ok((delim, tts.into()))\n     }\n \n-    fn parse_or_use_outer_attributes(&mut self,\n-                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                                     -> PResult<'a, ThinVec<Attribute>> {\n+    fn parse_or_use_outer_attributes(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, ThinVec<Attribute>> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {\n@@ -1189,53 +1086,52 @@ impl<'a> Parser<'a> {\n     /// Evaluates the closure with restrictions in place.\n     ///\n     /// Afters the closure is evaluated, restrictions are reset.\n-    fn with_res<F, T>(&mut self, r: Restrictions, f: F) -> T\n-        where F: FnOnce(&mut Self) -> T\n-    {\n+    fn with_res<T>(&mut self, res: Restrictions, f: impl FnOnce(&mut Self) -> T) -> T {\n         let old = self.restrictions;\n-        self.restrictions = r;\n-        let r = f(self);\n+        self.restrictions = res;\n+        let res = f(self);\n         self.restrictions = old;\n-        return r;\n-\n+        res\n     }\n \n-    fn parse_fn_params(&mut self, named_params: bool, allow_c_variadic: bool)\n-                     -> PResult<'a, Vec<Param>> {\n+    fn parse_fn_params(\n+        &mut self,\n+        named_params: bool,\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, Vec<Param>> {\n         let sp = self.token.span;\n+        let do_not_enforce_named_params_for_c_variadic = |token: &token::Token| {\n+            match token.kind {\n+                token::DotDotDot => false,\n+                _ => named_params,\n+            }\n+        };\n         let mut c_variadic = false;\n-        let (params, _): (Vec<Option<Param>>, _) = self.parse_paren_comma_seq(|p| {\n-            let do_not_enforce_named_arguments_for_c_variadic =\n-                |token: &token::Token| -> bool {\n-                    if token == &token::DotDotDot {\n-                        false\n-                    } else {\n-                        named_params\n-                    }\n-                };\n+        let (params, _) = self.parse_paren_comma_seq(|p| {\n             match p.parse_param_general(\n                 false,\n                 false,\n                 allow_c_variadic,\n-                do_not_enforce_named_arguments_for_c_variadic\n+                do_not_enforce_named_params_for_c_variadic,\n             ) {\n-                Ok(param) => {\n+                Ok(param) => Ok(\n                     if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n                         if p.token != token::CloseDelim(token::Paren) {\n-                            let span = p.token.span;\n-                            p.span_err(span,\n-                                \"`...` must be the last argument of a C-variadic function\");\n+                            p.span_err(\n+                                p.token.span,\n+                                \"`...` must be the last argument of a C-variadic function\",\n+                            );\n                             // FIXME(eddyb) this should probably still push `CVarArgs`.\n                             // Maybe AST validation/HIR lowering should emit the above error?\n-                            Ok(None)\n+                            None\n                         } else {\n-                            Ok(Some(param))\n+                            Some(param)\n                         }\n                     } else {\n-                        Ok(Some(param))\n+                        Some(param)\n                     }\n-                },\n+                ),\n                 Err(mut e) => {\n                     e.emit();\n                     let lo = p.prev_span;\n@@ -1251,26 +1147,169 @@ impl<'a> Parser<'a> {\n         let params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n \n         if c_variadic && params.len() <= 1 {\n-            self.span_err(sp,\n-                          \"C-variadic function must be declared with at least one named argument\");\n+            self.span_err(\n+                sp,\n+                \"C-variadic function must be declared with at least one named argument\",\n+            );\n         }\n \n         Ok(params)\n     }\n \n+    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n+    fn parse_fn_decl_with_self(\n+        &mut self,\n+        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n+        // Parse the arguments, starting out with `self` being allowed...\n+        let mut is_self_allowed = true;\n+        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n+            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n+            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n+            is_self_allowed = false;\n+            res\n+        })?;\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut inputs);\n+\n+        Ok(P(FnDecl {\n+            inputs,\n+            output: self.parse_ret_ty(true)?,\n+        }))\n+    }\n+\n+    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n+    /// error.\n+    /// This version of parse param doesn't necessarily require identifier names.\n+    fn parse_param_general(\n+        &mut self,\n+        is_self_allowed: bool,\n+        is_trait_item: bool,\n+        allow_c_variadic: bool,\n+        is_name_required: impl Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, Param> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_outer_attributes()?;\n+\n+        // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n+        if let Some(mut param) = self.parse_self_param()? {\n+            param.attrs = attrs.into();\n+            return if is_self_allowed {\n+                Ok(param)\n+            } else {\n+                self.recover_bad_self_param(param, is_trait_item)\n+            };\n+        }\n+\n+        let is_name_required = is_name_required(&self.token);\n+        let (pat, ty) = if is_name_required || self.is_named_param() {\n+            debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n+\n+            let pat = self.parse_fn_param_pat()?;\n+            if let Err(mut err) = self.expect(&token::Colon) {\n+                if let Some(ident) = self.parameter_without_type(\n+                    &mut err,\n+                    pat,\n+                    is_name_required,\n+                    is_trait_item,\n+                ) {\n+                    err.emit();\n+                    return Ok(dummy_arg(ident));\n+                } else {\n+                    return Err(err);\n+                }\n+            }\n+\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n+        } else {\n+            debug!(\"parse_param_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            self.eat_incorrect_doc_comment_for_param_type();\n+            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n+            if ty.is_ok() && self.token != token::Comma &&\n+               self.token != token::CloseDelim(token::Paren) {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(kw::Invalid, self.prev_span);\n+                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let pat = self.mk_pat_ident(ty.span, bm, ident);\n+                    (pat, ty)\n+                }\n+                // If this is a C-variadic argument and we hit an error, return the error.\n+                Err(err) if self.token == token::DotDotDot => return Err(err),\n+                // Recover from attempting to parse the argument as a type without pattern.\n+                Err(mut err) => {\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    self.recover_arg_parse()?\n+                }\n+            }\n+        };\n+\n+        let span = lo.to(self.token.span);\n+\n+        Ok(Param {\n+            attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n+            is_placeholder: false,\n+            pat,\n+            span,\n+            ty,\n+        })\n+    }\n+\n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n     ///\n     /// See `parse_self_param_with_attrs` to collect attributes.\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n-        let expect_ident = |this: &mut Self| match this.token.kind {\n-            // Preserve hygienic context.\n-            token::Ident(name, _) =>\n-                { let span = this.token.span; this.bump(); Ident::new(name, span) }\n-            _ => unreachable!()\n+        // Extract an identifier *after* having confirmed that the token is one.\n+        let expect_self_ident = |this: &mut Self| {\n+            match this.token.kind {\n+                // Preserve hygienic context.\n+                token::Ident(name, _) => {\n+                    let span = this.token.span;\n+                    this.bump();\n+                    Ident::new(name, span)\n+                }\n+                _ => unreachable!(),\n+            }\n+        };\n+        // Is `self` `n` tokens ahead?\n+        let is_isolated_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::SelfLower])\n+            && this.look_ahead(n + 1, |t| t != &token::ModSep)\n         };\n-        let isolated_self = |this: &mut Self, n| {\n-            this.look_ahead(n, |t| t.is_keyword(kw::SelfLower)) &&\n-            this.look_ahead(n + 1, |t| t != &token::ModSep)\n+        // Is `mut self` `n` tokens ahead?\n+        let is_isolated_mut_self = |this: &Self, n| {\n+            this.is_keyword_ahead(n, &[kw::Mut])\n+            && is_isolated_self(this, n + 1)\n+        };\n+        // Parse `self` or `self: TYPE`. We already know the current token is `self`.\n+        let parse_self_possibly_typed = |this: &mut Self, m| {\n+            let eself_ident = expect_self_ident(this);\n+            let eself_hi = this.prev_span;\n+            let eself = if this.eat(&token::Colon) {\n+                SelfKind::Explicit(this.parse_ty()?, m)\n+            } else {\n+                SelfKind::Value(m)\n+            };\n+            Ok((eself, eself_ident, eself_hi))\n+        };\n+        // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n+        let recover_self_ptr = |this: &mut Self| {\n+            let msg = \"cannot pass `self` by raw pointer\";\n+            let span = this.token.span;\n+            this.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .emit();\n+\n+            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n         };\n \n         // Parse optional `self` parameter of a method.\n@@ -1279,88 +1318,54 @@ impl<'a> Parser<'a> {\n         let eself_lo = self.token.span;\n         let (eself, eself_ident, eself_hi) = match self.token.kind {\n             token::BinOp(token::And) => {\n-                // `&self`\n-                // `&mut self`\n-                // `&'lt self`\n-                // `&'lt mut self`\n-                // `&not_self`\n-                (if isolated_self(self, 1) {\n+                let eself = if is_isolated_self(self, 1) {\n+                    // `&self`\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.is_keyword_ahead(1, &[kw::Mut]) &&\n-                          isolated_self(self, 2) {\n+                } else if is_isolated_mut_self(self, 1) {\n+                    // `&mut self`\n                     self.bump();\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Mutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          isolated_self(self, 2) {\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n+                    // `&'lt self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          self.is_keyword_ahead(2, &[kw::Mut]) &&\n-                          isolated_self(self, 3) {\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n+                    // `&'lt mut self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     self.bump();\n                     SelfKind::Region(Some(lt), Mutability::Mutable)\n                 } else {\n+                    // `&not_self`\n                     return Ok(None);\n-                }, expect_ident(self), self.prev_span)\n+                };\n+                (eself, expect_self_ident(self), self.prev_span)\n             }\n-            token::BinOp(token::Star) => {\n-                // `*self`\n-                // `*const self`\n-                // `*mut self`\n-                // `*not_self`\n-                // Emit special error for `self` cases.\n-                let msg = \"cannot pass `self` by raw pointer\";\n-                (if isolated_self(self, 1) {\n-                    self.bump();\n-                    self.struct_span_err(self.token.span, msg)\n-                        .span_label(self.token.span, msg)\n-                        .emit();\n-                    SelfKind::Value(Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_mutability()) &&\n-                          isolated_self(self, 2) {\n-                    self.bump();\n-                    self.bump();\n-                    self.struct_span_err(self.token.span, msg)\n-                        .span_label(self.token.span, msg)\n-                        .emit();\n-                    SelfKind::Value(Mutability::Immutable)\n-                } else {\n-                    return Ok(None);\n-                }, expect_ident(self), self.prev_span)\n+            // `*self`\n+            token::BinOp(token::Star) if is_isolated_self(self, 1) => {\n+                self.bump();\n+                recover_self_ptr(self)?\n             }\n-            token::Ident(..) => {\n-                if isolated_self(self, 0) {\n-                    // `self`\n-                    // `self: TYPE`\n-                    let eself_ident = expect_ident(self);\n-                    let eself_hi = self.prev_span;\n-                    (if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty()?;\n-                        SelfKind::Explicit(ty, Mutability::Immutable)\n-                    } else {\n-                        SelfKind::Value(Mutability::Immutable)\n-                    }, eself_ident, eself_hi)\n-                } else if self.token.is_keyword(kw::Mut) &&\n-                          isolated_self(self, 1) {\n-                    // `mut self`\n-                    // `mut self: TYPE`\n-                    self.bump();\n-                    let eself_ident = expect_ident(self);\n-                    let eself_hi = self.prev_span;\n-                    (if self.eat(&token::Colon) {\n-                        let ty = self.parse_ty()?;\n-                        SelfKind::Explicit(ty, Mutability::Mutable)\n-                    } else {\n-                        SelfKind::Value(Mutability::Mutable)\n-                    }, eself_ident, eself_hi)\n-                } else {\n-                    return Ok(None);\n-                }\n+            // `*mut self` and `*const self`\n+            token::BinOp(token::Star) if\n+                self.look_ahead(1, |t| t.is_mutability())\n+                && is_isolated_self(self, 2) =>\n+            {\n+                self.bump();\n+                self.bump();\n+                recover_self_ptr(self)?\n+            }\n+            // `self` and `self: TYPE`\n+            token::Ident(..) if is_isolated_self(self, 0) => {\n+                parse_self_possibly_typed(self, Mutability::Immutable)?\n+            }\n+            // `mut self` and `mut self: TYPE`\n+            token::Ident(..) if is_isolated_mut_self(self, 0) => {\n+                self.bump();\n+                parse_self_possibly_typed(self, Mutability::Mutable)?\n             }\n             _ => return Ok(None),\n         };\n@@ -1369,27 +1374,19 @@ impl<'a> Parser<'a> {\n         Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n     }\n \n-    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self(\n-        &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        // Parse the arguments, starting out with `self` being allowed...\n-        let mut is_self_allowed = true;\n-        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n-            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n-            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n-            is_self_allowed = false;\n-            res\n-        })?;\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut inputs);\n+    fn is_named_param(&self) -> bool {\n+        let offset = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n+                _ => 0,\n+            }\n+            token::BinOp(token::And) | token::AndAnd => 1,\n+            _ if self.token.is_keyword(kw::Mut) => 1,\n+            _ => 0,\n+        };\n \n-        Ok(P(FnDecl {\n-            inputs,\n-            output: self.parse_ret_ty(true)?,\n-        }))\n+        self.look_ahead(offset, |t| t.is_ident()) &&\n+        self.look_ahead(offset + 1, |t| t == &token::Colon)\n     }\n \n     fn is_crate_vis(&self) -> bool {\n@@ -1423,100 +1420,107 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.is_keyword_ahead(1, &[kw::Crate]) &&\n-                self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n+            if self.is_keyword_ahead(1, &[kw::Crate])\n+                && self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n-                // `pub(crate)`\n+                // Parse `pub(crate)`.\n                 self.bump(); // `(`\n                 self.bump(); // `crate`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(\n-                    lo.to(self.prev_span),\n-                    VisibilityKind::Crate(CrateSugar::PubCrate),\n-                );\n-                return Ok(vis)\n+                let vis = VisibilityKind::Crate(CrateSugar::PubCrate);\n+                return Ok(respan(lo.to(self.prev_span), vis));\n             } else if self.is_keyword_ahead(1, &[kw::In]) {\n-                // `pub(in path)`\n+                // Parse `pub(in path)`.\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?; // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+                let vis = VisibilityKind::Restricted {\n                     path: P(path),\n                     id: ast::DUMMY_NODE_ID,\n-                });\n-                return Ok(vis)\n-            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n+                };\n+                return Ok(respan(lo.to(self.prev_span), vis));\n+            } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren))\n+                && self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n-                // `pub(self)` or `pub(super)`\n+                // Parse `pub(self)` or `pub(super)`.\n                 self.bump(); // `(`\n                 let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n-                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+                let vis = VisibilityKind::Restricted {\n                     path: P(path),\n                     id: ast::DUMMY_NODE_ID,\n-                });\n-                return Ok(vis)\n-            } else if !can_take_tuple {  // Provide this diagnostic if this is not a tuple struct\n-                // `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n-                self.bump(); // `(`\n-                let msg = \"incorrect visibility restriction\";\n-                let suggestion = r##\"some possible visibility restrictions are:\n-`pub(crate)`: visible only on the current crate\n-`pub(super)`: visible only in the current module's parent\n-`pub(in path::to::module)`: visible only on the specified path\"##;\n-                let path = self.parse_path(PathStyle::Mod)?;\n-                let sp = path.span;\n-                let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n-                self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg)\n-                    .help(suggestion)\n-                    .span_suggestion(\n-                        sp,\n-                        &help_msg,\n-                        format!(\"in {}\", path),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit(); // Emit diagnostic, but continue with public visibility.\n+                };\n+                return Ok(respan(lo.to(self.prev_span), vis));\n+            } else if !can_take_tuple { // Provide this diagnostic if this is not a tuple struct.\n+                self.recover_incorrect_vis_restriction()?;\n+                // Emit diagnostic, but continue with public visibility.\n             }\n         }\n \n         Ok(respan(lo, VisibilityKind::Public))\n     }\n \n+    /// Recovery for e.g. `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n+    fn recover_incorrect_vis_restriction(&mut self) -> PResult<'a, ()> {\n+        self.bump(); // `(`\n+        let path = self.parse_path(PathStyle::Mod)?;\n+        self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n+\n+        let msg = \"incorrect visibility restriction\";\n+        let suggestion = r##\"some possible visibility restrictions are:\n+`pub(crate)`: visible only on the current crate\n+`pub(super)`: visible only in the current module's parent\n+`pub(in path::to::module)`: visible only on the specified path\"##;\n+\n+        struct_span_err!(self.sess.span_diagnostic, path.span, E0704, \"{}\", msg)\n+            .help(suggestion)\n+            .span_suggestion(\n+                path.span,\n+                &format!(\"make this visible only to module `{}` with `in`\", path),\n+                format!(\"in {}\", path),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+\n+        Ok(())\n+    }\n+\n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n     /// the `extern` keyword, if one is found.\n     fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n         match self.token.kind {\n             token::Literal(token::Lit { kind: token::Str, symbol, suffix }) |\n             token::Literal(token::Lit { kind: token::StrRaw(..), symbol, suffix }) => {\n-                let sp = self.token.span;\n-                self.expect_no_suffix(sp, \"an ABI spec\", suffix);\n+                self.expect_no_suffix(self.token.span, \"an ABI spec\", suffix);\n                 self.bump();\n                 match abi::lookup(&symbol.as_str()) {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n-                        let prev_span = self.prev_span;\n-                        struct_span_err!(\n-                            self.sess.span_diagnostic,\n-                            prev_span,\n-                            E0703,\n-                            \"invalid ABI: found `{}`\",\n-                            symbol\n-                        )\n-                        .span_label(prev_span, \"invalid ABI\")\n-                        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-                        .emit();\n+                        self.error_on_invalid_abi(symbol);\n                         Ok(None)\n                     }\n                 }\n             }\n-\n             _ => Ok(None),\n         }\n     }\n \n+    /// Emit an error where `symbol` is an invalid ABI.\n+    fn error_on_invalid_abi(&self, symbol: Symbol) {\n+        let prev_span = self.prev_span;\n+        struct_span_err!(\n+            self.sess.span_diagnostic,\n+            prev_span,\n+            E0703,\n+            \"invalid ABI: found `{}`\",\n+            symbol\n+        )\n+        .span_label(prev_span, \"invalid ABI\")\n+        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+        .emit();\n+    }\n+\n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error.\n     fn ban_async_in_2015(&self, async_span: Span) {\n         if async_span.rust_2015() {\n@@ -1530,9 +1534,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n-        where F: FnOnce(&mut Self) -> PResult<'a, R>\n-    {\n+    fn collect_tokens<R>(\n+        &mut self,\n+        f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n+    ) -> PResult<'a, (R, TokenStream)> {\n         // Record all tokens we parse when parsing this item.\n         let mut tokens = Vec::new();\n         let prev_collecting = match self.token_cursor.frame.last_token {"}, {"sha": "c00a5807d52c5d56a125715f45eace6b4adc33b8", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 162, "deletions": 231, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=db9689333a2b52af4dffde750e7055cf6badb576", "patch": "@@ -7,7 +7,7 @@ use crate::ast::{\n     Item, ItemKind, ImplItem, TraitItem, TraitItemKind,\n     UseTree, UseTreeKind, PathSegment,\n     IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n-    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader,\n+    Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n     ForeignItem, ForeignItemKind,\n     Ty, TyKind, Generics, GenericBounds, TraitRef,\n     EnumDef, VariantData, StructField, AnonConst,\n@@ -18,7 +18,7 @@ use crate::parse::token;\n use crate::parse::parser::maybe_append;\n use crate::parse::diagnostics::Error;\n use crate::tokenstream::{TokenTree, TokenStream};\n-use crate::source_map::{respan, Span, Spanned};\n+use crate::source_map::{respan, Span};\n use crate::symbol::{kw, sym};\n \n use std::mem;\n@@ -122,19 +122,13 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM\n                 let fn_span = self.prev_span;\n-                let abi = opt_abi.unwrap_or(Abi::C);\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(Unsafety::Normal,\n-                                       respan(fn_span, IsAsync::NotAsync),\n-                                       respan(fn_span, Constness::NotConst),\n-                                       abi)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                return Ok(Some(item));\n+                let header = FnHeader {\n+                    unsafety: Unsafety::Normal,\n+                    asyncness: respan(fn_span, IsAsync::NotAsync),\n+                    constness: respan(fn_span, Constness::NotConst),\n+                    abi: opt_abi.unwrap_or(Abi::C),\n+                };\n+                return self.parse_item_fn(lo, visibility, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return Ok(Some(\n                     self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n@@ -149,13 +143,9 @@ impl<'a> Parser<'a> {\n             // STATIC ITEM\n             let m = self.parse_mutability();\n             let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.eat_keyword(kw::Const) {\n             let const_span = self.prev_span;\n@@ -165,18 +155,13 @@ impl<'a> Parser<'a> {\n                 // CONST FUNCTION ITEM\n                 let unsafety = self.parse_unsafety();\n                 self.bump();\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety,\n-                                       respan(const_span, IsAsync::NotAsync),\n-                                       respan(const_span, Constness::Const),\n-                                       Abi::Rust)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n-                return Ok(Some(item));\n+                let header = FnHeader {\n+                    unsafety,\n+                    asyncness: respan(const_span, IsAsync::NotAsync),\n+                    constness: respan(const_span, Constness::Const),\n+                    abi: Abi::Rust,\n+                };\n+                return self.parse_item_fn(lo, visibility, attrs, header);\n             }\n \n             // CONST ITEM\n@@ -193,13 +178,9 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n \n         // Parses `async unsafe? fn`.\n@@ -213,22 +194,18 @@ impl<'a> Parser<'a> {\n                 let unsafety = self.parse_unsafety(); // `unsafe`?\n                 self.expect_keyword(kw::Fn)?; // `fn`\n                 let fn_span = self.prev_span;\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(unsafety,\n-                                    respan(async_span, IsAsync::Async {\n-                                        closure_id: DUMMY_NODE_ID,\n-                                        return_impl_trait_id: DUMMY_NODE_ID,\n-                                    }),\n-                                    respan(fn_span, Constness::NotConst),\n-                                    Abi::Rust)?;\n-                let prev_span = self.prev_span;\n-                let item = self.mk_item(lo.to(prev_span),\n-                                        ident,\n-                                        item_,\n-                                        visibility,\n-                                        maybe_append(attrs, extra_attrs));\n+                let asyncness = respan(async_span, IsAsync::Async {\n+                    closure_id: DUMMY_NODE_ID,\n+                    return_impl_trait_id: DUMMY_NODE_ID,\n+                });\n                 self.ban_async_in_2015(async_span);\n-                return Ok(Some(item));\n+                let header = FnHeader {\n+                    unsafety,\n+                    asyncness,\n+                    constness: respan(fn_span, Constness::NotConst),\n+                    abi: Abi::Rust,\n+                };\n+                return self.parse_item_fn(lo, visibility, attrs, header);\n             }\n         }\n         if self.check_keyword(kw::Unsafe) &&\n@@ -243,15 +220,10 @@ impl<'a> Parser<'a> {\n                 self.expect_keyword(kw::Trait)?;\n                 IsAuto::Yes\n             };\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n@@ -262,27 +234,22 @@ impl<'a> Parser<'a> {\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n+            let (ident, item_, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n             let span = lo.to(self.prev_span);\n-            return Ok(Some(self.mk_item(span, ident, item, visibility,\n-                                        maybe_append(attrs, extra_attrs))));\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.check_keyword(kw::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n             let fn_span = self.prev_span;\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Normal,\n-                                   respan(fn_span, IsAsync::NotAsync),\n-                                   respan(fn_span, Constness::NotConst),\n-                                   Abi::Rust)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let header = FnHeader {\n+                unsafety: Unsafety::Normal,\n+                asyncness: respan(fn_span, IsAsync::NotAsync),\n+                constness: respan(fn_span, Constness::NotConst),\n+                abi: Abi::Rust,\n+            };\n+            return self.parse_item_fn(lo, visibility, attrs, header);\n         }\n         if self.check_keyword(kw::Unsafe)\n             && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n@@ -297,30 +264,20 @@ impl<'a> Parser<'a> {\n             };\n             self.expect_keyword(kw::Fn)?;\n             let fn_span = self.prev_span;\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(Unsafety::Unsafe,\n-                                   respan(fn_span, IsAsync::NotAsync),\n-                                   respan(fn_span, Constness::NotConst),\n-                                   abi)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let header = FnHeader {\n+                unsafety: Unsafety::Unsafe,\n+                asyncness: respan(fn_span, IsAsync::NotAsync),\n+                constness: respan(fn_span, Constness::NotConst),\n+                abi,\n+            };\n+            return self.parse_item_fn(lo, visibility, attrs, header);\n         }\n         if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(&attrs[..])?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item_, extra_attrs) = self.parse_item_mod(&attrs[..])?;\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if let Some(type_) = self.eat_type() {\n             let (ident, alias, generics) = type_?;\n@@ -329,24 +286,15 @@ impl<'a> Parser<'a> {\n                 AliasKind::Weak(ty) => ItemKind::TyAlias(ty, generics),\n                 AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n             };\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n@@ -360,38 +308,25 @@ impl<'a> Parser<'a> {\n                 IsAuto::Yes\n             };\n             // TRAIT ITEM\n-            let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, Unsafety::Normal)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Normal)?;\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if self.is_union_item() {\n             // UNION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_union()?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let span = lo.to(self.prev_span);\n+            let attrs = maybe_append(attrs, extra_attrs);\n+            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n         }\n         if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n             return Ok(Some(macro_def));\n@@ -848,29 +783,37 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n-                         -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n+    fn parse_impl_method(\n+        &mut self,\n+        vis: &Visibility,\n+        at_end: &mut bool\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n         // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n-            Ok((Ident::invalid(), vec![], Generics::default(),\n-                ast::ImplItemKind::Macro(mac)))\n+            Ok((Ident::invalid(), vec![], Generics::default(), ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-            let decl = self.parse_fn_decl_with_self(|_| true)?;\n-            generics.where_clause = self.parse_where_clause()?;\n+            let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n-                ast::MethodSig { header, decl },\n-                body\n-            )))\n+            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n         }\n     }\n \n+    /// Parse the \"signature\", including the identifier, parameters, and generics\n+    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n+    fn parse_method_sig(\n+        &mut self,\n+        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let (ident, mut generics) = self.parse_fn_header()?;\n+        let decl = self.parse_fn_decl_with_self(is_name_required)?;\n+        let sig = MethodSig { header, decl };\n+        generics.where_clause = self.parse_where_clause()?;\n+        Ok((ident, sig, generics))\n+    }\n+\n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n     /// and including the `fn` keyword:\n     ///\n@@ -879,14 +822,7 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc.\n-    fn parse_fn_front_matter(&mut self)\n-        -> PResult<'a, (\n-            Spanned<Constness>,\n-            Unsafety,\n-            Spanned<IsAsync>,\n-            Abi\n-        )>\n-    {\n+    fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n         let is_const_fn = self.eat_keyword(kw::Const);\n         let const_span = self.prev_span;\n         let asyncness = self.parse_asyncness();\n@@ -911,7 +847,7 @@ impl<'a> Parser<'a> {\n             // account for this.\n             if !self.expect_one_of(&[], &[])? { unreachable!() }\n         }\n-        Ok((constness, unsafety, asyncness, abi))\n+        Ok(FnHeader { constness, unsafety, asyncness, abi })\n     }\n \n     /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n@@ -1025,59 +961,12 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (Ident::invalid(), ast::TraitItemKind::Macro(mac), Generics::default())\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n-\n-            let ident = self.parse_ident()?;\n-            let mut generics = self.parse_generics()?;\n-\n             // This is somewhat dubious; We don't want to allow\n             // argument names to be left off if there is a definition...\n             //\n             // We don't allow argument names to be left off in edition 2018.\n-            let decl = self.parse_fn_decl_with_self(|t| t.span.rust_2018())?;\n-            generics.where_clause = self.parse_where_clause()?;\n-\n-            let sig = ast::MethodSig {\n-                header: FnHeader {\n-                    unsafety,\n-                    constness,\n-                    abi,\n-                    asyncness,\n-                },\n-                decl,\n-            };\n-\n-            let body = match self.token.kind {\n-                token::Semi => {\n-                    self.bump();\n-                    *at_end = true;\n-                    debug!(\"parse_trait_methods(): parsing required method\");\n-                    None\n-                }\n-                token::OpenDelim(token::Brace) => {\n-                    debug!(\"parse_trait_methods(): parsing provided method\");\n-                    *at_end = true;\n-                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n-                }\n-                token::Interpolated(ref nt) => {\n-                    match **nt {\n-                        token::NtBlock(..) => {\n-                            *at_end = true;\n-                            let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-                            attrs.extend(inner_attrs.iter().cloned());\n-                            Some(body)\n-                        }\n-                        _ => {\n-                            return self.expected_semi_or_open_brace();\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    return self.expected_semi_or_open_brace();\n-                }\n-            };\n+            let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n+            let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n             (ident, ast::TraitItemKind::Method(sig, body), generics)\n         };\n \n@@ -1092,6 +981,43 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parse the \"body\" of a method in a trait item definition.\n+    /// This can either be `;` when there's no body,\n+    /// or e.g. a block when the method is a provided one.\n+    fn parse_trait_method_body(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+    ) -> PResult<'a, Option<P<Block>>> {\n+        Ok(match self.token.kind {\n+            token::Semi => {\n+                debug!(\"parse_trait_method_body(): parsing required method\");\n+                self.bump();\n+                *at_end = true;\n+                None\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                *at_end = true;\n+                let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                attrs.extend(inner_attrs.iter().cloned());\n+                Some(body)\n+            }\n+            token::Interpolated(ref nt) => {\n+                match **nt {\n+                    token::NtBlock(..) => {\n+                        *at_end = true;\n+                        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n+                    _ => return self.expected_semi_or_open_brace(),\n+                }\n+            }\n+            _ => return self.expected_semi_or_open_brace(),\n+        })\n+    }\n+\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n@@ -1261,18 +1187,29 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(\n         &mut self,\n-        unsafety: Unsafety,\n-        asyncness: Spanned<IsAsync>,\n-        constness: Spanned<Constness>,\n-        abi: Abi\n-    ) -> PResult<'a, ItemInfo> {\n+        lo: Span,\n+        vis: Visibility,\n+        attrs: Vec<Attribute>,\n+        header: FnHeader,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let allow_c_variadic = header.abi == Abi::C && header.unsafety == Unsafety::Unsafe;\n+        let (ident, decl, generics) = self.parse_fn_sig(allow_c_variadic)?;\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        let span = lo.to(self.prev_span);\n+        let kind = ItemKind::Fn(decl, header, generics, body);\n+        let attrs = maybe_append(attrs, Some(inner_attrs));\n+        Ok(Some(self.mk_item(span, ident, kind, vis, attrs)))\n+    }\n+\n+    /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n+    fn parse_fn_sig(\n+        &mut self,\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n-        let allow_c_variadic = abi == Abi::C && unsafety == Unsafety::Unsafe;\n         let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let header = FnHeader { unsafety, asyncness, constness, abi };\n-        Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n+        Ok((ident, decl, generics))\n     }\n \n     /// Parses the name and optional generic types of a function header.\n@@ -1282,14 +1219,11 @@ impl<'a> Parser<'a> {\n         Ok((id, generics))\n     }\n \n-    /// Parses the argument list and result type of a function declaration.\n+    /// Parses the parameter list and result type of a function declaration.\n     fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n-        let args = self.parse_fn_params(true, allow_c_variadic)?;\n-        let ret_ty = self.parse_ret_ty(true)?;\n-\n         Ok(P(FnDecl {\n-            inputs: args,\n-            output: ret_ty,\n+            inputs: self.parse_fn_params(true, allow_c_variadic)?,\n+            output: self.parse_ret_ty(true)?,\n         }))\n     }\n \n@@ -1397,18 +1331,15 @@ impl<'a> Parser<'a> {\n         extern_sp: Span,\n     ) -> PResult<'a, ForeignItem> {\n         self.expect_keyword(kw::Fn)?;\n-\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(true)?;\n-        generics.where_clause = self.parse_where_clause()?;\n-        let hi = self.token.span;\n+        let (ident, decl, generics) = self.parse_fn_sig(true)?;\n+        let span = lo.to(self.token.span);\n         self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n         Ok(ast::ForeignItem {\n             ident,\n             attrs,\n             kind: ForeignItemKind::Fn(decl, generics),\n             id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n+            span,\n             vis,\n         })\n     }"}, {"sha": "41ee2a1599d74028ab9a9d092792e591fb56eb7f", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9689333a2b52af4dffde750e7055cf6badb576/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=db9689333a2b52af4dffde750e7055cf6badb576", "patch": "@@ -231,19 +231,15 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n-        let mutbl = if self.eat_keyword(kw::Mut) {\n-            Mutability::Mutable\n-        } else if self.eat_keyword(kw::Const) {\n-            Mutability::Immutable\n-        } else {\n+        let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n             let span = self.prev_span;\n             let msg = \"expected mut or const in raw pointer type\";\n             self.struct_span_err(span, msg)\n                 .span_label(span, msg)\n                 .help(\"use `*mut T` or `*const T` as appropriate\")\n                 .emit();\n             Mutability::Immutable\n-        };\n+        });\n         let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl })\n     }"}, {"sha": "7633825eb32ab167f1ee6894bb66ab3edeef10ad", "filename": "src/test/ui/async-await/edition-deny-async-fns-2015.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db9689333a2b52af4dffde750e7055cf6badb576/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db9689333a2b52af4dffde750e7055cf6badb576/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr?ref=db9689333a2b52af4dffde750e7055cf6badb576", "patch": "@@ -10,18 +10,18 @@ error[E0670]: `async fn` is not permitted in the 2015 edition\n LL | fn baz() { async fn foo() {} }\n    |            ^^^^^\n \n-error[E0670]: `async fn` is not permitted in the 2015 edition\n-  --> $DIR/edition-deny-async-fns-2015.rs:8:5\n-   |\n-LL |     async fn bar() {}\n-   |     ^^^^^\n-\n error[E0670]: `async fn` is not permitted in the 2015 edition\n   --> $DIR/edition-deny-async-fns-2015.rs:7:1\n    |\n LL | async fn async_baz() {\n    | ^^^^^\n \n+error[E0670]: `async fn` is not permitted in the 2015 edition\n+  --> $DIR/edition-deny-async-fns-2015.rs:8:5\n+   |\n+LL |     async fn bar() {}\n+   |     ^^^^^\n+\n error[E0670]: `async fn` is not permitted in the 2015 edition\n   --> $DIR/edition-deny-async-fns-2015.rs:14:5\n    |"}]}