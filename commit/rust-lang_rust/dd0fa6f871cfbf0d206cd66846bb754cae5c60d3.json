{"sha": "dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "node_id": "C_kwDOAAsO6NoAKGRkMGZhNmY4NzFjZmJmMGQyMDZjZDY2ODQ2YmI3NTRjYWU1YzYwZDM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-06T14:29:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-06T14:29:43Z"}, "message": "Rollup merge of #98496 - BoxyUwU:instancers_bad_equality, r=lcnr\n\nmake `compare_const_impl` a query and use it in `instance.rs`\n\nFixes #88365\n\nthe bug in #88365 was caused by some `instance.rs` code using the `PartialEq` impl on `Ty` to check that the type of the associated const in an impl is the same as the type of the associated const in the trait definition. This was wrong for two reasons:\n- the check typeck does is that the impl type is a subtype of the trait definition's type (see `mismatched_impl_ty_2.rs` which [was ICEing](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f6d60ebe6745011f0d52ab2bc712025d) before this PR on stable)\n- it assumes that if two types are equal then the `PartialEq` impl will reflect that which isnt true for higher ranked types or type level constants when `feature(generic_const_exprs)` is enabled (see `mismatched_impl_ty_3.rs` for higher ranked types which was [ICEing on stable](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d7af131a655ed515b035624626c62c71))\n\nr? `@lcnr`", "tree": {"sha": "531833978577bcf9180d65a4f7ccad153ad02b8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/531833978577bcf9180d65a4f7ccad153ad02b8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjPuZXCRBK7hj4Ov3rIwAARMsIAIEmvj2rC33MPUy6n/TlTEOH\nnvVYr9PsMrA6QvThrpx1X/JO+KPYT4hWlbCXrjf4o6HhMVfFD4v5qF6Oa7L240RF\npt1QWxcrzApZ1zdFO7++3Y1FXELhBqXAuV7EIqv8XYojZnRVSG8PoYHO6jt0QFn0\nV7n7z7FskfUGwW6t4yM+Sx6RoTssfGwYhR7+dKR7PV91PllX0TaxNpWaFUHdTyQA\nxB8gvKN2H8KVigocP0qgZSopYXOoycPL144E3d33SDMt2C70BJUAllzUyau2QKLF\nug3DrNGT+xIDAvZsZvYeVIxJjxR1m+R3GhXjILQY3cOszTCjnlroERFdPoMRcKA=\n=Q1oM\n-----END PGP SIGNATURE-----\n", "payload": "tree 531833978577bcf9180d65a4f7ccad153ad02b8d\nparent 6b6610b8bd5112bbb3bd2b73a97250cb06979505\nparent 25ed5d5db295e1fbf27e511c9159e67c22b08f43\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1665066583 +0200\ncommitter GitHub <noreply@github.com> 1665066583 +0200\n\nRollup merge of #98496 - BoxyUwU:instancers_bad_equality, r=lcnr\n\nmake `compare_const_impl` a query and use it in `instance.rs`\n\nFixes #88365\n\nthe bug in #88365 was caused by some `instance.rs` code using the `PartialEq` impl on `Ty` to check that the type of the associated const in an impl is the same as the type of the associated const in the trait definition. This was wrong for two reasons:\n- the check typeck does is that the impl type is a subtype of the trait definition's type (see `mismatched_impl_ty_2.rs` which [was ICEing](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f6d60ebe6745011f0d52ab2bc712025d) before this PR on stable)\n- it assumes that if two types are equal then the `PartialEq` impl will reflect that which isnt true for higher ranked types or type level constants when `feature(generic_const_exprs)` is enabled (see `mismatched_impl_ty_3.rs` for higher ranked types which was [ICEing on stable](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d7af131a655ed515b035624626c62c71))\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "html_url": "https://github.com/rust-lang/rust/commit/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b6610b8bd5112bbb3bd2b73a97250cb06979505", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b6610b8bd5112bbb3bd2b73a97250cb06979505", "html_url": "https://github.com/rust-lang/rust/commit/6b6610b8bd5112bbb3bd2b73a97250cb06979505"}, {"sha": "25ed5d5db295e1fbf27e511c9159e67c22b08f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/25ed5d5db295e1fbf27e511c9159e67c22b08f43", "html_url": "https://github.com/rust-lang/rust/commit/25ed5d5db295e1fbf27e511c9159e67c22b08f43"}], "stats": {"total": 160, "additions": 90, "deletions": 70}, "files": [{"sha": "a2636f23a4f259672d776c8bb16bdde4f38b27a5", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -2,7 +2,7 @@ use crate::check::intrinsicck::InlineAsmCtxt;\n \n use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n-use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n+use super::compare_method::{compare_impl_method, compare_ty_impl};\n use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n@@ -1048,14 +1048,10 @@ fn check_impl_items_against_trait<'tcx>(\n         let impl_item_full = tcx.hir().impl_item(impl_item.id);\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n-                // Find associated const definition.\n-                compare_const_impl(\n-                    tcx,\n-                    &ty_impl_item,\n-                    impl_item.span,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                );\n+                let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n+                    impl_item.id.def_id.def_id,\n+                    ty_impl_item.trait_item_def_id.unwrap(),\n+                ));\n             }\n             hir::ImplItemKind::Fn(..) => {\n                 let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);"}, {"sha": "d006948c587939eb201b9f74f22f447e51195747", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -1,6 +1,6 @@\n use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LocalDefId};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -1300,17 +1300,20 @@ fn compare_generic_param_kinds<'tcx>(\n     Ok(())\n }\n \n-pub(crate) fn compare_const_impl<'tcx>(\n+/// Use `tcx.compare_assoc_const_impl_item_with_trait_item` instead\n+pub(crate) fn raw_compare_const_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_c: &ty::AssocItem,\n-    impl_c_span: Span,\n-    trait_c: &ty::AssocItem,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-) {\n+    (impl_const_item_def, trait_const_item_def): (LocalDefId, DefId),\n+) -> Result<(), ErrorGuaranteed> {\n+    let impl_const_item = tcx.associated_item(impl_const_item_def);\n+    let trait_const_item = tcx.associated_item(trait_const_item_def);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_const_item.container_id(tcx)).unwrap();\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n+    let impl_c_span = tcx.def_span(impl_const_item_def.to_def_id());\n+\n     tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = tcx.param_env(impl_c.def_id);\n+        let param_env = tcx.param_env(impl_const_item_def.to_def_id());\n         let ocx = ObligationCtxt::new(&infcx);\n \n         // The below is for the most part highly similar to the procedure\n@@ -1322,18 +1325,18 @@ pub(crate) fn compare_const_impl<'tcx>(\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_c.def_id.expect_local());\n+        let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n \n         // Compute placeholder form of impl and trait const tys.\n-        let impl_ty = tcx.type_of(impl_c.def_id);\n-        let trait_ty = tcx.bound_type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n+        let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n+        let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n         let mut cause = ObligationCause::new(\n             impl_c_span,\n             impl_c_hir_id,\n             ObligationCauseCode::CompareImplItemObligation {\n-                impl_item_def_id: impl_c.def_id.expect_local(),\n-                trait_item_def_id: trait_c.def_id,\n-                kind: impl_c.kind,\n+                impl_item_def_id: impl_const_item_def,\n+                trait_item_def_id: trait_const_item_def,\n+                kind: impl_const_item.kind,\n             },\n         );\n \n@@ -1358,24 +1361,24 @@ pub(crate) fn compare_const_impl<'tcx>(\n             );\n \n             // Locate the Span containing just the type of the offending impl\n-            match tcx.hir().expect_impl_item(impl_c.def_id.expect_local()).kind {\n+            match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n                 ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-                _ => bug!(\"{:?} is not a impl const\", impl_c),\n+                _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n             }\n \n             let mut diag = struct_span_err!(\n                 tcx.sess,\n                 cause.span,\n                 E0326,\n                 \"implemented const `{}` has an incompatible type for trait\",\n-                trait_c.name\n+                trait_const_item.name\n             );\n \n-            let trait_c_span = trait_c.def_id.as_local().map(|trait_c_def_id| {\n+            let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n                 // Add a label to the Span containing just the type of the const\n                 match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n                     TraitItemKind::Const(ref ty, _) => ty.span,\n-                    _ => bug!(\"{:?} is not a trait const\", trait_c),\n+                    _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n                 }\n             });\n \n@@ -1391,23 +1394,22 @@ pub(crate) fn compare_const_impl<'tcx>(\n                 false,\n                 false,\n             );\n-            diag.emit();\n-        }\n+            return Err(diag.emit());\n+        };\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n-            return;\n+            return Err(infcx.report_fulfillment_errors(&errors, None, false));\n         }\n \n+        // FIXME return `ErrorReported` if region obligations error?\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n-        infcx.check_region_obligations_and_report_errors(\n-            impl_c.def_id.expect_local(),\n-            &outlives_environment,\n-        );\n-    });\n+        infcx\n+            .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment);\n+        Ok(())\n+    })\n }\n \n pub(crate) fn compare_ty_impl<'tcx>("}, {"sha": "04e8c9c22d15930cb4b2902abfd4762cc0be02cf", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -251,6 +251,7 @@ pub fn provide(providers: &mut Providers) {\n         check_mod_item_types,\n         region_scope_tree,\n         collect_trait_impl_trait_tys,\n+        compare_assoc_const_impl_item_with_trait_item: compare_method::raw_compare_const_impl,\n         ..*providers\n     };\n }"}, {"sha": "334eb953cbcb45f2d138b1f49f1bcd7a18669ebc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -2105,4 +2105,10 @@ rustc_queries! {\n     query permits_zero_init(key: TyAndLayout<'tcx>) -> bool {\n         desc { \"checking to see if {:?} permits being left zeroed\", key.ty }\n     }\n+\n+    query compare_assoc_const_impl_item_with_trait_item(\n+        key: (LocalDefId, DefId)\n+    ) -> Result<(), ErrorGuaranteed> {\n+        desc { |tcx| \"checking assoc const `{}` has the same type as trait item\", tcx.def_path_str(key.0.to_def_id()) }\n+    }\n }"}, {"sha": "fe6ebd4b93568388269d0e23c5aa66d0870d619b", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -186,40 +186,14 @@ fn resolve_associated_item<'tcx>(\n             // a `trait` to an associated `const` definition in an `impl`, where\n             // the definition in the `impl` has the wrong type (for which an\n             // error has already been/will be emitted elsewhere).\n-            //\n-            // NB: this may be expensive, we try to skip it in all the cases where\n-            // we know the error would've been caught (e.g. in an upstream crate).\n-            //\n-            // A better approach might be to just introduce a query (returning\n-            // `Result<(), ErrorGuaranteed>`) for the check that `rustc_hir_analysis`\n-            // performs (i.e. that the definition's type in the `impl` matches\n-            // the declaration in the `trait`), so that we can cheaply check\n-            // here if it failed, instead of approximating it.\n             if leaf_def.item.kind == ty::AssocKind::Const\n                 && trait_item_id != leaf_def.item.def_id\n-                && leaf_def.item.def_id.is_local()\n+                && let Some(leaf_def_item) = leaf_def.item.def_id.as_local()\n             {\n-                let normalized_type_of = |def_id, substs| {\n-                    tcx.subst_and_normalize_erasing_regions(substs, param_env, tcx.type_of(def_id))\n-                };\n-\n-                let original_ty = normalized_type_of(trait_item_id, rcvr_substs);\n-                let resolved_ty = normalized_type_of(leaf_def.item.def_id, substs);\n-\n-                if original_ty != resolved_ty {\n-                    let msg = format!(\n-                        \"Instance::resolve: inconsistent associated `const` type: \\\n-                         was `{}: {}` but resolved to `{}: {}`\",\n-                        tcx.def_path_str_with_substs(trait_item_id, rcvr_substs),\n-                        original_ty,\n-                        tcx.def_path_str_with_substs(leaf_def.item.def_id, substs),\n-                        resolved_ty,\n-                    );\n-                    let span = tcx.def_span(leaf_def.item.def_id);\n-                    let reported = tcx.sess.delay_span_bug(span, &msg);\n-\n-                    return Err(reported);\n-                }\n+                tcx.compare_assoc_const_impl_item_with_trait_item((\n+                    leaf_def_item,\n+                    trait_item_id,\n+                ))?;\n             }\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))"}, {"sha": "0ddc154fbebbfc38191b01de9b8a219e3a019bcc", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -5,6 +5,7 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(let_chains)]\n #![feature(control_flow_enum)]\n #![feature(never_type)]\n #![feature(box_patterns)]"}, {"sha": "742b81535dfdf4e0cdc67966cfe6b63840e0b944", "filename": "src/test/ui/associated-consts/associated-const-impl-wrong-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.stderr?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -2,7 +2,7 @@ error[E0308]: const not compatible with trait\n   --> $DIR/associated-const-impl-wrong-lifetime.rs:7:5\n    |\n LL |     const NAME: &'a str = \"unit\";\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+   |     ^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected reference `&'static str`\n               found reference `&'a str`"}, {"sha": "4dc6c2e47a9eab522d67ac8666a3c9dbd9883ce2", "filename": "src/test/ui/associated-consts/mismatched_impl_ty_1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_1.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait {\n+    type ArrayType;\n+    const SIZE: usize;\n+    const ARRAY: Self::ArrayType;\n+}\n+impl MyTrait for () {\n+    type ArrayType = [u8; Self::SIZE];\n+    const SIZE: usize = 4;\n+    const ARRAY: [u8; Self::SIZE] = [1, 2, 3, 4];\n+}\n+\n+fn main() {\n+    let _ = <() as MyTrait>::ARRAY;\n+}"}, {"sha": "539becfdc7c8287763b38b31e4350d0ca50bf9d5", "filename": "src/test/ui/associated-consts/mismatched_impl_ty_2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_2.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+trait Trait {\n+    const ASSOC: fn(&'static u32);\n+}\n+impl Trait for () {\n+    const ASSOC: for<'a> fn(&'a u32) = |_| ();\n+}\n+\n+fn main() {\n+    let _ = <() as Trait>::ASSOC;\n+}"}, {"sha": "17bcc8fe5768ceb917d754229ddbdb571dd3467c", "filename": "src/test/ui/associated-consts/mismatched_impl_ty_3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fmismatched_impl_ty_3.rs?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+trait Trait {\n+    const ASSOC: for<'a, 'b> fn(&'a u32, &'b u32);\n+}\n+impl Trait for () {\n+    const ASSOC: for<'a> fn(&'a u32, &'a u32) = |_, _| ();\n+}\n+\n+fn main() {\n+    let _ = <() as Trait>::ASSOC;\n+}"}, {"sha": "cf1c52ba7cc4332ed4af63137b31bd60c8867cde", "filename": "src/test/ui/nll/trait-associated-constant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd0fa6f871cfbf0d206cd66846bb754cae5c60d3/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr?ref=dd0fa6f871cfbf0d206cd66846bb754cae5c60d3", "patch": "@@ -2,7 +2,7 @@ error[E0308]: const not compatible with trait\n   --> $DIR/trait-associated-constant.rs:21:5\n    |\n LL |     const AC: Option<&'c str> = None;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n    |\n    = note: expected enum `Option<&'b str>`\n               found enum `Option<&'c str>`"}]}