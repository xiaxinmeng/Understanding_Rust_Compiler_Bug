{"sha": "0bcbe91b487ea933aba9a9e079f01133574fc98f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiY2JlOTFiNDg3ZWE5MzNhYmE5YTllMDc5ZjAxMTMzNTc0ZmM5OGY=", "commit": {"author": {"name": "Gabriel Smith", "email": "ga29smith@gmail.com", "date": "2018-07-23T12:43:22Z"}, "committer": {"name": "Gabriel Smith", "email": "ga29smith@gmail.com", "date": "2018-07-25T00:17:14Z"}, "message": "Deduplicate linkage checking code for statics\n\nSigned-off-by: Gabriel Smith <ga29smith@gmail.com>", "tree": {"sha": "f9a9b7cbda613d4be488eb795158b145191f69e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a9b7cbda613d4be488eb795158b145191f69e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bcbe91b487ea933aba9a9e079f01133574fc98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bcbe91b487ea933aba9a9e079f01133574fc98f", "html_url": "https://github.com/rust-lang/rust/commit/0bcbe91b487ea933aba9a9e079f01133574fc98f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bcbe91b487ea933aba9a9e079f01133574fc98f/comments", "author": {"login": "yodaldevoid", "id": 1204409, "node_id": "MDQ6VXNlcjEyMDQ0MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1204409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yodaldevoid", "html_url": "https://github.com/yodaldevoid", "followers_url": "https://api.github.com/users/yodaldevoid/followers", "following_url": "https://api.github.com/users/yodaldevoid/following{/other_user}", "gists_url": "https://api.github.com/users/yodaldevoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/yodaldevoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yodaldevoid/subscriptions", "organizations_url": "https://api.github.com/users/yodaldevoid/orgs", "repos_url": "https://api.github.com/users/yodaldevoid/repos", "events_url": "https://api.github.com/users/yodaldevoid/events{/privacy}", "received_events_url": "https://api.github.com/users/yodaldevoid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yodaldevoid", "id": 1204409, "node_id": "MDQ6VXNlcjEyMDQ0MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1204409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yodaldevoid", "html_url": "https://github.com/yodaldevoid", "followers_url": "https://api.github.com/users/yodaldevoid/followers", "following_url": "https://api.github.com/users/yodaldevoid/following{/other_user}", "gists_url": "https://api.github.com/users/yodaldevoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/yodaldevoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yodaldevoid/subscriptions", "organizations_url": "https://api.github.com/users/yodaldevoid/orgs", "repos_url": "https://api.github.com/users/yodaldevoid/repos", "events_url": "https://api.github.com/users/yodaldevoid/events{/privacy}", "received_events_url": "https://api.github.com/users/yodaldevoid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a20262c06986acb98150913e2c43cb13cead92a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a20262c06986acb98150913e2c43cb13cead92a7", "html_url": "https://github.com/rust-lang/rust/commit/a20262c06986acb98150913e2c43cb13cead92a7"}], "stats": {"total": 154, "additions": 69, "deletions": 85}, "files": [{"sha": "f0b5f4b887971f1cffa7bc150ef450d24d7c2ab0", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 69, "deletions": 85, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0bcbe91b487ea933aba9a9e079f01133574fc98f/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bcbe91b487ea933aba9a9e079f01133574fc98f/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=0bcbe91b487ea933aba9a9e079f01133574fc98f", "patch": "@@ -20,12 +20,14 @@ use monomorphize::MonoItem;\n use common::{CodegenCx, val_ty};\n use declare;\n use monomorphize::Instance;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::LocalInternedString;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Align, LayoutOf};\n \n-use rustc::hir::{self, CodegenFnAttrFlags};\n+use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n@@ -146,47 +148,8 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n-                let g = if let Some(linkage) = cx.tcx.codegen_fn_attrs(def_id).linkage {\n-                    debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n-\n-                    // If this is a static with a linkage specified, then we need to handle\n-                    // it a little specially. The typesystem prevents things like &T and\n-                    // extern \"C\" fn() from being non-null, so we can't just declare a\n-                    // static and call it a day. Some linkages (like weak) will make it such\n-                    // that the static actually has a null value.\n-                    let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n-                        _ => {\n-                            cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n-                        }\n-                    };\n-                    unsafe {\n-                        // Declare a symbol `foo` with the desired linkage.\n-                        let g1 = declare::declare_global(cx, &sym, llty2);\n-                        llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n-\n-                        // Declare an internal global `extern_with_linkage_foo` which\n-                        // is initialized with the address of `foo`.  If `foo` is\n-                        // discarded during linking (for example, if `foo` has weak\n-                        // linkage and there are no definitions), then\n-                        // `extern_with_linkage_foo` will instead be initialized to\n-                        // zero.\n-                        let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                        real_name.push_str(&sym);\n-                        let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n-                            cx.sess().span_fatal(span,\n-                                &format!(\"symbol `{}` is already defined\", &sym))\n-                        });\n-                        llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n-                        llvm::LLVMSetInitializer(g2, g1);\n-                        g2\n-                    }\n-                } else {\n-                    // Generate an external declaration.\n-                    declare::declare_global(cx, &sym, llty)\n-                };\n-\n-                (g, attrs)\n+                let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);\n+                (check_and_apply_linkage(cx, &fn_attrs, ty, sym, Some(span)), attrs)\n             }\n \n             item => bug!(\"get_static: expected static, found {:?}\", item)\n@@ -205,55 +168,16 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         debug!(\"get_static: sym={} item_attr={:?}\", sym, cx.tcx.item_attrs(def_id));\n \n-        let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(def_id);\n-        let llty = cx.layout_of(ty).llvm_type(cx);\n-        let g = if let Some(linkage) = codegen_fn_attrs.linkage {\n-            debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n-\n-            // If this is a static with a linkage specified, then we need to handle\n-            // it a little specially. The typesystem prevents things like &T and\n-            // extern \"C\" fn() from being non-null, so we can't just declare a\n-            // static and call it a day. Some linkages (like weak) will make it such\n-            // that the static actually has a null value.\n-            let llty2 = match ty.sty {\n-                ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n-                _ => {\n-                    bug!(\"must have type `*const T` or `*mut T`\")\n-                }\n-            };\n-            unsafe {\n-                // Declare a symbol `foo` with the desired linkage.\n-                let g1 = declare::declare_global(cx, &sym, llty2);\n-                llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n-\n-                // Declare an internal global `extern_with_linkage_foo` which\n-                // is initialized with the address of `foo`.  If `foo` is\n-                // discarded during linking (for example, if `foo` has weak\n-                // linkage and there are no definitions), then\n-                // `extern_with_linkage_foo` will instead be initialized to\n-                // zero.\n-                let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                real_name.push_str(&sym);\n-                let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n-                    bug!(\"symbol `{}` is already defined\", &sym)\n-                });\n-                llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n-                llvm::LLVMSetInitializer(g2, g1);\n-                g2\n-            }\n-        } else {\n-            // Generate an external declaration.\n-            // FIXME(nagisa): investigate whether it can be changed into define_global\n-            declare::declare_global(cx, &sym, llty)\n-        };\n+        let attrs = cx.tcx.codegen_fn_attrs(def_id);\n+        let g = check_and_apply_linkage(cx, &attrs, ty, sym, None);\n \n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n             llvm::set_thread_local_mode(g, cx.tls_model);\n         }\n \n@@ -289,6 +213,66 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     g\n }\n \n+fn check_and_apply_linkage<'tcx>(\n+    cx: &CodegenCx<'_, 'tcx>,\n+    attrs: &CodegenFnAttrs,\n+    ty: Ty<'tcx>,\n+    sym: LocalInternedString,\n+    span: Option<Span>\n+) -> ValueRef {\n+    let llty = cx.layout_of(ty).llvm_type(cx);\n+    if let Some(linkage) = attrs.linkage {\n+        debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n+\n+        // If this is a static with a linkage specified, then we need to handle\n+        // it a little specially. The typesystem prevents things like &T and\n+        // extern \"C\" fn() from being non-null, so we can't just declare a\n+        // static and call it a day. Some linkages (like weak) will make it such\n+        // that the static actually has a null value.\n+        let llty2 = match ty.sty {\n+            ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n+            _ => {\n+                if span.is_some() {\n+                    cx.sess().span_fatal(span.unwrap(), \"must have type `*const T` or `*mut T`\")\n+                } else {\n+                    bug!(\"must have type `*const T` or `*mut T`\")\n+                }\n+            }\n+        };\n+        unsafe {\n+            // Declare a symbol `foo` with the desired linkage.\n+            let g1 = declare::declare_global(cx, &sym, llty2);\n+            llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n+\n+            // Declare an internal global `extern_with_linkage_foo` which\n+            // is initialized with the address of `foo`.  If `foo` is\n+            // discarded during linking (for example, if `foo` has weak\n+            // linkage and there are no definitions), then\n+            // `extern_with_linkage_foo` will instead be initialized to\n+            // zero.\n+            let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n+            real_name.push_str(&sym);\n+            let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+                if span.is_some() {\n+                    cx.sess().span_fatal(\n+                        span.unwrap(),\n+                        &format!(\"symbol `{}` is already defined\", &sym)\n+                    )\n+                } else {\n+                    bug!(\"symbol `{}` is already defined\", &sym)\n+                }\n+            });\n+            llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n+            llvm::LLVMSetInitializer(g2, g1);\n+            g2\n+        }\n+    } else {\n+        // Generate an external declaration.\n+        // FIXME(nagisa): investigate whether it can be changed into define_global\n+        declare::declare_global(cx, &sym, llty)\n+    }\n+}\n+\n pub fn codegen_static<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId,"}]}