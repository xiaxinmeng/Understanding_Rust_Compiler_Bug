{"sha": "a1ed53a4f183b5826162eb9e998207b92be9c57f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZWQ1M2E0ZjE4M2I1ODI2MTYyZWI5ZTk5ODIwN2I5MmJlOWM1N2Y=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-03-31T18:02:16Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-04-14T09:28:53Z"}, "message": "More trait infrastructure\n\n - make it possible to get parent trait from method\n - add 'obligation' machinery for checking that a type implements a\n   trait (and inferring facts about type variables from that)\n - handle type parameters of traits (to a certain degree)\n - improve the hacky implements check to cover enough cases to exercise the\n   handling of traits with type parameters\n - basic canonicalization (will probably also be done by Chalk)", "tree": {"sha": "7c139a7dc38483188653c6d40583cddac9d23192", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c139a7dc38483188653c6d40583cddac9d23192"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1ed53a4f183b5826162eb9e998207b92be9c57f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1ed53a4f183b5826162eb9e998207b92be9c57f", "html_url": "https://github.com/rust-lang/rust/commit/a1ed53a4f183b5826162eb9e998207b92be9c57f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1ed53a4f183b5826162eb9e998207b92be9c57f/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "413c87f155ab6b389b1cc122b5739716acccb476", "url": "https://api.github.com/repos/rust-lang/rust/commits/413c87f155ab6b389b1cc122b5739716acccb476", "html_url": "https://github.com/rust-lang/rust/commit/413c87f155ab6b389b1cc122b5739716acccb476"}], "stats": {"total": 384, "additions": 333, "deletions": 51}, "files": [{"sha": "b53fe1f637a7f91f06146447f2b025ad172ee128", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -194,7 +194,7 @@ impl Module {\n         Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n \n-    pub fn declarations(self, db: &impl HirDatabase) -> Vec<ModuleDef> {\n+    pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n         let def_map = db.crate_def_map(self.krate);\n         def_map[self.module_id]\n             .scope\n@@ -547,13 +547,20 @@ impl Function {\n         ImplBlock::containing(module_impls, (*self).into())\n     }\n \n+    /// The containing trait, if this is a trait method definition.\n+    pub fn parent_trait(&self, db: &impl DefDatabase) -> Option<Trait> {\n+        db.trait_items_index(self.module(db)).get_parent_trait((*self).into())\n+    }\n+\n     // FIXME: move to a more general type for 'body-having' items\n     /// Builds a resolver for code inside this item.\n     pub(crate) fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n         // take the outer scope...\n+        // FIXME abstract over containers (trait/impl)\n         let r = self\n             .impl_block(db)\n             .map(|ib| ib.resolver(db))\n+            .or_else(|| self.parent_trait(db).map(|tr| tr.resolver(db)))\n             .unwrap_or_else(|| self.module(db).resolver(db));\n         // ...and add generic params, if present\n         let p = self.generic_params(db);\n@@ -699,6 +706,14 @@ impl Trait {\n     pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n         db.trait_data(self)\n     }\n+\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        let r = self.module(db).resolver(db);\n+        // add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n+        r\n+    }\n }\n \n impl Docs for Trait {"}, {"sha": "18627bbc24d083b83ffad8eb0852cf02bbfa994a", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -53,6 +53,9 @@ pub trait DefDatabase: SourceDatabase {\n     #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n     fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n \n+    #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n+    fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n+\n     #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n     fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n@@ -128,8 +131,8 @@ pub trait HirDatabase: DefDatabase {\n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n \n-    #[salsa::invoke(crate::ty::method_resolution::implements)]\n-    fn implements(&self, trait_ref: TraitRef) -> bool;\n+    #[salsa::invoke(crate::ty::traits::implements)]\n+    fn implements(&self, trait_ref: TraitRef) -> Option<crate::ty::traits::Solution>;\n }\n \n #[test]"}, {"sha": "51c846e91b7002e410fc5cef291ec762bf56f22b", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -45,12 +45,16 @@ impl GenericParams {\n     ) -> Arc<GenericParams> {\n         let mut generics = GenericParams::default();\n         let parent = match def {\n-            GenericDef::Function(it) => it.impl_block(db),\n-            GenericDef::TypeAlias(it) => it.impl_block(db),\n+            // FIXME abstract over containers (trait/impl)\n+            GenericDef::Function(it) => it\n+                .impl_block(db)\n+                .map(GenericDef::from)\n+                .or_else(|| it.parent_trait(db).map(GenericDef::from)),\n+            GenericDef::TypeAlias(it) => it.impl_block(db).map(GenericDef::from),\n             GenericDef::Struct(_) | GenericDef::Enum(_) | GenericDef::Trait(_) => None,\n             GenericDef::ImplBlock(_) => None,\n         };\n-        generics.parent_params = parent.map(|p| p.generic_params(db));\n+        generics.parent_params = parent.map(|p| db.generic_params(p));\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         match def {\n             GenericDef::Function(it) => generics.fill(&*it.source(db).1, start),"}, {"sha": "42c02c9fb93f9781555d2ac2336b3634e15f9703", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -84,7 +84,8 @@ impl ImplBlock {\n     }\n \n     pub fn target_trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n-        TraitRef::from_hir(db, &self.resolver(db), &self.target_trait(db)?)\n+        let target_ty = self.target_ty(db);\n+        TraitRef::from_hir(db, &self.resolver(db), &self.target_trait(db)?, Some(target_ty))\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<ImplItem> {"}, {"sha": "15f0977b718b4ed2d114dd35e3039e3507b3ddf8", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -1,10 +1,11 @@\n //! HIR for trait definitions.\n \n use std::sync::Arc;\n+use rustc_hash::FxHashMap;\n \n use ra_syntax::ast::{self, NameOwner};\n \n-use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName};\n+use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName, Module};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitData {\n@@ -49,4 +50,34 @@ pub enum TraitItem {\n     TypeAlias(TypeAlias),\n     // Existential\n }\n+// FIXME: not every function, ... is actually a trait item. maybe we should make\n+// sure that you can only turn actual trait items into TraitItems. This would\n+// require not implementing From, and instead having some checked way of\n+// casting them.\n impl_froms!(TraitItem: Function, Const, TypeAlias);\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitItemsIndex {\n+    traits_by_def: FxHashMap<TraitItem, Trait>,\n+}\n+\n+impl TraitItemsIndex {\n+    pub(crate) fn trait_items_index(db: &impl DefDatabase, module: Module) -> TraitItemsIndex {\n+        let mut index = TraitItemsIndex { traits_by_def: FxHashMap::default() };\n+        for decl in module.declarations(db) {\n+            match decl {\n+                crate::ModuleDef::Trait(tr) => {\n+                    for item in tr.trait_data(db).items() {\n+                        index.traits_by_def.insert(*item, tr);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        index\n+    }\n+\n+    pub(crate) fn get_parent_trait(&self, item: TraitItem) -> Option<Trait> {\n+        self.traits_by_def.get(&item).cloned()\n+    }\n+}"}, {"sha": "aa43bc800d36432a2439cacc1e9367f4e34e65fc", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -5,6 +5,7 @@ mod autoderef;\n pub(crate) mod primitive;\n #[cfg(test)]\n mod tests;\n+pub(crate) mod traits;\n pub(crate) mod method_resolution;\n mod op;\n mod lower;\n@@ -145,6 +146,10 @@ impl Substs {\n         Substs(Arc::new([ty]))\n     }\n \n+    pub fn prefix(&self, n: usize) -> Substs {\n+        Substs(self.0.iter().cloned().take(n).collect::<Vec<_>>().into())\n+    }\n+\n     pub fn iter(&self) -> impl Iterator<Item = &Ty> {\n         self.0.iter()\n     }\n@@ -170,6 +175,12 @@ impl Substs {\n     }\n }\n \n+impl From<Vec<Ty>> for Substs {\n+    fn from(v: Vec<Ty>) -> Self {\n+        Substs(v.into())\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "3dec5936a9cde9b64c9d72461368f765cb20029b", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -41,7 +41,7 @@ use crate::{\n     ty::infer::diagnostics::InferenceDiagnostic,\n     diagnostics::DiagnosticSink,\n };\n-use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n+use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor, traits::{ Solution, Obligation, Guidance}, CallableDef, TraitRef};\n \n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -153,6 +153,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     body: Arc<Body>,\n     resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    obligations: Vec<Obligation>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n@@ -173,6 +174,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             type_of_pat: ArenaMap::default(),\n             diagnostics: Vec::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n+            obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n             body,\n@@ -181,6 +183,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n+        // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut tv_stack = Vec::new();\n         let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n         for ty in expr_types.values_mut() {\n@@ -311,11 +314,49 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n     }\n \n+    fn resolve_obligations_as_possible(&mut self) {\n+        let obligations = mem::replace(&mut self.obligations, Vec::new());\n+        for obligation in obligations {\n+            // FIXME resolve types in the obligation first\n+            let (solution, var_mapping) = match &obligation {\n+                Obligation::Trait(tr) => {\n+                    let (tr, var_mapping) = super::traits::canonicalize(tr.clone());\n+                    (self.db.implements(tr), var_mapping)\n+                }\n+            };\n+            match solution {\n+                Some(Solution::Unique(substs)) => {\n+                    for (i, subst) in substs.0.iter().enumerate() {\n+                        let uncanonical = var_mapping[i];\n+                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n+                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n+                    }\n+                }\n+                Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                    for (i, subst) in substs.0.iter().enumerate() {\n+                        let uncanonical = var_mapping[i];\n+                        // FIXME the subst may contain type variables, which would need to be mapped back as well\n+                        self.unify(&Ty::Infer(InferTy::TypeVar(uncanonical)), subst);\n+                    }\n+                    self.obligations.push(obligation);\n+                }\n+                Some(_) => {\n+                    self.obligations.push(obligation);\n+                }\n+                None => {\n+                    // FIXME obligation cannot be fulfilled => diagnostic\n+                }\n+            }\n+        }\n+    }\n+\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n     fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        self.resolve_obligations_as_possible();\n+\n         ty.fold(&mut |ty| match ty {\n             Ty::Infer(tv) => {\n                 let inner = tv.to_inner();\n@@ -710,12 +751,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         &mut self,\n         def_generics: Option<Arc<GenericParams>>,\n         generic_args: &Option<GenericArgs>,\n+        receiver_ty: &Ty,\n     ) -> Substs {\n         let (parent_param_count, param_count) =\n-            def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n         let mut substs = Vec::with_capacity(parent_param_count + param_count);\n-        for _ in 0..parent_param_count {\n-            substs.push(Ty::Unknown);\n+        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n+            for param in &parent_generics.params {\n+                if param.name.as_known_name() == Some(crate::KnownName::SelfType) {\n+                    substs.push(receiver_ty.clone());\n+                } else {\n+                    substs.push(Ty::Unknown);\n+                }\n+            }\n         }\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n@@ -817,6 +865,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         (Vec::new(), Ty::Unknown)\n                     }\n                 };\n+                // FIXME register obligations from where clauses from the function\n                 let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n                 for (arg, param) in args.iter().zip(param_iter) {\n                     self.infer_expr(*arg, &Expectation::has_type(param));\n@@ -838,7 +887,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     None => (receiver_ty, Ty::Unknown, None),\n                 };\n-                let substs = self.substs_for_method_call(def_generics, generic_args);\n+                let substs = self.substs_for_method_call(\n+                    def_generics.clone(),\n+                    generic_args,\n+                    &derefed_receiver_ty,\n+                );\n                 let method_ty = method_ty.apply_substs(substs);\n                 let method_ty = self.insert_type_vars(method_ty);\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n@@ -859,6 +912,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             let sig = self.db.callable_item_signature(def);\n                             let ret_ty = sig.ret().clone().subst(&a_ty.parameters);\n \n+                            // add obligation for trait implementation, if this is a trait method\n+                            // FIXME also register obligations from where clauses from the trait or impl and method\n+                            match def {\n+                                CallableDef::Function(f) => {\n+                                    if let Some(trait_) = f.parent_trait(self.db) {\n+                                        // construct a TraitDef\n+                                        let substs = a_ty.parameters.prefix(\n+                                            def_generics\n+                                                .expect(\"trait parent should always have generics\")\n+                                                .count_parent_params(),\n+                                        );\n+                                        self.obligations\n+                                            .push(Obligation::Trait(TraitRef { trait_, substs }));\n+                                    }\n+                                }\n+                                CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n+                            }\n+\n                             if !sig.params().is_empty() {\n                                 let mut params_iter = sig\n                                     .params()\n@@ -875,6 +946,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n                 };\n                 // Apply autoref so the below unification works correctly\n+                // FIXME: return correct autorefs/derefs from lookup_method\n                 let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n                     Some((_, mutability)) => {\n                         Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty)\n@@ -1180,7 +1252,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n /// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(u32);\n+pub struct TypeVarId(pub(super) u32);\n \n impl UnifyKey for TypeVarId {\n     type Value = TypeVarValue;"}, {"sha": "ccacb5e737b02289ad52eaad803ca945c5c2d14a", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -206,6 +206,7 @@ impl TraitRef {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         type_ref: &TypeRef,\n+        explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n@@ -215,7 +216,13 @@ impl TraitRef {\n             Resolution::Def(ModuleDef::Trait(tr)) => tr,\n             _ => return None,\n         };\n-        let substs = Self::substs_from_path(db, resolver, path, resolved);\n+        let mut substs = Self::substs_from_path(db, resolver, path, resolved);\n+        if let Some(self_ty) = explicit_self_ty {\n+            // FIXME this could be nicer\n+            let mut substs_vec = substs.0.to_vec();\n+            substs_vec[0] = self_ty;\n+            substs.0 = substs_vec.into();\n+        }\n         Some(TraitRef { trait_: resolved, substs })\n     }\n "}, {"sha": "f69b8304b35984a07a905386c8098dc1f3f94136", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -108,20 +108,6 @@ impl CrateImplBlocks {\n     }\n }\n \n-/// Rudimentary check whether an impl exists for a given type and trait; this\n-/// will actually be done by chalk.\n-pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n-    // FIXME use all trait impls in the whole crate graph\n-    let krate = trait_ref.trait_.module(db).krate(db);\n-    let krate = match krate {\n-        Some(krate) => krate,\n-        None => return false,\n-    };\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n-    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n-}\n-\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -142,6 +128,7 @@ impl Ty {\n         resolver: &Resolver,\n     ) -> Option<(Ty, Function)> {\n         // FIXME: trait methods should be used before autoderefs\n+        // (and we need to do autoderefs for trait method calls as well)\n         let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n@@ -174,24 +161,15 @@ impl Ty {\n                 }\n             }\n         }\n-        // FIXME:\n-        //  - we might not actually be able to determine fully that the type\n-        //    implements the trait here; it's enough if we (well, Chalk) determine\n-        //    that it's possible.\n-        //  - when the trait method is picked, we need to register an\n-        //    'obligation' somewhere so that we later check that it's really\n-        //    implemented\n-        //  - both points go for additional requirements from where clauses as\n-        //    well (in fact, the 'implements' condition could just be considered a\n-        //    'where Self: Trait' clause)\n         candidates.retain(|(t, _m)| {\n-            // FIXME construct substs of the correct length for the trait\n-            //  - check in rustc whether it does anything smarter than putting variables for everything\n-            let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n-            db.implements(trait_ref)\n+            let trait_ref =\n+                TraitRef { trait_: *t, substs: fresh_substs_for_trait(db, *t, self.clone()) };\n+            let (trait_ref, _) = super::traits::canonicalize(trait_ref);\n+            db.implements(trait_ref).is_some()\n         });\n         // FIXME if there's multiple candidates here, that's an ambiguity error\n         let (_chosen_trait, chosen_method) = candidates.first()?;\n+        // FIXME return correct receiver type\n         Some((self.clone(), *chosen_method))\n     }\n \n@@ -254,3 +232,16 @@ impl Ty {\n         None\n     }\n }\n+\n+fn fresh_substs_for_trait(db: &impl HirDatabase, tr: Trait, self_ty: Ty) -> Substs {\n+    let mut substs = Vec::new();\n+    let mut counter = 0;\n+    let generics = tr.generic_params(db);\n+    substs.push(self_ty);\n+    substs.extend(generics.params_including_parent().into_iter().skip(1).map(|_p| {\n+        let fresh_var = Ty::Infer(super::infer::InferTy::TypeVar(super::infer::TypeVarId(counter)));\n+        counter += 1;\n+        fresh_var\n+    }));\n+    substs.into()\n+}"}, {"sha": "291bc9ae52a2e91f4e8a38f204bab1f3f9988f52", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -1926,8 +1926,8 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[31; 35) 'self': &{unknown}\n-[110; 114) 'self': &{unknown}\n+[31; 35) 'self': &Self\n+[110; 114) 'self': &Self\n [170; 228) '{     ...i128 }': ()\n [176; 178) 'S1': S1\n [176; 187) 'S1.method()': u32\n@@ -1972,8 +1972,8 @@ mod bar_test {\n }\n \"#),\n         @r###\"\n-[63; 67) 'self': &{unknown}\n-[169; 173) 'self': &{unknown}\n+[63; 67) 'self': &Self\n+[169; 173) 'self': &Self\n [300; 337) '{     ...     }': ()\n [310; 311) 'S': S\n [310; 320) 'S.method()': u32\n@@ -1998,10 +1998,45 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[33; 37) 'self': &{unknown}\n+[33; 37) 'self': &Self\n [92; 111) '{     ...d(); }': ()\n [98; 99) 'S': S\n-[98; 108) 'S.method()': {unknown}\"###\n+[98; 108) 'S.method()': u32\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_trait_method_generic_more_params() {\n+    // the trait implementation is intentionally incomplete -- it shouldn't matter\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait<T1, T2, T3> {\n+    fn method1(&self) -> (T1, T2, T3);\n+    fn method2(&self) -> (T3, T2, T1);\n+}\n+struct S1;\n+impl Trait<u8, u16, u32> for S1 {}\n+struct S2;\n+impl<T> Trait<i8, i16, T> for S2 {}\n+fn test() {\n+    S1.method1(); // u8, u16, u32\n+    S1.method2(); // u32, u16, u8\n+    S2.method1(); // i8, i16, {unknown}\n+    S2.method2(); // {unknown}, i16, i8\n+}\n+\"#),\n+        @r###\"\n+[43; 47) 'self': &Self\n+[82; 86) 'self': &Self\n+[210; 361) '{     ..., i8 }': ()\n+[216; 218) 'S1': S1\n+[216; 228) 'S1.method1()': (u8, u16, u32)\n+[250; 252) 'S1': S1\n+[250; 262) 'S1.method2()': (u32, u16, u8)\n+[284; 286) 'S2': S2\n+[284; 296) 'S2.method1()': (i8, i16, {unknown})\n+[324; 326) 'S2': S2\n+[324; 336) 'S2.method2()': ({unknown}, i16, i8)\"###\n     );\n }\n \n@@ -2020,7 +2055,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[33; 37) 'self': &{unknown}\n+[33; 37) 'self': &Self\n [102; 127) '{     ...d(); }': ()\n [108; 109) 'S': S<u32>(T) -> S<T>\n [108; 115) 'S(1u32)': S<u32>\n@@ -2168,7 +2203,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-[29; 33) 'self': {unknown}\n+[29; 33) 'self': Self\n [107; 198) '{     ...(S); }': ()\n [117; 118) 'x': u32\n [126; 127) 'S': S"}, {"sha": "f8c3958bd85a1d7f2edda8fecf4fb646b98264cc", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ed53a4f183b5826162eb9e998207b92be9c57f/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=a1ed53a4f183b5826162eb9e998207b92be9c57f", "patch": "@@ -0,0 +1,112 @@\n+//! Stuff that will probably mostly replaced by Chalk.\n+use std::collections::HashMap;\n+\n+use crate::db::HirDatabase;\n+use super::{ TraitRef, Substs, infer::{ TypeVarId, InferTy}, Ty};\n+\n+// Copied (and simplified) from Chalk\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// A (possible) solution for a proposed goal. Usually packaged in a `Result`,\n+/// where `Err` represents definite *failure* to prove a goal.\n+pub enum Solution {\n+    /// The goal indeed holds, and there is a unique value for all existential\n+    /// variables.\n+    Unique(Substs),\n+\n+    /// The goal may be provable in multiple ways, but regardless we may have some guidance\n+    /// for type inference.\n+    Ambig(Guidance),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// When a goal holds ambiguously (e.g., because there are multiple possible\n+/// solutions), we issue a set of *guidance* back to type inference.\n+pub enum Guidance {\n+    /// The existential variables *must* have the given values if the goal is\n+    /// ever to hold, but that alone isn't enough to guarantee the goal will\n+    /// actually hold.\n+    Definite(Substs),\n+\n+    /// There are multiple plausible values for the existentials, but the ones\n+    /// here are suggested as the preferred choice heuristically. These should\n+    /// be used for inference fallback only.\n+    Suggested(Substs),\n+\n+    /// There's no useful information to feed back to type inference\n+    Unknown,\n+}\n+\n+/// Something that needs to be proven (by Chalk) during type checking, e.g. that\n+/// a certain type implements a certain trait. Proving the Obligation might\n+/// result in additional information about inference variables.\n+///\n+/// This might be handled by Chalk when we integrate it?\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum Obligation {\n+    /// Prove that a certain type implements a trait (the type is the `Self` type\n+    /// parameter to the `TraitRef`).\n+    Trait(TraitRef),\n+}\n+\n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> Option<Solution> {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return None,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks\n+        .find_map(|impl_block| unify_trait_refs(&trait_ref, &impl_block.target_trait_ref(db)?))\n+}\n+\n+pub(super) fn canonicalize(trait_ref: TraitRef) -> (TraitRef, Vec<TypeVarId>) {\n+    let mut canonical = HashMap::new(); // mapping uncanonical -> canonical\n+    let mut uncanonical = Vec::new(); // mapping canonical -> uncanonical (which is dense)\n+    let mut substs = trait_ref.substs.0.to_vec();\n+    for ty in &mut substs {\n+        ty.walk_mut(&mut |ty| match ty {\n+            Ty::Infer(InferTy::TypeVar(tv)) => {\n+                let tv: &mut TypeVarId = tv;\n+                *tv = *canonical.entry(*tv).or_insert_with(|| {\n+                    let i = uncanonical.len();\n+                    uncanonical.push(*tv);\n+                    TypeVarId(i as u32)\n+                });\n+            }\n+            _ => {}\n+        });\n+    }\n+    (TraitRef { substs: substs.into(), ..trait_ref }, uncanonical)\n+}\n+\n+fn unify_trait_refs(tr1: &TraitRef, tr2: &TraitRef) -> Option<Solution> {\n+    if tr1.trait_ != tr2.trait_ {\n+        return None;\n+    }\n+    let mut solution_substs = Vec::new();\n+    for (t1, t2) in tr1.substs.0.iter().zip(tr2.substs.0.iter()) {\n+        // this is very bad / hacky 'unification' logic, just enough to make the simple tests pass\n+        match (t1, t2) {\n+            (_, Ty::Infer(InferTy::TypeVar(_))) | (_, Ty::Unknown) | (_, Ty::Param { .. }) => {\n+                // type variable (or similar) in the impl, we just assume it works\n+            }\n+            (Ty::Infer(InferTy::TypeVar(v1)), _) => {\n+                // type variable in the query and fixed type in the impl, record its value\n+                solution_substs.resize_with(v1.0 as usize + 1, || Ty::Unknown);\n+                solution_substs[v1.0 as usize] = t2.clone();\n+            }\n+            _ => {\n+                // check that they're equal (actually we'd have to recurse etc.)\n+                if t1 != t2 {\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+    Some(Solution::Unique(solution_substs.into()))\n+}"}]}