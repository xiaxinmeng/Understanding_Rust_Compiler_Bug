{"sha": "022cb6d11d7d3529fc09283d058e66017dadeb8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmNiNmQxMWQ3ZDM1MjlmYzA5MjgzZDA1OGU2NjAxN2RhZGViOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-02T05:24:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-02T05:24:36Z"}, "message": "Auto merge of #35915 - llogiq:rfc-1623, r=nikomatsakis\n\nimplementing RFC 1623. This fixes #35897.\n\nThis is a work in progress. In particular, I want to add more tests,\nespecially the compile-fail test is very bare-bones.", "tree": {"sha": "3d5f9837c757295f4068a83b67787928cb3f85db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d5f9837c757295f4068a83b67787928cb3f85db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022cb6d11d7d3529fc09283d058e66017dadeb8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022cb6d11d7d3529fc09283d058e66017dadeb8c", "html_url": "https://github.com/rust-lang/rust/commit/022cb6d11d7d3529fc09283d058e66017dadeb8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022cb6d11d7d3529fc09283d058e66017dadeb8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8aeb15acc73311ea4308e74a166ba3c0b261c810", "url": "https://api.github.com/repos/rust-lang/rust/commits/8aeb15acc73311ea4308e74a166ba3c0b261c810", "html_url": "https://github.com/rust-lang/rust/commit/8aeb15acc73311ea4308e74a166ba3c0b261c810"}, {"sha": "a87b4d88fb5c40736a5d884ac9fd3f01690d29d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87b4d88fb5c40736a5d884ac9fd3f01690d29d6", "html_url": "https://github.com/rust-lang/rust/commit/a87b4d88fb5c40736a5d884ac9fd3f01690d29d6"}], "stats": {"total": 378, "additions": 362, "deletions": 16}, "files": [{"sha": "2b62e513ab27abb77c396f23a02e534baf415f15", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=022cb6d11d7d3529fc09283d058e66017dadeb8c", "patch": "@@ -1555,7 +1555,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, _, _) | ItemConst(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&ExplicitRscope, &t)\n+                        ccx.icx(&()).to_ty(&ElidableRscope::new(ty::ReStatic), &t)\n                     }\n                     ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n                         let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,"}, {"sha": "8d0829a4cffc335048cde5719a8321f7431aa209", "filename": "src/test/compile-fail/regions-in-consts.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aeb15acc73311ea4308e74a166ba3c0b261c810/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs?ref=8aeb15acc73311ea4308e74a166ba3c0b261c810", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-static c_y: &isize = &22; //~ ERROR missing lifetime specifier\n-static c_z: &'static isize = &22;\n-\n-fn main() {\n-}"}, {"sha": "1d8fc7fe111c035b3fb36f2b928c0db6d926148a", "filename": "src/test/compile-fail/rfc1623.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1623.rs?ref=022cb6d11d7d3529fc09283d058e66017dadeb8c", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+fn non_elidable<'a, 'b>(a: &'a u8, b: &'b u8) -> &'a u8 {\n+    a\n+}\n+\n+// the boundaries of elision\n+static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 = &(non_elidable as fn(&u8, &u8) -> &u8);\n+//~^ ERROR missing lifetime specifier [E0106]\n+\n+struct SomeStruct<'x, 'y, 'z: 'x> {\n+    foo: &'x Foo<'z>,\n+    bar: &'x Bar<'z>,\n+    f: &'y for<'a, 'b: 'a> Fn(&'a Foo<'b>) -> &'a Bar<'b>,\n+}\n+\n+fn id<T>(t: T) -> T {\n+    t\n+}\n+\n+static SOME_STRUCT: &SomeStruct = SomeStruct {\n+    foo: &Foo { bools: &[false, true] },\n+    bar: &Bar { bools: &[true, true] },\n+    f: &id,\n+};\n+\n+// very simple test for a 'static static with default lifetime\n+static STATIC_STR: &'static str = \"&'static str\";\n+const CONST_STR: &'static str = \"&'static str\";\n+\n+// this should be the same as without default:\n+static EXPLICIT_STATIC_STR: &'static str = \"&'static str\";\n+const EXPLICIT_CONST_STR: &'static str = \"&'static str\";\n+\n+// a function that elides to an unbound lifetime for both in- and output\n+fn id_u8_slice(arg: &[u8]) -> &[u8] {\n+    arg\n+}\n+\n+// one with a function, argument elided\n+static STATIC_SIMPLE_FN: &'static fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+const CONST_SIMPLE_FN: &'static fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+\n+// this should be the same as without elision\n+static STATIC_NON_ELIDED_fN: &'static for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+const CONST_NON_ELIDED_fN: &'static for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+\n+// another function that elides, each to a different unbound lifetime\n+fn multi_args(a: &u8, b: &u8, c: &u8) {}\n+\n+static STATIC_MULTI_FN: &'static fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+const CONST_MULTI_FN: &'static fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+\n+struct Foo<'a> {\n+    bools: &'a [bool],\n+}\n+\n+static STATIC_FOO: Foo<'static> = Foo { bools: &[true, false] };\n+const CONST_FOO: Foo<'static> = Foo { bools: &[true, false] };\n+\n+type Bar<'a> = Foo<'a>;\n+\n+static STATIC_BAR: Bar<'static> = Bar { bools: &[true, false] };\n+const CONST_BAR: Bar<'static> = Bar { bools: &[true, false] };\n+\n+type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n+\n+fn baz(e: &[u8]) -> Option<u8> {\n+    e.first().map(|x| *x)\n+}\n+\n+static STATIC_BAZ: &'static Baz<'static> = &(baz as Baz);\n+const CONST_BAZ: &'static Baz<'static> = &(baz as Baz);\n+\n+static BYTES: &'static [u8] = &[1, 2, 3];\n+\n+fn main() {\n+    let x = &[1u8, 2, 3];\n+    let y = x;\n+\n+    // this works, so lifetime < `'static` is valid\n+    assert_eq!(Some(1), STATIC_BAZ(y));\n+    assert_eq!(Some(1), CONST_BAZ(y));\n+\n+    let y = &[1u8, 2, 3];\n+\n+    STATIC_BAZ(BYTES); // BYTES has static lifetime\n+    CONST_BAZ(y); // interestingly this does not get reported\n+}"}, {"sha": "abdcc02de767f6d0bfbcd6274a75562edf11c174", "filename": "src/test/compile-fail/rfc1623.rs.bk", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Fcompile-fail%2Frfc1623.rs.bk", "raw_url": "https://github.com/rust-lang/rust/raw/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Fcompile-fail%2Frfc1623.rs.bk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1623.rs.bk?ref=022cb6d11d7d3529fc09283d058e66017dadeb8c", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+fn non_elidable<'a, 'b>(a: &'a u8, b: &'b u8) -> &'a u8 { a }\n+\n+// the boundaries of elision\n+static NON_ELIDABLE_FN : &fn(&u8, &u8) -> &u8 =\n+//~^ ERROR: missing lifetime specifier\n+        &(non_elidable as fn(&u8, &u8) -> &u8);\n+\n+struct SomeStruct<'x, 'y, 'z: 'x> {\n+    foo: &'x Foo<'z>,\n+    bar: &'x Bar<'z>,\n+    f: &'y for<'a, 'b: 'a> Fn(&'a Foo<'b>) -> &'a Bar<'b>,\n+}\n+\n+fn id<T>(t: T) -> T { t }\n+\n+static SOME_STRUCT : &SomeStruct = SomeStruct {\n+    foo: &Foo { bools: &[false, true] },\n+    bar: &Bar { bools: &[true, true] },\n+    f: &id,\n+};\n+\n+// very simple test for a 'static static with default lifetime\n+static STATIC_STR : &'static str = \"&'static str\";\n+const CONST_STR : &'static str = \"&'static str\";\n+\n+// this should be the same as without default:\n+static EXPLICIT_STATIC_STR : &'static str = \"&'static str\";\n+const EXPLICIT_CONST_STR : &'static str = \"&'static str\";\n+\n+// a function that elides to an unbound lifetime for both in- and output\n+fn id_u8_slice(arg: &[u8]) -> &[u8] { arg }\n+\n+// one with a function, argument elided\n+static STATIC_SIMPLE_FN : &'static fn(&[u8]) -> &[u8] =\n+        &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+const CONST_SIMPLE_FN : &'static fn(&[u8]) -> &[u8] =\n+        &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+\n+// this should be the same as without elision\n+static STATIC_NON_ELIDED_fN : &'static for<'a> fn(&'a [u8]) -> &'a [u8] =\n+        &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+const CONST_NON_ELIDED_fN : &'static for<'a> fn(&'a [u8]) -> &'a [u8] =\n+        &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+\n+// another function that elides, each to a different unbound lifetime\n+fn multi_args(a: &u8, b: &u8, c: &u8) { }\n+\n+static STATIC_MULTI_FN : &'static fn(&u8, &u8, &u8) =\n+        &(multi_args as fn(&u8, &u8, &u8));\n+const CONST_MULTI_FN : &'static fn(&u8, &u8, &u8) =\n+        &(multi_args as fn(&u8, &u8, &u8));\n+\n+struct Foo<'a> {\n+    bools: &'a [bool]\n+}\n+\n+static STATIC_FOO : Foo<'static> = Foo { bools: &[true, false] };\n+const CONST_FOO : Foo<'static> = Foo { bools: &[true, false] };\n+\n+type Bar<'a> = Foo<'a>;\n+\n+static STATIC_BAR : Bar<'static> = Bar { bools: &[true, false] };\n+const CONST_BAR : Bar<'static> = Bar { bools: &[true, false] };\n+\n+type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n+\n+fn baz(e: &[u8]) -> Option<u8> { e.first().map(|x| *x) }\n+\n+static STATIC_BAZ : &'static Baz<'static> = &(baz as Baz);\n+const CONST_BAZ : &'static Baz<'static> = &(baz as Baz);\n+\n+static BYTES : &'static [u8] = &[1, 2, 3];\n+\n+fn main() {\n+    let x = &[1u8, 2, 3];\n+    let y = x;\n+\n+    //this works, so lifetime < `'static` is valid\n+    assert_eq!(Some(1), STATIC_BAZ(y));\n+    assert_eq!(Some(1), CONST_BAZ(y));\n+\n+    let y = &[1u8, 2, 3];\n+    //^~ ERROR: borrowed values does not live long enough\n+    STATIC_BAZ(BYTES); // BYTES has static lifetime\n+    CONST_BAZ(y); // This forces static lifetime, which y has not\n+}"}, {"sha": "17453933c8abcdc35b87ca4a20a409d8ec817b8d", "filename": "src/test/run-pass/rfc1623.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Frun-pass%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Frun-pass%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1623.rs?ref=022cb6d11d7d3529fc09283d058e66017dadeb8c", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// very simple test for a 'static static with default lifetime\n+static STATIC_STR: &str = \"&'static str\";\n+const CONST_STR: &str = \"&'static str\";\n+\n+// this should be the same as without default:\n+static EXPLICIT_STATIC_STR: &'static str = \"&'static str\";\n+const EXPLICIT_CONST_STR: &'static str = \"&'static str\";\n+\n+// a function that elides to an unbound lifetime for both in- and output\n+fn id_u8_slice(arg: &[u8]) -> &[u8] {\n+    arg\n+}\n+\n+// one with a function, argument elided\n+static STATIC_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+const CONST_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+\n+// this should be the same as without elision\n+static STATIC_NON_ELIDED_fN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+const CONST_NON_ELIDED_fN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+\n+// another function that elides, each to a different unbound lifetime\n+fn multi_args(a: &u8, b: &u8, c: &u8) {}\n+\n+static STATIC_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+const CONST_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+\n+struct Foo<'a> {\n+    bools: &'a [bool],\n+}\n+\n+static STATIC_FOO: Foo = Foo { bools: &[true, false] };\n+const CONST_FOO: Foo = Foo { bools: &[true, false] };\n+\n+type Bar<'a> = Foo<'a>;\n+\n+static STATIC_BAR: Bar = Bar { bools: &[true, false] };\n+const CONST_BAR: Bar = Bar { bools: &[true, false] };\n+\n+type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n+\n+fn baz(e: &[u8]) -> Option<u8> {\n+    e.first().map(|x| *x)\n+}\n+\n+static STATIC_BAZ: &Baz = &(baz as Baz);\n+const CONST_BAZ: &Baz = &(baz as Baz);\n+\n+static BYTES: &[u8] = &[1, 2, 3];\n+\n+fn main() {\n+    // make sure that the lifetime is actually elided (and not defaulted)\n+    let x = &[1u8, 2, 3];\n+    STATIC_SIMPLE_FN(x);\n+    CONST_SIMPLE_FN(x);\n+\n+    STATIC_BAZ(BYTES); // neees static lifetime\n+    CONST_BAZ(BYTES);\n+\n+    // make sure this works with different lifetimes\n+    let a = &1;\n+    {\n+        let b = &2;\n+        let c = &3;\n+        CONST_MULTI_FN(a, b, c);\n+    }\n+}"}, {"sha": "0915118ca27c077513280ee32f601ce5c27936e6", "filename": "src/test/run-pass/rfc1623.rs.bk", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Frun-pass%2Frfc1623.rs.bk", "raw_url": "https://github.com/rust-lang/rust/raw/022cb6d11d7d3529fc09283d058e66017dadeb8c/src%2Ftest%2Frun-pass%2Frfc1623.rs.bk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1623.rs.bk?ref=022cb6d11d7d3529fc09283d058e66017dadeb8c", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// very simple test for a 'static static with default lifetime\n+static STATIC_STR : &str = \"&'static str\";\n+const CONST_STR : &str = \"&'static str\";\n+\n+// this should be the same as without default:\n+static EXPLICIT_STATIC_STR : &'static str = \"&'static str\";\n+const EXPLICIT_CONST_STR : &'static str = \"&'static str\";\n+\n+// a function that elides to an unbound lifetime for both in- and output\n+fn id_u8_slice(arg: &[u8]) -> &[u8] { arg }\n+\n+// one with a function, argument elided\n+static STATIC_SIMPLE_FN : &fn(&[u8]) -> &[u8] =\n+        &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+const CONST_SIMPLE_FN : &fn(&[u8]) -> &[u8] =\n+        &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+\n+// this should be the same as without elision\n+static STATIC_NON_ELIDED_fN : &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+        &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+const CONST_NON_ELIDED_fN : &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+        &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+\n+// another function that elides, each to a different unbound lifetime\n+fn multi_args(a: &u8, b: &u8, c: &u8) { }\n+\n+static STATIC_MULTI_FN : &fn(&u8, &u8, &u8) =\n+        &(multi_args as fn(&u8, &u8, &u8));\n+const CONST_MULTI_FN : &fn(&u8, &u8, &u8) =\n+        &(multi_args as fn(&u8, &u8, &u8));\n+\n+struct Foo<'a> {\n+    bools: &'a [bool]\n+}\n+\n+static STATIC_FOO : Foo = Foo { bools: &[true, false] };\n+const CONST_FOO : Foo = Foo { bools: &[true, false] };\n+\n+type Bar<'a> = Foo<'a>;\n+\n+static STATIC_BAR : Bar = Bar { bools: &[true, false] };\n+const CONST_BAR : Bar = Bar { bools: &[true, false] };\n+\n+type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n+\n+fn baz(e: &[u8]) -> Option<u8> { e.first().map(|x| *x) }\n+\n+static STATIC_BAZ : &Baz = &(baz as Baz);\n+const CONST_BAZ : &Baz = &(baz as Baz);\n+\n+static BYTES : &[u8] = &[1, 2, 3];\n+\n+fn main() {\n+    // make sure that the lifetime is actually elided (and not defaulted)\n+    let x = &[1u8, 2, 3];\n+    STATIC_SIMPLE_FN(x);\n+    CONST_SIMPLE_FN(x);\n+\n+    STATIC_BAZ(BYTES); // neees static lifetime\n+    CONST_BAZ(BYTES);\n+\n+    // make sure this works with different lifetimes\n+    let a = &1;\n+    {\n+        let b = &2;\n+        let c = &3;\n+        CONST_MULTI_FN(a, b, c);\n+    }\n+}"}]}