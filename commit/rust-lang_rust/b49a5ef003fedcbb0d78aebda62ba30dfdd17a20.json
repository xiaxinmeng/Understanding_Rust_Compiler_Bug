{"sha": "b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OWE1ZWYwMDNmZWRjYmIwZDc4YWViZGE2MmJhMzBkZmRkMTdhMjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-06T22:08:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-06T22:08:01Z"}, "message": "Auto merge of #23857 - phildawes:libsyntax_nopanic, r=nikomatsakis\n\nHello! \r\n\r\nI've been working towards a libsyntax without panics. See:\r\nhttp://internals.rust-lang.org/t/changing-libsyntax-to-use-result-instead-of-panic/1670\r\n\r\nThis patch changes the internals of parser.rs to use Result<> rather than panicing. It keeps the following old-style panicing functions as a facade:\r\nparse_expr, parse_item, parse_pat, parse_arm, parse_ty, parse_stmt\r\n\r\nI left these functions because I wasn't sure what to do about the quote_* macros or how many syntax-extensions would break if these and quoting macros returned Result.\r\n\r\nThe gyst of the rest of the patch is:\r\n\r\n - Functions in parse/parser.rs return PResult<> rather than panicing\r\n - Other functions in libsyntax call panic! explicitly if they rely on panicing behaviour.\r\n - I added a macro 'panictry!()' to act as scaffolding for callers while converting panicing functions. (This does the same as 'unwrap()' but is easier to grep for and turn into try!()).\r\n\r\nAm I on the right track?  I'd quite like to get something merged soon as keeping this rebased in the face of libsyntax changes is a lot of work. Please let me know what changes you'd like to see to make this happen.\r\n\r\nThanks!, Phil", "tree": {"sha": "d99b438e04f810e098c79b634ed6d730d2dbcb4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d99b438e04f810e098c79b634ed6d730d2dbcb4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "html_url": "https://github.com/rust-lang/rust/commit/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aab8669ddad0432ef7279cc7f7b0b20d32785314", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab8669ddad0432ef7279cc7f7b0b20d32785314", "html_url": "https://github.com/rust-lang/rust/commit/aab8669ddad0432ef7279cc7f7b0b20d32785314"}, {"sha": "e3427c3c341fcd15cbac783bf8dad7276422c97a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3427c3c341fcd15cbac783bf8dad7276422c97a", "html_url": "https://github.com/rust-lang/rust/commit/e3427c3c341fcd15cbac783bf8dad7276422c97a"}], "stats": {"total": 2715, "additions": 1397, "deletions": 1318}, "files": [{"sha": "a2028c5ae722707c4f5bd08d6b492283a3315ff3", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -528,7 +528,10 @@ impl<'a> CrateReader<'a> {\n                                                               source_name.clone(),\n                                                               body);\n                 let lo = p.span.lo;\n-                let body = p.parse_all_token_trees();\n+                let body = match p.parse_all_token_trees() {\n+                    Ok(body) => body,\n+                    Err(err) => panic!(err),\n+                };\n                 let span = mk_sp(lo, p.last_span.hi);\n                 p.abort_if_errors();\n                 macros.push(ast::MacroDef {"}, {"sha": "452840310aa41eb5ccffd6b3e5981fc0a25a0e16", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -68,13 +68,13 @@ impl Session {\n         if self.opts.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.diagnostic().span_fatal(sp, msg)\n+        panic!(self.diagnostic().span_fatal(sp, msg))\n     }\n     pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n         if self.opts.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.diagnostic().span_fatal_with_code(sp, msg, code)\n+        panic!(self.diagnostic().span_fatal_with_code(sp, msg, code))\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n         if self.opts.treat_err_as_bug {"}, {"sha": "29b0716c8174fbebdab5bf754813e0ccf1e504b0", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -503,8 +503,8 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n         let name = meta.name();\n \n         if !set.insert(name.clone()) {\n-            diagnostic.span_fatal(meta.span,\n-                                  &format!(\"duplicate meta item `{}`\", name));\n+            panic!(diagnostic.span_fatal(meta.span,\n+                                  &format!(\"duplicate meta item `{}`\", name)));\n         }\n     }\n }"}, {"sha": "8fe23a3c8e82664bf1c053f46622f2be6fcae962", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -68,10 +68,11 @@ pub trait Emitter {\n                    sp: RenderSpan, msg: &str, lvl: Level);\n }\n \n-/// This structure is used to signify that a task has panicked with a fatal error\n-/// from the diagnostics. You can use this with the `Any` trait to figure out\n-/// how a rustc task died (if so desired).\n+/// Used as a return value to signify a fatal error occurred. (It is also\n+/// used as the argument to panic at the moment, but that will eventually\n+/// not be true.)\n #[derive(Copy, Clone)]\n+#[must_use]\n pub struct FatalError;\n \n /// Signifies that the compiler died with an explicit call to `.bug`\n@@ -88,13 +89,13 @@ pub struct SpanHandler {\n }\n \n impl SpanHandler {\n-    pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n         self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n-        panic!(FatalError);\n+        return FatalError;\n     }\n-    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n         self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Fatal);\n-        panic!(FatalError);\n+        return FatalError;\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Error);"}, {"sha": "f2b45d89f73501752492c10aa179203bbe796094", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -91,16 +91,16 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::ModSep {\n \n                     if outputs.len() != 0 {\n-                        p.eat(&token::Comma);\n+                        panictry!(p.eat(&token::Comma));\n                     }\n \n-                    let (constraint, _str_style) = p.parse_str();\n+                    let (constraint, _str_style) = panictry!(p.parse_str());\n \n                     let span = p.last_span;\n \n-                    p.expect(&token::OpenDelim(token::Paren));\n+                    panictry!(p.expect(&token::OpenDelim(token::Paren)));\n                     let out = p.parse_expr();\n-                    p.expect(&token::CloseDelim(token::Paren));\n+                    panictry!(p.expect(&token::CloseDelim(token::Paren)));\n \n                     // Expands a read+write operand into two operands.\n                     //\n@@ -131,20 +131,20 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::ModSep {\n \n                     if inputs.len() != 0 {\n-                        p.eat(&token::Comma);\n+                        panictry!(p.eat(&token::Comma));\n                     }\n \n-                    let (constraint, _str_style) = p.parse_str();\n+                    let (constraint, _str_style) = panictry!(p.parse_str());\n \n                     if constraint.starts_with(\"=\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '='\");\n                     } else if constraint.starts_with(\"+\") {\n                         cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n-                    p.expect(&token::OpenDelim(token::Paren));\n+                    panictry!(p.expect(&token::OpenDelim(token::Paren)));\n                     let input = p.parse_expr();\n-                    p.expect(&token::CloseDelim(token::Paren));\n+                    panictry!(p.expect(&token::CloseDelim(token::Paren)));\n \n                     inputs.push((constraint, input));\n                 }\n@@ -155,10 +155,10 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::ModSep {\n \n                     if clobs.len() != 0 {\n-                        p.eat(&token::Comma);\n+                        panictry!(p.eat(&token::Comma));\n                     }\n \n-                    let (s, _str_style) = p.parse_str();\n+                    let (s, _str_style) = panictry!(p.parse_str());\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.last_span, \"expected a clobber, found an option\");\n@@ -167,7 +167,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n             }\n             Options => {\n-                let (option, _str_style) = p.parse_str();\n+                let (option, _str_style) = panictry!(p.parse_str());\n \n                 if option == \"volatile\" {\n                     // Indicates that the inline assembly has side effects\n@@ -182,7 +182,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n \n                 if p.token == token::Comma {\n-                    p.eat(&token::Comma);\n+                    panictry!(p.eat(&token::Comma));\n                 }\n             }\n             StateNone => ()\n@@ -194,12 +194,12 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             match (&p.token, state.next(), state.next().next()) {\n                 (&token::Colon, StateNone, _)   |\n                 (&token::ModSep, _, StateNone) => {\n-                    p.bump();\n+                    panictry!(p.bump());\n                     break 'statement;\n                 }\n                 (&token::Colon, st, _)   |\n                 (&token::ModSep, _, st) => {\n-                    p.bump();\n+                    panictry!(p.bump());\n                     state = st;\n                 }\n                 (&token::Eof, _, _) => break 'statement,"}, {"sha": "80ee92608a520e965598a6ec62177a9356a5a4b1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -652,9 +652,9 @@ impl<'a> ExtCtxt<'a> {\n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n         self.recursion_count += 1;\n         if self.recursion_count > self.ecfg.recursion_limit {\n-            self.span_fatal(ei.call_site,\n+            panic!(self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name));\n+                                    ei.callee.name)));\n         }\n \n         let mut call_site = ei.call_site;\n@@ -699,7 +699,7 @@ impl<'a> ExtCtxt<'a> {\n     ///   value doesn't have to match anything)\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.print_backtrace();\n-        self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n+        panic!(self.parse_sess.span_diagnostic.span_fatal(sp, msg));\n     }\n \n     /// Emit `msg` attached to `sp`, without immediately stopping\n@@ -817,7 +817,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n         es.push(cx.expander().fold_expr(p.parse_expr()));\n-        if p.eat(&token::Comma) {\n+        if panictry!(p.eat(&token::Comma)){\n             continue;\n         }\n         if p.token != token::Eof {"}, {"sha": "8af7fb7b268afad0326211321d7405697ea7253b", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -29,7 +29,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n     let mut p = cx.new_parser_from_tts(tts);\n     let cfg = p.parse_meta_item();\n \n-    if !p.eat(&token::Eof) {\n+    if !panictry!(p.eat(&token::Eof)){\n         cx.span_err(sp, \"expected 1 cfg-pattern\");\n         return DummyResult::expr(sp);\n     }"}, {"sha": "f13047d3725ec7c40586ee55b73caad7eeb13911", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -1684,7 +1684,7 @@ mod test {\n \n     fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::new_parse_sess();\n-        let crate_ast = string_to_parser(&ps, crate_str).parse_crate_mod();\n+        let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n         expand_crate(&ps,test_ecfg(),vec!(),vec!(),crate_ast)\n     }"}, {"sha": "1d99a475b3286c9a9b65786ffc7ccd9cb11e7093", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -92,7 +92,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let fmtstr = p.parse_expr();\n     let mut named = false;\n     while p.token != token::Eof {\n-        if !p.eat(&token::Comma) {\n+        if !panictry!(p.eat(&token::Comma)) {\n             ecx.span_err(sp, \"expected token: `,`\");\n             return None;\n         }\n@@ -101,7 +101,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             named = true;\n             let ident = match p.token {\n                 token::Ident(i, _) => {\n-                    p.bump();\n+                    panictry!(p.bump());\n                     i\n                 }\n                 _ if named => {\n@@ -120,7 +120,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let interned_name = token::get_ident(ident);\n             let name = &interned_name[..];\n \n-            p.expect(&token::Eq);\n+            panictry!(p.expect(&token::Eq));\n             let e = p.parse_expr();\n             match names.get(name) {\n                 None => {}"}, {"sha": "5776fa997407687b4902c0c9ba3309684061c846", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -781,11 +781,11 @@ fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[ast::TokenTree])\n     p.quote_depth += 1;\n \n     let cx_expr = p.parse_expr();\n-    if !p.eat(&token::Comma) {\n-        p.fatal(\"expected token `,`\");\n+    if !panictry!(p.eat(&token::Comma)) {\n+        panic!(p.fatal(\"expected token `,`\"));\n     }\n \n-    let tts = p.parse_all_token_trees();\n+    let tts = panictry!(p.parse_all_token_trees());\n     p.abort_if_errors();\n \n     (cx_expr, tts)"}, {"sha": "a4c2d2dc030687f282a455434c9b9166361d526a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -117,11 +117,11 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n             while self.p.token != token::Eof {\n                 match self.p.parse_item() {\n                     Some(item) => ret.push(item),\n-                    None => self.p.span_fatal(\n+                    None => panic!(self.p.span_fatal(\n                         self.p.span,\n                         &format!(\"expected item, found `{}`\",\n                                  self.p.this_token_to_string())\n-                    )\n+                    ))\n                 }\n             }\n             Some(ret)"}, {"sha": "4e0b74401a2668fa1add306c64ac1a4bab153b61", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -226,10 +226,10 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                     }\n                     Occupied(..) => {\n                         let string = token::get_ident(bind_name);\n-                        p_s.span_diagnostic\n+                        panic!(p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        &format!(\"duplicated bind name: {}\",\n-                                               &string))\n+                                               &string)))\n                     }\n                 }\n             }\n@@ -260,10 +260,10 @@ pub fn parse_or_else(sess: &ParseSess,\n     match parse(sess, cfg, rdr, &ms[..]) {\n         Success(m) => m,\n         Failure(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, &str[..])\n+            panic!(sess.span_diagnostic.span_fatal(sp, &str[..]))\n         }\n         Error(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, &str[..])\n+            panic!(sess.span_diagnostic.span_fatal(sp, &str[..]))\n         }\n     }\n }\n@@ -512,46 +512,46 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n             p.quote_depth += 1; //but in theory, non-quoted tts might be useful\n-            let res = token::NtTT(P(p.parse_token_tree()));\n+            let res = token::NtTT(P(panictry!(p.parse_token_tree())));\n             p.quote_depth -= 1;\n             return res;\n         }\n         _ => {}\n     }\n     // check at the beginning and the parser checks after each bump\n-    p.check_unknown_macro_variable();\n+    panictry!(p.check_unknown_macro_variable());\n     match name {\n       \"item\" => match p.parse_item() {\n         Some(i) => token::NtItem(i),\n-        None => p.fatal(\"expected an item keyword\")\n+        None => panic!(p.fatal(\"expected an item keyword\"))\n       },\n-      \"block\" => token::NtBlock(p.parse_block()),\n+      \"block\" => token::NtBlock(panictry!(p.parse_block())),\n       \"stmt\" => match p.parse_stmt() {\n         Some(s) => token::NtStmt(s),\n-        None => p.fatal(\"expected a statement\")\n+        None => panic!(p.fatal(\"expected a statement\"))\n       },\n       \"pat\" => token::NtPat(p.parse_pat()),\n       \"expr\" => token::NtExpr(p.parse_expr()),\n       \"ty\" => token::NtTy(p.parse_ty()),\n       // this could be handled like a token, since it is one\n       \"ident\" => match p.token {\n-        token::Ident(sn,b) => { p.bump(); token::NtIdent(box sn,b) }\n+        token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(box sn,b) }\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n-            p.fatal(&format!(\"expected ident, found {}\",\n-                             &token_str[..]))\n+            panic!(p.fatal(&format!(\"expected ident, found {}\",\n+                             &token_str[..])))\n         }\n       },\n       \"path\" => {\n-        token::NtPath(box p.parse_path(LifetimeAndTypesWithoutColons))\n+        token::NtPath(box panictry!(p.parse_path(LifetimeAndTypesWithoutColons)))\n       }\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       _ => {\n-          p.span_fatal_help(sp,\n+          panic!(p.span_fatal_help(sp,\n                             &format!(\"invalid fragment specifier `{}`\", name),\n                             \"valid fragment specifiers are `ident`, `block`, \\\n                              `stmt`, `expr`, `pat`, `ty`, `path`, `meta`, `tt` \\\n-                             and `item`\")\n+                             and `item`\"))\n       }\n     }\n }"}, {"sha": "250ba0442babeee9b45ca5d6172f392f7b098ec7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -41,7 +41,7 @@ impl<'a> ParserAnyMacro<'a> {\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();\n         if allow_semi && parser.token == token::Semi {\n-            parser.bump()\n+            panictry!(parser.bump())\n         }\n         if parser.token != token::Eof {\n             let token_str = parser.this_token_to_string();\n@@ -81,7 +81,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => ret.push(parser.parse_impl_item())\n+                _ => ret.push(panictry!(parser.parse_impl_item()))\n             }\n         }\n         self.ensure_complete_parse(false);\n@@ -142,7 +142,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n           MatchedNonterminal(NtTT(ref lhs_tt)) => {\n             let lhs_tt = match **lhs_tt {\n                 TtDelimited(_, ref delim) => &delim.tts[..],\n-                _ => cx.span_fatal(sp, \"malformed macro lhs\")\n+                _ => panic!(cx.span_fatal(sp, \"malformed macro lhs\"))\n             };\n \n             match TokenTree::parse(cx, lhs_tt, arg) {\n@@ -153,7 +153,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                         match **tt {\n                             // ignore delimiters\n                             TtDelimited(_, ref delimed) => delimed.tts.clone(),\n-                            _ => cx.span_fatal(sp, \"macro rhs must be delimited\"),\n+                            _ => panic!(cx.span_fatal(sp, \"macro rhs must be delimited\")),\n                         }\n                     },\n                     _ => cx.span_bug(sp, \"bad thing in rhs\")\n@@ -164,7 +164,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.check_unknown_macro_variable();\n+                panictry!(p.check_unknown_macro_variable());\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return box ParserAnyMacro {\n@@ -175,13 +175,13 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n               },\n-              Error(sp, ref msg) => cx.span_fatal(sp, &msg[..])\n+              Error(sp, ref msg) => panic!(cx.span_fatal(sp, &msg[..]))\n             }\n           }\n           _ => cx.bug(\"non-matcher found in parsed lhses\")\n         }\n     }\n-    cx.span_fatal(best_fail_spot, &best_fail_msg[..]);\n+    panic!(cx.span_fatal(best_fail_spot, &best_fail_msg[..]));\n }\n \n // Note that macro-by-example's input is also matched against a token tree:"}, {"sha": "e39b46a2d3e11962aa90ed8af91f6e61e9c849f8", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -247,22 +247,22 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 match lockstep_iter_size(&TtSequence(sp, seq.clone()),\n                                          r) {\n                     LisUnconstrained => {\n-                        r.sp_diag.span_fatal(\n+                        panic!(r.sp_diag.span_fatal(\n                             sp.clone(), /* blame macro writer */\n                             \"attempted to repeat an expression \\\n                              containing no syntax \\\n-                             variables matched as repeating at this depth\");\n+                             variables matched as repeating at this depth\"));\n                     }\n                     LisContradiction(ref msg) => {\n                         // FIXME #2887 blame macro invoker instead\n-                        r.sp_diag.span_fatal(sp.clone(), &msg[..]);\n+                        panic!(r.sp_diag.span_fatal(sp.clone(), &msg[..]));\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n                             if seq.op == ast::OneOrMore {\n                                 // FIXME #2887 blame invoker\n-                                r.sp_diag.span_fatal(sp.clone(),\n-                                                     \"this must repeat at least once\");\n+                                panic!(r.sp_diag.span_fatal(sp.clone(),\n+                                                     \"this must repeat at least once\"));\n                             }\n \n                             r.stack.last_mut().unwrap().idx += 1;\n@@ -306,10 +306,10 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                 return ret_val;\n                             }\n                             MatchedSeq(..) => {\n-                                r.sp_diag.span_fatal(\n+                                panic!(r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n                                     &format!(\"variable '{:?}' is still repeating at this depth\",\n-                                            token::get_ident(ident)));\n+                                            token::get_ident(ident))));\n                             }\n                         }\n                     }"}, {"sha": "bf95daf87555d9673bc003246216110f608b9b50", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -50,6 +50,21 @@ extern crate libc;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+// A variant of 'try!' that panics on Err(FatalError). This is used as a\n+// crutch on the way towards a non-panic!-prone parser. It should be used\n+// for fatal parsing errors; eventually we plan to convert all code using\n+// panictry to just use normal try\n+macro_rules! panictry {\n+    ($e:expr) => ({\n+        use std::result::Result::{Ok, Err};\n+        use diagnostic::FatalError;\n+        match $e {\n+            Ok(e) => e,\n+            Err(FatalError) => panic!(FatalError)\n+        }\n+    })\n+}\n+\n pub mod util {\n     pub mod interner;\n     #[cfg(test)]"}, {"sha": "18588c59357b29c9d0e056474ee61caf3bf408cf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -45,10 +45,10 @@ impl<'a> ParserAttr for Parser<'a> {\n                     self.span.hi\n                 );\n                 if attr.node.style != ast::AttrOuter {\n-                  self.fatal(\"expected outer comment\");\n+                  panic!(self.fatal(\"expected outer comment\"));\n                 }\n                 attrs.push(attr);\n-                self.bump();\n+                panictry!(self.bump());\n               }\n               _ => break\n             }\n@@ -66,11 +66,11 @@ impl<'a> ParserAttr for Parser<'a> {\n         let (span, value, mut style) = match self.token {\n             token::Pound => {\n                 let lo = self.span.lo;\n-                self.bump();\n+                panictry!(self.bump());\n \n                 if permit_inner { self.expected_tokens.push(TokenType::Token(token::Not)); }\n                 let style = if self.token == token::Not {\n-                    self.bump();\n+                    panictry!(self.bump());\n                     if !permit_inner {\n                         let span = self.span;\n                         self.span_err(span,\n@@ -84,21 +84,21 @@ impl<'a> ParserAttr for Parser<'a> {\n                     ast::AttrOuter\n                 };\n \n-                self.expect(&token::OpenDelim(token::Bracket));\n+                panictry!(self.expect(&token::OpenDelim(token::Bracket)));\n                 let meta_item = self.parse_meta_item();\n                 let hi = self.span.hi;\n-                self.expect(&token::CloseDelim(token::Bracket));\n+                panictry!(self.expect(&token::CloseDelim(token::Bracket)));\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(&format!(\"expected `#`, found `{}`\", token_str));\n+                panic!(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n             }\n         };\n \n         if permit_inner && self.token == token::Semi {\n-            self.bump();\n+            panictry!(self.bump());\n             self.span_warn(span, \"this inner attribute syntax is deprecated. \\\n                            The new syntax is `#![foo]`, with a bang and no semicolon\");\n             style = ast::AttrInner;\n@@ -142,7 +142,7 @@ impl<'a> ParserAttr for Parser<'a> {\n                                                          lo, hi);\n                     if attr.node.style == ast::AttrInner {\n                         attrs.push(attr);\n-                        self.bump();\n+                        panictry!(self.bump());\n                     } else {\n                         break;\n                     }\n@@ -166,19 +166,19 @@ impl<'a> ParserAttr for Parser<'a> {\n \n         match nt_meta {\n             Some(meta) => {\n-                self.bump();\n+                panictry!(self.bump());\n                 return meta;\n             }\n             None => {}\n         }\n \n         let lo = self.span.lo;\n-        let ident = self.parse_ident();\n+        let ident = panictry!(self.parse_ident());\n         let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::Eq => {\n-                self.bump();\n-                let lit = self.parse_lit();\n+                panictry!(self.bump());\n+                let lit = panictry!(self.parse_lit());\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n@@ -206,10 +206,10 @@ impl<'a> ParserAttr for Parser<'a> {\n \n     /// matches meta_seq = ( COMMASEP(meta_item) )\n     fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n-        self.parse_seq(&token::OpenDelim(token::Paren),\n+        panictry!(self.parse_seq(&token::OpenDelim(token::Paren),\n                        &token::CloseDelim(token::Paren),\n                        seq_sep_trailing_allowed(token::Comma),\n-                       |p| p.parse_meta_item()).node\n+                       |p| Ok(p.parse_meta_item()))).node\n     }\n \n     fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>> {"}, {"sha": "22b7d5c9f1d32301d8d32ceb7eb7fbeb3073d29e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -116,7 +116,7 @@ impl<'a> Reader for TtReader<'a> {\n         r\n     }\n     fn fatal(&self, m: &str) -> ! {\n-        self.sp_diag.span_fatal(self.cur_span, m);\n+        panic!(self.sp_diag.span_fatal(self.cur_span, m));\n     }\n     fn err(&self, m: &str) {\n         self.sp_diag.span_err(self.cur_span, m);\n@@ -181,7 +181,7 @@ impl<'a> StringReader<'a> {\n \n     /// Report a fatal lexical error with a given span.\n     pub fn fatal_span(&self, sp: Span, m: &str) -> ! {\n-        self.span_diagnostic.span_fatal(sp, m)\n+        panic!(self.span_diagnostic.span_fatal(sp, m))\n     }\n \n     /// Report a lexical error with a given span."}, {"sha": "226e2037b2fbb38c01264779e40a62d91b31d9c3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -12,11 +12,12 @@\n \n use ast;\n use codemap::{Span, CodeMap, FileMap};\n-use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto};\n+use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto, FatalError};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n use ptr::P;\n \n+\n use std::cell::{Cell, RefCell};\n use std::fs::File;\n use std::io::Read;\n@@ -27,6 +28,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n \n+pub type PResult<T> = Result<T, FatalError>;\n+\n #[macro_use]\n pub mod parser;\n \n@@ -88,7 +91,7 @@ pub fn parse_crate_from_file(\n     cfg: ast::CrateConfig,\n     sess: &ParseSess\n ) -> ast::Crate {\n-    new_parser_from_file(sess, cfg, input).parse_crate_mod()\n+    panictry!(new_parser_from_file(sess, cfg, input).parse_crate_mod())\n     // why is there no p.abort_if_errors here?\n }\n \n@@ -109,7 +112,7 @@ pub fn parse_crate_from_source_str(name: String,\n                                            cfg,\n                                            name,\n                                            source);\n-    maybe_aborted(p.parse_crate_mod(),p)\n+    maybe_aborted(panictry!(p.parse_crate_mod()),p)\n }\n \n pub fn parse_crate_attrs_from_source_str(name: String,\n@@ -182,7 +185,7 @@ pub fn parse_tts_from_source_str(name: String,\n     );\n     p.quote_depth += 1;\n     // right now this is re-creating the token trees from ... token trees.\n-    maybe_aborted(p.parse_all_token_trees(),p)\n+    maybe_aborted(panictry!(p.parse_all_token_trees()),p)\n }\n \n // Note: keep in sync with `with_hygiene::new_parser_from_source_str`\n@@ -245,7 +248,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     -> Rc<FileMap> {\n     let err = |msg: &str| {\n         match spanopt {\n-            Some(sp) => sess.span_diagnostic.span_fatal(sp, msg),\n+            Some(sp) => panic!(sess.span_diagnostic.span_fatal(sp, msg)),\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n@@ -286,7 +289,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     let cfg = Vec::new();\n     let srdr = lexer::StringReader::new(&sess.span_diagnostic, filemap);\n     let mut p1 = Parser::new(sess, cfg, box srdr);\n-    p1.parse_all_token_trees()\n+    panictry!(p1.parse_all_token_trees())\n }\n \n /// Given tts and cfg, produce a parser\n@@ -295,7 +298,7 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n     let mut p = Parser::new(sess, cfg, box trdr);\n-    p.check_unknown_macro_variable();\n+    panictry!(p.check_unknown_macro_variable());\n     p\n }\n \n@@ -325,7 +328,7 @@ pub mod with_hygiene {\n         );\n         p.quote_depth += 1;\n         // right now this is re-creating the token trees from ... token trees.\n-        maybe_aborted(p.parse_all_token_trees(),p)\n+        maybe_aborted(panictry!(p.parse_all_token_trees()),p)\n     }\n \n     // Note: keep this in sync with `super::new_parser_from_source_str` until\n@@ -358,7 +361,7 @@ pub mod with_hygiene {\n         let cfg = Vec::new();\n         let srdr = make_reader(&sess.span_diagnostic, filemap);\n         let mut p1 = Parser::new(sess, cfg, box srdr);\n-        p1.parse_all_token_trees()\n+        panictry!(p1.parse_all_token_trees())\n     }\n }\n \n@@ -964,7 +967,7 @@ mod test {\n     #[test] fn parse_ident_pat () {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n-        assert!(parser.parse_pat()\n+        assert!(panictry!(parser.parse_pat_nopanic())\n                 == P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::PatIdent(ast::BindByValue(ast::MutImmutable),"}, {"sha": "3b21b5059daa1fb78c6d9042b7094663a0bb9b66", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -100,7 +100,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n     fn eat_obsolete_ident(&mut self, ident: &str) -> bool {\n         if self.is_obsolete_ident(ident) {\n-            self.bump();\n+            panictry!(self.bump());\n             true\n         } else {\n             false"}, {"sha": "272bb5f65067665e3e7aa5302582ae44b89670b1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1275, "deletions": 1219, "changes": 2494, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20"}, {"sha": "a3cfb647853d23f01c0bf910d516182efdb22f60", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -125,7 +125,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             match i.node {\n                 ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n-                    diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\");\n+                    panic!(diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\"));\n                 }\n                 _ => {\n                     debug!(\"this is a test function\");"}, {"sha": "c6646fe93a21bb1902665efb5acb08fff73aef46", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -44,7 +44,7 @@ fn with_error_checking_parse<T, F>(s: String, f: F) -> T where\n /// Parse a string, return a crate.\n pub fn string_to_crate (source_str : String) -> ast::Crate {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_crate_mod()\n+        panictry!(p.parse_crate_mod())\n     })\n }\n "}, {"sha": "99e0333ee29856f52ce5af6651d1019fcb67e02c", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "patch": "@@ -17,6 +17,7 @@ extern crate syntax;\n \n use syntax::ext::base::ExtCtxt;\n use syntax::ptr::P;\n+use syntax::parse::PResult;\n \n fn syntax_extension(cx: &ExtCtxt) {\n     let e_toks : Vec<syntax::ast::TokenTree> = quote_tokens!(cx, 1 + 2);"}]}