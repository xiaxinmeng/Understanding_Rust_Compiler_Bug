{"sha": "e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "node_id": "C_kwDOAAsO6NoAKGU3Zjk1YWNlMDhmZWNmYjk3NGNiYjJkNDg2ZTRjNzkyMGE2MDEwY2E", "commit": {"author": {"name": "Yoshiki Matsuda", "email": "myskjp@gmail.com", "date": "2022-04-25T11:58:30Z"}, "committer": {"name": "Yoshiki Matsuda", "email": "myskjp@gmail.com", "date": "2022-07-02T13:51:41Z"}, "message": "use rustc_serialize::opaque::FileEncoder", "tree": {"sha": "bb8f3f6091727f5d307c002723c98d0f268c253f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb8f3f6091727f5d307c002723c98d0f268c253f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "html_url": "https://github.com/rust-lang/rust/commit/e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/comments", "author": {"login": "m-ysk", "id": 47472854, "node_id": "MDQ6VXNlcjQ3NDcyODU0", "avatar_url": "https://avatars.githubusercontent.com/u/47472854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ysk", "html_url": "https://github.com/m-ysk", "followers_url": "https://api.github.com/users/m-ysk/followers", "following_url": "https://api.github.com/users/m-ysk/following{/other_user}", "gists_url": "https://api.github.com/users/m-ysk/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ysk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ysk/subscriptions", "organizations_url": "https://api.github.com/users/m-ysk/orgs", "repos_url": "https://api.github.com/users/m-ysk/repos", "events_url": "https://api.github.com/users/m-ysk/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ysk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ysk", "id": 47472854, "node_id": "MDQ6VXNlcjQ3NDcyODU0", "avatar_url": "https://avatars.githubusercontent.com/u/47472854?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ysk", "html_url": "https://github.com/m-ysk", "followers_url": "https://api.github.com/users/m-ysk/followers", "following_url": "https://api.github.com/users/m-ysk/following{/other_user}", "gists_url": "https://api.github.com/users/m-ysk/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ysk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ysk/subscriptions", "organizations_url": "https://api.github.com/users/m-ysk/orgs", "repos_url": "https://api.github.com/users/m-ysk/repos", "events_url": "https://api.github.com/users/m-ysk/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ysk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88", "html_url": "https://github.com/rust-lang/rust/commit/5d9ba49bb9ca0e8c2e563ca499a5e54e90c9fb88"}], "stats": {"total": 84, "additions": 46, "deletions": 38}, "files": [{"sha": "e3b6cb99b637305f7887fbdce47cb83c10b8de2d", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "patch": "@@ -55,27 +55,30 @@ pub fn encode_and_write_metadata(\n         .max()\n         .unwrap_or(MetadataKind::None);\n \n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n+    // To avoid races with another rustc process scanning the output directory,\n+    // we need to write the file somewhere else and atomically move it to its\n+    // final destination, with an `fs::rename` call. In order for the rename to\n+    // always succeed, the temporary file needs to be on the same filesystem,\n+    // which is why we create it inside the output directory specifically.\n+    let metadata_tmpdir = TempFileBuilder::new()\n+        .prefix(\"rmeta\")\n+        .tempdir_in(out_filename.parent().unwrap_or_else(|| Path::new(\"\")))\n+        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+    let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n+    let metadata_filename = metadata_tmpdir.as_ref().join(METADATA_FILENAME);\n     let metadata = match metadata_kind {\n         MetadataKind::None => EncodedMetadata::new(),\n-        MetadataKind::Uncompressed | MetadataKind::Compressed => encode_metadata(tcx),\n+        MetadataKind::Uncompressed | MetadataKind::Compressed => {\n+            encode_metadata(tcx, metadata_filename)\n+        }\n     };\n \n     let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n \n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     if need_metadata_file {\n-        let crate_name = tcx.crate_name(LOCAL_CRATE);\n-        let out_filename = filename_for_metadata(tcx.sess, crate_name.as_str(), outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with an `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n         let metadata_filename = emit_metadata(tcx.sess, metadata.raw_data(), &metadata_tmpdir);\n         if let Err(e) = non_durable_rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));"}, {"sha": "9ea383331b6e0458160bfe8aa84b659bd333761a", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "patch": "@@ -27,8 +27,7 @@ use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::opaque::MemEncoder;\n-use rustc_serialize::{Encodable, Encoder};\n+use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n@@ -41,10 +40,11 @@ use std::borrow::Borrow;\n use std::hash::Hash;\n use std::iter;\n use std::num::NonZeroUsize;\n+use std::path::Path;\n use tracing::{debug, trace};\n \n pub(super) struct EncodeContext<'a, 'tcx> {\n-    opaque: MemEncoder,\n+    opaque: opaque::FileEncoder,\n     tcx: TyCtxt<'tcx>,\n     feat: &'tcx rustc_feature::Features,\n \n@@ -730,25 +730,26 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         assert_eq!(total_bytes, computed_total_bytes);\n \n         if tcx.sess.meta_stats() {\n-            let mut zero_bytes = 0;\n-            for e in self.opaque.data.iter() {\n-                if *e == 0 {\n-                    zero_bytes += 1;\n-                }\n-            }\n+            // let mut zero_bytes = 0;\n+            // for e in self.opaque.data.iter() {\n+            //     if *e == 0 {\n+            //         zero_bytes += 1;\n+            //     }\n+            // }\n \n             let perc = |bytes| (bytes * 100) as f64 / total_bytes as f64;\n             let p = |label, bytes| {\n                 eprintln!(\"{:>21}: {:>8} bytes ({:4.1}%)\", label, bytes, perc(bytes));\n             };\n \n             eprintln!(\"\");\n-            eprintln!(\n-                \"{} metadata bytes, of which {} bytes ({:.1}%) are zero\",\n-                total_bytes,\n-                zero_bytes,\n-                perc(zero_bytes)\n-            );\n+            // FIXME print zero bytes\n+            //eprintln!(\n+            //    \"{} metadata bytes, of which {} bytes ({:.1}%) are zero\",\n+            //    total_bytes,\n+            //    zero_bytes,\n+            //    perc(zero_bytes)\n+            //);\n             p(\"preamble\", preamble_bytes);\n             p(\"dep\", dep_bytes);\n             p(\"lib feature\", lib_feature_bytes);\n@@ -2151,15 +2152,15 @@ impl EncodedMetadata {\n     }\n }\n \n-pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n+pub fn encode_metadata(tcx: TyCtxt<'_>, path: impl AsRef<Path>) -> EncodedMetadata {\n     let _prof_timer = tcx.prof.verbose_generic_activity(\"generate_crate_metadata\");\n \n     // Since encoding metadata is not in a query, and nothing is cached,\n     // there's no need to do dep-graph tracking for any of it.\n     tcx.dep_graph.assert_ignored();\n \n     join(\n-        || encode_metadata_impl(tcx),\n+        || encode_metadata_impl(tcx, path),\n         || {\n             if tcx.sess.threads() == 1 {\n                 return;\n@@ -2173,8 +2174,9 @@ pub fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     .0\n }\n \n-fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n-    let mut encoder = MemEncoder::new();\n+fn encode_metadata_impl(tcx: TyCtxt<'_>, path: impl AsRef<Path>) -> EncodedMetadata {\n+    let mut encoder = opaque::FileEncoder::new(path.as_ref())\n+        .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"failed to create file encoder: {}\", err)));\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n@@ -2209,7 +2211,8 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     // culminating in the `CrateRoot` which points to all of it.\n     let root = ecx.encode_crate_root();\n \n-    let mut result = ecx.opaque.finish();\n+    ecx.opaque.flush();\n+    let mut result = std::fs::read(path.as_ref()).unwrap();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n@@ -2219,6 +2222,8 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     result[header + 2] = (pos >> 8) as u8;\n     result[header + 3] = (pos >> 0) as u8;\n \n+    std::fs::write(path, &result).unwrap();\n+\n     // Record metadata size for self-profiling\n     tcx.prof.artifact_size(\"crate_metadata\", \"crate_metadata\", result.len() as u64);\n "}, {"sha": "5caeec665d2678a684ffd09e47582ea6395da448", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_middle::ty::{GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n-use rustc_serialize::opaque::MemEncoder;\n+use rustc_serialize::opaque::FileEncoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::edition::Edition;\n@@ -323,7 +323,7 @@ macro_rules! define_tables {\n         }\n \n         impl TableBuilders {\n-            fn encode(&self, buf: &mut MemEncoder) -> LazyTables {\n+            fn encode(&self, buf: &mut FileEncoder) -> LazyTables {\n                 LazyTables {\n                     $($name: self.$name.encode(buf)),+\n                 }"}, {"sha": "42759f0a652b3199b9dff5599c072c5763091c74", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7f95ace08fecfb974cbb2d486e4c7920a6010ca/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=e7f95ace08fecfb974cbb2d486e4c7920a6010ca", "patch": "@@ -4,8 +4,8 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def::{CtorKind, CtorOf};\n use rustc_index::vec::Idx;\n use rustc_middle::ty::ParameterizedOverTcx;\n-use rustc_serialize::opaque::MemEncoder;\n-use rustc_serialize::Encoder;\n+use rustc_serialize::opaque::FileEncoder;\n+use rustc_serialize::Encoder as _;\n use rustc_span::hygiene::MacroKind;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n@@ -281,7 +281,7 @@ where\n         Some(value).write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut MemEncoder) -> LazyTable<I, T>\n+    pub(crate) fn encode<const N: usize>(&self, buf: &mut FileEncoder) -> LazyTable<I, T>\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {"}]}