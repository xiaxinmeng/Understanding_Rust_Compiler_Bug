{"sha": "493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "node_id": "C_kwDOAAsO6NoAKDQ5M2M5NjBhM2U2Y2RkMmUyZmJlOGI2ZWExMzBmYWRlYTA1ZjFhYjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T05:47:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T05:47:42Z"}, "message": "Auto merge of #98656 - Dylan-DPC:rollup-hhytn0c, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #97423 (Simplify memory ordering intrinsics)\n - #97542 (Use typed indices in argument mismatch algorithm)\n - #97786 (Account for `-Z simulate-remapped-rust-src-base` when resolving remapped paths)\n - #98277 (Fix trait object reborrow suggestion)\n - #98525 (Add regression test for #79224)\n - #98549 (interpret: do not prune requires_caller_location stack frames quite so early)\n - #98603 (Some borrowck diagnostic fixes)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e30296c258fa15a5e111bdc182b12bc1beffa428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30296c258fa15a5e111bdc182b12bc1beffa428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "html_url": "https://github.com/rust-lang/rust/commit/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "116edb6800ea1d6615578e7f65366ae65364b3d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/116edb6800ea1d6615578e7f65366ae65364b3d8", "html_url": "https://github.com/rust-lang/rust/commit/116edb6800ea1d6615578e7f65366ae65364b3d8"}, {"sha": "25fb2b47a506b1c9956d7fba14d12a5175866154", "url": "https://api.github.com/repos/rust-lang/rust/commits/25fb2b47a506b1c9956d7fba14d12a5175866154", "html_url": "https://github.com/rust-lang/rust/commit/25fb2b47a506b1c9956d7fba14d12a5175866154"}], "stats": {"total": 3031, "additions": 1785, "deletions": 1246}, "files": [{"sha": "becb81b2e26a8d916a8ea6a84853004803060db1", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::ty;\n use rustc_mir_dataflow::move_paths::{\n     IllegalMoveOrigin, IllegalMoveOriginKind, LookupResult, MoveError, MovePathIndex,\n };\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n \n use crate::diagnostics::UseSpans;\n use crate::prefixes::PrefixSet;\n@@ -218,29 +218,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn report(&mut self, error: GroupedMoveError<'tcx>) {\n         let (mut err, err_span) = {\n-            let (span, use_spans, original_path, kind, has_complex_bindings): (\n-                Span,\n-                Option<UseSpans<'tcx>>,\n-                Place<'tcx>,\n-                &IllegalMoveOriginKind<'_>,\n-                bool,\n-            ) = match error {\n-                GroupedMoveError::MovesFromPlace {\n-                    span,\n-                    original_path,\n-                    ref kind,\n-                    ref binds_to,\n-                    ..\n+            let (span, use_spans, original_path, kind) = match error {\n+                GroupedMoveError::MovesFromPlace { span, original_path, ref kind, .. }\n+                | GroupedMoveError::MovesFromValue { span, original_path, ref kind, .. } => {\n+                    (span, None, original_path, kind)\n                 }\n-                | GroupedMoveError::MovesFromValue {\n-                    span,\n-                    original_path,\n-                    ref kind,\n-                    ref binds_to,\n-                    ..\n-                } => (span, None, original_path, kind, !binds_to.is_empty()),\n                 GroupedMoveError::OtherIllegalMove { use_spans, original_path, ref kind } => {\n-                    (use_spans.args_or_use(), Some(use_spans), original_path, kind, false)\n+                    (use_spans.args_or_use(), Some(use_spans), original_path, kind)\n                 }\n             };\n             debug!(\n@@ -259,7 +243,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             target_place,\n                             span,\n                             use_spans,\n-                            has_complex_bindings,\n                         ),\n                     &IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n                         self.cannot_move_out_of_interior_of_drop(span, ty)\n@@ -302,7 +285,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         deref_target_place: Place<'tcx>,\n         span: Span,\n         use_spans: Option<UseSpans<'tcx>>,\n-        has_complex_bindings: bool,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n@@ -399,28 +381,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n         };\n-        let ty = move_place.ty(self.body, self.infcx.tcx).ty;\n-        let def_id = match *ty.kind() {\n-            ty::Adt(self_def, _) => self_def.did(),\n-            ty::Foreign(def_id)\n-            | ty::FnDef(def_id, _)\n-            | ty::Closure(def_id, _)\n-            | ty::Generator(def_id, ..)\n-            | ty::Opaque(def_id, _) => def_id,\n-            _ => return err,\n-        };\n-        let diag_name = self.infcx.tcx.get_diagnostic_name(def_id);\n-        if matches!(diag_name, Some(sym::Option | sym::Result))\n-            && use_spans.map_or(true, |v| !v.for_closure())\n-            && !has_complex_bindings\n-        {\n-            err.span_suggestion_verbose(\n-                span.shrink_to_hi(),\n-                &format!(\"consider borrowing the `{}`'s content\", diag_name.unwrap()),\n-                \".as_ref()\",\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else if let Some(use_spans) = use_spans {\n+        if let Some(use_spans) = use_spans {\n             self.explain_captures(\n                 &mut err, span, span, use_spans, move_place, None, \"\", \"\", \"\", false, true,\n             );"}, {"sha": "49b24a05071b2746b0f9bbeba07cef3449862527", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -434,16 +434,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match local_decl.local_info.as_ref().unwrap() {\n-                            box LocalInfo::User(ClearCrossCrate::Set(\n+                        let label = match local_decl.local_info.as_deref().unwrap() {\n+                            LocalInfo::User(ClearCrossCrate::Set(\n                                 mir::BindingForm::ImplicitSelf(_),\n                             )) => {\n                                 let (span, suggestion) =\n                                     suggest_ampmut_self(self.infcx.tcx, local_decl);\n                                 Some((true, span, suggestion))\n                             }\n \n-                            box LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n                                 mir::VarBindingForm {\n                                     binding_mode: ty::BindingMode::BindByValue(_),\n                                     opt_ty_info,\n@@ -473,20 +473,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     // on for loops, RHS points to the iterator part\n                                     Some(DesugaringKind::ForLoop) => {\n                                         self.suggest_similar_mut_method_for_for_loop(&mut err);\n-                                        Some((\n-                                            false,\n-                                            opt_assignment_rhs_span.unwrap(),\n-                                            format!(\n-                                                \"this iterator yields `{SIGIL}` {DESC}s\",\n-                                                SIGIL = pointer_sigil,\n-                                                DESC = pointer_desc\n-                                            ),\n-                                        ))\n+                                        err.span_label(opt_assignment_rhs_span.unwrap(), format!(\n+                                            \"this iterator yields `{pointer_sigil}` {pointer_desc}s\",\n+                                        ));\n+                                        None\n                                     }\n                                     // don't create labels for compiler-generated spans\n                                     Some(_) => None,\n                                     None => {\n-                                        let (span, suggestion) = if name != kw::SelfLower {\n+                                        let label = if name != kw::SelfLower {\n                                             suggest_ampmut(\n                                                 self.infcx.tcx,\n                                                 local_decl,\n@@ -501,7 +496,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                         ..\n                                                     }),\n                                                 ))) => {\n-                                                    suggest_ampmut_self(self.infcx.tcx, local_decl)\n+                                                    let (span, sugg) = suggest_ampmut_self(\n+                                                        self.infcx.tcx,\n+                                                        local_decl,\n+                                                    );\n+                                                    (true, span, sugg)\n                                                 }\n                                                 // explicit self (eg `self: &'a Self`)\n                                                 _ => suggest_ampmut(\n@@ -512,12 +511,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                 ),\n                                             }\n                                         };\n-                                        Some((true, span, suggestion))\n+                                        Some(label)\n                                     }\n                                 }\n                             }\n \n-                            box LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n                                 mir::VarBindingForm {\n                                     binding_mode: ty::BindingMode::BindByReference(_),\n                                     ..\n@@ -528,7 +527,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     .map(|replacement| (true, pattern_span, replacement))\n                             }\n \n-                            box LocalInfo::User(ClearCrossCrate::Clear) => {\n+                            LocalInfo::User(ClearCrossCrate::Clear) => {\n                                 bug!(\"saw cleared local state\")\n                             }\n \n@@ -559,7 +558,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 }\n                             }\n                             Some((false, err_label_span, message)) => {\n-                                err.span_label(err_label_span, &message);\n+                                err.span_label(\n+                                    err_label_span,\n+                                    &format!(\n+                                        \"consider changing this binding's type to be: `{message}`\"\n+                                    ),\n+                                );\n                             }\n                             None => {}\n                         }\n@@ -1004,7 +1008,7 @@ fn suggest_ampmut<'tcx>(\n     local_decl: &mir::LocalDecl<'tcx>,\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n-) -> (Span, String) {\n+) -> (bool, Span, String) {\n     if let Some(assignment_rhs_span) = opt_assignment_rhs_span\n         && let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span)\n     {\n@@ -1028,37 +1032,38 @@ fn suggest_ampmut<'tcx>(\n             let lt_name = &src[1..ws_pos];\n             let ty = src[ws_pos..].trim_start();\n             if !is_mutbl(ty) {\n-                return (assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n+                return (true, assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n             }\n         } else if let Some(stripped) = src.strip_prefix('&') {\n             let stripped = stripped.trim_start();\n             if !is_mutbl(stripped) {\n-                return (assignment_rhs_span, format!(\"&mut {stripped}\"));\n+                return (true, assignment_rhs_span, format!(\"&mut {stripped}\"));\n             }\n         }\n     }\n \n-    let highlight_span = match opt_ty_info {\n+    let (suggestability, highlight_span) = match opt_ty_info {\n         // if this is a variable binding with an explicit type,\n         // try to highlight that for the suggestion.\n-        Some(ty_span) => ty_span,\n+        Some(ty_span) => (true, ty_span),\n \n         // otherwise, just highlight the span associated with\n         // the (MIR) LocalDecl.\n-        None => local_decl.source_info.span,\n+        None => (false, local_decl.source_info.span),\n     };\n \n     if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span)\n         && let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace))\n     {\n         let lt_name = &src[1..ws_pos];\n         let ty = &src[ws_pos..];\n-        return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n+        return (true, highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n     assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n     (\n+        suggestability,\n         highlight_span,\n         if local_decl.ty.is_region_ptr() {\n             format!(\"&mut {}\", ty_mut.ty)"}, {"sha": "4be3ae11e4e5bf2fab4a05b146472cdc87fa8281", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -6,6 +6,7 @@\n #![feature(associated_type_bounds)]\n #![feature(strict_provenance)]\n #![feature(int_roundings)]\n+#![feature(if_let_guard)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "7f14b95317b46e66ca0be4501eecfdf7281fe0b0", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -376,32 +376,23 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             // This requires that atomic intrinsics follow a specific naming pattern:\n-            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-            name if name_str.starts_with(\"atomic_\") => {\n+            // \"atomic_<operation>[_<ordering>]\"\n+            name if let Some(atomic) = name_str.strip_prefix(\"atomic_\") => {\n                 use crate::common::AtomicOrdering::*;\n                 use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n \n-                let split: Vec<_> = name_str.split('_').collect();\n-\n-                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n-                let (order, failorder) = match split.len() {\n-                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n-                    3 => match split[2] {\n-                        \"unordered\" => (Unordered, Unordered),\n-                        \"relaxed\" => (Relaxed, Relaxed),\n-                        \"acq\" => (Acquire, Acquire),\n-                        \"rel\" => (Release, Relaxed),\n-                        \"acqrel\" => (AcquireRelease, Acquire),\n-                        \"failrelaxed\" if is_cxchg => (SequentiallyConsistent, Relaxed),\n-                        \"failacq\" if is_cxchg => (SequentiallyConsistent, Acquire),\n-                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    4 => match (split[2], split[3]) {\n-                        (\"acq\", \"failrelaxed\") if is_cxchg => (Acquire, Relaxed),\n-                        (\"acqrel\", \"failrelaxed\") if is_cxchg => (AcquireRelease, Relaxed),\n-                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    _ => bx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                let Some((instruction, ordering)) = atomic.split_once('_') else {\n+                    bx.sess().fatal(\"Atomic intrinsic missing memory ordering\");\n+                };\n+\n+                let parse_ordering = |bx: &Bx, s| match s {\n+                    \"unordered\" => Unordered,\n+                    \"relaxed\" => Relaxed,\n+                    \"acquire\" => Acquire,\n+                    \"release\" => Release,\n+                    \"acqrel\" => AcquireRelease,\n+                    \"seqcst\" => SequentiallyConsistent,\n+                    _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n                 };\n \n                 let invalid_monomorphization = |ty| {\n@@ -416,11 +407,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     );\n                 };\n \n-                match split[1] {\n+                match instruction {\n                     \"cxchg\" | \"cxchgweak\" => {\n+                        let Some((success, failure)) = ordering.split_once('_') else {\n+                            bx.sess().fatal(\"Atomic compare-exchange intrinsic missing failure memory ordering\");\n+                        };\n                         let ty = substs.type_at(0);\n                         if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n-                            let weak = split[1] == \"cxchgweak\";\n+                            let weak = instruction == \"cxchgweak\";\n                             let mut dst = args[0].immediate();\n                             let mut cmp = args[1].immediate();\n                             let mut src = args[2].immediate();\n@@ -432,7 +426,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 cmp = bx.ptrtoint(cmp, bx.type_isize());\n                                 src = bx.ptrtoint(src, bx.type_isize());\n                             }\n-                            let pair = bx.atomic_cmpxchg(dst, cmp, src, order, failorder, weak);\n+                            let pair = bx.atomic_cmpxchg(dst, cmp, src, parse_ordering(bx, success), parse_ordering(bx, failure), weak);\n                             let val = bx.extract_value(pair, 0);\n                             let success = bx.extract_value(pair, 1);\n                             let val = bx.from_immediate(val);\n@@ -460,11 +454,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 let llty = bx.type_isize();\n                                 let ptr_llty = bx.type_ptr_to(llty);\n                                 source = bx.pointercast(source, ptr_llty);\n-                                let result = bx.atomic_load(llty, source, order, size);\n+                                let result = bx.atomic_load(llty, source, parse_ordering(bx, ordering), size);\n                                 // ... and then cast the result back to a pointer\n                                 bx.inttoptr(result, bx.backend_type(layout))\n                             } else {\n-                                bx.atomic_load(bx.backend_type(layout), source, order, size)\n+                                bx.atomic_load(bx.backend_type(layout), source, parse_ordering(bx, ordering), size)\n                             }\n                         } else {\n                             return invalid_monomorphization(ty);\n@@ -484,20 +478,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 ptr = bx.pointercast(ptr, ptr_llty);\n                                 val = bx.ptrtoint(val, bx.type_isize());\n                             }\n-                            bx.atomic_store(val, ptr, order, size);\n+                            bx.atomic_store(val, ptr, parse_ordering(bx, ordering), size);\n                             return;\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }\n                     }\n \n                     \"fence\" => {\n-                        bx.atomic_fence(order, SynchronizationScope::CrossThread);\n+                        bx.atomic_fence(parse_ordering(bx, ordering), SynchronizationScope::CrossThread);\n                         return;\n                     }\n \n                     \"singlethreadfence\" => {\n-                        bx.atomic_fence(order, SynchronizationScope::SingleThread);\n+                        bx.atomic_fence(parse_ordering(bx, ordering), SynchronizationScope::SingleThread);\n                         return;\n                     }\n \n@@ -531,7 +525,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 ptr = bx.pointercast(ptr, ptr_llty);\n                                 val = bx.ptrtoint(val, bx.type_isize());\n                             }\n-                            bx.atomic_rmw(atom_op, ptr, val, order)\n+                            bx.atomic_rmw(atom_op, ptr, val, parse_ordering(bx, ordering))\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }"}, {"sha": "eb81f43c3fe8cbafa2b3b9fa1f70e40594b88904", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -82,12 +82,12 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         'tcx: 'mir,\n     {\n         error.print_backtrace();\n-        let stacktrace = ecx.generate_stacktrace();\n-        ConstEvalErr {\n-            error: error.into_kind(),\n-            stacktrace,\n-            span: span.unwrap_or_else(|| ecx.cur_span()),\n-        }\n+        let mut stacktrace = ecx.generate_stacktrace();\n+        // Filter out `requires_caller_location` frames.\n+        stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+        // If `span` is missing, use topmost remaining frame, or else the \"root\" span from `ecx.tcx`.\n+        let span = span.or_else(|| stacktrace.first().map(|f| f.span)).unwrap_or(ecx.tcx.span);\n+        ConstEvalErr { error: error.into_kind(), stacktrace, span }\n     }\n \n     pub fn struct_error("}, {"sha": "09a2977af04033b6e2559c38f7d0a575e9077d75", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -337,7 +337,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     }\n                 };\n \n-                Err(err.report_as_error(ecx.tcx.at(ecx.cur_span()), &msg))\n+                Err(err.report_as_error(ecx.tcx.at(err.span), &msg))\n             } else {\n                 let hir_id = tcx.hir().local_def_id_to_hir_id(def.as_local().unwrap().did);\n                 Err(err.report_as_lint("}, {"sha": "66c736245017c5397775201dd6829d2285074a29", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -428,11 +428,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline(always)]\n     pub fn cur_span(&self) -> Span {\n-        self.stack()\n-            .iter()\n-            .rev()\n-            .find(|frame| !frame.instance.def.requires_caller_location(*self.tcx))\n-            .map_or(self.tcx.span, |f| f.current_span())\n+        // This deliberately does *not* honor `requires_caller_location` since it is used for much\n+        // more than just panics.\n+        self.stack().last().map_or(self.tcx.span, |f| f.current_span())\n     }\n \n     #[inline(always)]\n@@ -939,12 +937,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[must_use]\n     pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n         let mut frames = Vec::new();\n-        for frame in self\n-            .stack()\n-            .iter()\n-            .rev()\n-            .skip_while(|frame| frame.instance.def.requires_caller_location(*self.tcx))\n-        {\n+        // This deliberately does *not* honor `requires_caller_location` since it is used for much\n+        // more than just panics.\n+        for frame in self.stack().iter().rev() {\n             let lint_root = frame.current_source_info().and_then(|source_info| {\n                 match &frame.body.source_scopes[source_info.scope].local_data {\n                     mir::ClearCrossCrate::Set(data) => Some(data.lint_root),"}, {"sha": "b1683cf4fc4aea0970c161604e22eed460daacc2", "filename": "compiler/rustc_error_codes/src/error_codes/E0093.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -24,12 +24,12 @@ functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n-    fn atomic_fence(); // ok!\n+    fn atomic_fence_seqcst(); // ok!\n }\n \n fn main() {\n     unsafe {\n-        atomic_fence();\n+        atomic_fence_seqcst();\n     }\n }\n ```"}, {"sha": "3280fd5c3108b462495d8449453d1525e54dd797", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -42,7 +42,7 @@ use std::io;\n use std::iter::TrustedLen;\n use std::mem;\n use std::num::NonZeroUsize;\n-use std::path::Path;\n+use std::path::PathBuf;\n use tracing::debug;\n \n pub(super) use cstore_impl::provide;\n@@ -1473,28 +1473,34 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         //\n         // NOTE: if you update this, you might need to also update bootstrap's code for generating\n         // the `rust-src` component in `Src::run` in `src/bootstrap/dist.rs`.\n-        let virtual_rust_source_base_dir = option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\")\n-            .map(Path::new)\n-            .filter(|_| {\n-                // Only spend time on further checks if we have what to translate *to*.\n-                sess.opts.real_rust_source_base_dir.is_some()\n-                    // Some tests need the translation to be always skipped.\n-                    && sess.opts.debugging_opts.translate_remapped_path_to_local_path\n-            })\n-            .filter(|virtual_dir| {\n-                // Don't translate away `/rustc/$hash` if we're still remapping to it,\n-                // since that means we're still building `std`/`rustc` that need it,\n-                // and we don't want the real path to leak into codegen/debuginfo.\n-                !sess.opts.remap_path_prefix.iter().any(|(_from, to)| to == virtual_dir)\n-            });\n+        let virtual_rust_source_base_dir = [\n+            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from),\n+            sess.opts.debugging_opts.simulate_remapped_rust_src_base.clone(),\n+        ]\n+        .into_iter()\n+        .filter(|_| {\n+            // Only spend time on further checks if we have what to translate *to*.\n+            sess.opts.real_rust_source_base_dir.is_some()\n+                // Some tests need the translation to be always skipped.\n+                && sess.opts.debugging_opts.translate_remapped_path_to_local_path\n+        })\n+        .flatten()\n+        .filter(|virtual_dir| {\n+            // Don't translate away `/rustc/$hash` if we're still remapping to it,\n+            // since that means we're still building `std`/`rustc` that need it,\n+            // and we don't want the real path to leak into codegen/debuginfo.\n+            !sess.opts.remap_path_prefix.iter().any(|(_from, to)| to == virtual_dir)\n+        })\n+        .collect::<Vec<_>>();\n+\n         let try_to_translate_virtual_to_real = |name: &mut rustc_span::FileName| {\n             debug!(\n                 \"try_to_translate_virtual_to_real(name={:?}): \\\n                  virtual_rust_source_base_dir={:?}, real_rust_source_base_dir={:?}\",\n                 name, virtual_rust_source_base_dir, sess.opts.real_rust_source_base_dir,\n             );\n \n-            if let Some(virtual_dir) = virtual_rust_source_base_dir {\n+            for virtual_dir in &virtual_rust_source_base_dir {\n                 if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n                     if let rustc_span::FileName::Real(old_name) = name {\n                         if let rustc_span::RealFileName::Remapped { local_path: _, virtual_name } ="}, {"sha": "7f913faf86058674556590620db0e944721d7798", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -253,7 +253,7 @@ pub enum ObligationCauseCode<'tcx> {\n     ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n \n     /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n+    ObjectCastObligation(/* Concrete type */ Ty<'tcx>, /* Object type */ Ty<'tcx>),\n \n     /// Obligation incurred due to a coercion.\n     Coercion {"}, {"sha": "cdacf3ad892e0c71531e5910b0b6475b45ece6c1", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -162,7 +162,11 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n                 let opt_ty_info;\n                 let self_arg;\n                 if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n-                    opt_ty_info = fn_decl.inputs.get(index).map(|ty| ty.span);\n+                    opt_ty_info = fn_decl\n+                        .inputs\n+                        .get(index)\n+                        // Make sure that inferred closure args have no type span\n+                        .and_then(|ty| if arg.pat.span != ty.span { Some(ty.span) } else { None });\n                     self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n                         match fn_decl.implicit_self {\n                             hir::ImplicitSelfKind::Imm => Some(ImplicitSelfKind::Imm),"}, {"sha": "debb9e8295122ad06bc8d0c929f8b9429d824b12", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -484,10 +484,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(span, explanation);\n                         }\n \n-                        if let ObligationCauseCode::ObjectCastObligation(obj_ty) = obligation.cause.code().peel_derives() &&\n-                           let Some(self_ty) = trait_predicate.self_ty().no_bound_vars() &&\n+                        if let ObligationCauseCode::ObjectCastObligation(concrete_ty, obj_ty) = obligation.cause.code().peel_derives() &&\n                            Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n-                            self.suggest_borrowing_for_object_cast(&mut err, &obligation, self_ty, *obj_ty);\n+                            self.suggest_borrowing_for_object_cast(&mut err, &root_obligation, *concrete_ty, *obj_ty);\n                         }\n \n                         if trait_predicate.is_const_if_const() && obligation.param_env.is_const() {\n@@ -1560,7 +1559,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     obligation.cause.code().peel_derives(),\n                     ObligationCauseCode::ItemObligation(_)\n                         | ObligationCauseCode::BindingObligation(_, _)\n-                        | ObligationCauseCode::ObjectCastObligation(_)\n+                        | ObligationCauseCode::ObjectCastObligation(..)\n                         | ObligationCauseCode::OpaqueType\n                 );\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp("}, {"sha": "12858172ee554288d8ca6198b3216f622ab7ca92", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2217,9 +2217,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     err.span_note(tcx.def_span(item_def_id), &descr);\n                 }\n             }\n-            ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+            ObligationCauseCode::ObjectCastObligation(concrete_ty, object_ty) => {\n                 err.note(&format!(\n-                    \"required for the cast to the object type `{}`\",\n+                    \"required for the cast from `{}` to the object type `{}`\",\n+                    self.ty_to_string(concrete_ty),\n                     self.ty_to_string(object_ty)\n                 ));\n             }"}, {"sha": "e1131140c39e881618139d2b1ecf491669ef19f5", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -813,7 +813,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let cause = ObligationCause::new(\n                     obligation.cause.span,\n                     obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n+                    ObjectCastObligation(source, target),\n                 );\n                 let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(\n@@ -910,7 +910,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let cause = ObligationCause::new(\n                     obligation.cause.span,\n                     obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n+                    ObjectCastObligation(source, target),\n                 );\n                 let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(\n@@ -931,7 +931,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let cause = ObligationCause::new(\n                     obligation.cause.span,\n                     obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n+                    ObjectCastObligation(source, target),\n                 );\n \n                 let predicate_to_obligation = |predicate| {"}, {"sha": "7602f2550e85baa18b943bd8ad53df0faf0fb340", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/arg_matrix.rs", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -1,7 +1,26 @@\n use std::cmp;\n \n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::error::TypeError;\n \n+rustc_index::newtype_index! {\n+    pub(crate) struct ExpectedIdx {\n+        DEBUG_FORMAT = \"ExpectedIdx({})\",\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub(crate) struct ProvidedIdx {\n+        DEBUG_FORMAT = \"ProvidedIdx({})\",\n+    }\n+}\n+\n+impl ExpectedIdx {\n+    pub fn to_provided_idx(self) -> ProvidedIdx {\n+        ProvidedIdx::from_usize(self.as_usize())\n+    }\n+}\n+\n // An issue that might be found in the compatibility matrix\n #[derive(Debug)]\n enum Issue {\n@@ -27,87 +46,89 @@ pub(crate) enum Compatibility<'tcx> {\n #[derive(Debug)]\n pub(crate) enum Error<'tcx> {\n     /// The provided argument is the invalid type for the expected input\n-    Invalid(usize, usize, Compatibility<'tcx>), // provided, expected\n+    Invalid(ProvidedIdx, ExpectedIdx, Compatibility<'tcx>),\n     /// There is a missing input\n-    Missing(usize),\n+    Missing(ExpectedIdx),\n     /// There's a superfluous argument\n-    Extra(usize),\n+    Extra(ProvidedIdx),\n     /// Two arguments should be swapped\n-    Swap(usize, usize, usize, usize),\n+    Swap(ProvidedIdx, ProvidedIdx, ExpectedIdx, ExpectedIdx),\n     /// Several arguments should be reordered\n-    Permutation(Vec<(usize, usize)>), // dest_arg, dest_input\n+    Permutation(Vec<(ExpectedIdx, ProvidedIdx)>),\n }\n \n pub(crate) struct ArgMatrix<'tcx> {\n     /// Maps the indices in the `compatibility_matrix` rows to the indices of\n     /// the *user provided* inputs\n-    input_indexes: Vec<usize>,\n+    provided_indices: Vec<ProvidedIdx>,\n     /// Maps the indices in the `compatibility_matrix` columns to the indices\n     /// of the *expected* args\n-    arg_indexes: Vec<usize>,\n+    expected_indices: Vec<ExpectedIdx>,\n     /// The first dimension (rows) are the remaining user provided inputs to\n     /// match and the second dimension (cols) are the remaining expected args\n     /// to match\n     compatibility_matrix: Vec<Vec<Compatibility<'tcx>>>,\n }\n \n impl<'tcx> ArgMatrix<'tcx> {\n-    pub(crate) fn new<F: FnMut(usize, usize) -> Compatibility<'tcx>>(\n-        minimum_input_count: usize,\n-        provided_arg_count: usize,\n+    pub(crate) fn new<F: FnMut(ProvidedIdx, ExpectedIdx) -> Compatibility<'tcx>>(\n+        provided_count: usize,\n+        expected_input_count: usize,\n         mut is_compatible: F,\n     ) -> Self {\n-        let compatibility_matrix = (0..provided_arg_count)\n-            .map(|i| (0..minimum_input_count).map(|j| is_compatible(i, j)).collect())\n+        let compatibility_matrix = (0..provided_count)\n+            .map(|i| {\n+                (0..expected_input_count)\n+                    .map(|j| is_compatible(ProvidedIdx::from_usize(i), ExpectedIdx::from_usize(j)))\n+                    .collect()\n+            })\n             .collect();\n         ArgMatrix {\n-            input_indexes: (0..provided_arg_count).collect(),\n-            arg_indexes: (0..minimum_input_count).collect(),\n+            provided_indices: (0..provided_count).map(ProvidedIdx::from_usize).collect(),\n+            expected_indices: (0..expected_input_count).map(ExpectedIdx::from_usize).collect(),\n             compatibility_matrix,\n         }\n     }\n \n     /// Remove a given input from consideration\n-    fn eliminate_input(&mut self, idx: usize) {\n-        self.input_indexes.remove(idx);\n+    fn eliminate_provided(&mut self, idx: usize) {\n+        self.provided_indices.remove(idx);\n         self.compatibility_matrix.remove(idx);\n     }\n \n     /// Remove a given argument from consideration\n-    fn eliminate_arg(&mut self, idx: usize) {\n-        self.arg_indexes.remove(idx);\n+    fn eliminate_expected(&mut self, idx: usize) {\n+        self.expected_indices.remove(idx);\n         for row in &mut self.compatibility_matrix {\n             row.remove(idx);\n         }\n     }\n \n     /// \"satisfy\" an input with a given arg, removing both from consideration\n-    fn satisfy_input(&mut self, input_idx: usize, arg_idx: usize) {\n-        self.eliminate_input(input_idx);\n-        self.eliminate_arg(arg_idx);\n+    fn satisfy_input(&mut self, provided_idx: usize, expected_idx: usize) {\n+        self.eliminate_provided(provided_idx);\n+        self.eliminate_expected(expected_idx);\n     }\n \n     // Returns a `Vec` of (user input, expected arg) of matched arguments. These\n     // are inputs on the remaining diagonal that match.\n-    fn eliminate_satisfied(&mut self) -> Vec<(usize, usize)> {\n-        let mut i = cmp::min(self.input_indexes.len(), self.arg_indexes.len());\n+    fn eliminate_satisfied(&mut self) -> Vec<(ProvidedIdx, ExpectedIdx)> {\n+        let num_args = cmp::min(self.provided_indices.len(), self.expected_indices.len());\n         let mut eliminated = vec![];\n-        while i > 0 {\n-            let idx = i - 1;\n-            if matches!(self.compatibility_matrix[idx][idx], Compatibility::Compatible) {\n-                eliminated.push((self.input_indexes[idx], self.arg_indexes[idx]));\n-                self.satisfy_input(idx, idx);\n+        for i in (0..num_args).rev() {\n+            if matches!(self.compatibility_matrix[i][i], Compatibility::Compatible) {\n+                eliminated.push((self.provided_indices[i], self.expected_indices[i]));\n+                self.satisfy_input(i, i);\n             }\n-            i -= 1;\n         }\n-        return eliminated;\n+        eliminated\n     }\n \n     // Find some issue in the compatibility matrix\n     fn find_issue(&self) -> Option<Issue> {\n         let mat = &self.compatibility_matrix;\n-        let ai = &self.arg_indexes;\n-        let ii = &self.input_indexes;\n+        let ai = &self.expected_indices;\n+        let ii = &self.provided_indices;\n \n         for i in 0..cmp::max(ai.len(), ii.len()) {\n             // If we eliminate the last row, any left-over inputs are considered missing\n@@ -264,12 +285,15 @@ impl<'tcx> ArgMatrix<'tcx> {\n     //\n     // We'll want to know which arguments and inputs these rows and columns correspond to\n     // even after we delete them.\n-    pub(crate) fn find_errors(mut self) -> (Vec<Error<'tcx>>, Vec<Option<usize>>) {\n-        let provided_arg_count = self.input_indexes.len();\n+    pub(crate) fn find_errors(\n+        mut self,\n+    ) -> (Vec<Error<'tcx>>, IndexVec<ExpectedIdx, Option<ProvidedIdx>>) {\n+        let provided_arg_count = self.provided_indices.len();\n \n         let mut errors: Vec<Error<'tcx>> = vec![];\n         // For each expected argument, the matched *actual* input\n-        let mut matched_inputs: Vec<Option<usize>> = vec![None; self.arg_indexes.len()];\n+        let mut matched_inputs: IndexVec<ExpectedIdx, Option<ProvidedIdx>> =\n+            IndexVec::from_elem_n(None, self.expected_indices.len());\n \n         // Before we start looking for issues, eliminate any arguments that are already satisfied,\n         // so that an argument which is already spoken for by the input it's in doesn't\n@@ -280,34 +304,34 @@ impl<'tcx> ArgMatrix<'tcx> {\n         // Without this elimination, the first argument causes the second argument\n         // to show up as both a missing input and extra argument, rather than\n         // just an invalid type.\n-        for (inp, arg) in self.eliminate_satisfied() {\n-            matched_inputs[arg] = Some(inp);\n+        for (provided, expected) in self.eliminate_satisfied() {\n+            matched_inputs[expected] = Some(provided);\n         }\n \n-        while self.input_indexes.len() > 0 || self.arg_indexes.len() > 0 {\n+        while !self.provided_indices.is_empty() || !self.expected_indices.is_empty() {\n             match self.find_issue() {\n                 Some(Issue::Invalid(idx)) => {\n                     let compatibility = self.compatibility_matrix[idx][idx].clone();\n-                    let input_idx = self.input_indexes[idx];\n-                    let arg_idx = self.arg_indexes[idx];\n+                    let input_idx = self.provided_indices[idx];\n+                    let arg_idx = self.expected_indices[idx];\n                     self.satisfy_input(idx, idx);\n                     errors.push(Error::Invalid(input_idx, arg_idx, compatibility));\n                 }\n                 Some(Issue::Extra(idx)) => {\n-                    let input_idx = self.input_indexes[idx];\n-                    self.eliminate_input(idx);\n+                    let input_idx = self.provided_indices[idx];\n+                    self.eliminate_provided(idx);\n                     errors.push(Error::Extra(input_idx));\n                 }\n                 Some(Issue::Missing(idx)) => {\n-                    let arg_idx = self.arg_indexes[idx];\n-                    self.eliminate_arg(idx);\n+                    let arg_idx = self.expected_indices[idx];\n+                    self.eliminate_expected(idx);\n                     errors.push(Error::Missing(arg_idx));\n                 }\n                 Some(Issue::Swap(idx, other)) => {\n-                    let input_idx = self.input_indexes[idx];\n-                    let other_input_idx = self.input_indexes[other];\n-                    let arg_idx = self.arg_indexes[idx];\n-                    let other_arg_idx = self.arg_indexes[other];\n+                    let input_idx = self.provided_indices[idx];\n+                    let other_input_idx = self.provided_indices[other];\n+                    let arg_idx = self.expected_indices[idx];\n+                    let other_arg_idx = self.expected_indices[other];\n                     let (min, max) = (cmp::min(idx, other), cmp::max(idx, other));\n                     self.satisfy_input(min, max);\n                     // Subtract 1 because we already removed the \"min\" row\n@@ -319,13 +343,14 @@ impl<'tcx> ArgMatrix<'tcx> {\n                 Some(Issue::Permutation(args)) => {\n                     let mut idxs: Vec<usize> = args.iter().filter_map(|&a| a).collect();\n \n-                    let mut real_idxs = vec![None; provided_arg_count];\n+                    let mut real_idxs: IndexVec<ProvidedIdx, Option<(ExpectedIdx, ProvidedIdx)>> =\n+                        IndexVec::from_elem_n(None, provided_arg_count);\n                     for (src, dst) in\n                         args.iter().enumerate().filter_map(|(src, dst)| dst.map(|dst| (src, dst)))\n                     {\n-                        let src_input_idx = self.input_indexes[src];\n-                        let dst_input_idx = self.input_indexes[dst];\n-                        let dest_arg_idx = self.arg_indexes[dst];\n+                        let src_input_idx = self.provided_indices[src];\n+                        let dst_input_idx = self.provided_indices[dst];\n+                        let dest_arg_idx = self.expected_indices[dst];\n                         real_idxs[src_input_idx] = Some((dest_arg_idx, dst_input_idx));\n                         matched_inputs[dest_arg_idx] = Some(src_input_idx);\n                     }"}, {"sha": "08df01c0c1a1a9ab1923ddc328d26f03201297cb", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 635, "deletions": 582, "changes": 1217, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -1,6 +1,8 @@\n use crate::astconv::AstConv;\n use crate::check::coercion::CoerceMany;\n-use crate::check::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error};\n+use crate::check::fn_ctxt::arg_matrix::{\n+    ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx,\n+};\n use crate::check::gather_locals::Declaration;\n use crate::check::method::MethodCallee;\n use crate::check::Expectation::*;\n@@ -17,13 +19,14 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n@@ -214,6 +217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let provided_arg_count = provided_args.len();\n \n         // We'll also want to keep track of the fully coerced argument types, for an awkward hack near the end\n+        // FIXME(compiler-errors): Get rid of this, actually.\n         let mut final_arg_types: Vec<Option<(Ty<'_>, Ty<'_>)>> = vec![None; provided_arg_count];\n \n         // We introduce a helper function to demand that a given argument satisfy a given input\n@@ -287,54 +291,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        // A \"softer\" version of the helper above, which checks types without persisting them,\n-        // and treats error types differently\n-        // This will allow us to \"probe\" for other argument orders that would likely have been correct\n-        let check_compatible = |input_idx, arg_idx| {\n-            let formal_input_ty: Ty<'tcx> = formal_input_tys[arg_idx];\n-            let expected_input_ty: Ty<'tcx> = expected_input_tys[arg_idx];\n-\n-            // If either is an error type, we defy the usual convention and consider them to *not* be\n-            // coercible.  This prevents our error message heuristic from trying to pass errors into\n-            // every argument.\n-            if formal_input_ty.references_error() || expected_input_ty.references_error() {\n-                return Compatibility::Incompatible(None);\n-            }\n-\n-            let provided_arg: &hir::Expr<'tcx> = &provided_args[input_idx];\n-            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n-            // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n-            //\n-            //   I had another method of \"soft\" type checking before,\n-            //   but it was failing to find the type of some expressions (like \"\")\n-            //   so I prodded this method and made it pub(super) so I could call it, and it seems to work well.\n-            let checked_ty = self.check_expr_kind(provided_arg, expectation);\n-\n-            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n-            let can_coerce = self.can_coerce(checked_ty, coerced_ty);\n-\n-            if !can_coerce {\n-                return Compatibility::Incompatible(None);\n-            }\n-\n-            let subtyping_result = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n-\n-            // Same as above: if either the coerce type or the checked type is an error type,\n-            // consider them *not* compatible.\n-            let coercible =\n-                !coerced_ty.references_error() && !checked_ty.references_error() && can_coerce;\n-\n-            match (coercible, &subtyping_result) {\n-                (true, Ok(_)) => Compatibility::Compatible,\n-                _ => Compatibility::Incompatible(subtyping_result.err()),\n-            }\n-        };\n-\n         // To start, we only care \"along the diagonal\", where we expect every\n         // provided arg to be in the right spot\n-        let mut compatibility = vec![Compatibility::Incompatible(None); provided_args.len()];\n+        let mut compatibility_diagonal =\n+            vec![Compatibility::Incompatible(None); provided_args.len()];\n \n         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path\n         // if the wrong number of arguments were supplied, we CAN'T be satisfied,\n@@ -394,78 +354,62 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let compatible = demand_compatible(idx, &mut final_arg_types);\n                 let is_compatible = matches!(compatible, Compatibility::Compatible);\n-                compatibility[idx] = compatible;\n+                compatibility_diagonal[idx] = compatible;\n \n                 if !is_compatible {\n                     call_appears_satisfied = false;\n                 }\n             }\n         }\n \n-        // Logic here is a bit hairy\n-        'errors: {\n-            // If something above didn't typecheck, we've fallen off the happy path\n-            // and we should make some effort to provide better error messages\n-            if call_appears_satisfied {\n-                break 'errors;\n-            }\n-\n-            self.set_tainted_by_errors();\n+        if c_variadic && provided_arg_count < minimum_input_count {\n+            err_code = \"E0060\";\n+        }\n \n-            // The algorithm here is inspired by levenshtein distance and longest common subsequence.\n-            // We'll try to detect 4 different types of mistakes:\n-            // - An extra parameter has been provided that doesn't satisfy *any* of the other inputs\n-            // - An input is missing, which isn't satisfied by *any* of the other arguments\n-            // - Some number of arguments have been provided in the wrong order\n-            // - A type is straight up invalid\n+        for arg in provided_args.iter().skip(minimum_input_count) {\n+            // Make sure we've checked this expr at least once.\n+            let arg_ty = self.check_expr(&arg);\n \n-            // First, let's find the errors\n-            let mut compatibility: Vec<_> = compatibility.into_iter().map(Some).collect();\n-            let (mut errors, matched_inputs) =\n-                ArgMatrix::new(minimum_input_count, provided_arg_count, |i, j| {\n-                    if i == j { compatibility[i].take().unwrap() } else { check_compatible(i, j) }\n-                })\n-                .find_errors();\n+            // If the function is c-style variadic, we skipped a bunch of arguments\n+            // so we need to check those, and write out the types\n+            // Ideally this would be folded into the above, for uniform style\n+            // but c-variadic is already a corner case\n+            if c_variadic {\n+                fn variadic_error<'tcx>(\n+                    sess: &'tcx Session,\n+                    span: Span,\n+                    ty: Ty<'tcx>,\n+                    cast_ty: &str,\n+                ) {\n+                    use crate::structured_errors::MissingCastForVariadicArg;\n \n-            // Okay, so here's where it gets complicated in regards to what errors\n-            // we emit and how.\n-            // There are 3 different \"types\" of errors we might encounter.\n-            //   1) Missing/extra/swapped arguments\n-            //   2) Valid but incorrect arguments\n-            //   3) Invalid arguments\n-            //      - Currently I think this only comes up with `CyclicTy`\n-            //\n-            // We first need to go through, remove those from (3) and emit those\n-            // as their own error, particularly since they're error code and\n-            // message is special. From what I can tell, we *must* emit these\n-            // here (vs somewhere prior to this function) since the arguments\n-            // become invalid *because* of how they get used in the function.\n-            // It is what it is.\n-\n-            let found_errors = !errors.is_empty();\n-\n-            errors.drain_filter(|error| {\n-                let Error::Invalid(input_idx, arg_idx, Compatibility::Incompatible(Some(e))) = error else { return false };\n-                let expected_ty = expected_input_tys[*arg_idx];\n-                let provided_ty = final_arg_types[*input_idx].map(|ty| ty.0).unwrap_or_else(|| tcx.ty_error());\n-                let cause = &self.misc(provided_args[*input_idx].span);\n-                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                if !matches!(trace.cause.as_failure_code(e), FailureCode::Error0308(_)) {\n-                    self.report_and_explain_type_error(trace, e).emit();\n-                    return true;\n+                    MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n                 }\n-                false\n-            });\n \n-            // We're done if we found errors, but we already emitted them.\n-            // I don't think we *should* be able to enter this bit of code\n-            // (`!call_appears_satisfied`) without *also* finding errors, but we\n-            // don't want to accidentally not emit an error if there is some\n-            // logic bug in the `ArgMatrix` code.\n-            if found_errors && errors.is_empty() {\n-                break 'errors;\n+                // There are a few types which get autopromoted when passed via varargs\n+                // in C but we just error out instead and require explicit casts.\n+                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n+                match arg_ty.kind() {\n+                    ty::Float(ty::FloatTy::F32) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n+                    }\n+                    ty::Int(ty::IntTy::I8 | ty::IntTy::I16) | ty::Bool => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n+                    }\n+                    ty::Uint(ty::UintTy::U8 | ty::UintTy::U16) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n+                    }\n+                    ty::FnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n+                        let ptr_ty = self.resolve_vars_if_possible(ptr_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n+                    }\n+                    _ => {}\n+                }\n             }\n+        }\n \n+        if !call_appears_satisfied {\n             // Next, let's construct the error\n             let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n                 hir::ExprKind::Call(\n@@ -500,524 +444,633 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(CtorOf::Variant) => \"enum variant\",\n                 None => \"function\",\n             };\n-            if c_variadic && provided_arg_count < minimum_input_count {\n-                err_code = \"E0060\";\n-            }\n \n-            // Next special case: The case where we expect a single tuple and\n-            // wrapping all the args in parentheses (or adding a comma to\n-            // already existing parentheses) will result in a tuple that\n-            // satisfies the call.\n-            // This isn't super ideal code, because we copy code from elsewhere\n-            // and somewhat duplicate this. We also delegate to the general type\n-            // mismatch suggestions for the single arg case.\n-            let sugg_tuple_wrap_args =\n-                self.suggested_tuple_wrap(&expected_input_tys, provided_args);\n-            match sugg_tuple_wrap_args {\n-                TupleMatchFound::None => {}\n-                TupleMatchFound::Single => {\n-                    let expected_ty = expected_input_tys[0];\n-                    let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n-                    let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                    let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                    let cause = &self.misc(provided_args[0].span);\n-                    let compatibility = demand_compatible(0, &mut final_arg_types);\n-                    let type_error = match compatibility {\n-                        Compatibility::Incompatible(Some(error)) => error,\n-                        _ => TypeError::Mismatch,\n-                    };\n-                    let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                    let mut err = self.report_and_explain_type_error(trace, &type_error);\n-                    self.emit_coerce_suggestions(\n-                        &mut err,\n-                        &provided_args[0],\n-                        final_arg_types[0].map(|ty| ty.0).unwrap(),\n-                        final_arg_types[0].map(|ty| ty.1).unwrap(),\n-                        None,\n-                        None,\n-                    );\n-                    err.span_label(\n-                        full_call_span,\n-                        format!(\"arguments to this {} are incorrect\", call_name),\n-                    );\n-                    // Call out where the function is defined\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n-                    err.emit();\n-                    break 'errors;\n-                }\n-                TupleMatchFound::Multiple(start, end) => {\n-                    let mut err = tcx.sess.struct_span_err_with_code(\n-                        full_call_span,\n-                        &format!(\n-                            \"this {} takes {}{} but {} {} supplied\",\n-                            call_name,\n-                            if c_variadic { \"at least \" } else { \"\" },\n-                            potentially_plural_count(minimum_input_count, \"argument\"),\n-                            potentially_plural_count(provided_arg_count, \"argument\"),\n-                            if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                        ),\n-                        DiagnosticId::Error(err_code.to_owned()),\n-                    );\n-                    // Call out where the function is defined\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n-                    err.multipart_suggestion(\n-                        \"use parentheses to construct a tuple\",\n-                        vec![(start, '('.to_string()), (end, ')'.to_string())],\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                    break 'errors;\n+            let try_tuple_wrap_args = || {\n+                // The case where we expect a single tuple and wrapping all the args\n+                // in parentheses (or adding a comma to already existing parentheses)\n+                // will result in a tuple that satisfies the call.\n+                // This isn't super ideal code, because we copy code from elsewhere\n+                // and somewhat duplicate this. We also delegate to the general type\n+                // mismatch suggestions for the single arg case.\n+                match self.suggested_tuple_wrap(&expected_input_tys, provided_args) {\n+                    TupleMatchFound::Single => {\n+                        let expected_ty = expected_input_tys[0];\n+                        let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n+                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n+                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n+                        let cause = &self.misc(provided_args[0].span);\n+                        let compatibility = demand_compatible(0, &mut final_arg_types);\n+                        let type_error = match compatibility {\n+                            Compatibility::Incompatible(Some(error)) => error,\n+                            _ => TypeError::Mismatch,\n+                        };\n+                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                        let mut err = self.report_and_explain_type_error(trace, &type_error);\n+                        self.emit_coerce_suggestions(\n+                            &mut err,\n+                            &provided_args[0],\n+                            final_arg_types[0].map(|ty| ty.0).unwrap(),\n+                            final_arg_types[0].map(|ty| ty.1).unwrap(),\n+                            None,\n+                            None,\n+                        );\n+                        err.span_label(\n+                            full_call_span,\n+                            format!(\"arguments to this {} are incorrect\", call_name),\n+                        );\n+                        // Call out where the function is defined\n+                        label_fn_like(tcx, &mut err, fn_def_id);\n+                        err.emit();\n+                        return true;\n+                    }\n+                    TupleMatchFound::Multiple(start, end) => {\n+                        let mut err = tcx.sess.struct_span_err_with_code(\n+                            full_call_span,\n+                            &format!(\n+                                \"this {} takes {}{} but {} {} supplied\",\n+                                call_name,\n+                                if c_variadic { \"at least \" } else { \"\" },\n+                                potentially_plural_count(minimum_input_count, \"argument\"),\n+                                potentially_plural_count(provided_arg_count, \"argument\"),\n+                                if provided_arg_count == 1 { \"was\" } else { \"were\" }\n+                            ),\n+                            DiagnosticId::Error(err_code.to_owned()),\n+                        );\n+                        // Call out where the function is defined\n+                        label_fn_like(tcx, &mut err, fn_def_id);\n+                        err.multipart_suggestion(\n+                            \"use parentheses to construct a tuple\",\n+                            vec![(start, '('.to_string()), (end, ')'.to_string())],\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                        return true;\n+                    }\n+                    TupleMatchFound::None => {}\n                 }\n+                false\n+            };\n+\n+            let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n+            let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n+                minimum_input_count\n+            } else {\n+                provided_arg_count\n+            }));\n+            debug_assert_eq!(\n+                formal_input_tys.len(),\n+                expected_input_tys.len(),\n+                \"expected formal_input_tys to be the same size as expected_input_tys\"\n+            );\n+            let formal_and_expected_inputs = IndexVec::from_iter(\n+                formal_input_tys\n+                    .iter()\n+                    .copied()\n+                    .zip(expected_input_tys.iter().copied())\n+                    .map(|vars| self.resolve_vars_if_possible(vars)),\n+            );\n+\n+            self.report_arg_errors(\n+                compatibility_diagonal,\n+                formal_and_expected_inputs,\n+                provided_args,\n+                full_call_span,\n+                error_span,\n+                args_span,\n+                call_name,\n+                c_variadic,\n+                err_code,\n+                fn_def_id,\n+                try_tuple_wrap_args,\n+            );\n+        }\n+    }\n+\n+    fn report_arg_errors(\n+        &self,\n+        compatibility_diagonal: IndexVec<ProvidedIdx, Compatibility<'tcx>>,\n+        formal_and_expected_inputs: IndexVec<ExpectedIdx, (Ty<'tcx>, Ty<'tcx>)>,\n+        provided_args: IndexVec<ProvidedIdx, &'tcx hir::Expr<'tcx>>,\n+        full_call_span: Span,\n+        error_span: Span,\n+        args_span: Span,\n+        call_name: &str,\n+        c_variadic: bool,\n+        err_code: &str,\n+        fn_def_id: Option<DefId>,\n+        try_tuple_wrap_args: impl FnOnce() -> bool,\n+    ) {\n+        // Don't print if it has error types or is just plain `_`\n+        fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n+            tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n+        }\n+\n+        self.set_tainted_by_errors();\n+        let tcx = self.tcx;\n+\n+        // A \"softer\" version of the `demand_compatible`, which checks types without persisting them,\n+        // and treats error types differently\n+        // This will allow us to \"probe\" for other argument orders that would likely have been correct\n+        let check_compatible = |provided_idx: ProvidedIdx, expected_idx: ExpectedIdx| {\n+            if provided_idx.as_usize() == expected_idx.as_usize() {\n+                return compatibility_diagonal[provided_idx].clone();\n+            }\n+\n+            let (formal_input_ty, expected_input_ty) = formal_and_expected_inputs[expected_idx];\n+            // If either is an error type, we defy the usual convention and consider them to *not* be\n+            // coercible.  This prevents our error message heuristic from trying to pass errors into\n+            // every argument.\n+            if (formal_input_ty, expected_input_ty).references_error() {\n+                return Compatibility::Incompatible(None);\n+            }\n+\n+            let provided_arg: &hir::Expr<'tcx> = &provided_args[provided_idx];\n+            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n+            // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n+            //\n+            //   I had another method of \"soft\" type checking before,\n+            //   but it was failing to find the type of some expressions (like \"\")\n+            //   so I prodded this method and made it pub(super) so I could call it, and it seems to work well.\n+            let checked_ty = self.check_expr_kind(provided_arg, expectation);\n+\n+            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n+            let can_coerce = self.can_coerce(checked_ty, coerced_ty);\n+            if !can_coerce {\n+                return Compatibility::Incompatible(None);\n+            }\n+\n+            let subtyping_result = self\n+                .at(&self.misc(provided_arg.span), self.param_env)\n+                .sup(formal_input_ty, coerced_ty);\n+\n+            // Same as above: if either the coerce type or the checked type is an error type,\n+            // consider them *not* compatible.\n+            let references_error = (coerced_ty, checked_ty).references_error();\n+            match (references_error, &subtyping_result) {\n+                (false, Ok(_)) => Compatibility::Compatible,\n+                _ => Compatibility::Incompatible(subtyping_result.err()),\n             }\n+        };\n+\n+        // The algorithm here is inspired by levenshtein distance and longest common subsequence.\n+        // We'll try to detect 4 different types of mistakes:\n+        // - An extra parameter has been provided that doesn't satisfy *any* of the other inputs\n+        // - An input is missing, which isn't satisfied by *any* of the other arguments\n+        // - Some number of arguments have been provided in the wrong order\n+        // - A type is straight up invalid\n+\n+        // First, let's find the errors\n+        let (mut errors, matched_inputs) =\n+            ArgMatrix::new(provided_args.len(), formal_and_expected_inputs.len(), check_compatible)\n+                .find_errors();\n+\n+        // Precompute the provided types and spans, since that's all we typically need for below\n+        let provided_arg_tys: IndexVec<ProvidedIdx, (Ty<'tcx>, Span)> = provided_args\n+            .iter()\n+            .map(|expr| {\n+                let ty = self\n+                    .in_progress_typeck_results\n+                    .as_ref()\n+                    .unwrap()\n+                    .borrow()\n+                    .expr_ty_adjusted_opt(*expr)\n+                    .unwrap_or_else(|| tcx.ty_error());\n+                (self.resolve_vars_if_possible(ty), expr.span)\n+            })\n+            .collect();\n+\n+        // Okay, so here's where it gets complicated in regards to what errors\n+        // we emit and how.\n+        // There are 3 different \"types\" of errors we might encounter.\n+        //   1) Missing/extra/swapped arguments\n+        //   2) Valid but incorrect arguments\n+        //   3) Invalid arguments\n+        //      - Currently I think this only comes up with `CyclicTy`\n+        //\n+        // We first need to go through, remove those from (3) and emit those\n+        // as their own error, particularly since they're error code and\n+        // message is special. From what I can tell, we *must* emit these\n+        // here (vs somewhere prior to this function) since the arguments\n+        // become invalid *because* of how they get used in the function.\n+        // It is what it is.\n+\n+        if errors.is_empty() {\n+            if cfg!(debug_assertions) {\n+                span_bug!(error_span, \"expected errors from argument matrix\");\n+            } else {\n+                tcx.sess\n+                    .struct_span_err(\n+                        error_span,\n+                        \"argument type mismatch was detected, \\\n+                        but rustc had trouble determining where\",\n+                    )\n+                    .note(\n+                        \"we would appreciate a bug report: \\\n+                        https://github.com/rust-lang/rust-clippy/issues/new\",\n+                    )\n+                    .emit();\n+            }\n+            return;\n+        }\n+\n+        errors.drain_filter(|error| {\n+                let Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(error)) = error else { return false };\n+                let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n+                let (expected_ty, _) = formal_and_expected_inputs[*expected_idx];\n+                let cause = &self.misc(provided_span);\n+                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                if let Some(e) = error {\n+                    if !matches!(trace.cause.as_failure_code(e), FailureCode::Error0308(_)) {\n+                        self.report_and_explain_type_error(trace, e).emit();\n+                        return true;\n+                    }\n+                }\n+                false\n+            });\n+\n+        // We're done if we found errors, but we already emitted them.\n+        if errors.is_empty() {\n+            return;\n+        }\n+\n+        // Okay, now that we've emitted the special errors separately, we\n+        // are only left missing/extra/swapped and mismatched arguments, both\n+        // can be collated pretty easily if needed.\n+\n+        // Next special case: if there is only one \"Incompatible\" error, just emit that\n+        if let [\n+            Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(Some(err))),\n+        ] = &errors[..]\n+        {\n+            let (formal_ty, expected_ty) = formal_and_expected_inputs[*expected_idx];\n+            let (provided_ty, provided_arg_span) = provided_arg_tys[*provided_idx];\n+            let cause = &self.misc(provided_arg_span);\n+            let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+            let mut err = self.report_and_explain_type_error(trace, err);\n+            self.emit_coerce_suggestions(\n+                &mut err,\n+                &provided_args[*provided_idx],\n+                provided_ty,\n+                Expectation::rvalue_hint(self, expected_ty)\n+                    .only_has_type(self)\n+                    .unwrap_or(formal_ty),\n+                None,\n+                None,\n+            );\n+            err.span_label(\n+                full_call_span,\n+                format!(\"arguments to this {} are incorrect\", call_name),\n+            );\n+            // Call out where the function is defined\n+            label_fn_like(tcx, &mut err, fn_def_id);\n+            err.emit();\n+            return;\n+        }\n+\n+        // Second, let's try tuple wrapping the args.\n+        // FIXME(compiler-errors): This is currently in its own closure because\n+        // I didn't want to factor it out.\n+        if try_tuple_wrap_args() {\n+            return;\n+        }\n+\n+        let mut err = if formal_and_expected_inputs.len() == provided_args.len() {\n+            struct_span_err!(\n+                tcx.sess,\n+                full_call_span,\n+                E0308,\n+                \"arguments to this {} are incorrect\",\n+                call_name,\n+            )\n+        } else {\n+            tcx.sess.struct_span_err_with_code(\n+                full_call_span,\n+                &format!(\n+                    \"this {} takes {}{} but {} {} supplied\",\n+                    call_name,\n+                    if c_variadic { \"at least \" } else { \"\" },\n+                    potentially_plural_count(formal_and_expected_inputs.len(), \"argument\"),\n+                    potentially_plural_count(provided_args.len(), \"argument\"),\n+                    if provided_args.len() == 1 { \"was\" } else { \"were\" }\n+                ),\n+                DiagnosticId::Error(err_code.to_owned()),\n+            )\n+        };\n+\n+        // As we encounter issues, keep track of what we want to provide for the suggestion\n+        let mut labels = vec![];\n+        // If there is a single error, we give a specific suggestion; otherwise, we change to\n+        // \"did you mean\" with the suggested function call\n+        enum SuggestionText {\n+            None,\n+            Provide(bool),\n+            Remove(bool),\n+            Swap,\n+            Reorder,\n+            DidYouMean,\n+        }\n+        let mut suggestion_text = SuggestionText::None;\n+\n+        let mut errors = errors.into_iter().peekable();\n+        while let Some(error) = errors.next() {\n+            match error {\n+                Error::Invalid(provided_idx, expected_idx, compatibility) => {\n+                    let (formal_ty, expected_ty) = formal_and_expected_inputs[expected_idx];\n+                    let (provided_ty, provided_span) = provided_arg_tys[provided_idx];\n+                    if let Compatibility::Incompatible(error) = &compatibility {\n+                        let cause = &self.misc(provided_span);\n+                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                        if let Some(e) = error {\n+                            self.note_type_err(\n+                                &mut err,\n+                                &trace.cause,\n+                                None,\n+                                Some(trace.values),\n+                                e,\n+                                false,\n+                                true,\n+                            );\n+                        }\n+                    }\n \n-            // Okay, now that we've emitted the special errors separately, we\n-            // are only left missing/extra/swapped and mismatched arguments, both\n-            // can be collated pretty easily if needed.\n-\n-            // Next special case: if there is only one \"Incompatible\" error, just emit that\n-            if errors.len() == 1 {\n-                if let Some(Error::Invalid(\n-                    input_idx,\n-                    arg_idx,\n-                    Compatibility::Incompatible(Some(error)),\n-                )) = errors.iter().next()\n-                {\n-                    let expected_ty = expected_input_tys[*arg_idx];\n-                    let provided_ty = final_arg_types[*input_idx]\n-                        .map(|ty| ty.0)\n-                        .unwrap_or_else(|| tcx.ty_error());\n-                    let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                    let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                    let cause = &self.misc(provided_args[*input_idx].span);\n-                    let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                    let mut err = self.report_and_explain_type_error(trace, error);\n                     self.emit_coerce_suggestions(\n                         &mut err,\n-                        &provided_args[*input_idx],\n+                        &provided_args[provided_idx],\n                         provided_ty,\n-                        final_arg_types[*input_idx]\n-                            .map(|ty| ty.1)\n-                            .unwrap_or_else(|| tcx.ty_error()),\n+                        Expectation::rvalue_hint(self, expected_ty)\n+                            .only_has_type(self)\n+                            .unwrap_or(formal_ty),\n                         None,\n                         None,\n                     );\n-                    err.span_label(\n-                        full_call_span,\n-                        format!(\"arguments to this {} are incorrect\", call_name),\n-                    );\n-                    // Call out where the function is defined\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n-                    err.emit();\n-                    break 'errors;\n                 }\n-            }\n-\n-            let mut err = if minimum_input_count == provided_arg_count {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    full_call_span,\n-                    E0308,\n-                    \"arguments to this {} are incorrect\",\n-                    call_name,\n-                )\n-            } else {\n-                tcx.sess.struct_span_err_with_code(\n-                    full_call_span,\n-                    &format!(\n-                        \"this {} takes {}{} but {} {} supplied\",\n-                        call_name,\n-                        if c_variadic { \"at least \" } else { \"\" },\n-                        potentially_plural_count(minimum_input_count, \"argument\"),\n-                        potentially_plural_count(provided_arg_count, \"argument\"),\n-                        if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                    ),\n-                    DiagnosticId::Error(err_code.to_owned()),\n-                )\n-            };\n-\n-            // As we encounter issues, keep track of what we want to provide for the suggestion\n-            let mut labels = vec![];\n-            // If there is a single error, we give a specific suggestion; otherwise, we change to\n-            // \"did you mean\" with the suggested function call\n-            enum SuggestionText {\n-                None,\n-                Provide(bool),\n-                Remove(bool),\n-                Swap,\n-                Reorder,\n-                DidYouMean,\n-            }\n-            let mut suggestion_text = SuggestionText::None;\n-\n-            let mut errors = errors.into_iter().peekable();\n-            while let Some(error) = errors.next() {\n-                match error {\n-                    Error::Invalid(input_idx, arg_idx, compatibility) => {\n-                        let expected_ty = expected_input_tys[arg_idx];\n-                        let provided_ty = final_arg_types[input_idx]\n-                            .map(|ty| ty.0)\n-                            .unwrap_or_else(|| tcx.ty_error());\n-                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                        if let Compatibility::Incompatible(error) = &compatibility {\n-                            let cause = &self.misc(provided_args[input_idx].span);\n-                            let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                            if let Some(e) = error {\n-                                self.note_type_err(\n-                                    &mut err,\n-                                    &trace.cause,\n-                                    None,\n-                                    Some(trace.values),\n-                                    e,\n-                                    false,\n-                                    true,\n-                                );\n-                            }\n+                Error::Extra(arg_idx) => {\n+                    let (provided_ty, provided_span) = provided_arg_tys[arg_idx];\n+                    let provided_ty_name = if !has_error_or_infer([provided_ty]) {\n+                        // FIXME: not suggestable, use something else\n+                        format!(\" of type `{}`\", provided_ty)\n+                    } else {\n+                        \"\".to_string()\n+                    };\n+                    labels\n+                        .push((provided_span, format!(\"argument{} unexpected\", provided_ty_name)));\n+                    suggestion_text = match suggestion_text {\n+                        SuggestionText::None => SuggestionText::Remove(false),\n+                        SuggestionText::Remove(_) => SuggestionText::Remove(true),\n+                        _ => SuggestionText::DidYouMean,\n+                    };\n+                }\n+                Error::Missing(expected_idx) => {\n+                    // If there are multiple missing arguments adjacent to each other,\n+                    // then we can provide a single error.\n+\n+                    let mut missing_idxs = vec![expected_idx];\n+                    while let Some(e) = errors.next_if(|e| {\n+                        matches!(e, Error::Missing(next_expected_idx)\n+                            if *next_expected_idx == *missing_idxs.last().unwrap() + 1)\n+                    }) {\n+                        match e {\n+                            Error::Missing(expected_idx) => missing_idxs.push(expected_idx),\n+                            _ => unreachable!(),\n                         }\n-\n-                        self.emit_coerce_suggestions(\n-                            &mut err,\n-                            &provided_args[input_idx],\n-                            provided_ty,\n-                            // FIXME(compiler-errors): expected_ty?\n-                            final_arg_types[input_idx]\n-                                .map(|ty| ty.1)\n-                                .unwrap_or_else(|| tcx.ty_error()),\n-                            None,\n-                            None,\n-                        );\n                     }\n-                    Error::Extra(arg_idx) => {\n-                        let arg_type = if let Some((_, ty)) = final_arg_types[arg_idx] {\n-                            if ty.references_error() || ty.has_infer_types() {\n-                                \"\".into()\n+\n+                    // NOTE: Because we might be re-arranging arguments, might have extra\n+                    // arguments, etc. it's hard to *really* know where we should provide\n+                    // this error label, so as a heuristic, we point to the provided arg, or\n+                    // to the call if the missing inputs pass the provided args.\n+                    match &missing_idxs[..] {\n+                        &[expected_idx] => {\n+                            let (_, input_ty) = formal_and_expected_inputs[expected_idx];\n+                            let span = if let Some((_, arg_span)) =\n+                                provided_arg_tys.get(expected_idx.to_provided_idx())\n+                            {\n+                                *arg_span\n                             } else {\n-                                format!(\" of type `{}`\", ty)\n-                            }\n-                        } else {\n-                            \"\".into()\n-                        };\n-                        labels.push((\n-                            provided_args[arg_idx].span,\n-                            format!(\"argument{} unexpected\", arg_type),\n-                        ));\n-                        suggestion_text = match suggestion_text {\n-                            SuggestionText::None => SuggestionText::Remove(false),\n-                            SuggestionText::Remove(_) => SuggestionText::Remove(true),\n-                            _ => SuggestionText::DidYouMean,\n-                        };\n-                    }\n-                    Error::Missing(input_idx) => {\n-                        // If there are multiple missing arguments adjacent to each other,\n-                        // then we can provide a single error.\n-\n-                        let mut missing_idxs = vec![input_idx];\n-                        while let Some(e) = errors.next_if(|e| matches!(e, Error::Missing(input_idx) if *input_idx == (missing_idxs.last().unwrap() + 1))) {\n-                            match e {\n-                                Error::Missing(input_idx) => missing_idxs.push(input_idx),\n-                                _ => unreachable!(),\n-                            }\n+                                args_span\n+                            };\n+                            let rendered = if !has_error_or_infer([input_ty]) {\n+                                format!(\" of type `{}`\", input_ty)\n+                            } else {\n+                                \"\".to_string()\n+                            };\n+                            labels.push((span, format!(\"an argument{} is missing\", rendered)));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None => SuggestionText::Provide(false),\n+                                SuggestionText::Provide(_) => SuggestionText::Provide(true),\n+                                _ => SuggestionText::DidYouMean,\n+                            };\n                         }\n-\n-                        // NOTE: Because we might be re-arranging arguments, might have extra\n-                        // arguments, etc. it's hard to *really* know where we should provide\n-                        // this error label, so as a heuristic, we point to the provided arg, or\n-                        // to the call if the missing inputs pass the provided args.\n-                        match &missing_idxs[..] {\n-                            &[input_idx] => {\n-                                let expected_ty = expected_input_tys[input_idx];\n-                                let input_ty = self.resolve_vars_if_possible(expected_ty);\n-                                let span = if input_idx < provided_arg_count {\n-                                    let arg_span = provided_args[input_idx].span;\n-                                    Span::new(arg_span.lo(), arg_span.hi(), arg_span.ctxt(), None)\n-                                } else {\n-                                    args_span\n-                                };\n-                                let arg_type =\n-                                    if input_ty.references_error() || input_ty.has_infer_types() {\n-                                        \"\".into()\n-                                    } else {\n-                                        format!(\" of type `{}`\", input_ty)\n-                                    };\n-                                labels.push((span, format!(\"an argument{} is missing\", arg_type)));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None => SuggestionText::Provide(false),\n-                                    SuggestionText::Provide(_) => SuggestionText::Provide(true),\n-                                    _ => SuggestionText::DidYouMean,\n-                                };\n-                            }\n-                            &[first_idx, second_idx] => {\n-                                let first_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[first_idx]);\n-                                let second_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[second_idx]);\n-\n-                                let span = if second_idx < provided_arg_count {\n-                                    let first_arg_span = provided_args[first_idx].span;\n-                                    let second_arg_span = provided_args[second_idx].span;\n-                                    Span::new(\n-                                        first_arg_span.lo(),\n-                                        second_arg_span.hi(),\n-                                        first_arg_span.ctxt(),\n-                                        None,\n-                                    )\n-                                } else {\n-                                    args_span\n-                                };\n-                                let any_unnameable = false\n-                                    || first_input_ty.references_error()\n-                                    || first_input_ty.has_infer_types()\n-                                    || second_input_ty.references_error()\n-                                    || second_input_ty.has_infer_types();\n-                                let arg_type = if any_unnameable {\n-                                    \"\".into()\n-                                } else {\n+                        &[first_idx, second_idx] => {\n+                            let (_, first_expected_ty) = formal_and_expected_inputs[first_idx];\n+                            let (_, second_expected_ty) = formal_and_expected_inputs[second_idx];\n+                            let span = if let (Some((_, first_span)), Some((_, second_span))) = (\n+                                provided_arg_tys.get(first_idx.to_provided_idx()),\n+                                provided_arg_tys.get(second_idx.to_provided_idx()),\n+                            ) {\n+                                first_span.to(*second_span)\n+                            } else {\n+                                args_span\n+                            };\n+                            let rendered =\n+                                if !has_error_or_infer([first_expected_ty, second_expected_ty]) {\n                                     format!(\n                                         \" of type `{}` and `{}`\",\n-                                        first_input_ty, second_input_ty\n-                                    )\n-                                };\n-                                labels\n-                                    .push((span, format!(\"two arguments{} are missing\", arg_type)));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None | SuggestionText::Provide(_) => {\n-                                        SuggestionText::Provide(true)\n-                                    }\n-                                    _ => SuggestionText::DidYouMean,\n-                                };\n-                            }\n-                            &[first_idx, second_idx, third_idx] => {\n-                                let first_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[first_idx]);\n-                                let second_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[second_idx]);\n-                                let third_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[third_idx]);\n-                                let span = if third_idx < provided_arg_count {\n-                                    let first_arg_span = provided_args[first_idx].span;\n-                                    let third_arg_span = provided_args[third_idx].span;\n-                                    Span::new(\n-                                        first_arg_span.lo(),\n-                                        third_arg_span.hi(),\n-                                        first_arg_span.ctxt(),\n-                                        None,\n-                                    )\n-                                } else {\n-                                    args_span\n-                                };\n-                                let any_unnameable = false\n-                                    || first_input_ty.references_error()\n-                                    || first_input_ty.has_infer_types()\n-                                    || second_input_ty.references_error()\n-                                    || second_input_ty.has_infer_types()\n-                                    || third_input_ty.references_error()\n-                                    || third_input_ty.has_infer_types();\n-                                let arg_type = if any_unnameable {\n-                                    \"\".into()\n-                                } else {\n-                                    format!(\n-                                        \" of type `{}`, `{}`, and `{}`\",\n-                                        first_input_ty, second_input_ty, third_input_ty\n-                                    )\n-                                };\n-                                labels.push((\n-                                    span,\n-                                    format!(\"three arguments{} are missing\", arg_type),\n-                                ));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None | SuggestionText::Provide(_) => {\n-                                        SuggestionText::Provide(true)\n-                                    }\n-                                    _ => SuggestionText::DidYouMean,\n-                                };\n-                            }\n-                            missing_idxs => {\n-                                let first_idx = *missing_idxs.first().unwrap();\n-                                let last_idx = *missing_idxs.last().unwrap();\n-                                // NOTE: Because we might be re-arranging arguments, might have extra arguments, etc.\n-                                // It's hard to *really* know where we should provide this error label, so this is a\n-                                // decent heuristic\n-                                let span = if last_idx < provided_arg_count {\n-                                    let first_arg_span = provided_args[first_idx].span;\n-                                    let last_arg_span = provided_args[last_idx].span;\n-                                    Span::new(\n-                                        first_arg_span.lo(),\n-                                        last_arg_span.hi(),\n-                                        first_arg_span.ctxt(),\n-                                        None,\n+                                        first_expected_ty, second_expected_ty\n                                     )\n                                 } else {\n-                                    // Otherwise just label the whole function\n-                                    args_span\n-                                };\n-                                labels.push((span, format!(\"multiple arguments are missing\")));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None | SuggestionText::Provide(_) => {\n-                                        SuggestionText::Provide(true)\n-                                    }\n-                                    _ => SuggestionText::DidYouMean,\n+                                    \"\".to_string()\n                                 };\n-                            }\n+                            labels.push((span, format!(\"two arguments{} are missing\", rendered)));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None | SuggestionText::Provide(_) => {\n+                                    SuggestionText::Provide(true)\n+                                }\n+                                _ => SuggestionText::DidYouMean,\n+                            };\n                         }\n-                    }\n-                    Error::Swap(input_idx, other_input_idx, arg_idx, other_arg_idx) => {\n-                        let first_span = provided_args[input_idx].span;\n-                        let second_span = provided_args[other_input_idx].span;\n-\n-                        let first_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[arg_idx]);\n-                        let first_provided_ty = if let Some((ty, _)) = final_arg_types[input_idx] {\n-                            format!(\", found `{}`\", ty)\n-                        } else {\n-                            String::new()\n-                        };\n-                        labels.push((\n-                            first_span,\n-                            format!(\"expected `{}`{}\", first_expected_ty, first_provided_ty),\n-                        ));\n-                        let other_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[other_arg_idx]);\n-                        let other_provided_ty =\n-                            if let Some((ty, _)) = final_arg_types[other_input_idx] {\n-                                format!(\", found `{}`\", ty)\n+                        &[first_idx, second_idx, third_idx] => {\n+                            let (_, first_expected_ty) = formal_and_expected_inputs[first_idx];\n+                            let (_, second_expected_ty) = formal_and_expected_inputs[second_idx];\n+                            let (_, third_expected_ty) = formal_and_expected_inputs[third_idx];\n+                            let span = if let (Some((_, first_span)), Some((_, third_span))) = (\n+                                provided_arg_tys.get(first_idx.to_provided_idx()),\n+                                provided_arg_tys.get(third_idx.to_provided_idx()),\n+                            ) {\n+                                first_span.to(*third_span)\n                             } else {\n-                                String::new()\n+                                args_span\n                             };\n-                        labels.push((\n-                            second_span,\n-                            format!(\"expected `{}`{}\", other_expected_ty, other_provided_ty),\n-                        ));\n-                        suggestion_text = match suggestion_text {\n-                            SuggestionText::None => SuggestionText::Swap,\n-                            _ => SuggestionText::DidYouMean,\n-                        };\n-                    }\n-                    Error::Permutation(args) => {\n-                        for (dst_arg, dest_input) in args {\n-                            let expected_ty =\n-                                self.resolve_vars_if_possible(expected_input_tys[dst_arg]);\n-                            let provided_ty = if let Some((ty, _)) = final_arg_types[dest_input] {\n-                                format!(\", found `{}`\", ty)\n+                            let rendered = if !has_error_or_infer([\n+                                first_expected_ty,\n+                                second_expected_ty,\n+                                third_expected_ty,\n+                            ]) {\n+                                format!(\n+                                    \" of type `{}`, `{}`, and `{}`\",\n+                                    first_expected_ty, second_expected_ty, third_expected_ty\n+                                )\n                             } else {\n-                                String::new()\n+                                \"\".to_string()\n+                            };\n+                            labels.push((span, format!(\"three arguments{} are missing\", rendered)));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None | SuggestionText::Provide(_) => {\n+                                    SuggestionText::Provide(true)\n+                                }\n+                                _ => SuggestionText::DidYouMean,\n+                            };\n+                        }\n+                        missing_idxs => {\n+                            let first_idx = *missing_idxs.first().unwrap();\n+                            let last_idx = *missing_idxs.last().unwrap();\n+                            // NOTE: Because we might be re-arranging arguments, might have extra arguments, etc.\n+                            // It's hard to *really* know where we should provide this error label, so this is a\n+                            // decent heuristic\n+                            let span = if let (Some((_, first_span)), Some((_, last_span))) = (\n+                                provided_arg_tys.get(first_idx.to_provided_idx()),\n+                                provided_arg_tys.get(last_idx.to_provided_idx()),\n+                            ) {\n+                                first_span.to(*last_span)\n+                            } else {\n+                                args_span\n+                            };\n+                            labels.push((span, format!(\"multiple arguments are missing\")));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None | SuggestionText::Provide(_) => {\n+                                    SuggestionText::Provide(true)\n+                                }\n+                                _ => SuggestionText::DidYouMean,\n                             };\n-                            labels.push((\n-                                provided_args[dest_input].span,\n-                                format!(\"expected `{}`{}\", expected_ty, provided_ty),\n-                            ));\n                         }\n-\n-                        suggestion_text = match suggestion_text {\n-                            SuggestionText::None => SuggestionText::Reorder,\n-                            _ => SuggestionText::DidYouMean,\n-                        };\n                     }\n                 }\n-            }\n-\n-            // If we have less than 5 things to say, it would be useful to call out exactly what's wrong\n-            if labels.len() <= 5 {\n-                for (span, label) in labels {\n-                    err.span_label(span, label);\n-                }\n-            }\n-\n-            // Call out where the function is defined\n-            label_fn_like(tcx, &mut err, fn_def_id);\n-\n-            // And add a suggestion block for all of the parameters\n-            let suggestion_text = match suggestion_text {\n-                SuggestionText::None => None,\n-                SuggestionText::Provide(plural) => {\n-                    Some(format!(\"provide the argument{}\", if plural { \"s\" } else { \"\" }))\n-                }\n-                SuggestionText::Remove(plural) => {\n-                    Some(format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }))\n-                }\n-                SuggestionText::Swap => Some(\"swap these arguments\".to_string()),\n-                SuggestionText::Reorder => Some(\"reorder these arguments\".to_string()),\n-                SuggestionText::DidYouMean => Some(\"did you mean\".to_string()),\n-            };\n-            if let Some(suggestion_text) = suggestion_text {\n-                let source_map = self.sess().source_map();\n-                let mut suggestion = format!(\n-                    \"{}(\",\n-                    source_map.span_to_snippet(full_call_span).unwrap_or_else(|_| String::new())\n-                );\n-                for (arg_index, input_idx) in matched_inputs.iter().enumerate() {\n-                    let suggestion_text = if let Some(input_idx) = input_idx {\n-                        let arg_span = provided_args[*input_idx].span.source_callsite();\n-                        let arg_text = source_map.span_to_snippet(arg_span).unwrap();\n-                        arg_text\n+                Error::Swap(\n+                    first_provided_idx,\n+                    second_provided_idx,\n+                    first_expected_idx,\n+                    second_expected_idx,\n+                ) => {\n+                    let (first_provided_ty, first_span) = provided_arg_tys[first_provided_idx];\n+                    let (_, first_expected_ty) = formal_and_expected_inputs[first_expected_idx];\n+                    let first_provided_ty_name = if !has_error_or_infer([first_provided_ty]) {\n+                        format!(\", found `{}`\", first_provided_ty)\n                     } else {\n-                        // Propose a placeholder of the correct type\n-                        let expected_ty = expected_input_tys[arg_index];\n-                        let input_ty = self.resolve_vars_if_possible(expected_ty);\n-                        if input_ty.is_unit() {\n-                            \"()\".to_string()\n-                        } else if !input_ty.is_ty_var() {\n-                            format!(\"/* {} */\", input_ty)\n+                        String::new()\n+                    };\n+                    labels.push((\n+                        first_span,\n+                        format!(\"expected `{}`{}\", first_expected_ty, first_provided_ty_name),\n+                    ));\n+\n+                    let (second_provided_ty, second_span) = provided_arg_tys[second_provided_idx];\n+                    let (_, second_expected_ty) = formal_and_expected_inputs[second_expected_idx];\n+                    let second_provided_ty_name = if !has_error_or_infer([second_provided_ty]) {\n+                        format!(\", found `{}`\", second_provided_ty)\n+                    } else {\n+                        String::new()\n+                    };\n+                    labels.push((\n+                        second_span,\n+                        format!(\"expected `{}`{}\", second_expected_ty, second_provided_ty_name),\n+                    ));\n+\n+                    suggestion_text = match suggestion_text {\n+                        SuggestionText::None => SuggestionText::Swap,\n+                        _ => SuggestionText::DidYouMean,\n+                    };\n+                }\n+                Error::Permutation(args) => {\n+                    for (dst_arg, dest_input) in args {\n+                        let (_, expected_ty) = formal_and_expected_inputs[dst_arg];\n+                        let (provided_ty, provided_span) = provided_arg_tys[dest_input];\n+                        let provided_ty_name = if !has_error_or_infer([provided_ty]) {\n+                            format!(\", found `{}`\", provided_ty)\n                         } else {\n-                            \"/* value */\".to_string()\n+                            String::new()\n+                        };\n+                        // FIXME(compiler-errors): Why do we get permutations with the same type?\n+                        if expected_ty != provided_ty {\n+                            labels.push((\n+                                provided_span,\n+                                format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n+                            ));\n                         }\n-                    };\n-                    suggestion += &suggestion_text;\n-                    if arg_index < minimum_input_count - 1 {\n-                        suggestion += \", \";\n                     }\n+\n+                    suggestion_text = match suggestion_text {\n+                        SuggestionText::None => SuggestionText::Reorder,\n+                        _ => SuggestionText::DidYouMean,\n+                    };\n                 }\n-                suggestion += \")\";\n-                err.span_suggestion_verbose(\n-                    error_span,\n-                    &suggestion_text,\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n             }\n-            err.emit();\n         }\n \n-        for arg in provided_args.iter().skip(minimum_input_count) {\n-            let arg_ty = self.check_expr(&arg);\n+        // If we have less than 5 things to say, it would be useful to call out exactly what's wrong\n+        if labels.len() <= 5 {\n+            for (span, label) in labels {\n+                err.span_label(span, label);\n+            }\n+        }\n \n-            // If the function is c-style variadic, we skipped a bunch of arguments\n-            // so we need to check those, and write out the types\n-            // Ideally this would be folded into the above, for uniform style\n-            // but c-variadic is already a corner case\n-            if c_variadic {\n-                fn variadic_error<'tcx>(\n-                    sess: &'tcx Session,\n-                    span: Span,\n-                    ty: Ty<'tcx>,\n-                    cast_ty: &str,\n-                ) {\n-                    use crate::structured_errors::MissingCastForVariadicArg;\n+        // Call out where the function is defined\n+        label_fn_like(tcx, &mut err, fn_def_id);\n \n-                    MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n+        // And add a suggestion block for all of the parameters\n+        let suggestion_text = match suggestion_text {\n+            SuggestionText::None => None,\n+            SuggestionText::Provide(plural) => {\n+                Some(format!(\"provide the argument{}\", if plural { \"s\" } else { \"\" }))\n+            }\n+            SuggestionText::Remove(plural) => {\n+                Some(format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }))\n+            }\n+            SuggestionText::Swap => Some(\"swap these arguments\".to_string()),\n+            SuggestionText::Reorder => Some(\"reorder these arguments\".to_string()),\n+            SuggestionText::DidYouMean => Some(\"did you mean\".to_string()),\n+        };\n+        if let Some(suggestion_text) = suggestion_text {\n+            let source_map = self.sess().source_map();\n+            let mut suggestion = format!(\n+                \"{}(\",\n+                source_map.span_to_snippet(full_call_span).unwrap_or_else(|_| fn_def_id\n+                    .map_or(\"\".to_string(), |fn_def_id| tcx.item_name(fn_def_id).to_string()))\n+            );\n+            let mut needs_comma = false;\n+            for (expected_idx, provided_idx) in matched_inputs.iter_enumerated() {\n+                if needs_comma {\n+                    suggestion += \", \";\n+                } else {\n+                    needs_comma = true;\n                 }\n-\n-                // There are a few types which get autopromoted when passed via varargs\n-                // in C but we just error out instead and require explicit casts.\n-                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n-                match arg_ty.kind() {\n-                    ty::Float(ty::FloatTy::F32) => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n-                    }\n-                    ty::Int(ty::IntTy::I8 | ty::IntTy::I16) | ty::Bool => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n-                    }\n-                    ty::Uint(ty::UintTy::U8 | ty::UintTy::U16) => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n-                    }\n-                    ty::FnDef(..) => {\n-                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_vars_if_possible(ptr_ty);\n-                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n+                let suggestion_text =\n+                    if let Some(provided_idx) = provided_idx\n+                    && let (_, provided_span) = provided_arg_tys[*provided_idx]\n+                    && let Ok(arg_text) = source_map.span_to_snippet(provided_span.source_callsite()) {\n+                    arg_text\n+                } else {\n+                    // Propose a placeholder of the correct type\n+                    let (_, expected_ty) = formal_and_expected_inputs[expected_idx];\n+                    if expected_ty.is_unit() {\n+                        \"()\".to_string()\n+                    } else if expected_ty.is_suggestable(tcx) {\n+                        format!(\"/* {} */\", expected_ty)\n+                    } else {\n+                        \"/* value */\".to_string()\n                     }\n-                    _ => {}\n-                }\n+                };\n+                suggestion += &suggestion_text;\n             }\n+            suggestion += \")\";\n+            err.span_suggestion_verbose(\n+                error_span,\n+                &suggestion_text,\n+                suggestion,\n+                Applicability::HasPlaceholders,\n+            );\n         }\n+\n+        err.emit();\n     }\n \n     fn suggested_tuple_wrap("}, {"sha": "d230c06a2112f87251f8063d95c3c0806cddc360", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 447, "deletions": 134, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -70,6 +70,214 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     unsafe { crate::ptr::drop_in_place(to_drop) }\n }\n \n+// These have been renamed.\n+#[cfg(bootstrap)]\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_fence();\n+    pub fn atomic_fence_acq();\n+    pub fn atomic_fence_rel();\n+    pub fn atomic_fence_acqrel();\n+    pub fn atomic_singlethreadfence();\n+    pub fn atomic_singlethreadfence_acq();\n+    pub fn atomic_singlethreadfence_rel();\n+    pub fn atomic_singlethreadfence_acqrel();\n+}\n+\n+// These have been renamed.\n+#[cfg(bootstrap)]\n+mod atomics {\n+    pub use super::atomic_cxchg as atomic_cxchg_seqcst_seqcst;\n+    pub use super::atomic_cxchg_acq as atomic_cxchg_acquire_acquire;\n+    pub use super::atomic_cxchg_acq_failrelaxed as atomic_cxchg_acquire_relaxed;\n+    pub use super::atomic_cxchg_acqrel as atomic_cxchg_acqrel_acquire;\n+    pub use super::atomic_cxchg_acqrel_failrelaxed as atomic_cxchg_acqrel_relaxed;\n+    pub use super::atomic_cxchg_failacq as atomic_cxchg_seqcst_acquire;\n+    pub use super::atomic_cxchg_failrelaxed as atomic_cxchg_seqcst_relaxed;\n+    pub use super::atomic_cxchg_rel as atomic_cxchg_release_relaxed;\n+    pub use super::atomic_cxchg_relaxed as atomic_cxchg_relaxed_relaxed;\n+\n+    pub use super::atomic_cxchgweak as atomic_cxchgweak_seqcst_seqcst;\n+    pub use super::atomic_cxchgweak_acq as atomic_cxchgweak_acquire_acquire;\n+    pub use super::atomic_cxchgweak_acq_failrelaxed as atomic_cxchgweak_acquire_relaxed;\n+    pub use super::atomic_cxchgweak_acqrel as atomic_cxchgweak_acqrel_acquire;\n+    pub use super::atomic_cxchgweak_acqrel_failrelaxed as atomic_cxchgweak_acqrel_relaxed;\n+    pub use super::atomic_cxchgweak_failacq as atomic_cxchgweak_seqcst_acquire;\n+    pub use super::atomic_cxchgweak_failrelaxed as atomic_cxchgweak_seqcst_relaxed;\n+    pub use super::atomic_cxchgweak_rel as atomic_cxchgweak_release_relaxed;\n+    pub use super::atomic_cxchgweak_relaxed as atomic_cxchgweak_relaxed_relaxed;\n+\n+    pub use super::atomic_load as atomic_load_seqcst;\n+    pub use super::atomic_load_acq as atomic_load_acquire;\n+    pub use super::atomic_load_relaxed;\n+    pub use super::atomic_load_unordered;\n+\n+    pub use super::atomic_store as atomic_store_seqcst;\n+    pub use super::atomic_store_rel as atomic_store_release;\n+    pub use super::atomic_store_relaxed;\n+    pub use super::atomic_store_unordered;\n+\n+    pub use super::atomic_xchg as atomic_xchg_seqcst;\n+    pub use super::atomic_xchg_acq as atomic_xchg_acquire;\n+    pub use super::atomic_xchg_acqrel;\n+    pub use super::atomic_xchg_rel as atomic_xchg_release;\n+    pub use super::atomic_xchg_relaxed;\n+\n+    pub use super::atomic_xadd as atomic_xadd_seqcst;\n+    pub use super::atomic_xadd_acq as atomic_xadd_acquire;\n+    pub use super::atomic_xadd_acqrel;\n+    pub use super::atomic_xadd_rel as atomic_xadd_release;\n+    pub use super::atomic_xadd_relaxed;\n+\n+    pub use super::atomic_xsub as atomic_xsub_seqcst;\n+    pub use super::atomic_xsub_acq as atomic_xsub_acquire;\n+    pub use super::atomic_xsub_acqrel;\n+    pub use super::atomic_xsub_rel as atomic_xsub_release;\n+    pub use super::atomic_xsub_relaxed;\n+\n+    pub use super::atomic_and as atomic_and_seqcst;\n+    pub use super::atomic_and_acq as atomic_and_acquire;\n+    pub use super::atomic_and_acqrel;\n+    pub use super::atomic_and_rel as atomic_and_release;\n+    pub use super::atomic_and_relaxed;\n+\n+    pub use super::atomic_nand as atomic_nand_seqcst;\n+    pub use super::atomic_nand_acq as atomic_nand_acquire;\n+    pub use super::atomic_nand_acqrel;\n+    pub use super::atomic_nand_rel as atomic_nand_release;\n+    pub use super::atomic_nand_relaxed;\n+\n+    pub use super::atomic_or as atomic_or_seqcst;\n+    pub use super::atomic_or_acq as atomic_or_acquire;\n+    pub use super::atomic_or_acqrel;\n+    pub use super::atomic_or_rel as atomic_or_release;\n+    pub use super::atomic_or_relaxed;\n+\n+    pub use super::atomic_xor as atomic_xor_seqcst;\n+    pub use super::atomic_xor_acq as atomic_xor_acquire;\n+    pub use super::atomic_xor_acqrel;\n+    pub use super::atomic_xor_rel as atomic_xor_release;\n+    pub use super::atomic_xor_relaxed;\n+\n+    pub use super::atomic_max as atomic_max_seqcst;\n+    pub use super::atomic_max_acq as atomic_max_acquire;\n+    pub use super::atomic_max_acqrel;\n+    pub use super::atomic_max_rel as atomic_max_release;\n+    pub use super::atomic_max_relaxed;\n+\n+    pub use super::atomic_min as atomic_min_seqcst;\n+    pub use super::atomic_min_acq as atomic_min_acquire;\n+    pub use super::atomic_min_acqrel;\n+    pub use super::atomic_min_rel as atomic_min_release;\n+    pub use super::atomic_min_relaxed;\n+\n+    pub use super::atomic_umin as atomic_umin_seqcst;\n+    pub use super::atomic_umin_acq as atomic_umin_acquire;\n+    pub use super::atomic_umin_acqrel;\n+    pub use super::atomic_umin_rel as atomic_umin_release;\n+    pub use super::atomic_umin_relaxed;\n+\n+    pub use super::atomic_umax as atomic_umax_seqcst;\n+    pub use super::atomic_umax_acq as atomic_umax_acquire;\n+    pub use super::atomic_umax_acqrel;\n+    pub use super::atomic_umax_rel as atomic_umax_release;\n+    pub use super::atomic_umax_relaxed;\n+\n+    pub use super::atomic_fence as atomic_fence_seqcst;\n+    pub use super::atomic_fence_acq as atomic_fence_acquire;\n+    pub use super::atomic_fence_acqrel;\n+    pub use super::atomic_fence_rel as atomic_fence_release;\n+\n+    pub use super::atomic_singlethreadfence as atomic_singlethreadfence_seqcst;\n+    pub use super::atomic_singlethreadfence_acq as atomic_singlethreadfence_acquire;\n+    pub use super::atomic_singlethreadfence_acqrel;\n+    pub use super::atomic_singlethreadfence_rel as atomic_singlethreadfence_release;\n+}\n+\n+#[cfg(bootstrap)]\n+pub use atomics::*;\n+\n+#[cfg(not(bootstrap))]\n extern \"rust-intrinsic\" {\n     // N.B., these intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n@@ -78,142 +286,226 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as both the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as both the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n-    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n-    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -227,13 +519,13 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n-    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n-    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -247,19 +539,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n-    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n-    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n-    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -278,19 +570,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n-    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n-    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n-    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -309,19 +601,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n-    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n-    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n-    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -340,19 +632,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n-    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n-    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n-    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -371,19 +663,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n-    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n-    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n-    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -402,19 +694,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n-    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n-    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n-    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -433,19 +725,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n-    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n-    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n-    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -464,19 +756,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n-    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n-    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n-    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -495,19 +787,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n-    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n-    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n-    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -526,19 +818,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n-    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n-    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n-    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -557,19 +849,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n-    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n-    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n-    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -583,67 +875,24 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n-}\n-\n-extern \"rust-intrinsic\" {\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n-    pub fn atomic_fence();\n+    pub fn atomic_fence_seqcst();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n-    pub fn atomic_fence_acq();\n+    pub fn atomic_fence_acquire();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n-    pub fn atomic_fence_rel();\n+    pub fn atomic_fence_release();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n@@ -661,7 +910,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n-    pub fn atomic_singlethreadfence();\n+    pub fn atomic_singlethreadfence_seqcst();\n     /// A compiler-only memory barrier.\n     ///\n     /// Memory accesses will never be reordered across this barrier by the\n@@ -672,7 +921,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n-    pub fn atomic_singlethreadfence_acq();\n+    pub fn atomic_singlethreadfence_acquire();\n     /// A compiler-only memory barrier.\n     ///\n     /// Memory accesses will never be reordered across this barrier by the\n@@ -683,7 +932,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n-    pub fn atomic_singlethreadfence_rel();\n+    pub fn atomic_singlethreadfence_release();\n     /// A compiler-only memory barrier.\n     ///\n     /// Memory accesses will never be reordered across this barrier by the\n@@ -695,6 +944,70 @@ extern \"rust-intrinsic\" {\n     /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_acqrel();\n+}\n+\n+// These have been renamed.\n+//\n+// These are the aliases for the old names.\n+// To be removed when stdarch and panic_unwind have been updated.\n+#[cfg(not(bootstrap))]\n+mod atomics {\n+    pub use super::atomic_cxchg_acqrel_acquire as atomic_cxchg_acqrel;\n+    pub use super::atomic_cxchg_acqrel_relaxed as atomic_cxchg_acqrel_failrelaxed;\n+    pub use super::atomic_cxchg_acquire_acquire as atomic_cxchg_acq;\n+    pub use super::atomic_cxchg_acquire_relaxed as atomic_cxchg_acq_failrelaxed;\n+    pub use super::atomic_cxchg_relaxed_relaxed as atomic_cxchg_relaxed;\n+    pub use super::atomic_cxchg_release_relaxed as atomic_cxchg_rel;\n+    pub use super::atomic_cxchg_seqcst_acquire as atomic_cxchg_failacq;\n+    pub use super::atomic_cxchg_seqcst_relaxed as atomic_cxchg_failrelaxed;\n+    pub use super::atomic_cxchg_seqcst_seqcst as atomic_cxchg;\n+    pub use super::atomic_store_seqcst as atomic_store;\n+}\n+\n+#[cfg(not(bootstrap))]\n+pub use atomics::*;\n+\n+extern \"rust-intrinsic\" {\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n \n     /// Magic intrinsic that derives its meaning from attributes\n     /// attached to the function."}, {"sha": "a68c6080e3a179a5d74050307130f3977a0232b9", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 86, "deletions": 74, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2575,11 +2575,11 @@ unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n     // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n     unsafe {\n         match order {\n-            Release => intrinsics::atomic_store_rel(dst, val),\n             Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_store(dst, val),\n+            Release => intrinsics::atomic_store_release(dst, val),\n+            SeqCst => intrinsics::atomic_store_seqcst(dst, val),\n             Acquire => panic!(\"there is no such thing as an acquire store\"),\n-            AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire-release store\"),\n         }\n     }\n }\n@@ -2589,11 +2589,11 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_load_acq(dst),\n             Relaxed => intrinsics::atomic_load_relaxed(dst),\n-            SeqCst => intrinsics::atomic_load(dst),\n+            Acquire => intrinsics::atomic_load_acquire(dst),\n+            SeqCst => intrinsics::atomic_load_seqcst(dst),\n             Release => panic!(\"there is no such thing as a release load\"),\n-            AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire-release load\"),\n         }\n     }\n }\n@@ -2604,11 +2604,11 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-            Release => intrinsics::atomic_xchg_rel(dst, val),\n-            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xchg(dst, val),\n+            Acquire => intrinsics::atomic_xchg_acquire(dst, val),\n+            Release => intrinsics::atomic_xchg_release(dst, val),\n+            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_xchg_seqcst(dst, val),\n         }\n     }\n }\n@@ -2620,11 +2620,11 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-            Release => intrinsics::atomic_xadd_rel(dst, val),\n-            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xadd(dst, val),\n+            Acquire => intrinsics::atomic_xadd_acquire(dst, val),\n+            Release => intrinsics::atomic_xadd_release(dst, val),\n+            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_xadd_seqcst(dst, val),\n         }\n     }\n }\n@@ -2636,11 +2636,11 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-            Release => intrinsics::atomic_xsub_rel(dst, val),\n-            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xsub(dst, val),\n+            Acquire => intrinsics::atomic_xsub_acquire(dst, val),\n+            Release => intrinsics::atomic_xsub_release(dst, val),\n+            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_xsub_seqcst(dst, val),\n         }\n     }\n }\n@@ -2657,16 +2657,22 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n     // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.\n     let (val, ok) = unsafe {\n         match (success, failure) {\n-            (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n-            (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n-            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-            (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n-            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n-            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n-            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n-            (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n-            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed_relaxed(dst, old, new),\n+            //(Relaxed, Acquire) => intrinsics::atomic_cxchg_relaxed_acquire(dst, old, new),\n+            //(Relaxed, SeqCst) => intrinsics::atomic_cxchg_relaxed_seqcst(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acquire_relaxed(dst, old, new),\n+            (Acquire, Acquire) => intrinsics::atomic_cxchg_acquire_acquire(dst, old, new),\n+            //(Acquire, SeqCst) => intrinsics::atomic_cxchg_acquire_seqcst(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchg_release_relaxed(dst, old, new),\n+            //(Release, Acquire) => intrinsics::atomic_cxchg_release_acquire(dst, old, new),\n+            //(Release, SeqCst) => intrinsics::atomic_cxchg_release_seqcst(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_relaxed(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel_acquire(dst, old, new),\n+            //(AcqRel, SeqCst) => intrinsics::atomic_cxchg_acqrel_seqcst(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_seqcst_relaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchg_seqcst_acquire(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchg_seqcst_seqcst(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire-release failure ordering\"),\n             (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n             _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n         }\n@@ -2686,16 +2692,22 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.\n     let (val, ok) = unsafe {\n         match (success, failure) {\n-            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n-            (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n-            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n-            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n-            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n-            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n-            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n-            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n-            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n-            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed_relaxed(dst, old, new),\n+            //(Relaxed, Acquire) => intrinsics::atomic_cxchgweak_relaxed_acquire(dst, old, new),\n+            //(Relaxed, SeqCst) => intrinsics::atomic_cxchgweak_relaxed_seqcst(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acquire_relaxed(dst, old, new),\n+            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acquire_acquire(dst, old, new),\n+            //(Acquire, SeqCst) => intrinsics::atomic_cxchgweak_acquire_seqcst(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchgweak_release_relaxed(dst, old, new),\n+            //(Release, Acquire) => intrinsics::atomic_cxchgweak_release_acquire(dst, old, new),\n+            //(Release, SeqCst) => intrinsics::atomic_cxchgweak_release_seqcst(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_relaxed(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel_acquire(dst, old, new),\n+            //(AcqRel, SeqCst) => intrinsics::atomic_cxchgweak_acqrel_seqcst(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_seqcst_relaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_seqcst_acquire(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak_seqcst_seqcst(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire-release failure ordering\"),\n             (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n             _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n         }\n@@ -2709,11 +2721,11 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_and_acq(dst, val),\n-            Release => intrinsics::atomic_and_rel(dst, val),\n-            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_and(dst, val),\n+            Acquire => intrinsics::atomic_and_acquire(dst, val),\n+            Release => intrinsics::atomic_and_release(dst, val),\n+            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_and_seqcst(dst, val),\n         }\n     }\n }\n@@ -2724,11 +2736,11 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_nand_acq(dst, val),\n-            Release => intrinsics::atomic_nand_rel(dst, val),\n-            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_nand(dst, val),\n+            Acquire => intrinsics::atomic_nand_acquire(dst, val),\n+            Release => intrinsics::atomic_nand_release(dst, val),\n+            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_nand_seqcst(dst, val),\n         }\n     }\n }\n@@ -2739,11 +2751,11 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_or_acq(dst, val),\n-            Release => intrinsics::atomic_or_rel(dst, val),\n+            SeqCst => intrinsics::atomic_or_seqcst(dst, val),\n+            Acquire => intrinsics::atomic_or_acquire(dst, val),\n+            Release => intrinsics::atomic_or_release(dst, val),\n             AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_or(dst, val),\n         }\n     }\n }\n@@ -2754,11 +2766,11 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xor_acq(dst, val),\n-            Release => intrinsics::atomic_xor_rel(dst, val),\n+            SeqCst => intrinsics::atomic_xor_seqcst(dst, val),\n+            Acquire => intrinsics::atomic_xor_acquire(dst, val),\n+            Release => intrinsics::atomic_xor_release(dst, val),\n             AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xor(dst, val),\n         }\n     }\n }\n@@ -2770,11 +2782,11 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_max_acq(dst, val),\n-            Release => intrinsics::atomic_max_rel(dst, val),\n-            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_max(dst, val),\n+            Acquire => intrinsics::atomic_max_acquire(dst, val),\n+            Release => intrinsics::atomic_max_release(dst, val),\n+            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_max_seqcst(dst, val),\n         }\n     }\n }\n@@ -2786,11 +2798,11 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_min_acq(dst, val),\n-            Release => intrinsics::atomic_min_rel(dst, val),\n-            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_min(dst, val),\n+            Acquire => intrinsics::atomic_min_acquire(dst, val),\n+            Release => intrinsics::atomic_min_release(dst, val),\n+            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_min_seqcst(dst, val),\n         }\n     }\n }\n@@ -2802,11 +2814,11 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_umax_acq(dst, val),\n-            Release => intrinsics::atomic_umax_rel(dst, val),\n-            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_umax(dst, val),\n+            Acquire => intrinsics::atomic_umax_acquire(dst, val),\n+            Release => intrinsics::atomic_umax_release(dst, val),\n+            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_umax_seqcst(dst, val),\n         }\n     }\n }\n@@ -2818,11 +2830,11 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_umin_acq(dst, val),\n-            Release => intrinsics::atomic_umin_rel(dst, val),\n-            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_umin(dst, val),\n+            Acquire => intrinsics::atomic_umin_acquire(dst, val),\n+            Release => intrinsics::atomic_umin_release(dst, val),\n+            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_umin_seqcst(dst, val),\n         }\n     }\n }\n@@ -2908,10 +2920,10 @@ pub fn fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_fence_acq(),\n-            Release => intrinsics::atomic_fence_rel(),\n+            Acquire => intrinsics::atomic_fence_acquire(),\n+            Release => intrinsics::atomic_fence_release(),\n             AcqRel => intrinsics::atomic_fence_acqrel(),\n-            SeqCst => intrinsics::atomic_fence(),\n+            SeqCst => intrinsics::atomic_fence_seqcst(),\n             Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n         }\n     }\n@@ -2990,10 +3002,10 @@ pub fn compiler_fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_singlethreadfence_acq(),\n-            Release => intrinsics::atomic_singlethreadfence_rel(),\n+            Acquire => intrinsics::atomic_singlethreadfence_acquire(),\n+            Release => intrinsics::atomic_singlethreadfence_release(),\n             AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n-            SeqCst => intrinsics::atomic_singlethreadfence(),\n+            SeqCst => intrinsics::atomic_singlethreadfence_seqcst(),\n             Relaxed => panic!(\"there is no such thing as a relaxed compiler fence\"),\n         }\n     }"}, {"sha": "47d90b1856be51ad7701c19df3a798b451cd6083", "filename": "src/test/run-make-fulldeps/atomic-lock-free/atomic_lock_free.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -3,7 +3,7 @@\n #![no_core]\n \n extern \"rust-intrinsic\" {\n-    fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    fn atomic_xadd_seqcst<T>(dst: *mut T, src: T) -> T;\n }\n \n #[lang = \"sized\"]\n@@ -17,50 +17,50 @@ impl<T: ?Sized> Copy for *mut T {}\n \n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_u8(x: *mut u8) {\n-    atomic_xadd(x, 1);\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_i8(x: *mut i8) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"16\")]\n pub unsafe fn atomic_u16(x: *mut u16) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"16\")]\n pub unsafe fn atomic_i16(x: *mut i16) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"32\")]\n pub unsafe fn atomic_u32(x: *mut u32) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"32\")]\n pub unsafe fn atomic_i32(x: *mut i32) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"64\")]\n pub unsafe fn atomic_u64(x: *mut u64) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"64\")]\n pub unsafe fn atomic_i64(x: *mut i64) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"128\")]\n pub unsafe fn atomic_u128(x: *mut u128) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"128\")]\n pub unsafe fn atomic_i128(x: *mut i128) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"ptr\")]\n pub unsafe fn atomic_usize(x: *mut usize) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"ptr\")]\n pub unsafe fn atomic_isize(x: *mut isize) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }"}, {"sha": "c495ad6b842f8bb8056b819e23b3e0869e0ff7c1", "filename": "src/test/ui/argument-suggestions/basic.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fbasic.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -16,7 +16,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/basic.rs:21:5\n    |\n LL |     extra(\"\");\n-   |     ^^^^^ -- argument unexpected\n+   |     ^^^^^ -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/basic.rs:14:4"}, {"sha": "32b1e15737ab9370bc007fd78b5fe2ffa9e61efd", "filename": "src/test/ui/argument-suggestions/extra_arguments.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/extra_arguments.rs:7:3\n    |\n LL |   empty(\"\");\n-   |   ^^^^^ -- argument unexpected\n+   |   ^^^^^ -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:1:4\n@@ -18,7 +18,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/extra_arguments.rs:9:3\n    |\n LL |   one_arg(1, 1);\n-   |   ^^^^^^^    - argument unexpected\n+   |   ^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:2:4\n@@ -34,7 +34,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/extra_arguments.rs:10:3\n    |\n LL |   one_arg(1, \"\");\n-   |   ^^^^^^^    -- argument unexpected\n+   |   ^^^^^^^    -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:2:4\n@@ -50,9 +50,9 @@ error[E0061]: this function takes 1 argument but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:11:3\n    |\n LL |   one_arg(1, \"\", 1.0);\n-   |   ^^^^^^^    --  --- argument unexpected\n+   |   ^^^^^^^    --  --- argument of type `{float}` unexpected\n    |              |\n-   |              argument unexpected\n+   |              argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:2:4\n@@ -68,7 +68,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:13:3\n    |\n LL |   two_arg_same(1, 1, 1);\n-   |   ^^^^^^^^^^^^       - argument unexpected\n+   |   ^^^^^^^^^^^^       - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -84,7 +84,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:14:3\n    |\n LL |   two_arg_same(1, 1, 1.0);\n-   |   ^^^^^^^^^^^^       --- argument unexpected\n+   |   ^^^^^^^^^^^^       --- argument of type `{float}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -100,7 +100,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:16:3\n    |\n LL |   two_arg_diff(1, 1, \"\");\n-   |   ^^^^^^^^^^^^    - argument of type `&str` unexpected\n+   |   ^^^^^^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -116,7 +116,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:17:3\n    |\n LL |   two_arg_diff(1, \"\", \"\");\n-   |   ^^^^^^^^^^^^        -- argument unexpected\n+   |   ^^^^^^^^^^^^        -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -132,9 +132,9 @@ error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n   --> $DIR/extra_arguments.rs:18:3\n    |\n LL |   two_arg_diff(1, 1, \"\", \"\");\n-   |   ^^^^^^^^^^^^    -      -- argument unexpected\n+   |   ^^^^^^^^^^^^    -      -- argument of type `&'static str` unexpected\n    |                   |\n-   |                   argument of type `&str` unexpected\n+   |                   argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -150,9 +150,9 @@ error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n   --> $DIR/extra_arguments.rs:19:3\n    |\n LL |   two_arg_diff(1, \"\", 1, \"\");\n-   |   ^^^^^^^^^^^^        -  -- argument unexpected\n+   |   ^^^^^^^^^^^^        -  -- argument of type `&'static str` unexpected\n    |                       |\n-   |                       argument unexpected\n+   |                       argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -168,7 +168,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:22:3\n    |\n LL |   two_arg_same(1, 1,     \"\");\n-   |   ^^^^^^^^^^^^           -- argument unexpected\n+   |   ^^^^^^^^^^^^           -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -184,7 +184,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:23:3\n    |\n LL |   two_arg_diff(1, 1,     \"\");\n-   |   ^^^^^^^^^^^^    - argument of type `&str` unexpected\n+   |   ^^^^^^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -203,7 +203,7 @@ LL |   two_arg_same(\n    |   ^^^^^^^^^^^^\n ...\n LL |     \"\"\n-   |     -- argument unexpected\n+   |     -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -222,7 +222,7 @@ LL |   two_arg_diff(\n    |   ^^^^^^^^^^^^\n LL |     1,\n LL |     1,\n-   |     - argument of type `&str` unexpected\n+   |     - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4"}, {"sha": "9589e919c0a1f15f0ad9359949eb8f75f92d35bd", "filename": "src/test/ui/argument-suggestions/issue-97484.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-97484.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-97484.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-97484.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,21 +2,20 @@ error[E0061]: this function takes 4 arguments but 7 arguments were supplied\n   --> $DIR/issue-97484.rs:12:5\n    |\n LL |     foo(&&A, B, C, D, E, F, G);\n-   |     ^^^      -  -        - argument unexpected\n+   |     ^^^      -  -        - argument of type `F` unexpected\n    |              |  |\n-   |              |  argument of type `&E` unexpected\n-   |              argument of type `D` unexpected\n+   |              |  argument of type `C` unexpected\n+   |              argument of type `B` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-97484.rs:9:4\n    |\n LL | fn foo(a: &A, d: D, e: &E, g: G) {}\n    |    ^^^ -----  ----  -----  ----\n-help: consider removing the ``\n-   |\n-LL -     foo(&&A, B, C, D, E, F, G);\n-LL +     foo(&&A, B, C, D, E, F, G);\n+help: consider borrowing here\n    |\n+LL |     foo(&&A, B, C, D, &E, F, G);\n+   |                       ~~\n help: remove the extra arguments\n    |\n LL |     foo(&&A, D, /* &E */, G);"}, {"sha": "a52a30d7884f899f2ea3c8be9aa17444fd9962ab", "filename": "src/test/ui/argument-suggestions/mixed_cases.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fmixed_cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fargument-suggestions%2Fmixed_cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fmixed_cases.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/mixed_cases.rs:10:3\n    |\n LL |   two_args(1, \"\", X {});\n-   |   ^^^^^^^^    --  ---- argument unexpected\n+   |   ^^^^^^^^    --  ---- argument of type `X` unexpected\n    |               |\n    |               expected `f32`, found `&str`\n    |\n@@ -20,9 +20,9 @@ error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n   --> $DIR/mixed_cases.rs:11:3\n    |\n LL |   three_args(1, \"\", X {}, \"\");\n-   |   ^^^^^^^^^^    --  ----  -- argument unexpected\n+   |   ^^^^^^^^^^    --  ----  -- argument of type `&'static str` unexpected\n    |                 |   |\n-   |                 |   argument of type `&str` unexpected\n+   |                 |   argument of type `X` unexpected\n    |                 an argument of type `f32` is missing\n    |\n note: function defined here\n@@ -58,7 +58,7 @@ error[E0308]: arguments to this function are incorrect\n   --> $DIR/mixed_cases.rs:17:3\n    |\n LL |   three_args(1, \"\", X {});\n-   |   ^^^^^^^^^^    --  ---- argument of type `&str` unexpected\n+   |   ^^^^^^^^^^    --  ---- argument of type `X` unexpected\n    |                 |\n    |                 an argument of type `f32` is missing\n    |"}, {"sha": "f40e6585b38b1e4fd9356378b0c5a30ab7a4c17d", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the trait bound `String: Copy` is not satisfied\n LL |         Box::new(AssocNoCopy)\n    |         ^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n    |\n-   = note: required for the cast to the object type `dyn Bar<Assoc = <AssocNoCopy as Thing>::Out::{opaque#0}>`\n+   = note: required for the cast from `AssocNoCopy` to the object type `dyn Bar<Assoc = <AssocNoCopy as Thing>::Out::{opaque#0}>`\n \n error: aborting due to previous error\n "}, {"sha": "bed63a5e6df03d20aabd3eaa00a673777e137d8d", "filename": "src/test/ui/associated-types/associated-types-eq-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-3.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -41,7 +41,7 @@ note: expected this to be `Bar`\n    |\n LL |     type A = usize;\n    |              ^^^^^\n-   = note: required for the cast to the object type `dyn Foo<A = Bar>`\n+   = note: required for the cast from `isize` to the object type `dyn Foo<A = Bar>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "dbd9a44ed97743769c32d37bb19b086f0be6ecb6", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -4,7 +4,7 @@ error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::It\n LL |     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();\n    |                                           ^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`\n    |\n-   = note: required for the cast to the object type `dyn Iterator<Item = u32, Item = i32>`\n+   = note: required for the cast from `std::vec::IntoIter<u32>` to the object type `dyn Iterator<Item = u32, Item = i32>`\n \n error: aborting due to previous error\n "}, {"sha": "419de689c52da9206a8ae88da10ee81ef3134cc5", "filename": "src/test/ui/associated-types/issue-65774-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -23,7 +23,7 @@ note: required because of the requirements on the impl of `MyDisplay` for `&mut\n    |\n LL | impl<'a, T: MyDisplay> MyDisplay for &'a mut T { }\n    |                        ^^^^^^^^^     ^^^^^^^^^\n-   = note: required for the cast to the object type `dyn MyDisplay`\n+   = note: required for the cast from `&mut T` to the object type `dyn MyDisplay`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c22302cdc2626b502646d8cf5cc2ff9d0101e1e8", "filename": "src/test/ui/associated-types/issue-65774-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -18,7 +18,7 @@ LL |         writer.my_write(valref)\n    |                         ^^^^^^ the trait `MyDisplay` is not implemented for `T`\n    |\n    = help: the trait `MyDisplay` is implemented for `&'a mut T`\n-   = note: required for the cast to the object type `dyn MyDisplay`\n+   = note: required for the cast from `T` to the object type `dyn MyDisplay`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e5887689690e76fd5066d2193ae5613782cfe0b2", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -37,7 +37,7 @@ error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Out\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected `()`, found `u8`\n    |\n-   = note: required for the cast to the object type `dyn Future<Output = ()>`\n+   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n \n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:12:43\n@@ -53,7 +53,7 @@ error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Out\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected `()`, found `u8`\n    |\n-   = note: required for the cast to the object type `dyn Future<Output = ()>`\n+   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n \n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:47:44"}, {"sha": "0e21dba980debf96e87594ac89a2370198a9619b", "filename": "src/test/ui/async-await/issue-86507.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fasync-await%2Fissue-86507.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fasync-await%2Fissue-86507.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-86507.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -13,7 +13,7 @@ note: captured value is not `Send` because `&` references cannot be sent unless\n    |\n LL |                     let x = x;\n    |                             ^ has type `&T` which is not `Send`, because `T` is not `Sync`\n-   = note: required for the cast to the object type `dyn Future<Output = ()> + Send`\n+   = note: required for the cast from `impl Future<Output = ()>` to the object type `dyn Future<Output = ()> + Send`\n help: consider further restricting this bound\n    |\n LL |     fn bar<'me, 'async_trait, T: Send + std::marker::Sync>(x: &'me T)"}, {"sha": "695b01d5ee3ad7798092c953c21d9c3283cd4088", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -63,8 +63,20 @@ LL |     use_mut(n); use_imm(m);\n error[E0507]: cannot move out of `*m` which is behind a mutable reference\n   --> $DIR/binop-move-semantics.rs:30:5\n    |\n-LL |     *m\n-   |     ^^ move occurs because `*m` has type `T`, which does not implement the `Copy` trait\n+LL |       *m\n+   |       -^\n+   |       |\n+   |  _____move occurs because `*m` has type `T`, which does not implement the `Copy` trait\n+   | |\n+LL | |     +\n+LL | |     *n;\n+   | |______- `*m` moved due to usage in operator\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n \n error[E0507]: cannot move out of `*n` which is behind a shared reference\n   --> $DIR/binop-move-semantics.rs:32:5"}, {"sha": "c99c0f77982edecf4a03edc402f7f8afb3526755", "filename": "src/test/ui/borrowck/borrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0594]: cannot assign to `**t1`, which is behind a `&` reference\n   --> $DIR/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs:9:5\n    |\n LL |     let t1 = t0;\n-   |         -- help: consider changing this to be a mutable reference: `&mut &mut isize`\n+   |         -- consider changing this binding's type to be: `&mut &mut isize`\n LL |     let p: &isize = &**t0;\n LL |     **t1 = 22;\n    |     ^^^^^^^^^ `t1` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "1598cd5d3c86fa98c005b47f2f725775a809d0f6", "filename": "src/test/ui/borrowck/issue-85765.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-85765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-85765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-85765.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let mut test = Vec::new();\n     let rofl: &Vec<Vec<i32>> = &mut test;\n-    //~^ HELP consider changing this to be a mutable reference\n+    //~^ NOTE consider changing this binding's type to be\n     rofl.push(Vec::new());\n     //~^ ERROR cannot borrow `*rofl` as mutable, as it is behind a `&` reference\n     //~| NOTE `rofl` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n@@ -15,14 +15,14 @@ fn main() {\n \n     #[rustfmt::skip]\n     let x: &usize = &mut{0};\n-    //~^ HELP consider changing this to be a mutable reference\n+    //~^ NOTE consider changing this binding's type to be\n     *x = 1;\n     //~^ ERROR cannot assign to `*x`, which is behind a `&` reference\n     //~| NOTE `x` is a `&` reference, so the data it refers to cannot be written\n \n     #[rustfmt::skip]\n     let y: &usize = &mut(0);\n-    //~^ HELP consider changing this to be a mutable reference\n+    //~^ NOTE consider changing this binding's type to be\n     *y = 1;\n     //~^ ERROR cannot assign to `*y`, which is behind a `&` reference\n     //~| NOTE `y` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "13033962142fa51583cd5065639db7221824a981", "filename": "src/test/ui/borrowck/issue-85765.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-85765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-85765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-85765.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0596]: cannot borrow `*rofl` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-85765.rs:5:5\n    |\n LL |     let rofl: &Vec<Vec<i32>> = &mut test;\n-   |         ---- help: consider changing this to be a mutable reference: `&mut Vec<Vec<i32>>`\n+   |         ---- consider changing this binding's type to be: `&mut Vec<Vec<i32>>`\n LL |\n LL |     rofl.push(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^ `rofl` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n@@ -20,7 +20,7 @@ error[E0594]: cannot assign to `*x`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:19:5\n    |\n LL |     let x: &usize = &mut{0};\n-   |         - help: consider changing this to be a mutable reference: `&mut usize`\n+   |         - consider changing this binding's type to be: `&mut usize`\n LL |\n LL |     *x = 1;\n    |     ^^^^^^ `x` is a `&` reference, so the data it refers to cannot be written\n@@ -29,7 +29,7 @@ error[E0594]: cannot assign to `*y`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:26:5\n    |\n LL |     let y: &usize = &mut(0);\n-   |         - help: consider changing this to be a mutable reference: `&mut usize`\n+   |         - consider changing this binding's type to be: `&mut usize`\n LL |\n LL |     *y = 1;\n    |     ^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "67407c1eae3cfe2bf2144e0e97609146d26de3b2", "filename": "src/test/ui/borrowck/issue-91206.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-91206.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-91206.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-91206.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -9,7 +9,8 @@ impl TestClient {\n fn main() {\n     let client = TestClient;\n     let inner = client.get_inner_ref();\n-    //~^ HELP consider changing this to be a mutable reference\n+    //~^ NOTE consider changing this binding's type to be\n     inner.clear();\n     //~^ ERROR cannot borrow `*inner` as mutable, as it is behind a `&` reference [E0596]\n+    //~| NOTE `inner` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n }"}, {"sha": "12d8d27c5f0264906276f2753ff25ce4260e8d4e", "filename": "src/test/ui/borrowck/issue-91206.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-91206.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-91206.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-91206.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0596]: cannot borrow `*inner` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-91206.rs:13:5\n    |\n LL |     let inner = client.get_inner_ref();\n-   |         ----- help: consider changing this to be a mutable reference: `&mut Vec<usize>`\n+   |         ----- consider changing this binding's type to be: `&mut Vec<usize>`\n LL |\n LL |     inner.clear();\n    |     ^^^^^^^^^^^^^ `inner` is a `&` reference, so the data it refers to cannot be borrowed as mutable"}, {"sha": "62b1183e71b4beb03ce8fa9de7fc83b69533cbd5", "filename": "src/test/ui/borrowck/issue-92015.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-92015.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n   --> $DIR/issue-92015.rs:6:5\n    |\n LL |     let foo = Some(&0).unwrap();\n-   |         --- help: consider changing this to be a mutable reference: `&mut i32`\n+   |         --- consider changing this binding's type to be: `&mut i32`\n LL |     *foo = 1;\n    |     ^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n "}, {"sha": "1dcf04618796e2e2b92a0c17745871364fbdcbf2", "filename": "src/test/ui/borrowck/suggest-as-ref-on-mut-closure.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -0,0 +1,16 @@\n+// This is not exactly right, yet.\n+\n+// Ideally we should be suggesting `as_mut` for the first case,\n+// and suggesting to change `as_ref` to `as_mut` in the second.\n+\n+fn x(cb: &mut Option<&mut dyn FnMut()>) {\n+    cb.map(|cb| cb());\n+    //~^ ERROR cannot move out of `*cb` which is behind a mutable reference\n+}\n+\n+fn x2(cb: &mut Option<&mut dyn FnMut()>) {\n+    cb.as_ref().map(|cb| cb());\n+    //~^ ERROR cannot borrow `*cb` as mutable, as it is behind a `&` reference\n+}\n+\n+fn main() {}"}, {"sha": "af26169c8068146c6def241f05af87c3a6ec39a0", "filename": "src/test/ui/borrowck/suggest-as-ref-on-mut-closure.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-as-ref-on-mut-closure.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -0,0 +1,31 @@\n+error[E0507]: cannot move out of `*cb` which is behind a mutable reference\n+  --> $DIR/suggest-as-ref-on-mut-closure.rs:7:5\n+   |\n+LL |     cb.map(|cb| cb());\n+   |     ^^^--------------\n+   |     |  |\n+   |     |  `*cb` moved due to this method call\n+   |     move occurs because `*cb` has type `Option<&mut dyn FnMut()>`, which does not implement the `Copy` trait\n+   |\n+note: this function takes ownership of the receiver `self`, which moves `*cb`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL |     pub const fn map<U, F>(self, f: F) -> Option<U>\n+   |                            ^^^^\n+help: consider calling `.as_ref()` to borrow the type's contents\n+   |\n+LL |     cb.as_ref().map(|cb| cb());\n+   |        +++++++++\n+\n+error[E0596]: cannot borrow `*cb` as mutable, as it is behind a `&` reference\n+  --> $DIR/suggest-as-ref-on-mut-closure.rs:12:26\n+   |\n+LL |     cb.as_ref().map(|cb| cb());\n+   |                      --  ^^ `cb` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+   |                      |\n+   |                      consider changing this binding's type to be: `&mut &mut dyn FnMut()`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0507, E0596.\n+For more information about an error, try `rustc --explain E0507`."}, {"sha": "980da536034327a835894f851eca4c78250aec07", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never-windows.nofallback.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never-windows.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never-windows.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never-windows.nofallback.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -4,15 +4,15 @@ error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n LL |     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n    |\n-   = note: required for the cast to the object type `dyn std::error::Error`\n+   = note: required for the cast from `()` to the object type `dyn std::error::Error`\n \n error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n   --> $DIR/coerce-issue-49593-box-never-windows.rs:23:49\n    |\n LL |     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n    |\n-   = note: required for the cast to the object type `(dyn std::error::Error + 'static)`\n+   = note: required for the cast from `()` to the object type `(dyn std::error::Error + 'static)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "322681b97bccb0c516d5140ebca68dba8be503b3", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.nofallback.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -4,15 +4,15 @@ error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n LL |     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n    |\n-   = note: required for the cast to the object type `dyn std::error::Error`\n+   = note: required for the cast from `()` to the object type `dyn std::error::Error`\n \n error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n   --> $DIR/coerce-issue-49593-box-never.rs:23:49\n    |\n LL |     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n    |\n-   = note: required for the cast to the object type `(dyn std::error::Error + 'static)`\n+   = note: required for the cast from `()` to the object type `(dyn std::error::Error + 'static)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "da85b2059f0a390d6d2e401bf2f6a4021c73cc6d", "filename": "src/test/ui/const-generics/defaults/trait_objects_fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -7,7 +7,7 @@ LL |     foo(&10_u32);\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Trait<2_u8>` is implemented for `u32`\n-   = note: required for the cast to the object type `dyn Trait`\n+   = note: required for the cast from `u32` to the object type `dyn Trait`\n \n error[E0277]: the trait bound `bool: Traitor<{_: u8}>` is not satisfied\n   --> $DIR/trait_objects_fail.rs:28:9\n@@ -18,7 +18,7 @@ LL |     bar(&true);\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Traitor<2_u8, 3_u8>` is implemented for `bool`\n-   = note: required for the cast to the object type `dyn Traitor<{_: u8}>`\n+   = note: required for the cast from `bool` to the object type `dyn Traitor<{_: u8}>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "61061ae529d1275939a7870d33751aec94c34e40", "filename": "src/test/ui/custom_test_frameworks/mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -6,7 +6,7 @@ LL | #[test]\n LL | fn wrong_kind(){}\n    | ^^^^^^^^^^^^^^^^^ the trait `Testable` is not implemented for `TestDescAndFn`\n    |\n-   = note: required for the cast to the object type `dyn Testable`\n+   = note: required for the cast from `TestDescAndFn` to the object type `dyn Testable`\n    = note: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "594acff853a0eb5b805917f162ffa8f0c489aff6", "filename": "src/test/ui/dst/dst-bad-coerce1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fdst%2Fdst-bad-coerce1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fdst%2Fdst-bad-coerce1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-coerce1.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -15,7 +15,7 @@ error[E0277]: the trait bound `Foo: Bar` is not satisfied\n LL |     let f3: &Fat<dyn Bar> = f2;\n    |                             ^^ the trait `Bar` is not implemented for `Foo`\n    |\n-   = note: required for the cast to the object type `dyn Bar`\n+   = note: required for the cast from `Foo` to the object type `dyn Bar`\n \n error[E0308]: mismatched types\n   --> $DIR/dst-bad-coerce1.rs:28:27\n@@ -34,7 +34,7 @@ error[E0277]: the trait bound `Foo: Bar` is not satisfied\n LL |     let f3: &(dyn Bar,) = f2;\n    |                           ^^ the trait `Bar` is not implemented for `Foo`\n    |\n-   = note: required for the cast to the object type `dyn Bar`\n+   = note: required for the cast from `Foo` to the object type `dyn Bar`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e24c96ebed63354936d9684b11dd0eede763d84e", "filename": "src/test/ui/dst/dst-object-from-unsized-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fdst%2Fdst-object-from-unsized-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fdst%2Fdst-object-from-unsized-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-object-from-unsized-type.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -6,7 +6,7 @@ LL | fn test1<T: ?Sized + Foo>(t: &T) {\n LL |     let u: &dyn Foo = t;\n    |                       ^ doesn't have a size known at compile-time\n    |\n-   = note: required for the cast to the object type `dyn Foo`\n+   = note: required for the cast from `T` to the object type `dyn Foo`\n help: consider removing the `?Sized` bound to make the type parameter `Sized`\n    |\n LL - fn test1<T: ?Sized + Foo>(t: &T) {\n@@ -21,7 +21,7 @@ LL | fn test2<T: ?Sized + Foo>(t: &T) {\n LL |     let v: &dyn Foo = t as &dyn Foo;\n    |                       ^ doesn't have a size known at compile-time\n    |\n-   = note: required for the cast to the object type `dyn Foo`\n+   = note: required for the cast from `T` to the object type `dyn Foo`\n help: consider removing the `?Sized` bound to make the type parameter `Sized`\n    |\n LL - fn test2<T: ?Sized + Foo>(t: &T) {\n@@ -35,7 +35,7 @@ LL |     let _: &[&dyn Foo] = &[\"hi\"];\n    |                            ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn Foo`\n+   = note: required for the cast from `str` to the object type `dyn Foo`\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> $DIR/dst-object-from-unsized-type.rs:23:23\n@@ -44,7 +44,7 @@ LL |     let _: &dyn Foo = x as &dyn Foo;\n    |                       ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\n-   = note: required for the cast to the object type `dyn Foo`\n+   = note: required for the cast from `[u8]` to the object type `dyn Foo`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "2307f52c93bceb8aa8f0fffab4c8806998ed0092", "filename": "src/test/ui/error-codes/E0057.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ferror-codes%2FE0057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ferror-codes%2FE0057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0057.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -18,7 +18,7 @@ error[E0057]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/E0057.rs:5:13\n    |\n LL |     let c = f(2, 3);\n-   |             ^    - argument unexpected\n+   |             ^    - argument of type `{integer}` unexpected\n    |\n note: closure defined here\n   --> $DIR/E0057.rs:2:13"}, {"sha": "9bcbd74716845fcac8462c76c3538e64037f52cf", "filename": "src/test/ui/generic-associated-types/issue-79422.extended.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.extended.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.extended.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-79422.extended.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -27,7 +27,7 @@ LL |     type VRefCont<'a> = &'a V where Self: 'a;\n    |                         ^^^^^\n    = note: expected trait object `(dyn RefCont<'_, u8> + 'static)`\n                  found reference `&u8`\n-   = note: required for the cast to the object type `dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>`\n+   = note: required for the cast from `BTreeMap<u8, u8>` to the object type `dyn MapLike<u8, u8, VRefCont = (dyn RefCont<'_, u8> + 'static)>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f3b9d569ce3b1977a4d87a0690b529de67cb571c", "filename": "src/test/ui/intrinsics/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fauxiliary%2Fcci_intrinsic.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,13 +2,13 @@\n \n pub mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_seqcst<T>(dst: *mut T, src: T) -> T;\n     }\n }\n \n #[inline(always)]\n-pub fn atomic_xchg(dst: *mut isize, src: isize) -> isize {\n+pub fn atomic_xchg_seqcst(dst: *mut isize, src: isize) -> isize {\n     unsafe {\n-        rusti::atomic_xchg(dst, src)\n+        rusti::atomic_xchg_seqcst(dst, src)\n     }\n }"}, {"sha": "ce3fa7b0c05e68a7652a046ff100a63045d53b3d", "filename": "src/test/ui/intrinsics/intrinsic-atomics-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics-cc.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -3,10 +3,10 @@\n \n \n extern crate cci_intrinsic;\n-use cci_intrinsic::atomic_xchg;\n+use cci_intrinsic::atomic_xchg_seqcst;\n \n pub fn main() {\n     let mut x = 1;\n-    atomic_xchg(&mut x, 5);\n+    atomic_xchg_seqcst(&mut x, 5);\n     assert_eq!(x, 5);\n }"}, {"sha": "b17f4347be31cce7dd97c0f4614e021e64b4f0f5", "filename": "src/test/ui/intrinsics/intrinsic-atomics.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -3,77 +3,77 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_seqcst_seqcst<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_acquire_acquire<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_release_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n-        pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_seqcst_seqcst<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_acquire_acquire<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_release_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n-        pub fn atomic_load<T>(src: *const T) -> T;\n-        pub fn atomic_load_acq<T>(src: *const T) -> T;\n+        pub fn atomic_load_seqcst<T>(src: *const T) -> T;\n+        pub fn atomic_load_acquire<T>(src: *const T) -> T;\n \n-        pub fn atomic_store<T>(dst: *mut T, val: T);\n-        pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+        pub fn atomic_store_seqcst<T>(dst: *mut T, val: T);\n+        pub fn atomic_store_release<T>(dst: *mut T, val: T);\n \n-        pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_seqcst<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_acquire<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_release<T>(dst: *mut T, src: T) -> T;\n \n-        pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_seqcst<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_acquire<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_release<T>(dst: *mut T, src: T) -> T;\n \n-        pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_seqcst<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_acquire<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_release<T>(dst: *mut T, src: T) -> T;\n     }\n }\n \n pub fn main() {\n     unsafe {\n         let mut x: Box<_> = Box::new(1);\n \n-        assert_eq!(rusti::atomic_load(&*x), 1);\n+        assert_eq!(rusti::atomic_load_seqcst(&*x), 1);\n         *x = 5;\n-        assert_eq!(rusti::atomic_load_acq(&*x), 5);\n+        assert_eq!(rusti::atomic_load_acquire(&*x), 5);\n \n-        rusti::atomic_store(&mut *x,3);\n+        rusti::atomic_store_seqcst(&mut *x,3);\n         assert_eq!(*x, 3);\n-        rusti::atomic_store_rel(&mut *x,1);\n+        rusti::atomic_store_release(&mut *x,1);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_cxchg(&mut *x, 1, 2), (1, true));\n+        assert_eq!(rusti::atomic_cxchg_seqcst_seqcst(&mut *x, 1, 2), (1, true));\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_acq(&mut *x, 1, 3), (2, false));\n+        assert_eq!(rusti::atomic_cxchg_acquire_acquire(&mut *x, 1, 3), (2, false));\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_rel(&mut *x, 2, 1), (2, true));\n+        assert_eq!(rusti::atomic_cxchg_release_relaxed(&mut *x, 2, 1), (2, true));\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_xchg(&mut *x, 0), 1);\n+        assert_eq!(rusti::atomic_xchg_seqcst(&mut *x, 0), 1);\n         assert_eq!(*x, 0);\n \n-        assert_eq!(rusti::atomic_xchg_acq(&mut *x, 1), 0);\n+        assert_eq!(rusti::atomic_xchg_acquire(&mut *x, 1), 0);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_xchg_rel(&mut *x, 0), 1);\n+        assert_eq!(rusti::atomic_xchg_release(&mut *x, 0), 1);\n         assert_eq!(*x, 0);\n \n-        assert_eq!(rusti::atomic_xadd(&mut *x, 1), 0);\n-        assert_eq!(rusti::atomic_xadd_acq(&mut *x, 1), 1);\n-        assert_eq!(rusti::atomic_xadd_rel(&mut *x, 1), 2);\n+        assert_eq!(rusti::atomic_xadd_seqcst(&mut *x, 1), 0);\n+        assert_eq!(rusti::atomic_xadd_acquire(&mut *x, 1), 1);\n+        assert_eq!(rusti::atomic_xadd_release(&mut *x, 1), 2);\n         assert_eq!(*x, 3);\n \n-        assert_eq!(rusti::atomic_xsub(&mut *x, 1), 3);\n-        assert_eq!(rusti::atomic_xsub_acq(&mut *x, 1), 2);\n-        assert_eq!(rusti::atomic_xsub_rel(&mut *x, 1), 1);\n+        assert_eq!(rusti::atomic_xsub_seqcst(&mut *x, 1), 3);\n+        assert_eq!(rusti::atomic_xsub_acquire(&mut *x, 1), 2);\n+        assert_eq!(rusti::atomic_xsub_release(&mut *x, 1), 1);\n         assert_eq!(*x, 0);\n \n         loop {\n-            let res = rusti::atomic_cxchgweak(&mut *x, 0, 1);\n+            let res = rusti::atomic_cxchgweak_seqcst_seqcst(&mut *x, 0, 1);\n             assert_eq!(res.0, 0);\n             if res.1 {\n                 break;\n@@ -82,7 +82,7 @@ pub fn main() {\n         assert_eq!(*x, 1);\n \n         loop {\n-            let res = rusti::atomic_cxchgweak_acq(&mut *x, 1, 2);\n+            let res = rusti::atomic_cxchgweak_acquire_acquire(&mut *x, 1, 2);\n             assert_eq!(res.0, 1);\n             if res.1 {\n                 break;\n@@ -91,7 +91,7 @@ pub fn main() {\n         assert_eq!(*x, 2);\n \n         loop {\n-            let res = rusti::atomic_cxchgweak_rel(&mut *x, 2, 3);\n+            let res = rusti::atomic_cxchgweak_release_relaxed(&mut *x, 2, 3);\n             assert_eq!(res.0, 2);\n             if res.1 {\n                 break;"}, {"sha": "85ea81ba67961e116765b353888adb88f657bb1f", "filename": "src/test/ui/intrinsics/non-integer-atomic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -12,81 +12,81 @@ pub type Bar = &'static Fn();\n pub type Quux = [u8; 100];\n \n pub unsafe fn test_bool_load(p: &mut bool, v: bool) {\n-    intrinsics::atomic_load(p);\n-    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_load_seqcst(p);\n+    //~^ ERROR `atomic_load_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_bool_store(p: &mut bool, v: bool) {\n-    intrinsics::atomic_store(p, v);\n-    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_store_seqcst(p, v);\n+    //~^ ERROR `atomic_store_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_bool_xchg(p: &mut bool, v: bool) {\n-    intrinsics::atomic_xchg(p, v);\n-    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_xchg_seqcst(p, v);\n+    //~^ ERROR `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_bool_cxchg(p: &mut bool, v: bool) {\n-    intrinsics::atomic_cxchg(p, v, v);\n-    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+    //~^ ERROR `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_Foo_load(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_load(p);\n-    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_load_seqcst(p);\n+    //~^ ERROR `atomic_load_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Foo_store(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_store(p, v);\n-    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_store_seqcst(p, v);\n+    //~^ ERROR `atomic_store_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Foo_xchg(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_xchg(p, v);\n-    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_xchg_seqcst(p, v);\n+    //~^ ERROR `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Foo_cxchg(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_cxchg(p, v, v);\n-    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+    //~^ ERROR `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Bar_load(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_load(p);\n+    intrinsics::atomic_load_seqcst(p);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Bar_store(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_store(p, v);\n+    intrinsics::atomic_store_seqcst(p, v);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Bar_xchg(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_xchg(p, v);\n+    intrinsics::atomic_xchg_seqcst(p, v);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Bar_cxchg(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_cxchg(p, v, v);\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Quux_load(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_load(p);\n-    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_load_seqcst(p);\n+    //~^ ERROR `atomic_load_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n pub unsafe fn test_Quux_store(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_store(p, v);\n-    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_store_seqcst(p, v);\n+    //~^ ERROR `atomic_store_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n pub unsafe fn test_Quux_xchg(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_xchg(p, v);\n-    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_xchg_seqcst(p, v);\n+    //~^ ERROR `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n pub unsafe fn test_Quux_cxchg(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_cxchg(p, v, v);\n-    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+    //~^ ERROR `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }"}, {"sha": "32791a8e8b7f1c870fe357c19817046327025fd7", "filename": "src/test/ui/intrinsics/non-integer-atomic.stderr", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -1,98 +1,98 @@\n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:15:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:20:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:25:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:30:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:35:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:40:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:45:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:50:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:55:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:60:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:65:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:70:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:75:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:80:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:85:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:90:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 16 previous errors\n "}, {"sha": "10a73b245ac570e6b40854f8a04b91cdbda78823", "filename": "src/test/ui/issues/issue-14366.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-14366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-14366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14366.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -5,7 +5,7 @@ LL |     let _x = \"test\" as &dyn (::std::any::Any);\n    |              ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn Any`\n+   = note: required for the cast from `str` to the object type `dyn Any`\n help: consider borrowing the value, since `&str` can be coerced into `dyn Any`\n    |\n LL |     let _x = &\"test\" as &dyn (::std::any::Any);"}, {"sha": "b32de5b24b924f7eb74e8be819b28684c1353aec", "filename": "src/test/ui/issues/issue-22034.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-22034.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-22034.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22034.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -6,7 +6,7 @@ LL |         &mut *(ptr as *mut dyn Fn())\n    |\n    = help: the trait `Fn<()>` is not implemented for `()`\n    = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n-   = note: required for the cast to the object type `dyn Fn()`\n+   = note: required for the cast from `()` to the object type `dyn Fn()`\n \n error: aborting due to previous error\n "}, {"sha": "a84cb7d8c5922a4f75ee1c9dc7c4cb473966abb3", "filename": "src/test/ui/issues/issue-22872.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -10,7 +10,7 @@ note: required because of the requirements on the impl of `for<'b> Wrap<'b>` for\n    |\n LL | impl<'b, P> Wrap<'b> for Wrapper<P>\n    |             ^^^^^^^^     ^^^^^^^^^^\n-   = note: required for the cast to the object type `dyn for<'b> Wrap<'b>`\n+   = note: required for the cast from `Wrapper<P>` to the object type `dyn for<'b> Wrap<'b>`\n help: consider further restricting the associated type\n    |\n LL | fn push_process<P>(process: P) where P: Process<'static>, <P as Process<'_>>::Item: Iterator {"}, {"sha": "df8c2f739108db485ed7b8a1ed782e532fd4a545", "filename": "src/test/ui/issues/issue-26094.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-26094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-26094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26094.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -1,6 +1,6 @@\n macro_rules! some_macro {\n     ($other: expr) => ({\n-        $other(None) //~ NOTE argument unexpected\n+        $other(None) //~ NOTE argument of type `Option<_>` unexpected\n     })\n }\n "}, {"sha": "881a6e538ee44621b9d6b7e23f9d671498a264e2", "filename": "src/test/ui/issues/issue-26094.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/issue-26094.rs:10:17\n    |\n LL |         $other(None)\n-   |                ---- argument unexpected\n+   |                ---- argument of type `Option<_>` unexpected\n ...\n LL |     some_macro!(some_function);\n    |                 ^^^^^^^^^^^^^"}, {"sha": "aab19a699ace08770c7e3b89e40cf6fa2d1a80a0", "filename": "src/test/ui/issues/issue-4935.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/issue-4935.rs:5:13\n    |\n LL | fn main() { foo(5, 6) }\n-   |             ^^^    - argument unexpected\n+   |             ^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-4935.rs:3:4"}, {"sha": "797c1085d517b1b44b9159f6252a29399d92c328", "filename": "src/test/ui/issues/issue-51515.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-51515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-51515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51515.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -5,8 +5,6 @@ fn main() {\n     *foo = 32;\n     //~^ ERROR cannot assign to `*foo`, which is behind a `&` reference\n     let bar = foo;\n-    //~^ HELP consider changing this to be a mutable reference\n-    //~| SUGGESTION &mut i32\n     *bar = 64;\n     //~^ ERROR cannot assign to `*bar`, which is behind a `&` reference\n }"}, {"sha": "067bdef8b6746c73a645eda9e50115ebbae0ebac", "filename": "src/test/ui/issues/issue-51515.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-51515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-51515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51515.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -8,11 +8,10 @@ LL |     *foo = 32;\n    |     ^^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n \n error[E0594]: cannot assign to `*bar`, which is behind a `&` reference\n-  --> $DIR/issue-51515.rs:10:5\n+  --> $DIR/issue-51515.rs:8:5\n    |\n LL |     let bar = foo;\n-   |         --- help: consider changing this to be a mutable reference: `&mut i32`\n-...\n+   |         --- consider changing this binding's type to be: `&mut i32`\n LL |     *bar = 64;\n    |     ^^^^^^^^^ `bar` is a `&` reference, so the data it refers to cannot be written\n "}, {"sha": "f6cb1cbdc11c677df8fd6d9616a7e7c72c73ac71", "filename": "src/test/ui/issues/issue-7013.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-7013.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fissues%2Fissue-7013.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7013.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -11,7 +11,7 @@ note: required because it appears within the type `B`\n    |\n LL | struct B {\n    |        ^\n-   = note: required for the cast to the object type `dyn Foo + Send`\n+   = note: required for the cast from `B` to the object type `dyn Foo + Send`\n \n error: aborting due to previous error\n "}, {"sha": "902349135c549f1718ccdb6425ebd2bb7fc8fb5d", "filename": "src/test/ui/kindck/kindck-impl-type-params.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -9,7 +9,7 @@ note: required because of the requirements on the impl of `Gettable<T>` for `S<T\n    |\n LL | impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n    |                                ^^^^^^^^^^^     ^^^^\n-   = note: required for the cast to the object type `dyn Gettable<T>`\n+   = note: required for the cast from `S<T>` to the object type `dyn Gettable<T>`\n help: consider restricting type parameter `T`\n    |\n LL | fn f<T: std::marker::Send>(val: T) {\n@@ -26,7 +26,7 @@ note: required because of the requirements on the impl of `Gettable<T>` for `S<T\n    |\n LL | impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n    |                                ^^^^^^^^^^^     ^^^^\n-   = note: required for the cast to the object type `dyn Gettable<T>`\n+   = note: required for the cast from `S<T>` to the object type `dyn Gettable<T>`\n help: consider restricting type parameter `T`\n    |\n LL | fn f<T: std::marker::Copy>(val: T) {\n@@ -43,7 +43,7 @@ note: required because of the requirements on the impl of `Gettable<T>` for `S<T\n    |\n LL | impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n    |                                ^^^^^^^^^^^     ^^^^\n-   = note: required for the cast to the object type `dyn Gettable<T>`\n+   = note: required for the cast from `S<T>` to the object type `dyn Gettable<T>`\n help: consider restricting type parameter `T`\n    |\n LL | fn g<T: std::marker::Send>(val: T) {\n@@ -60,7 +60,7 @@ note: required because of the requirements on the impl of `Gettable<T>` for `S<T\n    |\n LL | impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n    |                                ^^^^^^^^^^^     ^^^^\n-   = note: required for the cast to the object type `dyn Gettable<T>`\n+   = note: required for the cast from `S<T>` to the object type `dyn Gettable<T>`\n help: consider restricting type parameter `T`\n    |\n LL | fn g<T: std::marker::Copy>(val: T) {\n@@ -78,7 +78,7 @@ note: required because of the requirements on the impl of `Gettable<String>` for\n    |\n LL | impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n    |                                ^^^^^^^^^^^     ^^^^\n-   = note: required for the cast to the object type `dyn Gettable<String>`\n+   = note: required for the cast from `S<String>` to the object type `dyn Gettable<String>`\n \n error[E0277]: the trait bound `Foo: Copy` is not satisfied\n   --> $DIR/kindck-impl-type-params.rs:43:37\n@@ -92,7 +92,7 @@ note: required because of the requirements on the impl of `Gettable<Foo>` for `S\n    |\n LL | impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n    |                                ^^^^^^^^^^^     ^^^^\n-   = note: required for the cast to the object type `dyn Gettable<Foo>`\n+   = note: required for the cast from `S<Foo>` to the object type `dyn Gettable<Foo>`\n help: consider annotating `Foo` with `#[derive(Copy)]`\n    |\n LL |     #[derive(Copy)]"}, {"sha": "57662e1e265aec21e69880ffe6211b59168b8c6e", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/method-call-err-msg.rs:13:7\n    |\n LL |     x.zero(0)\n-   |       ^^^^ - argument unexpected\n+   |       ^^^^ - argument of type `{integer}` unexpected\n    |\n note: associated function defined here\n   --> $DIR/method-call-err-msg.rs:5:8"}, {"sha": "eab8e8e80c424234eea1b862ab531d227cb9cafd", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -220,7 +220,7 @@ LL |     let _ = fat_v as *const dyn Foo;\n    |             ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\n-   = note: required for the cast to the object type `dyn Foo`\n+   = note: required for the cast from `[u8]` to the object type `dyn Foo`\n help: consider borrowing the value, since `&[u8]` can be coerced into `dyn Foo`\n    |\n LL |     let _ = &fat_v as *const dyn Foo;\n@@ -233,7 +233,7 @@ LL |     let _ = a as *const dyn Foo;\n    |             ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn Foo`\n+   = note: required for the cast from `str` to the object type `dyn Foo`\n help: consider borrowing the value, since `&str` can be coerced into `dyn Foo`\n    |\n LL |     let _ = &a as *const dyn Foo;"}, {"sha": "cb93a7ad9008d871314e3364cd02d3ce9fd3ef37", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -32,7 +32,7 @@ error[E0057]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:31:15\n    |\n LL |     let ans = s(\"burma\", \"shave\");\n-   |               ^ -------  ------- argument unexpected\n+   |               ^ -------  ------- argument of type `&'static str` unexpected\n    |                 |\n    |                 expected `isize`, found `&str`\n    |"}, {"sha": "6b9635d4a60bcd889b794d08db7625fbf898b597", "filename": "src/test/ui/never_type/fallback-closure-wrap.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -10,7 +10,7 @@ LL | |     }) as Box<dyn FnMut()>);\n    |\n    = note: expected unit type `()`\n                    found type `!`\n-   = note: required for the cast to the object type `dyn FnMut()`\n+   = note: required for the cast from `[closure@$DIR/fallback-closure-wrap.rs:18:40: 21:6]` to the object type `dyn FnMut()`\n \n error: aborting due to previous error\n "}, {"sha": "e676d7372e89133121c2128a816623b963703b49", "filename": "src/test/ui/span/issue-34264.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -54,7 +54,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/issue-34264.rs:7:5\n    |\n LL |     foo(Some(42), 2, \"\");\n-   |     ^^^              -- argument unexpected\n+   |     ^^^              -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-34264.rs:1:4\n@@ -84,7 +84,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/issue-34264.rs:10:5\n    |\n LL |     bar(1, 2, 3);\n-   |     ^^^       - argument unexpected\n+   |     ^^^       - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-34264.rs:3:4"}, {"sha": "408732fe944fe1c558c52aa3d78e0f05d3f8fe23", "filename": "src/test/ui/specialization/min_specialization/issue-79224.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -0,0 +1,24 @@\n+#![feature(min_specialization)]\n+use std::fmt::{self, Display};\n+\n+pub enum Cow<'a, B: ?Sized + 'a, O = <B as ToOwned>::Owned>\n+where\n+    B: ToOwned,\n+{\n+    Borrowed(&'a B),\n+    Owned(O),\n+}\n+\n+impl ToString for Cow<'_, str> {\n+    fn to_string(&self) -> String {\n+        String::new()\n+    }\n+}\n+\n+impl<B: ?Sized> Display for Cow<'_, B> { //~ ERROR: the trait bound `B: Clone` is not satisfied [E0277]\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { //~ ERROR: the trait bound `B: Clone` is not satisfied [E0277]\n+        write!(f, \"foo\")\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "44c6ec1426b9080d94589640c2f753f1fea08bf9", "filename": "src/test/ui/specialization/min_specialization/issue-79224.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fissue-79224.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -0,0 +1,29 @@\n+error[E0277]: the trait bound `B: Clone` is not satisfied\n+  --> $DIR/issue-79224.rs:18:17\n+   |\n+LL | impl<B: ?Sized> Display for Cow<'_, B> {\n+   |                 ^^^^^^^ the trait `Clone` is not implemented for `B`\n+   |\n+   = note: required because of the requirements on the impl of `ToOwned` for `B`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B: ?Sized + std::clone::Clone> Display for Cow<'_, B> {\n+   |                +++++++++++++++++++\n+\n+error[E0277]: the trait bound `B: Clone` is not satisfied\n+  --> $DIR/issue-79224.rs:19:5\n+   |\n+LL | /     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+LL | |         write!(f, \"foo\")\n+LL | |     }\n+   | |_____^ the trait `Clone` is not implemented for `B`\n+   |\n+   = note: required because of the requirements on the impl of `ToOwned` for `B`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B: ?Sized + std::clone::Clone> Display for Cow<'_, B> {\n+   |                +++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "805c75f464cd558200b0ec23d388fddd8cbd890a", "filename": "src/test/ui/suggestions/args-instead-of-tuple-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this enum variant takes 1 argument but 2 arguments were supplied\n   --> $DIR/args-instead-of-tuple-errors.rs:6:34\n    |\n LL |     let _: Option<(i32, bool)> = Some(1, 2);\n-   |                                  ^^^^ -  - argument unexpected\n+   |                                  ^^^^ -  - argument of type `{integer}` unexpected\n    |                                       |\n    |                                       expected tuple, found integer\n    |\n@@ -22,7 +22,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/args-instead-of-tuple-errors.rs:8:5\n    |\n LL |     int_bool(1, 2);\n-   |     ^^^^^^^^ -  - argument unexpected\n+   |     ^^^^^^^^ -  - argument of type `{integer}` unexpected\n    |              |\n    |              expected tuple, found integer\n    |"}, {"sha": "4186dc7cb35ae51a349ddb7af70931217a157d84", "filename": "src/test/ui/suggestions/derive-macro-missing-bounds.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -33,7 +33,7 @@ LL |     impl<T: Debug + Trait> Debug for Inner<T> {\n    |                            ^^^^^     ^^^^^^^^\n    = note: 1 redundant requirement hidden\n    = note: required because of the requirements on the impl of `Debug` for `&c::Inner<T>`\n-   = note: required for the cast to the object type `dyn Debug`\n+   = note: required for the cast from `&c::Inner<T>` to the object type `dyn Debug`\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |\n@@ -55,7 +55,7 @@ LL |     impl<T> Debug for Inner<T> where T: Debug, T: Trait {\n    |             ^^^^^     ^^^^^^^^\n    = note: 1 redundant requirement hidden\n    = note: required because of the requirements on the impl of `Debug` for `&d::Inner<T>`\n-   = note: required for the cast to the object type `dyn Debug`\n+   = note: required for the cast from `&d::Inner<T>` to the object type `dyn Debug`\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |\n@@ -77,7 +77,7 @@ LL |     impl<T> Debug for Inner<T> where T: Debug + Trait {\n    |             ^^^^^     ^^^^^^^^\n    = note: 1 redundant requirement hidden\n    = note: required because of the requirements on the impl of `Debug` for `&e::Inner<T>`\n-   = note: required for the cast to the object type `dyn Debug`\n+   = note: required for the cast from `&e::Inner<T>` to the object type `dyn Debug`\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |\n@@ -99,7 +99,7 @@ LL |     impl<T: Debug> Debug for Inner<T> where T: Trait {\n    |                    ^^^^^     ^^^^^^^^\n    = note: 1 redundant requirement hidden\n    = note: required because of the requirements on the impl of `Debug` for `&f::Inner<T>`\n-   = note: required for the cast to the object type `dyn Debug`\n+   = note: required for the cast from `&f::Inner<T>` to the object type `dyn Debug`\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |"}, {"sha": "fccfbe1d744c2054159e72ad87afd1d27a073229", "filename": "src/test/ui/suggestions/option-content-move.stderr", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,23 +2,37 @@ error[E0507]: cannot move out of `selection.1` which is behind a shared referenc\n   --> $DIR/option-content-move.rs:11:20\n    |\n LL |                 if selection.1.unwrap().contains(selection.0) {\n-   |                    ^^^^^^^^^^^ move occurs because `selection.1` has type `Option<String>`, which does not implement the `Copy` trait\n+   |                    ^^^^^^^^^^^ -------- `selection.1` moved due to this method call\n+   |                    |\n+   |                    move occurs because `selection.1` has type `Option<String>`, which does not implement the `Copy` trait\n    |\n-help: consider borrowing the `Option`'s content\n+note: this function takes ownership of the receiver `self`, which moves `selection.1`\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL |     pub const fn unwrap(self) -> T {\n+   |                         ^^^^\n+help: consider calling `.as_ref()` to borrow the type's contents\n    |\n LL |                 if selection.1.as_ref().unwrap().contains(selection.0) {\n-   |                               +++++++++\n+   |                                +++++++++\n \n error[E0507]: cannot move out of `selection.1` which is behind a shared reference\n   --> $DIR/option-content-move.rs:29:20\n    |\n LL |                 if selection.1.unwrap().contains(selection.0) {\n-   |                    ^^^^^^^^^^^ move occurs because `selection.1` has type `Result<String, String>`, which does not implement the `Copy` trait\n+   |                    ^^^^^^^^^^^ -------- `selection.1` moved due to this method call\n+   |                    |\n+   |                    move occurs because `selection.1` has type `Result<String, String>`, which does not implement the `Copy` trait\n+   |\n+note: this function takes ownership of the receiver `self`, which moves `selection.1`\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n-help: consider borrowing the `Result`'s content\n+LL |     pub fn unwrap(self) -> T\n+   |                   ^^^^\n+help: consider calling `.as_ref()` to borrow the type's contents\n    |\n LL |                 if selection.1.as_ref().unwrap().contains(selection.0) {\n-   |                               +++++++++\n+   |                                +++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "120fc538307a7ac85b7b0a27e5a03766db900610", "filename": "src/test/ui/suggestions/suggest-borrow-to-dyn-object.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-borrow-to-dyn-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-borrow-to-dyn-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-borrow-to-dyn-object.rs?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -0,0 +1,16 @@\n+use std::ffi::{OsStr, OsString};\n+use std::path::Path;\n+\n+fn check(p: &dyn AsRef<Path>) {\n+    let m = std::fs::metadata(&p);\n+    println!(\"{:?}\", &m);\n+}\n+\n+fn main() {\n+    let s: OsString = \".\".into();\n+    let s: &OsStr = &s;\n+    check(s);\n+    //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+    //~| HELP within `OsStr`, the trait `Sized` is not implemented for `[u8]`\n+    //~| HELP consider borrowing the value, since `&OsStr` can be coerced into `dyn AsRef<Path>`\n+}"}, {"sha": "6b6e406130ec2934120b565060f719dca06aa87f", "filename": "src/test/ui/suggestions/suggest-borrow-to-dyn-object.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-borrow-to-dyn-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-borrow-to-dyn-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-borrow-to-dyn-object.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/suggest-borrow-to-dyn-object.rs:12:11\n+   |\n+LL |     check(s);\n+   |     ----- ^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: within `OsStr`, the trait `Sized` is not implemented for `[u8]`\n+   = note: required because it appears within the type `OsStr`\n+   = note: required for the cast from `OsStr` to the object type `dyn AsRef<Path>`\n+help: consider borrowing the value, since `&OsStr` can be coerced into `dyn AsRef<Path>`\n+   |\n+LL |     check(&s);\n+   |           +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "93d6770eb47d177975bbd96a67cba312575fa406", "filename": "src/test/ui/traits/coercion-generic-bad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Fcoercion-generic-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Fcoercion-generic-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcoercion-generic-bad.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -5,7 +5,7 @@ LL |     let s: Box<dyn Trait<isize>> = Box::new(Struct { person: \"Fred\" });\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<isize>` is not implemented for `Struct`\n    |\n    = help: the trait `Trait<&'static str>` is implemented for `Struct`\n-   = note: required for the cast to the object type `dyn Trait<isize>`\n+   = note: required for the cast from `Struct` to the object type `dyn Trait<isize>`\n \n error: aborting due to previous error\n "}, {"sha": "f685c50b07d5b439e8a7542ec26618df141d877c", "filename": "src/test/ui/traits/map-types.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Fmap-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Fmap-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fmap-types.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -5,7 +5,7 @@ LL |     let y: Box<dyn Map<usize, isize>> = Box::new(x);\n    |                                         ^^^^^^^^^^^ the trait `Map<usize, isize>` is not implemented for `Box<dyn Map<isize, isize>>`\n    |\n    = help: the trait `Map<K, V>` is implemented for `HashMap<K, V>`\n-   = note: required for the cast to the object type `dyn Map<usize, isize>`\n+   = note: required for the cast from `Box<dyn Map<isize, isize>>` to the object type `dyn Map<usize, isize>`\n \n error: aborting due to previous error\n "}, {"sha": "3985372119e886a98443f00bc890f08aa370f8bc", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-1.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -15,7 +15,7 @@ error[E0277]: the trait bound `&dyn Foo: Bar<_>` is not satisfied\n LL |     let _ = x as &dyn Bar<_>; // Ambiguous\n    |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo`\n    |\n-   = note: required for the cast to the object type `dyn Bar<_>`\n+   = note: required for the cast from `&dyn Foo` to the object type `dyn Bar<_>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "93c71f54eb53a6b6ddad16edff44b18ea83144eb", "filename": "src/test/ui/traits/trait-upcasting/type-checking-test-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Ftype-checking-test-2.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -15,7 +15,7 @@ error[E0277]: the trait bound `&dyn Foo<i32>: Bar<u32>` is not satisfied\n LL |     let _ = x as &dyn Bar<u32>; // Error\n    |             ^ the trait `Bar<u32>` is not implemented for `&dyn Foo<i32>`\n    |\n-   = note: required for the cast to the object type `dyn Bar<u32>`\n+   = note: required for the cast from `&dyn Foo<i32>` to the object type `dyn Bar<u32>`\n \n error[E0605]: non-primitive cast: `&dyn Foo<u32>` as `&dyn Bar<_>`\n   --> $DIR/type-checking-test-2.rs:26:13\n@@ -34,7 +34,7 @@ error[E0277]: the trait bound `&dyn Foo<u32>: Bar<_>` is not satisfied\n LL |     let a = x as &dyn Bar<_>; // Ambiguous\n    |             ^ the trait `Bar<_>` is not implemented for `&dyn Foo<u32>`\n    |\n-   = note: required for the cast to the object type `dyn Bar<_>`\n+   = note: required for the cast from `&dyn Foo<u32>` to the object type `dyn Bar<_>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "2733fb3149b55d1f8fcf87d9ca62091987fb4c6f", "filename": "src/test/ui/tuple/wrong_argument_ice-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/wrong_argument_ice-3.rs:9:16\n    |\n LL |         groups.push(new_group, vec![process]);\n-   |                ^^^^ ---------  ------------- argument unexpected\n+   |                ^^^^ ---------  ------------- argument of type `Vec<&Process>` unexpected\n    |                     |\n    |                     expected tuple, found struct `Vec`\n    |"}, {"sha": "3645d11842f7d4dc605dd34f067cb0ea01837975", "filename": "src/test/ui/tuple/wrong_argument_ice-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-4.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -6,7 +6,7 @@ LL |       (|| {})(|| {\n LL | |\n LL | |         let b = 1;\n LL | |     });\n-   | |_____- argument unexpected\n+   | |_____- argument of type `[closure@$DIR/wrong_argument_ice-4.rs:2:13: 5:6]` unexpected\n    |\n note: closure defined here\n   --> $DIR/wrong_argument_ice-4.rs:2:6"}, {"sha": "fcac6c495c4b2705eeb71a01775c56bcc789eca3", "filename": "src/test/ui/type/type-ascription-instead-of-initializer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-initializer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-initializer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-initializer.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -11,7 +11,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/type-ascription-instead-of-initializer.rs:2:12\n    |\n LL |     let x: Vec::with_capacity(10, 20);\n-   |            ^^^^^^^^^^^^^^^^^^     -- argument unexpected\n+   |            ^^^^^^^^^^^^^^^^^^     -- argument of type `{integer}` unexpected\n    |\n note: associated function defined here\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL"}, {"sha": "703032a83223154ff916a6292876b5497bae7819", "filename": "src/test/ui/typeck/remove-extra-argument.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftypeck%2Fremove-extra-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftypeck%2Fremove-extra-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fremove-extra-argument.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/remove-extra-argument.rs:6:5\n    |\n LL |     l(vec![], vec![])\n-   |     ^         ------ argument unexpected\n+   |     ^         ------ argument of type `Vec<_>` unexpected\n    |\n note: function defined here\n   --> $DIR/remove-extra-argument.rs:3:4"}, {"sha": "f72082d53016729e3b45b3f68205382ac45b016e", "filename": "src/test/ui/typeck/struct-enum-wrong-args.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftypeck%2Fstruct-enum-wrong-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Ftypeck%2Fstruct-enum-wrong-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fstruct-enum-wrong-args.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this enum variant takes 1 argument but 2 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:6:13\n    |\n LL |     let _ = Some(3, 2);\n-   |             ^^^^    - argument unexpected\n+   |             ^^^^    - argument of type `{integer}` unexpected\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n@@ -18,9 +18,9 @@ error[E0061]: this enum variant takes 1 argument but 3 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:7:13\n    |\n LL |     let _ = Ok(3, 6, 2);\n-   |             ^^    -  - argument unexpected\n+   |             ^^    -  - argument of type `{integer}` unexpected\n    |                   |\n-   |                   argument unexpected\n+   |                   argument of type `{integer}` unexpected\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n@@ -68,7 +68,7 @@ error[E0061]: this struct takes 1 argument but 2 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:10:13\n    |\n LL |     let _ = Wrapper(5, 2);\n-   |             ^^^^^^^    - argument unexpected\n+   |             ^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: tuple struct defined here\n   --> $DIR/struct-enum-wrong-args.rs:2:8\n@@ -116,7 +116,7 @@ error[E0061]: this struct takes 2 arguments but 3 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:13:13\n    |\n LL |     let _ = DoubleWrapper(5, 2, 7);\n-   |             ^^^^^^^^^^^^^       - argument unexpected\n+   |             ^^^^^^^^^^^^^       - argument of type `{integer}` unexpected\n    |\n note: tuple struct defined here\n   --> $DIR/struct-enum-wrong-args.rs:3:8"}, {"sha": "65d866c716e0e01049bd00b514915b708b5b5e4f", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -46,13 +46,25 @@ error[E0507]: cannot move out of `*m` which is behind a mutable reference\n   --> $DIR/unop-move-semantics.rs:24:6\n    |\n LL |     !*m;\n-   |      ^^ move occurs because `*m` has type `T`, which does not implement the `Copy` trait\n+   |     -^^\n+   |     ||\n+   |     |move occurs because `*m` has type `T`, which does not implement the `Copy` trait\n+   |     `*m` moved due to usage in operator\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n+   |\n+LL |     fn not(self) -> Self::Output;\n+   |            ^^^^\n \n error[E0507]: cannot move out of `*n` which is behind a shared reference\n   --> $DIR/unop-move-semantics.rs:26:6\n    |\n LL |     !*n;\n-   |      ^^ move occurs because `*n` has type `T`, which does not implement the `Copy` trait\n+   |     -^^\n+   |     ||\n+   |     |move occurs because `*n` has type `T`, which does not implement the `Copy` trait\n+   |     `*n` moved due to usage in operator\n \n error: aborting due to 5 previous errors\n "}, {"sha": "b4772605432584914fb79fa5a6ec9f6a8fdeeca6", "filename": "src/test/ui/unsized/unsized-fn-param.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr?ref=493c960a3e6cdd2e2fbe8b6ea130fadea05f1ab0", "patch": "@@ -5,7 +5,7 @@ LL |     foo11(\"bar\", &\"baz\");\n    |           ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn AsRef<Path>`\n+   = note: required for the cast from `str` to the object type `dyn AsRef<Path>`\n help: consider borrowing the value, since `&str` can be coerced into `dyn AsRef<Path>`\n    |\n LL |     foo11(&\"bar\", &\"baz\");\n@@ -18,7 +18,7 @@ LL |     foo12(&\"bar\", \"baz\");\n    |                   ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn AsRef<Path>`\n+   = note: required for the cast from `str` to the object type `dyn AsRef<Path>`\n help: consider borrowing the value, since `&str` can be coerced into `dyn AsRef<Path>`\n    |\n LL |     foo12(&\"bar\", &\"baz\");\n@@ -31,7 +31,7 @@ LL |     foo21(\"bar\", &\"baz\");\n    |           ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn AsRef<str>`\n+   = note: required for the cast from `str` to the object type `dyn AsRef<str>`\n help: consider borrowing the value, since `&str` can be coerced into `dyn AsRef<str>`\n    |\n LL |     foo21(&\"bar\", &\"baz\");\n@@ -44,7 +44,7 @@ LL |     foo22(&\"bar\", \"baz\");\n    |                   ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n-   = note: required for the cast to the object type `dyn AsRef<str>`\n+   = note: required for the cast from `str` to the object type `dyn AsRef<str>`\n help: consider borrowing the value, since `&str` can be coerced into `dyn AsRef<str>`\n    |\n LL |     foo22(&\"bar\", &\"baz\");"}]}