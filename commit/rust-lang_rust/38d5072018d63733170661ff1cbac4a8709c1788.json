{"sha": "38d5072018d63733170661ff1cbac4a8709c1788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZDUwNzIwMThkNjM3MzMxNzA2NjFmZjFjYmFjNGE4NzA5YzE3ODg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-20T21:29:48Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T21:01:29Z"}, "message": "librustc: De-`@mut` the undo log in `RegionVarBindings`", "tree": {"sha": "8b21777f22cfe04cfd9503554602c4ec94283c4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b21777f22cfe04cfd9503554602c4ec94283c4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38d5072018d63733170661ff1cbac4a8709c1788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38d5072018d63733170661ff1cbac4a8709c1788", "html_url": "https://github.com/rust-lang/rust/commit/38d5072018d63733170661ff1cbac4a8709c1788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38d5072018d63733170661ff1cbac4a8709c1788/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b84f294c4672018e237e8196eef59bb668b805f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b84f294c4672018e237e8196eef59bb668b805f2", "html_url": "https://github.com/rust-lang/rust/commit/b84f294c4672018e237e8196eef59bb668b805f2"}], "stats": {"total": 89, "additions": 57, "deletions": 32}, "files": [{"sha": "fc0479805afbd7d1ffc556f8a0f6cfaaa9800d27", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/38d5072018d63733170661ff1cbac4a8709c1788/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d5072018d63733170661ff1cbac4a8709c1788/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=38d5072018d63733170661ff1cbac4a8709c1788", "patch": "@@ -103,7 +103,7 @@ pub struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    undo_log: ~[UndoLogEntry],\n+    undo_log: RefCell<~[UndoLogEntry]>,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n@@ -120,36 +120,45 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n         glbs: RefCell::new(HashMap::new()),\n         skolemization_count: Cell::new(0),\n         bound_count: Cell::new(0),\n-        undo_log: ~[]\n+        undo_log: RefCell::new(~[])\n     }\n }\n \n impl RegionVarBindings {\n     pub fn in_snapshot(&self) -> bool {\n-        self.undo_log.len() > 0\n+        let undo_log = self.undo_log.borrow();\n+        undo_log.get().len() > 0\n     }\n \n     pub fn start_snapshot(&mut self) -> uint {\n-        debug!(\"RegionVarBindings: snapshot()={}\", self.undo_log.len());\n+        debug!(\"RegionVarBindings: start_snapshot()\");\n         if self.in_snapshot() {\n-            self.undo_log.len()\n+            {\n+                let undo_log = self.undo_log.borrow();\n+                undo_log.get().len()\n+            }\n         } else {\n-            self.undo_log.push(Snapshot);\n-            0\n+            {\n+                let mut undo_log = self.undo_log.borrow_mut();\n+                undo_log.get().push(Snapshot);\n+                0\n+            }\n         }\n     }\n \n     pub fn commit(&mut self) {\n         debug!(\"RegionVarBindings: commit()\");\n-        while self.undo_log.len() > 0 {\n-            self.undo_log.pop();\n+        let mut undo_log = self.undo_log.borrow_mut();\n+        while undo_log.get().len() > 0 {\n+            undo_log.get().pop();\n         }\n     }\n \n     pub fn rollback_to(&mut self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n-        while self.undo_log.len() > snapshot {\n-            let undo_item = self.undo_log.pop();\n+        let mut undo_log = self.undo_log.borrow_mut();\n+        while undo_log.get().len() > snapshot {\n+            let undo_item = undo_log.get().pop();\n             debug!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n@@ -182,7 +191,10 @@ impl RegionVarBindings {\n         self.var_origins.push(origin);\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n-            self.undo_log.push(AddVar(vid));\n+            {\n+                let mut undo_log = self.undo_log.borrow_mut();\n+                undo_log.get().push(AddVar(vid));\n+            }\n         }\n         debug!(\"created new region variable {:?} with origin {:?}\",\n                vid, origin.repr(self.tcx));\n@@ -235,7 +247,10 @@ impl RegionVarBindings {\n         let mut constraints = self.constraints.borrow_mut();\n         if constraints.get().insert(constraint, origin) {\n             if self.in_snapshot() {\n-                self.undo_log.push(AddConstraint(constraint));\n+                {\n+                    let mut undo_log = self.undo_log.borrow_mut();\n+                    undo_log.get().push(AddConstraint(constraint));\n+                }\n             }\n         }\n     }\n@@ -380,7 +395,10 @@ impl RegionVarBindings {\n             map.get().insert(vars, c);\n         }\n         if self.in_snapshot() {\n-            self.undo_log.push(AddCombination(t, vars));\n+            {\n+                let mut undo_log = self.undo_log.borrow_mut();\n+                undo_log.get().push(AddCombination(t, vars));\n+            }\n         }\n         relate(self, a, ReInfer(ReVar(c)));\n         relate(self, b, ReInfer(ReVar(c)));\n@@ -390,7 +408,8 @@ impl RegionVarBindings {\n \n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n                                        -> ~[RegionVid] {\n-        self.undo_log.slice_from(snapshot).iter()\n+        let undo_log = self.undo_log.borrow();\n+        undo_log.get().slice_from(snapshot).iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n                 _ => None\n@@ -410,7 +429,10 @@ impl RegionVarBindings {\n         debug!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n         let _indenter = indenter();\n \n-        let undo_len = self.undo_log.len();\n+        let undo_len = {\n+            let undo_log = self.undo_log.borrow();\n+            undo_log.get().len()\n+        };\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n@@ -426,22 +448,25 @@ impl RegionVarBindings {\n             let mut undo_index = snapshot;\n             while undo_index < undo_len {\n                 // nb: can't use uint::range() here as we move result_set\n-                let regs = match self.undo_log[undo_index] {\n-                    AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)),\n-                              ReInfer(ReVar(*b))))\n-                    }\n-                    AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n-                        Some((*a, ReInfer(ReVar(*b))))\n-                    }\n-                    AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n-                        Some((ReInfer(ReVar(*a)), *b))\n-                    }\n-                    AddConstraint(ConstrainRegSubReg(a, b)) => {\n-                        Some((a, b))\n-                    }\n-                    _ => {\n-                        None\n+                let regs = {\n+                    let undo_log = self.undo_log.borrow();\n+                    match undo_log.get()[undo_index] {\n+                        AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n+                            Some((ReInfer(ReVar(*a)),\n+                                  ReInfer(ReVar(*b))))\n+                        }\n+                        AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n+                            Some((*a, ReInfer(ReVar(*b))))\n+                        }\n+                        AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n+                            Some((ReInfer(ReVar(*a)), *b))\n+                        }\n+                        AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                            Some((a, b))\n+                        }\n+                        _ => {\n+                            None\n+                        }\n                     }\n                 };\n "}]}