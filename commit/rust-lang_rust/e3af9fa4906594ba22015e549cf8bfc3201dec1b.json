{"sha": "e3af9fa4906594ba22015e549cf8bfc3201dec1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYWY5ZmE0OTA2NTk0YmEyMjAxNWU1NDljZjhiZmMzMjAxZGVjMWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-07T18:20:50Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-06-09T11:55:19Z"}, "message": "make the basic_blocks field private", "tree": {"sha": "a98c4a76863fbc9d190d00d73bb533200c9f73b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a98c4a76863fbc9d190d00d73bb533200c9f73b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3af9fa4906594ba22015e549cf8bfc3201dec1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3af9fa4906594ba22015e549cf8bfc3201dec1b", "html_url": "https://github.com/rust-lang/rust/commit/e3af9fa4906594ba22015e549cf8bfc3201dec1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3af9fa4906594ba22015e549cf8bfc3201dec1b/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc1eb67721a842d62bec8e879aad339fd22fe3c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1eb67721a842d62bec8e879aad339fd22fe3c6", "html_url": "https://github.com/rust-lang/rust/commit/bc1eb67721a842d62bec8e879aad339fd22fe3c6"}], "stats": {"total": 403, "additions": 203, "deletions": 200}, "files": [{"sha": "7394d0081ed85a0166b0b7caa007fec5b7b3128c", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -55,7 +55,7 @@ macro_rules! newtype_index {\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n-    pub basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n     /// List of visibility (lexical) scopes; these are referenced by statements\n     /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n@@ -94,18 +94,37 @@ pub struct Mir<'tcx> {\n pub const START_BLOCK: BasicBlock = BasicBlock(0);\n \n impl<'tcx> Mir<'tcx> {\n-    pub fn all_basic_blocks(&self) -> Vec<BasicBlock> {\n-        (0..self.basic_blocks.len())\n-            .map(|i| BasicBlock::new(i))\n-            .collect()\n+    pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+               visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+               promoted: IndexVec<Promoted, Mir<'tcx>>,\n+               return_ty: FnOutput<'tcx>,\n+               var_decls: IndexVec<Var, VarDecl<'tcx>>,\n+               arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n+               temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n+               upvar_decls: Vec<UpvarDecl>,\n+               span: Span) -> Self\n+    {\n+        Mir {\n+            basic_blocks: basic_blocks,\n+            visibility_scopes: visibility_scopes,\n+            promoted: promoted,\n+            return_ty: return_ty,\n+            var_decls: var_decls,\n+            arg_decls: arg_decls,\n+            temp_decls: temp_decls,\n+            upvar_decls: upvar_decls,\n+            span: span\n+        }\n     }\n \n-    pub fn basic_block_data(&self, bb: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.basic_blocks[bb]\n+    #[inline]\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.basic_blocks\n     }\n \n-    pub fn basic_block_data_mut(&mut self, bb: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks[bb]\n+    #[inline]\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &mut self.basic_blocks\n     }\n }\n \n@@ -114,14 +133,14 @@ impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n \n     #[inline]\n     fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        self.basic_block_data(index)\n+        &self.basic_blocks()[index]\n     }\n }\n \n impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     #[inline]\n     fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        self.basic_block_data_mut(index)\n+        &mut self.basic_blocks_mut()[index]\n     }\n }\n "}, {"sha": "1af5123b4df6046828bf6f6d00c3e53152efd780", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n \n         Preorder {\n             mir: mir,\n-            visited: BitVector::new(mir.basic_blocks.len()),\n+            visited: BitVector::new(mir.basic_blocks().len()),\n             worklist: worklist\n         }\n     }\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n                 continue;\n             }\n \n-            let data = self.mir.basic_block_data(idx);\n+            let data = &self.mir[idx];\n \n             if let Some(ref term) = data.terminator {\n                 for &succ in term.successors().iter() {\n@@ -107,12 +107,12 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n             mir: mir,\n-            visited: BitVector::new(mir.basic_blocks.len()),\n+            visited: BitVector::new(mir.basic_blocks().len()),\n             visit_stack: Vec::new()\n         };\n \n \n-        let data = po.mir.basic_block_data(root);\n+        let data = &po.mir[root];\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root.index());\n@@ -186,9 +186,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n             };\n \n             if self.visited.insert(bb.index()) {\n-                let data = self.mir.basic_block_data(bb);\n-\n-                if let Some(ref term) = data.terminator {\n+                if let Some(ref term) = self.mir[bb].terminator {\n                     let succs = term.successors().into_owned().into_iter();\n                     self.visit_stack.push((bb, succs));\n                 }\n@@ -210,10 +208,7 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n             self.traverse_successor();\n         }\n \n-        next.map(|(bb, _)| {\n-            let data = self.mir.basic_block_data(bb);\n-            (bb, data)\n-        })\n+        next.map(|(bb, _)| (bb, &self.mir[bb]))\n     }\n }\n \n@@ -279,9 +274,6 @@ impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n         if self.idx == 0 { return None; }\n         self.idx -= 1;\n \n-        self.blocks.get(self.idx).map(|&bb| {\n-            let data = self.mir.basic_block_data(bb);\n-            (bb, data)\n-        })\n+        self.blocks.get(self.idx).map(|&bb| (bb, &self.mir[bb]))\n     }\n }"}, {"sha": "fcc7715a8af3138debe43c1188da5411197d1721", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -252,42 +252,30 @@ macro_rules! make_mir_visitor {\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {\n-                let Mir {\n-                    ref $($mutability)* basic_blocks,\n-                    ref $($mutability)* visibility_scopes,\n-                    promoted: _, // Visited by passes separately.\n-                    ref $($mutability)* return_ty,\n-                    ref $($mutability)* var_decls,\n-                    ref $($mutability)* arg_decls,\n-                    ref $($mutability)* temp_decls,\n-                    upvar_decls: _,\n-                    ref $($mutability)* span,\n-                } = *mir;\n-\n-                for (index, data) in basic_blocks.into_iter().enumerate() {\n+                for index in 0..mir.basic_blocks().len() {\n                     let block = BasicBlock::new(index);\n-                    self.visit_basic_block_data(block, data);\n+                    self.visit_basic_block_data(block, &$($mutability)* mir[block]);\n                 }\n \n-                for scope in visibility_scopes {\n+                for scope in &$($mutability)* mir.visibility_scopes {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                self.visit_fn_output(return_ty);\n+                self.visit_fn_output(&$($mutability)* mir.return_ty);\n \n-                for var_decl in var_decls {\n+                for var_decl in &$($mutability)* mir.var_decls {\n                     self.visit_var_decl(var_decl);\n                 }\n \n-                for arg_decl in arg_decls {\n+                for arg_decl in &$($mutability)* mir.arg_decls {\n                     self.visit_arg_decl(arg_decl);\n                 }\n \n-                for temp_decl in temp_decls {\n+                for temp_decl in &$($mutability)* mir.temp_decls {\n                     self.visit_temp_decl(temp_decl);\n                 }\n \n-                self.visit_span(span);\n+                self.visit_span(&$($mutability)* mir.span);\n             }\n \n             fn super_basic_block_data(&mut self,"}, {"sha": "91be50d11f952c68fe9e1bc8a28758ad93ef2300", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -127,7 +127,7 @@ pub type Node = BasicBlock;\n pub struct Edge { source: BasicBlock, index: usize }\n \n fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n-    let succ_len = mir.basic_block_data(bb).terminator().successors().len();\n+    let succ_len = mir[bb].terminator().successors().len();\n     (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n }\n \n@@ -313,17 +313,20 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n     type Node = Node;\n     type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        self.mbcx.mir().all_basic_blocks().into_cow()\n+        self.mbcx.mir()\n+            .basic_blocks()\n+            .indices()\n+            .collect::<Vec<_>>()\n+            .into_cow()\n     }\n \n     fn edges(&self) -> dot::Edges<Edge> {\n         let mir = self.mbcx.mir();\n-        let blocks = mir.all_basic_blocks();\n         // base initial capacity on assumption every block has at\n         // least one outgoing edge (Which should be true for all\n         // blocks but one, the exit-block).\n-        let mut edges = Vec::with_capacity(blocks.len());\n-        for bb in blocks {\n+        let mut edges = Vec::with_capacity(mir.basic_blocks().len());\n+        for bb in mir.basic_blocks().indices() {\n             let outgoing = outgoing(mir, bb);\n             edges.extend(outgoing.into_iter());\n         }\n@@ -336,6 +339,6 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n \n     fn target(&self, edge: &Edge) -> Node {\n         let mir = self.mbcx.mir();\n-        mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n+        mir[edge.source].terminator().successors()[edge.index]\n     }\n }"}, {"sha": "932b748520170ac11c594920a74f047c7eca3345", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                         bb: repr::BasicBlock,\n                         idx: usize) {\n         let (tcx, mir, move_data) = (self.tcx, self.mir, &ctxt.move_data);\n-        let stmt = &mir.basic_block_data(bb).statements[idx];\n+        let stmt = &mir[bb].statements[idx];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n         let rev_lookup = &move_data.rev_lookup;\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                          statements_len: usize)\n     {\n         let (mir, move_data) = (self.mir, &ctxt.move_data);\n-        let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n+        let term = mir[bb].terminator();\n         let loc_map = &move_data.loc_map;\n         let loc = Location { block: bb, index: statements_len };\n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\","}, {"sha": "d42103d5d25a20fecf1d7bb97cb9a4af46acc3a1", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -83,11 +83,10 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n             self.flow_state.operator.start_block_effect(&self.ctxt, sets);\n         }\n \n-        for bb in self.mir.all_basic_blocks() {\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let &repr::BasicBlockData { ref statements,\n                                         ref terminator,\n-                                        is_cleanup: _ } =\n-                self.mir.basic_block_data(bb);\n+                                        is_cleanup: _ } = data;\n \n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n             for j_stmt in 0..statements.len() {\n@@ -114,7 +113,7 @@ impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n \n     fn walk_cfg(&mut self, in_out: &mut IdxSet<BD::Idx>) {\n         let mir = self.builder.mir;\n-        for (bb_idx, bb_data) in mir.basic_blocks.iter().enumerate() {\n+        for (bb_idx, bb_data) in mir.basic_blocks().iter().enumerate() {\n             let builder = &mut self.builder;\n             {\n                 let sets = builder.flow_state.sets.for_block(bb_idx);\n@@ -398,7 +397,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         // (now rounded up to multiple of word size)\n         let bits_per_block = words_per_block * usize_bits;\n \n-        let num_blocks = mir.basic_blocks.len();\n+        let num_blocks = mir.basic_blocks().len();\n         let num_overall = num_blocks * bits_per_block;\n \n         let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));"}, {"sha": "c8d3ff01b6c1a37acce4ed97113b6afd9a6e246a", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -50,8 +50,7 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // `dataflow::build_sets`. (But note it is doing non-standard\n     // stuff, so such generalization may not be realistic.)\n \n-    let blocks = mir.all_basic_blocks();\n-    'next_block: for bb in blocks {\n+    for bb in mir.basic_blocks().indices() {\n         each_block(tcx, mir, flow_ctxt, results, bb);\n     }\n }\n@@ -64,10 +63,9 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n {\n     let move_data = &ctxt.move_data;\n-    let bb_data = mir.basic_block_data(bb);\n-    let &repr::BasicBlockData { ref statements,\n-                                ref terminator,\n-                                is_cleanup: _ } = bb_data;\n+    let repr::BasicBlockData { ref statements,\n+                               ref terminator,\n+                               is_cleanup: _ } = mir[bb];\n \n     let (args, span) = match is_rustc_peek(tcx, terminator) {\n         Some(args_and_span) => args_and_span,"}, {"sha": "6ecf4a66d62b1ff42d7db636672b386518e83baa", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -225,8 +225,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn collect_drop_flags(&mut self)\n     {\n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let terminator = data.terminator();\n             let location = match terminator.kind {\n                 TerminatorKind::Drop { ref location, .. } |\n@@ -262,8 +261,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn elaborate_drops(&mut self)\n     {\n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let loc = Location { block: bb, index: data.statements.len() };\n             let terminator = data.terminator();\n \n@@ -323,7 +321,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         unwind: Option<BasicBlock>)\n     {\n         let bb = loc.block;\n-        let data = self.mir.basic_block_data(bb);\n+        let data = &self.mir[bb];\n         let terminator = data.terminator();\n \n         let assign = Statement {\n@@ -942,8 +940,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_for_fn_rets(&mut self) {\n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             if let TerminatorKind::Call {\n                 destination: Some((ref lv, tgt)), cleanup: Some(_), ..\n             } = data.terminator().kind {\n@@ -975,8 +972,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // drop flags by themselves, to avoid the drop flags being\n         // clobbered before they are read.\n \n-        for bb in self.mir.all_basic_blocks() {\n-            let data = self.mir.basic_block_data(bb);\n+        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len()+1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);"}, {"sha": "7a3f467a627f84120548c6bf5cd7dc6d0d64fae2", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -519,9 +519,9 @@ enum StmtKind {\n fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n     use self::StmtKind as SK;\n \n-    let bbs = mir.all_basic_blocks();\n-    let mut moves = Vec::with_capacity(bbs.len());\n-    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bbs.len()).collect();\n+    let bb_count = mir.basic_blocks().len();\n+    let mut moves = vec![];\n+    let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bb_count).collect();\n     let mut path_map = Vec::new();\n \n     // this is mutable only because we will move it to and fro' the\n@@ -541,22 +541,21 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n     assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n     assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n-    for (var, _) in mir.var_decls.iter_enumerated() {\n+    for var in mir.var_decls.indices() {\n         let path_idx = builder.move_path_for(&Lvalue::Var(var));\n         path_map.fill_to(path_idx.index());\n     }\n-    for (arg, _) in mir.arg_decls.iter_enumerated() {\n+    for arg in mir.arg_decls.indices() {\n         let path_idx = builder.move_path_for(&Lvalue::Arg(arg));\n         path_map.fill_to(path_idx.index());\n     }\n-    for (temp, _) in mir.temp_decls.iter_enumerated() {\n+    for temp in mir.temp_decls.indices() {\n         let path_idx = builder.move_path_for(&Lvalue::Temp(temp));\n         path_map.fill_to(path_idx.index());\n     }\n \n-    for bb in bbs {\n+    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let loc_map_bb = &mut loc_map[bb.index()];\n-        let bb_data = mir.basic_block_data(bb);\n \n         debug_assert!(loc_map_bb.len() == 0);\n         let len = bb_data.statements.len();"}, {"sha": "270b16fcf49fe2e7c211294c73305acf5776df5c", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -111,7 +111,7 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n         flow_uninits: flow_uninits,\n     };\n \n-    for bb in mir.all_basic_blocks() {\n+    for bb in mir.basic_blocks().indices() {\n         mbcx.process_basic_block(bb);\n     }\n \n@@ -180,8 +180,8 @@ pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n     fn process_basic_block(&mut self, bb: BasicBlock) {\n-        let &BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n-            self.mir.basic_block_data(bb);\n+        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n+            self.mir[bb];\n         for stmt in statements {\n             self.process_statement(bb, stmt);\n         }\n@@ -337,8 +337,8 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                              |moi| callback(moi, DropFlagState::Absent))\n     }\n \n-    let bb = mir.basic_block_data(loc.block);\n-    match bb.statements.get(loc.index) {\n+    let block = &mir[loc.block];\n+    match block.statements.get(loc.index) {\n         Some(stmt) => match stmt.kind {\n             repr::StatementKind::Assign(ref lvalue, _) => {\n                 debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n@@ -348,8 +348,8 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             }\n         },\n         None => {\n-            debug!(\"drop_flag_effects: replace {:?}\", bb.terminator());\n-            match bb.terminator().kind {\n+            debug!(\"drop_flag_effects: replace {:?}\", block.terminator());\n+            match block.terminator().kind {\n                 repr::TerminatorKind::DropAndReplace { ref location, .. } => {\n                     on_all_children_bits(tcx, mir, move_data,\n                                          move_data.rev_lookup.find(location),"}, {"sha": "417e719a9dcb9f73cee1c24c6736cdaf532ed185", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -28,7 +28,7 @@ pub struct MirPatch<'tcx> {\n impl<'tcx> MirPatch<'tcx> {\n     pub fn new(mir: &Mir<'tcx>) -> Self {\n         let mut result = MirPatch {\n-            patch_map: IndexVec::from_elem(None, &mir.basic_blocks),\n+            patch_map: IndexVec::from_elem(None, mir.basic_blocks()),\n             new_blocks: vec![],\n             new_temps: vec![],\n             new_statements: vec![],\n@@ -43,13 +43,12 @@ impl<'tcx> MirPatch<'tcx> {\n \n         let mut resume_block = None;\n         let mut resume_stmt_block = None;\n-        for block in mir.all_basic_blocks() {\n-            let data = mir.basic_block_data(block);\n-            if let TerminatorKind::Resume = data.terminator().kind {\n-                if data.statements.len() > 0 {\n-                    resume_stmt_block = Some(block);\n+        for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+            if let TerminatorKind::Resume = block.terminator().kind {\n+                if block.statements.len() > 0 {\n+                    resume_stmt_block = Some(bb);\n                 } else {\n-                    resume_block = Some(block);\n+                    resume_block = Some(bb);\n                 }\n                 break\n             }\n@@ -84,9 +83,9 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn terminator_loc(&self, mir: &Mir<'tcx>, bb: BasicBlock) -> Location {\n-        let offset = match bb.index().checked_sub(mir.basic_blocks.len()) {\n+        let offset = match bb.index().checked_sub(mir.basic_blocks().len()) {\n             Some(index) => self.new_blocks[index].statements.len(),\n-            None => mir.basic_block_data(bb).statements.len()\n+            None => mir[bb].statements.len()\n         };\n         Location {\n             block: bb,\n@@ -128,13 +127,13 @@ impl<'tcx> MirPatch<'tcx> {\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n                self.new_temps.len(), mir.temp_decls.len(), self.new_temps);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\",\n-               self.new_blocks.len(), mir.basic_blocks.len());\n-        mir.basic_blocks.extend(self.new_blocks);\n+               self.new_blocks.len(), mir.basic_blocks().len());\n+        mir.basic_blocks_mut().extend(self.new_blocks);\n         mir.temp_decls.extend(self.new_temps);\n         for (src, patch) in self.patch_map.into_iter_enumerated() {\n             if let Some(patch) = patch {\n                 debug!(\"MirPatch: patching block {:?}\", src);\n-                mir.basic_blocks[src].terminator_mut().kind = patch;\n+                mir[src].terminator_mut().kind = patch;\n             }\n         }\n \n@@ -152,9 +151,9 @@ impl<'tcx> MirPatch<'tcx> {\n                    stmt, loc, delta);\n             loc.index += delta;\n             let source_info = Self::source_info_for_index(\n-                mir.basic_block_data(loc.block), loc\n+                &mir[loc.block], loc\n             );\n-            mir.basic_block_data_mut(loc.block).statements.insert(\n+            mir[loc.block].statements.insert(\n                 loc.index, Statement {\n                     source_info: source_info,\n                     kind: stmt\n@@ -171,9 +170,9 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn source_info_for_location(&self, mir: &Mir, loc: Location) -> SourceInfo {\n-        let data = match loc.block.index().checked_sub(mir.basic_blocks.len()) {\n+        let data = match loc.block.index().checked_sub(mir.basic_blocks().len()) {\n             Some(new) => &self.new_blocks[new],\n-            None => mir.basic_block_data(loc.block)\n+            None => &mir[loc.block]\n         };\n         Self::source_info_for_index(data, loc)\n     }"}, {"sha": "db054477f75a10517956dc457e03692c8cf43330", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -11,7 +11,7 @@\n use std::iter::{self, FromIterator};\n use std::slice;\n use std::marker::PhantomData;\n-use std::ops::{Index, IndexMut};\n+use std::ops::{Index, IndexMut, Range};\n use std::fmt;\n use std::vec;\n \n@@ -115,6 +115,11 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.iter().enumerate().map(IntoIdx { _marker: PhantomData })\n     }\n \n+    #[inline]\n+    pub fn indices(&self) -> iter::Map<Range<usize>, IntoIdx<I>> {\n+        (0..self.len()).map(IntoIdx { _marker: PhantomData })\n+    }\n+\n     #[inline]\n     pub fn iter_mut(&mut self) -> slice::IterMut<T> {\n         self.raw.iter_mut()\n@@ -207,3 +212,17 @@ impl<I: Idx, T> FnMut<((usize, T),)> for IntoIdx<I> {\n         (I::new(n), t)\n     }\n }\n+\n+impl<I: Idx> FnOnce<(usize,)> for IntoIdx<I> {\n+    type Output = I;\n+\n+    extern \"rust-call\" fn call_once(self, (n,): (usize,)) -> Self::Output {\n+        I::new(n)\n+    }\n+}\n+\n+impl<I: Idx> FnMut<(usize,)> for IntoIdx<I> {\n+    extern \"rust-call\" fn call_mut(&mut self, (n,): (usize,)) -> Self::Output {\n+        I::new(n)\n+    }\n+}"}, {"sha": "2626a02281f7dc3a3d55d28b5eb92eb713b6ece9", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -295,17 +295,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        (Mir {\n-            basic_blocks: self.cfg.basic_blocks,\n-            visibility_scopes: self.visibility_scopes,\n-            promoted: IndexVec::new(),\n-            var_decls: self.var_decls,\n-            arg_decls: arg_decls,\n-            temp_decls: self.temp_decls,\n-            upvar_decls: upvar_decls,\n-            return_ty: return_ty,\n-            span: self.fn_span\n-        }, self.scope_auxiliary)\n+        (Mir::new(self.cfg.basic_blocks,\n+                  self.visibility_scopes,\n+                  IndexVec::new(),\n+                  return_ty,\n+                  self.var_decls,\n+                  arg_decls,\n+                  self.temp_decls,\n+                  upvar_decls,\n+                  self.fn_span\n+        ), self.scope_auxiliary)\n     }\n \n     fn args_and_body<A>(&mut self,"}, {"sha": "fdfa872b0b698805f140863294837893e86a70e7", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -34,12 +34,12 @@ where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n         write_graph_label(tcx, nodeid, mir, w)?;\n \n         // Nodes\n-        for block in mir.all_basic_blocks() {\n+        for (block, _) in mir.basic_blocks().iter_enumerated() {\n             write_node(block, mir, w)?;\n         }\n \n         // Edges\n-        for source in mir.all_basic_blocks() {\n+        for (source, _) in mir.basic_blocks().iter_enumerated() {\n             write_edges(source, mir, w)?;\n         }\n         writeln!(w, \"}}\")?\n@@ -63,7 +63,7 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n     where INIT: Fn(&mut W) -> io::Result<()>,\n           FINI: Fn(&mut W) -> io::Result<()>\n {\n-    let data = mir.basic_block_data(block);\n+    let data = &mir[block];\n \n     write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n \n@@ -107,7 +107,7 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<(\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n-    let terminator = &mir.basic_block_data(source).terminator();\n+    let terminator = mir[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n     for (&target, label) in terminator.successors().iter().zip(labels) {"}, {"sha": "856d6cda5af0f2cbc3addf020c1a41ff0f846e35", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -135,9 +135,9 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               -> io::Result<()> {\n     let annotations = scope_entry_exit_annotations(auxiliary);\n     write_mir_intro(tcx, src, mir, w)?;\n-    for block in mir.all_basic_blocks() {\n+    for block in mir.basic_blocks().indices() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n-        if block.index() + 1 != mir.basic_blocks.len() {\n+        if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n     }\n@@ -153,7 +153,7 @@ fn write_basic_block(tcx: TyCtxt,\n                      w: &mut Write,\n                      annotations: &FnvHashMap<Location, Vec<Annotation>>)\n                      -> io::Result<()> {\n-    let data = mir.basic_block_data(block);\n+    let data = &mir[block];\n \n     // Basic block label at the top.\n     writeln!(w, \"{}{:?}: {{\", INDENT, block)?;"}, {"sha": "dee9227fd9b0e98a222f5a08e285e0d3b3fa8fc0", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -40,7 +40,7 @@ pub struct AddCallGuards;\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut pred_count = IndexVec::from_elem(0u32, &mir.basic_blocks);\n+        let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n \n         // Build the precedecessor map for the MIR\n         for (_, data) in traversal::preorder(mir) {\n@@ -54,13 +54,10 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n-        let bbs = mir.all_basic_blocks();\n-        let cur_len = mir.basic_blocks.len();\n+        let cur_len = mir.basic_blocks().len();\n \n-        for &bb in &bbs {\n-            let data = mir.basic_block_data_mut(bb);\n-\n-            match data.terminator {\n+        for block in mir.basic_blocks_mut() {\n+            match block.terminator {\n                 Some(Terminator {\n                     kind: TerminatorKind::Call {\n                         destination: Some((_, ref mut destination)),\n@@ -71,7 +68,7 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n                     // It's a critical edge, break it\n                     let call_guard = BasicBlockData {\n                         statements: vec![],\n-                        is_cleanup: data.is_cleanup,\n+                        is_cleanup: block.is_cleanup,\n                         terminator: Some(Terminator {\n                             source_info: source_info,\n                             kind: TerminatorKind::Goto { target: *destination }\n@@ -90,7 +87,7 @@ impl<'tcx> MirPass<'tcx> for AddCallGuards {\n         pretty::dump_mir(tcx, \"break_cleanup_edges\", &0, src, mir, None);\n         debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        mir.basic_blocks.extend(new_blocks);\n+        mir.basic_blocks_mut().extend(new_blocks);\n     }\n }\n "}, {"sha": "3ebfef10d43113444b0fc16d284ea20eb28a49e1", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -163,11 +163,12 @@ struct Promoter<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn new_block(&mut self) -> BasicBlock {\n-        self.promoted.basic_blocks.push(BasicBlockData {\n+        let span = self.promoted.span;\n+        self.promoted.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n                 source_info: SourceInfo {\n-                    span: self.promoted.span,\n+                    span: span,\n                     scope: ARGUMENT_VISIBILITY_SCOPE\n                 },\n                 kind: TerminatorKind::Return\n@@ -177,8 +178,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted.basic_blocks.last().unwrap();\n-        let data = &mut self.promoted.basic_blocks[last];\n+        let last = self.promoted.basic_blocks().last().unwrap();\n+        let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span: span,\n@@ -268,7 +269,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         if stmt_idx < no_stmts {\n             self.assign(Lvalue::Temp(new_temp), rvalue.unwrap(), source_info.span);\n         } else {\n-            let last = self.promoted.basic_blocks.last().unwrap();\n+            let last = self.promoted.basic_blocks().last().unwrap();\n             let new_target = self.new_block();\n             let mut call = call.unwrap();\n             match call {\n@@ -277,7 +278,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }\n                 _ => bug!()\n             }\n-            let terminator = &mut self.promoted.basic_blocks[last].terminator_mut();\n+            let terminator = self.promoted[last].terminator_mut();\n             terminator.source_info.span = source_info.span;\n             terminator.kind = call;\n         }\n@@ -365,20 +366,20 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n \n         let mut promoter = Promoter {\n             source: mir,\n-            promoted: Mir {\n-                basic_blocks: IndexVec::new(),\n-                visibility_scopes: Some(VisibilityScopeData {\n+            promoted: Mir::new(\n+                IndexVec::new(),\n+                Some(VisibilityScopeData {\n                     span: span,\n                     parent_scope: None\n                 }).into_iter().collect(),\n-                promoted: IndexVec::new(),\n-                return_ty: ty::FnConverging(ty),\n-                var_decls: IndexVec::new(),\n-                arg_decls: IndexVec::new(),\n-                temp_decls: IndexVec::new(),\n-                upvar_decls: vec![],\n-                span: span\n-            },\n+                IndexVec::new(),\n+                ty::FnConverging(ty),\n+                IndexVec::new(),\n+                IndexVec::new(),\n+                IndexVec::new(),\n+                vec![],\n+                span\n+            ),\n             temps: &mut temps,\n             keep_original: false\n         };\n@@ -388,7 +389,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n \n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Temp| temps[index] == TempState::PromotedOut;\n-    for block in &mut mir.basic_blocks {\n+    for block in mir.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n                 StatementKind::Assign(Lvalue::Temp(index), _) => {"}, {"sha": "73ecac553894c1ab0d43ad992cf45aa9a9a9c3e6", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -337,7 +337,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn qualify_const(&mut self) -> Qualif {\n         let mir = self.mir;\n \n-        let mut seen_blocks = BitVector::new(mir.basic_blocks.len());\n+        let mut seen_blocks = BitVector::new(mir.basic_blocks().len());\n         let mut bb = START_BLOCK;\n         loop {\n             seen_blocks.insert(bb.index());\n@@ -367,12 +367,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::Return => {\n                     // Check for unused values. This usually means\n                     // there are extra statements in the AST.\n-                    for (i, _) in mir.temp_decls.iter_enumerated() {\n-                        if self.temp_qualif[i].is_none() {\n+                    for temp in mir.temp_decls.indices() {\n+                        if self.temp_qualif[temp].is_none() {\n                             continue;\n                         }\n \n-                        let state = self.temp_promotion_state[i];\n+                        let state = self.temp_promotion_state[temp];\n                         if let TempState::Defined { location, uses: 0 } = state {\n                             let data = &mir[location.block];\n                             let stmt_idx = location.statement_index;"}, {"sha": "fcc8224995324ce7208874add9edac9ae9f89833", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -60,15 +60,15 @@ impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n         pretty::dump_mir(tcx, \"simplify_cfg\", &format!(\"{}-after\", self.label), src, mir, None);\n \n         // FIXME: Should probably be moved into some kind of pass manager\n-        mir.basic_blocks.raw.shrink_to_fit();\n+        mir.basic_blocks_mut().raw.shrink_to_fit();\n     }\n }\n \n impl<'l> Pass for SimplifyCfg<'l> {}\n \n fn merge_consecutive_blocks(mir: &mut Mir) {\n     // Build the precedecessor map for the MIR\n-    let mut pred_count = IndexVec::from_elem(0u32, &mir.basic_blocks);\n+    let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n     for (_, data) in traversal::preorder(mir) {\n         if let Some(ref term) = data.terminator {\n             for &tgt in term.successors().iter() {\n@@ -79,12 +79,11 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n \n     loop {\n         let mut changed = false;\n-        let mut seen = BitVector::new(mir.basic_blocks.len());\n+        let mut seen = BitVector::new(mir.basic_blocks().len());\n         let mut worklist = vec![START_BLOCK];\n         while let Some(bb) = worklist.pop() {\n             // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n-            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n-                .expect(\"invalid terminator state\");\n+            let mut terminator = mir[bb].terminator.take().expect(\"invalid terminator state\");\n \n             // See if we can merge the target block into this one\n             loop {\n@@ -96,8 +95,8 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n                         break;\n                     }\n \n-                    let num_insts = mir.basic_block_data(target).statements.len();\n-                    match mir.basic_block_data(target).terminator().kind {\n+                    let num_insts = mir[target].statements.len();\n+                    match mir[target].terminator().kind {\n                         TerminatorKind::Goto { target: new_target } if num_insts == 0 => {\n                             inner_change = true;\n                             terminator.kind = TerminatorKind::Goto { target: new_target };\n@@ -108,12 +107,12 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n                             inner_change = true;\n                             let mut stmts = Vec::new();\n                             {\n-                                let target_data = mir.basic_block_data_mut(target);\n+                                let target_data = &mut mir[target];\n                                 mem::swap(&mut stmts, &mut target_data.statements);\n                                 mem::swap(&mut terminator, target_data.terminator_mut());\n                             }\n \n-                            mir.basic_block_data_mut(bb).statements.append(&mut stmts);\n+                            mir[bb].statements.append(&mut stmts);\n                         }\n                         _ => {}\n                     };\n@@ -122,7 +121,7 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n                 for target in terminator.successors_mut() {\n                     let new_target = match final_target(mir, *target) {\n                         Some(new_target) => new_target,\n-                        None if mir.basic_block_data(bb).statements.is_empty() => bb,\n+                        None if mir[bb].statements.is_empty() => bb,\n                         None => continue\n                     };\n                     if *target != new_target {\n@@ -139,9 +138,9 @@ fn merge_consecutive_blocks(mir: &mut Mir) {\n                 }\n             }\n \n-            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n+            mir[bb].terminator = Some(terminator);\n \n-            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n+            for succ in mir[bb].terminator().successors().iter() {\n                 if seen.insert(succ.index()) {\n                     worklist.push(*succ);\n                 }\n@@ -159,11 +158,11 @@ fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n     // Keep track of already seen blocks to detect loops\n     let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n \n-    while mir.basic_block_data(target).statements.is_empty() {\n+    while mir[target].statements.is_empty() {\n         // NB -- terminator may have been swapped with `None` in\n         // merge_consecutive_blocks, in which case we have a cycle and just want\n         // to stop\n-        match mir.basic_block_data(target).terminator {\n+        match mir[target].terminator {\n             Some(Terminator { kind: TerminatorKind::Goto { target: next }, .. }) =>  {\n                 if seen.contains(&next) {\n                     return None;\n@@ -182,8 +181,7 @@ fn simplify_branches(mir: &mut Mir) {\n     loop {\n         let mut changed = false;\n \n-        for bb in mir.all_basic_blocks() {\n-            let basic_block = mir.basic_block_data_mut(bb);\n+        for (_, basic_block) in mir.basic_blocks_mut().iter_enumerated_mut() {\n             let mut terminator = basic_block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::If { ref targets, .. } if targets.0 == targets.1 => {\n@@ -228,28 +226,29 @@ fn simplify_branches(mir: &mut Mir) {\n }\n \n fn remove_dead_blocks(mir: &mut Mir) {\n-    let mut seen = BitVector::new(mir.basic_blocks.len());\n+    let mut seen = BitVector::new(mir.basic_blocks().len());\n     for (bb, _) in traversal::preorder(mir) {\n         seen.insert(bb.index());\n     }\n \n-    let num_blocks = mir.basic_blocks.len();\n+    let basic_blocks = mir.basic_blocks_mut();\n \n+    let num_blocks = basic_blocks.len();\n     let mut replacements : Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n     let mut used_blocks = 0;\n     for alive_index in seen.iter() {\n         replacements[alive_index] = BasicBlock::new(used_blocks);\n         if alive_index != used_blocks {\n             // Swap the next alive block data with the current available slot. Since alive_index is\n             // non-decreasing this is a valid operation.\n-            mir.basic_blocks.raw.swap(alive_index, used_blocks);\n+            basic_blocks.raw.swap(alive_index, used_blocks);\n         }\n         used_blocks += 1;\n     }\n-    mir.basic_blocks.raw.truncate(used_blocks);\n+    basic_blocks.raw.truncate(used_blocks);\n \n-    for bb in mir.all_basic_blocks() {\n-        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n+    for block in basic_blocks {\n+        for target in block.terminator_mut().successors_mut() {\n             *target = replacements[target.index()];\n         }\n     }"}, {"sha": "16ea4780bb3463edf39c08377e0f68722759d546", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -626,7 +626,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         bb: BasicBlock,\n                         iscleanuppad: bool)\n     {\n-        if mir.basic_block_data(bb).is_cleanup != iscleanuppad {\n+        if mir[bb].is_cleanup != iscleanuppad {\n             span_mirbug!(self, ctxt, \"cleanuppad mismatch: {:?} should be {:?}\",\n                          bb, iscleanuppad);\n         }\n@@ -635,7 +635,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n-        for block in &mir.basic_blocks {\n+        for block in mir.basic_blocks() {\n             for stmt in &block.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n                     self.last_span = stmt.source_info.span;"}, {"sha": "df00abf7b1c5fdc042bd356575e3be53c85ff255", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -168,8 +168,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                               mir: &mir::Mir<'tcx>) {\n-        for bb in mir.all_basic_blocks() {\n-            let data = mir.basic_block_data(bb);\n+        for (bb, data) in mir.basic_blocks().iter_enumerated() {\n             match data.terminator().kind {\n                 TerminatorKind::Goto { .. } |\n                 TerminatorKind::Resume |\n@@ -195,7 +194,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n \n     fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                        mir: &mir::Mir<'tcx>) {\n-        let mut funclet_succs = IndexVec::from_elem(None, &mir.basic_blocks);\n+        let mut funclet_succs = IndexVec::from_elem(None, mir.basic_blocks());\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| {\n             match funclet_succs[funclet] {\n@@ -249,7 +248,7 @@ pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n         }\n     }\n \n-    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, &mir.basic_blocks);\n+    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, mir.basic_blocks());\n \n     discover_masters(&mut result, mir);\n     propagate(&mut result, mir);"}, {"sha": "8dabce2ec4eb92f3f1aa97ca1bccff600f12b2ee", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -43,7 +43,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bcx = self.bcx(bb);\n         let mir = self.mir.clone();\n-        let data = mir.basic_block_data(bb);\n+        let data = &mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n@@ -725,7 +725,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     pub fn init_cpad(&mut self, bb: mir::BasicBlock) {\n         let bcx = self.bcx(bb);\n-        let data = self.mir.basic_block_data(bb);\n+        let data = &self.mir[bb];\n         debug!(\"init_cpad({:?})\", data);\n \n         match self.cleanup_kinds[bb] {"}, {"sha": "316c7341ef142a8b958571d5ac899945a38ab924", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let mut failure = Ok(());\n \n         loop {\n-            let data = self.mir.basic_block_data(bb);\n+            let data = &self.mir[bb];\n             for statement in &data.statements {\n                 let span = statement.source_info.span;\n                 match statement.kind {"}, {"sha": "1932a2023fac8cb05f5b078ca88d81b7269ca14b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3af9fa4906594ba22015e549cf8bfc3201dec1b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e3af9fa4906594ba22015e549cf8bfc3201dec1b", "patch": "@@ -155,8 +155,6 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let bcx = fcx.init(false, None).build();\n     let mir = bcx.mir();\n \n-    let mir_blocks = mir.all_basic_blocks();\n-\n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n     let (lvalue_temps, cleanup_kinds) = bcx.with_block(|bcx| {\n@@ -202,15 +200,13 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n-        mir_blocks.iter()\n-                  .map(|&bb| {\n-                      if bb == mir::START_BLOCK {\n-                          fcx.new_block(\"start\", None)\n-                      } else {\n-                          fcx.new_block(&format!(\"{:?}\", bb), None)\n-                      }\n-                  })\n-                  .collect();\n+        mir.basic_blocks().indices().map(|bb| {\n+            if bb == mir::START_BLOCK {\n+                fcx.new_block(\"start\", None)\n+            } else {\n+                fcx.new_block(&format!(\"{:?}\", bb), None)\n+            }\n+        }).collect();\n \n     // Branch to the START block\n     let start_bcx = block_bcxs[mir::START_BLOCK];\n@@ -228,14 +224,14 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         blocks: block_bcxs,\n         unreachable_block: None,\n         cleanup_kinds: cleanup_kinds,\n-        landing_pads: mir_blocks.iter().map(|_| None).collect(),\n+        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n         vars: vars,\n         temps: temps,\n         args: args,\n         scopes: scopes\n     };\n \n-    let mut visited = BitVector::new(mir_blocks.len());\n+    let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     let mut rpo = traversal::reverse_postorder(&mir);\n \n@@ -253,7 +249,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n-    for &bb in &mir_blocks {\n+    for bb in mir.basic_blocks().indices() {\n         let block = mircx.blocks[bb];\n         let block = BasicBlock(block.llbb);\n         // Unreachable block"}]}