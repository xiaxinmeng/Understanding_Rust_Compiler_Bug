{"sha": "663d2f5cd3163f17eddb74ee1e028d542255f21a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2M2QyZjVjZDMxNjNmMTdlZGRiNzRlZTFlMDI4ZDU0MjI1NWYyMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-22T18:46:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-22T18:46:42Z"}, "message": "Auto merge of #75171 - amosonn:new_zeroed_slice, r=Amanieu\n\nNew zeroed slice\n\nAdd to #63291 the methods\n\n```rust\nimpl<T> Box<[T]> { pub fn new_zeroed_slice(len: usize) -> Box<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Rc<[T]> { pub fn new_zeroed_slice(len: usize) -> Rc<[MaybeUninit<T>]> {\u2026} }\nimpl<T> Arc<[T]> { pub fn new_zeroed_slice(len: usize) -> Arc<[MaybeUninit<T>]> {\u2026} }\n```\n\nas suggested in https://github.com/rust-lang/rust/issues/63291#issuecomment-605511675 .\n\nAlso optimize `{Rc, Arc}::new_zeroed` to use `alloc_zeroed`, otherwise they are no more efficient than using `new_uninit` and zeroing the memory manually (which was the original implementation).", "tree": {"sha": "9fa6ffb91539e291d601c8ce585949a3ef830c0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fa6ffb91539e291d601c8ce585949a3ef830c0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/663d2f5cd3163f17eddb74ee1e028d542255f21a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/663d2f5cd3163f17eddb74ee1e028d542255f21a", "html_url": "https://github.com/rust-lang/rust/commit/663d2f5cd3163f17eddb74ee1e028d542255f21a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/663d2f5cd3163f17eddb74ee1e028d542255f21a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5528caf91442729b47b8f818be0a0ddfd0c17ffb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5528caf91442729b47b8f818be0a0ddfd0c17ffb", "html_url": "https://github.com/rust-lang/rust/commit/5528caf91442729b47b8f818be0a0ddfd0c17ffb"}, {"sha": "5aba816672d08a076eaa8005a109968af8ce1083", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aba816672d08a076eaa8005a109968af8ce1083", "html_url": "https://github.com/rust-lang/rust/commit/5aba816672d08a076eaa8005a109968af8ce1083"}], "stats": {"total": 169, "additions": 139, "deletions": 30}, "files": [{"sha": "05211e2037bb78a1f41f373995ebb8ff4f3415ff", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/663d2f5cd3163f17eddb74ee1e028d542255f21a/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663d2f5cd3163f17eddb74ee1e028d542255f21a/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=663d2f5cd3163f17eddb74ee1e028d542255f21a", "patch": "@@ -271,6 +271,29 @@ impl<T> Box<[T]> {\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         unsafe { RawVec::with_capacity(len).into_box(len) }\n     }\n+\n+    /// Constructs a new boxed slice with uninitialized contents, with the memory\n+    /// being filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let values = Box::<[u32]>::new_zeroed_slice(3);\n+    /// let values = unsafe { values.assume_init() };\n+    ///\n+    /// assert_eq!(*values, [0, 0, 0])\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }\n+    }\n }\n \n impl<T> Box<mem::MaybeUninit<T>> {"}, {"sha": "1046397f4be601beda58eb79e2c49605aec492cd", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/663d2f5cd3163f17eddb74ee1e028d542255f21a/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663d2f5cd3163f17eddb74ee1e028d542255f21a/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=663d2f5cd3163f17eddb74ee1e028d542255f21a", "patch": "@@ -247,7 +247,7 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -349,9 +349,11 @@ impl<T> Rc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n-            Rc::from_ptr(Rc::allocate_for_layout(Layout::new::<T>(), |mem| {\n-                mem as *mut RcBox<mem::MaybeUninit<T>>\n-            }))\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -378,9 +380,11 @@ impl<T> Rc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(Rc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n-            uninit\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc_zeroed(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -460,6 +464,40 @@ impl<T> Rc<[T]> {\n     pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n         unsafe { Rc::from_ptr(Rc::allocate_for_slice(len)) }\n     }\n+\n+    /// Constructs a new reference-counted slice with uninitialized contents, with the memory being\n+    /// filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let values = Rc::<[u32]>::new_zeroed_slice(3);\n+    /// let values = unsafe { values.assume_init() };\n+    ///\n+    /// assert_eq!(*values, [0, 0, 0])\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::array::<T>(len).unwrap(),\n+                |layout| Global.alloc_zeroed(layout),\n+                |mem| {\n+                    ptr::slice_from_raw_parts_mut(mem as *mut T, len)\n+                        as *mut RcBox<[mem::MaybeUninit<T>]>\n+                },\n+            ))\n+        }\n+    }\n }\n \n impl<T> Rc<mem::MaybeUninit<T>> {\n@@ -905,6 +943,7 @@ impl<T: ?Sized> Rc<T> {\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocErr>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> *mut RcBox<T> {\n         // Calculate layout using the given value layout.\n@@ -914,7 +953,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());\n@@ -932,9 +971,11 @@ impl<T: ?Sized> Rc<T> {\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         unsafe {\n-            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-                set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::for_value(&*ptr),\n+                |layout| Global.alloc(layout),\n+                |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n+            )\n         }\n     }\n \n@@ -965,9 +1006,11 @@ impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n         unsafe {\n-            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::array::<T>(len).unwrap(),\n+                |layout| Global.alloc(layout),\n+                |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n+            )\n         }\n     }\n }\n@@ -2061,7 +2104,7 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> {}\n \n-/// Get the offset within an `ArcInner` for\n+/// Get the offset within an `RcBox` for\n /// a payload of type described by a pointer.\n ///\n /// # Safety"}, {"sha": "2e5e3b713a14a8efd716fe935d242f48c6b09c1e", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/663d2f5cd3163f17eddb74ee1e028d542255f21a/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/663d2f5cd3163f17eddb74ee1e028d542255f21a/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=663d2f5cd3163f17eddb74ee1e028d542255f21a", "patch": "@@ -21,7 +21,7 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -343,9 +343,11 @@ impl<T> Arc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n-            Arc::from_ptr(Arc::allocate_for_layout(Layout::new::<T>(), |mem| {\n-                mem as *mut ArcInner<mem::MaybeUninit<T>>\n-            }))\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -372,9 +374,11 @@ impl<T> Arc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(Arc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n-            uninit\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc_zeroed(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -426,7 +430,7 @@ impl<T> Arc<T> {\n }\n \n impl<T> Arc<[T]> {\n-    /// Constructs a new reference-counted slice with uninitialized contents.\n+    /// Constructs a new atomically reference-counted slice with uninitialized contents.\n     ///\n     /// # Examples\n     ///\n@@ -453,6 +457,40 @@ impl<T> Arc<[T]> {\n     pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n         unsafe { Arc::from_ptr(Arc::allocate_for_slice(len)) }\n     }\n+\n+    /// Constructs a new atomically reference-counted slice with uninitialized contents, with the memory being\n+    /// filled with `0` bytes.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let values = Arc::<[u32]>::new_zeroed_slice(3);\n+    /// let values = unsafe { values.assume_init() };\n+    ///\n+    /// assert_eq!(*values, [0, 0, 0])\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_zeroed_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::array::<T>(len).unwrap(),\n+                |layout| Global.alloc_zeroed(layout),\n+                |mem| {\n+                    ptr::slice_from_raw_parts_mut(mem as *mut T, len)\n+                        as *mut ArcInner<[mem::MaybeUninit<T>]>\n+                },\n+            ))\n+        }\n+    }\n }\n \n impl<T> Arc<mem::MaybeUninit<T>> {\n@@ -858,6 +896,7 @@ impl<T: ?Sized> Arc<T> {\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocErr>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n         // Calculate layout using the given value layout.\n@@ -866,7 +905,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n@@ -884,9 +923,11 @@ impl<T: ?Sized> Arc<T> {\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         unsafe {\n-            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-                set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::for_value(&*ptr),\n+                |layout| Global.alloc(layout),\n+                |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n+            )\n         }\n     }\n \n@@ -917,9 +958,11 @@ impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n         unsafe {\n-            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::array::<T>(len).unwrap(),\n+                |layout| Global.alloc(layout),\n+                |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n+            )\n         }\n     }\n }"}]}