{"sha": "81bce5290ff55b9a2eddd83d31b0778180904d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYmNlNTI5MGZmNTViOWEyZWRkZDgzZDMxYjA3NzgxODA5MDRkN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-16T20:31:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-16T20:31:15Z"}, "message": "Auto merge of #22230 - nikomatsakis:object-lifetime-defaults-2, r=pnkfelix\n\nImplement rules described in rust-lang/rfcs#599.\r\n\r\nFixes https://github.com/rust-lang/rust/issues/22211.\r\n\r\n~~Based atop PR https://github.com/rust-lang/rust/pull/22182, so the first few commits (up to and including \"Pacify the mercilous nrc\") have already been reviewed.~~", "tree": {"sha": "4084cf72cf82195b29cd94ab65f57769b694d29e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4084cf72cf82195b29cd94ab65f57769b694d29e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81bce5290ff55b9a2eddd83d31b0778180904d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81bce5290ff55b9a2eddd83d31b0778180904d7f", "html_url": "https://github.com/rust-lang/rust/commit/81bce5290ff55b9a2eddd83d31b0778180904d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81bce5290ff55b9a2eddd83d31b0778180904d7f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4e7aa28566d062514a7a1f5534d76b9d82f524a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e7aa28566d062514a7a1f5534d76b9d82f524a", "html_url": "https://github.com/rust-lang/rust/commit/e4e7aa28566d062514a7a1f5534d76b9d82f524a"}, {"sha": "503e15b7c9095e11838c1bbb3f084232950aff18", "url": "https://api.github.com/repos/rust-lang/rust/commits/503e15b7c9095e11838c1bbb3f084232950aff18", "html_url": "https://github.com/rust-lang/rust/commit/503e15b7c9095e11838c1bbb3f084232950aff18"}], "stats": {"total": 1536, "additions": 1264, "deletions": 272}, "files": [{"sha": "94654b849229a3a058b3b42d78b03392e31c7c65", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -824,14 +824,32 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n     assert_eq!(next(st), '|');\n     let bounds = parse_bounds_(st, conv);\n     let default = parse_opt(st, |st| parse_ty_(st, conv));\n+    let object_lifetime_default = parse_object_lifetime_default(st, conv);\n \n     ty::TypeParameterDef {\n         name: name,\n         def_id: def_id,\n         space: space,\n         index: index,\n         bounds: bounds,\n-        default: default\n+        default: default,\n+        object_lifetime_default: object_lifetime_default,\n+    }\n+}\n+\n+fn parse_object_lifetime_default<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n+                                             conv: &mut F)\n+                                             -> Option<ty::ObjectLifetimeDefault>\n+    where F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    match next(st) {\n+        'n' => None,\n+        'a' => Some(ty::ObjectLifetimeDefault::Ambiguous),\n+        's' => {\n+            let region = parse_region_(st, conv);\n+            Some(ty::ObjectLifetimeDefault::Specific(region))\n+        }\n+        _ => panic!(\"parse_object_lifetime_default: bad input\")\n     }\n }\n "}, {"sha": "e1e9d49dd05859d3df5e3ff67b98c2f6d17ef0cf", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -414,6 +414,21 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n              v.space.to_uint(), v.index);\n     enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n+    enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n+}\n+\n+fn enc_object_lifetime_default<'a, 'tcx>(w: &mut SeekableMemWriter,\n+                                         cx: &ctxt<'a, 'tcx>,\n+                                         default: Option<ty::ObjectLifetimeDefault>)\n+{\n+    match default {\n+        None => mywrite!(w, \"n\"),\n+        Some(ty::ObjectLifetimeDefault::Ambiguous) => mywrite!(w, \"a\"),\n+        Some(ty::ObjectLifetimeDefault::Specific(r)) => {\n+            mywrite!(w, \"s\");\n+            enc_region(w, cx, r);\n+        }\n+    }\n }\n \n pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,"}, {"sha": "72b33613c66aab63e81c562e53237821decd3058", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -619,7 +619,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    \"declared lifetime bound not satisfied\");\n+                    \"lifetime bound not satisfied\");\n                 note_and_explain_region(\n                     self.tcx,\n                     \"lifetime parameter instantiated with \",\n@@ -1628,7 +1628,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that the type `{}` \\\n-                             will meet the declared lifetime bounds\",\n+                             will meet its required lifetime bounds\",\n                             self.ty_to_string(t))[]);\n             }\n             infer::RelateDefaultParamBound(span, t) => {"}, {"sha": "107715a8261574858a6233678264466652accab0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -1762,6 +1762,21 @@ impl fmt::Debug for IntVarValue {\n     }\n }\n \n+/// Default region to use for the bound of objects that are\n+/// supplied as the value for this type parameter. This is derived\n+/// from `T:'a` annotations appearing in the type definition.  If\n+/// this is `None`, then the default is inherited from the\n+/// surrounding context. See RFC #599 for details.\n+#[derive(Copy, Clone, Debug)]\n+pub enum ObjectLifetimeDefault {\n+    /// Require an explicit annotation. Occurs when multiple\n+    /// `T:'a` constraints are found.\n+    Ambiguous,\n+\n+    /// Use the given region as the default.\n+    Specific(Region),\n+}\n+\n #[derive(Clone, Debug)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n@@ -1770,6 +1785,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub index: u32,\n     pub bounds: ParamBounds<'tcx>,\n     pub default: Option<Ty<'tcx>>,\n+    pub object_lifetime_default: Option<ObjectLifetimeDefault>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n@@ -5884,42 +5900,13 @@ pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n     return true;\n }\n \n-pub fn object_region_bounds<'tcx>(\n-    tcx: &ctxt<'tcx>,\n-    opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n-    others: BuiltinBounds)\n-    -> Vec<ty::Region>\n-{\n-    // Since we don't actually *know* the self type for an object,\n-    // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, FreshTy(0));\n-\n-    let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n-        // Note that we preserve the overall binding levels here.\n-        assert!(!open_ty.has_escaping_regions());\n-        let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-        vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))))\n-    });\n-\n-    let param_bounds = ty::ParamBounds {\n-        region_bounds: Vec::new(),\n-        builtin_bounds: others,\n-        trait_bounds: opt_trait_ref,\n-        projection_bounds: Vec::new(), // not relevant to computing region bounds\n-    };\n-\n-    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n-    ty::required_region_bounds(tcx, open_ty, predicates)\n-}\n-\n /// Given a set of predicates that apply to an object type, returns\n /// the region bounds that the (erased) `Self` type must\n /// outlive. Precisely *because* the `Self` type is erased, the\n /// parameter `erased_self_ty` must be supplied to indicate what type\n /// has been used to represent `Self` in the predicates\n /// themselves. This should really be a unique type; `FreshTy(0)` is a\n-/// popular choice (see `object_region_bounds` above).\n+/// popular choice.\n ///\n /// Requires that trait definitions have been processed so that we can\n /// elaborate predicates and walk supertraits.\n@@ -7390,3 +7377,12 @@ impl<'a, 'tcx> Repr<'tcx> for ParameterEnvironment<'a, 'tcx> {\n             self.caller_bounds.repr(tcx))\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ObjectLifetimeDefault {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        match *self {\n+            ObjectLifetimeDefault::Ambiguous => format!(\"Ambiguous\"),\n+            ObjectLifetimeDefault::Specific(ref r) => r.repr(tcx),\n+        }\n+    }\n+}"}, {"sha": "5e46ce08e4f7605b57fd458e383a85ad4241342e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -379,6 +379,19 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             index: self.index,\n             bounds: self.bounds.fold_with(folder),\n             default: self.default.fold_with(folder),\n+            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ObjectLifetimeDefault {\n+        match *self {\n+            ty::ObjectLifetimeDefault::Ambiguous =>\n+                ty::ObjectLifetimeDefault::Ambiguous,\n+\n+            ty::ObjectLifetimeDefault::Specific(r) =>\n+                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n         }\n     }\n }"}, {"sha": "0183b3474a509c8b41266d7123dcba67c8c51401", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 219, "deletions": 125, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -55,8 +55,8 @@ use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n-use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n-             ShiftedRscope, BindingRscope};\n+use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n+             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::DefIdMap;\n@@ -264,34 +264,31 @@ pub fn ast_path_substs_for_ty<'tcx>(\n \n     let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n-            convert_angle_bracketed_parameters(this, rscope, data)\n+            convert_angle_bracketed_parameters(this, rscope, path.span, decl_generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n-            convert_parenthesized_parameters(this, data)\n+            convert_parenthesized_parameters(this, rscope, path.span, decl_generics, data)\n         }\n     };\n \n     prohibit_projections(this.tcx(), &assoc_bindings);\n \n     create_substs_for_ast_path(this,\n-                               rscope,\n                                path.span,\n                                decl_generics,\n                                None,\n                                types,\n                                regions)\n }\n \n-fn create_substs_for_ast_path<'tcx>(\n+fn create_region_substs<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     decl_generics: &ty::Generics<'tcx>,\n-    self_ty: Option<Ty<'tcx>>,\n-    types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>)\n+    regions_provided: Vec<ty::Region>)\n     -> Substs<'tcx>\n {\n     let tcx = this.tcx();\n@@ -300,9 +297,9 @@ fn create_substs_for_ast_path<'tcx>(\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n-    let supplied_num_region_params = regions.len();\n+    let supplied_num_region_params = regions_provided.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        regions\n+        regions_provided\n     } else {\n         let anon_regions =\n             rscope.anon_regions(span, expected_num_region_params);\n@@ -314,51 +311,82 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n \n         match anon_regions {\n-            Ok(v) => v.into_iter().collect(),\n-            Err(_) => (0..expected_num_region_params)\n-                          .map(|_| ty::ReStatic).collect() // hokey\n+            Ok(anon_regions) => anon_regions,\n+            Err(_) => (0..expected_num_region_params).map(|_| ty::ReStatic).collect()\n         }\n     };\n+    Substs::new_type(vec![], regions)\n+}\n+\n+/// Given the type/region arguments provided to some path (along with\n+/// an implicit Self, if this is a trait reference) returns the complete\n+/// set of substitutions. This may involve applying defaulted type parameters.\n+///\n+/// Note that the type listing given here is *exactly* what the user provided.\n+///\n+/// The `region_substs` should be the result of `create_region_substs`\n+/// -- that is, a substitution with no types but the correct number of\n+/// regions.\n+fn create_substs_for_ast_path<'tcx>(\n+    this: &AstConv<'tcx>,\n+    span: Span,\n+    decl_generics: &ty::Generics<'tcx>,\n+    self_ty: Option<Ty<'tcx>>,\n+    types_provided: Vec<Ty<'tcx>>,\n+    region_substs: Substs<'tcx>)\n+    -> Substs<'tcx>\n+{\n+    let tcx = this.tcx();\n+\n+    debug!(\"create_substs_for_ast_path(decl_generics={}, self_ty={}, \\\n+           types_provided={}, region_substs={}\",\n+           decl_generics.repr(tcx), self_ty.repr(tcx), types_provided.repr(tcx),\n+           region_substs.repr(tcx));\n+\n+    assert_eq!(region_substs.regions().len(TypeSpace), decl_generics.regions.len(TypeSpace));\n+    assert!(region_substs.types.is_empty());\n \n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-    let supplied_ty_param_count = types.len();\n-    let formal_ty_param_count =\n-        ty_param_defs.iter()\n-        .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n-        .count();\n-    let required_ty_param_count =\n-        ty_param_defs.iter()\n-        .take_while(|x| {\n-            x.default.is_none() &&\n-                !ty::is_associated_type(tcx, x.def_id)\n-        })\n-        .count();\n+    let supplied_ty_param_count = types_provided.len();\n+    let formal_ty_param_count = ty_param_defs.len();\n+    let required_ty_param_count = ty_param_defs.iter()\n+                                               .take_while(|x| x.default.is_none())\n+                                               .count();\n+\n+    let mut type_substs = types_provided;\n     if supplied_ty_param_count < required_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at least\"\n         } else {\n             \"expected\"\n         };\n-        span_fatal!(this.tcx().sess, span, E0243,\n-                                   \"wrong number of type arguments: {} {}, found {}\",\n-                                           expected,\n-                                           required_ty_param_count,\n-                                           supplied_ty_param_count);\n+        span_err!(this.tcx().sess, span, E0243,\n+                  \"wrong number of type arguments: {} {}, found {}\",\n+                  expected,\n+                  required_ty_param_count,\n+                  supplied_ty_param_count);\n+        while type_substs.len() < required_ty_param_count {\n+            type_substs.push(tcx.types.err);\n+        }\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n-        span_fatal!(this.tcx().sess, span, E0244,\n-                                   \"wrong number of type arguments: {} {}, found {}\",\n-                                           expected,\n-                                           formal_ty_param_count,\n-                                           supplied_ty_param_count);\n+        span_err!(this.tcx().sess, span, E0244,\n+                  \"wrong number of type arguments: {} {}, found {}\",\n+                  expected,\n+                  formal_ty_param_count,\n+                  supplied_ty_param_count);\n+        type_substs.truncate(formal_ty_param_count);\n     }\n+    assert!(type_substs.len() >= required_ty_param_count &&\n+            type_substs.len() <= formal_ty_param_count);\n \n-    let mut substs = Substs::new_type(types, regions);\n+    let mut substs = region_substs;\n+    substs.types.extend(TypeSpace, type_substs.into_iter());\n \n     match self_ty {\n         None => {\n@@ -374,7 +402,8 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    for param in &ty_param_defs[supplied_ty_param_count..] {\n+    let actual_supplied_ty_param_count = substs.types.len(TypeSpace);\n+    for param in &ty_param_defs[actual_supplied_ty_param_count..] {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter.\n@@ -400,29 +429,36 @@ struct ConvertedBinding<'tcx> {\n \n fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n                                             rscope: &RegionScope,\n+                                            span: Span,\n+                                            decl_generics: &ty::Generics<'tcx>,\n                                             data: &ast::AngleBracketedParameterData)\n-                                            -> (Vec<ty::Region>,\n+                                            -> (Substs<'tcx>,\n                                                 Vec<Ty<'tcx>>,\n                                                 Vec<ConvertedBinding<'tcx>>)\n {\n     let regions: Vec<_> =\n         data.lifetimes.iter()\n-        .map(|l| ast_region_to_region(this.tcx(), l))\n-        .collect();\n+                      .map(|l| ast_region_to_region(this.tcx(), l))\n+                      .collect();\n+\n+    let region_substs =\n+        create_region_substs(this, rscope, span, decl_generics, regions);\n \n     let types: Vec<_> =\n         data.types.iter()\n-        .map(|t| ast_ty_to_ty(this, rscope, &**t))\n-        .collect();\n+                  .enumerate()\n+                  .map(|(i,t)| ast_ty_arg_to_ty(this, rscope, decl_generics,\n+                                                i, &region_substs, t))\n+                  .collect();\n \n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n-        .map(|b| ConvertedBinding { item_name: b.ident.name,\n-                                    ty: ast_ty_to_ty(this, rscope, &*b.ty),\n-                                    span: b.span })\n-        .collect();\n+                     .map(|b| ConvertedBinding { item_name: b.ident.name,\n+                                                 ty: ast_ty_to_ty(this, rscope, &*b.ty),\n+                                                 span: b.span })\n+                     .collect();\n \n-    (regions, types, assoc_bindings)\n+    (region_substs, types, assoc_bindings)\n }\n \n /// Returns the appropriate lifetime to use for any output lifetimes\n@@ -465,7 +501,7 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n {\n     match implied_output_region {\n         Some(implied_output_region) => {\n-            let rb = SpecificRscope::new(implied_output_region);\n+            let rb = ElidableRscope::new(implied_output_region);\n             ast_ty_to_ty(this, &rb, ty)\n         }\n         None => {\n@@ -479,15 +515,23 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n }\n \n fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n+                                          rscope: &RegionScope,\n+                                          span: Span,\n+                                          decl_generics: &ty::Generics<'tcx>,\n                                           data: &ast::ParenthesizedParameterData)\n-                                          -> (Vec<ty::Region>,\n+                                          -> (Substs<'tcx>,\n                                               Vec<Ty<'tcx>>,\n                                               Vec<ConvertedBinding<'tcx>>)\n {\n+    let region_substs =\n+        create_region_substs(this, rscope, span, decl_generics, Vec::new());\n+\n     let binding_rscope = BindingRscope::new();\n-    let inputs = data.inputs.iter()\n-                            .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n-                            .collect::<Vec<Ty<'tcx>>>();\n+    let inputs =\n+        data.inputs.iter()\n+                   .map(|a_t| ast_ty_arg_to_ty(this, &binding_rscope, decl_generics,\n+                                               0, &region_substs, a_t))\n+                   .collect::<Vec<Ty<'tcx>>>();\n \n     let input_params: Vec<_> = repeat(String::new()).take(inputs.len()).collect();\n     let (implied_output_region,\n@@ -514,7 +558,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n         span: output_span\n     };\n \n-    (vec![], vec![input_ty], vec![output_binding])\n+    (region_substs, vec![input_ty], vec![output_binding])\n }\n \n pub fn instantiate_poly_trait_ref<'tcx>(\n@@ -615,7 +659,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n \n     let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n-            // For now, require that parenthetical5D notation be used\n+            // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n             if !this.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n                 span_err!(this.tcx().sess, path.span, E0215,\n@@ -626,7 +670,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            convert_angle_bracketed_parameters(this, rscope, data)\n+            convert_angle_bracketed_parameters(this, rscope, path.span, &trait_def.generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n@@ -640,12 +684,11 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            convert_parenthesized_parameters(this, data)\n+            convert_parenthesized_parameters(this, rscope, path.span, &trait_def.generics, data)\n         }\n     };\n \n     let substs = create_substs_for_ast_path(this,\n-                                            rscope,\n                                             path.span,\n                                             &trait_def.generics,\n                                             self_ty,\n@@ -932,7 +975,7 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      span,\n-                                                     Some(trait_ref.clone()),\n+                                                     trait_ref.clone(),\n                                                      projection_bounds,\n                                                      bounds);\n \n@@ -1031,10 +1074,45 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                              qpath.item_path.identifier.name);\n }\n \n-// Parses the programmer's textual representation of a type into our\n-// internal notion of a type.\n-pub fn ast_ty_to_ty<'tcx>(\n-        this: &AstConv<'tcx>, rscope: &RegionScope, ast_ty: &ast::Ty) -> Ty<'tcx>\n+/// Convert a type supplied as value for a type argument from AST into our\n+/// our internal representation. This is the same as `ast_ty_to_ty` but that\n+/// it applies the object lifetime default.\n+///\n+/// # Parameters\n+///\n+/// * `this`, `rscope`: the surrounding context\n+/// * `decl_generics`: the generics of the struct/enum/trait declaration being\n+///   referenced\n+/// * `index`: the index of the type parameter being instantiated from the list\n+///   (we assume it is in the `TypeSpace`)\n+/// * `region_substs`: a partial substitution consisting of\n+///   only the region type parameters being supplied to this type.\n+/// * `ast_ty`: the ast representation of the type being supplied\n+pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                              rscope: &RegionScope,\n+                              decl_generics: &ty::Generics<'tcx>,\n+                              index: usize,\n+                              region_substs: &Substs<'tcx>,\n+                              ast_ty: &ast::Ty)\n+                              -> Ty<'tcx>\n+{\n+    let tcx = this.tcx();\n+\n+    if let Some(def) = decl_generics.types.opt_get(TypeSpace, index) {\n+        let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n+        let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n+        ast_ty_to_ty(this, rscope1, ast_ty)\n+    } else {\n+        ast_ty_to_ty(this, rscope, ast_ty)\n+    }\n+}\n+\n+/// Parses the programmer's textual representation of a type into our\n+/// internal notion of a type.\n+pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                          rscope: &RegionScope,\n+                          ast_ty: &ast::Ty)\n+                          -> Ty<'tcx>\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -1084,7 +1162,11 @@ pub fn ast_ty_to_ty<'tcx>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                let t = ast_ty_to_ty(this, rscope, &*mt.ty);\n+                let rscope1 =\n+                    &ObjectLifetimeDefaultRscope::new(\n+                        rscope,\n+                        Some(ty::ObjectLifetimeDefault::Specific(r)));\n+                let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n                 ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n             }\n             ast::TyTup(ref fields) => {\n@@ -1518,11 +1600,11 @@ pub fn ty_of_closure<'tcx>(\n /// `ExistentialBounds` struct. The `main_trait_refs` argument specifies the `Foo` -- it is absent\n /// for closures. Eventually this should all be normalized, I think, so that there is no \"main\n /// trait ref\" and instead we just have a flat list of bounds as the existential type.\n-pub fn conv_existential_bounds<'tcx>(\n+fn conv_existential_bounds<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n-    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: ty::PolyTraitRef<'tcx>,\n     projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds<'tcx>\n@@ -1546,15 +1628,15 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n         let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n-        Some(instantiate_poly_trait_ref(this,\n-                                        rscope,\n-                                        trait_bound,\n-                                        None,\n-                                        &mut projection_bounds))\n+        instantiate_poly_trait_ref(this,\n+                                   rscope,\n+                                   trait_bound,\n+                                   None,\n+                                   &mut projection_bounds)\n     } else {\n         span_err!(this.tcx().sess, span, E0224,\n-            \"at least one non-builtin trait is required for an object type\");\n-        None\n+                  \"at least one non-builtin trait is required for an object type\");\n+        return this.tcx().types.err;\n     };\n \n     let bounds =\n@@ -1565,17 +1647,14 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                                         projection_bounds,\n                                                         partitioned_bounds);\n \n-    match main_trait_bound {\n-        None => this.tcx().types.err,\n-        Some(principal) => ty::mk_trait(this.tcx(), principal, bounds)\n-    }\n+    ty::mk_trait(this.tcx(), main_trait_bound, bounds)\n }\n \n pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n-    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: ty::PolyTraitRef<'tcx>,\n     mut projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds<'tcx>\n@@ -1588,16 +1667,15 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n         span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n-            \"only the builtin traits can be used \\\n-                     as closure or object bounds\");\n+                  \"only the builtin traits can be used as closure or object bounds\");\n     }\n \n-    let region_bound = compute_region_bound(this,\n-                                            rscope,\n-                                            span,\n-                                            &region_bounds,\n-                                            principal_trait_ref,\n-                                            builtin_bounds);\n+    let region_bound = compute_object_lifetime_bound(this,\n+                                                     rscope,\n+                                                     span,\n+                                                     &region_bounds,\n+                                                     principal_trait_ref,\n+                                                     builtin_bounds);\n \n     ty::sort_bounds_list(&mut projection_bounds);\n \n@@ -1608,17 +1686,21 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n     }\n }\n \n-/// Given the bounds on a type parameter / existential type, determines what single region bound\n+/// Given the bounds on an object, determines what single region bound\n /// (if any) we can use to summarize this type. The basic idea is that we will use the bound the\n /// user provided, if they provided one, and otherwise search the supertypes of trait bounds for\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n-fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  span: Span,\n-                                  explicit_region_bounds: &[&ast::Lifetime],\n-                                  principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n-                                  builtin_bounds: ty::BuiltinBounds)\n-                                  -> Option<ty::Region>\n+fn compute_object_lifetime_bound<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n+    span: Span,\n+    explicit_region_bounds: &[&ast::Lifetime],\n+    principal_trait_ref: ty::PolyTraitRef<'tcx>,\n+    builtin_bounds: ty::BuiltinBounds)\n+    -> ty::Region\n {\n+    let tcx = this.tcx();\n+\n     debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n            principal_trait_ref={}, builtin_bounds={})\",\n            explicit_region_bounds,\n@@ -1633,24 +1715,32 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if explicit_region_bounds.len() != 0 {\n         // Explicitly specified region bound. Use that.\n         let r = explicit_region_bounds[0];\n-        return Some(ast_region_to_region(tcx, r));\n+        return ast_region_to_region(tcx, r);\n     }\n \n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n-        ty::object_region_bounds(tcx, principal_trait_ref.as_ref(), builtin_bounds);\n+        object_region_bounds(tcx, &principal_trait_ref, builtin_bounds);\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n     if derived_region_bounds.len() == 0 {\n-        return None;\n+        match rscope.object_lifetime_default(span) {\n+            Some(r) => { return r; }\n+            None => {\n+                span_err!(this.tcx().sess, span, E0228,\n+                          \"the lifetime bound for this object type cannot be deduced \\\n+                           from context; please supply an explicit bound\");\n+                return ty::ReStatic;\n+            }\n+        }\n     }\n \n     // If any of the derived region bounds are 'static, that is always\n     // the best choice.\n     if derived_region_bounds.iter().any(|r| ty::ReStatic == *r) {\n-        return Some(ty::ReStatic);\n+        return ty::ReStatic;\n     }\n \n     // Determine whether there is exactly one unique region in the set\n@@ -1659,38 +1749,42 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let r = derived_region_bounds[0];\n     if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n         span_err!(tcx.sess, span, E0227,\n-            \"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\");\n+                  \"ambiguous lifetime bound, explicit lifetime bound required\");\n     }\n-    return Some(r);\n+    return r;\n }\n \n-/// A version of `compute_opt_region_bound` for use where some region bound is required\n-/// (existential types, basically). Reports an error if no region bound can be derived and we are\n-/// in an `rscope` that does not provide a default.\n-fn compute_region_bound<'tcx>(\n-    this: &AstConv<'tcx>,\n-    rscope: &RegionScope,\n-    span: Span,\n-    region_bounds: &[&ast::Lifetime],\n-    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for closures\n-    builtin_bounds: ty::BuiltinBounds)\n-    -> ty::Region\n+/// Given an object type like `SomeTrait+Send`, computes the lifetime\n+/// bounds that must hold on the elided self type. These are derived\n+/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n+/// they declare `trait SomeTrait : 'static`, for example, then\n+/// `'static` would appear in the list. The hard work is done by\n+/// `ty::required_region_bounds`, see that for more information.\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    principal: &ty::PolyTraitRef<'tcx>,\n+    others: ty::BuiltinBounds)\n+    -> Vec<ty::Region>\n {\n-    match compute_opt_region_bound(this.tcx(), span, region_bounds,\n-                                   principal_trait_ref, builtin_bounds) {\n-        Some(r) => r,\n-        None => {\n-            match rscope.default_region_bound(span) {\n-                Some(r) => { r }\n-                None => {\n-                    span_err!(this.tcx().sess, span, E0228,\n-                        \"explicit lifetime bound required\");\n-                    ty::ReStatic\n-                }\n-            }\n-        }\n-    }\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+\n+    // Note that we preserve the overall binding levels here.\n+    assert!(!open_ty.has_escaping_regions());\n+    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+    let trait_refs = vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))));\n+\n+    let param_bounds = ty::ParamBounds {\n+        region_bounds: Vec::new(),\n+        builtin_bounds: others,\n+        trait_bounds: trait_refs,\n+        projection_bounds: Vec::new(), // not relevant to computing region bounds\n+    };\n+\n+    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n+    ty::required_region_bounds(tcx, open_ty, predicates)\n }\n \n pub struct PartitionedBounds<'a> {"}, {"sha": "30896c1607a88140be22fdfafda6d698051fe42e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -1890,7 +1890,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        // RFC #599 specifies that object lifetime defaults take\n+        // precedence over other defaults. But within a fn body we\n+        // don't have a *default* region, rather we use inference to\n+        // find the *correct* region, which is strictly more general\n+        // (and anyway, within a fn body the right region may not even\n+        // be something the user can write explicitly, since it might\n+        // be some expression).\n         Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n "}, {"sha": "17c259e674e9f08f2ea38ea710ed65dba1e69f62", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -154,7 +154,7 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // empty region is a subregion of all others, this can't fail\n         // unless the type does not meet the well-formedness\n         // requirements.\n-        type_must_outlive(&mut rcx, infer::RelateRegionParamBound(span),\n+        type_must_outlive(&mut rcx, infer::RelateParamBound(span, component_ty),\n                           component_ty, ty::ReEmpty);\n     }\n }\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = infer::RelateRegionParamBound(r_o.cause.span);\n+            let origin = infer::RelateParamBound(r_o.cause.span, sup_type);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n "}, {"sha": "209570585d29dd87d902ef621fc239821133b515", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -12,6 +12,7 @@\n \n pub use self::WfConstraint::*;\n \n+use astconv::object_region_bounds;\n use middle::infer::GenericKind;\n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty::{self, Ty};\n@@ -95,7 +96,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_trait(ref t) => {\n                 let required_region_bounds =\n-                    ty::object_region_bounds(self.tcx, Some(&t.principal), t.bounds.builtin_bounds);\n+                    object_region_bounds(self.tcx, &t.principal, t.bounds.builtin_bounds);\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n "}, {"sha": "f26041dbbe1eb04dea4e769a185bd23e74127423", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 124, "deletions": 5, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -86,6 +86,7 @@ There are some shortcomings in this design:\n */\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n+use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -1199,8 +1200,23 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                                              predicates.clone());\n     assert!(prev_predicates.is_none());\n \n-    return (scheme, predicates);\n+    // Debugging aid.\n+    if ty::has_attr(tcx, local_def(it.id), \"rustc_object_lifetime_default\") {\n+        let object_lifetime_default_reprs: String =\n+            scheme.generics.types.iter()\n+                                 .map(|t| match t.object_lifetime_default {\n+                                     Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n+                                         r.user_string(tcx),\n+                                     d =>\n+                                         d.repr(ccx.tcx()),\n+                                 })\n+                                 .collect::<Vec<String>>()\n+                                 .connect(\",\");\n+\n+        tcx.sess.span_err(it.span, &object_lifetime_default_reprs);\n+    }\n \n+    return (scheme, predicates);\n }\n \n fn type_scheme_of_foreign_item<'a, 'tcx>(\n@@ -1269,6 +1285,7 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                 subst::TypeSpace,\n                 &generics.lifetimes[],\n                 &generics.ty_params[],\n+                &generics.where_clause,\n                 ty::Generics::empty())\n }\n \n@@ -1298,6 +1315,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                     subst::TypeSpace,\n                     &ast_generics.lifetimes[],\n                     &ast_generics.ty_params[],\n+                    &ast_generics.where_clause,\n                     ty::Generics::empty());\n \n     // Add in the self type parameter.\n@@ -1321,7 +1339,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             trait_bounds: vec!(ty::Binder(self_trait_ref.clone())),\n             projection_bounds: vec!(),\n         },\n-        default: None\n+        default: None,\n+        object_lifetime_default: None,\n     };\n \n     ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n@@ -1341,6 +1360,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 subst::FnSpace,\n                 &early_lifetimes[],\n                 &generics.ty_params[],\n+                &generics.where_clause,\n                 base_generics)\n }\n \n@@ -1487,6 +1507,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n+                        where_clause: &ast::WhereClause,\n                         base_generics: ty::Generics<'tcx>)\n                         -> ty::Generics<'tcx>\n {\n@@ -1511,7 +1532,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n \n     // Now create the real type parameters.\n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx, space, param, i as u32);\n+        let def = get_or_create_type_parameter_def(ccx, space, param, i as u32, where_clause);\n         debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n         result.types.push(space, def);\n     }\n@@ -1522,7 +1543,8 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n-                                             index: u32)\n+                                             index: u32,\n+                                             where_clause: &ast::WhereClause)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n     let tcx = ccx.tcx;\n@@ -1558,20 +1580,117 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n         }\n     };\n \n+    let object_lifetime_default =\n+        compute_object_lifetime_default(ccx, space, index, &param.bounds, where_clause);\n+\n     let def = ty::TypeParameterDef {\n         space: space,\n         index: index,\n         name: param.ident.name,\n         def_id: local_def(param.id),\n         bounds: bounds,\n-        default: default\n+        default: default,\n+        object_lifetime_default: object_lifetime_default,\n     };\n \n     tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n     def\n }\n \n+/// Scan the bounds and where-clauses on a parameter to extract bounds\n+/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`.\n+/// This runs as part of computing the minimal type scheme, so we\n+/// intentionally avoid just asking astconv to convert all the where\n+/// clauses into a `ty::Predicate`. This is because that could induce\n+/// artificial cycles.\n+fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                            space: subst::ParamSpace,\n+                                            index: u32,\n+                                            param_bounds: &[ast::TyParamBound],\n+                                            where_clause: &ast::WhereClause)\n+                                            -> Option<ty::ObjectLifetimeDefault>\n+{\n+    let inline_bounds = from_bounds(ccx, param_bounds);\n+    let where_bounds = from_predicates(ccx, space, index, &where_clause.predicates);\n+    let all_bounds: HashSet<_> = inline_bounds.into_iter()\n+                                              .chain(where_bounds.into_iter())\n+                                              .collect();\n+    return if all_bounds.len() > 1 {\n+        Some(ty::ObjectLifetimeDefault::Ambiguous)\n+    } else {\n+        all_bounds.into_iter()\n+                  .next()\n+                  .map(ty::ObjectLifetimeDefault::Specific)\n+    };\n+\n+    fn from_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                            bounds: &[ast::TyParamBound])\n+                            -> Vec<ty::Region>\n+    {\n+        bounds.iter()\n+              .filter_map(|bound| {\n+                  match *bound {\n+                      ast::TraitTyParamBound(..) =>\n+                          None,\n+                      ast::RegionTyParamBound(ref lifetime) =>\n+                          Some(astconv::ast_region_to_region(ccx.tcx(), lifetime)),\n+                  }\n+              })\n+              .collect()\n+    }\n+\n+    fn from_predicates<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                space: subst::ParamSpace,\n+                                index: u32,\n+                                predicates: &[ast::WherePredicate])\n+                                -> Vec<ty::Region>\n+    {\n+        predicates.iter()\n+                  .flat_map(|predicate| {\n+                      match *predicate {\n+                          ast::WherePredicate::BoundPredicate(ref data) => {\n+                              if data.bound_lifetimes.len() == 0 &&\n+                                  is_param(ccx, &data.bounded_ty, space, index)\n+                              {\n+                                  from_bounds(ccx, &data.bounds).into_iter()\n+                              } else {\n+                                  Vec::new().into_iter()\n+                              }\n+                          }\n+                          ast::WherePredicate::RegionPredicate(..) |\n+                          ast::WherePredicate::EqPredicate(..) => {\n+                              Vec::new().into_iter()\n+                          }\n+                      }\n+                  })\n+                  .collect()\n+    }\n+\n+    fn is_param(ccx: &CollectCtxt,\n+                ast_ty: &ast::Ty,\n+                space: subst::ParamSpace,\n+                index: u32)\n+                -> bool\n+    {\n+        match ast_ty.node {\n+            ast::TyPath(_, id) => {\n+                match ccx.tcx.def_map.borrow()[id] {\n+                    def::DefTyParam(s, i, _, _) => {\n+                        space == s && index == i\n+                    }\n+                    _ => {\n+                        false\n+                    }\n+                }\n+            }\n+            _ => {\n+                false\n+            }\n+        }\n+    }\n+}\n+\n enum SizedByDefault { Yes, No }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or"}, {"sha": "b591209a6383a8685ff78d550650c43c1cf55001", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 66, "deletions": 22, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -32,7 +32,10 @@ pub trait RegionScope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>;\n \n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region>;\n+    /// If an object omits any explicit lifetime bound, and none can\n+    /// be derived from the object traits, what should we use? If\n+    /// `None` is returned, an explicit annotation is required.\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;\n }\n \n // A scope in which all regions must be explicitly named. This is used\n@@ -41,8 +44,8 @@ pub trait RegionScope {\n pub struct ExplicitRscope;\n \n impl RegionScope for ExplicitRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n-        None\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n+        Some(ty::ReStatic)\n     }\n \n     fn anon_regions(&self,\n@@ -63,8 +66,8 @@ impl UnelidableRscope {\n }\n \n impl RegionScope for UnelidableRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n-        None\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n+        Some(ty::ReStatic)\n     }\n \n     fn anon_regions(&self,\n@@ -76,22 +79,26 @@ impl RegionScope for UnelidableRscope {\n     }\n }\n \n-// A scope in which any omitted region defaults to `default`. This is\n-// used after the `->` in function signatures, but also for backwards\n-// compatibility with object types. The latter use may go away.\n-pub struct SpecificRscope {\n-    default: ty::Region\n+// A scope in which omitted anonymous region defaults to\n+// `default`. This is used after the `->` in function signatures. The\n+// latter use may go away. Note that object-lifetime defaults work a\n+// bit differently, as specified in RFC #599.\n+pub struct ElidableRscope {\n+    default: ty::Region,\n }\n \n-impl SpecificRscope {\n-    pub fn new(r: ty::Region) -> SpecificRscope {\n-        SpecificRscope { default: r }\n+impl ElidableRscope {\n+    pub fn new(r: ty::Region) -> ElidableRscope {\n+        ElidableRscope { default: r }\n     }\n }\n \n-impl RegionScope for SpecificRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n-        Some(self.default)\n+impl RegionScope for ElidableRscope {\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n+        // Per RFC #599, object-lifetimes default to 'static unless\n+        // overridden by context, and this takes precedence over\n+        // lifetime elision.\n+        Some(ty::ReStatic)\n     }\n \n     fn anon_regions(&self,\n@@ -124,9 +131,11 @@ impl BindingRscope {\n }\n \n impl RegionScope for BindingRscope {\n-    fn default_region_bound(&self, _span: Span) -> Option<ty::Region>\n-    {\n-        Some(self.next_region())\n+    fn object_lifetime_default(&self, _span: Span) -> Option<ty::Region> {\n+        // Per RFC #599, object-lifetimes default to 'static unless\n+        // overridden by context, and this takes precedence over the\n+        // binding defaults.\n+        Some(ty::ReStatic)\n     }\n \n     fn anon_regions(&self,\n@@ -138,6 +147,42 @@ impl RegionScope for BindingRscope {\n     }\n }\n \n+/// A scope which overrides the default object lifetime but has no other effect.\n+pub struct ObjectLifetimeDefaultRscope<'r> {\n+    base_scope: &'r (RegionScope+'r),\n+    default: Option<ty::ObjectLifetimeDefault>,\n+}\n+\n+impl<'r> ObjectLifetimeDefaultRscope<'r> {\n+    pub fn new(base_scope: &'r (RegionScope+'r),\n+               default: Option<ty::ObjectLifetimeDefault>)\n+               -> ObjectLifetimeDefaultRscope<'r>\n+    {\n+        ObjectLifetimeDefaultRscope {\n+            base_scope: base_scope,\n+            default: default,\n+        }\n+    }\n+}\n+\n+impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        match self.default {\n+            None => self.base_scope.object_lifetime_default(span),\n+            Some(ty::ObjectLifetimeDefault::Ambiguous) => None,\n+            Some(ty::ObjectLifetimeDefault::Specific(r)) => Some(r),\n+        }\n+    }\n+\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+    {\n+        self.base_scope.anon_regions(span, count)\n+    }\n+}\n+\n /// A scope which simply shifts the Debruijn index of other scopes\n /// to account for binding levels.\n pub struct ShiftedRscope<'r> {\n@@ -151,9 +196,8 @@ impl<'r> ShiftedRscope<'r> {\n }\n \n impl<'r> RegionScope for ShiftedRscope<'r> {\n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region>\n-    {\n-        self.base_scope.default_region_bound(span)\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        self.base_scope.object_lifetime_default(span)\n             .map(|r| ty_fold::shift_region(r, 1))\n     }\n "}, {"sha": "083039995ee955ce5366292ceff367578e6b0a6e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -35,18 +35,18 @@ pub trait ItemDecorator {\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &ast::Item,\n-              push: Box<FnMut(P<ast::Item>)>);\n+              push: &mut FnMut(P<ast::Item>));\n }\n \n impl<F> ItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, Box<FnMut(P<ast::Item>)>)\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, &mut FnMut(P<ast::Item>))\n {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &ast::Item,\n-              push: Box<FnMut(P<ast::Item>)>) {\n+              push: &mut FnMut(P<ast::Item>)) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n }"}, {"sha": "0ed9e85e57677a19f52fbf890d003032e078a41c", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -72,15 +72,15 @@ pub fn expand_deprecated_deriving(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   _: &MetaItem,\n                                   _: &Item,\n-                                  _: Box<FnMut(P<Item>)>) {\n+                                  _: &mut FnMut(P<Item>)) {\n     cx.span_err(span, \"`deriving` has been renamed to `derive`\");\n }\n \n pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                           _span: Span,\n                           mitem: &MetaItem,\n                           item: &Item,\n-                          mut push: Box<FnMut(P<Item>)>) {\n+                          push: &mut FnMut(P<Item>)) {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `derive`\");"}, {"sha": "fd98f42c2ab03c0693c21e2f75b74980fdf4f7ec", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -363,7 +363,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                              mark_thunk: G,\n                              fld: &mut MacroExpander)\n                              -> Option<T> where\n-    F: FnOnce(Box<MacResult>) -> Option<T>,\n+    F: for<'a> FnOnce(Box<MacResult+'a>) -> Option<T>,\n     G: FnOnce(T, Mrk) -> T,\n {\n     match mac.node {\n@@ -1102,9 +1102,10 @@ fn expand_annotatable(a: Annotatable,\n                     // but that double-mut-borrows fld\n                     let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n                     dec.expand(fld.cx, attr.span, &*attr.node.value, &**it,\n-                               box |item| items.push(item));\n-                    decorator_items.extend(items.into_iter()\n-                        .flat_map(|item| expand_item(item, fld).into_iter()));\n+                               &mut |item| items.push(item));\n+                    decorator_items.extend(\n+                        items.into_iter()\n+                             .flat_map(|item| expand_item(item, fld).into_iter()));\n \n                     fld.cx.bt_pop();\n                 }"}, {"sha": "c7b75ade5558440ded259a53aaaf115b984904b5", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -14,6 +14,6 @@\n trait Foo : Send { }\n \n impl <'a> Foo for &'a mut () { }\n-//~^ ERROR declared lifetime bound not satisfied\n+//~^ ERROR the type `&'a mut ()` does not fulfill the required lifetime\n \n fn main() { }"}, {"sha": "09d7293a3d0c020202b99da5a11299e531d68e74", "filename": "src/test/compile-fail/issue-11374.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -12,7 +12,7 @@ use std::old_io;\n use std::vec;\n \n pub struct Container<'a> {\n-    reader: &'a mut Reader //~ ERROR explicit lifetime bound required\n+    reader: &'a mut Reader\n }\n \n impl<'a> Container<'a> {\n@@ -33,5 +33,5 @@ pub fn for_stdin<'a>() -> Container<'a> {\n fn main() {\n     let mut c = for_stdin();\n     let mut v = Vec::new();\n-    c.read_to(v);\n+    c.read_to(v); //~ ERROR mismatched types\n }"}, {"sha": "81424577d491bce1c04a2d7b29e452117bb35c1e", "filename": "src/test/compile-fail/issue-5216.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn f() { }\n-struct S(Box<FnMut()>); //~ ERROR explicit lifetime bound required\n-pub static C: S = S(f);\n+struct S(Box<FnMut()>);\n+pub static C: S = S(f); //~ ERROR mismatched types\n \n \n fn g() { }\n-type T = Box<FnMut()>;  //~ ERROR explicit lifetime bound required\n-pub static D: T = g;\n+type T = Box<FnMut()>;\n+pub static D: T = g; //~ ERROR mismatched types\n \n fn main() {}"}, {"sha": "de7639c621325cb171fcfe7229f8bc4be192f740", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -36,7 +36,7 @@ fn g<T>(val: T) {\n fn foo<'a>() {\n     let t: S<&'a isize> = S;\n     let a = &t as &Gettable<&'a isize>;\n-    //~^ ERROR declared lifetime bound not satisfied\n+    //~^ ERROR the type `&'a isize` does not fulfill the required lifetime\n }\n \n fn foo2<'a>() {"}, {"sha": "3d47d33d7c35d0af26b75285944093ad380f235b", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -22,7 +22,7 @@ fn test51<'a>() {\n }\n fn test52<'a>() {\n     assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR declared lifetime bound not satisfied\n+    //~^ ERROR does not fulfill the required lifetime\n }\n \n // ...unless they are properly bounded"}, {"sha": "266b61566560f12aee08dfbe1138774caf6767dd", "filename": "src/test/compile-fail/kindck-send-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -19,7 +19,7 @@ fn test32() { assert_send::<Vec<isize> >(); }\n \n // but not if they own a bad thing\n fn test40<'a>(_: &'a isize) {\n-    assert_send::<Box<&'a isize>>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<Box<&'a isize>>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn main() { }"}, {"sha": "e2a5b0678a6283164b661393c9dd5cb1dfdf016f", "filename": "src/test/compile-fail/kindck-send-region-pointers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -22,13 +22,13 @@ fn test10() { assert_send::<&'static mut isize>(); }\n \n // otherwise lifetime pointers are not ok\n fn test20<'a>(_: &'a isize) {\n-    assert_send::<&'a isize>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a isize>(); //~ ERROR does not fulfill the required lifetime\n }\n fn test21<'a>(_: &'a isize) {\n-    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n }\n fn test22<'a>(_: &'a isize) {\n-    assert_send::<&'a [isize]>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a [isize]>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn main() { }"}, {"sha": "322283a4ca9ad4e1f0c271aba29c24d4e1909c2e", "filename": "src/test/compile-fail/object-lifetime-default-ambiguous.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-ambiguous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-ambiguous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-ambiguous.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that if a struct declares multiple region bounds for a given\n+// type parameter, an explicit lifetime bound is required on object\n+// lifetimes within.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct Ref0<T:?Sized> {\n+    r: *mut T\n+}\n+\n+struct Ref1<'a,T:'a+?Sized> {\n+    r: &'a T\n+}\n+\n+struct Ref2<'a,'b:'a,T:'a+'b+?Sized> {\n+    r: &'a &'b T\n+}\n+\n+fn a<'a,'b>(t: Ref2<'a,'b,Test>) {\n+    //~^ ERROR lifetime bound for this object type cannot be deduced from context\n+}\n+\n+fn b(t: Ref2<Test>) {\n+    //~^ ERROR lifetime bound for this object type cannot be deduced from context\n+}\n+\n+fn c(t: Ref2<&Test>) {\n+    // In this case, the &'a overrides.\n+}\n+\n+fn d(t: Ref2<Ref1<Test>>) {\n+    // In this case, the lifetime parameter from the Ref1 overrides.\n+}\n+\n+fn e(t: Ref2<Ref0<Test>>) {\n+    //~^ ERROR lifetime bound for this object type cannot be deduced from context\n+    //\n+    // In this case, Ref2 is ambiguous, and Ref0 inherits the\n+    // ambiguity.\n+}\n+\n+fn f(t: &Ref2<Test>) {\n+    //~^ ERROR lifetime bound for this object type cannot be deduced from context\n+}\n+\n+fn main() {\n+}"}, {"sha": "0077d10e6ca826e4a8312615a66b3837817c0fae", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various cases where the old rules under lifetime elision\n+// yield slightly different results than the new rules.\n+\n+#![allow(dead_code)]\n+\n+trait SomeTrait {\n+    fn dummy(&self) { }\n+}\n+\n+struct SomeStruct<'a> {\n+    r: Box<SomeTrait+'a>\n+}\n+\n+fn deref<T>(ss: &T) -> T {\n+    // produces the type of a deref without worrying about whether a\n+    // move out would actually be legal\n+    loop { }\n+}\n+\n+fn load0<'a>(ss: &'a Box<SomeTrait>) -> Box<SomeTrait> {\n+    // Under old rules, the fully elaborated types of input/output were:\n+    //\n+    // for<'a,'b> fn(&'a Box<SomeTrait+'b>) -> Box<SomeTrait+'a>\n+    //\n+    // Under new rules the result is:\n+    //\n+    // for<'a> fn(&'a Box<SomeTrait+'a>) -> Box<SomeTrait+'static>\n+    //\n+    // Therefore, we get a type error attempting to return `deref(ss)`\n+    // since `SomeTrait+'a <: SomeTrait+'static` does not hold.\n+\n+    deref(ss)\n+        //~^ ERROR cannot infer\n+}\n+\n+fn load1(ss: &SomeTrait) -> &SomeTrait {\n+    // Under old rules, the fully elaborated types of input/output were:\n+    //\n+    // for<'a,'b> fn(&'a (SomeTrait+'b)) -> &'a (SomeTrait+'a)\n+    //\n+    // Under new rules the result is:\n+    //\n+    // for<'a> fn(&'a (SomeTrait+'a)) -> &'a (SomeTrait+'a)\n+    //\n+    // In both cases, returning `ss` is legal.\n+\n+    ss\n+}\n+\n+fn load2<'a>(ss: &'a SomeTrait) -> &SomeTrait {\n+    // Same as `load1` but with an explicit name thrown in for fun.\n+\n+    ss\n+}\n+\n+fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n+    // Under old rules, the fully elaborated types of input/output were:\n+    //\n+    // for<'a,'b,'c>fn(&'a (SomeTrait+'c)) -> &'b (SomeTrait+'a)\n+    //\n+    // Based on the input/output types, the compiler could infer that\n+    //     'c : 'a\n+    //     'b : 'a\n+    // must hold, and therefore it permitted `&'a (Sometrait+'c)` to be\n+    // coerced to `&'b (SomeTrait+'a)`.\n+    //\n+    // Under the newer defaults, though, we get:\n+    //\n+    // for<'a,'b> fn(&'a (SomeTrait+'a)) -> &'b (SomeTrait+'b)\n+    //\n+    // which fails to type check.\n+\n+    ss\n+        //~^ ERROR cannot infer\n+        //~| ERROR mismatched types\n+}\n+\n+fn main() {\n+}"}, {"sha": "70752cbfda19f11396ec29a6c288a365e1da3336", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various cases where the defaults should lead to errors being\n+// reported.\n+\n+#![allow(dead_code)]\n+\n+trait SomeTrait {\n+    fn dummy(&self) { }\n+}\n+\n+struct SomeStruct<'a> {\n+    r: Box<SomeTrait+'a>\n+}\n+\n+fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n+    // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n+    // is illegal.\n+\n+    ss.r //~ ERROR mismatched types\n+}\n+\n+fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n+    // No error: b is bounded by 'static which outlives the\n+    // (anonymous) lifetime on the struct.\n+\n+    ss.r = b;\n+}\n+\n+fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n+    // Here we override the lifetimes explicitly, and so naturally we get an error.\n+\n+    ss.r = b; //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+}"}, {"sha": "c107c8d131d3a8f01672639bbfda0d7f810d0636", "filename": "src/test/compile-fail/object-lifetime-default-mybox.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a \"pass-through\" object-lifetime-default that produces errors.\n+\n+#![allow(dead_code)]\n+\n+trait SomeTrait {\n+    fn dummy(&self) { }\n+}\n+\n+struct MyBox<T:?Sized> {\n+    r: Box<T>\n+}\n+\n+fn deref<T>(ss: &T) -> T {\n+    // produces the type of a deref without worrying about whether a\n+    // move out would actually be legal\n+    loop { }\n+}\n+\n+fn load0(ss: &MyBox<SomeTrait>) -> MyBox<SomeTrait> {\n+    deref(ss) //~ ERROR cannot infer\n+}\n+\n+fn load1<'a,'b>(a: &'a MyBox<SomeTrait>,\n+                b: &'b MyBox<SomeTrait>)\n+                -> &'b MyBox<SomeTrait>\n+{\n+    a\n+      //~^ ERROR cannot infer\n+      //~| ERROR mismatched types\n+      //~| ERROR mismatched types\n+}\n+\n+fn main() {\n+}"}, {"sha": "73f71751ee80f37d35e857e31e86917af0f83381", "filename": "src/test/compile-fail/object-lifetime-default.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[rustc_object_lifetime_default]\n+struct A<T>(T); //~ ERROR None\n+\n+#[rustc_object_lifetime_default]\n+struct B<'a,T>(&'a (), T); //~ ERROR None\n+\n+#[rustc_object_lifetime_default]\n+struct C<'a,T:'a>(&'a T); //~ ERROR 'a\n+\n+#[rustc_object_lifetime_default]\n+struct D<'a,'b,T:'a+'b>(&'a T, &'b T); //~ ERROR Ambiguous\n+\n+#[rustc_object_lifetime_default]\n+struct E<'a,'b:'a,T:'b>(&'a T, &'b T); //~ ERROR 'b\n+\n+#[rustc_object_lifetime_default]\n+struct F<'a,'b,T:'a,U:'b>(&'a T, &'b U); //~ ERROR 'a,'b\n+\n+#[rustc_object_lifetime_default]\n+struct G<'a,'b,T:'a,U:'a+'b>(&'a T, &'b U); //~ ERROR 'a,Ambiguous\n+\n+fn main() { }"}, {"sha": "b8cbbdbe9ec3e93c30461e13e3c8fab1ed550658", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -25,7 +25,7 @@ struct Foo<'a,'b,'c> {\n     c: Box<Is<'a>>,\n     d: Box<IsSend>,\n     e: Box<Is<'a>+Send>, // we can derive two bounds, but one is 'static, so ok\n-    f: Box<SomeTrait>, //~ ERROR explicit lifetime bound required\n+    f: Box<SomeTrait>,   // OK, defaults to 'static due to RFC 599.\n     g: Box<SomeTrait+'a>,\n \n     z: Box<Is<'a>+'b+'c>, //~ ERROR only a single explicit lifetime bound is permitted"}, {"sha": "bb37d55fb08d067157623166d9ee1bce52b813a6", "filename": "src/test/compile-fail/region-object-lifetime-1.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -11,6 +11,8 @@\n // Various tests related to testing how region inference works\n // with respect to the object receivers.\n \n+#![allow(warnings)]\n+\n trait Foo {\n     fn borrowed<'a>(&'a self) -> &'a ();\n }\n@@ -21,29 +23,6 @@ fn borrowed_receiver_same_lifetime<'a>(x: &'a Foo) -> &'a () {\n     x.borrowed()\n }\n \n-// Borrowed receiver but two distinct lifetimes, we get an error.\n-fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a Foo) -> &'b () {\n-    x.borrowed() //~ ERROR cannot infer\n-}\n-\n-// Borrowed receiver with two distinct lifetimes, but we know that\n-// 'b:'a, hence &'a () is permitted.\n-fn borrowed_receiver_related_lifetimes<'a,'b>(x: &'a (Foo+'b)) -> &'a () {\n-    x.borrowed()\n-}\n-\n-// Here we have two distinct lifetimes, but we try to return a pointer\n-// with the longer lifetime when (from the signature) we only know\n-// that it lives as long as the shorter lifetime. Therefore, error.\n-fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a (Foo+'b)) -> &'b () {\n-    x.borrowed() //~ ERROR cannot infer\n-}\n-\n-// Here, the object is bounded by an anonymous lifetime and returned\n-// as `&'static`, so you get an error.\n-fn owned_receiver(x: Box<Foo>) -> &'static () {\n-    x.borrowed() //~ ERROR cannot infer\n-}\n-\n-fn main() {}\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful\n "}, {"sha": "f9bf4e257b3638188003768a744bad8ead6526b8", "filename": "src/test/compile-fail/region-object-lifetime-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-2.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various tests related to testing how region inference works\n+// with respect to the object receivers.\n+\n+trait Foo {\n+    fn borrowed<'a>(&'a self) -> &'a ();\n+}\n+\n+// Borrowed receiver but two distinct lifetimes, we get an error.\n+fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a Foo) -> &'b () {\n+    x.borrowed() //~ ERROR cannot infer\n+}\n+\n+fn main() {}\n+"}, {"sha": "7f00334f67e9f750c29fadda423b0b1fdf311d33", "filename": "src/test/compile-fail/region-object-lifetime-3.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various tests related to testing how region inference works\n+// with respect to the object receivers.\n+\n+#![allow(warnings)]\n+\n+trait Foo {\n+    fn borrowed<'a>(&'a self) -> &'a ();\n+}\n+\n+// Borrowed receiver with two distinct lifetimes, but we know that\n+// 'b:'a, hence &'a () is permitted.\n+fn borrowed_receiver_related_lifetimes<'a,'b>(x: &'a (Foo+'b)) -> &'a () {\n+    x.borrowed()\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful\n+"}, {"sha": "fe0ff8dc3fe5d2d9e38d96d23479e9915b50fd87", "filename": "src/test/compile-fail/region-object-lifetime-4.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-4.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various tests related to testing how region inference works\n+// with respect to the object receivers.\n+\n+trait Foo {\n+    fn borrowed<'a>(&'a self) -> &'a ();\n+}\n+\n+// Here we have two distinct lifetimes, but we try to return a pointer\n+// with the longer lifetime when (from the signature) we only know\n+// that it lives as long as the shorter lifetime. Therefore, error.\n+fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a (Foo+'b)) -> &'b () {\n+    x.borrowed() //~ ERROR cannot infer\n+}\n+\n+fn main() {}\n+"}, {"sha": "f07f753d82529965f2b306eda2f2513c8c050f2d", "filename": "src/test/compile-fail/region-object-lifetime-5.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-5.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various tests related to testing how region inference works\n+// with respect to the object receivers.\n+\n+trait Foo {\n+    fn borrowed<'a>(&'a self) -> &'a ();\n+}\n+\n+// Here, the object is bounded by an anonymous lifetime and returned\n+// as `&'static`, so you get an error.\n+fn owned_receiver(x: Box<Foo>) -> &'static () {\n+    x.borrowed() //~ ERROR `*x` does not live long enough\n+}\n+\n+fn main() {}\n+"}, {"sha": "20cc624ab19040aa421c7c8fdaab78562f247d8d", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -17,20 +17,22 @@ trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<Foo + 'static> {\n-    let x: Box<Foo + 'static> = box v; //~ ERROR declared lifetime bound not satisfied\n+    let x: Box<Foo + 'static> = box v; //~ ERROR does not fulfill the required lifetime\n     x\n }\n \n fn b(v: &[u8]) -> Box<Foo + 'static> {\n-    box v //~ ERROR declared lifetime bound not satisfied\n+    box v //~ ERROR does not fulfill the required lifetime\n }\n \n fn c(v: &[u8]) -> Box<Foo> {\n-    box v // OK thanks to lifetime elision\n+    // same as previous case due to RFC 599\n+\n+    box v //~ ERROR does not fulfill the required lifetime\n }\n \n fn d<'a,'b>(v: &'a [u8]) -> Box<Foo+'b> {\n-    box v //~ ERROR declared lifetime bound not satisfied\n+    box v //~ ERROR does not fulfill the required lifetime\n }\n \n fn e<'a:'b,'b>(v: &'a [u8]) -> Box<Foo+'b> {"}, {"sha": "71254e15d32fc37051b70324bc7e7d1942f77085", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -32,15 +32,15 @@ fn static_lifime_ok<'a,T,U:Send>(_: &'a isize) {\n // otherwise lifetime pointers are not ok\n \n fn param_not_ok<'a>(x: &'a isize) {\n-    assert_send::<&'a isize>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a isize>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn param_not_ok1<'a>(_: &'a isize) {\n-    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn param_not_ok2<'a>(_: &'a isize) {\n-    assert_send::<&'a [isize]>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a [isize]>(); //~ ERROR does not fulfill the required lifetime\n }\n \n // boxes are ok\n@@ -54,7 +54,7 @@ fn box_ok() {\n // but not if they own a bad thing\n \n fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a isize>>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<Box<&'a isize>>(); //~ ERROR does not fulfill the required lifetime\n }\n \n // objects with insufficient bounds no ok\n@@ -66,7 +66,7 @@ fn object_with_random_bound_not_ok<'a>() {\n \n fn object_with_send_bound_not_ok<'a>() {\n     assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR declared lifetime bound not satisfied\n+    //~^ ERROR does not fulfill the required lifetime\n }\n \n // unsafe pointers are ok unless they point at unsendable things"}, {"sha": "9e4c4e677cc695b1524561b77e7ae0e754caca0f", "filename": "src/test/compile-fail/regions-bounded-by-trait-requiring-static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-trait-requiring-static.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -29,15 +29,15 @@ fn static_lifime_ok<'a,T,U:Send>(_: &'a isize) {\n // otherwise lifetime pointers are not ok\n \n fn param_not_ok<'a>(x: &'a isize) {\n-    assert_send::<&'a isize>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a isize>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn param_not_ok1<'a>(_: &'a isize) {\n-    assert_send::<&'a str>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn param_not_ok2<'a>(_: &'a isize) {\n-    assert_send::<&'a [isize]>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<&'a [isize]>(); //~ ERROR does not fulfill the required lifetime\n }\n \n // boxes are ok\n@@ -51,7 +51,7 @@ fn box_ok() {\n // but not if they own a bad thing\n \n fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a isize>>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<Box<&'a isize>>(); //~ ERROR does not fulfill the required lifetime\n }\n \n // unsafe pointers are ok unless they point at unsendable things\n@@ -62,11 +62,11 @@ fn unsafe_ok1<'a>(_: &'a isize) {\n }\n \n fn unsafe_ok2<'a>(_: &'a isize) {\n-    assert_send::<*const &'a isize>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<*const &'a isize>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn unsafe_ok3<'a>(_: &'a isize) {\n-    assert_send::<*mut &'a isize>(); //~ ERROR declared lifetime bound not satisfied\n+    assert_send::<*mut &'a isize>(); //~ ERROR does not fulfill the required lifetime\n }\n \n fn main() {"}, {"sha": "da4e8231a239f11563931bdf16e2be7c96889feb", "filename": "src/test/compile-fail/regions-bounded-method-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-method-type-parameters.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn caller<'a>(x: &isize) {\n     Foo.some_method::<&'a isize>();\n-    //~^ ERROR declared lifetime bound not satisfied\n+    //~^ ERROR does not fulfill the required lifetime\n }\n \n fn main() { }"}, {"sha": "7a0e3cf4611c7156e0ef22218d2b3023a3449d2d", "filename": "src/test/compile-fail/regions-close-object-into-object-1.rs", "status": "renamed", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(box_syntax)]\n+#![allow(warnings)]\n \n trait A<T> {}\n struct B<'a, T>(&'a (A<T>+'a));\n@@ -17,19 +18,7 @@ trait X {}\n impl<'a, T> X for B<'a, T> {}\n \n fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n-    box B(&*v) as Box<X>\n-}\n-\n-fn g<'a, T: 'static>(v: Box<A<T>>) -> Box<X+'static> {\n-    box B(&*v) as Box<X> //~ ERROR cannot infer\n-}\n-\n-fn h<'a, T, U>(v: Box<A<U>+'static>) -> Box<X+'static> {\n-    box B(&*v) as Box<X>\n-}\n-\n-fn i<'a, T, U>(v: Box<A<U>>) -> Box<X+'static> {\n-    box B(&*v) as Box<X> //~ ERROR cannot infer\n+    box B(&*v) as Box<X> //~ ERROR `*v` does not live long enough\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/regions-close-object-into-object.rs"}, {"sha": "7861fb95fef666d315e46f2b989199eea7a8038c", "filename": "src/test/compile-fail/regions-close-object-into-object-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+trait A<T> {}\n+struct B<'a, T>(&'a (A<T>+'a));\n+\n+trait X {}\n+impl<'a, T> X for B<'a, T> {}\n+\n+fn g<'a, T: 'static>(v: Box<A<T>+'a>) -> Box<X+'static> {\n+    box B(&*v) as Box<X> //~ ERROR cannot infer\n+}\n+\n+fn main() { }"}, {"sha": "31354de2a27df7aac0a0ac73c4dbf7130a6daf46", "filename": "src/test/compile-fail/regions-close-object-into-object-3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+#![allow(warnings)]\n+\n+trait A<T> {}\n+struct B<'a, T>(&'a (A<T>+'a));\n+\n+trait X {}\n+impl<'a, T> X for B<'a, T> {}\n+\n+fn h<'a, T, U>(v: Box<A<U>+'static>) -> Box<X+'static> {\n+    box B(&*v) as Box<X> //~ ERROR `*v` does not live long enough\n+}\n+\n+fn main() {}\n+"}, {"sha": "c60975f97e13d5dd07e24c03ec7cfc542fc994f9", "filename": "src/test/compile-fail/regions-close-object-into-object-4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+\n+trait A<T> {}\n+struct B<'a, T>(&'a (A<T>+'a));\n+\n+trait X {}\n+impl<'a, T> X for B<'a, T> {}\n+\n+fn i<'a, T, U>(v: Box<A<U>+'a>) -> Box<X+'static> {\n+    box B(&*v) as Box<X> //~ ERROR cannot infer\n+}\n+\n+fn main() {}\n+"}, {"sha": "44b049d6561d5f7cbdc2e4dd681b659a577187ba", "filename": "src/test/compile-fail/seq-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fseq-args.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -14,7 +14,7 @@ trait seq { }\n impl<T> seq<T> for Vec<T> { //~ ERROR wrong number of type arguments\n     /* ... */\n }\n-impl seq<bool> for u32 {\n+impl seq<bool> for u32 { //~ ERROR wrong number of type arguments\n    /* Treat the integer as a sequence of bits */\n }\n "}, {"sha": "c276228b18ee3552cadd01ab33491abcb2828759", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -57,6 +57,7 @@ fn main() {\n \n     let pt3 = PointF::<i32> {\n         //~^ ERROR wrong number of type arguments\n+        //~| ERROR structure constructor specifies a structure of type\n         x: 9i32,\n         y: 10i32,\n     };"}, {"sha": "89e89cf82469391d4de8f1bd89799aea061385e0", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -22,7 +22,7 @@ fn c(x: Box<Foo+Sync+Send>) {\n fn d(x: Box<Foo>) {\n     a(x); //~  ERROR mismatched types\n           //~| expected `Box<Foo + Send>`\n-          //~| found `Box<Foo>`\n+          //~| found `Box<Foo + 'static>`\n           //~| expected bounds `Send`\n           //~| found no bounds\n }"}, {"sha": "3d264e681a3d25c6b0ea5d7f88e24068dcecdf38", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -24,8 +24,7 @@ fn c(x: Box<Foo+Sync>) {\n }\n \n fn d(x: &'static (Foo+Sync)) {\n-    b(x); //~ ERROR cannot infer\n-    //~^ ERROR mismatched types\n+    b(x);\n }\n \n fn main() {}"}, {"sha": "9f0682df3fe443c70b639a85a9515b06067ab5ed", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -12,7 +12,9 @@\n \n trait Three<A,B,C> { fn dummy(&self) -> (A,B,C); }\n \n-fn foo(_: &Three()) //~ ERROR wrong number of type arguments\n+fn foo(_: &Three())\n+//~^ ERROR wrong number of type arguments\n+//~| ERROR no associated type `Output`\n {}\n \n fn main() { }"}, {"sha": "40635cf3ddda32ca7bd689f94c011bad1eaa42e3", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -12,7 +12,9 @@\n \n trait Zero { fn dummy(&self); }\n \n-fn foo(_: Zero()) //~ ERROR wrong number of type arguments\n+fn foo(_: Zero())\n+    //~^ ERROR wrong number of type arguments\n+    //~| ERROR no associated type `Output` defined in `Zero`\n {}\n \n fn main() { }"}, {"sha": "5810ffcf21ab69e569974f9aa8fee6f92a6f810e", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -14,6 +14,7 @@ trait Trait {}\n \n fn f<F:Trait(isize) -> isize>(x: F) {}\n //~^ ERROR wrong number of type arguments: expected 0, found 1\n+//~| ERROR no associated type `Output`\n \n fn main() {}\n "}, {"sha": "c385a0195b6b20868b36a53180df2fdd9ca79c1b", "filename": "src/test/run-pass/object-lifetime-default-default-to-static.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-default-to-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-default-to-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-default-to-static.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `Box<Test>` is equivalent to `Box<Test+'static>`, both in\n+// fields and fn arguments.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct SomeStruct {\n+    t: Box<Test>,\n+    u: Box<Test+'static>,\n+}\n+\n+fn a(t: Box<Test>, mut ss: SomeStruct) {\n+    ss.t = t;\n+}\n+\n+fn b(t: Box<Test+'static>, mut ss: SomeStruct) {\n+    ss.t = t;\n+}\n+\n+fn c(t: Box<Test>, mut ss: SomeStruct) {\n+    ss.u = t;\n+}\n+\n+fn d(t: Box<Test+'static>, mut ss: SomeStruct) {\n+    ss.u = t;\n+}\n+\n+fn main() {\n+}"}, {"sha": "24da9603679065f404866242f82aa9210200de87", "filename": "src/test/run-pass/object-lifetime-default-from-ref-struct.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-ref-struct.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the lifetime of the enclosing `&` is used for the object\n+// lifetime bound.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct Ref<'a,T:'a+?Sized> {\n+    r: &'a T\n+}\n+\n+struct SomeStruct<'a> {\n+    t: Ref<'a,Test>,\n+    u: Ref<'a,Test+'a>,\n+}\n+\n+fn a<'a>(t: Ref<'a,Test>, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn b<'a>(t: Ref<'a,Test>, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn c<'a>(t: Ref<'a,Test+'a>, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn d<'a>(t: Ref<'a,Test+'a>, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+\n+fn main() {\n+}"}, {"sha": "825800e1d4447e1fd9daf28db8ad0c47610612e0", "filename": "src/test/run-pass/object-lifetime-default-from-rptr-box.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-box.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the lifetime from the enclosing `&` is \"inherited\"\n+// through the `Box` struct.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct SomeStruct<'a> {\n+    t: &'a Box<Test>,\n+    u: &'a Box<Test+'a>,\n+}\n+\n+fn a<'a>(t: &'a Box<Test>, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn b<'a>(t: &'a Box<Test>, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn c<'a>(t: &'a Box<Test+'a>, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn d<'a>(t: &'a Box<Test+'a>, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn main() {\n+}"}, {"sha": "0f34d945c8fb9976e7dc7884a48ed166b43a1815", "filename": "src/test/run-pass/object-lifetime-default-from-rptr-mut.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-mut.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the lifetime of the enclosing `&` is used for the object\n+// lifetime bound.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct SomeStruct<'a> {\n+    t: &'a mut Test,\n+    u: &'a mut (Test+'a),\n+}\n+\n+fn a<'a>(t: &'a mut Test, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn b<'a>(t: &'a mut Test, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn c<'a>(t: &'a mut (Test+'a), mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn d<'a>(t: &'a mut (Test+'a), mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+\n+fn main() {\n+}"}, {"sha": "9d5dac536f10ade4c0e41136cfc8d56876e737a5", "filename": "src/test/run-pass/object-lifetime-default-from-rptr-struct.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-struct.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the lifetime from the enclosing `&` is \"inherited\"\n+// through the `MyBox` struct.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct SomeStruct<'a> {\n+    t: &'a MyBox<Test>,\n+    u: &'a MyBox<Test+'a>,\n+}\n+\n+struct MyBox<T:?Sized> {\n+    b: Box<T>\n+}\n+\n+fn a<'a>(t: &'a MyBox<Test>, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn b<'a>(t: &'a MyBox<Test>, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn c<'a>(t: &'a MyBox<Test+'a>, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn d<'a>(t: &'a MyBox<Test+'a>, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn main() {\n+}"}, {"sha": "b7a28a5c524156764809cf9a2443635e46d4e837", "filename": "src/test/run-pass/object-lifetime-default-from-rptr.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81bce5290ff55b9a2eddd83d31b0778180904d7f/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs?ref=81bce5290ff55b9a2eddd83d31b0778180904d7f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the lifetime of the enclosing `&` is used for the object\n+// lifetime bound.\n+\n+#![allow(dead_code)]\n+\n+trait Test {\n+    fn foo(&self) { }\n+}\n+\n+struct SomeStruct<'a> {\n+    t: &'a Test,\n+    u: &'a (Test+'a),\n+}\n+\n+fn a<'a>(t: &'a Test, mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn b<'a>(t: &'a Test, mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+fn c<'a>(t: &'a (Test+'a), mut ss: SomeStruct<'a>) {\n+    ss.t = t;\n+}\n+\n+fn d<'a>(t: &'a (Test+'a), mut ss: SomeStruct<'a>) {\n+    ss.u = t;\n+}\n+\n+\n+fn main() {\n+}"}]}