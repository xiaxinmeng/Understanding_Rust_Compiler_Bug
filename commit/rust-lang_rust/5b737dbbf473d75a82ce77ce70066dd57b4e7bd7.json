{"sha": "5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNzM3ZGJiZjQ3M2Q3NWE4MmNlNzdjZTcwMDY2ZGQ1N2I0ZTdiZDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-25T19:22:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "get rid of *most* of the fn call hack by honoring mir.spread_arg", "tree": {"sha": "de6d53fa6bc0277aeaddf3d695555be6f54cf24b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de6d53fa6bc0277aeaddf3d695555be6f54cf24b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "html_url": "https://github.com/rust-lang/rust/commit/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38cc896dc69383cef01b40b1139b4e9c030a6dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38cc896dc69383cef01b40b1139b4e9c030a6dd", "html_url": "https://github.com/rust-lang/rust/commit/c38cc896dc69383cef01b40b1139b4e9c030a6dd"}], "stats": {"total": 118, "additions": 56, "deletions": 62}, "files": [{"sha": "87ee94cbe30f75c5d88c9397740a33381da792a2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::borrow::Cow;\n+\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::LayoutOf;\n@@ -335,84 +337,76 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // Figure out how to pass which arguments.\n                 // FIXME: Somehow this is horribly full of special cases here, and codegen has\n                 // none of that.  What is going on?\n-                trace!(\"ABI: {:?}\", sig.abi);\n                 trace!(\n-                    \"args: {:#?}\",\n+                    \"ABI: {:?}, args: {:#?}\",\n+                    sig.abi,\n                     args.iter()\n                         .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n                         .collect::<Vec<_>>()\n                 );\n                 trace!(\n-                    \"locals: {:#?}\",\n+                    \"spread_arg: {:?}, locals: {:#?}\",\n+                    mir.spread_arg,\n                     mir.args_iter()\n                         .map(|local|\n                             (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n                         )\n                         .collect::<Vec<_>>()\n                 );\n-                match instance.def {\n-                    ty::InstanceDef::ClosureOnceShim { .. } if sig.abi == Abi::Rust => {\n-                        // this has an entirely ridicolous calling convention where it uses the\n-                        // \"Rust\" ABI, but arguments come in untupled and are supposed to be tupled\n-                        // for the callee!  The function's first argument is a ZST, and then\n-                        // there comes a tuple for the rest.\n-                        let mut arg_locals = mir.args_iter();\n-\n-                        {   // the ZST. nothing to write.\n-                            let arg_local = arg_locals.next().unwrap();\n-                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            assert!(dest.layout.is_zst());\n-                        }\n \n-                        {   // the tuple argument.\n-                            let arg_local = arg_locals.next().unwrap();\n-                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            assert_eq!(dest.layout.fields.count(), args.len());\n-                            for (i, &op) in args.iter().enumerate() {\n-                                let dest_field = self.place_field(dest, i as u64)?;\n-                                self.copy_op(op, dest_field)?;\n-                            }\n-                        }\n+                // We have two iterators: Where the arguments come from,\n+                // and where they go to.\n+\n+                // For where they come from: If the ABI is RustCall, we untuple the\n+                // last incoming argument.  These do not have the same type,\n+                // so to keep the code paths uniform we accept an allocation\n+                // (for RustCall ABI only).\n+                let args_effective : Cow<[OpTy<'tcx>]> =\n+                    if sig.abi == Abi::RustCall && !args.is_empty() {\n+                        // Untuple\n+                        let (&untuple_arg, args) = args.split_last().unwrap();\n+                        trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                        Cow::from(args.iter().map(|&a| Ok(a))\n+                            .chain((0..untuple_arg.layout.fields.count()).into_iter()\n+                                .map(|i| self.operand_field(untuple_arg, i as u64))\n+                            )\n+                            .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n+                    } else {\n+                        // Plain arg passing\n+                        Cow::from(args)\n+                    };\n \n-                        // that should be it\n-                        assert!(arg_locals.next().is_none());\n+                // Now we have to spread them out across the callee's locals,\n+                // taking into account the `spread_arg`.\n+                let mut args_iter = args_effective.iter();\n+                let mut local_iter = mir.args_iter();\n+                // HACK: ClosureOnceShim calls something that expects a ZST as\n+                // first argument, but the callers do not actually pass that ZST.\n+                // Codegen doesn't care because ZST arguments do not even exist there.\n+                match instance.def {\n+                    ty::InstanceDef::ClosureOnceShim { .. } if sig.abi == Abi::Rust => {\n+                        let local = local_iter.next().unwrap();\n+                        let dest = self.eval_place(&mir::Place::Local(local))?;\n+                        assert!(dest.layout.is_zst());\n                     }\n-                    _ => {\n-                        // overloaded-calls-simple.rs in miri's test suite demomstrates that there is\n-                        // no way to predict, from the ABI and instance.def, whether the function\n-                        // wants arguments passed with untupling or not.  So we just make it\n-                        // depend on the number of arguments...\n-                        let untuple =\n-                            sig.abi == Abi::RustCall && !args.is_empty() && args.len() != mir.arg_count;\n-                        let (normal_args, untuple_arg) = if untuple {\n-                            let (tup, args) = args.split_last().unwrap();\n-                            trace!(\"eval_fn_call: Will pass last argument by untupling\");\n-                            (args, Some(tup))\n-                        } else {\n-                            (&args[..], None)\n-                        };\n-\n-                        // Pass the arguments.\n-                        let mut arg_locals = mir.args_iter();\n-                        // First the normal ones.\n-                        for &op in normal_args {\n-                            let arg_local = arg_locals.next().unwrap();\n-                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.copy_op(op, dest)?;\n-                        }\n-                        // The the ones to untuple.\n-                        if let Some(&untuple_arg) = untuple_arg {\n-                            for i in 0..untuple_arg.layout.fields.count() {\n-                                let arg_local = arg_locals.next().unwrap();\n-                                let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                                let op = self.operand_field(untuple_arg, i as u64)?;\n-                                self.copy_op(op, dest)?;\n-                            }\n+                    _ => {}\n+                }\n+                // Now back to norml argument passing.\n+                while let Some(local) = local_iter.next() {\n+                    let dest = self.eval_place(&mir::Place::Local(local))?;\n+                    if Some(local) == mir.spread_arg {\n+                        // Must be a tuple\n+                        for i in 0..dest.layout.fields.count() {\n+                            let dest = self.place_field(dest, i as u64)?;\n+                            self.copy_op(*args_iter.next().unwrap(), dest)?;\n                         }\n-                        // That should be it.\n-                        assert!(arg_locals.next().is_none());\n+                    } else {\n+                        // Normal argument\n+                        self.copy_op(*args_iter.next().unwrap(), dest)?;\n                     }\n                 }\n+                // Now we should be done\n+                assert!(args_iter.next().is_none());\n                 Ok(())\n             }\n             // cannot use the shim here, because that will only result in infinite recursion"}, {"sha": "47d5c88e5f51eb3a604fb0f6064624f2b1409f54", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b737dbbf473d75a82ce77ce70066dd57b4e7bd7/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5b737dbbf473d75a82ce77ce70066dd57b4e7bd7", "patch": "@@ -357,10 +357,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         Ok(ptr) => ptr,\n                         Err(_) =>\n                             return validation_failure!(\n-                                \"undefined metadata in fat pointer\", path\n+                                \"undefined location or metadata in fat pointer\", path\n                             ),\n                     };\n-                    // check metadata\n+                    // check metadata early, for better diagnostics\n                     match self.tcx.struct_tail(ptr.layout.ty).sty {\n                         ty::Dynamic(..) => {\n                             match ptr.extra.unwrap().to_ptr() {"}]}