{"sha": "1b2d91c79da93461563428d25ae09bbeb59ed292", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMmQ5MWM3OWRhOTM0NjE1NjM0MjhkMjVhZTA5YmJlYjU5ZWQyOTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-08T19:58:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-10T01:26:50Z"}, "message": "de-mode-ify infer and some parts of typeck\n\nalso, fix bug in the various lint passes that fn() was considered\nnot suitable for the default mode", "tree": {"sha": "3a9bd4db41536f3cc05107d448a11fc4dd7355cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a9bd4db41536f3cc05107d448a11fc4dd7355cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b2d91c79da93461563428d25ae09bbeb59ed292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2d91c79da93461563428d25ae09bbeb59ed292", "html_url": "https://github.com/rust-lang/rust/commit/1b2d91c79da93461563428d25ae09bbeb59ed292", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b2d91c79da93461563428d25ae09bbeb59ed292/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe8c8ad5827e0156490d78257b5e33cf9bc1281a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8c8ad5827e0156490d78257b5e33cf9bc1281a", "html_url": "https://github.com/rust-lang/rust/commit/fe8c8ad5827e0156490d78257b5e33cf9bc1281a"}], "stats": {"total": 301, "additions": 164, "deletions": 137}, "files": [{"sha": "762191842b8ccc9e57fc98fb36425572a1136666", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=1b2d91c79da93461563428d25ae09bbeb59ed292", "patch": "@@ -250,7 +250,7 @@ impl<T: copy, E: copy> result<T, E> {\n  *     }\n  */\n fn map_vec<T,U:copy,V:copy>(\n-    ts: ~[T], op: fn(T) -> result<V,U>) -> result<~[V],U> {\n+    ts: &[T], op: fn(T) -> result<V,U>) -> result<~[V],U> {\n \n     let mut vs: ~[V] = ~[];\n     vec::reserve(vs, vec::len(ts));\n@@ -284,7 +284,7 @@ fn map_opt<T,U:copy,V:copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n-fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n+fn map_vec2<S,T,U:copy,V:copy>(ss: &[S], ts: &[T],\n                                op: fn(S,T) -> result<V,U>) -> result<~[V],U> {\n \n     assert vec::same_length(ss, ts);\n@@ -307,7 +307,7 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n  * error.  This could be implemented using `map2()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n-fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n+fn iter_vec2<S,T,U:copy>(ss: &[S], ts: &[T],\n                          op: fn(S,T) -> result<(),U>) -> result<(),U> {\n \n     assert vec::same_length(ss, ts);"}, {"sha": "5e756918d302e120f70e158e4afeb9d4aa7a6117", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=1b2d91c79da93461563428d25ae09bbeb59ed292", "patch": "@@ -17,6 +17,7 @@ export capacity;\n export len;\n export from_fn;\n export from_elem;\n+export from_slice;\n export build, build_sized;\n export to_mut;\n export from_mut;\n@@ -211,6 +212,11 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n     return v;\n }\n \n+/// Creates a new unique vector with the same contents as the slice\n+pure fn from_slice<T: copy>(t: &[T]) -> ~[T] {\n+    from_fn(t.len(), |i| t[i])\n+}\n+\n /**\n  * Builds a vector by calling a provided function with an argument\n  * function that pushes an element to the back of a vector."}, {"sha": "363c2fc719e02541fbc3228d8a1aae2490f299a6", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=1b2d91c79da93461563428d25ae09bbeb59ed292", "patch": "@@ -532,6 +532,16 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     kind\n }\n \n+/// A polytype.\n+///\n+/// - `bounds`: The list of bounds for each type parameter.  The length of the\n+///   list also tells you how many type parameters there are.\n+///\n+/// - `rp`: true if the type is region-parameterized.  Types can have at\n+///   most one region parameter, always called `&self`.\n+///\n+/// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n+///   region `&self` or to (unsubstituted) ty_param types\n type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n                                rp: bool,\n                                ty: t};\n@@ -1532,7 +1542,7 @@ pure fn kind_is_owned(k: kind) -> bool {\n \n fn proto_kind(p: proto) -> kind {\n     match p {\n-      ast::proto_block => kind_noncopyable(),\n+      ast::proto_block => kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE),\n       ast::proto_box => kind_safe_for_default_mode() | kind_owned(),\n       ast::proto_uniq => kind_send_copy() | kind_owned(),\n       ast::proto_bare => kind_safe_for_default_mode_send() | kind_const() |"}, {"sha": "a0c1d5bd3c45706513c3de2eea3b4177e1d13001", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=1b2d91c79da93461563428d25ae09bbeb59ed292", "patch": "@@ -175,13 +175,16 @@ fn check_bare_fn(ccx: @crate_ctxt,\n                  id: ast::node_id,\n                  self_info: option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    let fn_ty = match check ty::get(fty).struct { ty::ty_fn(f) => f };\n-    check_fn(ccx, self_info, fn_ty, decl, body, false, none);\n+    match check ty::get(fty).struct {\n+        ty::ty_fn(ref fn_ty) => {\n+            check_fn(ccx, self_info, fn_ty, decl, body, false, none)\n+        }\n+    }\n }\n \n fn check_fn(ccx: @crate_ctxt,\n             self_info: option<self_info>,\n-            fn_ty: ty::fn_ty,\n+            fn_ty: &ty::fn_ty,\n             decl: ast::fn_decl,\n             body: ast::blk,\n             indirect_ret: bool,\n@@ -620,13 +623,15 @@ impl @fn_ctxt {\n \n     fn mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n                    sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n-        let anmnt = {expr_id: expr.id, span: expr.span, borrow_lb: borrow_lb};\n+        let anmnt = &{expr_id: expr.id, span: expr.span,\n+                      borrow_lb: borrow_lb};\n         infer::mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n     fn can_mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n                        sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n-        let anmnt = {expr_id: expr.id, span: expr.span, borrow_lb: borrow_lb};\n+        let anmnt = &{expr_id: expr.id, span: expr.span,\n+                      borrow_lb: borrow_lb};\n         infer::can_mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n@@ -821,7 +826,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // functions.  Therefore, we match one level of structure.\n         let fn_ty =\n             match structure_of(fcx, sp, in_fty) {\n-              sty @ ty::ty_fn(fn_ty) => {\n+              sty @ ty::ty_fn(ref fn_ty) => {\n                 replace_bound_regions_in_fn_ty(\n                     fcx.ccx.tcx, @nil, none, fn_ty,\n                     |_br| fcx.infcx.next_region_var_nb()).fn_ty\n@@ -1124,7 +1129,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // what's going on here.\n         let expected_tys = do unpack_expected(fcx, expected) |sty| {\n             match sty {\n-              ty::ty_fn(fn_ty) => {\n+              ty::ty_fn(ref fn_ty) => {\n                 let {fn_ty, _} =\n                     replace_bound_regions_in_fn_ty(\n                         tcx, @nil, none, fn_ty,\n@@ -1146,7 +1151,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        check_fn(fcx.ccx, fcx.self_info, fn_ty, decl, body,\n+        check_fn(fcx.ccx, fcx.self_info, &fn_ty, decl, body,\n                  is_loop_body, some(fcx));\n     }\n "}, {"sha": "7a7efd694603a9b47de53ecdbc3afe2a98b62b2f", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=1b2d91c79da93461563428d25ae09bbeb59ed292", "patch": "@@ -1,3 +1,6 @@\n+// #[warn(deprecated_mode)];\n+// #[warn(deprecated_pattern)];\n+\n import syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n@@ -6,7 +9,7 @@ fn replace_bound_regions_in_fn_ty(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n     self_info: option<self_info>,\n-    fn_ty: ty::fn_ty,\n+    fn_ty: &ty::fn_ty,\n     mapf: fn(ty::bound_region) -> ty::region) ->\n     {isr: isr_alist, self_info: option<self_info>, fn_ty: ty::fn_ty} {\n \n@@ -17,22 +20,22 @@ fn replace_bound_regions_in_fn_ty(\n       none => none\n     };\n \n-    let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n+    let mut all_tys = ty::tys_in_fn_ty(*fn_ty);\n \n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n     debug!{\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n                 all_tys=%?)\",\n            self_ty.map(|t| ty_to_str(tcx, t)),\n-           ty_to_str(tcx, ty::mk_fn(tcx, fn_ty)),\n+           ty_to_str(tcx, ty::mk_fn(tcx, *fn_ty)),\n            all_tys.map(|t| ty_to_str(tcx, t))};\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n         debug!{\"br=%?\", br};\n         mapf(br)\n     };\n-    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty), |t| {\n+    let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(*fn_ty), |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));"}, {"sha": "38913a5b605317947daab7e4f925c974457fa898", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 124, "deletions": 121, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b2d91c79da93461563428d25ae09bbeb59ed292/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=1b2d91c79da93461563428d25ae09bbeb59ed292", "patch": "@@ -164,6 +164,9 @@ section on \"Type Combining\" below for details.\n \n */\n \n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+\n import std::smallintmap;\n import std::smallintmap::smallintmap;\n import std::map::hashmap;\n@@ -361,25 +364,25 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     debug!{\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n-    indent(|| cx.commit(|| sub(cx).tys(a, b) ) ).to_ures()\n+    indent(|| cx.commit(|| (&sub(cx)).tys(a, b) ) ).to_ures()\n }\n \n fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     debug!{\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n-    indent(|| cx.probe(|| sub(cx).tys(a, b) ) ).to_ures()\n+    indent(|| cx.probe(|| (&sub(cx)).tys(a, b) ) ).to_ures()\n }\n \n fn mk_subr(cx: infer_ctxt, a: ty::region, b: ty::region) -> ures {\n     debug!{\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n-    indent(|| cx.commit(|| sub(cx).regions(a, b) ) ).to_ures()\n+    indent(|| cx.commit(|| (&sub(cx)).regions(a, b) ) ).to_ures()\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     debug!{\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n     indent(|| cx.commit(|| cx.eq_tys(a, b) ) ).to_ures()\n }\n \n-fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n+fn mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n                a: ty::t, b: ty::t) -> ures {\n     debug!{\"mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)};\n@@ -388,7 +391,7 @@ fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     ) ).to_ures()\n }\n \n-fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n+fn can_mk_assignty(cx: infer_ctxt, anmnt: &assignment,\n                 a: ty::t, b: ty::t) -> ures {\n     debug!{\"can_mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)};\n@@ -536,29 +539,29 @@ trait st {\n \n impl ty::t: st {\n     fn sub(infcx: infer_ctxt, &&b: ty::t) -> ures {\n-        sub(infcx).tys(self, b).to_ures()\n+        (&sub(infcx)).tys(self, b).to_ures()\n     }\n \n     fn lub(infcx: infer_ctxt, &&b: ty::t) -> cres<ty::t> {\n-        lub(infcx).tys(self, b)\n+        (&lub(infcx)).tys(self, b)\n     }\n \n     fn glb(infcx: infer_ctxt, &&b: ty::t) -> cres<ty::t> {\n-        glb(infcx).tys(self, b)\n+        (&glb(infcx)).tys(self, b)\n     }\n }\n \n impl ty::region: st {\n     fn sub(infcx: infer_ctxt, &&b: ty::region) -> ures {\n-        sub(infcx).regions(self, b).chain(|_r| ok(()))\n+        (&sub(infcx)).regions(self, b).chain(|_r| ok(()))\n     }\n \n     fn lub(infcx: infer_ctxt, &&b: ty::region) -> cres<ty::region> {\n-        lub(infcx).regions(self, b)\n+        (&lub(infcx)).regions(self, b)\n     }\n \n     fn glb(infcx: infer_ctxt, &&b: ty::region) -> cres<ty::region> {\n-        glb(infcx).regions(self, b)\n+        (&glb(infcx)).regions(self, b)\n     }\n }\n \n@@ -567,7 +570,7 @@ fn uok() -> ures {\n }\n \n fn rollback_to<V:copy vid, T:copy>(\n-    vb: vals_and_bindings<V, T>, len: uint) {\n+    vb: &vals_and_bindings<V, T>, len: uint) {\n \n     while vb.bindings.len() != len {\n         let (vid, old_v) = vec::pop(vb.bindings);\n@@ -605,8 +608,8 @@ impl infer_ctxt {\n           result::ok(_) => debug!{\"try--ok\"},\n           result::err(_) => {\n             debug!{\"try--rollback\"};\n-            rollback_to(self.tvb, tvbl);\n-            rollback_to(self.rb, rbl);\n+            rollback_to(&self.tvb, tvbl);\n+            rollback_to(&self.rb, rbl);\n             while self.borrowings.len() != bl { self.borrowings.pop(); }\n           }\n         }\n@@ -618,8 +621,8 @@ impl infer_ctxt {\n         assert self.tvb.bindings.len() == 0u;\n         assert self.rb.bindings.len() == 0u;\n         let r <- f();\n-        rollback_to(self.tvb, 0u);\n-        rollback_to(self.rb, 0u);\n+        rollback_to(&self.tvb, 0u);\n+        rollback_to(&self.rb, 0u);\n         return r;\n     }\n }\n@@ -697,7 +700,7 @@ impl infer_ctxt {\n impl infer_ctxt {\n \n     fn set<V:copy vid, T:copy to_str>(\n-        vb: vals_and_bindings<V, T>, vid: V,\n+        vb: &vals_and_bindings<V, T>, vid: V,\n         +new_v: var_value<V, T>) {\n \n         let old_v = vb.vals.get(vid.to_uint());\n@@ -709,7 +712,7 @@ impl infer_ctxt {\n     }\n \n     fn get<V:copy vid, T:copy>(\n-        vb: vals_and_bindings<V, T>, vid: V)\n+        vb: &vals_and_bindings<V, T>, vid: V)\n         -> node<V, T> {\n \n         let vid_u = vid.to_uint();\n@@ -784,7 +787,7 @@ impl infer_ctxt {\n     // If this cannot be achieved, the result is failure.\n \n     fn set_var_to_merged_bounds<V:copy vid, T:copy to_str st>(\n-        vb: vals_and_bindings<V, bounds<T>>,\n+        vb: &vals_and_bindings<V, bounds<T>>,\n         v_id: V, a: bounds<T>, b: bounds<T>, rank: uint) -> ures {\n \n         // Think of the two diamonds, we want to find the\n@@ -833,7 +836,7 @@ impl infer_ctxt {\n     }\n \n     fn vars<V:copy vid, T:copy to_str st>(\n-        vb: vals_and_bindings<V, bounds<T>>,\n+        vb: &vals_and_bindings<V, bounds<T>>,\n         a_id: V, b_id: V) -> ures {\n \n         // Need to make sub_id a subtype of sup_id.\n@@ -898,7 +901,7 @@ impl infer_ctxt {\n     }\n \n     fn vars_integral<V:copy vid>(\n-        vb: vals_and_bindings<V, int_ty_set>,\n+        vb: &vals_and_bindings<V, int_ty_set>,\n         a_id: V, b_id: V) -> ures {\n \n         let nde_a = self.get(vb, a_id);\n@@ -945,7 +948,7 @@ impl infer_ctxt {\n     }\n \n     fn vart<V: copy vid, T: copy to_str st>(\n-        vb: vals_and_bindings<V, bounds<T>>,\n+        vb: &vals_and_bindings<V, bounds<T>>,\n         a_id: V, b: T) -> ures {\n \n         let nde_a = self.get(vb, a_id);\n@@ -961,7 +964,7 @@ impl infer_ctxt {\n     }\n \n     fn vart_integral<V: copy vid>(\n-        vb: vals_and_bindings<V, int_ty_set>,\n+        vb: &vals_and_bindings<V, int_ty_set>,\n         a_id: V, b: ty::t) -> ures {\n \n         assert ty::type_is_integral(b);\n@@ -981,7 +984,7 @@ impl infer_ctxt {\n     }\n \n     fn tvar<V: copy vid, T: copy to_str st>(\n-        vb: vals_and_bindings<V, bounds<T>>,\n+        vb: &vals_and_bindings<V, bounds<T>>,\n         a: T, b_id: V) -> ures {\n \n         let a_bounds = {lb: some(a), ub: none};\n@@ -997,7 +1000,7 @@ impl infer_ctxt {\n     }\n \n     fn tvar_integral<V: copy vid>(\n-        vb: vals_and_bindings<V, int_ty_set>,\n+        vb: &vals_and_bindings<V, int_ty_set>,\n         a: ty::t, b_id: V) -> ures {\n \n         assert ty::type_is_integral(a);\n@@ -1035,11 +1038,11 @@ impl infer_ctxt {\n     }\n \n     fn sub_tys(a: ty::t, b: ty::t) -> ures {\n-        sub(self).tys(a, b).chain(|_t| ok(()) )\n+        (&sub(self)).tys(a, b).chain(|_t| ok(()) )\n     }\n \n     fn sub_regions(a: ty::region, b: ty::region) -> ures {\n-        sub(self).regions(a, b).chain(|_t| ok(()) )\n+        (&sub(self)).regions(a, b).chain(|_t| ok(()) )\n     }\n \n     fn eq_tys(a: ty::t, b: ty::t) -> ures {\n@@ -1210,7 +1213,7 @@ impl resolve_state {\n         if !self.should(resolve_rvar) {\n             return ty::re_var(rid)\n         }\n-        let nde = self.infcx.get(self.infcx.rb, rid);\n+        let nde = self.infcx.get(&self.infcx.rb, rid);\n         let bounds = nde.possible_types;\n         match bounds {\n           { ub:_, lb:some(r) } => { self.assert_not_rvar(rid, r); r }\n@@ -1247,7 +1250,7 @@ impl resolve_state {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let nde = self.infcx.get(self.infcx.tvb, vid);\n+            let nde = self.infcx.get(&self.infcx.tvb, vid);\n             let bounds = nde.possible_types;\n \n             let t1 = match bounds {\n@@ -1271,7 +1274,7 @@ impl resolve_state {\n             return ty::mk_var_integral(self.infcx.tcx, vid);\n         }\n \n-        let nde = self.infcx.get(self.infcx.tvib, vid);\n+        let nde = self.infcx.get(&self.infcx.tvib, vid);\n         let pt = nde.possible_types;\n \n         // If there's only one type in the set of possible types, then\n@@ -1283,7 +1286,7 @@ impl resolve_state {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n-                    self.infcx.tvib, vid,\n+                    &self.infcx.tvib, vid,\n                     root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n                                                            ty),\n                         nde.rank));\n@@ -1347,7 +1350,7 @@ impl resolve_state {\n // needed.\n \n impl infer_ctxt {\n-    fn assign_tys(anmnt: assignment, a: ty::t, b: ty::t) -> ures {\n+    fn assign_tys(anmnt: &assignment, a: ty::t, b: ty::t) -> ures {\n \n         fn select(fst: option<ty::t>, snd: option<ty::t>) -> option<ty::t> {\n             match fst {\n@@ -1369,8 +1372,8 @@ impl infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-            let nde_a = self.get(self.tvb, a_id);\n-            let nde_b = self.get(self.tvb, b_id);\n+            let nde_a = self.get(&self.tvb, a_id);\n+            let nde_b = self.get(&self.tvb, b_id);\n             let a_bounds = nde_a.possible_types;\n             let b_bounds = nde_b.possible_types;\n \n@@ -1380,15 +1383,15 @@ impl infer_ctxt {\n           }\n \n           (ty::ty_var(a_id), _) => {\n-            let nde_a = self.get(self.tvb, a_id);\n+            let nde_a = self.get(&self.tvb, a_id);\n             let a_bounds = nde_a.possible_types;\n \n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             self.assign_tys_or_sub(anmnt, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) => {\n-            let nde_b = self.get(self.tvb, b_id);\n+            let nde_b = self.get(&self.tvb, b_id);\n             let b_bounds = nde_b.possible_types;\n \n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n@@ -1402,9 +1405,9 @@ impl infer_ctxt {\n     }\n \n     fn assign_tys_or_sub(\n-        anmnt: assignment,\n+        anmnt: &assignment,\n         a: ty::t, b: ty::t,\n-        a_bnd: option<ty::t>, b_bnd: option<ty::t>) -> ures {\n+        +a_bnd: option<ty::t>, +b_bnd: option<ty::t>) -> ures {\n \n         debug!{\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n                anmnt, a.to_str(self), b.to_str(self),\n@@ -1456,7 +1459,7 @@ impl infer_ctxt {\n         }\n     }\n \n-    fn crosspollinate(anmnt: assignment,\n+    fn crosspollinate(anmnt: &assignment,\n                       a: ty::t,\n                       nr_b: ty::t,\n                       m: ast::mutability,\n@@ -1473,7 +1476,7 @@ impl infer_ctxt {\n                 let r_a = self.next_region_var_with_scope_lb(anmnt.borrow_lb);\n \n                 debug!{\"anmnt=%?\", anmnt};\n-                do sub(self).contraregions(r_a, r_b).chain |_r| {\n+                do (&sub(self)).contraregions(r_a, r_b).chain |_r| {\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n                     debug!{\"borrowing expression #%?, scope=%?, m=%?\",\n@@ -1542,10 +1545,10 @@ trait combine {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn tps(as: ~[ty::t], bs: ~[ty::t]) -> cres<~[ty::t]>;\n+    fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>>;\n-    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs>;\n-    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty>;\n+    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs>;\n+    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n@@ -1563,7 +1566,7 @@ enum lub = infer_ctxt;  // \"least upper bound\" (common supertype)\n enum glb = infer_ctxt;  // \"greatest lower bound\" (common subtype)\n \n fn super_substs<C:combine>(\n-    self: C, a: ty::substs, b: ty::substs) -> cres<ty::substs> {\n+    self: &C, a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n \n     fn eq_opt_regions(infcx: infer_ctxt,\n                       a: option<ty::region>,\n@@ -1602,7 +1605,7 @@ fn super_substs<C:combine>(\n }\n \n fn super_tps<C:combine>(\n-    self: C, as: ~[ty::t], bs: ~[ty::t]) -> cres<~[ty::t]> {\n+    self: &C, as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n \n     // Note: type parameters are always treated as *invariant*\n     // (otherwise the type system would be unsound).  In the\n@@ -1612,14 +1615,14 @@ fn super_tps<C:combine>(\n     if vec::same_length(as, bs) {\n         iter_vec2(as, bs, |a, b| {\n             self.infcx().eq_tys(a, b)\n-        }).then(|| ok(as) )\n+        }).then(|| ok(as.to_vec()) )\n     } else {\n         err(ty::terr_ty_param_size(bs.len(), as.len()))\n     }\n }\n \n fn super_self_tys<C:combine>(\n-    self: C, a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n+    self: &C, a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n \n     // Note: the self type parameter is (currently) always treated as\n     // *invariant* (otherwise the type system would be unsound).\n@@ -1642,7 +1645,7 @@ fn super_self_tys<C:combine>(\n }\n \n fn super_flds<C:combine>(\n-    self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n+    self: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n         self.mts(a.mt, b.mt)\n@@ -1654,15 +1657,15 @@ fn super_flds<C:combine>(\n }\n \n fn super_modes<C:combine>(\n-    self: C, a: ast::mode, b: ast::mode)\n+    self: &C, a: ast::mode, b: ast::mode)\n     -> cres<ast::mode> {\n \n     let tcx = self.infcx().tcx;\n     ty::unify_mode(tcx, a, b)\n }\n \n fn super_args<C:combine>(\n-    self: C, a: ty::arg, b: ty::arg)\n+    self: &C, a: ty::arg, b: ty::arg)\n     -> cres<ty::arg> {\n \n     do self.modes(a.mode, b.mode).chain |m| {\n@@ -1673,7 +1676,7 @@ fn super_args<C:combine>(\n }\n \n fn super_vstores<C:combine>(\n-    self: C, vk: ty::terr_vstore_kind,\n+    self: &C, vk: ty::terr_vstore_kind,\n     a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n \n     match (a, b) {\n@@ -1694,9 +1697,9 @@ fn super_vstores<C:combine>(\n }\n \n fn super_fns<C:combine>(\n-    self: C, a_f: ty::fn_ty, b_f: ty::fn_ty) -> cres<ty::fn_ty> {\n+    self: &C, a_f: &ty::fn_ty, b_f: &ty::fn_ty) -> cres<ty::fn_ty> {\n \n-    fn argvecs<C:combine>(self: C, a_args: ~[ty::arg],\n+    fn argvecs<C:combine>(self: &C, a_args: ~[ty::arg],\n                           b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n \n         if vec::same_length(a_args, b_args) {\n@@ -1729,7 +1732,7 @@ fn super_fns<C:combine>(\n }\n \n fn super_tys<C:combine>(\n-    self: C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = self.infcx().tcx;\n     match (ty::get(a).struct, ty::get(b).struct) {\n@@ -1747,17 +1750,17 @@ fn super_tys<C:combine>(\n \n       // Have to handle these first\n       (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) => {\n-        self.infcx().vars_integral(self.infcx().tvib, a_id, b_id)\n+        self.infcx().vars_integral(&self.infcx().tvib, a_id, b_id)\n             .then(|| ok(a) )\n       }\n       (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n       (ty::ty_var_integral(a_id), ty::ty_uint(_)) => {\n-        self.infcx().vart_integral(self.infcx().tvib, a_id, b)\n+        self.infcx().vart_integral(&self.infcx().tvib, a_id, b)\n             .then(|| ok(a) )\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) => {\n-        self.infcx().tvar_integral(self.infcx().tvib, a, b_id)\n+        self.infcx().tvar_integral(&self.infcx().tvib, a, b_id)\n             .then(|| ok(a) )\n       }\n \n@@ -1787,21 +1790,21 @@ fn super_tys<C:combine>(\n         ok(a)\n       }\n \n-      (ty::ty_enum(a_id, a_substs), ty::ty_enum(b_id, b_substs))\n+      (ty::ty_enum(a_id, ref a_substs), ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n         do self.substs(a_substs, b_substs).chain |tps| {\n             ok(ty::mk_enum(tcx, a_id, tps))\n         }\n       }\n \n-      (ty::ty_trait(a_id, a_substs), ty::ty_trait(b_id, b_substs))\n+      (ty::ty_trait(a_id, ref a_substs), ty::ty_trait(b_id, ref b_substs))\n       if a_id == b_id => {\n         do self.substs(a_substs, b_substs).chain |substs| {\n             ok(ty::mk_trait(tcx, a_id, substs))\n         }\n       }\n \n-      (ty::ty_class(a_id, a_substs), ty::ty_class(b_id, b_substs))\n+      (ty::ty_class(a_id, ref a_substs), ty::ty_class(b_id, ref b_substs))\n       if a_id == b_id => {\n         do self.substs(a_substs, b_substs).chain |substs| {\n             ok(ty::mk_class(tcx, a_id, substs))\n@@ -1867,7 +1870,7 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) => {\n+      (ty::ty_fn(ref a_fty), ty::ty_fn(ref b_fty)) => {\n         do self.fns(a_fty, b_fty).chain |fty| {\n             ok(ty::mk_fn(tcx, fty))\n         }\n@@ -1881,7 +1884,7 @@ impl sub: combine {\n     fn infcx() -> infer_ctxt { *self }\n     fn tag() -> ~str { ~\"sub\" }\n \n-    fn lub() -> lub { lub(*self) }\n+    fn lub() -> lub { lub(self.infcx()) }\n \n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n         self.tys(b, a)\n@@ -1899,22 +1902,22 @@ impl sub: combine {\n         do indent {\n             match (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) => {\n-                do self.infcx().vars(self.rb, a_id, b_id).then {\n+                do self.infcx().vars(&self.rb, a_id, b_id).then {\n                     ok(a)\n                 }\n               }\n               (ty::re_var(a_id), _) => {\n-                do self.infcx().vart(self.rb, a_id, b).then {\n+                do self.infcx().vart(&self.rb, a_id, b).then {\n                       ok(a)\n                   }\n               }\n               (_, ty::re_var(b_id)) => {\n-                  do self.infcx().tvar(self.rb, a, b_id).then {\n+                  do self.infcx().tvar(&self.rb, a, b_id).then {\n                       ok(a)\n                   }\n               }\n               _ => {\n-                  do self.lub().regions(a, b).compare(b) {\n+                  do (&self.lub()).regions(a, b).compare(b) {\n                     ty::terr_regions_differ(b, a)\n                 }\n               }\n@@ -1943,19 +1946,19 @@ impl sub: combine {\n     }\n \n     fn protos(a: ast::proto, b: ast::proto) -> cres<ast::proto> {\n-        self.lub().protos(a, b).compare(b, || {\n+        (&self.lub()).protos(a, b).compare(b, || {\n             ty::terr_proto_mismatch(b, a)\n         })\n     }\n \n     fn purities(f1: purity, f2: purity) -> cres<purity> {\n-        self.lub().purities(f1, f2).compare(f2, || {\n+        (&self.lub()).purities(f1, f2).compare(f2, || {\n             ty::terr_purity_mismatch(f2, f1)\n         })\n     }\n \n     fn ret_styles(a: ret_style, b: ret_style) -> cres<ret_style> {\n-        self.lub().ret_styles(a, b).compare(b, || {\n+        (&self.lub()).ret_styles(a, b).compare(b, || {\n             ty::terr_ret_style_mismatch(b, a)\n         })\n     }\n@@ -1970,25 +1973,25 @@ impl sub: combine {\n                 ok(a)\n               }\n               (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-                self.infcx().vars(self.tvb, a_id, b_id).then(|| ok(a) )\n+                self.infcx().vars(&self.tvb, a_id, b_id).then(|| ok(a) )\n               }\n               (ty::ty_var(a_id), _) => {\n-                self.infcx().vart(self.tvb, a_id, b).then(|| ok(a) )\n+                self.infcx().vart(&self.tvb, a_id, b).then(|| ok(a) )\n               }\n               (_, ty::ty_var(b_id)) => {\n-                self.infcx().tvar(self.tvb, a, b_id).then(|| ok(a) )\n+                self.infcx().tvar(&self.tvb, a, b_id).then(|| ok(a) )\n               }\n               (_, ty::ty_bot) => {\n                 err(ty::terr_sorts(b, a))\n               }\n               _ => {\n-                super_tys(self, a, b)\n+                super_tys(&self, a, b)\n               }\n             }\n         }\n     }\n \n-    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n+    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty> {\n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n         // that function subtyping works correctly with respect to regions\n@@ -2021,38 +2024,38 @@ impl sub: combine {\n \n         // Try to compare the supertype and subtype now that they've been\n         // instantiated.\n-        super_fns(self, a_fn_ty, b_fn_ty)\n+        super_fns(&self, &a_fn_ty, &b_fn_ty)\n     }\n \n     // Traits please:\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n+        super_flds(&self, a, b)\n     }\n \n     fn vstores(vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(self, vk, a, b)\n+        super_vstores(&self, vk, a, b)\n     }\n \n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n+        super_modes(&self, a, b)\n     }\n \n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(self, a, b)\n+        super_args(&self, a, b)\n     }\n \n-    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n-        super_substs(self, as, bs)\n+    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs> {\n+        super_substs(&self, as, bs)\n     }\n \n-    fn tps(as: ~[ty::t], bs: ~[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(self, as, bs)\n+    fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+        super_tps(&self, as, bs)\n     }\n \n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n-        super_self_tys(self, a, b)\n+        super_self_tys(&self, a, b)\n     }\n }\n \n@@ -2146,7 +2149,7 @@ impl lub: combine {\n               }\n \n               (ty::re_var(_), _) | (_, ty::re_var(_)) => {\n-                lattice_rvars(self, a, b)\n+                lattice_rvars(&self, a, b)\n               }\n \n               (f @ ty::re_free(f_id, _), ty::re_scope(s_id)) |\n@@ -2199,40 +2202,40 @@ impl lub: combine {\n     // Traits please:\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        lattice_tys(self, a, b)\n+        lattice_tys(&self, a, b)\n     }\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n+        super_flds(&self, a, b)\n     }\n \n     fn vstores(vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(self, vk, a, b)\n+        super_vstores(&self, vk, a, b)\n     }\n \n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n+        super_modes(&self, a, b)\n     }\n \n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(self, a, b)\n+        super_args(&self, a, b)\n     }\n \n-    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n-        super_fns(self, a, b)\n+    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty> {\n+        super_fns(&self, a, b)\n     }\n \n-    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n-        super_substs(self, as, bs)\n+    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs> {\n+        super_substs(&self, as, bs)\n     }\n \n-    fn tps(as: ~[ty::t], bs: ~[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(self, as, bs)\n+    fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+        super_tps(&self, as, bs)\n     }\n \n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n-        super_self_tys(self, a, b)\n+        super_self_tys(&self, a, b)\n     }\n }\n \n@@ -2344,7 +2347,7 @@ impl glb: combine {\n               }\n \n               (ty::re_var(_), _) | (_, ty::re_var(_)) => {\n-                lattice_rvars(self, a, b)\n+                lattice_rvars(&self, a, b)\n               }\n \n               (ty::re_free(f_id, _), s @ ty::re_scope(s_id)) |\n@@ -2396,42 +2399,42 @@ impl glb: combine {\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        lattice_tys(self, a, b)\n+        lattice_tys(&self, a, b)\n     }\n \n     // Traits please:\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n+        super_flds(&self, a, b)\n     }\n \n     fn vstores(vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(self, vk, a, b)\n+        super_vstores(&self, vk, a, b)\n     }\n \n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n+        super_modes(&self, a, b)\n     }\n \n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(self, a, b)\n+        super_args(&self, a, b)\n     }\n \n-    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n-        super_fns(self, a, b)\n+    fn fns(a: &ty::fn_ty, b: &ty::fn_ty) -> cres<ty::fn_ty> {\n+        super_fns(&self, a, b)\n     }\n \n-    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n-        super_substs(self, as, bs)\n+    fn substs(as: &ty::substs, bs: &ty::substs) -> cres<ty::substs> {\n+        super_substs(&self, as, bs)\n     }\n \n-    fn tps(as: ~[ty::t], bs: ~[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(self, as, bs)\n+    fn tps(as: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+        super_tps(&self, as, bs)\n     }\n \n     fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n-        super_self_tys(self, a, b)\n+        super_self_tys(&self, a, b)\n     }\n }\n \n@@ -2468,7 +2471,7 @@ impl glb: lattice_ops {\n }\n \n fn lattice_tys<L:lattice_ops combine>(\n-    self: L, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    self: &L, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     debug!{\"%s.lattice_tys(%s, %s)\", self.tag(),\n            a.to_str(self.infcx()),\n@@ -2480,18 +2483,18 @@ fn lattice_tys<L:lattice_ops combine>(\n           (_, ty::ty_bot) => self.ty_bot(a),\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n-            lattice_vars(self, self.infcx().tvb,\n+            lattice_vars(self, &self.infcx().tvb,\n                          a, a_id, b_id,\n                          |x, y| self.tys(x, y) )\n           }\n \n           (ty::ty_var(a_id), _) => {\n-            lattice_var_t(self, self.infcx().tvb, a_id, b,\n+            lattice_var_t(self, &self.infcx().tvb, a_id, b,\n                           |x, y| self.tys(x, y) )\n           }\n \n           (_, ty::ty_var(b_id)) => {\n-            lattice_var_t(self, self.infcx().tvb, b_id, a,\n+            lattice_var_t(self, &self.infcx().tvb, b_id, a,\n                           |x, y| self.tys(x, y) )\n           }\n           _ => {\n@@ -2503,17 +2506,17 @@ fn lattice_tys<L:lattice_ops combine>(\n \n // Pull out some common code from LUB/GLB for handling region vars:\n fn lattice_rvars<L:lattice_ops combine>(\n-    self: L, a: ty::region, b: ty::region) -> cres<ty::region> {\n+    self: &L, a: ty::region, b: ty::region) -> cres<ty::region> {\n \n     match (a, b) {\n       (ty::re_var(a_id), ty::re_var(b_id)) => {\n-        lattice_vars(self, self.infcx().rb,\n+        lattice_vars(self, &self.infcx().rb,\n                      a, a_id, b_id,\n                      |x, y| self.regions(x, y) )\n       }\n \n       (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) => {\n-        lattice_var_t(self, self.infcx().rb,\n+        lattice_var_t(self, &self.infcx().rb,\n                       v_id, r,\n                       |x, y| self.regions(x, y) )\n       }\n@@ -2530,8 +2533,8 @@ fn lattice_rvars<L:lattice_ops combine>(\n }\n \n fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n-    self: L, vb: vals_and_bindings<V, bounds<T>>,\n-    a_t: T, a_vid: V, b_vid: V,\n+    self: &L, vb: &vals_and_bindings<V, bounds<T>>,\n+    +a_t: T, +a_vid: V, +b_vid: V,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n \n     // The comments in this function are written for LUB and types,\n@@ -2574,8 +2577,8 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n }\n \n fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n-    self: L, vb: vals_and_bindings<V, bounds<T>>,\n-    a_id: V, b: T,\n+    self: &L, vb: &vals_and_bindings<V, bounds<T>>,\n+    +a_id: V, +b: T,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n \n     let nde_a = self.infcx().get(vb, a_id);"}]}