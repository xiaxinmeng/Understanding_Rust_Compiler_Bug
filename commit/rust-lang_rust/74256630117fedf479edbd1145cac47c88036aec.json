{"sha": "74256630117fedf479edbd1145cac47c88036aec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MjU2NjMwMTE3ZmVkZjQ3OWVkYmQxMTQ1Y2FjNDdjODgwMzZhZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-29T16:58:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-29T16:58:15Z"}, "message": "Auto merge of #57901 - lqd:issue_57362, r=nikomatsakis\n\nAdd information to higher-ranked lifetimes conflicts error messages\n\nMake these errors go through the new \"placeholder error\" code path, to have self tys displayed and make them hopefully less confusing.\n\nShould fix #57362.\n\nr? @nikomatsakis \u2014 so we can iterate on the specific wording you wanted.", "tree": {"sha": "0afb824ea81463d142c99c2cd957cc44f0b7558f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0afb824ea81463d142c99c2cd957cc44f0b7558f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74256630117fedf479edbd1145cac47c88036aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74256630117fedf479edbd1145cac47c88036aec", "html_url": "https://github.com/rust-lang/rust/commit/74256630117fedf479edbd1145cac47c88036aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74256630117fedf479edbd1145cac47c88036aec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "html_url": "https://github.com/rust-lang/rust/commit/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7"}, {"sha": "c97d13545290c559ac93442ea6dc6a93545302fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97d13545290c559ac93442ea6dc6a93545302fb", "html_url": "https://github.com/rust-lang/rust/commit/c97d13545290c559ac93442ea6dc6a93545302fb"}], "stats": {"total": 643, "additions": 427, "deletions": 216}, "files": [{"sha": "8be49b2792441ab7043e714281356ee2d8c6d827", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let (span, sub, sup) = self.get_regions();\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let anon_reg_sup = self.tcx.is_suitable_region(sup)?;\n+        let anon_reg_sup = self.tcx().is_suitable_region(sup)?;\n \n-        let anon_reg_sub = self.tcx.is_suitable_region(sub)?;\n+        let anon_reg_sub = self.tcx().is_suitable_region(sub)?;\n         let scope_def_id_sup = anon_reg_sup.def_id;\n         let bregion_sup = anon_reg_sup.boundregion;\n         let scope_def_id_sub = anon_reg_sub.def_id;\n@@ -138,7 +138,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         };\n \n \n-        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n+        struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\")\n             .span_label(span_1, main_label)\n             .span_label(span_2, String::new())\n             .span_label(span, span_label)"}, {"sha": "eeaa01375ed4da9456c0c7ca0f2d95305a4b00c3", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -26,10 +26,10 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n-        if let Some(anon_reg) = self.tcx.is_suitable_region(region) {\n+        if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-                let fndecl = match self.tcx.hir().get(node_id) {\n+            if let Some(node_id) = self.tcx().hir().as_local_node_id(def_id) {\n+                let fndecl = match self.tcx().hir().get(node_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         br: &ty::BoundRegion,\n     ) -> Option<(&'gcx hir::Ty)> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n-            tcx: self.tcx,\n+            tcx: self.tcx(),\n             bound_region: *br,\n             found_type: None,\n             current_index: ty::INNERMOST,"}, {"sha": "d34b71c33f4b43b50ee657ce5ed1b47aa4997f79", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -22,37 +22,41 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         if let Some(tables) = self.in_progress_tables {\n             let tables = tables.borrow();\n-            NiceRegionError::new(self.tcx, error.clone(), Some(&tables)).try_report().is_some()\n+            NiceRegionError::new(self, error.clone(), Some(&tables)).try_report().is_some()\n         } else {\n-            NiceRegionError::new(self.tcx, error.clone(), None).try_report().is_some()\n+            NiceRegionError::new(self, error.clone(), None).try_report().is_some()\n         }\n     }\n }\n \n pub struct NiceRegionError<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,\n     tables: Option<&'cx ty::TypeckTables<'tcx>>,\n }\n \n impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n         error: RegionResolutionError<'tcx>,\n         tables: Option<&'cx ty::TypeckTables<'tcx>>,\n     ) -> Self {\n-        Self { tcx, error: Some(error), regions: None, tables }\n+        Self { infcx, error: Some(error), regions: None, tables }\n     }\n \n     pub fn new_from_span(\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n         span: Span,\n         sub: ty::Region<'tcx>,\n         sup: ty::Region<'tcx>,\n         tables: Option<&'cx ty::TypeckTables<'tcx>>,\n     ) -> Self {\n-        Self { tcx, error: None, regions: Some((span, sub, sup)), tables }\n+        Self { infcx, error: None, regions: Some((span, sub, sup)), tables }\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n     }\n \n     pub fn try_report_from_nll(&self) -> Option<ErrorReported> {"}, {"sha": "05333f43373367e3f8a169f37e16060d5625e47b", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -24,23 +24,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n         let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n-            && self.tcx.is_suitable_region(sup).is_some()\n+            && self.tcx().is_suitable_region(sup).is_some()\n             && self.find_arg_with_region(sup, sub).is_some()\n         {\n             (\n                 sub,\n                 sup,\n                 self.find_arg_with_region(sup, sub).unwrap(),\n-                self.tcx.is_suitable_region(sup).unwrap(),\n+                self.tcx().is_suitable_region(sup).unwrap(),\n             )\n-        } else if self.is_named_region(sup) && self.tcx.is_suitable_region(sub).is_some()\n+        } else if self.is_named_region(sup) && self.tcx().is_suitable_region(sub).is_some()\n             && self.find_arg_with_region(sub, sup).is_some()\n         {\n             (\n                 sup,\n                 sub,\n                 self.find_arg_with_region(sub, sup).unwrap(),\n-                self.tcx.is_suitable_region(sub).unwrap(),\n+                self.tcx().is_suitable_region(sub).unwrap(),\n             )\n         } else {\n             return None; // inapplicable\n@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         };\n \n         struct_span_err!(\n-            self.tcx.sess,\n+            self.tcx().sess,\n             span,\n             E0621,\n             \"explicit lifetime required in {}\","}, {"sha": "cbd36a8b2db8ae2b853c3df4e386f0208912fe7d", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -47,15 +47,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             // closure, provide a specific message pointing this out.\n             if let (&SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n-                let hir = &self.tcx.hir();\n+                let hir = &self.tcx().hir();\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n                         node: Closure(_, _, _, closure_span, None),\n                         ..\n                     }) = hir.get(node_id) {\n                         let sup_sp = sup_origin.span();\n                         let origin_sp = origin.span();\n-                        let mut err = self.tcx.sess.struct_span_err(\n+                        let mut err = self.tcx().sess.struct_span_err(\n                             sup_sp,\n                             \"borrowed data cannot be stored outside of its closure\");\n                         err.span_label(sup_sp, \"cannot be stored outside of its closure\");"}, {"sha": "ebac5a0c2a69ece72ff99352f776cb3c48c55fcf", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 274, "deletions": 137, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -1,3 +1,4 @@\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::lexical_region_resolve::RegionResolutionError;\n@@ -12,7 +13,7 @@ use util::ppaux::RegionHighlightMode;\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n-    /// an anonymous region, emit an descriptive diagnostic error.\n+    /// an anonymous region, emit a descriptive diagnostic error.\n     pub(super) fn try_report_placeholder_conflict(&self) -> Option<ErrorReported> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n@@ -34,19 +35,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            ))\n-                if expected.def_id == found.def_id =>\n-            {\n-                Some(self.try_report_placeholders_trait(\n-                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n-                    cause,\n-                    Some(sub_placeholder),\n-                    Some(sup_placeholder),\n-                    expected.def_id,\n-                    expected.substs,\n-                    found.substs,\n-                ))\n-            }\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                Some(sub_placeholder),\n+                Some(sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n@@ -58,19 +55,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 _,\n-            ))\n-                if expected.def_id == found.def_id =>\n-            {\n-                Some(self.try_report_placeholders_trait(\n-                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n-                    cause,\n-                    Some(sub_placeholder),\n-                    None,\n-                    expected.def_id,\n-                    expected.substs,\n-                    found.substs,\n-                ))\n-            }\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                Some(sub_placeholder),\n+                None,\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n@@ -82,19 +75,35 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 _,\n                 _,\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            ))\n-                if expected.def_id == found.def_id =>\n-            {\n-                Some(self.try_report_placeholders_trait(\n-                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                None,\n+                Some(*sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n+\n+            Some(RegionResolutionError::SubSupConflict(\n+                vid,\n+                _,\n+                _,\n+                _,\n+                SubregionOrigin::Subtype(TypeTrace {\n                     cause,\n-                    None,\n-                    Some(*sup_placeholder),\n-                    expected.def_id,\n-                    expected.substs,\n-                    found.substs,\n-                ))\n-            }\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                None,\n+                Some(*sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(TypeTrace {\n@@ -103,19 +112,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 }),\n                 sub_region @ ty::RePlaceholder(_),\n                 sup_region @ ty::RePlaceholder(_),\n-            ))\n-                if expected.def_id == found.def_id =>\n-            {\n-                Some(self.try_report_placeholders_trait(\n-                    None,\n-                    cause,\n-                    Some(*sub_region),\n-                    Some(*sup_region),\n-                    expected.def_id,\n-                    expected.substs,\n-                    found.substs,\n-                ))\n-            }\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                None,\n+                cause,\n+                Some(*sub_region),\n+                Some(*sup_region),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(TypeTrace {\n@@ -124,19 +129,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 }),\n                 sub_region @ ty::RePlaceholder(_),\n                 sup_region,\n-            ))\n-                if expected.def_id == found.def_id =>\n-            {\n-                Some(self.try_report_placeholders_trait(\n-                    Some(sup_region),\n-                    cause,\n-                    Some(*sub_region),\n-                    None,\n-                    expected.def_id,\n-                    expected.substs,\n-                    found.substs,\n-                ))\n-            }\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(sup_region),\n+                cause,\n+                Some(*sub_region),\n+                None,\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(TypeTrace {\n@@ -145,19 +146,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 }),\n                 sub_region,\n                 sup_region @ ty::RePlaceholder(_),\n-            ))\n-                if expected.def_id == found.def_id =>\n-            {\n-                Some(self.try_report_placeholders_trait(\n-                    Some(sub_region),\n-                    cause,\n-                    None,\n-                    Some(*sup_region),\n-                    expected.def_id,\n-                    expected.substs,\n-                    found.substs,\n-                ))\n-            }\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(sub_region),\n+                cause,\n+                None,\n+                Some(*sup_region),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n \n             _ => None,\n         }\n@@ -182,32 +179,43 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         expected_substs: &'tcx Substs<'tcx>,\n         actual_substs: &'tcx Substs<'tcx>,\n     ) -> ErrorReported {\n-        let mut err = self.tcx.sess.struct_span_err(\n-            cause.span(&self.tcx),\n+        debug!(\n+            \"try_report_placeholders_trait(\\\n+             vid={:?}, \\\n+             sub_placeholder={:?}, \\\n+             sup_placeholder={:?}, \\\n+             trait_def_id={:?}, \\\n+             expected_substs={:?}, \\\n+             actual_substs={:?})\",\n+            vid, sub_placeholder, sup_placeholder, trait_def_id, expected_substs, actual_substs\n+        );\n+\n+        let mut err = self.tcx().sess.struct_span_err(\n+            cause.span(&self.tcx()),\n             &format!(\n                 \"implementation of `{}` is not general enough\",\n-                self.tcx.item_path_str(trait_def_id),\n+                self.tcx().item_path_str(trait_def_id),\n             ),\n         );\n \n         match cause.code {\n             ObligationCauseCode::ItemObligation(def_id) => {\n                 err.note(&format!(\n                     \"Due to a where-clause on `{}`,\",\n-                    self.tcx.item_path_str(def_id),\n+                    self.tcx().item_path_str(def_id),\n                 ));\n             }\n             _ => (),\n         }\n \n-        let expected_trait_ref = ty::TraitRef {\n+        let expected_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n-        };\n-        let actual_trait_ref = ty::TraitRef {\n+        });\n+        let actual_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: actual_substs,\n-        };\n+        });\n \n         // Search the expected and actual trait references to see (a)\n         // whether the sub/sup placeholders appear in them (sometimes\n@@ -218,90 +226,219 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         let mut counter = 0;\n         let mut has_sub = None;\n         let mut has_sup = None;\n-        let mut has_vid = None;\n \n-        self.tcx.for_each_free_region(&expected_trait_ref, |r| {\n+        let mut actual_has_vid = None;\n+        let mut expected_has_vid = None;\n+\n+        self.tcx().for_each_free_region(&expected_trait_ref, |r| {\n             if Some(r) == sub_placeholder && has_sub.is_none() {\n                 has_sub = Some(counter);\n                 counter += 1;\n             } else if Some(r) == sup_placeholder && has_sup.is_none() {\n                 has_sup = Some(counter);\n                 counter += 1;\n             }\n+\n+            if Some(r) == vid && expected_has_vid.is_none() {\n+                expected_has_vid = Some(counter);\n+                counter += 1;\n+            }\n         });\n \n-        self.tcx.for_each_free_region(&actual_trait_ref, |r| {\n-            if Some(r) == vid && has_vid.is_none() {\n-                has_vid = Some(counter);\n+        self.tcx().for_each_free_region(&actual_trait_ref, |r| {\n+            if Some(r) == vid && actual_has_vid.is_none() {\n+                actual_has_vid = Some(counter);\n                 counter += 1;\n             }\n         });\n \n-        let self_ty_has_vid = self\n-            .tcx\n+        let actual_self_ty_has_vid = self\n+            .tcx()\n             .any_free_region_meets(&actual_trait_ref.self_ty(), |r| Some(r) == vid);\n \n+        let expected_self_ty_has_vid = self\n+            .tcx()\n+            .any_free_region_meets(&expected_trait_ref.self_ty(), |r| Some(r) == vid);\n+\n+        let any_self_ty_has_vid = actual_self_ty_has_vid || expected_self_ty_has_vid;\n+\n+        debug!(\n+            \"try_report_placeholders_trait: actual_has_vid={:?}\",\n+            actual_has_vid\n+        );\n+        debug!(\n+            \"try_report_placeholders_trait: expected_has_vid={:?}\",\n+            expected_has_vid\n+        );\n+        debug!(\"try_report_placeholders_trait: has_sub={:?}\", has_sub);\n+        debug!(\"try_report_placeholders_trait: has_sup={:?}\", has_sup);\n+        debug!(\n+            \"try_report_placeholders_trait: actual_self_ty_has_vid={:?}\",\n+            actual_self_ty_has_vid\n+        );\n+        debug!(\n+            \"try_report_placeholders_trait: expected_self_ty_has_vid={:?}\",\n+            expected_self_ty_has_vid\n+        );\n+\n+        self.explain_actual_impl_that_was_found(\n+            &mut err,\n+            sub_placeholder,\n+            sup_placeholder,\n+            has_sub,\n+            has_sup,\n+            expected_trait_ref,\n+            actual_trait_ref,\n+            vid,\n+            expected_has_vid,\n+            actual_has_vid,\n+            any_self_ty_has_vid,\n+        );\n+\n+        err.emit();\n+        ErrorReported\n+    }\n+\n+    /// Add notes with details about the expected and actual trait refs, with attention to cases\n+    /// when placeholder regions are involved: either the trait or the self type containing\n+    /// them needs to be mentioned the closest to the placeholders.\n+    /// This makes the error messages read better, however at the cost of some complexity\n+    /// due to the number of combinations we have to deal with.\n+    fn explain_actual_impl_that_was_found(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        sub_placeholder: Option<ty::Region<'tcx>>,\n+        sup_placeholder: Option<ty::Region<'tcx>>,\n+        has_sub: Option<usize>,\n+        has_sup: Option<usize>,\n+        expected_trait_ref: ty::TraitRef<'_>,\n+        actual_trait_ref: ty::TraitRef<'_>,\n+        vid: Option<ty::Region<'tcx>>,\n+        expected_has_vid: Option<usize>,\n+        actual_has_vid: Option<usize>,\n+        any_self_ty_has_vid: bool,\n+    ) {\n+        // The weird thing here with the `maybe_highlighting_region` calls and the\n+        // the match inside is meant to be like this:\n+        //\n+        // - The match checks whether the given things (placeholders, etc) appear\n+        //   in the types are about to print\n+        // - Meanwhile, the `maybe_highlighting_region` calls set up\n+        //   highlights so that, if they do appear, we will replace\n+        //   them `'0` and whatever.  (This replacement takes place\n+        //   inside the closure given to `maybe_highlighting_region`.)\n+        //\n+        // There is some duplication between the calls -- i.e., the\n+        // `maybe_highlighting_region` checks if (e.g.) `has_sub` is\n+        // None, an then we check again inside the closure, but this\n+        // setup sort of minimized the number of calls and so form.\n+\n         RegionHighlightMode::maybe_highlighting_region(sub_placeholder, has_sub, || {\n             RegionHighlightMode::maybe_highlighting_region(sup_placeholder, has_sup, || {\n                 match (has_sub, has_sup) {\n                     (Some(n1), Some(n2)) => {\n-                        err.note(&format!(\n-                            \"`{}` must implement `{}` \\\n-                             for any two lifetimes `'{}` and `'{}`\",\n-                            expected_trait_ref.self_ty(),\n-                            expected_trait_ref,\n-                            std::cmp::min(n1, n2),\n-                            std::cmp::max(n1, n2),\n-                        ));\n+                        if any_self_ty_has_vid {\n+                            err.note(&format!(\n+                                \"`{}` would have to be implemented for the type `{}`, \\\n+                                 for any two lifetimes `'{}` and `'{}`\",\n+                                expected_trait_ref,\n+                                expected_trait_ref.self_ty(),\n+                                std::cmp::min(n1, n2),\n+                                std::cmp::max(n1, n2),\n+                            ));\n+                        } else {\n+                            err.note(&format!(\n+                                \"`{}` must implement `{}`, \\\n+                                 for any two lifetimes `'{}` and `'{}`\",\n+                                expected_trait_ref.self_ty(),\n+                                expected_trait_ref,\n+                                std::cmp::min(n1, n2),\n+                                std::cmp::max(n1, n2),\n+                            ));\n+                        }\n                     }\n                     (Some(n), _) | (_, Some(n)) => {\n+                        if any_self_ty_has_vid {\n+                            err.note(&format!(\n+                                \"`{}` would have to be implemented for the type `{}`, \\\n+                                 for any lifetime `'{}`\",\n+                                expected_trait_ref,\n+                                expected_trait_ref.self_ty(),\n+                                n,\n+                            ));\n+                        } else {\n+                            err.note(&format!(\n+                                \"`{}` must implement `{}`, for any lifetime `'{}`\",\n+                                expected_trait_ref.self_ty(),\n+                                expected_trait_ref,\n+                                n,\n+                            ));\n+                        }\n+                    }\n+                    (None, None) => RegionHighlightMode::maybe_highlighting_region(\n+                        vid,\n+                        expected_has_vid,\n+                        || {\n+                            if let Some(n) = expected_has_vid {\n+                                err.note(&format!(\n+                                    \"`{}` would have to be implemented for the type `{}`, \\\n+                                     for some specific lifetime `'{}`\",\n+                                    expected_trait_ref,\n+                                    expected_trait_ref.self_ty(),\n+                                    n,\n+                                ));\n+                            } else {\n+                                if any_self_ty_has_vid {\n+                                    err.note(&format!(\n+                                        \"`{}` would have to be implemented for the type `{}`\",\n+                                        expected_trait_ref,\n+                                        expected_trait_ref.self_ty(),\n+                                    ));\n+                                } else {\n+                                    err.note(&format!(\n+                                        \"`{}` must implement `{}`\",\n+                                        expected_trait_ref.self_ty(),\n+                                        expected_trait_ref,\n+                                    ));\n+                                }\n+                            }\n+                        },\n+                    ),\n+                }\n+            })\n+        });\n+\n+        RegionHighlightMode::maybe_highlighting_region(\n+            vid,\n+            actual_has_vid,\n+            || match actual_has_vid {\n+                Some(n) => {\n+                    if any_self_ty_has_vid {\n                         err.note(&format!(\n-                            \"`{}` must implement `{}` \\\n-                             for any lifetime `'{}`\",\n-                            expected_trait_ref.self_ty(),\n-                            expected_trait_ref,\n-                            n,\n+                            \"but `{}` is actually implemented for the type `{}`, \\\n+                             for some specific lifetime `'{}`\",\n+                            actual_trait_ref,\n+                            actual_trait_ref.self_ty(),\n+                            n\n                         ));\n-                    }\n-                    (None, None) => {\n+                    } else {\n                         err.note(&format!(\n-                            \"`{}` must implement `{}`\",\n-                            expected_trait_ref.self_ty(),\n-                            expected_trait_ref,\n+                            \"but `{}` actually implements `{}`, for some specific lifetime `'{}`\",\n+                            actual_trait_ref.self_ty(),\n+                            actual_trait_ref,\n+                            n\n                         ));\n                     }\n                 }\n-            })\n-        });\n \n-        RegionHighlightMode::maybe_highlighting_region(vid, has_vid, || match has_vid {\n-            Some(n) => {\n-                if self_ty_has_vid {\n+                _ => {\n                     err.note(&format!(\n-                        \"but `{}` only implements `{}` for the lifetime `'{}`\",\n-                        actual_trait_ref.self_ty(),\n+                        \"but `{}` is actually implemented for the type `{}`\",\n                         actual_trait_ref,\n-                        n\n-                    ));\n-                } else {\n-                    err.note(&format!(\n-                        \"but `{}` only implements `{}` for some lifetime `'{}`\",\n                         actual_trait_ref.self_ty(),\n-                        actual_trait_ref,\n-                        n\n                     ));\n                 }\n-            }\n-            None => {\n-                err.note(&format!(\n-                    \"but `{}` only implements `{}`\",\n-                    actual_trait_ref.self_ty(),\n-                    actual_trait_ref,\n-                ));\n-            }\n-        });\n-\n-        err.emit();\n-        ErrorReported\n+            },\n+        );\n     }\n }"}, {"sha": "4331518d403ddd42b770b7dd7aabe51b658aa40c", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -19,13 +19,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                     sup_r,\n                 ) = error.clone()\n             {\n-                let anon_reg_sup = self.tcx.is_suitable_region(sup_r)?;\n+                let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n                 if sub_r == &RegionKind::ReStatic &&\n-                    self.tcx.return_type_impl_trait(anon_reg_sup.def_id).is_some()\n+                    self.tcx().return_type_impl_trait(anon_reg_sup.def_id).is_some()\n                 {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n-                    let mut err = self.tcx.sess.struct_span_err(\n+                    let mut err = self.tcx().sess.struct_span_err(\n                         sp,\n                         \"cannot infer an appropriate lifetime\",\n                     );\n@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                         \"...but this borrow...\",\n                     );\n \n-                    let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n+                    let (lifetime, lt_sp_opt) = self.tcx().msg_span_from_free_region(sup_r);\n                     if let Some(lifetime_sp) = lt_sp_opt {\n                         err.span_note(\n                             lifetime_sp,\n@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                         }) => name.to_string(),\n                         _ => \"'_\".to_owned(),\n                     };\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n+                    if let Ok(snippet) = self.tcx().sess.source_map().span_to_snippet(return_sp) {\n                         err.span_suggestion(\n                             return_sp,\n                             &format!("}, {"sha": "dd8a33829eb532f444f46e2b62f296eef6d06b68", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -44,13 +44,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ref ebr) => (\n-                self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                self.tcx().parent_def_id(ebr.def_id).unwrap(),\n                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n             ),\n             _ => return None, // not a free region\n         };\n \n-        let hir = &self.tcx.hir();\n+        let hir = &self.tcx().hir();\n         if let Some(node_id) = hir.as_local_node_id(id) {\n             if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n                 let body = hir.body(body_id);\n@@ -66,7 +66,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                             let arg_ty_span = hir.span(hir.hir_to_node_id(ty_hir_id));\n                             let ty = tables.node_id_to_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx.fold_regions(&ty, &mut false, |r, _| {\n+                            let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n@@ -108,10 +108,10 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         br: ty::BoundRegion,\n         decl: &hir::FnDecl,\n     ) -> Option<Span> {\n-        let ret_ty = self.tcx.type_of(scope_def_id);\n+        let ret_ty = self.tcx().type_of(scope_def_id);\n         if let ty::FnDef(_, _) = ret_ty.sty {\n-            let sig = ret_ty.fn_sig(self.tcx);\n-            let late_bound_regions = self.tcx\n+            let sig = ret_ty.fn_sig(self.tcx());\n+            let late_bound_regions = self.tcx()\n                 .collect_referenced_late_bound_regions(&sig.output());\n             if late_bound_regions.iter().any(|r| *r == br) {\n                 return Some(decl.output.span());\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     // enable E0621 for it.\n     pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n         is_first\n-            && self.tcx\n+            && self.tcx()\n                    .opt_associated_item(scope_def_id)\n                    .map(|i| i.method_has_self_argument) == Some(true)\n     }"}, {"sha": "ec68ddaf3c852cb4156bda9ec6c76a502bc5a3eb", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -243,7 +243,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n-            let nice = NiceRegionError::new_from_span(infcx.tcx, span, o, f, Some(tables));\n+            let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n             if let Some(_error_reported) = nice.try_report_from_nll() {\n                 return;\n             }"}, {"sha": "5299ebbb1ba8a439e3ac8e35ef0327e3b7fbfa78", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -41,8 +41,8 @@ LL |     tuple_one::<Tuple>();\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: Due to a where-clause on `tuple_one`,\n-   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n-   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:96:5\n@@ -51,8 +51,8 @@ LL |     tuple_two::<Tuple>();\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: Due to a where-clause on `tuple_two`,\n-   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n-   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:105:5\n@@ -61,8 +61,8 @@ LL |     tuple_four::<Tuple>();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: Due to a where-clause on `tuple_four`,\n-   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n-   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "3bbf48cb37f58ebfd90e267a78b1a0b71f4fd288", "filename": "src/test/ui/associated-types/higher-ranked-projection.bad.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -1,12 +1,12 @@\n-error[E0308]: mismatched types\n+error: implementation of `Mirror` is not general enough\n   --> $DIR/higher-ranked-projection.rs:25:5\n    |\n LL |     foo(());\n-   |     ^^^ one type is more general than the other\n+   |     ^^^\n    |\n-   = note: expected type `Mirror`\n-              found type `Mirror`\n+   = note: Due to a where-clause on `foo`,\n+   = note: `Mirror` would have to be implemented for the type `&'0 ()`, for any lifetime `'0`\n+   = note: but `Mirror` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c5c8451a5a9db7453c3092cabc05ce6b68b2c08c", "filename": "src/test/ui/associated-types/higher-ranked-projection.good.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -3,7 +3,7 @@ error: compilation successful\n    |\n LL | / fn main() { //[good]~ ERROR compilation successful\n LL | |     foo(());\n-LL | |     //[bad]~^ ERROR E0308\n+LL | |     //[bad]~^ ERROR not general enough\n LL | | }\n    | |_^\n "}, {"sha": "1280c8cb4cb0968c199c4b2b8a82d0fde1a6f5d4", "filename": "src/test/ui/associated-types/higher-ranked-projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -23,5 +23,5 @@ fn foo<U, T>(_t: T)\n #[rustc_error]\n fn main() { //[good]~ ERROR compilation successful\n     foo(());\n-    //[bad]~^ ERROR E0308\n+    //[bad]~^ ERROR not general enough\n }"}, {"sha": "92f92e2a32a361e98351df07cd6a2e54cd7b683e", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -4,17 +4,17 @@ error: implementation of `Foo` is not general enough\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^\n    |\n-   = note: `&'0 OnlyFooIfStaticRef` must implement `Foo` for any lifetime `'0`\n-   = note: but `&'1 OnlyFooIfStaticRef` only implements `Foo` for the lifetime `'1`\n+   = note: `Foo` would have to be implemented for the type `&'0 OnlyFooIfStaticRef`, for any lifetime `'0`\n+   = note: but `Foo` is actually implemented for the type `&'1 OnlyFooIfStaticRef`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:48:5\n    |\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^\n    |\n-   = note: `A<'0, '1>` must implement `Foo` for any two lifetimes `'0` and `'1`\n-   = note: but `A<'_, '2>` only implements `Foo` for the lifetime `'2`\n+   = note: `Foo` would have to be implemented for the type `A<'0, '1>`, for any two lifetimes `'0` and `'1`\n+   = note: but `Foo` is actually implemented for the type `A<'_, '2>`, for some specific lifetime `'2`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "21d154eb2316c141f424e8401a896b02a3cb2c2f", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -4,8 +4,8 @@ error: implementation of `Deserialize` is not general enough\n LL |     assert_deserialize_owned::<&'static str>(); //~ ERROR\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `&'static str` must implement `Deserialize<'0>` for any lifetime `'0`\n-   = note: but `&str` only implements `Deserialize<'1>` for some lifetime `'1`\n+   = note: `&'static str` must implement `Deserialize<'0>`, for any lifetime `'0`\n+   = note: but `&str` actually implements `Deserialize<'1>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "630dda2694fdea25724f5d17a0bc85a655c0f6d5", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -5,8 +5,8 @@ LL | fn b() { want_foo2::<SomeStruct>(); } //~ ERROR\n    |          ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: Due to a where-clause on `want_foo2`,\n-   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n-   = note: but `SomeStruct` only implements `Foo<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n+   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`\n+   = note: but `SomeStruct` actually implements `Foo<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n "}, {"sha": "a44837a1e26fdd456463d745ce1b06b17f7b2c13", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -6,7 +6,7 @@ LL |     foo::<()>(); //~ ERROR not general enough\n    |\n    = note: Due to a where-clause on `foo`,\n    = note: `()` must implement `Trait<for<'b> fn(std::cell::Cell<&'b u32>)>`\n-   = note: but `()` only implements `Trait<fn(std::cell::Cell<&'0 u32>)>` for some lifetime `'0`\n+   = note: but `()` actually implements `Trait<fn(std::cell::Cell<&'0 u32>)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n "}, {"sha": "99c87f13672b1c9cae6afc86d17ec8b57fca9d52", "filename": "src/test/ui/hrtb/hrtb-just-for-static.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -5,8 +5,8 @@ LL |     want_hrtb::<StaticInt>() //~ ERROR\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: Due to a where-clause on `want_hrtb`,\n-   = note: `StaticInt` must implement `Foo<&'0 isize>` for any lifetime `'0`\n-   = note: but `StaticInt` only implements `Foo<&'1 isize>` for some lifetime `'1`\n+   = note: `StaticInt` must implement `Foo<&'0 isize>`, for any lifetime `'0`\n+   = note: but `StaticInt` actually implements `Foo<&'1 isize>`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:30:5\n@@ -15,8 +15,8 @@ LL |     want_hrtb::<&'a u32>() //~ ERROR\n    |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: Due to a where-clause on `want_hrtb`,\n-   = note: `&'a u32` must implement `Foo<&'0 isize>` for any lifetime `'0`\n-   = note: but `&'1 u32` only implements `Foo<&'1 isize>` for the lifetime `'1`\n+   = note: `Foo<&'0 isize>` would have to be implemented for the type `&'a u32`, for any lifetime `'0`\n+   = note: but `Foo<&'1 isize>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0094091c6bd7608bbef23860bb57ee5b07df555c", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -43,7 +43,7 @@ fn foo_hrtb_bar_not<'b,T>(mut t: T)\n     // be implemented. Thus to satisfy `&mut T : for<'a> Foo<&'a\n     // isize>`, we require `T : for<'a> Bar<&'a isize>`, but the where\n     // clause only specifies `T : Bar<&'b isize>`.\n-    foo_hrtb_bar_not(&mut t); //~ ERROR E0308\n+    foo_hrtb_bar_not(&mut t); //~ ERROR not general enough\n }\n \n fn foo_hrtb_bar_hrtb<T>(mut t: T)"}, {"sha": "c7be3790aa1c80c495cbba2d5403894eb354acec", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -1,12 +1,12 @@\n-error[E0308]: mismatched types\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-perfect-forwarding.rs:46:5\n    |\n-LL |     foo_hrtb_bar_not(&mut t); //~ ERROR E0308\n-   |     ^^^^^^^^^^^^^^^^ one type is more general than the other\n+LL |     foo_hrtb_bar_not(&mut t); //~ ERROR not general enough\n+   |     ^^^^^^^^^^^^^^^^\n    |\n-   = note: expected type `Foo<&'a isize>`\n-              found type `Foo<&isize>`\n+   = note: Due to a where-clause on `foo_hrtb_bar_not`,\n+   = note: `&mut T` must implement `Foo<&'0 isize>`, for any lifetime `'0`\n+   = note: but `&mut T` actually implements `Foo<&'1 isize>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "98637611b79fec92617241c56af0e633e5e6f888", "filename": "src/test/ui/issues/issue-54302-cases.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -4,35 +4,35 @@ error: implementation of `Foo` is not general enough\n LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `&'0 u32` must implement `Foo<'static, u32>` for any lifetime `'0`\n-   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n+   = note: `Foo<'static, u32>` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`\n+   = note: but `Foo<'_, u32>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:69:5\n    |\n LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `&'0 i32` must implement `Foo<'static, i32>` for any lifetime `'0`\n-   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n+   = note: `Foo<'static, i32>` would have to be implemented for the type `&'0 i32`, for any lifetime `'0`\n+   = note: but `Foo<'_, i32>` is actually implemented for the type `&'1 i32`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:75:5\n    |\n LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `&'0 u64` must implement `Foo<'static, u64>` for any lifetime `'0`\n-   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n+   = note: `Foo<'static, u64>` would have to be implemented for the type `&'0 u64`, for any lifetime `'0`\n+   = note: but `Foo<'_, u64>` is actually implemented for the type `&'1 u64`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:81:5\n    |\n LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `&'0 i64` must implement `Foo<'static, i64>` for any lifetime `'0`\n-   = note: but `&'1 _` only implements `Foo<'_, _>` for the lifetime `'1`\n+   = note: `Foo<'static, i64>` would have to be implemented for the type `&'0 i64`, for any lifetime `'0`\n+   = note: but `Foo<'_, i64>` is actually implemented for the type `&'1 i64`, for some specific lifetime `'1`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c6d0805f3ab2a2d629f6070c77c451d6b70bc1c6", "filename": "src/test/ui/issues/issue-54302.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -4,8 +4,8 @@ error: implementation of `Deserialize` is not general enough\n LL |     assert_deserialize_owned::<&'static str>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `&'static str` must implement `Deserialize<'0>` for any lifetime `'0`\n-   = note: but `&str` only implements `Deserialize<'1>` for some lifetime `'1`\n+   = note: `&'static str` must implement `Deserialize<'0>`, for any lifetime `'0`\n+   = note: but `&str` actually implements `Deserialize<'1>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "fe6b69f00977dd89a2a8ec22c0dcffa19faba52c", "filename": "src/test/ui/issues/issue-57362-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -0,0 +1,23 @@\n+// Test for issue #57362, ensuring that the self ty is shown in cases of higher-ranked lifetimes\n+// conflicts: the `expected` and `found` trait refs would otherwise be printed the same, leading\n+// to confusing notes such as:\n+//  = note: expected type `Trait`\n+//             found type `Trait`\n+\n+// from issue #57362\n+trait Trait {\n+    fn f(self);\n+}\n+\n+impl<T> Trait for fn(&T) {\n+    fn f(self) {\n+        println!(\"f\");\n+    }\n+}\n+\n+fn f() {\n+    let a: fn(_) = |_: &u8| {};\n+    a.f(); //~ ERROR not general enough\n+}\n+\n+fn main() {}"}, {"sha": "06946bcf744a75a6f6fa09a4b27c6a8da4ba3c7f", "filename": "src/test/ui/issues/issue-57362-1.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -0,0 +1,11 @@\n+error: implementation of `Trait` is not general enough\n+  --> $DIR/issue-57362-1.rs:20:7\n+   |\n+LL |     a.f(); //~ ERROR not general enough\n+   |       ^\n+   |\n+   = note: `Trait` would have to be implemented for the type `fn(&'0 u8)`, for some specific lifetime `'0`\n+   = note: but `Trait` is actually implemented for the type `for<'r> fn(&'r u8)`\n+\n+error: aborting due to previous error\n+"}, {"sha": "436a4a904576dff5fffcec53d883b1db3e7d5c7d", "filename": "src/test/ui/issues/issue-57362-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.rs?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -0,0 +1,25 @@\n+// Test for issue #57362, ensuring that the self ty is shown in cases of higher-ranked lifetimes\n+// conflicts: the `expected` and `found` trait refs would otherwise be printed the same, leading\n+// to confusing notes such as:\n+//  = note: expected type `Trait`\n+//             found type `Trait`\n+\n+// extracted from a similar issue: #57642\n+trait X {\n+    type G;\n+    fn make_g() -> Self::G;\n+}\n+\n+impl<'a> X for fn(&'a ()) {\n+    type G = &'a ();\n+\n+    fn make_g() -> Self::G {\n+        &()\n+    }\n+}\n+\n+fn g() {\n+    let x = <fn (&())>::make_g(); //~ ERROR not general enough\n+}\n+\n+fn main() {}"}, {"sha": "14b7f52bb87992e74be3901495747efe9f332ee5", "filename": "src/test/ui/issues/issue-57362-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-2.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -0,0 +1,11 @@\n+error: implementation of `X` is not general enough\n+  --> $DIR/issue-57362-2.rs:22:13\n+   |\n+LL |     let x = <fn (&())>::make_g(); //~ ERROR not general enough\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `X` would have to be implemented for the type `for<'r> fn(&'r ())`\n+   = note: but `X` is actually implemented for the type `fn(&'0 ())`, for some specific lifetime `'0`\n+\n+error: aborting due to previous error\n+"}, {"sha": "342cabfd6bf0a0da42022f02a61bcfba35c4dd58", "filename": "src/test/ui/where-clauses/where-for-self-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74256630117fedf479edbd1145cac47c88036aec/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr?ref=74256630117fedf479edbd1145cac47c88036aec", "patch": "@@ -5,8 +5,8 @@ LL |     foo(&X); //~ ERROR implementation of `Bar` is not general enough\n    |     ^^^\n    |\n    = note: Due to a where-clause on `foo`,\n-   = note: `&'0 _` must implement `Bar` for any lifetime `'0`\n-   = note: but `&'1 u32` only implements `Bar` for the lifetime `'1`\n+   = note: `Bar` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`\n+   = note: but `Bar` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}]}