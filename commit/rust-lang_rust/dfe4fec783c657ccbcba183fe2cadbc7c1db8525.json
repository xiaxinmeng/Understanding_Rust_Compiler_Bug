{"sha": "dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZTRmZWM3ODNjNjU3Y2NiY2JhMTgzZmUyY2FkYmM3YzFkYjg1MjU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-08-02T15:44:04Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-08-05T21:08:29Z"}, "message": "Remove LightSpan and use Span directly", "tree": {"sha": "c6a50c9dac6895072387e5029000f447bdcd924f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6a50c9dac6895072387e5029000f447bdcd924f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "html_url": "https://github.com/rust-lang/rust/commit/dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cf300d695c4ac6e4bdab8fe5c48de6b05b2cd96", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf300d695c4ac6e4bdab8fe5c48de6b05b2cd96", "html_url": "https://github.com/rust-lang/rust/commit/5cf300d695c4ac6e4bdab8fe5c48de6b05b2cd96"}], "stats": {"total": 142, "additions": 44, "deletions": 98}, "files": [{"sha": "3cdb1352bef956045502b1d557e4d49ffe2c7209", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "patch": "@@ -14,20 +14,16 @@ use std::iter::Peekable;\n use rustc_lexer::{LiteralKind, TokenKind};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use super::format::{self, Buffer};\n-use super::render::{LightSpan, LinkFromSrc};\n+use super::render::LinkFromSrc;\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n crate struct ContextInfo<'a, 'b, 'c> {\n     crate context: &'a Context<'b>,\n-    /// This represents the \"lo\" bytes of the current file we're rendering. To get a [`Span`] from\n-    /// it, you just need to add add your current byte position in the string and its length (to get\n-    /// the \"hi\" part).\n-    ///\n-    /// This is used to create a [`LightSpan`] which is then used as an index in the `span_map` in\n-    /// order to retrieve the definition's [`Span`] (which is used to generate the URL).\n-    crate file_span_lo: u32,\n+    /// This span contains the current file we're going through.\n+    crate file_span: Span,\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n     crate root_path: &'c str,\n@@ -86,7 +82,6 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n /// item definition.\n ///\n /// More explanations about spans and how we use them here are provided in the\n-/// [`LightSpan::new_in_file`] function documentation about how it works.\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n@@ -95,7 +90,7 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    Classifier::new(&src, edition, context_info.as_ref().map(|c| c.file_span_lo).unwrap_or(0))\n+    Classifier::new(&src, edition, context_info.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP))\n         .highlight(&mut |highlight| {\n             match highlight {\n                 Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n@@ -118,14 +113,14 @@ enum Class {\n     KeyWord,\n     // Keywords that do pointer/reference stuff.\n     RefKeyWord,\n-    Self_(LightSpan),\n+    Self_(Span),\n     Op,\n     Macro,\n     MacroNonTerminal,\n     String,\n     Number,\n     Bool,\n-    Ident(LightSpan),\n+    Ident(Span),\n     Lifetime,\n     PreludeTy,\n     PreludeVal,\n@@ -158,7 +153,7 @@ impl Class {\n \n     /// In case this is an item which can be converted into a link to a definition, it'll contain\n     /// a \"span\" (a tuple representing `(lo, hi)` equivalent of `Span`).\n-    fn get_span(self) -> Option<LightSpan> {\n+    fn get_span(self) -> Option<Span> {\n         match self {\n             Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n             _ => None,\n@@ -213,15 +208,14 @@ struct Classifier<'a> {\n     in_macro_nonterminal: bool,\n     edition: Edition,\n     byte_pos: u32,\n-    file_span_lo: u32,\n+    file_span: Span,\n     src: &'a str,\n }\n \n impl<'a> Classifier<'a> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n-    /// file \"lo\" byte which we be used later on by the `span_correspondance_map`. More explanations\n-    /// are provided in the [`LightSpan::new_in_file`] function documentation about how it works.\n-    fn new(src: &str, edition: Edition, file_span_lo: u32) -> Classifier<'_> {\n+    /// file span which will be used later on by the `span_correspondance_map`.\n+    fn new(src: &str, edition: Edition, file_span: Span) -> Classifier<'_> {\n         let tokens = TokenIter { src }.peekable();\n         Classifier {\n             tokens,\n@@ -230,15 +224,16 @@ impl<'a> Classifier<'a> {\n             in_macro_nonterminal: false,\n             edition,\n             byte_pos: 0,\n-            file_span_lo,\n+            file_span,\n             src,\n         }\n     }\n \n-    /// Convenient wrapper around [`LightSpan::new_in_file`] to prevent passing the `file_span_lo`\n-    /// argument every time.\n-    fn new_light_span(&self, lo: u32, hi: u32) -> LightSpan {\n-        LightSpan::new_in_file(self.file_span_lo, lo, hi)\n+    /// Convenient wrapper to create a [`Span`] from a position in the file.\n+    fn new_span(&self, lo: u32, text: &str) -> Span {\n+        let hi = lo + text.len() as u32;\n+        let file_lo = self.file_span.lo();\n+        self.file_span.with_lo(file_lo + BytePos(lo)).with_hi(file_lo + BytePos(hi))\n     }\n \n     /// Concatenate colons and idents as one when possible.\n@@ -487,15 +482,13 @@ impl<'a> Classifier<'a> {\n                         self.in_macro_nonterminal = false;\n                         Class::MacroNonTerminal\n                     }\n-                    \"self\" | \"Self\" => {\n-                        Class::Self_(self.new_light_span(before, before + text.len() as u32))\n-                    }\n-                    _ => Class::Ident(self.new_light_span(before, before + text.len() as u32)),\n+                    \"self\" | \"Self\" => Class::Self_(self.new_span(before, text)),\n+                    _ => Class::Ident(self.new_span(before, text)),\n                 },\n                 Some(c) => c,\n             },\n             TokenKind::RawIdent | TokenKind::UnknownPrefix => {\n-                Class::Ident(self.new_light_span(before, before + text.len() as u32))\n+                Class::Ident(self.new_span(before, text))\n             }\n             TokenKind::Lifetime { .. } => Class::Lifetime,\n         };\n@@ -560,7 +553,7 @@ fn string<T: Display>(\n                 \"self\" | \"Self\" => write!(\n                     &mut path,\n                     \"<span class=\\\"{}\\\">{}</span>\",\n-                    Class::Self_(LightSpan::dummy()).as_html(),\n+                    Class::Self_(DUMMY_SP).as_html(),\n                     t\n                 ),\n                 \"crate\" | \"super\" => {"}, {"sha": "6ce0828e159402b867eb447921efc0d2e6ada44c", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "patch": "@@ -18,8 +18,8 @@ use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n use super::{\n-    collect_spans_and_sources, print_sidebar, settings, AllTypes, LightSpan, LinkFromSrc, NameDoc,\n-    StylePath, BASIC_KEYWORDS,\n+    collect_spans_and_sources, print_sidebar, settings, AllTypes, LinkFromSrc, NameDoc, StylePath,\n+    BASIC_KEYWORDS,\n };\n \n use crate::clean;\n@@ -131,7 +131,7 @@ crate struct SharedContext<'tcx> {\n \n     /// Correspondance map used to link types used in the source code pages to allow to click on\n     /// links to jump to the type's definition.\n-    crate span_correspondance_map: FxHashMap<LightSpan, LinkFromSrc>,\n+    crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n }\n \n impl SharedContext<'_> {"}, {"sha": "fd2e18a8be77f0d3933d14c4e1174076649ec3d6", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "patch": "@@ -34,7 +34,7 @@ mod span_map;\n mod write_shared;\n \n crate use context::*;\n-crate use span_map::{collect_spans_and_sources, LightSpan, LinkFromSrc};\n+crate use span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;"}, {"sha": "b35cd45dc9a886c60979dd15ba134df14b162a6a", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 8, "deletions": 53, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "patch": "@@ -24,43 +24,6 @@ crate enum LinkFromSrc {\n     External(DefId),\n }\n \n-/// This struct is used only as index in the `span_map`, not as [`Span`]! `Span`s contain\n-/// some extra information (the syntax context) we don't need. **Do not convert this type back to\n-/// `Span`!!!**\n-#[derive(Clone, Copy, Hash, PartialEq, Eq, Debug)]\n-crate struct LightSpan {\n-    crate lo: u32,\n-    crate hi: u32,\n-}\n-\n-impl LightSpan {\n-    /// Before explaining what this method does, some global explanations on rust's `Span`:\n-    ///\n-    /// Each source code file is stored in the source map in the compiler and has a\n-    /// `lo` and a `hi` (lowest and highest bytes in this source map which can be seen as one huge\n-    /// string to simplify things). So in this case, this represents the starting byte of the\n-    /// current file. It'll be used later on to retrieve the \"definition span\" from the\n-    /// `span_correspondance_map` (which is inside `context`).\n-    ///\n-    /// This when we transform the \"span\" we have from reading the input into a \"span\" which can be\n-    /// used as index to the `span_correspondance_map` to get the definition of this item.\n-    ///\n-    /// So in here, `file_span_lo` is representing the \"lo\" byte in the global source map, and to\n-    /// make our \"span\" works in there, we simply add `file_span_lo` to our values.\n-    crate fn new_in_file(file_span_lo: u32, lo: u32, hi: u32) -> Self {\n-        Self { lo: lo + file_span_lo, hi: hi + file_span_lo }\n-    }\n-\n-    crate fn dummy() -> Self {\n-        Self { lo: 0, hi: 0 }\n-    }\n-\n-    /// Extra the `lo` and `hi` from the [`Span`] and discard the unused syntax context.\n-    fn new_from_span(sp: Span) -> Self {\n-        Self { lo: sp.lo().0, hi: sp.hi().0 }\n-    }\n-}\n-\n /// This function will do at most two things:\n ///\n /// 1. Generate a `span` correspondance map which links an item `span` to its definition `span`.\n@@ -77,7 +40,7 @@ crate fn collect_spans_and_sources(\n     src_root: &Path,\n     include_sources: bool,\n     generate_link_to_definition: bool,\n-) -> (clean::Crate, FxHashMap<PathBuf, String>, FxHashMap<LightSpan, LinkFromSrc>) {\n+) -> (clean::Crate, FxHashMap<PathBuf, String>, FxHashMap<Span, LinkFromSrc>) {\n     let mut visitor = SpanMapVisitor { tcx, matches: FxHashMap::default() };\n \n     if include_sources {\n@@ -93,7 +56,7 @@ crate fn collect_spans_and_sources(\n \n struct SpanMapVisitor<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n-    crate matches: FxHashMap<LightSpan, LinkFromSrc>,\n+    crate matches: FxHashMap<Span, LinkFromSrc>,\n }\n \n impl<'tcx> SpanMapVisitor<'tcx> {\n@@ -115,18 +78,12 @@ impl<'tcx> SpanMapVisitor<'tcx> {\n         };\n         if let Some(span) = self.tcx.hir().res_span(path.res) {\n             self.matches.insert(\n-                path_span\n-                    .map(LightSpan::new_from_span)\n-                    .unwrap_or_else(|| LightSpan::new_from_span(path.span)),\n+                path_span.unwrap_or_else(|| path.span),\n                 LinkFromSrc::Local(clean::Span::new(span)),\n             );\n         } else if let Some(def_id) = info {\n-            self.matches.insert(\n-                path_span\n-                    .map(LightSpan::new_from_span)\n-                    .unwrap_or_else(|| LightSpan::new_from_span(path.span)),\n-                LinkFromSrc::External(def_id),\n-            );\n+            self.matches\n+                .insert(path_span.unwrap_or_else(|| path.span), LinkFromSrc::External(def_id));\n         }\n     }\n }\n@@ -163,10 +120,8 @@ impl Visitor<'tcx> for SpanMapVisitor<'tcx> {\n             if let Some(node) = self.tcx.hir().find(id) {\n                 match node {\n                     Node::Item(item) => {\n-                        self.matches.insert(\n-                            LightSpan::new_from_span(item.ident.span),\n-                            LinkFromSrc::Local(clean::Span::new(m.inner)),\n-                        );\n+                        self.matches\n+                            .insert(item.ident.span, LinkFromSrc::Local(clean::Span::new(m.inner)));\n                     }\n                     _ => {}\n                 }\n@@ -188,7 +143,7 @@ impl Visitor<'tcx> for SpanMapVisitor<'tcx> {\n                     });\n                     if let Some(def_id) = typeck_results.type_dependent_def_id(expr.hir_id) {\n                         self.matches.insert(\n-                            LightSpan::new_from_span(method_span),\n+                            method_span,\n                             match hir.span_if_local(def_id) {\n                                 Some(span) => LinkFromSrc::Local(clean::Span::new(span)),\n                                 None => LinkFromSrc::External(def_id),"}, {"sha": "73916e204d9426aa805a9e8915f0ac5bdcccd83f", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe4fec783c657ccbcba183fe2cadbc7c1db8525/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=dfe4fec783c657ccbcba183fe2cadbc7c1db8525", "patch": "@@ -111,13 +111,14 @@ impl DocFolder for SourceCollector<'_, '_> {\n         if self.cx.include_sources && is_real_and_local(span, sess) {\n             let filename = span.filename(sess);\n             let span = span.inner();\n-            let start_pos = sess.source_map().lookup_source_file(span.lo()).start_pos;\n+            let pos = sess.source_map().lookup_source_file(span.lo());\n+            let file_span = span.with_lo(pos.start_pos).with_hi(pos.end_pos);\n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx.include_sources = match self.emit_source(&filename, start_pos.0) {\n+            self.cx.include_sources = match self.emit_source(&filename, file_span) {\n                 Ok(()) => true,\n                 Err(e) => {\n                     self.cx.shared.tcx.sess.span_err(\n@@ -140,7 +141,11 @@ impl DocFolder for SourceCollector<'_, '_> {\n \n impl SourceCollector<'_, 'tcx> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName, file_span_lo: u32) -> Result<(), Error> {\n+    fn emit_source(\n+        &mut self,\n+        filename: &FileName,\n+        file_span: rustc_span::Span,\n+    ) -> Result<(), Error> {\n         let p = match *filename {\n             FileName::Real(ref file) => {\n                 if let Some(local_path) = file.local_path() {\n@@ -200,14 +205,7 @@ impl SourceCollector<'_, 'tcx> {\n             &page,\n             \"\",\n             |buf: &mut _| {\n-                print_src(\n-                    buf,\n-                    contents,\n-                    self.cx.shared.edition(),\n-                    file_span_lo,\n-                    &self.cx,\n-                    &root_path,\n-                )\n+                print_src(buf, contents, self.cx.shared.edition(), file_span, &self.cx, &root_path)\n             },\n             &self.cx.shared.style_files,\n         );\n@@ -250,7 +248,7 @@ fn print_src(\n     buf: &mut Buffer,\n     s: &str,\n     edition: Edition,\n-    file_span_lo: u32,\n+    file_span: rustc_span::Span,\n     context: &Context<'_>,\n     root_path: &str,\n ) {\n@@ -275,6 +273,6 @@ fn print_src(\n         None,\n         edition,\n         Some(line_numbers),\n-        Some(highlight::ContextInfo { context, file_span_lo, root_path }),\n+        Some(highlight::ContextInfo { context, file_span, root_path }),\n     );\n }"}]}