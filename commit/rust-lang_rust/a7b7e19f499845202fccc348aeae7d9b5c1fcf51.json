{"sha": "a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YjdlMTlmNDk5ODQ1MjAyZmNjYzM0OGFlYWU3ZDliNWMxZmNmNTE=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-09-26T09:03:36Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-09-26T09:03:36Z"}, "message": "Rustup https://github.com/rust-lang/rust/pull/64513", "tree": {"sha": "093af6f817397318cb7b0680be65e6157034c631", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/093af6f817397318cb7b0680be65e6157034c631"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "html_url": "https://github.com/rust-lang/rust/commit/a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "html_url": "https://github.com/rust-lang/rust/commit/adc1df11b4d8ef005363585dc4d3ee2a03dfed08"}], "stats": {"total": 248, "additions": 124, "deletions": 124}, "files": [{"sha": "845b1e0514f6374a1b55753849244365abf41cbc", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n+                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).kind {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args) ="}, {"sha": "401a63698a23ade17184ea6396e88a95d6756fde", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -124,7 +124,7 @@ impl Constant {\n             (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n             (&Self::Int(l), &Self::Int(r)) => {\n-                if let ty::Int(int_ty) = cmp_type.sty {\n+                if let ty::Int(int_ty) = cmp_type.kind {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n@@ -161,7 +161,7 @@ pub fn lit_to_constant(lit: &LitKind, ty: Ty<'_>) -> Constant {\n         LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n-        LitKind::Float(ref is, _) | LitKind::FloatUnsuffixed(ref is) => match ty.sty {\n+        LitKind::Float(ref is, _) | LitKind::FloatUnsuffixed(ref is) => match ty.kind {\n             ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n             ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n             _ => bug!(),\n@@ -229,7 +229,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n-                let n = match self.tables.expr_ty(e).sty {\n+                let n = match self.tables.expr_ty(e).kind {\n                     ty::Array(_, n) => n.eval_usize(self.lcx.tcx, self.lcx.param_env),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n@@ -286,7 +286,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             Bool(b) => Some(Bool(!b)),\n             Int(value) => {\n                 let value = !value;\n-                match ty.sty {\n+                match ty.kind {\n                     ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n                     ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n                     _ => None,\n@@ -300,7 +300,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         use self::Constant::*;\n         match *o {\n             Int(value) => {\n-                let ity = match ty.sty {\n+                let ity = match ty.kind {\n                     ty::Int(ity) => ity,\n                     _ => return None,\n                 };\n@@ -378,7 +378,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty(left).sty {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty(left).kind {\n                 ty::Int(ity) => {\n                     let l = sext(self.lcx.tcx, l, ity);\n                     let r = sext(self.lcx.tcx, r, ity);\n@@ -470,7 +470,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n     use rustc::mir::interpret::{ConstValue, Scalar};\n     match result.val {\n-        ConstValue::Scalar(Scalar::Raw { data: d, .. }) => match result.ty.sty {\n+        ConstValue::Scalar(Scalar::Raw { data: d, .. }) => match result.ty.kind {\n             ty::Bool => Some(Constant::Bool(d == 1)),\n             ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n             ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n@@ -480,16 +480,16 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 d.try_into().expect(\"invalid f64 bit representation\"),\n             ))),\n             ty::RawPtr(type_and_mut) => {\n-                if let ty::Uint(_) = type_and_mut.ty.sty {\n+                if let ty::Uint(_) = type_and_mut.ty.kind {\n                     return Some(Constant::RawPtr(d));\n                 }\n                 None\n             },\n             // FIXME: implement other conversions.\n             _ => None,\n         },\n-        ConstValue::Slice { data, start, end } => match result.ty.sty {\n-            ty::Ref(_, tam, _) => match tam.sty {\n+        ConstValue::Slice { data, start, end } => match result.ty.kind {\n+            ty::Ref(_, tam, _) => match tam.kind {\n                 ty::Str => String::from_utf8(\n                     data.inspect_with_undef_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),"}, {"sha": "73c17c702b6169144d555473020bee9299e771ca", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n                         let expr_ty = cx.tables.expr_ty(expr);\n-                        if let ty::Adt(..) = expr_ty.sty {\n+                        if let ty::Adt(..) = expr_ty.kind {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg(\n                                 cx,"}, {"sha": "6be04dfa687bcaba441e3b2098ff4401b287e667", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -134,20 +134,20 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n             return;\n         }\n \n-        match ty.sty {\n+        match ty.kind {\n             ty::Adt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n             ty::Adt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n-                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).sty {\n+                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind {\n                             return;\n                         }\n                     }\n                     for subst in substs {\n                         if let ty::subst::UnpackedKind::Type(subst) = subst.unpack() {\n-                            if let ty::Param(_) = subst.sty {\n+                            if let ty::Param(_) = subst.kind {\n                                 return;\n                             }\n                         }"}, {"sha": "29a35c05ecaa5d96f081b1bcc4fc301ee0f45063", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n                 let arg = &args[0];\n                 let arg_ty = cx.tables.expr_ty(arg);\n \n-                if let ty::Ref(..) = arg_ty.sty {\n+                if let ty::Ref(..) = arg_ty.kind {\n                     if match_def_path(cx, def_id, &paths::DROP) {\n                         lint = DROP_REF;\n                         msg = DROP_REF_SUMMARY.to_string();"}, {"sha": "b74cb9862678e4641dd11140a81561f20daa2f3a", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -57,12 +57,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                     let constant = cx.tcx.const_eval(param_env.and(c_id)).ok();\n                     if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n                         let mut ty = cx.tcx.type_of(def_id);\n-                        if let ty::Adt(adt, _) = ty.sty {\n+                        if let ty::Adt(adt, _) = ty.kind {\n                             if adt.is_enum() {\n                                 ty = adt.repr.discr_type().to_ty(cx.tcx);\n                             }\n                         }\n-                        match ty.sty {\n+                        match ty.kind {\n                             ty::Int(IntTy::Isize) => {\n                                 let val = ((val as i128) << 64) >> 64;\n                                 if i32::try_from(val).is_ok() {"}, {"sha": "a92ac5865d95945f375ea3a81d1aeb1731b8020e", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -94,7 +94,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n \n             let fn_ty = cx.tables.expr_ty(caller);\n \n-            if matches!(fn_ty.sty, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n+            if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n \n             if !type_is_unsafe_function(cx, fn_ty);\n \n@@ -171,7 +171,7 @@ fn get_ufcs_type_name(\n }\n \n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.sty, &rhs.sty) {\n+    match (&lhs.kind, &rhs.kind) {\n         (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n         (l, r) => match (l, r) {\n             (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n@@ -181,7 +181,7 @@ fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n }\n \n fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.sty, &rhs.sty) {\n+    match (&lhs.kind, &rhs.kind) {\n         (ty::Bool, ty::Bool)\n         | (ty::Char, ty::Char)\n         | (ty::Int(_), ty::Int(_))\n@@ -195,7 +195,7 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n }\n \n fn get_type_name(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> String {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n         ty::Ref(_, r, _) => get_type_name(cx, &r),\n         _ => ty.to_string(),"}, {"sha": "83da6dd589e07a7fa2edc00b29c255a914e4eb1f", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -128,10 +128,10 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n-                match typ.sty {\n+                match typ.kind {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n-                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().sty {\n+                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().kind {\n                             self.report_diverging_sub_expr(e);\n                         }\n                     },"}, {"sha": "c95e536d140647a9f450e76643d221f79022d87f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n-            if let ty::Float(fty) = ty.sty;\n+            if let ty::Float(fty) = ty.kind;\n             if let hir::ExprKind::Lit(ref lit) = expr.node;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);"}, {"sha": "4b6a2eaf796f8ddc6152d756fafc779a310cfc33", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -123,7 +123,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n }\n \n fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }"}, {"sha": "85d360afd816191cf540e6a13eeb950e2ff923be", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -89,7 +89,7 @@ fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arm\n         if pats.len() == 1;\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pats[0]));\n-            if ty.sty != rustc::ty::Str && !match_type(cx, ty, &paths::STRING) {\n+            if ty.kind != rustc::ty::Str && !match_type(cx, ty, &paths::STRING) {\n                 return None;\n             }\n             if let ExprKind::Lit(ref lit) = format_args.node {"}, {"sha": "f4b98fc60caeb7df668ba2de4802a8a8c85b15c3", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_, '_>, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n-        let check = match cx.tables.expr_ty(e).sty {\n+        let check = match cx.tables.expr_ty(e).kind {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n             ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,"}, {"sha": "d9924212e2ecc7a84e1777176b51f5e49cabe63d", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n-                if let ty::Array(_, s) = ty.sty {\n+                if let ty::Array(_, s) = ty.kind {\n                     let size: u128 = s.eval_usize(cx.tcx, cx.param_env).into();\n \n                     let const_range = to_const_range(cx, range, size);\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n                 utils::span_help_and_lint(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", help_msg);\n             } else {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n-                if let ty::Array(..) = ty.sty {\n+                if let ty::Array(..) = ty.kind {\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.tables, index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays."}, {"sha": "ef924775a18fb779f96f275a78defc07cf3d3852", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -280,7 +280,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     }\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n-    match ty.sty {\n+    match ty.kind {\n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n                 cx.tcx"}, {"sha": "006f8833afcb495b00513c3f21486997ec6f32fd", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -787,7 +787,7 @@ struct FixedOffsetVar {\n }\n \n fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n-    let is_slice = match ty.sty {\n+    let is_slice = match ty.kind {\n         ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n         ty::Slice(..) | ty::Array(..) => true,\n         _ => false,\n@@ -1225,7 +1225,7 @@ fn is_end_eq_array_len<'tcx>(\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = end.node;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n-        if let ty::Array(_, arr_len_const) = indexed_ty.sty;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind;\n         if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n         then {\n             return match limits {\n@@ -1256,7 +1256,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n                 let ty = cx.tables.expr_ty(start);\n                 let (sup, eq) = match (start_idx, end_idx) {\n                     (Constant::Int(start_idx), Constant::Int(end_idx)) => (\n-                        match ty.sty {\n+                        match ty.kind {\n                             ty::Int(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n                             ty::Uint(_) => start_idx > end_idx,\n                             _ => false,\n@@ -1345,7 +1345,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                 let fn_arg_tys = method_type.fn_sig(cx.tcx).inputs();\n                 assert_eq!(fn_arg_tys.skip_binder().len(), 1);\n                 if fn_arg_tys.skip_binder()[0].is_region_ptr() {\n-                    match cx.tables.expr_ty(&args[0]).sty {\n+                    match cx.tables.expr_ty(&args[0]).kind {\n                         // If the length is greater than 32 no traits are implemented for array and\n                         // therefore we cannot use `&`.\n                         ty::Array(_, size) if size.eval_usize(cx.tcx, cx.param_env) > 32 => {},\n@@ -1497,7 +1497,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.node {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).sty {\n+            let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).kind {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].node, &pat[1].node) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, MutImmutable),\n@@ -1852,7 +1852,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 for expr in args {\n                     let ty = self.cx.tables.expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.sty {\n+                    if let ty::Ref(_, _, mutbl) = ty.kind {\n                         if mutbl == MutMutable {\n                             self.prefer_mutable = true;\n                         }\n@@ -1864,7 +1864,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 let def_id = self.cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.sty {\n+                    if let ty::Ref(_, _, mutbl) = ty.kind {\n                         if mutbl == MutMutable {\n                             self.prefer_mutable = true;\n                         }\n@@ -1960,7 +1960,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n \n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'_, 'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.sty {\n+    match ty.kind {\n         ty::Array(_, n) => (0..=32).contains(&n.eval_usize(cx.tcx, cx.param_env)),\n         _ => false,\n     }"}, {"sha": "b6264af9dfaa2852f64f5b21c3c98b066d512932", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n                                     let obj_ty = cx.tables.expr_ty(&obj[0]);\n-                                    if let ty::Ref(_, ty, _) = obj_ty.sty {\n+                                    if let ty::Ref(_, ty, _) = obj_ty.kind {\n                                         let copy = is_copy(cx, ty);\n                                         lint(cx, e.span, args[0].span, copy);\n                                     } else {"}, {"sha": "ddbd4e961d991847afed872f7923e58096c284e7", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -94,7 +94,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MapUnit => [OPTION_MAP_UNIT_FN, RESULT_MAP_UNIT_FN]);\n \n fn is_unit_type(ty: Ty<'_>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Tuple(slice) => slice.is_empty(),\n         ty::Never => true,\n         _ => false,\n@@ -104,7 +104,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n-    if let ty::FnDef(id, _) = ty.sty {\n+    if let ty::FnDef(id, _) = ty.kind {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_bound_vars() {\n             return is_unit_type(fn_type.output());\n         }"}, {"sha": "1c5a8f6240c6c129d624c69a35eaa2388075d1a7", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -271,7 +271,7 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n             return;\n         };\n         let ty = cx.tables.expr_ty(ex);\n-        if ty.sty != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+        if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }\n@@ -360,7 +360,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // Type of expression is `bool`.\n-    if cx.tables.expr_ty(ex).sty == ty::Bool {\n+    if cx.tables.expr_ty(ex).kind == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -497,7 +497,7 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n         // already covered.\n \n         let mut missing_variants = vec![];\n-        if let ty::Adt(def, _) = ty.sty {\n+        if let ty::Adt(def, _) = ty.kind {\n             for variant in &def.variants {\n                 missing_variants.push(variant);\n             }\n@@ -622,11 +622,11 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n             let input_ty = cx.tables.expr_ty(ex);\n \n             let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.sty;\n+                if let ty::Adt(_, substs) = input_ty.kind;\n                 let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.sty;\n+                if let ty::Adt(_, substs) = output_ty.kind;\n                 let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = output_ty.sty;\n+                if let ty::Ref(_, output_ty, _) = output_ty.kind;\n                 if input_ty != output_ty;\n                 then {\n                     \".map(|x| x as _)\""}, {"sha": "9c0fbc4d56cd6057b388237848a857e0536145de", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -1123,8 +1123,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n                 }\n \n-                match self_ty.sty {\n-                    ty::Ref(_, ty, _) if ty.sty == ty::Str => {\n+                match self_ty.kind {\n+                    ty::Ref(_, ty, _) if ty.kind == ty::Str => {\n                         for &(method, pos) in &PATTERN_METHODS {\n                             if method_call.ident.name.as_str() == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n@@ -1230,7 +1230,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             }\n \n             // if return type is impl trait, check the associated types\n-            if let ty::Opaque(def_id, _) = ret_ty.sty {\n+            if let ty::Opaque(def_id, _) = ret_ty.kind {\n                 // one of the associated types must be Self\n                 for predicate in &cx.tcx.predicates_of(def_id).predicates {\n                     match predicate {\n@@ -1453,7 +1453,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n                         && {\n                             let arg_type = cx.tables.expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n-                            base_type.sty == ty::Str || match_type(cx, base_type, &paths::STRING)\n+                            base_type.kind == ty::Str || match_type(cx, base_type, &paths::STRING)\n                         }\n                     {\n                         &call_args[0]\n@@ -1474,8 +1474,8 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         if match_type(cx, arg_ty, &paths::STRING) {\n             return false;\n         }\n-        if let ty::Ref(ty::ReStatic, ty, ..) = arg_ty.sty {\n-            if ty.sty == ty::Str {\n+        if let ty::Ref(ty::ReStatic, ty, ..) = arg_ty.kind {\n+            if ty.kind == ty::Str {\n                 return false;\n             }\n         };\n@@ -1583,8 +1583,8 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'_>) {\n     let ty = cx.tables.expr_ty(expr);\n-    if let ty::Ref(_, inner, _) = arg_ty.sty {\n-        if let ty::Ref(_, innermost, _) = inner.sty {\n+    if let ty::Ref(_, inner, _) = arg_ty.kind {\n+        if let ty::Ref(_, innermost, _) = inner.kind {\n             span_lint_and_then(\n                 cx,\n                 CLONE_DOUBLE_REF,\n@@ -1595,7 +1595,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                         let mut ty = innermost;\n                         let mut n = 0;\n-                        while let ty::Ref(_, inner, _) = ty.sty {\n+                        while let ty::Ref(_, inner, _) = ty.kind {\n                             ty = inner;\n                             n += 1;\n                         }\n@@ -1677,7 +1677,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n-    if let ty::Adt(_, subst) = obj_ty.sty {\n+    if let ty::Adt(_, subst) = obj_ty.kind {\n         let caller_type = if match_type(cx, obj_ty, &paths::RC) {\n             \"Rc\"\n         } else if match_type(cx, obj_ty, &paths::ARC) {\n@@ -1710,7 +1710,7 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = walk_ptrs_ty(cx.tables.expr_ty(target));\n-        let ref_str = if self_ty.sty == ty::Str {\n+        let ref_str = if self_ty.kind == ty::Str {\n             \"\"\n         } else if match_type(cx, self_ty, &paths::STRING) {\n             \"&\"\n@@ -1746,7 +1746,7 @@ fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, source: &hir::Expr, unwrap: &hir::Expr) {\n     if_chain! {\n         let source_type = cx.tables.expr_ty(source);\n-        if let ty::Adt(def, substs) = source_type.sty;\n+        if let ty::Adt(def, substs) = source_type.kind;\n         if match_def_path(cx, def.did, &paths::RESULT);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n         then {\n@@ -1985,7 +1985,7 @@ fn derefs_to_slice<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> Option<&'tcx hir::Expr> {\n     fn may_slice<'a>(cx: &LateContext<'_, 'a>, ty: Ty<'a>) -> bool {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\")),\n@@ -2002,7 +2002,7 @@ fn derefs_to_slice<'a, 'tcx>(\n             None\n         }\n     } else {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Slice(_) => Some(expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n@@ -2525,7 +2525,7 @@ fn lint_chars_cmp(\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n \n-            if self_ty.sty != ty::Str {\n+            if self_ty.kind != ty::Str {\n                 return false;\n             }\n \n@@ -2690,7 +2690,7 @@ fn ty_has_iter_method(\n         } else {\n             INTO_ITER_ON_REF\n         };\n-        let mutbl = match self_ref_ty.sty {\n+        let mutbl = match self_ref_ty.kind {\n             ty::Ref(_, _, mutbl) => mutbl,\n             _ => unreachable!(),\n         };\n@@ -2742,7 +2742,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr, outer: &hir::Ex\n }\n \n fn is_maybe_uninit_ty_valid(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n         ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n         ty::Adt(ref adt, _) => {\n@@ -2765,7 +2765,7 @@ fn lint_suspicious_map(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(_, substs) if match_type(cx, ty, &paths::RESULT) => substs.types().nth(1),\n         _ => None,\n     }\n@@ -2865,7 +2865,7 @@ impl SelfKind {\n             } else if ty.is_box() {\n                 ty.boxed_ty() == parent_ty\n             } else if ty.is_rc() || ty.is_arc() {\n-                if let ty::Adt(_, substs) = ty.sty {\n+                if let ty::Adt(_, substs) = ty.kind {\n                     substs.types().next().map_or(false, |t| t == parent_ty)\n                 } else {\n                     false\n@@ -2881,7 +2881,7 @@ impl SelfKind {\n             parent_ty: Ty<'a>,\n             ty: Ty<'a>,\n         ) -> bool {\n-            if let ty::Ref(_, t, m) = ty.sty {\n+            if let ty::Ref(_, t, m) = ty.kind {\n                 return m == mutability && t == parent_ty;\n             }\n "}, {"sha": "0cf6b6093c616e60b1df36423c2a44c3da38a7f6", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -494,7 +494,7 @@ fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::Float(_))\n+    matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).kind, ty::Float(_))\n }\n \n fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {"}, {"sha": "457062d5dd1bf2fc72de9083e8d9ca21801280b4", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::MutMutable) = self.cx.tables.expr_ty(e).sty {\n+            } else if let ty::Ref(_, _, hir::MutMutable) = self.cx.tables.expr_ty(e).kind {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "e8f3beb9f9234e0e639c3ca9bdecb4e89ca3f97b", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -50,11 +50,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n }\n \n fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], type_definition: Ty<'tcx>, name: &str) {\n-    match type_definition.sty {\n+    match type_definition.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n-                match parameter.sty {\n+                match parameter.kind {\n                     ty::Ref(_, _, MutImmutable)\n                     | ty::RawPtr(ty::TypeAndMut {\n                         mutbl: MutImmutable, .."}, {"sha": "d4194b0ca4137ddae533fa620517cbc5252fbd29", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -57,7 +57,7 @@ declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let ty = cx.tables.expr_ty(expr);\n-        if let ty::Adt(_, subst) = ty.sty {\n+        if let ty::Adt(_, subst) = ty.kind {\n             if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n                          behaviour and not the internal type, consider using Mutex<()>.\",\n                         atomic_name\n                     );\n-                    match mutex_param.sty {\n+                    match mutex_param.kind {\n                         ty::Uint(t) if t != ast::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::Int(t) if t != ast::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n }\n \n fn get_atomic_name(ty: Ty<'_>) -> Option<(&'static str)> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Bool => Some(\"AtomicBool\"),\n         ty::Uint(_) => Some(\"AtomicUsize\"),\n         ty::Int(_) => Some(\"AtomicIsize\"),"}, {"sha": "da363a9b6d67a12ea65d14d3f7cd7c49aafe52f3", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(MutImmutable, ref inner) = e.node {\n-            if let ty::Ref(..) = cx.tables.expr_ty(inner).sty {\n+            if let ty::Ref(..) = cx.tables.expr_ty(inner).kind {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n@@ -81,9 +81,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.node;\n-            if let ty::Ref(_, tam, mutbl) = cx.tables.pat_ty(pat).sty;\n+            if let ty::Ref(_, tam, mutbl) = cx.tables.pat_ty(pat).kind;\n             if mutbl == MutImmutable;\n-            if let ty::Ref(_, _, mutbl) = tam.sty;\n+            if let ty::Ref(_, _, mutbl) = tam.kind;\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n             if mutbl == MutImmutable;\n             then {"}, {"sha": "66e84a404c5405a2c6bcef4c149465bf47ecf213", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n                     // Dereference suggestion\n                     let sugg = |db: &mut DiagnosticBuilder<'_>| {\n-                        if let ty::Adt(def, ..) = ty.sty {\n+                        if let ty::Adt(def, ..) = ty.kind {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n                                 if cx.param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n                                     db.span_help(span, \"consider marking this type as Copy\");"}, {"sha": "8cc27182d83c127d85a55cac834d2c58ad1fa8ea", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n-            if let ty::Adt(def, _) = ty.sty {\n+            if let ty::Adt(def, _) = ty.kind {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint(\n                         cx,"}, {"sha": "16c8e2c4c47991ccdcf7a5d7922f47816ee120f5", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -214,7 +214,7 @@ fn create_new_without_default_suggest_msg(ty: Ty<'_>) -> String {\n }\n \n fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);"}, {"sha": "f5cc89a733042b20485beb3e933b404d59a6eccd", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -150,7 +150,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id:\n     let fn_ty = sig.skip_binder();\n \n     for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n-        if let ty::Ref(_, ty, MutImmutable) = ty.sty {\n+        if let ty::Ref(_, ty, MutImmutable) = ty.kind {\n             if is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\")) {\n                 let mut ty_snippet = None;\n                 if_chain! {"}, {"sha": "09a55d264246b7a78ac225565ea8cd34f59e92e4", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -227,7 +227,7 @@ fn is_call_with_ref_arg<'tcx>(\n         if let TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n         if let mir::Operand::Move(mir::Place { base: mir::PlaceBase::Local(local), .. }) = &args[0];\n-        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).sty;\n+        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).kind;\n         if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n         if !is_copy(cx, inner_ty);\n         then {"}, {"sha": "a9467756c11131f885f7fb7c971d96f7f4896716", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -151,7 +151,7 @@ fn check_local<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, local: &'tcx Local, binding\n \n fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables.node_type(pat_id);\n-    match var_ty.sty {\n+    match var_ty.kind {\n         ty::Adt(..) => false,\n         _ => true,\n     }"}, {"sha": "998d008c6a859506a6c66cffc3cc39ff7e26d564", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -107,8 +107,8 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n-                                if matches!(ty.sty, ty::Slice(_)) ||\n-                                    matches!(ty.sty, ty::Array(_, _)) ||\n+                                if matches!(ty.kind, ty::Slice(_)) ||\n+                                    matches!(ty.kind, ty::Array(_, _)) ||\n                                     is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\")) ||\n                                     match_type(cx, ty, &paths::VEC_DEQUE) {\n                                         return Some((lhs1, idx1, idx2));"}, {"sha": "31223cb27a2e30ff1ebdc58be8c7af3656ba4bd5", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n                         let to_ty = cx.tables.expr_ty(e);\n \n-                        match (&from_ty.sty, &to_ty.sty) {\n+                        match (&from_ty.kind, &to_ty.kind) {\n                             _ if from_ty == to_ty => span_lint(\n                                 cx,\n                                 USELESS_TRANSMUTE,\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     &format!(\"transmute from a `{}` to a `char`\", from_ty),\n                                     |db| {\n                                         let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                        let arg = if let ty::Int(_) = from_ty.sty {\n+                                        let arg = if let ty::Int(_) = from_ty.kind {\n                                             arg.as_ty(ast::UintTy::U32)\n                                         } else {\n                                             arg\n@@ -365,8 +365,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             },\n                             (&ty::Ref(_, ty_from, from_mutbl), &ty::Ref(_, ty_to, to_mutbl)) => {\n                                 if_chain! {\n-                                    if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.sty, &ty_to.sty);\n-                                    if let ty::Uint(ast::UintTy::U8) = slice_ty.sty;\n+                                    if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind, &ty_to.kind);\n+                                    if let ty::Uint(ast::UintTy::U8) = slice_ty.kind;\n                                     if from_mutbl == to_mutbl;\n                                     then {\n                                         let postfix = if from_mutbl == Mutability::MutMutable {\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                                 |db| {\n                                     let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let arg = if let ty::Int(int_ty) = from_ty.sty {\n+                                    let arg = if let ty::Int(int_ty) = from_ty.kind {\n                                         arg.as_ty(format!(\n                                             \"u{}\",\n                                             int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())"}, {"sha": "3bda90a66e3af8b00e5e2f542fe6d71bbcbc87e1", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n         // Use lifetimes to determine if we're returning a reference to the\n         // argument. In that case we can't switch to pass-by-value as the\n         // argument will not live long enough.\n-        let output_lts = match fn_sig.output().sty {\n+        let output_lts = match fn_sig.output().kind {\n             ty::Ref(output_lt, _, _) => vec![output_lt],\n             ty::Adt(_, substs) => substs.regions().collect(),\n             _ => vec![],\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n             }\n \n             if_chain! {\n-                if let ty::Ref(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n+                if let ty::Ref(input_lt, ty, Mutability::MutImmutable) = ty.kind;\n                 if !output_lts.contains(&input_lt);\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());"}, {"sha": "57be349c10534efec9a141c0896125d244182db0", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -633,7 +633,7 @@ fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n }\n \n fn is_unit(ty: Ty<'_>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Tuple(slice) if slice.is_empty() => true,\n         _ => false,\n     }\n@@ -865,7 +865,7 @@ declare_clippy_lint! {\n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n-    match typ.sty {\n+    match typ.kind {\n         ty::Int(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n             IntTy::I8 => 8,\n@@ -887,7 +887,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n }\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    match typ.sty {\n+    match typ.kind {\n         ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => true,\n         _ => false,\n     }\n@@ -979,7 +979,7 @@ fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n     if_chain! {\n         if let Some((const_val, _)) = const_val;\n         if let Constant::Int(n) = const_val;\n-        if let ty::Int(ity) = cast_from.sty;\n+        if let ty::Int(ity) = cast_from.kind;\n         if sext(cx.tcx, n, ity) >= 0;\n         then {\n             return\n@@ -1090,7 +1090,7 @@ declare_lint_pass!(Casts => [\n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n fn is_c_void(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.sty {\n+    if let ty::Adt(adt, _) = ty.kind {\n         let names = cx.get_def_path(adt.did);\n \n         if names.is_empty() {\n@@ -1106,7 +1106,7 @@ fn is_c_void(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n /// Returns the mantissa bits wide of a fp type.\n /// Will return 0 if the type is not a fp\n fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n-    match typ.sty {\n+    match typ.kind {\n         ty::Float(FloatTy::F32) => 23,\n         ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n         _ => 0,\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n                     _ => {\n-                        if cast_from.sty == cast_to.sty && !in_external_macro(cx.sess(), expr.span) {\n+                        if cast_from.kind == cast_to.kind && !in_external_macro(cx.sess(), expr.span) {\n                             span_lint(\n                                 cx,\n                                 UNNECESSARY_CAST,\n@@ -1176,7 +1176,7 @@ fn lint_numeric_casts<'tcx>(\n     match (cast_from.is_integral(), cast_to.is_integral()) {\n         (true, false) => {\n             let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.sty {\n+            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind {\n                 32\n             } else {\n                 64\n@@ -1210,15 +1210,15 @@ fn lint_numeric_casts<'tcx>(\n             check_lossless(cx, expr, cast_expr, cast_from, cast_to);\n         },\n         (false, false) => {\n-            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty) {\n+            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind, &cast_to.kind) {\n                 span_lint(\n                     cx,\n                     CAST_POSSIBLE_TRUNCATION,\n                     expr.span,\n                     \"casting f64 to f32 may truncate the value\",\n                 );\n             }\n-            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty) {\n+            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind, &cast_to.kind) {\n                 span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n             }\n         },\n@@ -1227,8 +1227,8 @@ fn lint_numeric_casts<'tcx>(\n \n fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n     if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.sty;\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.sty;\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind;\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind;\n         if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n         if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n         if from_layout.align.abi < to_layout.align.abi;\n@@ -1261,11 +1261,11 @@ fn lint_fn_to_numeric_cast(\n     cast_to: Ty<'_>,\n ) {\n     // We only want to check casts to `ty::Uint` or `ty::Int`\n-    match cast_to.sty {\n+    match cast_to.kind {\n         ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n         _ => return,\n     }\n-    match cast_from.sty {\n+    match cast_from.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let mut applicability = Applicability::MaybeIncorrect;\n             let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n@@ -1284,7 +1284,7 @@ fn lint_fn_to_numeric_cast(\n                     format!(\"{} as usize\", from_snippet),\n                     applicability,\n                 );\n-            } else if cast_to.sty != ty::Uint(UintTy::Usize) {\n+            } else if cast_to.kind != ty::Uint(UintTy::Usize) {\n                 span_lint_and_sugg(\n                     cx,\n                     FN_TO_NUMERIC_CAST,\n@@ -1498,7 +1498,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n             if let ExprKind::Cast(e, _) = &expr.node;\n             if let ExprKind::Lit(l) = &e.node;\n             if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == cx.tables.expr_ty(expr).sty;\n+            if ty::Uint(UintTy::U8) == cx.tables.expr_ty(expr).kind;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n@@ -1642,7 +1642,7 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -\n \n     let cv = constant(cx, cx.tables, expr)?.0;\n \n-    let which = match (&ty.sty, cv) {\n+    let which = match (&ty.kind, cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n         (&ty::Int(ity), Constant::Int(i))\n             if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n@@ -1778,7 +1778,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n         if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n             return None;\n         }\n-        match pre_cast_ty.sty {\n+        match pre_cast_ty.kind {\n             ty::Int(int_ty) => Some(match int_ty {\n                 IntTy::I8 => (\n                     FullInt::S(i128::from(i8::min_value())),\n@@ -1835,7 +1835,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<FullInt> {\n     let val = constant(cx, cx.tables, expr)?.0;\n     if let Constant::Int(const_int) = val {\n-        match cx.tables.expr_ty(expr).sty {\n+        match cx.tables.expr_ty(expr).kind {\n             ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n             ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n@@ -2330,7 +2330,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RefToMut {\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::MutMutable, .. }) = t.node;\n             if let ExprKind::Cast(e, t) = &e.node;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::MutImmutable, .. }) = t.node;\n-            if let ty::Ref(..) = cx.tables.node_type(e.hir_id).sty;\n+            if let ty::Ref(..) = cx.tables.node_type(e.hir_id).kind;\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "dd53a7111a2ad986e3056431dbca538e01590225", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -54,7 +54,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n         Some(expr)\n     }\n \n-    let def_path = match cx.tables.expr_ty(expr).sty {\n+    let def_path = match cx.tables.expr_ty(expr).kind {\n         ty::Adt(def, _) => cx.tcx.def_path(def.did),\n         _ => return None,\n     };"}, {"sha": "235c083dbe034f1c9475b348b090a792d7872bb1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -125,15 +125,15 @@ pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n \n /// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Checks if the type is equal to a diagnostic item\n pub fn is_type_diagnostic_item(cx: &LateContext<'_, '_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n         _ => false,\n     }\n@@ -665,7 +665,7 @@ pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n \n /// Returns the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n-    match ty.sty {\n+    match ty.kind {\n         ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n     }\n@@ -675,7 +675,7 @@ pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n /// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n-        match ty.sty {\n+        match ty.kind {\n             ty::Ref(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n         }\n@@ -792,7 +792,7 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n \n /// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n+    match ty.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n@@ -1063,12 +1063,12 @@ pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Opt\n         &paths::RECEIVER,\n     ];\n \n-    let ty_to_check = match probably_ref_ty.sty {\n+    let ty_to_check = match probably_ref_ty.kind {\n         ty::Ref(_, ty_to_check, _) => ty_to_check,\n         _ => probably_ref_ty,\n     };\n \n-    let def_id = match ty_to_check.sty {\n+    let def_id = match ty_to_check.kind {\n         ty::Array(..) => return Some(\"array\"),\n         ty::Slice(..) => return Some(\"slice\"),\n         ty::Adt(adt, _) => adt.did,"}, {"sha": "bb97f894c0646ba9fae1d742b453c55a91851a9f", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b7e19f499845202fccc348aeae7d9b5c1fcf51/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=a7b7e19f499845202fccc348aeae7d9b5c1fcf51", "patch": "@@ -31,8 +31,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.tables.expr_ty_adjusted(expr).sty;\n-            if let ty::Slice(..) = ty.sty;\n+            if let ty::Ref(_, ty, _) = cx.tables.expr_ty_adjusted(expr).kind;\n+            if let ty::Slice(..) = ty.kind;\n             if let ExprKind::AddrOf(_, ref addressee) = expr.node;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n@@ -98,7 +98,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n \n /// Returns the item type of the vector (i.e., the `T` in `Vec<T>`).\n fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n-    if let ty::Adt(_, substs) = ty.sty {\n+    if let ty::Adt(_, substs) = ty.kind {\n         substs.type_at(0)\n     } else {\n         panic!(\"The type of `vec!` is a not a struct?\");"}]}