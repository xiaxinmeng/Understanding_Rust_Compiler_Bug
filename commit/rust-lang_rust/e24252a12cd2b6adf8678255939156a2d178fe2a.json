{"sha": "e24252a12cd2b6adf8678255939156a2d178fe2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNDI1MmExMmNkMmI2YWRmODY3ODI1NTkzOTE1NmEyZDE3OGZlMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-16T20:49:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-16T20:49:26Z"}, "message": "Auto merge of #68970 - matthewjasper:min-spec, r=nikomatsakis\n\nImplement a feature for a sound specialization subset\n\nThis implements a new feature (`min_specialization`) that restricts specialization to a subset that is reasonable for the standard library to use.\n\nThe plan is to then:\n\n* Update `libcore` and `liballoc` to compile with `min_specialization`.\n* Add a lint to forbid use of `feature(specialization)` (and other unsound, type system extending features) in the standard library.\n* Fix the soundness issues around `specialization`.\n* Remove `min_specialization`\n\nThe rest of this is an overview from a comment in this PR\n\n## Basic approach\n\nTo enforce this requirement on specializations we take the following approach:\n1. Match up the substs for `impl2` so that the implemented trait and self-type match those for `impl1`.\n2. Check for any direct use of `'static` in the substs of `impl2`.\n3. Check that all of the generic parameters of `impl1` occur at most once in the *unconstrained* substs for `impl2`. A parameter is constrained if its value is completely determined by an associated type projection predicate.\n4. Check that all predicates on `impl1` also exist on `impl2` (after matching substs).\n\n## Example\n\nSuppose we have the following always applicable impl:\n\n```rust\nimpl<T> SpecExtend<T> for std::vec::IntoIter<T> { /* specialized impl */ }\nimpl<T, I: Iterator<Item=T>> SpecExtend<T> for I { /* default impl */ }\n```\n\nWe get that the subst for `impl2` are `[T, std::vec::IntoIter<T>]`. `T` is constrained to be `<I as Iterator>::Item`, so we check only `std::vec::IntoIter<T>` for repeated parameters, which it doesn't have. The predicates of `impl1` are only `T: Sized`, which is also a predicate of impl2`. So this specialization is sound.\n\n## Extensions\n\nUnfortunately not all specializations in the standard library are allowed by this. So there are two extensions to these rules that allow specializing on some traits.\n\n### rustc_specialization_trait\n\nIf a trait is always applicable, then it's sound to specialize on it. We check trait is always applicable in the same way as impls, except that step 4 is now \"all predicates on `impl1` are always applicable\". We require that `specialization` or `min_specialization` is enabled to implement these traits.\n\n### rustc_specialization_marker\n\nThere are also some specialization on traits with no methods, including the `FusedIterator` trait which is advertised as allowing optimizations. We allow marking marker traits with an unstable attribute that means we ignore them in point 3 of the checks above. This is unsound but we allow it in the short term because it can't cause use after frees with purely safe code in the same way as specializing on traits methods can.\n\nr? @nikomatsakis\ncc #31844 #67194", "tree": {"sha": "89d3d3fa1131bffc86390b4bb97a5ad9c1630b85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89d3d3fa1131bffc86390b4bb97a5ad9c1630b85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e24252a12cd2b6adf8678255939156a2d178fe2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e24252a12cd2b6adf8678255939156a2d178fe2a", "html_url": "https://github.com/rust-lang/rust/commit/e24252a12cd2b6adf8678255939156a2d178fe2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e24252a12cd2b6adf8678255939156a2d178fe2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd67187965e136bff1ed05e035293441c60f0790", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd67187965e136bff1ed05e035293441c60f0790", "html_url": "https://github.com/rust-lang/rust/commit/dd67187965e136bff1ed05e035293441c60f0790"}, {"sha": "39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "url": "https://api.github.com/repos/rust-lang/rust/commits/39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "html_url": "https://github.com/rust-lang/rust/commit/39ee66ab82fc38a13d046ac1caa1eb55edfa8901"}], "stats": {"total": 1168, "additions": 1095, "deletions": 73}, "files": [{"sha": "2b908f07af8da585f6cdbe7f9ff2590709662d05", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -90,6 +90,7 @@ impl<T: ?Sized> !Send for *mut T {}\n           ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\"\n )]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n+#[cfg_attr(not(bootstrap), rustc_specialization_trait)]\n pub trait Sized {\n     // Empty.\n }"}, {"sha": "8f16e3c08ec5b542ddf167b4d45a95a1b8002f50", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -26,7 +26,8 @@\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(rustc_attrs)]\n-#![feature(specialization)]\n+#![cfg_attr(bootstrap, feature(specialization))]\n+#![cfg_attr(not(bootstrap), feature(min_specialization))]\n #![recursion_limit = \"256\"]\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]"}, {"sha": "1847326a742eb7897b2c83726ad84114da3c91c6", "filename": "src/librustc/traits/specialization_graph.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -4,6 +4,7 @@ use crate::ty::{self, TyCtxt};\n use rustc_ast::ast::Ident;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::ErrorReported;\n use rustc_hir::def_id::{DefId, DefIdMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n@@ -23,17 +24,20 @@ use rustc_hir::def_id::{DefId, DefIdMap};\n ///   has at most one parent.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Graph {\n-    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n-    // of the trait.\n+    /// All impls have a parent; the \"root\" impls have as their parent the `def_id`\n+    /// of the trait.\n     pub parent: DefIdMap<DefId>,\n \n-    // The \"root\" impls are found by looking up the trait's def_id.\n+    /// The \"root\" impls are found by looking up the trait's def_id.\n     pub children: DefIdMap<Children>,\n+\n+    /// Whether an error was emitted while constructing the graph.\n+    pub has_errored: bool,\n }\n \n impl Graph {\n     pub fn new() -> Graph {\n-        Graph { parent: Default::default(), children: Default::default() }\n+        Graph { parent: Default::default(), children: Default::default(), has_errored: false }\n     }\n \n     /// The parent of a given impl, which is the `DefId` of the trait when the\n@@ -179,17 +183,22 @@ impl<'tcx> Ancestors<'tcx> {\n }\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n-/// impl itself.\n+/// impl itself. Returns `None` if an error was reported while building the\n+/// specialization graph.\n pub fn ancestors(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n     start_from_impl: DefId,\n-) -> Ancestors<'tcx> {\n+) -> Result<Ancestors<'tcx>, ErrorReported> {\n     let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n-    Ancestors {\n-        trait_def_id,\n-        specialization_graph,\n-        current_source: Some(Node::Impl(start_from_impl)),\n+    if specialization_graph.has_errored {\n+        Err(ErrorReported)\n+    } else {\n+        Ok(Ancestors {\n+            trait_def_id,\n+            specialization_graph,\n+            current_source: Some(Node::Impl(start_from_impl)),\n+        })\n     }\n }\n "}, {"sha": "b0287be65294f1ae57ef7c7fb8f0f4129d9d6270", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::HirId;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_errors::ErrorReported;\n use rustc_macros::HashStable;\n use std::collections::BTreeMap;\n \n@@ -35,11 +36,33 @@ pub struct TraitDef {\n     /// and thus `impl`s of it are allowed to overlap.\n     pub is_marker: bool,\n \n+    /// Used to determine whether the standard library is allowed to specialize\n+    /// on this trait.\n+    pub specialization_kind: TraitSpecializationKind,\n+\n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n     pub def_path_hash: DefPathHash,\n }\n \n+/// Whether this trait is treated specially by the standard library\n+/// specialization lint.\n+#[derive(HashStable, PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n+pub enum TraitSpecializationKind {\n+    /// The default. Specializing on this trait is not allowed.\n+    None,\n+    /// Specializing on this trait is allowed because it doesn't have any\n+    /// methods. For example `Sized` or `FusedIterator`.\n+    /// Applies to traits with the `rustc_unsafe_specialization_marker`\n+    /// attribute.\n+    Marker,\n+    /// Specializing on this trait is allowed because all of the impls of this\n+    /// trait are \"always applicable\". Always applicable means that if\n+    /// `X<'x>: T<'y>` for any lifetimes, then `for<'a, 'b> X<'a>: T<'b>`.\n+    /// Applies to traits with the `rustc_specialization_trait` attribute.\n+    AlwaysApplicable,\n+}\n+\n #[derive(Default)]\n pub struct TraitImpls {\n     blanket_impls: Vec<DefId>,\n@@ -54,16 +77,25 @@ impl<'tcx> TraitDef {\n         paren_sugar: bool,\n         has_auto_impl: bool,\n         is_marker: bool,\n+        specialization_kind: TraitSpecializationKind,\n         def_path_hash: DefPathHash,\n     ) -> TraitDef {\n-        TraitDef { def_id, unsafety, paren_sugar, has_auto_impl, is_marker, def_path_hash }\n+        TraitDef {\n+            def_id,\n+            unsafety,\n+            paren_sugar,\n+            has_auto_impl,\n+            is_marker,\n+            specialization_kind,\n+            def_path_hash,\n+        }\n     }\n \n     pub fn ancestors(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         of_impl: DefId,\n-    ) -> specialization_graph::Ancestors<'tcx> {\n+    ) -> Result<specialization_graph::Ancestors<'tcx>, ErrorReported> {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n }"}, {"sha": "364c86bd99b4e60c00e0a9b24255b745fc69c2b7", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -542,15 +542,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n-        if let ast::Defaultness::Default(_) = i.kind.defaultness() {\n-            gate_feature_post!(&self, specialization, i.span, \"specialization is unstable\");\n-        }\n-\n-        match i.kind {\n+        let is_fn = match i.kind {\n             ast::AssocItemKind::Fn(_, ref sig, _, _) => {\n                 if let (ast::Const::Yes(_), AssocCtxt::Trait) = (sig.header.constness, ctxt) {\n                     gate_feature_post!(&self, const_fn, i.span, \"const fn is unstable\");\n                 }\n+                true\n             }\n             ast::AssocItemKind::TyAlias(_, ref generics, _, ref ty) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n@@ -565,8 +562,19 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     self.check_impl_trait(ty);\n                 }\n                 self.check_gat(generics, i.span);\n+                false\n             }\n-            _ => {}\n+            _ => false,\n+        };\n+        if let ast::Defaultness::Default(_) = i.kind.defaultness() {\n+            // Limit `min_specialization` to only specializing functions.\n+            gate_feature_fn!(\n+                &self,\n+                |x: &Features| x.specialization || (is_fn && x.min_specialization),\n+                i.span,\n+                sym::specialization,\n+                \"specialization is unstable\"\n+            );\n         }\n         visit::walk_assoc_item(self, i, ctxt)\n     }"}, {"sha": "9f1fee8fc09d8f31c9a57e7e54d7c17fc5fac63b", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -301,6 +301,11 @@ declare_features! (\n     /// Allows specialization of implementations (RFC 1210).\n     (active, specialization, \"1.7.0\", Some(31844), None),\n \n+    /// A minimal, sound subset of specialization intended to be used by the\n+    /// standard library until the soundness issues with specialization\n+    /// are fixed.\n+    (active, min_specialization, \"1.7.0\", Some(31844), None),\n+\n     /// Allows using `#[naked]` on functions.\n     (active, naked_functions, \"1.9.0\", Some(32408), None),\n "}, {"sha": "83830b9d78ad4d9f66460c7959dbd74995a72b7f", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -530,6 +530,14 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         rustc_test_marker, Normal, template!(Word),\n         \"the `#[rustc_test_marker]` attribute is used internally to track tests\",\n     ),\n+    rustc_attr!(\n+        rustc_unsafe_specialization_marker, Normal, template!(Word),\n+        \"the `#[rustc_unsafe_specialization_marker]` attribute is used to check specializations\"\n+    ),\n+    rustc_attr!(\n+        rustc_specialization_trait, Normal, template!(Word),\n+        \"the `#[rustc_specialization_trait]` attribute is used to check specializations\"\n+    ),\n \n     // ==========================================================================\n     // Internal attributes, Testing:"}, {"sha": "5b7d89243c35fe0f41adadfb613dce38cf032c51", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -651,6 +651,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     data.paren_sugar,\n                     data.has_auto_impl,\n                     data.is_marker,\n+                    data.specialization_kind,\n                     self.def_path_table.def_path_hash(item_id),\n                 )\n             }\n@@ -660,6 +661,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 false,\n                 false,\n                 false,\n+                ty::trait_def::TraitSpecializationKind::None,\n                 self.def_path_table.def_path_hash(item_id),\n             ),\n             _ => bug!(\"def-index does not refer to trait or trait alias\"),"}, {"sha": "4c8e07c223bd3f58f7dd78173f97fa6139689108", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -1077,12 +1077,13 @@ impl EncodeContext<'tcx> {\n                 let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(self.tcx, def_id).nth(1).and_then(|node| {\n-                        match node {\n-                            specialization_graph::Node::Impl(parent) => Some(parent),\n-                            _ => None,\n-                        }\n-                    })\n+                    trait_def.ancestors(self.tcx, def_id).ok()\n+                        .and_then(|mut an| an.nth(1).and_then(|node| {\n+                            match node {\n+                                specialization_graph::Node::Impl(parent) => Some(parent),\n+                                _ => None,\n+                            }\n+                        }))\n                 } else {\n                     None\n                 };\n@@ -1114,6 +1115,7 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n+                    specialization_kind: trait_def.specialization_kind,\n                 };\n \n                 EntryKind::Trait(self.lazy(data))"}, {"sha": "e2d8d5466bd3edad4216415aa13c0710eb224fe6", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -343,6 +343,7 @@ struct TraitData {\n     paren_sugar: bool,\n     has_auto_impl: bool,\n     is_marker: bool,\n+    specialization_kind: ty::trait_def::TraitSpecializationKind,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "97e3fbd41b3fd6e59f3dd4cb6a52e69b5b817380", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -453,6 +453,7 @@ symbols! {\n         min_align_of,\n         min_const_fn,\n         min_const_unsafe_fn,\n+        min_specialization,\n         mips_target_feature,\n         mmx_target_feature,\n         module,\n@@ -654,6 +655,8 @@ symbols! {\n         rustc_proc_macro_decls,\n         rustc_promotable,\n         rustc_regions,\n+        rustc_unsafe_specialization_marker,\n+        rustc_specialization_trait,\n         rustc_stable,\n         rustc_std_internal_symbol,\n         rustc_symbol_name,"}, {"sha": "1ad915742127ea93f7b8bb474f493950e4789c80", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_ast::ast::Ident;\n+use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n@@ -1010,7 +1011,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc::ty::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id);\n+                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n+                        .map_err(|ErrorReported| ())?;\n \n                 let is_default = if node_item.node.is_from_trait() {\n                     // If true, the impl inherited a `type Foo = Bar`\n@@ -1405,7 +1407,10 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let assoc_ty = assoc_ty_def(selcx, impl_def_id, assoc_item_id);\n+    let assoc_ty = match assoc_ty_def(selcx, impl_def_id, assoc_item_id) {\n+        Ok(assoc_ty) => assoc_ty,\n+        Err(ErrorReported) => return Progress { ty: tcx.types.err, obligations: nested },\n+    };\n \n     if !assoc_ty.item.defaultness.has_value() {\n         // This means that the impl is missing a definition for the\n@@ -1444,14 +1449,14 @@ fn assoc_ty_def(\n     selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n     assoc_ty_def_id: DefId,\n-) -> specialization_graph::NodeItem<ty::AssocItem> {\n+) -> Result<specialization_graph::NodeItem<ty::AssocItem>, ErrorReported> {\n     let tcx = selcx.tcx();\n     let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     // This function may be called while we are still building the\n-    // specialization graph that is queried below (via TraidDef::ancestors()),\n+    // specialization graph that is queried below (via TraitDef::ancestors()),\n     // so, in order to avoid unnecessary infinite recursion, we manually look\n     // for the associated item at the given impl.\n     // If there is no such item in that impl, this function will fail with a\n@@ -1461,17 +1466,16 @@ fn assoc_ty_def(\n         if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n-            return specialization_graph::NodeItem {\n+            return Ok(specialization_graph::NodeItem {\n                 node: specialization_graph::Node::Impl(impl_def_id),\n                 item: *item,\n-            };\n+            });\n         }\n     }\n \n-    if let Some(assoc_item) =\n-        trait_def.ancestors(tcx, impl_def_id).leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type)\n-    {\n-        assoc_item\n+    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type) {\n+        Ok(assoc_item)\n     } else {\n         // This is saying that neither the trait nor\n         // the impl contain a definition for this"}, {"sha": "b763851b86ef63cf7f5387fed3fc502df820f580", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -130,24 +130,27 @@ pub fn find_associated_item<'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.trait_def(trait_def_id);\n \n-    let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n-    match ancestors.leaf_def(tcx, item.ident, item.kind) {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = param_env.with_reveal_all();\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                let substs = translate_substs(\n-                    &infcx,\n-                    param_env,\n-                    impl_data.impl_def_id,\n-                    substs,\n-                    node_item.node,\n-                );\n-                infcx.tcx.erase_regions(&substs)\n-            });\n-            (node_item.item.def_id, substs)\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_data.impl_def_id) {\n+        match ancestors.leaf_def(tcx, item.ident, item.kind) {\n+            Some(node_item) => {\n+                let substs = tcx.infer_ctxt().enter(|infcx| {\n+                    let param_env = param_env.with_reveal_all();\n+                    let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                    let substs = translate_substs(\n+                        &infcx,\n+                        param_env,\n+                        impl_data.impl_def_id,\n+                        substs,\n+                        node_item.node,\n+                    );\n+                    infcx.tcx.erase_regions(&substs)\n+                });\n+                (node_item.item.def_id, substs)\n+            }\n+            None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id),\n         }\n-        None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id),\n+    } else {\n+        (item.def_id, substs)\n     }\n }\n \n@@ -161,7 +164,9 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n \n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n-    if !tcx.features().specialization && (impl1_def_id.is_local() || impl2_def_id.is_local()) {\n+    let features = tcx.features();\n+    let specialization_enabled = features.specialization || features.min_specialization;\n+    if !specialization_enabled && (impl1_def_id.is_local() || impl2_def_id.is_local()) {\n         return false;\n     }\n \n@@ -380,6 +385,7 @@ pub(super) fn specialization_graph_provider(\n \n                 match used_to_be_allowed {\n                     None => {\n+                        sg.has_errored = true;\n                         let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n                         decorate(LintDiagnosticBuilder::new(err));\n                     }"}, {"sha": "1766b688468f11b00f36d4a128c924ed0f36f570", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -1901,8 +1901,11 @@ fn check_specialization_validity<'tcx>(\n         hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n     };\n \n-    let mut ancestor_impls = trait_def\n-        .ancestors(tcx, impl_id)\n+    let ancestors = match trait_def.ancestors(tcx, impl_id) {\n+        Ok(ancestors) => ancestors,\n+        Err(_) => return,\n+    };\n+    let mut ancestor_impls = ancestors\n         .skip(1)\n         .filter_map(|parent| {\n             if parent.is_from_trait() {\n@@ -2083,16 +2086,17 @@ fn check_impl_items_against_trait<'tcx>(\n \n     // Check for missing items from trait\n     let mut missing_items = Vec::new();\n-    for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n-        let is_implemented = trait_def\n-            .ancestors(tcx, impl_id)\n-            .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-            .map(|node_item| !node_item.node.is_from_trait())\n-            .unwrap_or(false);\n-\n-        if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n-            if !trait_item.defaultness.has_value() {\n-                missing_items.push(*trait_item);\n+    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) {\n+        for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n+            let is_implemented = ancestors\n+                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .map(|node_item| !node_item.node.is_from_trait())\n+                .unwrap_or(false);\n+\n+            if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n+                if !trait_item.defaultness.has_value() {\n+                    missing_items.push(*trait_item);\n+                }\n             }\n         }\n     }"}, {"sha": "e4a57f66196288ee28f8cfe9cfe763441837acbe", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -4,6 +4,7 @@ use crate::constrained_generic_params::{identify_constrained_generic_params, Par\n use rustc::middle::lang_items;\n use rustc::session::parse::feature_err;\n use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::trait_def::TraitSpecializationKind;\n use rustc::ty::{\n     self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n@@ -412,7 +413,9 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     let trait_def_id = tcx.hir().local_def_id(item.hir_id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n-    if trait_def.is_marker {\n+    if trait_def.is_marker\n+        || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n+    {\n         for associated_def_id in &*tcx.associated_item_def_ids(trait_def_id) {\n             struct_span_err!(\n                 tcx.sess,"}, {"sha": "27b2c19499ccd61f89ba71aca9627dccafcea8cc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -76,6 +76,22 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n         return;\n     }\n \n+    if let ty::trait_def::TraitSpecializationKind::AlwaysApplicable =\n+        tcx.trait_def(trait_def_id).specialization_kind\n+    {\n+        if !tcx.features().specialization && !tcx.features().min_specialization {\n+            let span = impl_header_span(tcx, impl_def_id);\n+            tcx.sess\n+                .struct_span_err(\n+                    span,\n+                    \"implementing `rustc_specialization_trait` traits is unstable\",\n+                )\n+                .help(\"add `#![feature(min_specialization)]` to the crate attributes to enable\")\n+                .emit();\n+            return;\n+        }\n+    }\n+\n     let trait_name = if did == li.fn_trait() {\n         \"Fn\"\n     } else if did == li.fn_mut_trait() {"}, {"sha": "8e60bd2a4b3e80d1879d2fe99f666a61e9555c0e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -1032,8 +1032,23 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n     }\n \n     let is_marker = tcx.has_attr(def_id, sym::marker);\n+    let spec_kind = if tcx.has_attr(def_id, sym::rustc_unsafe_specialization_marker) {\n+        ty::trait_def::TraitSpecializationKind::Marker\n+    } else if tcx.has_attr(def_id, sym::rustc_specialization_trait) {\n+        ty::trait_def::TraitSpecializationKind::AlwaysApplicable\n+    } else {\n+        ty::trait_def::TraitSpecializationKind::None\n+    };\n     let def_path_hash = tcx.def_path_hash(def_id);\n-    let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, is_auto, is_marker, def_path_hash);\n+    let def = ty::TraitDef::new(\n+        def_id,\n+        unsafety,\n+        paren_sugar,\n+        is_auto,\n+        is_marker,\n+        spec_kind,\n+        def_path_hash,\n+    );\n     tcx.arena.alloc(def)\n }\n "}, {"sha": "b16aa6ff3b2e4c41bc0473b04e8f452f388dc02d", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -79,10 +79,18 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n \n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n-        if let ty::ConstKind::Param(data) = c.val {\n-            self.parameters.push(Parameter::from(data));\n+        match c.val {\n+            ty::ConstKind::Unevaluated(..) if !self.include_nonconstraining => {\n+                // Constant expressions are not injective\n+                return c.ty.visit_with(self);\n+            }\n+            ty::ConstKind::Param(data) => {\n+                self.parameters.push(Parameter::from(data));\n+            }\n+            _ => {}\n         }\n-        false\n+\n+        c.super_visit_with(self)\n     }\n }\n "}, {"sha": "42cb4fcf85dcb9584d11c76b1b18d2bad109925d", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -9,16 +9,20 @@\n //! fixed, but for the moment it's easier to do these checks early.\n \n use crate::constrained_generic_params as cgp;\n+use min_specialization::check_min_specialization;\n+\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_span::Span;\n+\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n-use rustc_span::Span;\n+mod min_specialization;\n \n /// Checks that all the type/lifetime parameters on an impl also\n /// appear in the trait ref or self type (or are constrained by a\n@@ -60,7 +64,9 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n }\n \n fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx });\n+    let min_specialization = tcx.features().min_specialization;\n+    tcx.hir()\n+        .visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx, min_specialization });\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -69,6 +75,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n struct ImplWfCheck<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    min_specialization: bool,\n }\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n@@ -77,6 +84,9 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx, impl_def_id, items);\n             enforce_impl_items_are_distinct(self.tcx, items);\n+            if self.min_specialization {\n+                check_min_specialization(self.tcx, impl_def_id, item.span);\n+            }\n         }\n     }\n "}, {"sha": "e96a8c454b8c7b60fc47ae20dbadbe32c42b9666", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,409 @@\n+//! # Minimal Specialization\n+//!\n+//! This module contains the checks for sound specialization used when the\n+//! `min_specialization` feature is enabled. This requires that the impl is\n+//! *always applicable*.\n+//!\n+//! If `impl1` specializes `impl2` then `impl1` is always applicable if we know\n+//! that all the bounds of `impl2` are satisfied, and all of the bounds of\n+//! `impl1` are satisfied for some choice of lifetimes then we know that\n+//! `impl1` applies for any choice of lifetimes.\n+//!\n+//! ## Basic approach\n+//!\n+//! To enforce this requirement on specializations we take the following\n+//! approach:\n+//!\n+//! 1. Match up the substs for `impl2` so that the implemented trait and\n+//!    self-type match those for `impl1`.\n+//! 2. Check for any direct use of `'static` in the substs of `impl2`.\n+//! 3. Check that all of the generic parameters of `impl1` occur at most once\n+//!    in the *unconstrained* substs for `impl2`. A parameter is constrained if\n+//!    its value is completely determined by an associated type projection\n+//!    predicate.\n+//! 4. Check that all predicates on `impl1` either exist on `impl2` (after\n+//!    matching substs), or are well-formed predicates for the trait's type\n+//!    arguments.\n+//!\n+//! ## Example\n+//!\n+//! Suppose we have the following always applicable impl:\n+//!\n+//! ```rust\n+//! impl<T> SpecExtend<T> for std::vec::IntoIter<T> { /* specialized impl */ }\n+//! impl<T, I: Iterator<Item=T>> SpecExtend<T> for I { /* default impl */ }\n+//! ```\n+//!\n+//! We get that the subst for `impl2` are `[T, std::vec::IntoIter<T>]`. `T` is\n+//! constrained to be `<I as Iterator>::Item`, so we check only\n+//! `std::vec::IntoIter<T>` for repeated parameters, which it doesn't have. The\n+//! predicates of `impl1` are only `T: Sized`, which is also a predicate of\n+//! `impl2`. So this specialization is sound.\n+//!\n+//! ## Extensions\n+//!\n+//! Unfortunately not all specializations in the standard library are allowed\n+//! by this. So there are two extensions to these rules that allow specializing\n+//! on some traits: that is, using them as bounds on the specializing impl,\n+//! even when they don't occur in the base impl.\n+//!\n+//! ### rustc_specialization_trait\n+//!\n+//! If a trait is always applicable, then it's sound to specialize on it. We\n+//! check trait is always applicable in the same way as impls, except that step\n+//! 4 is now \"all predicates on `impl1` are always applicable\". We require that\n+//! `specialization` or `min_specialization` is enabled to implement these\n+//! traits.\n+//!\n+//! ### rustc_unsafe_specialization_marker\n+//!\n+//! There are also some specialization on traits with no methods, including the\n+//! stable `FusedIterator` trait. We allow marking marker traits with an\n+//! unstable attribute that means we ignore them in point 3 of the checks\n+//! above. This is unsound, in the sense that the specialized impl may be used\n+//! when it doesn't apply, but we allow it in the short term since it can't\n+//! cause use after frees with purely safe code in the same way as specializing\n+//! on traits with methods can.\n+\n+use crate::constrained_generic_params as cgp;\n+\n+use rustc::middle::region::ScopeTree;\n+use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n+use rustc::ty::trait_def::TraitSpecializationKind;\n+use rustc::ty::{self, InstantiatedPredicates, TyCtxt, TypeFoldable};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::traits::specialization_graph::Node;\n+use rustc_span::Span;\n+use rustc_trait_selection::traits::{self, translate_substs, wf};\n+\n+pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: DefId, span: Span) {\n+    if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            check_always_applicable(&infcx, impl_def_id, node, span);\n+        });\n+    }\n+}\n+\n+fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: DefId) -> Option<Node> {\n+    let trait_ref = tcx.impl_trait_ref(impl1_def_id)?;\n+    let trait_def = tcx.trait_def(trait_ref.def_id);\n+\n+    let impl2_node = trait_def.ancestors(tcx, impl1_def_id).ok()?.nth(1)?;\n+\n+    let always_applicable_trait =\n+        matches!(trait_def.specialization_kind, TraitSpecializationKind::AlwaysApplicable);\n+    if impl2_node.is_from_trait() && !always_applicable_trait {\n+        // Implementing a normal trait isn't a specialization.\n+        return None;\n+    }\n+    Some(impl2_node)\n+}\n+\n+/// Check that `impl1` is a sound specialization\n+fn check_always_applicable(\n+    infcx: &InferCtxt<'_, '_>,\n+    impl1_def_id: DefId,\n+    impl2_node: Node,\n+    span: Span,\n+) {\n+    if let Some((impl1_substs, impl2_substs)) =\n+        get_impl_substs(infcx, impl1_def_id, impl2_node, span)\n+    {\n+        let impl2_def_id = impl2_node.def_id();\n+        debug!(\n+            \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n+            impl1_def_id, impl2_def_id, impl2_substs\n+        );\n+\n+        let tcx = infcx.tcx;\n+\n+        let parent_substs = if impl2_node.is_from_trait() {\n+            impl2_substs.to_vec()\n+        } else {\n+            unconstrained_parent_impl_substs(tcx, impl2_def_id, impl2_substs)\n+        };\n+\n+        check_static_lifetimes(tcx, &parent_substs, span);\n+        check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n+\n+        check_predicates(infcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n+    }\n+}\n+\n+/// Given a specializing impl `impl1`, and the base impl `impl2`, returns two\n+/// substitutions `(S1, S2)` that equate their trait references. The returned\n+/// types are expressed in terms of the generics of `impl1`.\n+///\n+/// Example\n+///\n+/// impl<A, B> Foo<A> for B { /* impl2 */ }\n+/// impl<C> Foo<Vec<C>> for C { /* impl1 */ }\n+///\n+/// Would return `S1 = [C]` and `S2 = [Vec<C>, C]`.\n+fn get_impl_substs<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    impl1_def_id: DefId,\n+    impl2_node: Node,\n+    span: Span,\n+) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n+    let tcx = infcx.tcx;\n+    let param_env = tcx.param_env(impl1_def_id);\n+\n+    let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id);\n+    let impl2_substs = translate_substs(infcx, param_env, impl1_def_id, impl1_substs, impl2_node);\n+\n+    // Conservatively use an empty `ParamEnv`.\n+    let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n+    infcx.resolve_regions_and_report_errors(\n+        impl1_def_id,\n+        &ScopeTree::default(),\n+        &outlives_env,\n+        SuppressRegionErrors::default(),\n+    );\n+    let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n+        Ok(s) => s,\n+        Err(_) => {\n+            tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();\n+            return None;\n+        }\n+    };\n+    Some((impl1_substs, impl2_substs))\n+}\n+\n+/// Returns a list of all of the unconstrained subst of the given impl.\n+///\n+/// For example given the impl:\n+///\n+/// impl<'a, T, I> ... where &'a I: IntoIterator<Item=&'a T>\n+///\n+/// This would return the substs corresponding to `['a, I]`, because knowing\n+/// `'a` and `I` determines the value of `T`.\n+fn unconstrained_parent_impl_substs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: SubstsRef<'tcx>,\n+) -> Vec<GenericArg<'tcx>> {\n+    let impl_generic_predicates = tcx.predicates_of(impl_def_id);\n+    let mut unconstrained_parameters = FxHashSet::default();\n+    let mut constrained_params = FxHashSet::default();\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+\n+    // Unfortunately the functions in `constrained_generic_parameters` don't do\n+    // what we want here. We want only a list of constrained parameters while\n+    // the functions in `cgp` add the constrained parameters to a list of\n+    // unconstrained parameters.\n+    for (predicate, _) in impl_generic_predicates.predicates.iter() {\n+        if let ty::Predicate::Projection(proj) = predicate {\n+            let projection_ty = proj.skip_binder().projection_ty;\n+            let projected_ty = proj.skip_binder().ty;\n+\n+            let unbound_trait_ref = projection_ty.trait_ref(tcx);\n+            if Some(unbound_trait_ref) == impl_trait_ref {\n+                continue;\n+            }\n+\n+            unconstrained_parameters.extend(cgp::parameters_for(&projection_ty, true));\n+\n+            for param in cgp::parameters_for(&projected_ty, false) {\n+                if !unconstrained_parameters.contains(&param) {\n+                    constrained_params.insert(param.0);\n+                }\n+            }\n+\n+            unconstrained_parameters.extend(cgp::parameters_for(&projected_ty, true));\n+        }\n+    }\n+\n+    impl_substs\n+        .iter()\n+        .enumerate()\n+        .filter(|&(idx, _)| !constrained_params.contains(&(idx as u32)))\n+        .map(|(_, arg)| *arg)\n+        .collect()\n+}\n+\n+/// Check that parameters of the derived impl don't occur more than once in the\n+/// equated substs of the base impl.\n+///\n+/// For example forbid the following:\n+///\n+/// impl<A> Tr for A { }\n+/// impl<B> Tr for (B, B) { }\n+///\n+/// Note that only consider the unconstrained parameters of the base impl:\n+///\n+/// impl<S, I: IntoIterator<Item = S>> Tr<S> for I { }\n+/// impl<T> Tr<T> for Vec<T> { }\n+///\n+/// The substs for the parent impl here are `[T, Vec<T>]`, which repeats `T`,\n+/// but `S` is constrained in the parent impl, so `parent_substs` is only\n+/// `[Vec<T>]`. This means we allow this impl.\n+fn check_duplicate_params<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl1_substs: SubstsRef<'tcx>,\n+    parent_substs: &Vec<GenericArg<'tcx>>,\n+    span: Span,\n+) {\n+    let mut base_params = cgp::parameters_for(parent_substs, true);\n+    base_params.sort_by_key(|param| param.0);\n+    if let (_, [duplicate, ..]) = base_params.partition_dedup() {\n+        let param = impl1_substs[duplicate.0 as usize];\n+        tcx.sess\n+            .struct_span_err(span, &format!(\"specializing impl repeats parameter `{}`\", param))\n+            .emit();\n+    }\n+}\n+\n+/// Check that `'static` lifetimes are not introduced by the specializing impl.\n+///\n+/// For example forbid the following:\n+///\n+/// impl<A> Tr for A { }\n+/// impl Tr for &'static i32 { }\n+fn check_static_lifetimes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    parent_substs: &Vec<GenericArg<'tcx>>,\n+    span: Span,\n+) {\n+    if tcx.any_free_region_meets(parent_substs, |r| *r == ty::ReStatic) {\n+        tcx.sess.struct_span_err(span, &format!(\"cannot specialize on `'static` lifetime\")).emit();\n+    }\n+}\n+\n+/// Check whether predicates on the specializing impl (`impl1`) are allowed.\n+///\n+/// Each predicate `P` must be:\n+///\n+/// * global (not reference any parameters)\n+/// * `T: Tr` predicate where `Tr` is an always-applicable trait\n+/// * on the base `impl impl2`\n+///     * Currently this check is done using syntactic equality, which is\n+///       conservative but generally sufficient.\n+/// * a well-formed predicate of a type argument of the trait being implemented,\n+///   including the `Self`-type.\n+fn check_predicates<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    impl1_def_id: DefId,\n+    impl1_substs: SubstsRef<'tcx>,\n+    impl2_node: Node,\n+    impl2_substs: SubstsRef<'tcx>,\n+    span: Span,\n+) {\n+    let tcx = infcx.tcx;\n+    let impl1_predicates = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n+    let mut impl2_predicates = if impl2_node.is_from_trait() {\n+        // Always applicable traits have to be always applicable without any\n+        // assumptions.\n+        InstantiatedPredicates::empty()\n+    } else {\n+        tcx.predicates_of(impl2_node.def_id()).instantiate(tcx, impl2_substs)\n+    };\n+    debug!(\n+        \"check_always_applicable(\\nimpl1_predicates={:?},\\nimpl2_predicates={:?}\\n)\",\n+        impl1_predicates, impl2_predicates,\n+    );\n+\n+    // Since impls of always applicable traits don't get to assume anything, we\n+    // can also assume their supertraits apply.\n+    //\n+    // For example, we allow:\n+    //\n+    // #[rustc_specialization_trait]\n+    // trait AlwaysApplicable: Debug { }\n+    //\n+    // impl<T> Tr for T { }\n+    // impl<T: AlwaysApplicable> Tr for T { }\n+    //\n+    // Specializing on `AlwaysApplicable` allows also specializing on `Debug`\n+    // which is sound because we forbid impls like the following\n+    //\n+    // impl<D: Debug> AlwaysApplicable for D { }\n+    let always_applicable_traits: Vec<_> = impl1_predicates\n+        .predicates\n+        .iter()\n+        .filter(|predicate| {\n+            matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::AlwaysApplicable)\n+            )\n+        })\n+        .copied()\n+        .collect();\n+\n+    // Include the well-formed predicates of the type parameters of the impl.\n+    for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {\n+        if let Some(obligations) = wf::obligations(\n+            infcx,\n+            tcx.param_env(impl1_def_id),\n+            tcx.hir().as_local_hir_id(impl1_def_id).unwrap(),\n+            ty,\n+            span,\n+        ) {\n+            impl2_predicates\n+                .predicates\n+                .extend(obligations.into_iter().map(|obligation| obligation.predicate))\n+        }\n+    }\n+    impl2_predicates.predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n+\n+    for predicate in impl1_predicates.predicates {\n+        if !impl2_predicates.predicates.contains(&predicate) {\n+            check_specialization_on(tcx, &predicate, span)\n+        }\n+    }\n+}\n+\n+fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'tcx>, span: Span) {\n+    debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n+    match predicate {\n+        // Global predicates are either always true or always false, so we\n+        // are fine to specialize on.\n+        _ if predicate.is_global() => (),\n+        // We allow specializing on explicitly marked traits with no associated\n+        // items.\n+        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+            if !matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::Marker)\n+            ) {\n+                tcx.sess\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"cannot specialize on trait `{}`\",\n+                            tcx.def_path_str(pred.def_id()),\n+                        ),\n+                    )\n+                    .emit()\n+            }\n+        }\n+        _ => tcx\n+            .sess\n+            .struct_span_err(span, &format!(\"cannot specialize on `{:?}`\", predicate))\n+            .emit(),\n+    }\n+}\n+\n+fn trait_predicate_kind<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicate: &ty::Predicate<'tcx>,\n+) -> Option<TraitSpecializationKind> {\n+    match predicate {\n+        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+            Some(tcx.trait_def(pred.def_id()).specialization_kind)\n+        }\n+        ty::Predicate::Trait(_, hir::Constness::Const)\n+        | ty::Predicate::RegionOutlives(_)\n+        | ty::Predicate::TypeOutlives(_)\n+        | ty::Predicate::Projection(_)\n+        | ty::Predicate::WellFormed(_)\n+        | ty::Predicate::Subtype(_)\n+        | ty::Predicate::ObjectSafe(_)\n+        | ty::Predicate::ClosureKind(..)\n+        | ty::Predicate::ConstEvaluatable(..) => None,\n+    }\n+}"}, {"sha": "bab354cff7c9c7aa9ef6f37b7663e185f0bfb7b0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -64,6 +64,7 @@ This API is completely unstable and subject to change.\n #![feature(nll)]\n #![feature(try_blocks)]\n #![feature(never_type)]\n+#![feature(slice_partition_dedup)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "703f60e5250a25efd689eae651d3354d3fbe65cb", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -292,7 +292,8 @@\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n-#![feature(specialization)]\n+#![cfg_attr(bootstrap, feature(specialization))]\n+#![cfg_attr(not(bootstrap), feature(min_specialization))]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stdsimd)]"}, {"sha": "6ec0d261d518aa266dbb7612bb775dfe36a070a4", "filename": "src/test/ui/specialization/min_specialization/auxiliary/specialization-trait.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fauxiliary%2Fspecialization-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fauxiliary%2Fspecialization-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fauxiliary%2Fspecialization-trait.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,6 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+pub trait SpecTrait {\n+    fn method(&self);\n+}"}, {"sha": "03cab00b0fb965cf2680726b22b590e77d6f46fb", "filename": "src/test/ui/specialization/min_specialization/dyn-trait-assoc-types.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,32 @@\n+// Test that associated types in trait objects are not considered to be\n+// constrained.\n+\n+#![feature(min_specialization)]\n+\n+trait Specializable {\n+    fn f();\n+}\n+\n+trait B<T> {\n+    type Y;\n+}\n+\n+trait C {\n+    type Y;\n+}\n+\n+impl<A: ?Sized> Specializable for A {\n+    default fn f() {}\n+}\n+\n+impl<'a, T> Specializable for dyn B<T, Y = T> + 'a {\n+    //~^ ERROR specializing impl repeats parameter `T`\n+    fn f() {}\n+}\n+\n+impl<'a, T> Specializable for dyn C<Y = (T, T)> + 'a {\n+    //~^ ERROR specializing impl repeats parameter `T`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "6345cee2c3781ee529b387a016071ad2d9aafece", "filename": "src/test/ui/specialization/min_specialization/dyn-trait-assoc-types.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fdyn-trait-assoc-types.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,20 @@\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/dyn-trait-assoc-types.rs:22:1\n+   |\n+LL | / impl<'a, T> Specializable for dyn B<T, Y = T> + 'a {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/dyn-trait-assoc-types.rs:27:1\n+   |\n+LL | / impl<'a, T> Specializable for dyn C<Y = (T, T)> + 'a {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "723ed71c3e95dbd67e63f90316ff2c392f174e94", "filename": "src/test/ui/specialization/min_specialization/impl_specialization_trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimpl_specialization_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimpl_specialization_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimpl_specialization_trait.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,16 @@\n+// Check that specialization traits can't be implemented without a feature.\n+\n+// gate-test-min_specialization\n+\n+// aux-build:specialization-trait.rs\n+\n+extern crate specialization_trait;\n+\n+struct A {}\n+\n+impl specialization_trait::SpecTrait for A {\n+    //~^ ERROR implementing `rustc_specialization_trait` traits is unstable\n+    fn method(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "934103d49dc0e21fe5595f741aaf4deb7bd4b8fc", "filename": "src/test/ui/specialization/min_specialization/impl_specialization_trait.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimpl_specialization_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimpl_specialization_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimpl_specialization_trait.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,10 @@\n+error: implementing `rustc_specialization_trait` traits is unstable\n+  --> $DIR/impl_specialization_trait.rs:11:1\n+   |\n+LL | impl specialization_trait::SpecTrait for A {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(min_specialization)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}, {"sha": "98d7f9194351c078e6696e7bb5ae14b8e8b81d81", "filename": "src/test/ui/specialization/min_specialization/implcit-well-formed-bounds.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimplcit-well-formed-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimplcit-well-formed-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimplcit-well-formed-bounds.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,30 @@\n+// Test that specializing on the well-formed predicates of the trait and\n+// self-type of an impl is allowed.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+\n+struct OrdOnly<T: Ord>(T);\n+\n+trait SpecTrait<U> {\n+    fn f();\n+}\n+\n+impl<T, U> SpecTrait<U> for T {\n+    default fn f() {}\n+}\n+\n+impl<T: Ord> SpecTrait<()> for OrdOnly<T> {\n+    fn f() {}\n+}\n+\n+impl<T: Ord> SpecTrait<OrdOnly<T>> for () {\n+    fn f() {}\n+}\n+\n+impl<T: Ord, U: Ord, V: Ord> SpecTrait<(OrdOnly<T>, OrdOnly<U>)> for &[OrdOnly<V>] {\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "f21f39f066981f922833615da1162050ebd36194", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,24 @@\n+// Test that projection bounds can't be specialized on.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+trait Id {\n+    type This;\n+}\n+impl<T> Id for T {\n+    type This = T;\n+}\n+\n+impl<T: Id> X for T {\n+    default fn f() {}\n+}\n+\n+impl<I, V: Id<This = (I,)>> X for V {\n+    //~^ ERROR cannot specialize on\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "7cc4357a704c0feeb51484e89b2cbb404d880235", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id[0]::This[0]) }, (I,)))`\n+  --> $DIR/repeated_projection_type.rs:19:1\n+   |\n+LL | / impl<I, V: Id<This = (I,)>> X for V {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "49bfacec0ae12d3c370182b8ae31ffaccfbacd12", "filename": "src/test/ui/specialization/min_specialization/repeating_lifetimes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,19 @@\n+// Test that directly specializing on repeated lifetime parameters is not\n+// allowed.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+\n+impl<'a> X for (&'a u8, &'a u8) {\n+    //~^ ERROR specializing impl repeats parameter `'a`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "ce9309f70122b90b8f0cf9c35abc72b6f55fbb42", "filename": "src/test/ui/specialization/min_specialization/repeating_lifetimes.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_lifetimes.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,11 @@\n+error: specializing impl repeats parameter `'a`\n+  --> $DIR/repeating_lifetimes.rs:14:1\n+   |\n+LL | / impl<'a> X for (&'a u8, &'a u8) {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5a1c97fd321a9bd9e8d02e9a3ad4953fba4ab478", "filename": "src/test/ui/specialization/min_specialization/repeating_param.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,17 @@\n+// Test that specializing on two type parameters being equal is not allowed.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+impl<T> X for (T, T) {\n+    //~^ ERROR specializing impl repeats parameter `T`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "8b4be1c499537b1e2160e51ce778b40e0e29980a", "filename": "src/test/ui/specialization/min_specialization/repeating_param.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeating_param.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,11 @@\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/repeating_param.rs:12:1\n+   |\n+LL | / impl<T> X for (T, T) {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e17e9dd5f133c8bf24b1db557e95697eaea1aff9", "filename": "src/test/ui/specialization/min_specialization/spec-iter.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-iter.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,20 @@\n+// Check that we can specialize on a concrete iterator type. This requires us\n+// to consider which parameters in the parent impl are constrained.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+\n+trait SpecFromIter<T> {\n+    fn f(&self);\n+}\n+\n+impl<'a, T: 'a, I: Iterator<Item = &'a T>> SpecFromIter<T> for I {\n+    default fn f(&self) {}\n+}\n+\n+impl<'a, T> SpecFromIter<T> for std::slice::Iter<'a, T> {\n+    fn f(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "377889e2ccad28b76b000f19899fea8df7ff98df", "filename": "src/test/ui/specialization/min_specialization/spec-reference.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-reference.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,19 @@\n+// Check that lifetime parameters are allowed in specializing impls.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+\n+trait MySpecTrait {\n+    fn f();\n+}\n+\n+impl<T> MySpecTrait for T {\n+    default fn f() {}\n+}\n+\n+impl<'a, T: ?Sized> MySpecTrait for &'a T {\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "93462d02ea578ede01fc25aae1af8b4255d8a9de", "filename": "src/test/ui/specialization/min_specialization/specialization_marker.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,17 @@\n+// Test that `rustc_unsafe_specialization_marker` is only allowed on marker traits.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_unsafe_specialization_marker]\n+trait SpecMarker {\n+    fn f();\n+    //~^ ERROR marker traits\n+}\n+\n+#[rustc_unsafe_specialization_marker]\n+trait SpecMarker2 {\n+    type X;\n+    //~^ ERROR marker traits\n+}\n+\n+fn main() {}"}, {"sha": "ffeced198211f0d148aa5ec6f3334be3a7727c74", "filename": "src/test/ui/specialization/min_specialization/specialization_marker.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_marker.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,15 @@\n+error[E0714]: marker traits cannot have associated items\n+  --> $DIR/specialization_marker.rs:7:5\n+   |\n+LL |     fn f();\n+   |     ^^^^^^^\n+\n+error[E0714]: marker traits cannot have associated items\n+  --> $DIR/specialization_marker.rs:13:5\n+   |\n+LL |     type X;\n+   |     ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0714`."}, {"sha": "145f376edf938cf3e17bb7f3ff7a8d79e89b8c90", "filename": "src/test/ui/specialization/min_specialization/specialization_super_trait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,18 @@\n+// Test that supertraits can't be assumed in impls of\n+// `rustc_specialization_trait`, as such impls would\n+// allow specializing on the supertrait.\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait SpecMarker: Default {\n+    fn f();\n+}\n+\n+impl<T: Default> SpecMarker for T {\n+    //~^ ERROR cannot specialize\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "154c839c6da6e81eb5ab8a43b5e93fd41ad5fefe", "filename": "src/test/ui/specialization/min_specialization/specialization_super_trait.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on trait `std::default::Default`\n+  --> $DIR/specialization_super_trait.rs:13:1\n+   |\n+LL | / impl<T: Default> SpecMarker for T {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d597278d29693ac5577c5cacaca5a69372341997", "filename": "src/test/ui/specialization/min_specialization/specialization_trait.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,26 @@\n+// Test that `rustc_specialization_trait` requires always applicable impls.\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait SpecMarker {\n+    fn f();\n+}\n+\n+impl SpecMarker for &'static u8 {\n+    //~^ ERROR cannot specialize\n+    fn f() {}\n+}\n+\n+impl<T> SpecMarker for (T, T) {\n+    //~^ ERROR specializing impl\n+    fn f() {}\n+}\n+\n+impl<T: Clone> SpecMarker for [T] {\n+    //~^ ERROR cannot specialize\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "4357d2318fc5dcce82883468691df3a03fc02533", "filename": "src/test/ui/specialization/min_specialization/specialization_trait.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,29 @@\n+error: cannot specialize on `'static` lifetime\n+  --> $DIR/specialization_trait.rs:11:1\n+   |\n+LL | / impl SpecMarker for &'static u8 {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: specializing impl repeats parameter `T`\n+  --> $DIR/specialization_trait.rs:16:1\n+   |\n+LL | / impl<T> SpecMarker for (T, T) {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: cannot specialize on trait `std::clone::Clone`\n+  --> $DIR/specialization_trait.rs:21:1\n+   |\n+LL | / impl<T: Clone> SpecMarker for [T] {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "4219bd13b1816cdc3331c6b0f65f3521dbf4832f", "filename": "src/test/ui/specialization/min_specialization/specialize_on_marker.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_marker.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,24 @@\n+// Test that specializing on a `rustc_unsafe_specialization_marker` trait is\n+// allowed.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_unsafe_specialization_marker]\n+trait SpecMarker {}\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+\n+impl<T: SpecMarker> X for T {\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "abbab5c23dbb760cc07f77d0fe7c91655adc3eec", "filename": "src/test/ui/specialization/min_specialization/specialize_on_spec_trait.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_spec_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_spec_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_spec_trait.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,27 @@\n+// Test that specializing on a `rustc_specialization_trait` trait is allowed.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait SpecTrait {\n+    fn g(&self);\n+}\n+\n+trait X {\n+    fn f(&self);\n+}\n+\n+impl<T> X for T {\n+    default fn f(&self) {}\n+}\n+\n+impl<T: SpecTrait> X for T {\n+    fn f(&self) {\n+        self.g();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "dd1b05401e6e7dc754fd695f896172517517f0e9", "filename": "src/test/ui/specialization/min_specialization/specialize_on_static.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,18 @@\n+// Test that directly specializing on `'static` is not allowed.\n+\n+#![feature(min_specialization)]\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for &'_ T {\n+    default fn f() {}\n+}\n+\n+impl X for &'static u8 {\n+    //~^ ERROR cannot specialize on `'static` lifetime\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "d1809d6dfbb527ef80ed8acd6dc7430f29977f89", "filename": "src/test/ui/specialization/min_specialization/specialize_on_static.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_static.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on `'static` lifetime\n+  --> $DIR/specialize_on_static.rs:13:1\n+   |\n+LL | / impl X for &'static u8 {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0588442c320807e89157339ee0e32c19a55b17a1", "filename": "src/test/ui/specialization/min_specialization/specialize_on_trait.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.rs?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,20 @@\n+// Test that specializing on a trait is not allowed in general.\n+\n+#![feature(min_specialization)]\n+\n+trait SpecMarker {}\n+\n+trait X {\n+    fn f();\n+}\n+\n+impl<T> X for T {\n+    default fn f() {}\n+}\n+\n+impl<T: SpecMarker> X for T {\n+    //~^ ERROR cannot specialize on trait `SpecMarker`\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "35445fd09b949ce606225270583d5bf07be1e620", "filename": "src/test/ui/specialization/min_specialization/specialize_on_trait.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e24252a12cd2b6adf8678255939156a2d178fe2a/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr?ref=e24252a12cd2b6adf8678255939156a2d178fe2a", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on trait `SpecMarker`\n+  --> $DIR/specialize_on_trait.rs:15:1\n+   |\n+LL | / impl<T: SpecMarker> X for T {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}]}