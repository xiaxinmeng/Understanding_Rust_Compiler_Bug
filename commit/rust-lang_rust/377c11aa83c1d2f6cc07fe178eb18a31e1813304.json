{"sha": "377c11aa83c1d2f6cc07fe178eb18a31e1813304", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3N2MxMWFhODNjMWQyZjZjYzA3ZmUxNzhlYjE4YTMxZTE4MTMzMDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-13T05:19:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-16T01:09:17Z"}, "message": "collections: Add issues for unstable features", "tree": {"sha": "cfbe368801c2229c7caab2ecbe7381be1e810b1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfbe368801c2229c7caab2ecbe7381be1e810b1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/377c11aa83c1d2f6cc07fe178eb18a31e1813304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/377c11aa83c1d2f6cc07fe178eb18a31e1813304", "html_url": "https://github.com/rust-lang/rust/commit/377c11aa83c1d2f6cc07fe178eb18a31e1813304", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/377c11aa83c1d2f6cc07fe178eb18a31e1813304/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3263d41bac17fe55093117b285e5addcbc5f41d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3263d41bac17fe55093117b285e5addcbc5f41d5", "html_url": "https://github.com/rust-lang/rust/commit/3263d41bac17fe55093117b285e5addcbc5f41d5"}], "stats": {"total": 185, "additions": 120, "deletions": 65}, "files": [{"sha": "b817ed6a6d0ebfe2e5fce8df4923ff2cb15f9de5", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -547,7 +547,8 @@ impl<T: Ord> BinaryHeap<T> {\n     #[inline]\n     #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, \\\n-                         waiting for dust to settle\")]\n+                         waiting for dust to settle\",\n+               issue = \"27711\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain(..) }\n     }\n@@ -685,7 +686,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable(feature = \"drain\", reason = \"recent addition\")]\n+#[unstable(feature = \"drain\", reason = \"recent addition\", issue = \"27711\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }"}, {"sha": "bfd069152509de024da0c8dcd0035a3bcecf2d01", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -344,7 +344,8 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n }\n \n /// Trait for moving into a `Cow`.\n-#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n+           issue = \"27735\")]\n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     /// Moves `self` into `Cow`\n     fn into_cow(self) -> Cow<'a, B>;"}, {"sha": "2835e28a9462c61dc0246a9630d183622ec3cb4f", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -157,6 +157,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with the given B.\n     ///\n     /// B cannot be less than 2.\n+    #[unstable(feature = \"btree_b\",\n+               reason = \"probably want this to be on the type, eventually\",\n+               issue = \"27795\")]\n     pub fn with_b(b: usize) -> BTreeMap<K, V> {\n         assert!(b > 1, \"B must be greater than 1\");\n         BTreeMap {\n@@ -1504,7 +1507,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n     #[unstable(feature = \"btree_range\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27787\")]\n     pub fn range<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&self, min: Bound<&Min>,\n                                                                max: Bound<&Max>)\n         -> Range<K, V> where\n@@ -1537,7 +1541,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[unstable(feature = \"btree_range\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27787\")]\n     pub fn range_mut<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&mut self, min: Bound<&Min>,\n                                                                    max: Bound<&Max>)\n         -> RangeMut<K, V> where"}, {"sha": "a942d6aa6696a79736c560d367d13ee883149e6a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -101,7 +101,8 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// B cannot be less than 2.\n     #[unstable(feature = \"btree_b\",\n-               reason = \"probably want this to be on the type, eventually\")]\n+               reason = \"probably want this to be on the type, eventually\",\n+               issue = \"27795\")]\n     pub fn with_b(b: usize) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n@@ -154,7 +155,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(Some(&5), set.range(Included(&4), Unbounded).next());\n     /// ```\n     #[unstable(feature = \"btree_range\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27787\")]\n     pub fn range<'a, Min: ?Sized + Ord = T, Max: ?Sized + Ord = T>(&'a self, min: Bound<&Min>,\n                                                                    max: Bound<&Max>)\n         -> Range<'a, T> where"}, {"sha": "7e7e8ba2356e36b6396328f19c0769a3f7d41286", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -15,7 +15,8 @@\n \n #![unstable(feature = \"enumset\",\n             reason = \"matches collection reform specification, \\\n-                      waiting for dust to settle\")]\n+                      waiting for dust to settle\",\n+            issue = \"0\")]\n \n use core::marker;\n use core::fmt;"}, {"sha": "702b01f0e2eeeabd290770b8665081efa4872820", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -20,7 +20,8 @@\n #![crate_type = \"rlib\"]\n #![unstable(feature = \"collections\",\n             reason = \"library is unlikely to be stabilized with the current \\\n-                      layout and name, use std::collections instead\")]\n+                      layout and name, use std::collections instead\",\n+            issue = \"27783\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -110,7 +111,7 @@ mod std {\n }\n \n /// An endpoint of a range of keys.\n-#[unstable(feature = \"collections_bound\")]\n+#[unstable(feature = \"collections_bound\", issue = \"27711\")]\n #[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n pub enum Bound<T> {\n     /// An inclusive bound."}, {"sha": "80ef2067819cfcb60be0a8bb40571926a7634f1c", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -801,7 +801,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"linked_list_extras\",\n-               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n+               reason = \"this is probably better handled by a cursor type -- we'll see\",\n+               issue = \"27794\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n     }\n@@ -825,7 +826,8 @@ impl<'a, A> IterMut<'a, A> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"linked_list_extras\",\n-               reason = \"this is probably better handled by a cursor type -- we'll see\")]\n+               reason = \"this is probably better handled by a cursor type -- we'll see\",\n+               issue = \"27794\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n             return None"}, {"sha": "e7414bcf323f68604394ffdda00a6dafd214038c", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"collections_range\", reason = \"was just added\")]\n+#![unstable(feature = \"collections_range\", reason = \"was just added\",\n+            issue = \"27711\")]\n \n //! Range syntax.\n "}, {"sha": "76bdd6dbea1221a69da5864a649ebb97f8233b20", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -214,29 +214,29 @@ impl<T> [T] {\n     }\n \n     /// Returns the first and all the rest of the elements of a slice.\n-    #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\", issue = \"27742\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n         core_slice::SliceExt::split_first(self)\n     }\n \n     /// Returns the first and all the rest of the elements of a slice.\n-    #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\", issue = \"27742\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n         core_slice::SliceExt::split_first_mut(self)\n     }\n \n     /// Returns the last and all the rest of the elements of a slice.\n-    #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\", issue = \"27742\")]\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n         core_slice::SliceExt::split_last(self)\n \n     }\n \n     /// Returns the last and all the rest of the elements of a slice.\n-    #[unstable(feature = \"slice_splits\", since = \"1.3.0\")]\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\", issue = \"27742\")]\n     #[inline]\n     pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n         core_slice::SliceExt::split_last_mut(self)\n@@ -785,7 +785,7 @@ impl<T> [T] {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"clone_from_slice\")]\n+    #[unstable(feature = \"clone_from_slice\", issue = \"27750\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n@@ -811,11 +811,13 @@ impl<T> [T] {\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n #[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\")]\n+           reason = \"trait should not have to exist\",\n+           issue = \"27747\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized> {\n     #[unstable(feature = \"slice_concat_ext\",\n-               reason = \"trait should not have to exist\")]\n+               reason = \"trait should not have to exist\",\n+               issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n "}, {"sha": "657a3f60448e4de348bc01041f460fd20b8aa4cd", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -105,7 +105,7 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"str_utf16\")]\n+#[unstable(feature = \"str_utf16\", issue = \"27714\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n@@ -211,7 +211,8 @@ impl str {\n                reason = \"it is unclear whether this method pulls its weight \\\n                          with the existence of the char_indices iterator or \\\n                          this method may want to be replaced with checked \\\n-                         slicing\")]\n+                         slicing\",\n+               issue = \"27754\")]\n     #[inline]\n     pub fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(self, index)\n@@ -275,7 +276,8 @@ impl str {\n     /// Takes a bytewise mutable slice from a string.\n     ///\n     /// Same as `slice_unchecked`, but works with `&mut str` instead of `&str`.\n-    #[unstable(feature = \"str_slice_mut\", reason = \"recently added\")]\n+    #[unstable(feature = \"str_slice_mut\", reason = \"recently added\",\n+               issue = \"27793\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n         core_str::StrExt::slice_mut_unchecked(self, begin, end)\n@@ -329,7 +331,8 @@ impl str {\n     #[unstable(feature = \"str_char\",\n                reason = \"often replaced by char_indices, this method may \\\n                          be removed in favor of just char_at() or eventually \\\n-                         removed altogether\")]\n+                         removed altogether\",\n+               issue = \"27754\")]\n     #[inline]\n     pub fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(self, start)\n@@ -388,7 +391,8 @@ impl str {\n     #[unstable(feature = \"str_char\",\n                reason = \"often replaced by char_indices, this method may \\\n                          be removed in favor of just char_at_reverse() or \\\n-                         eventually removed altogether\")]\n+                         eventually removed altogether\",\n+               issue = \"27754\")]\n     #[inline]\n     pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(self, start)\n@@ -416,7 +420,8 @@ impl str {\n                          method may be removed or possibly renamed in the \\\n                          future; it is normally replaced by chars/char_indices \\\n                          iterators or by getting the first char from a \\\n-                         subslice\")]\n+                         subslice\",\n+               issue = \"27754\")]\n     #[inline]\n     pub fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(self, i)\n@@ -443,7 +448,8 @@ impl str {\n     #[unstable(feature = \"str_char\",\n                reason = \"see char_at for more details, but reverse semantics \\\n                          are also somewhat unclear, especially with which \\\n-                         cases generate panics\")]\n+                         cases generate panics\",\n+               issue = \"27754\")]\n     #[inline]\n     pub fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(self, i)\n@@ -478,7 +484,8 @@ impl str {\n     #[unstable(feature = \"str_char\",\n                reason = \"awaiting conventions about shifting and slices and \\\n                          may not be warranted with the existence of the chars \\\n-                         and/or char_indices iterators\")]\n+                         and/or char_indices iterators\",\n+               issue = \"27754\")]\n     #[inline]\n     pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(self)\n@@ -508,14 +515,16 @@ impl str {\n     /// assert_eq!(b, \" \u8001\u864e L\u00e9opard\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_at\", reason = \"recently added\")]\n+    #[unstable(feature = \"str_split_at\", reason = \"recently added\",\n+               issue = \"27792\")]\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         core_str::StrExt::split_at(self, mid)\n     }\n \n     /// Divide one mutable string slice into two at an index.\n     #[inline]\n-    #[unstable(feature = \"str_split_at\", reason = \"recently added\")]\n+    #[unstable(feature = \"str_split_at\", reason = \"recently added\",\n+               issue = \"27792\")]\n     pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n         core_str::StrExt::split_at_mut(self, mid)\n     }\n@@ -652,7 +661,8 @@ impl str {\n \n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable(feature = \"str_utf16\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+               reason = \"this functionality may only be provided by libunicode\",\n+               issue = \"27714\")]\n     pub fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n     }\n@@ -1186,7 +1196,8 @@ impl str {\n     /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n     #[unstable(feature = \"str_match_indices\",\n-               reason = \"might have its iterator type changed\")]\n+               reason = \"might have its iterator type changed\",\n+               issue = \"27743\")]\n     // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n     // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n     pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n@@ -1231,7 +1242,8 @@ impl str {\n     /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n     /// ```\n     #[unstable(feature = \"str_match_indices\",\n-               reason = \"might have its iterator type changed\")]\n+               reason = \"might have its iterator type changed\",\n+               issue = \"27743\")]\n     // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n     // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n     pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n@@ -1476,21 +1488,24 @@ impl str {\n \n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\")]\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n     pub fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n     #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\")]\n+               reason = \"return type may change to be an iterator\",\n+               issue = \"27791\")]\n     pub fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n \n     /// Converts the `Box<str>` into a `String` without copying or allocating.\n     #[unstable(feature = \"box_str\",\n-               reason = \"recently added, matches RFC\")]\n+               reason = \"recently added, matches RFC\",\n+               issue = \"27785\")]\n     pub fn into_string(self: Box<str>) -> String {\n         unsafe {\n             let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);"}, {"sha": "5c5f6cace6a4b0cf51386c811bbfe153371c4de0", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -343,7 +343,8 @@ impl String {\n     /// Extracts a string slice containing the entire string.\n     #[inline]\n     #[unstable(feature = \"convert\",\n-               reason = \"waiting on RFC revision\")]\n+               reason = \"waiting on RFC revision\",\n+               issue = \"27729\")]\n     pub fn as_str(&self) -> &str {\n         self\n     }\n@@ -698,7 +699,8 @@ impl String {\n     /// assert_eq!(s, \"\");\n     /// ```\n     #[unstable(feature = \"drain\",\n-               reason = \"recently added, matches RFC\")]\n+               reason = \"recently added, matches RFC\",\n+               issue = \"27711\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeArgument<usize> {\n         // Memory safety\n         //\n@@ -728,7 +730,8 @@ impl String {\n     ///\n     /// Note that this will drop any excess capacity.\n     #[unstable(feature = \"box_str\",\n-               reason = \"recently added, matches RFC\")]\n+               reason = \"recently added, matches RFC\",\n+               issue = \"27785\")]\n     pub fn into_boxed_str(self) -> Box<str> {\n         let slice = self.vec.into_boxed_slice();\n         unsafe { mem::transmute::<Box<[u8]>, Box<str>>(slice) }\n@@ -1019,7 +1022,8 @@ impl ops::DerefMut for String {\n \n /// Error returned from `String::from`\n #[unstable(feature = \"str_parse_error\", reason = \"may want to be replaced with \\\n-                                                  Void if it ever exists\")]\n+                                                  Void if it ever exists\",\n+           issue = \"27734\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub struct ParseError(());\n \n@@ -1110,15 +1114,17 @@ impl Into<Vec<u8>> for String {\n     }\n }\n \n-#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n+           issue= \"27735\")]\n impl IntoCow<'static, str> for String {\n     #[inline]\n     fn into_cow(self) -> Cow<'static, str> {\n         Cow::Owned(self)\n     }\n }\n \n-#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n+           issue = \"27735\")]\n impl<'a> IntoCow<'a, str> for &'a str {\n     #[inline]\n     fn into_cow(self) -> Cow<'a, str> {\n@@ -1142,7 +1148,7 @@ impl fmt::Write for String {\n }\n \n /// A draining iterator for `String`.\n-#[unstable(feature = \"drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\", issue = \"27711\")]\n pub struct Drain<'a> {\n     /// Will be used as &'a mut String in the destructor\n     string: *mut String,\n@@ -1157,7 +1163,7 @@ pub struct Drain<'a> {\n unsafe impl<'a> Sync for Drain<'a> {}\n unsafe impl<'a> Send for Drain<'a> {}\n \n-#[unstable(feature = \"drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\", issue = \"27711\")]\n impl<'a> Drop for Drain<'a> {\n     fn drop(&mut self) {\n         unsafe {\n@@ -1171,7 +1177,7 @@ impl<'a> Drop for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\", issue = \"27711\")]\n impl<'a> Iterator for Drain<'a> {\n     type Item = char;\n \n@@ -1185,7 +1191,7 @@ impl<'a> Iterator for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\", issue = \"27711\")]\n impl<'a> DoubleEndedIterator for Drain<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {"}, {"sha": "ec3c36d0c813765e15014fc944bf541dbce437d2", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -384,7 +384,8 @@ impl<T> Vec<T> {\n     /// Equivalent to `&s[..]`.\n     #[inline]\n     #[unstable(feature = \"convert\",\n-               reason = \"waiting on RFC revision\")]\n+               reason = \"waiting on RFC revision\",\n+               issue = \"27729\")]\n     pub fn as_slice(&self) -> &[T] {\n         self\n     }\n@@ -394,7 +395,8 @@ impl<T> Vec<T> {\n     /// Equivalent to `&mut s[..]`.\n     #[inline]\n     #[unstable(feature = \"convert\",\n-               reason = \"waiting on RFC revision\")]\n+               reason = \"waiting on RFC revision\",\n+               issue = \"27729\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         &mut self[..]\n     }\n@@ -622,7 +624,8 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"append\",\n-               reason = \"new API, waiting for dust to settle\")]\n+               reason = \"new API, waiting for dust to settle\",\n+               issue = \"27765\")]\n     pub fn append(&mut self, other: &mut Self) {\n         self.reserve(other.len());\n         let len = self.len();\n@@ -661,7 +664,8 @@ impl<T> Vec<T> {\n     /// assert_eq!(u, &[1, 2, 3]);\n     /// ```\n     #[unstable(feature = \"drain\",\n-               reason = \"recently added, matches RFC\")]\n+               reason = \"recently added, matches RFC\",\n+               issue = \"27711\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n         // Memory safety\n         //\n@@ -762,7 +766,8 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"split_off\",\n-               reason = \"new API, waiting for dust to settle\")]\n+               reason = \"new API, waiting for dust to settle\",\n+               issue = \"27766\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         assert!(at <= self.len(), \"`at` out of bounds\");\n \n@@ -804,7 +809,8 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[unstable(feature = \"vec_resize\",\n-               reason = \"matches collection reform specification; waiting for dust to settle\")]\n+               reason = \"matches collection reform specification; waiting for dust to settle\",\n+               issue = \"27790\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n@@ -854,7 +860,8 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"vec_push_all\",\n-               reason = \"likely to be replaced by a more optimized extend\")]\n+               reason = \"likely to be replaced by a more optimized extend\",\n+               issue = \"27744\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n@@ -1495,7 +1502,7 @@ impl<T> Drop for IntoIter<T> {\n }\n \n /// A draining iterator for `Vec<T>`.\n-#[unstable(feature = \"drain\", reason = \"recently added\")]\n+#[unstable(feature = \"drain\", reason = \"recently added\", issue = \"27711\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve\n     tail_start: usize,"}, {"sha": "96e24b412d52528bc91bce74733ca16a725ae954", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377c11aa83c1d2f6cc07fe178eb18a31e1813304/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=377c11aa83c1d2f6cc07fe178eb18a31e1813304", "patch": "@@ -467,7 +467,8 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n     #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification; waiting on panic semantics\")]\n+               reason = \"matches collection reform specification; waiting on panic semantics\",\n+               issue = \"27788\")]\n     pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n             self.pop_back();\n@@ -528,7 +529,8 @@ impl<T> VecDeque<T> {\n     /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27788\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -548,7 +550,8 @@ impl<T> VecDeque<T> {\n     /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27788\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let contiguous = self.is_contiguous();\n@@ -615,7 +618,8 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"drain\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+               reason = \"matches collection reform specification, waiting for dust to settle\",\n+               issue = \"27711\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n             inner: self,\n@@ -864,7 +868,8 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf[1], 2);\n     /// ```\n     #[unstable(feature = \"deque_extras\",\n-               reason = \"the naming of this function may be altered\")]\n+               reason = \"the naming of this function may be altered\",\n+               issue = \"27788\")]\n     pub fn swap_back_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n@@ -901,7 +906,8 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf[1], 1);\n     /// ```\n     #[unstable(feature = \"deque_extras\",\n-               reason = \"the naming of this function may be altered\")]\n+               reason = \"the naming of this function may be altered\",\n+               issue = \"27788\")]\n     pub fn swap_front_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length && index != 0 {\n@@ -1311,7 +1317,8 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"split_off\",\n-               reason = \"new API, waiting for dust to settle\")]\n+               reason = \"new API, waiting for dust to settle\",\n+               issue = \"27766\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let len = self.len();\n         assert!(at <= len, \"`at` out of bounds\");\n@@ -1375,7 +1382,8 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"append\",\n-               reason = \"new API, waiting for dust to settle\")]\n+               reason = \"new API, waiting for dust to settle\",\n+               issue = \"27765\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // naive impl\n         self.extend(other.drain());\n@@ -1402,7 +1410,8 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(&v[..], &[2, 4]);\n     /// ```\n     #[unstable(feature = \"vec_deque_retain\",\n-               reason = \"new API, waiting for dust to settle\")]\n+               reason = \"new API, waiting for dust to settle\",\n+               issue = \"27767\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n         let mut del = 0;\n@@ -1441,7 +1450,8 @@ impl<T: Clone> VecDeque<T> {\n     /// }\n     /// ```\n     #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification; waiting on panic semantics\")]\n+               reason = \"matches collection reform specification; waiting on panic semantics\",\n+               issue = \"27788\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n@@ -1610,7 +1620,8 @@ impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining VecDeque iterator\n #[unstable(feature = \"drain\",\n-           reason = \"matches collection reform specification, waiting for dust to settle\")]\n+           reason = \"matches collection reform specification, waiting for dust to settle\",\n+           issue = \"27711\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut VecDeque<T>,\n }"}]}