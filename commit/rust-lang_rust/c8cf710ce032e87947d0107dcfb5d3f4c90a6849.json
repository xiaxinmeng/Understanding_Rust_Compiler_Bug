{"sha": "c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4Y2Y3MTBjZTAzMmU4Nzk0N2QwMTA3ZGNmYjVkM2Y0YzkwYTY4NDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-08T14:08:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:49:24Z"}, "message": "replace `LexicalRegionConstraintData` with `QueryRegionConstraint`", "tree": {"sha": "290aa186fbf2a5873224024ad01b4a4ead97a5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/290aa186fbf2a5873224024ad01b4a4ead97a5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "html_url": "https://github.com/rust-lang/rust/commit/c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2624c14a26bdab3af7c9a6d03c30d6b913cb77f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2624c14a26bdab3af7c9a6d03c30d6b913cb77f5", "html_url": "https://github.com/rust-lang/rust/commit/2624c14a26bdab3af7c9a6d03c30d6b913cb77f5"}], "stats": {"total": 209, "additions": 86, "deletions": 123}, "files": [{"sha": "33e5f6cd3e2710b466cab3e108e5abdaf209f0e0", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "patch": "@@ -44,7 +44,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n \n mod canonicalizer;\n \n-mod query_result;\n+pub mod query_result;\n \n mod substitute;\n "}, {"sha": "4d03ccb42a9f6aa5fbfb0a75aab971ddfaf7f31d", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "patch": "@@ -325,7 +325,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n /// Given the region obligations and constraints scraped from the infcx,\n /// creates query region constraints.\n-fn make_query_outlives<'tcx>(\n+pub fn make_query_outlives<'tcx>(\n     tcx: TyCtxt<'_, '_, 'tcx>,\n     region_obligations: Vec<(ast::NodeId, RegionObligation<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,"}, {"sha": "96e99aae6937388899c930ac31ad5a72950b7b62", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "patch": "@@ -11,13 +11,15 @@\n use borrow_check::location::LocationTable;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n-use borrow_check::nll::type_check::{Locations, LexicalRegionConstraintData};\n+use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use rustc::infer::{self, RegionObligation, SubregionOrigin};\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n-use rustc::infer::region_constraints::{Constraint, GenericKind, VerifyBound};\n+use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n+use rustc::infer::{self, SubregionOrigin};\n use rustc::mir::{Location, Mir};\n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::subst::UnpackedKind;\n use syntax::codemap::Span;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -63,73 +65,70 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert(&mut self, data: &LexicalRegionConstraintData<'tcx>) {\n+    pub(super) fn convert(&mut self, query_constraints: &[QueryRegionConstraint<'tcx>]) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n-        let LexicalRegionConstraintData {\n-            constraints,\n-            region_obligations,\n-        } = data;\n-\n-        for constraint in constraints {\n-            debug!(\"generate: constraint: {:?}\", constraint);\n-            let (a_vid, b_vid) = match constraint {\n-                Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n-                Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n-                Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n-                Constraint::RegSubReg(a_r, b_r) => {\n-                    (self.to_region_vid(a_r), self.to_region_vid(b_r))\n-                }\n-            };\n-\n-            // We have the constraint that `a_vid <= b_vid`. Add\n-            // `b_vid: a_vid` to our region checker. Note that we\n-            // reverse direction, because `regioncx` talks about\n-            // \"outlives\" (`>=`) whereas the region constraints\n-            // talk about `<=`.\n-            self.add_outlives(b_vid, a_vid);\n-\n-            // In the new analysis, all outlives relations etc\n-            // \"take effect\" at the mid point of the statement\n-            // that requires them, so ignore the `at_location`.\n-            if let Some(all_facts) = &mut self.all_facts {\n-                if let Some(from_location) = self.locations.from_location() {\n-                    all_facts.outlives.push((\n-                        b_vid,\n-                        a_vid,\n-                        self.location_table.mid_index(from_location),\n-                    ));\n-                } else {\n-                    for location in self.location_table.all_points() {\n-                        all_facts.outlives.push((b_vid, a_vid, location));\n-                    }\n-                }\n-            }\n-        }\n \n+        // Extract out various useful fields we'll need below.\n         let ConstraintConversion {\n             tcx,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n             ..\n         } = *self;\n-        for r_o in region_obligations {\n-            let RegionObligation {\n-                sup_type,\n-                sub_region,\n-                cause,\n-            } = r_o;\n-\n-            // we don't actually use this for anything.\n-            let origin = infer::RelateParamBound(cause.span, sup_type);\n-\n-            TypeOutlives::new(\n-                &mut *self,\n-                tcx,\n-                region_bound_pairs,\n-                implicit_region_bound,\n-                param_env,\n-            ).type_must_outlive(origin, sup_type, sub_region);\n+\n+        for query_constraint in query_constraints {\n+            // At the moment, we never generate any \"higher-ranked\"\n+            // region constraints like `for<'a> 'a: 'b`. At some point\n+            // when we move to universes, we will, and this assertion\n+            // will start to fail.\n+            let ty::OutlivesPredicate(k1, r2) =\n+                query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n+                    span_bug!(\n+                        self.span(),\n+                        \"query_constraint {:?} contained bound regions\",\n+                        query_constraint,\n+                    );\n+                });\n+\n+            match k1.unpack() {\n+                UnpackedKind::Lifetime(r1) => {\n+                    let r1_vid = self.to_region_vid(r1);\n+                    let r2_vid = self.to_region_vid(r2);\n+                    self.add_outlives(r1_vid, r2_vid);\n+\n+                    // In the new analysis, all outlives relations etc\n+                    // \"take effect\" at the mid point of the statement\n+                    // that requires them, so ignore the `at_location`.\n+                    if let Some(all_facts) = &mut self.all_facts {\n+                        if let Some(from_location) = self.locations.from_location() {\n+                            all_facts.outlives.push((\n+                                r1_vid,\n+                                r2_vid,\n+                                self.location_table.mid_index(from_location),\n+                            ));\n+                        } else {\n+                            for location in self.location_table.all_points() {\n+                                all_facts.outlives.push((r1_vid, r2_vid, location));\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                UnpackedKind::Type(t1) => {\n+                    // we don't actually use this for anything, but\n+                    // the `TypeOutlives` code needs an origin.\n+                    let origin = infer::RelateParamBound(self.span(), t1);\n+\n+                    TypeOutlives::new(\n+                        &mut *self,\n+                        tcx,\n+                        region_bound_pairs,\n+                        implicit_region_bound,\n+                        param_env,\n+                    ).type_must_outlive(origin, t1, r2);\n+                }\n+            }\n         }\n     }\n \n@@ -185,17 +184,12 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     }\n \n     fn span(&self) -> Span {\n-        self\n-            .mir\n+        self.mir\n             .source_info(self.locations.from_location().unwrap_or(Location::START))\n             .span\n     }\n \n-    fn add_outlives(\n-        &mut self,\n-        sup: ty::RegionVid,\n-        sub: ty::RegionVid,\n-    ) {\n+    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n         let span = self.span();\n         let point = self.locations.at_location().unwrap_or(Location::START);\n \n@@ -213,7 +207,9 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'b, 'gcx, 'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx>\n+    for &'a mut ConstraintConversion<'b, 'gcx, 'tcx>\n+{\n     fn push_sub_region_constraint(\n         &mut self,\n         _origin: SubregionOrigin<'tcx>,"}, {"sha": "37898adeb923e43f8e316a105114d05c8e23b529", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "patch": "@@ -10,10 +10,11 @@\n \n use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::type_check::type_op::{DropckOutlives, TypeOp};\n-use borrow_check::nll::type_check::{AtLocation, LexicalRegionConstraintData};\n+use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::mir::Local;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::subst::Kind;\n@@ -70,7 +71,7 @@ where\n \n struct DropData<'tcx> {\n     dropped_kinds: Vec<Kind<'tcx>>,\n-    region_constraint_data: Option<Rc<LexicalRegionConstraintData<'tcx>>>,\n+    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {"}, {"sha": "92ee1f2a892ef30356b4cbd03d02563cf30df7cc", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "patch": "@@ -20,8 +20,9 @@ use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::region_constraints::{Constraint, GenericKind};\n-use rustc::infer::{InferCtxt, LateBoundRegionConversionTime, RegionObligation, UnitResult};\n+use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime, UnitResult};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n@@ -625,21 +626,6 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n-/// The type checker layers on top of the \"old\" inference engine.  The\n-/// idea is that we run some operations, like trait selection, and\n-/// then we \"scrape out\" the region constraints that have accumulated\n-/// from the old lexical solver. This struct just collects the bits of\n-/// that data that we care about into one place.\n-#[derive(Debug)]\n-struct LexicalRegionConstraintData<'tcx> {\n-    /// The `'a <= 'b` constraints extracted from `RegionConstraintData`.\n-    constraints: Vec<Constraint<'tcx>>,\n-\n-    /// The `T: 'a` (and `'a: 'b`, in some cases) constraints\n-    /// extracted from the pending \"region obligations\".\n-    region_obligations: Vec<RegionObligation<'tcx>>,\n-}\n-\n /// The `Locations` type summarizes *where* region constraints are\n /// required to hold. Normally, this is at a particular point which\n /// created the obligation, but for constraints that the user gave, we\n@@ -759,7 +745,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        data: &LexicalRegionConstraintData<'tcx>,\n+        data: &[QueryRegionConstraint<'tcx>],\n     ) {\n         debug!(\n             \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n@@ -1703,10 +1689,3 @@ impl ToLocations for Location {\n         self.at_self()\n     }\n }\n-\n-impl<'tcx> LexicalRegionConstraintData<'tcx> {\n-    fn is_empty(&self) -> bool {\n-        let LexicalRegionConstraintData { constraints, region_obligations } = self;\n-        constraints.is_empty() && region_obligations.is_empty()\n-    }\n-}"}, {"sha": "434b1d799ae1660ea4ce74871c6847618d117f3d", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/mod.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf710ce032e87947d0107dcfb5d3f4c90a6849/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs?ref=c8cf710ce032e87947d0107dcfb5d3f4c90a6849", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::type_check::LexicalRegionConstraintData;\n-use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::canonical::query_result;\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::{InferCtxt, InferOk, InferResult};\n use rustc::traits::query::NoSolution;\n use rustc::traits::{Normalized, Obligation, ObligationCause, PredicateObligation, TraitEngine};\n@@ -44,7 +44,7 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    ) -> Result<(Self::Output, Option<Rc<LexicalRegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n+    ) -> Result<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>), TypeError<'tcx>> {\n         let op = match self.trivial_noop() {\n             Ok(r) => return Ok((r, None)),\n             Err(op) => op,\n@@ -66,33 +66,20 @@ pub(super) trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n             );\n         }\n \n-        let region_obligations: Vec<_> = infcx\n-            .take_registered_region_obligations()\n-            .into_iter()\n-            .map(|(_node_id, region_obligation)| region_obligation)\n-            .collect();\n+        let region_obligations = infcx.take_registered_region_obligations();\n \n-        let RegionConstraintData {\n-            constraints,\n-            verifys,\n-            givens,\n-        } = infcx.take_and_reset_region_constraints();\n+        let region_constraint_data = infcx.take_and_reset_region_constraints();\n \n-        // These are created when we \"process\" the registered region\n-        // obliations, and that hasn't happened yet.\n-        assert!(verifys.is_empty());\n-\n-        // NLL doesn't use givens (and thank goodness!).\n-        assert!(givens.is_empty());\n-\n-        let data = LexicalRegionConstraintData {\n-            constraints: constraints.keys().cloned().collect(),\n+        let outlives = query_result::make_query_outlives(\n+            infcx.tcx,\n             region_obligations,\n-        };\n-        if data.is_empty() {\n+            &region_constraint_data,\n+        );\n+\n+        if outlives.is_empty() {\n             Ok((value, None))\n         } else {\n-            Ok((value, Some(Rc::new(data))))\n+            Ok((value, Some(Rc::new(outlives))))\n         }\n     }\n }"}]}