{"sha": "aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhY2VlZGVkOWVlN2EwNWQ1YmVhOTYwYWU2ZmRmM2I3YWY4ZDIxNjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-09T06:18:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-09T06:18:27Z"}, "message": "Rollup merge of #65949 - ecstatic-morse:promote-only-pass, r=eddyb\n\nMove promotion into its own pass\n\n**edited**\n\nThis adds a `PromoteTemps` pass, which runs after the old `QualifyAndPromoteConsts` pass, that *only* does promotion (no const-checking). Everything related to promotion has been removed from `QualifyAndPromoteConstants`: it no longer even visits the body of a non-const `fn`.\n\nAs a result we no longer need to keep the `BitSet` of promotable locals that was returned by `mir_const_qualif`. Rvalue-static promotion in a `const` is now done in `promote_consts`, and it operates on a set of `Candidate`s instead. This will allow me\u2013in a later PR\u2013to create promoted MIR fragments for `const`s when necessary, which could resolve some shortcomings of the current approach (removing `StorageDead`).\n\nr? @eddyb", "tree": {"sha": "5fa2580eeedb248f91ce3f129d48b30985895259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fa2580eeedb248f91ce3f129d48b30985895259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxlo0CRBK7hj4Ov3rIwAAdHIIAJGiMp39TP9lmGddsbndDajB\nTTtuO081gbN9LLVrHcqQXNJmhYYrZGUk+5JIoJMVqIUDF9ODVtc9f+cInnfPxcyc\n9ym2m+v5MMEqQGG+zklL+wkWo60VuezgqNizNnBCy3nshoXsqexSIQiPgDDsifas\n0W2ZujBX0pLXOpJOR4wQRWLdF8W/evelgXfPGb8oH5s5PyORMGopBSclpEtHxrzA\nfRgDfzSglLLXq7s6Up6SU+F0wlt5sS0JZEmyZWEb3ffngPfQCQ730YgkrJGwlrw1\naOyDz4TP5e46+r1Tdd2b++Bp91VEDekA0/Ju2DR9+7wPYE/UQbjLwH4pprljobI=\n=4hJT\n-----END PGP SIGNATURE-----\n", "payload": "tree 5fa2580eeedb248f91ce3f129d48b30985895259\nparent 475c713b2f8c41eb06fd1a65f226c77f84fea4a5\nparent a3b03690c07f72ed802e4e77501960482c7c2661\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573280307 +0100\ncommitter GitHub <noreply@github.com> 1573280307 +0100\n\nRollup merge of #65949 - ecstatic-morse:promote-only-pass, r=eddyb\n\nMove promotion into its own pass\n\n**edited**\n\nThis adds a `PromoteTemps` pass, which runs after the old `QualifyAndPromoteConsts` pass, that *only* does promotion (no const-checking). Everything related to promotion has been removed from `QualifyAndPromoteConstants`: it no longer even visits the body of a non-const `fn`.\n\nAs a result we no longer need to keep the `BitSet` of promotable locals that was returned by `mir_const_qualif`. Rvalue-static promotion in a `const` is now done in `promote_consts`, and it operates on a set of `Candidate`s instead. This will allow me\u2013in a later PR\u2013to create promoted MIR fragments for `const`s when necessary, which could resolve some shortcomings of the current approach (removing `StorageDead`).\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "html_url": "https://github.com/rust-lang/rust/commit/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "475c713b2f8c41eb06fd1a65f226c77f84fea4a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/475c713b2f8c41eb06fd1a65f226c77f84fea4a5", "html_url": "https://github.com/rust-lang/rust/commit/475c713b2f8c41eb06fd1a65f226c77f84fea4a5"}, {"sha": "a3b03690c07f72ed802e4e77501960482c7c2661", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b03690c07f72ed802e4e77501960482c7c2661", "html_url": "https://github.com/rust-lang/rust/commit/a3b03690c07f72ed802e4e77501960482c7c2661"}], "stats": {"total": 383, "additions": 186, "deletions": 197}, "files": [{"sha": "bd7b77b0abb17dd7ef69cbc9b3a8a7df59eee307", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -93,7 +93,7 @@ rustc_queries! {\n         /// Maps DefId's that have an associated `mir::Body` to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n-        query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n+        query mir_const_qualif(key: DefId) -> u8 {\n             desc { |tcx| \"const checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }"}, {"sha": "0615004125b3ca94df1720fb94ca0241b1f96eb9", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -42,7 +42,6 @@ use crate::util::common::ErrorReported;\n use crate::util::profiling::ProfileCategory::*;\n \n use rustc_data_structures::svh::Svh;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::fx::{FxIndexMap, FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;"}, {"sha": "1118162bdeb021940ca6a3200ba312ace7e06640", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -32,7 +32,6 @@ use syntax::parse::parser::emit_unclosed_delims;\n use syntax::source_map::Spanned;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, FileName};\n-use rustc_index::bit_set::BitSet;\n \n macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n@@ -122,9 +121,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), tcx.arena.alloc(BitSet::new_empty(0)))\n-    }\n+    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }"}, {"sha": "ad1ab16a410744d9477fa85f07853c6e394e0a27", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -955,7 +955,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n-                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n+                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n \n                     EntryKind::AssocConst(container,\n                         ConstQualif { mir },\n@@ -1089,7 +1089,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n-                let mir = self.tcx.at(item.span).mir_const_qualif(def_id).0;\n+                let mir = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n                     ConstQualif { mir },\n                     self.encode_rendered_const_for_body(body_id)\n@@ -1368,7 +1368,7 @@ impl EncodeContext<'tcx> {\n         let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let mir = self.tcx.mir_const_qualif(def_id).0;\n+        let mir = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.per_def.kind[def_id] <- EntryKind::Const(ConstQualif { mir }, const_data));\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);"}, {"sha": "496a56790679b41d922570682f157f1e6b91bb01", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -123,7 +123,7 @@ pub trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = QualifSet(bits).contains::<Self>();\n "}, {"sha": "6d6d6bea2a0eabb868939975477a6ae6a32b4d09", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -210,13 +210,14 @@ fn mir_validated(\n     }\n \n     let mut body = tcx.mir_const(def_id).steal();\n-    let qualify_and_promote_pass = qualify_consts::QualifyAndPromoteConstants::default();\n+    let promote_pass = promote_consts::PromoteTemps::default();\n     run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n-        &qualify_and_promote_pass,\n+        &qualify_consts::QualifyAndPromoteConstants::default(),\n+        &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n-    let promoted = qualify_and_promote_pass.promoted.into_inner();\n+    let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n "}, {"sha": "48a58f1d0ee57a9adcfa37ebfdcc248fde334084", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 138, "deletions": 2, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -17,20 +17,76 @@ use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, List, TyCtxt};\n+use rustc::ty::{self, List, TyCtxt, TypeFoldable};\n use rustc::ty::subst::InternalSubsts;\n use rustc::ty::cast::CastTy;\n use syntax::ast::LitKind;\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_index::vec::{IndexVec, Idx};\n+use rustc_index::bit_set::HybridBitSet;\n use rustc_target::spec::abi::Abi;\n \n+use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::transform::{MirPass, MirSource};\n use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn};\n \n+/// A `MirPass` for promotion.\n+///\n+/// In this case, \"promotion\" entails the following:\n+/// - Extract promotable temps in `fn` and `const fn` into their own MIR bodies.\n+/// - Extend lifetimes in `const` and `static` by removing `Drop` and `StorageDead`.\n+/// - Emit errors if the requirements of `#[rustc_args_required_const]` are not met.\n+///\n+/// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n+/// newly created `StaticKind::Promoted`.\n+#[derive(Default)]\n+pub struct PromoteTemps<'tcx> {\n+    pub promoted_fragments: Cell<IndexVec<Promoted, Body<'tcx>>>,\n+}\n+\n+impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        // There's not really any point in promoting errorful MIR.\n+        //\n+        // This does not include MIR that failed const-checking, which we still try to promote.\n+        if body.return_ty().references_error() {\n+            tcx.sess.delay_span_bug(body.span, \"PromoteTemps: MIR had errors\");\n+            return;\n+        }\n+\n+        if src.promoted.is_some() {\n+            return;\n+        }\n+\n+        let def_id = src.def_id();\n+\n+        let item = Item::new(tcx, def_id, body);\n+        let mut rpo = traversal::reverse_postorder(body);\n+        let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+\n+        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+\n+        // For now, lifetime extension is done in `const` and `static`s without creating promoted\n+        // MIR fragments by removing `Drop` and `StorageDead` for each referent. However, this will\n+        // not work inside loops when they are allowed in `const`s.\n+        //\n+        // FIXME: use promoted MIR fragments everywhere?\n+        let promoted_fragments = if should_create_promoted_mir_fragments(item.const_kind) {\n+            promote_candidates(def_id, body, tcx, temps, promotable_candidates)\n+        } else {\n+            // FIXME: promote const array initializers in consts.\n+            remove_drop_and_storage_dead_on_promoted_locals(tcx, body, &promotable_candidates);\n+            IndexVec::new()\n+        };\n+\n+        self.promoted_fragments.set(promoted_fragments);\n+    }\n+}\n+\n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TempState {\n@@ -538,7 +594,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         // is gone - we can always promote constants even if they\n                         // fail to pass const-checking, as compilation would've\n                         // errored independently and promotion can't change that.\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n                         if bits == super::qualify_consts::QUALIF_ERROR_BIT {\n                             self.tcx.sess.delay_span_bug(\n                                 constant.span,\n@@ -1154,3 +1210,83 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n             should_promote={:?} feature_flag={:?}\", mir_def_id, should_promote, feature_flag);\n     should_promote && !feature_flag\n }\n+\n+fn should_create_promoted_mir_fragments(const_kind: Option<ConstKind>) -> bool {\n+    match const_kind {\n+        Some(ConstKind::ConstFn) | None => true,\n+        Some(ConstKind::Const) | Some(ConstKind::Static) | Some(ConstKind::StaticMut) => false,\n+    }\n+}\n+\n+/// In `const` and `static` everything without `StorageDead`\n+/// is `'static`, we don't have to create promoted MIR fragments,\n+/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+fn remove_drop_and_storage_dead_on_promoted_locals(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    promotable_candidates: &[Candidate],\n+) {\n+    debug!(\"run_pass: promotable_candidates={:?}\", promotable_candidates);\n+\n+    // Removing `StorageDead` will cause errors for temps declared inside a loop body. For now we\n+    // simply skip promotion if a loop exists, since loops are not yet allowed in a `const`.\n+    //\n+    // FIXME: Just create MIR fragments for `const`s instead of using this hackish approach?\n+    if body.is_cfg_cyclic() {\n+        tcx.sess.delay_span_bug(body.span, \"Control-flow cycle detected in `const`\");\n+        return;\n+    }\n+\n+    // The underlying local for promotion contexts like `&temp` and `&(temp.proj)`.\n+    let mut requires_lifetime_extension = HybridBitSet::new_empty(body.local_decls.len());\n+\n+    promotable_candidates\n+        .iter()\n+        .filter_map(|c| {\n+            match c {\n+                Candidate::Ref(loc) => Some(loc),\n+                Candidate::Repeat(_) | Candidate::Argument { .. } => None,\n+            }\n+        })\n+        .map(|&Location { block, statement_index }| {\n+            // FIXME: store the `Local` for each `Candidate` when it is created.\n+            let place = match &body[block].statements[statement_index].kind {\n+                StatementKind::Assign(box ( _, Rvalue::Ref(_, _, place))) => place,\n+                _ => bug!(\"`Candidate::Ref` without corresponding assignment\"),\n+            };\n+\n+            match place.base {\n+                PlaceBase::Local(local) => local,\n+                PlaceBase::Static(_) => bug!(\"`Candidate::Ref` for a non-local\"),\n+            }\n+        })\n+        .for_each(|local| {\n+            requires_lifetime_extension.insert(local);\n+        });\n+\n+    // Remove `Drop` terminators and `StorageDead` statements for all promotable temps that require\n+    // lifetime extension.\n+    for block in body.basic_blocks_mut() {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::StorageDead(index) => !requires_lifetime_extension.contains(index),\n+                _ => true\n+            }\n+        });\n+        let terminator = block.terminator_mut();\n+        match &terminator.kind {\n+            TerminatorKind::Drop {\n+                location,\n+                target,\n+                ..\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if requires_lifetime_extension.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "5ad5363768d34a3142480b24f514020470b14e97", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 25, "deletions": 148, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -15,7 +15,6 @@ use rustc::ty::cast::CastTy;\n use rustc::ty::query::Providers;\n use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n-use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n@@ -31,7 +30,6 @@ use std::usize;\n \n use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n-use super::promote_consts::{self, Candidate, TempState};\n use crate::transform::check_consts::ops::{self, NonConstOp};\n \n /// What kind of item we are in.\n@@ -258,7 +256,7 @@ trait Qualif {\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty).unwrap_or(false)\n                     } else {\n-                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let bits = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n \n@@ -477,10 +475,6 @@ struct Checker<'a, 'tcx> {\n \n     span: Span,\n     def_id: DefId,\n-    rpo: ReversePostorder<'a, 'tcx>,\n-\n-    temp_promotion_state: IndexVec<Local, TempState>,\n-    unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n     suppress_errors: bool,\n@@ -509,10 +503,6 @@ impl Deref for Checker<'a, 'tcx> {\n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n-        let mut rpo = traversal::reverse_postorder(body);\n-        let (temps, unchecked_promotion_candidates) =\n-            promote_consts::collect_temps_and_candidates(tcx, body, &mut rpo);\n-        rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n \n@@ -539,9 +529,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             cx,\n             span: body.span,\n             def_id,\n-            rpo,\n-            temp_promotion_state: temps,\n-            unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n         }\n@@ -662,14 +649,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let kind = self.body.local_kind(index);\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n-        // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::NonConstFn {\n-            if kind != LocalKind::Temp ||\n-               !self.temp_promotion_state[index].is_promotable() {\n-                return;\n-            }\n-        }\n-\n         // this is overly restrictive, because even full assignments do not clear the qualif\n         // While we could special case full assignments, this would be inconsistent with\n         // aggregates where we overwrite all fields via assignments, which would not get\n@@ -682,7 +661,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n \n     /// Check a whole const, static initializer or const fn.\n-    fn check_const(&mut self) -> (u8, &'tcx BitSet<Local>) {\n+    fn check_const(&mut self) -> u8 {\n         use crate::transform::check_consts as new_checker;\n \n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n@@ -704,7 +683,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n         let mut bb = START_BLOCK;\n-        let mut has_controlflow_error = false;\n         loop {\n             seen_blocks.insert(bb.index());\n \n@@ -745,7 +723,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n-                    has_controlflow_error = true;\n                     self.not_const(ops::Loop);\n                     validator.check_op(ops::Loop);\n                     break;\n@@ -772,51 +749,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         }\n \n-        // Collect all the temps we need to promote.\n-        let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n-\n-        // HACK: if parts of the control-flow graph were skipped due to an error, don't try to\n-        // promote anything, since that can cause errors in a `const` if e.g. rvalue static\n-        // promotion is attempted within a loop body.\n-        let unleash_miri = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n-        let promotion_candidates = if has_controlflow_error && !unleash_miri {\n-            self.tcx.sess.delay_span_bug(\n-                body.span,\n-                \"check_const: expected control-flow error(s)\",\n-            );\n-\n-            vec![]\n-        } else {\n-            promote_consts::validate_candidates(\n-                self.tcx,\n-                self.body,\n-                self.def_id,\n-                &self.temp_promotion_state,\n-                &self.unchecked_promotion_candidates,\n-            )\n-        };\n-\n-        debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n-        for candidate in promotion_candidates {\n-            match candidate {\n-                Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                    if let StatementKind::Assign(box( _, Rvalue::Ref(_, _, place)))\n-                        = &self.body[bb].statements[stmt_idx].kind\n-                    {\n-                        if let PlaceBase::Local(local) = place.base {\n-                            promoted_temps.insert(local);\n-                        }\n-                    }\n-                }\n-\n-                // Only rvalue-static promotion requires extending the lifetime of the promoted\n-                // local.\n-                Candidate::Argument { .. } | Candidate::Repeat(_) => {}\n-            }\n-        }\n-\n-        let qualifs = self.qualifs_in_local(RETURN_PLACE);\n-        (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n+        self.qualifs_in_local(RETURN_PLACE).encode_to_bits()\n     }\n }\n \n@@ -1346,7 +1279,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n // in `promote_consts`, see the comment in `validate_operand`.\n pub(super) const QUALIF_ERROR_BIT: u8 = 1 << 2;\n \n-fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n+fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1355,7 +1288,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return (QUALIF_ERROR_BIT, tcx.arena.alloc(BitSet::new_empty(0)));\n+        return QUALIF_ERROR_BIT;\n     }\n \n     Checker::new(tcx, def_id, body, Mode::Const).check_const()\n@@ -1391,56 +1324,34 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n         let mode = determine_mode(tcx, hir_id, def_id);\n \n         debug!(\"run_pass: mode={:?}\", mode);\n-        if let Mode::NonConstFn | Mode::ConstFn = mode {\n+        if let Mode::NonConstFn = mode {\n+            // No need to const-check a non-const `fn` now that we don't do promotion here.\n+            return;\n+        } else if let Mode::ConstFn = mode {\n             let mut checker = Checker::new(tcx, def_id, body, mode);\n-            if let Mode::ConstFn = mode {\n-                let use_min_const_fn_checks =\n-                    !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n-                    tcx.is_min_const_fn(def_id);\n-                if use_min_const_fn_checks {\n-                    // Enforce `min_const_fn` for stable `const fn`s.\n-                    use super::qualify_min_const_fn::is_min_const_fn;\n-                    if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                        error_min_const_fn_violation(tcx, span, err);\n-                        return;\n-                    }\n-\n-                    // `check_const` should not produce any errors, but better safe than sorry\n-                    // FIXME(#53819)\n-                    // NOTE(eddyb) `check_const` is actually needed for promotion inside\n-                    // `min_const_fn` functions.\n-                }\n-\n-                // Enforce a constant-like CFG for `const fn`.\n-                checker.check_const();\n-            } else {\n-                while let Some((bb, data)) = checker.rpo.next() {\n-                    checker.visit_basic_block_data(bb, data);\n+            let use_min_const_fn_checks =\n+                !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                tcx.is_min_const_fn(def_id);\n+            if use_min_const_fn_checks {\n+                // Enforce `min_const_fn` for stable `const fn`s.\n+                use super::qualify_min_const_fn::is_min_const_fn;\n+                if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                    error_min_const_fn_violation(tcx, span, err);\n+                    return;\n                 }\n             }\n \n-            // Promote only the promotable candidates.\n-            let temps = checker.temp_promotion_state;\n-            let candidates = promote_consts::validate_candidates(\n-                tcx,\n-                body,\n-                def_id,\n-                &temps,\n-                &checker.unchecked_promotion_candidates,\n-            );\n-\n-            // Do the actual promotion, now that we know what's viable.\n-            self.promoted.set(\n-                promote_consts::promote_candidates(def_id, body, tcx, temps, candidates)\n-            );\n+            // `check_const` should not produce any errors, but better safe than sorry\n+            // FIXME(#53819)\n+            // Enforce a constant-like CFG for `const fn`.\n+            checker.check_const();\n         } else {\n             check_short_circuiting_in_const_local(tcx, body, mode);\n \n-            let promoted_temps = match mode {\n-                Mode::Const => tcx.mir_const_qualif(def_id).1,\n-                _ => Checker::new(tcx, def_id, body, mode).check_const().1,\n+            match mode {\n+                Mode::Const => tcx.mir_const_qualif(def_id),\n+                _ => Checker::new(tcx, def_id, body, mode).check_const(),\n             };\n-            remove_drop_and_storage_dead_on_promoted_locals(body, promoted_temps);\n         }\n \n         if mode == Mode::Static && !tcx.has_attr(def_id, sym::thread_local) {\n@@ -1501,40 +1412,6 @@ fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>,\n     }\n }\n \n-/// In `const` and `static` everything without `StorageDead`\n-/// is `'static`, we don't have to create promoted MIR fragments,\n-/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n-fn remove_drop_and_storage_dead_on_promoted_locals(\n-    body: &mut Body<'tcx>,\n-    promoted_temps: &BitSet<Local>,\n-) {\n-    debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n-\n-    for block in body.basic_blocks_mut() {\n-        block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::StorageDead(index) => !promoted_temps.contains(index),\n-                _ => true\n-            }\n-        });\n-        let terminator = block.terminator_mut();\n-        match &terminator.kind {\n-            TerminatorKind::Drop {\n-                location,\n-                target,\n-                ..\n-            } => {\n-                if let Some(index) = location.as_local() {\n-                    if promoted_temps.contains(index) {\n-                        terminator.kind = TerminatorKind::Goto { target: *target };\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n     let ty = body.return_ty();\n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "648856b5523d318df57e3db964064eaef656306c", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -39,7 +39,7 @@ fn main() {\n \n // END RUST SOURCE\n //\n-// START rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n+// START rustc.full_tested_match.PromoteTemps.after.mir\n //  bb0: {\n //      ...\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n@@ -108,9 +108,9 @@ fn main() {\n //      _0 = ();\n //      return;\n //  }\n-// END rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n+// END rustc.full_tested_match.PromoteTemps.after.mir\n //\n-// START rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n+// START rustc.full_tested_match2.PromoteTemps.before.mir\n //  bb0: {\n //      ...\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n@@ -179,9 +179,9 @@ fn main() {\n //      _0 = ();\n //      return;\n //  }\n-// END rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n+// END rustc.full_tested_match2.PromoteTemps.before.mir\n //\n-// START rustc.main.QualifyAndPromoteConstants.before.mir\n+// START rustc.main.PromoteTemps.before.mir\n //  bb0: {\n //     ...\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n@@ -276,4 +276,4 @@ fn main() {\n //      _0 = ();\n //      return;\n //  }\n-// END rustc.main.QualifyAndPromoteConstants.before.mir\n+// END rustc.main.PromoteTemps.before.mir"}, {"sha": "db68a05905a144ba8da92d365e6591521a368fcc", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -136,7 +136,6 @@ const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn\n const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n //~^ ERROR trait bounds other than `Sized`\n-//~| ERROR cannot return reference to temporary value\n \n const fn no_unsafe() { unsafe {} }\n "}, {"sha": "64b2ce83da2f84a2208b0a50f9dd87363a5c392f", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -286,17 +286,8 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0515]: cannot return reference to temporary value\n-  --> $DIR/min_const_fn.rs:137:63\n-   |\n-LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n-   |                                                               ^--\n-   |                                                               ||\n-   |                                                               |temporary value created here\n-   |                                                               returns a reference to data owned by the current function\n-\n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:143:41\n+  --> $DIR/min_const_fn.rs:142:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -305,7 +296,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:146:21\n+  --> $DIR/min_const_fn.rs:145:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n@@ -314,15 +305,15 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:148:27\n+  --> $DIR/min_const_fn.rs:147:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error: aborting due to 37 previous errors\n+error: aborting due to 36 previous errors\n \n-Some errors have detailed explanations: E0493, E0515, E0723.\n+Some errors have detailed explanations: E0493, E0723.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "6ca1e59b3af106815ab316f2ceb094b9a3e6084a", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.rs?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -11,6 +11,5 @@ const fn no_inner_dyn_trait2(x: Hide) {\n }\n const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n //~^ ERROR trait bounds other than `Sized`\n-//~| ERROR temporary value dropped while borrowed\n \n fn main() {}"}, {"sha": "e20b4f9dcb47137bdb2ffb393a9aad69743ea25c", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_dyn.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_dyn.stderr?ref=aaceeded9ee7a05d5bea960ae6fdf3b7af8d2163", "patch": "@@ -16,16 +16,6 @@ LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/min_const_fn_dyn.rs:12:67\n-   |\n-LL | const fn no_inner_dyn_trait_ret() -> Hide { Hide(HasDyn { field: &0 }) }\n-   |                                                                  -^    - temporary value is freed at the end of this statement\n-   |                                                                  ||\n-   |                                                                  |creates a temporary which is freed while still in use\n-   |                                                                  cast requires that borrow lasts for `'static`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0716, E0723.\n-For more information about an error, try `rustc --explain E0716`.\n+For more information about this error, try `rustc --explain E0723`."}]}