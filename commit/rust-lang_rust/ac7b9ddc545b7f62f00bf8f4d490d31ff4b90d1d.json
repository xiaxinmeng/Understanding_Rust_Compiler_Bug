{"sha": "ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjN2I5ZGRjNTQ1YjdmNjJmMDBiZjhmNGQ0OTBkMzFmZjRiOTBkMWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-12T18:40:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-13T20:53:34Z"}, "message": "Audit usage of NativeMutex\n\nOnce a native mutex has been used once, it is never allowed to be moved again.\nThis is because some pthreads implementations take pointers inside the mutex\nitself.\n\nThis commit adds stern wording around the methods on native mutexes, and fixes\none use case in the codebase. The Mutex type in libsync was susceptible to\nmovement, so the inner static mutex is now boxed to ensure that the address of\nthe native mutex is constant.", "tree": {"sha": "88392ca6e57d1ec5481f9cc9d002b7b153bd8148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88392ca6e57d1ec5481f9cc9d002b7b153bd8148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "html_url": "https://github.com/rust-lang/rust/commit/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b612ae9edea26cb8704363c47a66d583b644ad09", "url": "https://api.github.com/repos/rust-lang/rust/commits/b612ae9edea26cb8704363c47a66d583b644ad09", "html_url": "https://github.com/rust-lang/rust/commit/b612ae9edea26cb8704363c47a66d583b644ad09"}], "stats": {"total": 91, "additions": 87, "deletions": 4}, "files": [{"sha": "3fece698a1de491726f07a29255eea5935d6a985", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "patch": "@@ -115,6 +115,18 @@ impl StaticNativeMutex {\n     ///     // critical section...\n     /// } // automatically unlocked in `_guard`'s destructor\n     /// ```\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe because it will not function correctly if this\n+    /// mutex has been *moved* since it was last used. The mutex can move an\n+    /// arbitrary number of times before its first usage, but once a mutex has\n+    /// been used once it is no longer allowed to move (or otherwise it invokes\n+    /// undefined behavior).\n+    ///\n+    /// Additionally, this type does not take into account any form of\n+    /// scheduling model. This will unconditionally block the *os thread* which\n+    /// is not always desired.\n     pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock();\n \n@@ -123,6 +135,10 @@ impl StaticNativeMutex {\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`.\n     pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         if self.inner.trylock() {\n             Some(LockGuard { lock: self })\n@@ -135,6 +151,12 @@ impl StaticNativeMutex {\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n+    /// does not guarantee that the mutex will ever be unlocked, and it is\n+    /// undefined to drop an already-locked mutex.\n     pub unsafe fn lock_noguard(&self) { self.inner.lock() }\n \n     /// Attempts to acquire the lock without creating a\n@@ -143,22 +165,42 @@ impl StaticNativeMutex {\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock_noguard`.\n     pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, it\n+    /// is not guaranteed that this is unlocking a previously locked mutex. It\n+    /// is undefined to unlock an unlocked mutex.\n     pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n+    /// is unsafe because the mutex may not be currently locked.\n     pub unsafe fn wait_noguard(&self) { self.inner.wait() }\n \n     /// Signals a thread in `wait` to wake up\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n+    /// is unsafe because the mutex may not be currently locked.\n     pub unsafe fn signal_noguard(&self) { self.inner.signal() }\n \n     /// This function is especially unsafe because there are no guarantees made\n@@ -181,6 +223,7 @@ impl NativeMutex {\n     /// already hold the lock.\n     ///\n     /// # Example\n+    ///\n     /// ```rust\n     /// use std::rt::mutex::NativeMutex;\n     /// unsafe {\n@@ -192,12 +235,22 @@ impl NativeMutex {\n     ///     } // automatically unlocked in `_guard`'s destructor\n     /// }\n     /// ```\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::lock`.\n     pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock()\n     }\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::trylock`.\n     pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         self.inner.trylock()\n     }\n@@ -206,6 +259,11 @@ impl NativeMutex {\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::lock_noguard`.\n     pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }\n \n     /// Attempts to acquire the lock without creating a\n@@ -214,22 +272,42 @@ impl NativeMutex {\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::trylock_noguard`.\n     pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock_noguard()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::unlock_noguard`.\n     pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::wait_noguard`.\n     pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }\n \n     /// Signals a thread in `wait` to wake up\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::signal_noguard`.\n     pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }\n }\n "}, {"sha": "aebed5a8829c5290c3acc2965ee623934c7086c7", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "patch": "@@ -73,7 +73,6 @@ use libc::c_void;\n \n use local::Local;\n use task::{Task, Result};\n-use exclusive::Exclusive;\n \n use uw = libunwind;\n \n@@ -88,7 +87,6 @@ struct Exception {\n }\n \n pub type Callback = fn(msg: &Any:Send, file: &'static str, line: uint);\n-type Queue = Exclusive<Vec<Callback>>;\n \n // Variables used for invoking callbacks when a task starts to unwind.\n //"}, {"sha": "ef558d3f9241bb0d04f6259cd0aa425fea457c00", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=ac7b9ddc545b7f62f00bf8f4d490d31ff4b90d1d", "patch": "@@ -97,7 +97,14 @@ pub static NATIVE_BLOCKED: uint = 1 << 2;\n /// drop(guard); // unlock the lock\n /// ```\n pub struct Mutex {\n-    lock: StaticMutex,\n+    // Note that this static mutex is in a *box*, not inlined into the struct\n+    // itself. This is done for memory safety reasons with the usage of a\n+    // StaticNativeMutex inside the static mutex above. Once a native mutex has\n+    // been used once, its address can never change (it can't be moved). This\n+    // mutex type can be safely moved at any time, so to ensure that the native\n+    // mutex is used correctly we box the inner lock to give it a constant\n+    // address.\n+    lock: Box<StaticMutex>,\n }\n \n #[deriving(PartialEq, Show)]\n@@ -458,7 +465,7 @@ impl Mutex {\n     /// Creates a new mutex in an unlocked state ready for use.\n     pub fn new() -> Mutex {\n         Mutex {\n-            lock: StaticMutex {\n+            lock: box StaticMutex {\n                 state: atomics::AtomicUint::new(0),\n                 flavor: Unsafe::new(Unlocked),\n                 green_blocker: Unsafe::new(0),"}]}