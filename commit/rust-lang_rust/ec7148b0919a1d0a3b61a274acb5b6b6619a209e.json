{"sha": "ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "node_id": "C_kwDOAAsO6NoAKGVjNzE0OGIwOTE5YTFkMGEzYjYxYTI3NGFjYjViNmI2NjE5YTIwOWU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-12-27T09:18:18Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-12-27T09:23:01Z"}, "message": "mbe: split `Op::Leaf` and handle multi-character puncts", "tree": {"sha": "55e0fb77c85947e24bfe0bdd17c1e5783a33c44d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e0fb77c85947e24bfe0bdd17c1e5783a33c44d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmOquacACgkQ4laYqTBY\nYXEtVw/+IBN/dJluWJN6QEXind+z+jsf306HAgdwQmLhIL9XEKrxdhluIoDaKGOp\nxfeDcrQhEw7QG2ZpSvU4GGLyrvYl4rJXlj+25cAGOoyiRZO0JNb/u5jLxXmIPTNM\nbxQkm4AXhbT2yCSsROHG9tLjtAAOZE4Tc9LiWXXoNcFDB1HpPuEFeBLk7Cxy+E9h\ndHJGoUCi+BSHyCrkGAGLy4bYMqx1A61oKWhrWsbBxFp6owJWYdb/F2NPgp17U0rk\nIh9J3lMEBm6aHda4Xy8W/plFcGYlXQPVw6y3D+aOcmk8luEgZFmV4wN2XQC7vgUQ\nf/Acf7uinbbWiR1VSfEa/PqFCtr90O1BJLswaSrbWMUOD8owf96wSSosGhh6rg9D\nS2WtMtY/8EtFSKCNW8e1M1UChsbZNkvK/7uobBcarNLqQXJ6u4hyxzIr+YSateg5\ntZtnr3cVqeAOCGmQT7X6DZk4e2kVbTCLY7ztivE0zSzR3dRsiIYsy2vHbu29W5Oe\nWuHrtLlRZhHHChM6X2soc9FZjvAA+EjN6501dbI0vvsyQ1iSwJIvaP0x2GFe3ZUD\naQKvhjRIqkhlN6Gn9J8XZIvvK3tJ5YHOxauzH7Sa3CgKrCzxCWfG7tOwUYSL4i7m\nCKNpvd82L5jpvRuTD0bvRYF/5TTeAwinTbX0/ku0lByuP5TiJ/g=\n=bAuQ\n-----END PGP SIGNATURE-----", "payload": "tree 55e0fb77c85947e24bfe0bdd17c1e5783a33c44d\nparent 47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1672132698 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1672132981 +0900\n\nmbe: split `Op::Leaf` and handle multi-character puncts\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "html_url": "https://github.com/rust-lang/rust/commit/ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "url": "https://api.github.com/repos/rust-lang/rust/commits/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29", "html_url": "https://github.com/rust-lang/rust/commit/47c6c8e2f3393fc2094bd6ab0f6f8ad426f32d29"}], "stats": {"total": 233, "additions": 180, "deletions": 53}, "files": [{"sha": "2d5f2a692e5daab8674568717eb561a205a57012", "filename": "crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "patch": "@@ -1630,3 +1630,48 @@ const _: i32 = -0--1--2;\n     \"#]],\n     );\n }\n+\n+#[test]\n+fn test_punct_without_space() {\n+    // Puncts are \"glued\" greedily.\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    (: : :) => { \"1 1 1\" };\n+    (: ::) => { \"1 2\" };\n+    (:: :) => { \"2 1\" };\n+\n+    (: : : :) => { \"1 1 1 1\" };\n+    (:: : :) => { \"2 1 1\" };\n+    (: :: :) => { \"1 2 1\" };\n+    (: : ::) => { \"1 1 2\" };\n+    (:: ::) => { \"2 2\" };\n+}\n+\n+fn test() {\n+    foo!(:::);\n+    foo!(: :::);\n+    foo!(::::);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    (: : :) => { \"1 1 1\" };\n+    (: ::) => { \"1 2\" };\n+    (:: :) => { \"2 1\" };\n+\n+    (: : : :) => { \"1 1 1 1\" };\n+    (:: : :) => { \"2 1 1\" };\n+    (: :: :) => { \"1 2 1\" };\n+    (: : ::) => { \"1 1 2\" };\n+    (:: ::) => { \"2 2\" };\n+}\n+\n+fn test() {\n+    \"2 1\";\n+    \"1 2 1\";\n+    \"2 2\";\n+}\n+\"#]],\n+    );\n+}"}, {"sha": "4b7500250187815e8b2a6611a40d8785a23f855f", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "patch": "@@ -141,7 +141,13 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                 None => (),\n                 Some(kind) => panic!(\"Unhandled kind {kind:?}\"),\n             },\n-            Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n+            Op::Literal(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Ident(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Punct(puncts) => {\n+                for punct in puncts {\n+                    parent.token_trees.push(tt::Leaf::from(punct.clone()).into());\n+                }\n+            }\n             Op::Repeat { tokens, kind, separator } => {\n                 let max = 10;\n                 let cnt = match kind {"}, {"sha": "8773993a2ed72768bcf24a64475a1d5b120c48fe", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 82, "deletions": 40, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "patch": "@@ -68,7 +68,7 @@ use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n-    ExpandError, MetaTemplate,\n+    ExpandError, MetaTemplate, ValueResult,\n };\n \n impl Bindings {\n@@ -500,18 +500,69 @@ fn match_loop_inner<'t>(\n                     }\n                 }\n             }\n-            OpDelimited::Op(Op::Leaf(leaf)) => {\n-                if let Err(err) = match_leaf(leaf, &mut src.clone()) {\n-                    res.add_err(err);\n+            OpDelimited::Op(Op::Literal(lhs)) => {\n+                if let Ok(rhs) = src.clone().expect_leaf() {\n+                    if matches!(rhs, tt::Leaf::Literal(it) if it.text == lhs.text) {\n+                        item.dot.next();\n+                    } else {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        item.is_error = true;\n+                    }\n+                } else {\n+                    res.add_err(ExpandError::binding_error(format!(\"expected literal: `{lhs}`\")));\n                     item.is_error = true;\n+                }\n+                try_push!(next_items, item);\n+            }\n+            OpDelimited::Op(Op::Ident(lhs)) => {\n+                if let Ok(rhs) = src.clone().expect_leaf() {\n+                    if matches!(rhs, tt::Leaf::Ident(it) if it.text == lhs.text) {\n+                        item.dot.next();\n+                    } else {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        item.is_error = true;\n+                    }\n                 } else {\n-                    item.dot.next();\n+                    res.add_err(ExpandError::binding_error(format!(\"expected ident: `{lhs}`\")));\n+                    item.is_error = true;\n                 }\n                 try_push!(next_items, item);\n             }\n+            OpDelimited::Op(Op::Punct(lhs)) => {\n+                let mut fork = src.clone();\n+                let error = if let Ok(rhs) = fork.expect_glued_punct() {\n+                    let first_is_single_quote = rhs[0].char == '\\'';\n+                    let lhs = lhs.iter().map(|it| it.char);\n+                    let rhs = rhs.iter().map(|it| it.char);\n+                    if lhs.clone().eq(rhs) {\n+                        // HACK: here we use `meta_result` to pass `TtIter` back to caller because\n+                        // it might have been advanced multiple times. `ValueResult` is\n+                        // insignificant.\n+                        item.meta_result = Some((fork, ValueResult::ok(None)));\n+                        item.dot.next();\n+                        next_items.push(item);\n+                        continue;\n+                    }\n+\n+                    if first_is_single_quote {\n+                        // If the first punct token is a single quote, that's a part of a lifetime\n+                        // ident, not a punct.\n+                        ExpandError::UnexpectedToken\n+                    } else {\n+                        let lhs: SmolStr = lhs.collect();\n+                        ExpandError::binding_error(format!(\"expected punct: `{lhs}`\"))\n+                    }\n+                } else {\n+                    ExpandError::UnexpectedToken\n+                };\n+\n+                res.add_err(error);\n+                item.is_error = true;\n+                error_items.push(item);\n+            }\n             OpDelimited::Op(Op::Ignore { .. } | Op::Index { .. }) => {}\n             OpDelimited::Open => {\n-                if matches!(src.clone().next(), Some(tt::TokenTree::Subtree(..))) {\n+                if matches!(src.peek_n(0), Some(tt::TokenTree::Subtree(..))) {\n                     item.dot.next();\n                     try_push!(next_items, item);\n                 }\n@@ -616,21 +667,33 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n         }\n         // Dump all possible `next_items` into `cur_items` for the next iteration.\n         else if !next_items.is_empty() {\n-            // Now process the next token\n-            cur_items.extend(next_items.drain(..));\n-\n-            match src.next() {\n-                Some(tt::TokenTree::Subtree(subtree)) => {\n-                    stack.push(src.clone());\n-                    src = TtIter::new(subtree);\n+            if let Some((iter, _)) = next_items[0].meta_result.take() {\n+                // We've matched a possibly \"glued\" punct. The matched punct (hence\n+                // `meta_result` also) must be the same for all items.\n+                // FIXME: If there are multiple items, it's definitely redundant (and it's hacky!\n+                // `meta_result` isn't supposed to be used this way).\n+\n+                // We already bumped, so no need to call `.next()` like in the other branch.\n+                src = iter;\n+                for item in next_items.iter_mut() {\n+                    item.meta_result = None;\n                 }\n-                None => {\n-                    if let Some(iter) = stack.pop() {\n-                        src = iter;\n+            } else {\n+                match src.next() {\n+                    Some(tt::TokenTree::Subtree(subtree)) => {\n+                        stack.push(src.clone());\n+                        src = TtIter::new(subtree);\n+                    }\n+                    None => {\n+                        if let Some(iter) = stack.pop() {\n+                            src = iter;\n+                        }\n                     }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n+            // Now process the next token\n+            cur_items.extend(next_items.drain(..));\n         }\n         // Finally, we have the case where we need to call the black-box parser to get some\n         // nonterminal.\n@@ -663,27 +726,6 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     }\n }\n \n-fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n-    let rhs = src\n-        .expect_leaf()\n-        .map_err(|()| ExpandError::binding_error(format!(\"expected leaf: `{lhs}`\")))?;\n-    match (lhs, rhs) {\n-        (\n-            tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n-            tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        (\n-            tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n-            tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        (\n-            tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n-            tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n-        ) if lhs == rhs => Ok(()),\n-        _ => Err(ExpandError::UnexpectedToken),\n-    }\n-}\n-\n fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         MetaVarKind::Path => parser::PrefixEntryPoint::Path,\n@@ -756,10 +798,10 @@ fn collect_vars(collector_fun: &mut impl FnMut(SmolStr), pattern: &MetaTemplate)\n     for op in pattern.iter() {\n         match op {\n             Op::Var { name, .. } => collector_fun(name.clone()),\n-            Op::Leaf(_) => (),\n             Op::Subtree { tokens, .. } => collect_vars(collector_fun, tokens),\n             Op::Repeat { tokens, .. } => collect_vars(collector_fun, tokens),\n-            Op::Ignore { .. } | Op::Index { .. } => {}\n+            Op::Ignore { .. } | Op::Index { .. } | Op::Literal(_) | Op::Ident(_) | Op::Punct(_) => {\n+            }\n         }\n     }\n }"}, {"sha": "db0d327bf409b2752b641ec653a1e6a13075de23", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "patch": "@@ -134,7 +134,13 @@ fn expand_subtree(\n     let mut err = None;\n     for op in template.iter() {\n         match op {\n-            Op::Leaf(tt) => arena.push(tt.clone().into()),\n+            Op::Literal(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Ident(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n+            Op::Punct(puncts) => {\n+                for punct in puncts {\n+                    arena.push(tt::Leaf::from(punct.clone()).into());\n+                }\n+            }\n             Op::Subtree { tokens, delimiter } => {\n                 let ExpandResult { value: tt, err: e } =\n                     expand_subtree(ctx, tokens, *delimiter, arena);"}, {"sha": "c2c702261c4ea8ec90d2d38cffa7775e4e0e8ea1", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "patch": "@@ -1,7 +1,7 @@\n //! Parser recognizes special macro syntax, `$var` and `$(repeat)*`, in token\n //! trees.\n \n-use smallvec::SmallVec;\n+use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n use crate::{tt_iter::TtIter, ParseError};\n@@ -39,7 +39,7 @@ impl MetaTemplate {\n         let mut src = TtIter::new(tt);\n \n         let mut res = Vec::new();\n-        while let Some(first) = src.next() {\n+        while let Some(first) = src.peek_n(0) {\n             let op = next_op(first, &mut src, mode)?;\n             res.push(op);\n         }\n@@ -54,8 +54,10 @@ pub(crate) enum Op {\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n-    Leaf(tt::Leaf),\n     Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n+    Literal(tt::Literal),\n+    Punct(SmallVec<[tt::Punct; 3]>),\n+    Ident(tt::Ident),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -124,12 +126,17 @@ enum Mode {\n     Template,\n }\n \n-fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ParseError> {\n-    let res = match first {\n-        tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n+fn next_op<'a>(\n+    first_peeked: &tt::TokenTree,\n+    src: &mut TtIter<'a>,\n+    mode: Mode,\n+) -> Result<Op, ParseError> {\n+    let res = match first_peeked {\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(p @ tt::Punct { char: '$', .. })) => {\n+            src.next().expect(\"first token already peeked\");\n             // Note that the '$' itself is a valid token inside macro_rules.\n             let second = match src.next() {\n-                None => return Ok(Op::Leaf(leaf.clone())),\n+                None => return Ok(Op::Punct(smallvec![p.clone()])),\n                 Some(it) => it,\n             };\n             match second {\n@@ -160,7 +167,7 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-                        Op::Leaf(tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: ident.id }))\n+                        Op::Ident(tt::Ident { text: \"$crate\".into(), id: ident.id })\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n@@ -180,16 +187,33 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                                 \"`$$` is not allowed on the pattern side\",\n                             ))\n                         }\n-                        Mode::Template => Op::Leaf(tt::Leaf::Punct(*punct)),\n+                        Mode::Template => Op::Punct(smallvec![*punct]),\n                     },\n                     tt::Leaf::Punct(_) | tt::Leaf::Literal(_) => {\n                         return Err(ParseError::expected(\"expected ident\"))\n                     }\n                 },\n             }\n         }\n-        tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Literal(it)) => {\n+            src.next().expect(\"first token already peeked\");\n+            Op::Literal(it.clone())\n+        }\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Ident(it)) => {\n+            src.next().expect(\"first token already peeked\");\n+            Op::Ident(it.clone())\n+        }\n+\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(_)) => {\n+            // There's at least one punct so this shouldn't fail.\n+            let puncts = src.expect_glued_punct().unwrap();\n+            Op::Punct(puncts)\n+        }\n+\n         tt::TokenTree::Subtree(subtree) => {\n+            src.next().expect(\"first token already peeked\");\n             let tokens = MetaTemplate::parse(subtree, mode)?;\n             Op::Subtree { tokens, delimiter: subtree.delimiter }\n         }"}, {"sha": "16387bc896ab49723e22d9a4bc4de52694e41508", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7148b0919a1d0a3b61a274acb5b6b6619a209e/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=ec7148b0919a1d0a3b61a274acb5b6b6619a209e", "patch": "@@ -88,6 +88,10 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n+    /// Returns consecutive `Punct`s that can be glued together.\n+    ///\n+    /// This method currently may return a single quotation, which is part of lifetime ident and\n+    /// conceptually not a punct in the context of mbe. Callers should handle this.\n     pub(crate) fn expect_glued_punct(&mut self) -> Result<SmallVec<[tt::Punct; 3]>, ()> {\n         let tt::TokenTree::Leaf(tt::Leaf::Punct(first)) = self.next().ok_or(())?.clone() else {\n             return Err(());\n@@ -182,7 +186,7 @@ impl<'a> TtIter<'a> {\n         ExpandResult { value: res, err }\n     }\n \n-    pub(crate) fn peek_n(&self, n: usize) -> Option<&tt::TokenTree> {\n+    pub(crate) fn peek_n(&self, n: usize) -> Option<&'a tt::TokenTree> {\n         self.inner.as_slice().get(n)\n     }\n }"}]}