{"sha": "0c429872a32c3005cf2b347025163361218634a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNDI5ODcyYTMyYzMwMDVjZjJiMzQ3MDI1MTYzMzYxMjE4NjM0YTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-19T05:13:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T05:13:09Z"}, "message": "Auto merge of #37269 - eddyb:rollup, r=eddyb\n\nRollup of 23 pull requests\n\n- Successful merges: #36964, #37108, #37117, #37124, #37161, #37176, #37182, #37193, #37198, #37202, #37208, #37218, #37221, #37224, #37230, #37231, #37233, #37236, #37240, #37254, #37257, #37265, #37267\n- Failed merges: #37213, #37220, #37261", "tree": {"sha": "607bd7e44e220b55cfad4f5789fa45eb53265d47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/607bd7e44e220b55cfad4f5789fa45eb53265d47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c429872a32c3005cf2b347025163361218634a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c429872a32c3005cf2b347025163361218634a4", "html_url": "https://github.com/rust-lang/rust/commit/0c429872a32c3005cf2b347025163361218634a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c429872a32c3005cf2b347025163361218634a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16eeeac783d2ede28e09f2a433c612dea309fe33", "url": "https://api.github.com/repos/rust-lang/rust/commits/16eeeac783d2ede28e09f2a433c612dea309fe33", "html_url": "https://github.com/rust-lang/rust/commit/16eeeac783d2ede28e09f2a433c612dea309fe33"}, {"sha": "f354d72536fee00eb7e0522c8185879c7d1b0641", "url": "https://api.github.com/repos/rust-lang/rust/commits/f354d72536fee00eb7e0522c8185879c7d1b0641", "html_url": "https://github.com/rust-lang/rust/commit/f354d72536fee00eb7e0522c8185879c7d1b0641"}], "stats": {"total": 3488, "additions": 2675, "deletions": 813}, "files": [{"sha": "686c48abb30cd25846331f66ec1cc361c14c0114", "filename": "appveyor.yml", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,110 @@\n+environment:\n+  matrix:\n+  # 32/64 bit MSVC\n+  - MSYS_BITS: 64\n+    TARGET: x86_64-pc-windows-msvc\n+    CHECK: check\n+    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+  - MSYS_BITS: 32\n+    TARGET: i686-pc-windows-msvc\n+    CHECK: check\n+    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+\n+  # MSVC rustbuild\n+  - MSYS_BITS: 64\n+    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: x86_64-pc-windows-msvc\n+    CHECK: check\n+\n+  # MSVC cargotest\n+  - MSYS_BITS: 64\n+    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: x86_64-pc-windows-msvc\n+    CHECK: check-cargotest\n+\n+  # 32/64-bit MinGW builds.\n+  #\n+  # The MinGW builds unfortunately have to both download a custom toolchain and\n+  # avoid the one installed by AppVeyor by default. Interestingly, though, for\n+  # different reasons!\n+  #\n+  # For 32-bit the installed gcc toolchain on AppVeyor uses the pthread\n+  # threading model. This is unfortunately not what we want, and if we compile\n+  # with it then there's lots of link errors in the standard library (undefined\n+  # references to pthread symbols).\n+  #\n+  # For 64-bit the installed gcc toolchain is currently 5.3.0 which\n+  # unfortunately segfaults on Windows with --enable-llvm-assertions (segfaults\n+  # in LLVM). See rust-lang/rust#28445 for more information, but to work around\n+  # this we go back in time to 4.9.2 specifically.\n+  #\n+  # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n+  # bucket, but they cleraly didn't originate there! The downloads originally\n+  # came from the mingw-w64 SourceForge download site. Unfortunately\n+  # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n+  #\n+  # And as a final point of note, the 32-bit MinGW build using the makefiles do\n+  # *not* use debug assertions and llvm assertions. This is because they take\n+  # too long on appveyor and this is tested by rustbuild below.\n+  - MSYS_BITS: 32\n+    TARGET: i686-pc-windows-gnu\n+    CHECK: check\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n+    MINGW_DIR: mingw32\n+\n+  - MSYS_BITS: 32\n+    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: i686-pc-windows-gnu\n+    CHECK: check\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n+    MINGW_DIR: mingw32\n+\n+  - MSYS_BITS: 64\n+    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: x86_64-pc-windows-gnu\n+    CHECK: check\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n+    MINGW_DIR: mingw64\n+\n+clone_depth: 1\n+build: false\n+\n+install:\n+  # If we need to download a custom MinGW, do so here and set the path\n+  # appropriately.\n+  #\n+  # Note that this *also* means that we're not using what is typically\n+  # /mingw32/bin/python2.7.exe, which is a \"correct\" python interpreter where\n+  # /usr/bin/python2.7.exe is not. To ensure we use the right interpreter we\n+  # move `C:\\Python27` ahead in PATH and then also make sure the `python2.7.exe`\n+  # file exists in there (which it doesn't by default).\n+  - if defined MINGW_URL appveyor DownloadFile %MINGW_URL%/%MINGW_ARCHIVE%\n+  - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n+  - if defined MINGW_URL set PATH=C:\\Python27;%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n+  - if defined MINGW_URL copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n+\n+  # Otherwise pull in the MinGW installed on appveyor\n+  - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n+\n+test_script:\n+  - sh ./configure\n+          %CONFIGURE_ARGS%\n+          --build=%TARGET%\n+  - bash -c \"make -j$(nproc)\"\n+  - bash -c \"make %CHECK% -j$(nproc)\"\n+\n+cache:\n+  - build/%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\n+  - \"%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+\n+branches:\n+  only:\n+    - auto\n+\n+# init:\n+#   - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n+# on_finish:\n+#   - ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))"}, {"sha": "5a91f5fcaa48374c95341f52d7a5e3b41fa21a5f", "filename": "mk/llvm.mk", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -36,22 +36,27 @@ endif\n # If CFG_LLVM_ROOT is defined then we don't build LLVM ourselves\n ifeq ($(CFG_LLVM_ROOT),)\n \n-LLVM_STAMP_$(1) = $$(CFG_LLVM_BUILD_DIR_$(1))/llvm-auto-clean-stamp\n+LLVM_STAMP_$(1) = $(S)src/rustllvm/llvm-auto-clean-trigger\n LLVM_DONE_$(1) = $$(CFG_LLVM_BUILD_DIR_$(1))/llvm-finished-building\n \n $$(LLVM_CONFIG_$(1)): $$(LLVM_DONE_$(1))\n \n-$$(LLVM_DONE_$(1)): $$(LLVM_DEPS_TARGET_$(1)) $$(LLVM_STAMP_$(1))\n-\t@$$(call E, cmake: llvm)\n ifneq ($$(CFG_NINJA),)\n-\t$$(Q)$$(CFG_NINJA) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n+BUILD_LLVM_$(1) := $$(CFG_NINJA) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n else ifeq ($$(findstring msvc,$(1)),msvc)\n-\t$$(Q)$$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n-\t\t--config $$(LLVM_BUILD_CONFIG_MODE)\n+BUILD_LLVM_$(1) := $$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n+\t\t\t--config $$(LLVM_BUILD_CONFIG_MODE)\n else\n-\t$$(Q)$$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n+BUILD_LLVM_$(1) := $$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n endif\n-\t$$(Q)touch $$@\n+\n+$$(LLVM_DONE_$(1)): $$(LLVM_DEPS_TARGET_$(1)) $$(LLVM_STAMP_$(1))\n+\t@$$(call E, cmake: llvm)\n+\t$$(Q)if ! cmp $$(LLVM_STAMP_$(1)) $$(LLVM_DONE_$(1)); then \\\n+\t\t$$(MAKE) clean-llvm$(1); \\\n+\t\t$$(BUILD_LLVM_$(1)); \\\n+\tfi\n+\t$$(Q)cp $$(LLVM_STAMP_$(1)) $$@\n \n ifneq ($$(CFG_NINJA),)\n clean-llvm$(1):\n@@ -75,17 +80,6 @@ endif\n \n $$(LLVM_AR_$(1)): $$(LLVM_CONFIG_$(1))\n \n-# This is used to independently force an LLVM clean rebuild\n-# when we changed something not otherwise captured by builtin\n-# dependencies. In these cases, commit a change that touches\n-# the stamp in the source dir.\n-$$(LLVM_STAMP_$(1)): $$(S)src/rustllvm/llvm-auto-clean-trigger\n-\t@$$(call E, make: cleaning llvm)\n-\t$$(Q)touch $$@.start_time\n-\t$$(Q)$$(MAKE) clean-llvm$(1)\n-\t@$$(call E, make: done cleaning llvm)\n-\ttouch -r $$@.start_time $$@ && rm $$@.start_time\n-\n ifeq ($$(CFG_ENABLE_LLVM_STATIC_STDCPP),1)\n LLVM_STDCPP_RUSTFLAGS_$(1) = -L \"$$(dir $$(shell $$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \\\n \t\t\t\t\t-print-file-name=lib$(CFG_STDCPP_NAME).a))\""}, {"sha": "d4efee90361b7862195c7e6c6739480e73123114", "filename": "mk/main.mk", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -53,17 +53,6 @@ endif\n # versions in the same place\n CFG_FILENAME_EXTRA=$(shell printf '%s' $(CFG_RELEASE)$(CFG_EXTRA_FILENAME) | $(CFG_HASH_COMMAND))\n \n-# A magic value that allows the compiler to use unstable features during the\n-# bootstrap even when doing so would normally be an error because of feature\n-# staging or because the build turns on warnings-as-errors and unstable features\n-# default to warnings. The build has to match this key in an env var.\n-#\n-# This value is keyed off the release to ensure that all compilers for one\n-# particular release have the same bootstrap key. Note that this is\n-# intentionally not \"secure\" by any definition, this is largely just a deterrent\n-# from users enabling unstable features on the stable compiler.\n-CFG_BOOTSTRAP_KEY=$(CFG_FILENAME_EXTRA)\n-\n # If local-rust is the same as the current version, then force a local-rebuild\n ifdef CFG_ENABLE_LOCAL_RUST\n ifeq ($(CFG_RELEASE),\\\n@@ -73,14 +62,6 @@ ifeq ($(CFG_RELEASE),\\\n endif\n endif\n \n-# The stage0 compiler needs to use the previous key recorded in src/stage0.txt,\n-# except for local-rebuild when it just uses the same current key.\n-ifdef CFG_ENABLE_LOCAL_REBUILD\n-CFG_BOOTSTRAP_KEY_STAGE0=$(CFG_BOOTSTRAP_KEY)\n-else\n-CFG_BOOTSTRAP_KEY_STAGE0=$(shell sed -ne 's/^rustc_key: //p' $(S)src/stage0.txt)\n-endif\n-\n # The name of the package to use for creating tarballs, installers etc.\n CFG_PACKAGE_NAME=rustc-$(CFG_PACKAGE_VERS)\n \n@@ -387,13 +368,16 @@ CFG_INFO := $(info cfg: disabling unstable features (CFG_DISABLE_UNSTABLE_FEATUR\n # Turn on feature-staging\n export CFG_DISABLE_UNSTABLE_FEATURES\n # Subvert unstable feature lints to do the self-build\n-export RUSTC_BOOTSTRAP_KEY:=$(CFG_BOOTSTRAP_KEY)\n+export RUSTC_BOOTSTRAP\n endif\n-export CFG_BOOTSTRAP_KEY\n ifdef CFG_MUSL_ROOT\n export CFG_MUSL_ROOT\n endif\n \n+# FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n+# Remove this once the bootstrap compiler uses the new login in Issue #36548.\n+export RUSTC_BOOTSTRAP_KEY=62b3e239\n+\n ######################################################################\n # Per-stage targets and runner\n ######################################################################"}, {"sha": "1b139909ab458587e6398629275c2245183fca77", "filename": "mk/target.mk", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -42,23 +42,6 @@ $(foreach host,$(CFG_HOST), \\\n    $(foreach crate,$(CRATES), \\\n     $(eval $(call RUST_CRATE_FULLDEPS,$(stage),$(target),$(host),$(crate)))))))\n \n-# $(1) stage\n-# $(2) target\n-# $(3) host\n-define DEFINE_BOOTSTRAP_KEY\n-BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3) := $$(CFG_BOOTSTRAP_KEY)\n-ifeq ($(1),0)\n-ifeq ($(3),$$(CFG_BUILD))\n-BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3) := $$(CFG_BOOTSTRAP_KEY_STAGE0)\n-endif\n-endif\n-endef\n-\n-$(foreach host,$(CFG_TARGET), \\\n- $(foreach target,$(CFG_TARGET), \\\n-  $(foreach stage,$(STAGES), \\\n-   $(eval $(call DEFINE_BOOTSTRAP_KEY,$(stage),$(target),$(host))))))\n-\n # RUST_TARGET_STAGE_N template: This defines how target artifacts are built\n # for all stage/target architecture combinations. This is one giant rule which\n # works as follows:\n@@ -83,8 +66,6 @@ $(foreach host,$(CFG_TARGET), \\\n define RUST_TARGET_STAGE_N\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): CFG_COMPILER_HOST_TRIPLE = $(2)\n-$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n-\texport RUSTC_BOOTSTRAP_KEY := $$(BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3))\n $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t\t$$(CRATEFILE_$(4)) \\\n \t\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4)) \\\n@@ -132,8 +113,6 @@ endef\n # $(4) - name of the tool being built\n define TARGET_TOOL\n \n-$$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n-\texport RUSTC_BOOTSTRAP_KEY := $$(BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3))\n $$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n \t\t$$(TOOL_SOURCE_$(4)) \\\n \t\t$$(TOOL_INPUTS_$(4)) \\"}, {"sha": "af76a49fed0455bbf5028b5a67b7da39cba445c2", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -214,7 +214,7 @@ pub fn compiletest(build: &Build,\n             }\n         }\n     }\n-    build.add_bootstrap_key(compiler, &mut cmd);\n+    build.add_bootstrap_key(&mut cmd);\n \n     cmd.arg(\"--adb-path\").arg(\"adb\");\n     cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);"}, {"sha": "ff8e4757bd1f140aceb274f70734a7b8309ca998", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -119,7 +119,7 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n     for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n         let file = t!(file);\n         let mut cmd = Command::new(&compiler_path);\n-        build.add_bootstrap_key(&compiler, &mut cmd);\n+        build.add_bootstrap_key(&mut cmd);\n         build.run(cmd.arg(\"--target\").arg(target)\n                      .arg(\"--emit=obj\")\n                      .arg(\"--out-dir\").arg(into)\n@@ -185,7 +185,6 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     cargo.env(\"CFG_RELEASE\", &build.release)\n          .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n          .env(\"CFG_VERSION\", &build.version)\n-         .env(\"CFG_BOOTSTRAP_KEY\", &build.bootstrap_key)\n          .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(String::new()))\n          .env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n "}, {"sha": "e4577bfcdfc94ea4f4407c555718e22513ba9641", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -120,6 +120,7 @@ struct Build {\n     rustc: Option<String>,\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n+    submodules: Option<bool>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -225,6 +226,7 @@ impl Config {\n         config.cargo = build.cargo.map(PathBuf::from);\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n+        set(&mut config.submodules, build.submodules);\n \n         if let Some(ref llvm) = toml.llvm {\n             set(&mut config.ccache, llvm.ccache);"}, {"sha": "39c976edc13d1954ce6a6032c93f3ebb8513a0af", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -76,6 +76,9 @@\n # library and facade crates.\n #compiler-docs = false\n \n+# Indicate whether submodules are managed and updated automatically.\n+#submodules = true\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "a63c23b46212d0e68d9a081f135d488ce0f77843", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -662,7 +662,7 @@ impl Build {\n              .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n              .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n \n-        self.add_bootstrap_key(compiler, &mut cargo);\n+        self.add_bootstrap_key(&mut cargo);\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -871,16 +871,11 @@ impl Build {\n     }\n \n     /// Adds the compiler's bootstrap key to the environment of `cmd`.\n-    fn add_bootstrap_key(&self, compiler: &Compiler, cmd: &mut Command) {\n-        // In stage0 we're using a previously released stable compiler, so we\n-        // use the stage0 bootstrap key. Otherwise we use our own build's\n-        // bootstrap key.\n-        let bootstrap_key = if compiler.is_snapshot(self) && !self.local_rebuild {\n-            &self.bootstrap_key_stage0\n-        } else {\n-            &self.bootstrap_key\n-        };\n-        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", bootstrap_key);\n+    fn add_bootstrap_key(&self, cmd: &mut Command) {\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"\");\n+        // FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n+        // Remove this once the bootstrap compiler uses the new login in Issue #36548.\n+        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", \"62b3e239\");\n     }\n \n     /// Returns the compiler's libdir where it stores the dynamic libraries that"}, {"sha": "1b4e86fb30f254c8cb2dd914501c2f55b9e7f2dd", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -18,9 +18,10 @@\n //! LLVM and compiler-rt are essentially just wired up to everything else to\n //! ensure that they're always in place if needed.\n \n+use std::fs::{self, File};\n+use std::io::{Read, Write};\n use std::path::Path;\n use std::process::Command;\n-use std::fs::{self, File};\n \n use build_helper::output;\n use cmake;\n@@ -43,11 +44,17 @@ pub fn llvm(build: &Build, target: &str) {\n     // artifacts are missing) then we keep going, otherwise we bail out.\n     let dst = build.llvm_out(target);\n     let stamp = build.src.join(\"src/rustllvm/llvm-auto-clean-trigger\");\n+    let mut stamp_contents = String::new();\n+    t!(t!(File::open(&stamp)).read_to_string(&mut stamp_contents));\n     let done_stamp = dst.join(\"llvm-finished-building\");\n-    build.clear_if_dirty(&dst, &stamp);\n-    if fs::metadata(&done_stamp).is_ok() {\n-        return\n+    if done_stamp.exists() {\n+        let mut done_contents = String::new();\n+        t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n+        if done_contents == stamp_contents {\n+            return\n+        }\n     }\n+    drop(fs::remove_dir_all(&dst));\n \n     println!(\"Building LLVM for {}\", target);\n \n@@ -73,7 +80,9 @@ pub fn llvm(build: &Build, target: &str) {\n        .define(\"WITH_POLLY\", \"OFF\")\n        .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n        .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n-       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string());\n+       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string())\n+       .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n+       .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n     if target.starts_with(\"i686\") {\n         cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n@@ -86,9 +95,7 @@ pub fn llvm(build: &Build, target: &str) {\n         //        actually exists most of the time in normal installs of LLVM.\n         let host = build.llvm_out(&build.config.build).join(\"bin/llvm-tblgen\");\n         cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n-           .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n-           .define(\"LLVM_TABLEGEN\", &host)\n-           .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n+           .define(\"LLVM_TABLEGEN\", &host);\n     }\n \n     // MSVC handles compiler business itself\n@@ -114,7 +121,7 @@ pub fn llvm(build: &Build, target: &str) {\n     //        tools and libs on all platforms.\n     cfg.build();\n \n-    t!(File::create(&done_stamp));\n+    t!(t!(File::create(&done_stamp)).write_all(stamp_contents.as_bytes()));\n }\n \n fn check_llvm_version(build: &Build, llvm_config: &Path) {"}, {"sha": "eb0636e8576beb147e3c4f3823cd7e5b2cb09b46", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -351,12 +351,10 @@ impl TypeId {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(get_type_id)]\n-    ///\n     /// use std::any::{Any, TypeId};\n     ///\n-    /// fn is_string(s: &Any) -> bool {\n-    ///     TypeId::of::<String>() == s.get_type_id()\n+    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n+    ///     TypeId::of::<String>() == TypeId::of::<T>()\n     /// }\n     ///\n     /// fn main() {"}, {"sha": "9eeb2608071c2fd4bca9f43479e64b36f861f756", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -420,6 +420,18 @@ impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n     where I: FusedIterator<Item=&'a T>, T: Clone\n {}\n \n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        self.it.get_unchecked(i).clone()\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n /// An iterator that repeats endlessly.\n ///\n /// This `struct` is created by the [`cycle()`] method on [`Iterator`]. See its\n@@ -773,6 +785,13 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n             unsafe {\n                 Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n             }\n+        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+            // match the base implementation's potential side effects\n+            unsafe {\n+                self.a.get_unchecked(self.index);\n+            }\n+            self.index += 1;\n+            None\n         } else {\n             None\n         }\n@@ -789,6 +808,23 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n               B: DoubleEndedIterator + ExactSizeIterator\n     {\n+        // Adjust a, b to equal length\n+        if A::may_have_side_effect() {\n+            let sz = self.a.len();\n+            if sz > self.len {\n+                for _ in 0..sz - cmp::max(self.len, self.index) {\n+                    self.a.next_back();\n+                }\n+            }\n+        }\n+        if B::may_have_side_effect() {\n+            let sz = self.b.len();\n+            if sz > self.len {\n+                for _ in 0..sz - self.len {\n+                    self.b.next_back();\n+                }\n+            }\n+        }\n         if self.index < self.len {\n             self.len -= 1;\n             let i = self.len;\n@@ -814,6 +850,9 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n         (self.a.get_unchecked(i), self.b.get_unchecked(i))\n     }\n \n+    fn may_have_side_effect() -> bool {\n+        A::may_have_side_effect() || B::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -920,6 +959,18 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n     where F: FnMut(I::Item) -> B {}\n \n+#[doc(hidden)]\n+unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n+    where I: TrustedRandomAccess,\n+          F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        (self.f)(self.iter.get_unchecked(i))\n+    }\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n /// An iterator that filters the elements of `iter` with `predicate`.\n ///\n /// This `struct` is created by the [`filter()`] method on [`Iterator`]. See its\n@@ -1135,6 +1186,10 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n         (self.count + i, self.iter.get_unchecked(i))\n     }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1764,6 +1819,10 @@ unsafe impl<I> TrustedRandomAccess for Fuse<I>\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         self.iter.get_unchecked(i)\n     }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "bc1aaa09f3dbd35d3f566c667dc896564b591ce5", "filename": "src/libcore/iter_private.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fiter_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fiter_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter_private.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -14,12 +14,15 @@\n /// # Safety\n ///\n /// The iterator's .len() and size_hint() must be exact.\n+/// `.len()` must be cheap to call.\n ///\n /// .get_unchecked() must return distinct mutable references for distinct\n /// indices (if applicable), and must return a valid reference if index is in\n /// 0..self.len().\n #[doc(hidden)]\n pub unsafe trait TrustedRandomAccess : ExactSizeIterator {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n+    /// Return `true` if getting an iterator element may have\n+    /// side effects. Remember to take inner iterators into account.\n+    fn may_have_side_effect() -> bool;\n }\n-"}, {"sha": "31be404ba905a1fcb580d0e219aa4528c7b96972", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1968,11 +1968,13 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n         &*self.ptr.offset(i as isize)\n     }\n+    fn may_have_side_effect() -> bool { false }\n }\n \n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n         &mut *self.ptr.offset(i as isize)\n     }\n+    fn may_have_side_effect() -> bool { false }\n }"}, {"sha": "657f7e7992fee06ba53947f87802138df76500a7", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -277,7 +277,9 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val as u8, order); }\n+        unsafe {\n+            atomic_store(self.v.get(), val as u8, order);\n+        }\n     }\n \n     /// Stores a value into the bool, returning the old value.\n@@ -366,9 +368,11 @@ impl AtomicBool {\n                             current: bool,\n                             new: bool,\n                             success: Ordering,\n-                            failure: Ordering) -> Result<bool, bool> {\n-        match unsafe { atomic_compare_exchange(self.v.get(), current as u8, new as u8,\n-                                               success, failure) } {\n+                            failure: Ordering)\n+                            -> Result<bool, bool> {\n+        match unsafe {\n+            atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n+        } {\n             Ok(x) => Ok(x != 0),\n             Err(x) => Err(x != 0),\n         }\n@@ -409,9 +413,11 @@ impl AtomicBool {\n                                  current: bool,\n                                  new: bool,\n                                  success: Ordering,\n-                                 failure: Ordering) -> Result<bool, bool> {\n-        match unsafe { atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8,\n-                                                    success, failure) } {\n+                                 failure: Ordering)\n+                                 -> Result<bool, bool> {\n+        match unsafe {\n+            atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n+        } {\n             Ok(x) => Ok(x != 0),\n             Err(x) => Err(x != 0),\n         }\n@@ -632,9 +638,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_load(self.p.get() as *mut usize, order) as *mut T\n-        }\n+        unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n     }\n \n     /// Stores a value into the pointer.\n@@ -660,7 +664,9 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get() as *mut usize, ptr as usize, order); }\n+        unsafe {\n+            atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n+        }\n     }\n \n     /// Stores a value into the pointer, returning the old value.\n@@ -745,7 +751,8 @@ impl<T> AtomicPtr<T> {\n                             current: *mut T,\n                             new: *mut T,\n                             success: Ordering,\n-                            failure: Ordering) -> Result<*mut T, *mut T> {\n+                            failure: Ordering)\n+                            -> Result<*mut T, *mut T> {\n         unsafe {\n             let res = atomic_compare_exchange(self.p.get() as *mut usize,\n                                               current as usize,\n@@ -794,7 +801,8 @@ impl<T> AtomicPtr<T> {\n                                  current: *mut T,\n                                  new: *mut T,\n                                  success: Ordering,\n-                                 failure: Ordering) -> Result<*mut T, *mut T> {\n+                                 failure: Ordering)\n+                                 -> Result<*mut T, *mut T> {\n         unsafe {\n             let res = atomic_compare_exchange_weak(self.p.get() as *mut usize,\n                                                    current as usize,\n@@ -1266,9 +1274,9 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n         Relaxed => Relaxed,\n-        SeqCst  => SeqCst,\n+        SeqCst => SeqCst,\n         Acquire => Acquire,\n-        AcqRel  => Acquire,\n+        AcqRel => Acquire,\n     }\n }\n \n@@ -1277,9 +1285,9 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n     match order {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_store(dst, val),\n+        SeqCst => intrinsics::atomic_store(dst, val),\n         Acquire => panic!(\"there is no such thing as an acquire store\"),\n-        AcqRel  => panic!(\"there is no such thing as an acquire/release store\"),\n+        AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n     }\n }\n \n@@ -1288,9 +1296,9 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        SeqCst  => intrinsics::atomic_load(dst),\n+        SeqCst => intrinsics::atomic_load(dst),\n         Release => panic!(\"there is no such thing as a release load\"),\n-        AcqRel  => panic!(\"there is no such thing as an acquire/release load\"),\n+        AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n     }\n }\n \n@@ -1299,9 +1307,9 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n         Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xchg(dst, val)\n+        SeqCst => intrinsics::atomic_xchg(dst, val),\n     }\n }\n \n@@ -1311,9 +1319,9 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n         Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xadd(dst, val)\n+        SeqCst => intrinsics::atomic_xadd(dst, val),\n     }\n }\n \n@@ -1323,9 +1331,9 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n         Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xsub(dst, val)\n+        SeqCst => intrinsics::atomic_xsub(dst, val),\n     }\n }\n \n@@ -1334,63 +1342,57 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n                                      success: Ordering,\n-                                     failure: Ordering) -> Result<T, T> {\n+                                     failure: Ordering)\n+                                     -> Result<T, T> {\n     let (val, ok) = match (success, failure) {\n         (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n         (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        (AcqRel, Acquire)  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n         (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        (SeqCst, SeqCst)   => intrinsics::atomic_cxchg(dst, old, new),\n+        (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n         (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed)  => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed)  => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire)  => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+        (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n         (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n     };\n-    if ok {\n-        Ok(val)\n-    } else {\n-        Err(val)\n-    }\n+    if ok { Ok(val) } else { Err(val) }\n }\n \n #[inline]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n                                           success: Ordering,\n-                                          failure: Ordering) -> Result<T, T> {\n+                                          failure: Ordering)\n+                                          -> Result<T, T> {\n     let (val, ok) = match (success, failure) {\n         (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n         (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n-        (AcqRel, Acquire)  => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n+        (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n         (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n-        (SeqCst, SeqCst)   => intrinsics::atomic_cxchgweak(dst, old, new),\n+        (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n         (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed)  => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed)  => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire)  => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+        (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n         (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n     };\n-    if ok {\n-        Ok(val)\n-    } else {\n-        Err(val)\n-    }\n+    if ok { Ok(val) } else { Err(val) }\n }\n \n #[inline]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n         Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_and(dst, val)\n+        SeqCst => intrinsics::atomic_and(dst, val),\n     }\n }\n \n@@ -1399,9 +1401,9 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n         Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_or(dst, val)\n+        SeqCst => intrinsics::atomic_or(dst, val),\n     }\n }\n \n@@ -1410,9 +1412,9 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n         Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xor(dst, val)\n+        SeqCst => intrinsics::atomic_xor(dst, val),\n     }\n }\n \n@@ -1443,9 +1445,9 @@ pub fn fence(order: Ordering) {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n             Release => intrinsics::atomic_fence_rel(),\n-            AcqRel  => intrinsics::atomic_fence_acqrel(),\n-            SeqCst  => intrinsics::atomic_fence(),\n-            Relaxed => panic!(\"there is no such thing as a relaxed fence\")\n+            AcqRel => intrinsics::atomic_fence_acqrel(),\n+            SeqCst => intrinsics::atomic_fence(),\n+            Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n         }\n     }\n }"}, {"sha": "e7994f4e0ef0a3837ee33ad2719db00e18d45c80", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -116,7 +116,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n         // The \"IP\" is an index into the call-site table, with two exceptions:\n         // -1 means 'no-action', and 0 means 'terminate'.\n         match ip as isize {\n-           -1 => return EHAction::None,\n+            -1 => return EHAction::None,\n             0 => return EHAction::Terminate,\n             _ => (),\n         }\n@@ -182,12 +182,8 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n             assert!(context.func_start != 0);\n             context.func_start\n         }\n-        DW_EH_PE_textrel => {\n-            (*context.get_text_start)()\n-        }\n-        DW_EH_PE_datarel => {\n-            (*context.get_data_start)()\n-        }\n+        DW_EH_PE_textrel => (*context.get_text_start)(),\n+        DW_EH_PE_datarel => (*context.get_data_start)(),\n         _ => panic!(),\n     };\n "}, {"sha": "0e48e37c92358150f285f4cc5db6357e098b9fb3", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -57,13 +57,10 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n                                          exception_object: *mut uw::_Unwind_Exception,\n                                          context: *mut uw::_Unwind_Context)\n                                          -> uw::_Unwind_Reason_Code {\n-    __gxx_personality_v0(version, actions,\n-                         exception_class,\n-                         exception_object,\n-                         context)\n+    __gxx_personality_v0(version, actions, exception_class, exception_object, context)\n }\n \n-extern {\n+extern \"C\" {\n     fn __cxa_allocate_exception(thrown_size: libc::size_t) -> *mut libc::c_void;\n     fn __cxa_free_exception(thrown_exception: *mut libc::c_void);\n     fn __cxa_throw(thrown_exception: *mut libc::c_void,"}, {"sha": "f0f19be3366bd064f9699fa87271f7518007f401", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -156,14 +156,16 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     let eh_action = find_eh_action(context);\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n-            EHAction::None | EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::None |\n+            EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n             EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n             EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n         }\n     } else {\n         match eh_action {\n             EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+            EHAction::Cleanup(lpad) |\n+            EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n@@ -182,7 +184,7 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n                                          exception_object: *mut uw::_Unwind_Exception,\n                                          context: *mut uw::_Unwind_Context)\n-                                        -> uw::_Unwind_Reason_Code {\n+                                         -> uw::_Unwind_Reason_Code {\n     let state = state as c_int;\n     let action = state & uw::_US_ACTION_MASK as c_int;\n     let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n@@ -191,7 +193,7 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n         // we want to continue unwinding the stack, otherwise all our backtraces\n         // would end at __rust_try\n         if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n-            return continue_unwind(exception_object, context)\n+            return continue_unwind(exception_object, context);\n         }\n         true\n     } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n@@ -207,7 +209,9 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n     // take only the context pointer, GCC personality routines stash a pointer to exception_object\n     // in the context, using location reserved for ARM's \"scratch register\" (r12).\n-    uw::_Unwind_SetGR(context, uw::UNWIND_POINTER_REG, exception_object as uw::_Unwind_Ptr);\n+    uw::_Unwind_SetGR(context,\n+                      uw::UNWIND_POINTER_REG,\n+                      exception_object as uw::_Unwind_Ptr);\n     // ...A more principled approach would be to provide the full definition of ARM's\n     // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n     // bypassing DWARF compatibility functions.\n@@ -223,7 +227,8 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     } else {\n         match eh_action {\n             EHAction::None => return continue_unwind(exception_object, context),\n-            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+            EHAction::Cleanup(lpad) |\n+            EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n@@ -247,8 +252,8 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     // defined in libgcc\n     extern \"C\" {\n         fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-                                -> uw::_Unwind_Reason_Code;\n+                              context: *mut uw::_Unwind_Context)\n+                              -> uw::_Unwind_Reason_Code;\n     }\n }\n "}, {"sha": "d4906b556b31a5be0fd2e9922dd7c9ade6629f0e", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -129,7 +129,8 @@ unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n     };\n     match find_eh_action(dc.HandlerData, &eh_ctx) {\n         EHAction::None => None,\n-        EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => Some(lpad),\n+        EHAction::Cleanup(lpad) |\n+        EHAction::Catch(lpad) => Some(lpad),\n         EHAction::Terminate => intrinsics::abort(),\n     }\n }"}, {"sha": "80340f9a9255b1b5f79d32ab756a4250004df0cd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -401,6 +401,7 @@ impl<'a> LoweringContext<'a> {\n             bounds: self.lower_bounds(&tp.bounds),\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n+            pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n@@ -420,6 +421,7 @@ impl<'a> LoweringContext<'a> {\n         hir::LifetimeDef {\n             lifetime: self.lower_lifetime(&l.lifetime),\n             bounds: self.lower_lifetimes(&l.bounds),\n+            pure_wrt_drop: l.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n "}, {"sha": "6e81c3e700ed2ab47a8350f7a5560602080252d9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -95,6 +95,7 @@ impl fmt::Debug for Lifetime {\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: HirVec<Lifetime>,\n+    pub pure_wrt_drop: bool,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -290,6 +291,7 @@ pub struct TyParam {\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n     pub span: Span,\n+    pub pure_wrt_drop: bool,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -328,6 +330,36 @@ impl Generics {\n     }\n }\n \n+pub enum UnsafeGeneric {\n+    Region(LifetimeDef, &'static str),\n+    Type(TyParam, &'static str),\n+}\n+\n+impl UnsafeGeneric {\n+    pub fn attr_name(&self) -> &'static str {\n+        match *self {\n+            UnsafeGeneric::Region(_, s) => s,\n+            UnsafeGeneric::Type(_, s) => s,\n+        }\n+    }\n+}\n+\n+impl Generics {\n+    pub fn carries_unsafe_attr(&self) -> Option<UnsafeGeneric> {\n+        for r in &self.lifetimes {\n+            if r.pure_wrt_drop {\n+                return Some(UnsafeGeneric::Region(r.clone(), \"may_dangle\"));\n+            }\n+        }\n+        for t in &self.ty_params {\n+            if t.pure_wrt_drop {\n+                return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n /// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {"}, {"sha": "be6594320244d263811c6c9a8696226ef4da6bbe", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1231,16 +1231,17 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                          lifetime: hir::Lifetime,\n                          region_names: &HashSet<ast::Name>)\n                          -> hir::HirVec<hir::TyParam> {\n-        ty_params.iter().map(|ty_param| {\n-            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n+        ty_params.into_iter().map(|ty_param| {\n+            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds,\n                                                       lifetime,\n                                                       region_names);\n             hir::TyParam {\n                 name: ty_param.name,\n                 id: ty_param.id,\n                 bounds: bounds,\n-                default: ty_param.default.clone(),\n+                default: ty_param.default,\n                 span: ty_param.span,\n+                pure_wrt_drop: ty_param.pure_wrt_drop,\n             }\n         }).collect()\n     }\n@@ -1299,8 +1300,11 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                         -> hir::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n-            lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n-                                              bounds: hir::HirVec::new() });\n+            lifetimes.push(hir::LifetimeDef {\n+                lifetime: *lt,\n+                bounds: hir::HirVec::new(),\n+                pure_wrt_drop: false,\n+            });\n         }\n         for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||"}, {"sha": "b54862ae0ade6c2f4be2e08d2b2a963b54e79a49", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -35,7 +35,6 @@ use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MultiItemModifier;\n@@ -425,7 +424,7 @@ pub struct LoadedMacro {\n \n pub enum LoadedMacroKind {\n     Def(ast::MacroDef),\n-    CustomDerive(String, Rc<MultiItemModifier>),\n+    CustomDerive(String, Box<MultiItemModifier>),\n }\n \n pub trait CrateLoader {"}, {"sha": "5ce43d905ec717cd84ec4c2d83d27f405314f880", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -597,7 +597,8 @@ impl<'a, 'gcx, 'tcx> Struct {\n                                   -> Result<Option<FieldPath>, LayoutError<'gcx>> {\n         let tcx = infcx.tcx.global_tcx();\n         match (ty.layout(infcx)?, &ty.sty) {\n-            (&Scalar { non_zero: true, .. }, _) => Ok(Some(vec![])),\n+            (&Scalar { non_zero: true, .. }, _) |\n+            (&CEnum { non_zero: true, .. }, _) => Ok(Some(vec![])),\n             (&FatPointer { non_zero: true, .. }, _) => {\n                 Ok(Some(vec![FAT_PTR_ADDR as u32]))\n             }\n@@ -769,6 +770,7 @@ pub enum Layout {\n     CEnum {\n         discr: Integer,\n         signed: bool,\n+        non_zero: bool,\n         // Inclusive discriminant range.\n         // If min > max, it represents min...u64::MAX followed by 0...max.\n         // FIXME(eddyb) always use the shortest range, e.g. by finding\n@@ -1002,9 +1004,10 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                 if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n-                    let (mut min, mut max) = (i64::MAX, i64::MIN);\n+                    let (mut min, mut max, mut non_zero) = (i64::MAX, i64::MIN, true);\n                     for v in &def.variants {\n                         let x = v.disr_val.to_u64_unchecked() as i64;\n+                        if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n                     }\n@@ -1013,6 +1016,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n+                        non_zero: non_zero,\n                         min: min as u64,\n                         max: max as u64\n                     });\n@@ -1069,19 +1073,17 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if path == &[0] && variants[discr].len() == 1 {\n-                            match *variants[discr][0].layout(infcx)? {\n-                                Scalar { value, .. } => {\n-                                    return success(RawNullablePointer {\n-                                        nndiscr: discr as u64,\n-                                        value: value\n-                                    });\n-                                }\n-                                _ => {\n-                                    bug!(\"Layout::compute: `{}`'s non-zero \\\n-                                        `{}` field not scalar?!\",\n-                                        ty, variants[discr][0])\n-                                }\n-                            }\n+                            let value = match *variants[discr][0].layout(infcx)? {\n+                                Scalar { value, .. } => value,\n+                                CEnum { discr, .. } => Int(discr),\n+                                _ => bug!(\"Layout::compute: `{}`'s non-zero \\\n+                                           `{}` field not scalar?!\",\n+                                           ty, variants[discr][0])\n+                            };\n+                            return success(RawNullablePointer {\n+                                nndiscr: discr as u64,\n+                                value: value,\n+                            });\n                         }\n \n                         path.push(0); // For GEP through a pointer."}, {"sha": "03d0e1e41be2e49033e68f0f666e81fb024a1fc3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -680,6 +680,11 @@ pub struct TypeParameterDef<'tcx> {\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n     pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n+\n+    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n+    /// on generic parameter `T`, asserts data behind the parameter\n+    /// `T` won't be accessed during the parent type's `Drop` impl.\n+    pub pure_wrt_drop: bool,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -688,6 +693,11 @@ pub struct RegionParameterDef<'tcx> {\n     pub def_id: DefId,\n     pub index: u32,\n     pub bounds: Vec<&'tcx ty::Region>,\n+\n+    /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n+    /// on generic parameter `'a`, asserts data of lifetime `'a`\n+    /// won't be accessed during the parent type's `Drop` impl.\n+    pub pure_wrt_drop: bool,\n }\n \n impl<'tcx> RegionParameterDef<'tcx> {\n@@ -732,6 +742,14 @@ impl<'tcx> Generics<'tcx> {\n     pub fn count(&self) -> usize {\n         self.parent_count() + self.own_count()\n     }\n+\n+    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef<'tcx> {\n+        &self.regions[param.index as usize - self.has_self as usize]\n+    }\n+\n+    pub fn type_param(&self, param: &ParamTy) -> &TypeParameterDef<'tcx> {\n+        &self.types[param.idx as usize - self.has_self as usize - self.regions.len()]\n+    }\n }\n \n /// Bounds on generics."}, {"sha": "49683c634692c324f7497d449e04cb15d54461da", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -716,6 +716,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n             object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n+            pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n \n@@ -754,6 +755,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n             def_id: self.def_id,\n             index: self.index,\n             bounds: self.bounds.fold_with(folder),\n+            pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n "}, {"sha": "e82da3c3958310e6be29986d1aac3c2a1e54a8c0", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -304,8 +304,15 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let params = self.iter().map(|k| k.fold_with(folder)).collect();\n-        folder.tcx().mk_substs(params)\n+        let params: Vec<_> = self.iter().map(|k| k.fold_with(folder)).collect();\n+\n+        // If folding doesn't change the substs, it's faster to avoid\n+        // calling `mk_substs` and instead reuse the existing substs.\n+        if params[..] == self[..] {\n+            self\n+        } else {\n+            folder.tcx().mk_substs(params)\n+        }\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {"}, {"sha": "996df2e7fcfcaf3597b510b59ecb82b7e5727ca2", "filename": "src/librustc_data_structures/blake2b.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// An implementation of the Blake2b cryptographic hash function.\n+// The implementation closely follows: https://tools.ietf.org/html/rfc7693\n+//\n+// \"BLAKE2 is a cryptographic hash function faster than MD5, SHA-1, SHA-2, and\n+//  SHA-3, yet is at least as secure as the latest standard SHA-3.\"\n+// according to their own website :)\n+//\n+// Indeed this implementation is two to three times as fast as our SHA-256\n+// implementation. If you have the luxury of being able to use crates from\n+// crates.io, you can go there and find still faster implementations.\n+\n+pub struct Blake2bCtx {\n+    b: [u8; 128],\n+    h: [u64; 8],\n+    t: [u64; 2],\n+    c: usize,\n+    outlen: usize,\n+}\n+\n+impl ::std::fmt::Debug for Blake2bCtx {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{:?}\", self.h)\n+    }\n+}\n+\n+#[inline(always)]\n+fn b2b_g(v: &mut [u64; 16],\n+         a: usize,\n+         b: usize,\n+         c: usize,\n+         d: usize,\n+         x: u64,\n+         y: u64)\n+{\n+    v[a] = v[a].wrapping_add(v[b]).wrapping_add(x);\n+    v[d] = (v[d] ^ v[a]).rotate_right(32);\n+    v[c] = v[c].wrapping_add(v[d]);\n+    v[b] = (v[b] ^ v[c]).rotate_right(24);\n+    v[a] = v[a].wrapping_add(v[b]).wrapping_add(y);\n+    v[d] = (v[d] ^ v[a]).rotate_right(16);\n+    v[c] = v[c].wrapping_add(v[d]);\n+    v[b] = (v[b] ^ v[c]).rotate_right(63);\n+}\n+\n+// Initialization vector\n+const BLAKE2B_IV: [u64; 8] = [\n+   0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n+   0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n+   0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n+   0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n+];\n+\n+fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n+\n+    const SIGMA: [[usize; 16]; 12] = [\n+        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n+        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ],\n+        [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 ],\n+        [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 ],\n+        [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 ],\n+        [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 ],\n+        [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 ],\n+        [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 ],\n+        [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 ],\n+        [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 ],\n+        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n+        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ]\n+    ];\n+\n+    let mut v: [u64; 16] = [\n+        ctx.h[0],\n+        ctx.h[1],\n+        ctx.h[2],\n+        ctx.h[3],\n+        ctx.h[4],\n+        ctx.h[5],\n+        ctx.h[6],\n+        ctx.h[7],\n+\n+        BLAKE2B_IV[0],\n+        BLAKE2B_IV[1],\n+        BLAKE2B_IV[2],\n+        BLAKE2B_IV[3],\n+        BLAKE2B_IV[4],\n+        BLAKE2B_IV[5],\n+        BLAKE2B_IV[6],\n+        BLAKE2B_IV[7],\n+    ];\n+\n+    v[12] ^= ctx.t[0]; // low 64 bits of offset\n+    v[13] ^= ctx.t[1]; // high 64 bits\n+    if last {\n+        v[14] = !v[14];\n+    }\n+\n+    {\n+        // Re-interpret the input buffer in the state as u64s\n+        let m: &mut [u64; 16] = unsafe {\n+            let b: &mut [u8; 128] = &mut ctx.b;\n+            ::std::mem::transmute(b)\n+        };\n+\n+        // It's OK to modify the buffer in place since this is the last time\n+        // this data will be accessed before it's overwritten\n+        if cfg!(target_endian = \"big\") {\n+            for word in &mut m[..] {\n+                *word = word.to_be();\n+            }\n+        }\n+\n+        for i in 0 .. 12 {\n+            b2b_g(&mut v, 0, 4,  8, 12, m[SIGMA[i][ 0]], m[SIGMA[i][ 1]]);\n+            b2b_g(&mut v, 1, 5,  9, 13, m[SIGMA[i][ 2]], m[SIGMA[i][ 3]]);\n+            b2b_g(&mut v, 2, 6, 10, 14, m[SIGMA[i][ 4]], m[SIGMA[i][ 5]]);\n+            b2b_g(&mut v, 3, 7, 11, 15, m[SIGMA[i][ 6]], m[SIGMA[i][ 7]]);\n+            b2b_g(&mut v, 0, 5, 10, 15, m[SIGMA[i][ 8]], m[SIGMA[i][ 9]]);\n+            b2b_g(&mut v, 1, 6, 11, 12, m[SIGMA[i][10]], m[SIGMA[i][11]]);\n+            b2b_g(&mut v, 2, 7,  8, 13, m[SIGMA[i][12]], m[SIGMA[i][13]]);\n+            b2b_g(&mut v, 3, 4,  9, 14, m[SIGMA[i][14]], m[SIGMA[i][15]]);\n+        }\n+    }\n+\n+    for i in 0 .. 8 {\n+        ctx.h[i] ^= v[i] ^ v[i + 8];\n+    }\n+}\n+\n+pub fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n+    assert!(outlen > 0 && outlen <= 64 && key.len() <= 64);\n+\n+    let mut ctx = Blake2bCtx {\n+        b: [0; 128],\n+        h: BLAKE2B_IV,\n+        t: [0; 2],\n+        c: 0,\n+        outlen: outlen,\n+    };\n+\n+    ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n+\n+    if key.len() > 0 {\n+       blake2b_update(&mut ctx, key);\n+       ctx.c = ctx.b.len();\n+    }\n+\n+    ctx\n+}\n+\n+pub fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8])\n+{\n+    let mut bytes_to_copy = data.len();\n+    let mut space_in_buffer = ctx.b.len() - ctx.c;\n+\n+    while bytes_to_copy > space_in_buffer {\n+        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], space_in_buffer);\n+\n+        ctx.t[0] = ctx.t[0].wrapping_add(ctx.b.len() as u64);\n+        if ctx.t[0] < (ctx.b.len() as u64) {\n+            ctx.t[1] += 1;\n+        }\n+        blake2b_compress(ctx, false);\n+        ctx.c = 0;\n+\n+        data = &data[space_in_buffer .. ];\n+        bytes_to_copy -= space_in_buffer;\n+        space_in_buffer = ctx.b.len();\n+    }\n+\n+    if bytes_to_copy > 0 {\n+        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], bytes_to_copy);\n+        ctx.c += bytes_to_copy;\n+    }\n+}\n+\n+pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n+{\n+    ctx.t[0] = ctx.t[0].wrapping_add(ctx.c as u64);\n+    if ctx.t[0] < ctx.c as u64 {\n+        ctx.t[1] += 1;\n+    }\n+\n+    while ctx.c < 128 {\n+        ctx.b[ctx.c] = 0;\n+        ctx.c += 1;\n+    }\n+\n+    blake2b_compress(&mut ctx, true);\n+\n+    if cfg!(target_endian = \"big\") {\n+        // Make sure that the data is in memory in little endian format, as is\n+        // demanded by BLAKE2\n+        for word in &mut ctx.h {\n+            *word = word.to_le();\n+        }\n+    }\n+\n+    checked_mem_copy(&ctx.h, out, ctx.outlen);\n+}\n+\n+#[inline(always)]\n+fn checked_mem_copy<T1, T2>(from: &[T1], to: &mut [T2], byte_count: usize) {\n+    let from_size = from.len() * ::std::mem::size_of::<T1>();\n+    let to_size = to.len() * ::std::mem::size_of::<T2>();\n+    assert!(from_size >= byte_count);\n+    assert!(to_size >= byte_count);\n+    let from_byte_ptr = from.as_ptr() as * const u8;\n+    let to_byte_ptr = to.as_mut_ptr() as * mut u8;\n+    unsafe {\n+        ::std::ptr::copy_nonoverlapping(from_byte_ptr, to_byte_ptr, byte_count);\n+    }\n+}\n+\n+pub fn blake2b(out: &mut [u8], key: &[u8],  data: &[u8])\n+{\n+    let mut ctx = blake2b_new(out.len(), key);\n+    blake2b_update(&mut ctx, data);\n+    blake2b_final(ctx, out);\n+}\n+\n+#[cfg(test)]\n+fn selftest_seq(out: &mut [u8], seed: u32)\n+{\n+   let mut a: u32 = 0xDEAD4BADu32.wrapping_mul(seed);\n+   let mut b: u32 = 1;\n+\n+   for i in 0 .. out.len() {\n+       let t: u32 = a.wrapping_add(b);\n+       a = b;\n+       b = t;\n+       out[i] = ((t >> 24) & 0xFF) as u8;\n+   }\n+}\n+\n+#[test]\n+fn blake2b_selftest()\n+{\n+    // grand hash of hash results\n+    const BLAKE2B_RES: [u8; 32] = [\n+        0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n+        0x10, 0xF5, 0x06, 0xC6, 0x1E, 0x29, 0xDA, 0x56,\n+        0x03, 0xD7, 0x63, 0xB8, 0xBB, 0xAD, 0x2E, 0x73,\n+        0x7F, 0x5E, 0x76, 0x5A, 0x7B, 0xCC, 0xD4, 0x75\n+    ];\n+\n+    // parameter sets\n+    const B2B_MD_LEN: [usize; 4] = [20, 32, 48, 64];\n+    const B2B_IN_LEN: [usize; 6] = [0, 3, 128, 129, 255, 1024];\n+\n+    let mut data = [0u8; 1024];\n+    let mut md = [0u8; 64];\n+    let mut key = [0u8; 64];\n+\n+    let mut ctx = blake2b_new(32, &[]);\n+\n+    for i in 0 .. 4 {\n+       let outlen = B2B_MD_LEN[i];\n+       for j in 0 .. 6 {\n+            let inlen = B2B_IN_LEN[j];\n+\n+            selftest_seq(&mut data[.. inlen], inlen as u32); // unkeyed hash\n+            blake2b(&mut md[.. outlen], &[], &data[.. inlen]);\n+            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+\n+            selftest_seq(&mut key[0 .. outlen], outlen as u32); // keyed hash\n+            blake2b(&mut md[.. outlen], &key[.. outlen], &data[.. inlen]);\n+            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+       }\n+    }\n+\n+    // compute and compare the hash of hashes\n+    blake2b_final(ctx, &mut md[..]);\n+    for i in 0 .. 32 {\n+        assert_eq!(md[i], BLAKE2B_RES[i]);\n+    }\n+}"}, {"sha": "26b9f48ad04dd4041eb879e9b34dfad2098120c5", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -42,6 +42,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n extern crate libc;\n \n pub mod bitslice;\n+pub mod blake2b;\n pub mod bitvec;\n pub mod graph;\n pub mod ivar;"}, {"sha": "5e590cb445f79967be49d645839331aa646f068b", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -333,6 +333,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                 }\n                 Err(err) => {\n+                    stalled = false;\n                     let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n@@ -342,6 +343,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n             }\n         }\n \n+        if stalled {\n+            // There's no need to perform marking, cycle processing and compression when nothing\n+            // changed.\n+            return Outcome {\n+                completed: vec![],\n+                errors: errors,\n+                stalled: stalled,\n+            };\n+        }\n+\n         self.mark_as_waiting();\n         self.process_cycles(processor);\n "}, {"sha": "a307e9b696def0ad6171c570d885544c6cff19b7", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 84, "deletions": 90, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -51,8 +51,8 @@ impl ColorConfig {\n     fn use_color(&self) -> bool {\n         match *self {\n             ColorConfig::Always => true,\n-            ColorConfig::Never  => false,\n-            ColorConfig::Auto   => stderr_isatty(),\n+            ColorConfig::Never => false,\n+            ColorConfig::Auto => stderr_isatty(),\n         }\n     }\n }\n@@ -83,22 +83,22 @@ macro_rules! println_maybe_styled {\n }\n \n impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig,\n-                  code_map: Option<Rc<CodeMapper>>)\n-                  -> EmitterWriter {\n+    pub fn stderr(color_config: ColorConfig, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n-            EmitterWriter { dst: dst,\n-                            cm: code_map}\n+            EmitterWriter {\n+                dst: dst,\n+                cm: code_map,\n+            }\n         } else {\n-            EmitterWriter { dst: Raw(Box::new(io::stderr())),\n-                            cm: code_map}\n+            EmitterWriter {\n+                dst: Raw(Box::new(io::stderr())),\n+                cm: code_map,\n+            }\n         }\n     }\n \n-    pub fn new(dst: Box<Write + Send>,\n-               code_map: Option<Rc<CodeMapper>>)\n-               -> EmitterWriter {\n+    pub fn new(dst: Box<Write + Send>, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst),\n             cm: code_map,\n@@ -107,9 +107,9 @@ impl EmitterWriter {\n \n     fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                    file: Rc<FileMap>,\n-                                    line_index: usize,\n-                                    ann: Annotation) {\n+                                  file: Rc<FileMap>,\n+                                  line_index: usize,\n+                                  ann: Annotation) {\n \n             for slot in file_vec.iter_mut() {\n                 // Look through each of our files for the one we're adding to\n@@ -168,15 +168,15 @@ impl EmitterWriter {\n                 }\n \n                 add_annotation_to_file(&mut output,\n-                                        lo.file,\n-                                        lo.line,\n-                                        Annotation {\n-                                            start_col: lo.col.0,\n-                                            end_col: hi.col.0,\n-                                            is_primary: span_label.is_primary,\n-                                            is_minimized: is_minimized,\n-                                            label: span_label.label.clone(),\n-                                        });\n+                                       lo.file,\n+                                       lo.line,\n+                                       Annotation {\n+                                           start_col: lo.col.0,\n+                                           end_col: hi.col.0,\n+                                           is_primary: span_label.is_primary,\n+                                           is_minimized: is_minimized,\n+                                           label: span_label.label.clone(),\n+                                       });\n             }\n         }\n         output\n@@ -237,19 +237,15 @@ impl EmitterWriter {\n                                 '^',\n                                 Style::UnderlinePrimary);\n                     if !annotation.is_minimized {\n-                        buffer.set_style(line_offset,\n-                                            width_offset + p,\n-                                            Style::UnderlinePrimary);\n+                        buffer.set_style(line_offset, width_offset + p, Style::UnderlinePrimary);\n                     }\n                 } else {\n                     buffer.putc(line_offset + 1,\n                                 width_offset + p,\n                                 '-',\n                                 Style::UnderlineSecondary);\n                     if !annotation.is_minimized {\n-                        buffer.set_style(line_offset,\n-                                            width_offset + p,\n-                                            Style::UnderlineSecondary);\n+                        buffer.set_style(line_offset, width_offset + p, Style::UnderlineSecondary);\n                     }\n                 }\n             }\n@@ -429,8 +425,7 @@ impl EmitterWriter {\n                         }\n                         // Check to make sure we're not in any <*macros>\n                         if !cm.span_to_filename(def_site).contains(\"macros>\") &&\n-                            !trace.macro_decl_name.starts_with(\"#[\")\n-                        {\n+                           !trace.macro_decl_name.starts_with(\"#[\") {\n                             new_labels.push((trace.call_site,\n                                              \"in this macro invocation\".to_string()));\n                             break;\n@@ -475,10 +470,10 @@ impl EmitterWriter {\n         if spans_updated {\n             children.push(SubDiagnostic {\n                 level: Level::Note,\n-                message:\"this error originates in a macro outside of the current \\\n-                         crate\".to_string(),\n+                message: \"this error originates in a macro outside of the current crate\"\n+                    .to_string(),\n                 span: MultiSpan::new(),\n-                render_span: None\n+                render_span: None,\n             });\n         }\n     }\n@@ -502,8 +497,7 @@ impl EmitterWriter {\n             buffer.append(0, &level.to_string(), Style::HeaderMsg);\n             buffer.append(0, \": \", Style::NoStyle);\n             buffer.append(0, msg, Style::NoStyle);\n-        }\n-        else {\n+        } else {\n             buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n             match code {\n                 &Some(ref code) => {\n@@ -522,23 +516,21 @@ impl EmitterWriter {\n         let mut annotated_files = self.preprocess_annotations(msp);\n \n         // Make sure our primary file comes first\n-        let primary_lo =\n-            if let (Some(ref cm), Some(ref primary_span)) = (self.cm.as_ref(),\n-                                                             msp.primary_span().as_ref()) {\n-                if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n-                    cm.lookup_char_pos(primary_span.lo)\n-                }\n-                else {\n-                    emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-                    return Ok(());\n-                }\n+        let primary_lo = if let (Some(ref cm), Some(ref primary_span)) =\n+            (self.cm.as_ref(), msp.primary_span().as_ref()) {\n+            if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n+                cm.lookup_char_pos(primary_span.lo)\n             } else {\n-                // If we don't have span information, emit and exit\n                 emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n-            };\n+            }\n+        } else {\n+            // If we don't have span information, emit and exit\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+            return Ok(());\n+        };\n         if let Ok(pos) =\n-                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n+            annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n             annotated_files.swap(0, pos);\n         }\n \n@@ -554,8 +546,8 @@ impl EmitterWriter {\n                 buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n                 let loc = primary_lo.clone();\n                 buffer.append(buffer_msg_line_offset,\n-                                &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n-                                Style::LineAndColumn);\n+                              &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n+                              Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                 }\n@@ -569,8 +561,8 @@ impl EmitterWriter {\n                 // Then, the secondary file indicator\n                 buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n                 buffer.append(buffer_msg_line_offset + 1,\n-                                &annotated_file.file.name,\n-                                Style::LineAndColumn);\n+                              &annotated_file.file.name,\n+                              Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n                 }\n@@ -591,7 +583,7 @@ impl EmitterWriter {\n                 // this annotated line and the next one\n                 if line_idx < (annotated_file.lines.len() - 1) {\n                     let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n-                                            annotated_file.lines[line_idx].line_index;\n+                                         annotated_file.lines[line_idx].line_index;\n                     if line_idx_delta > 2 {\n                         let last_buffer_line_num = buffer.num_lines();\n                         buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n@@ -672,12 +664,7 @@ impl EmitterWriter {\n         let max_line_num = self.get_max_line_num(span, children);\n         let max_line_num_len = max_line_num.to_string().len();\n \n-        match self.emit_message_default(span,\n-                                        message,\n-                                        code,\n-                                        level,\n-                                        max_line_num_len,\n-                                        false) {\n+        match self.emit_message_default(span, message, code, level, max_line_num_len, false) {\n             Ok(()) => {\n                 if !children.is_empty() {\n                     let mut buffer = StyledBuffer::new();\n@@ -723,13 +710,15 @@ impl EmitterWriter {\n                     }\n                 }\n             }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n+            Err(e) => panic!(\"failed to emit error: {}\", e),\n         }\n         match write!(&mut self.dst, \"\\n\") {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n-            _ => match self.dst.flush() {\n-                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                _ => ()\n+            _ => {\n+                match self.dst.flush() {\n+                    Err(e) => panic!(\"failed to emit error: {}\", e),\n+                    _ => (),\n+                }\n             }\n         }\n     }\n@@ -753,8 +742,9 @@ fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n }\n \n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n-        lvl: &Level,\n-        dst: &mut Destination) -> io::Result<()> {\n+                       lvl: &Level,\n+                       dst: &mut Destination)\n+                       -> io::Result<()> {\n     use lock;\n \n     // In order to prevent error message interleaving, where multiple error lines get intermixed\n@@ -795,8 +785,7 @@ fn stderr_isatty() -> bool {\n     const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n     extern \"system\" {\n         fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE,\n-                          lpMode: *mut DWORD) -> BOOL;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: *mut DWORD) -> BOOL;\n     }\n     unsafe {\n         let handle = GetStdHandle(STD_ERROR_HANDLE);\n@@ -824,9 +813,7 @@ impl BufferedWriter {\n     // note: we use _new because the conditional compilation at its use site may make this\n     // this function unused on some platforms\n     fn _new() -> BufferedWriter {\n-        BufferedWriter {\n-            buffer: vec![]\n-        }\n+        BufferedWriter { buffer: vec![] }\n     }\n }\n \n@@ -853,35 +840,34 @@ impl Destination {\n     /// When not on Windows, prefer the buffered terminal so that we can buffer an entire error\n     /// to be emitted at one time.\n     fn from_stderr() -> Destination {\n-        let stderr: Option<Box<BufferedStderr>>  =\n+        let stderr: Option<Box<BufferedStderr>> =\n             term::TerminfoTerminal::new(BufferedWriter::_new())\n                 .map(|t| Box::new(t) as Box<BufferedStderr>);\n \n         match stderr {\n             Some(t) => BufferedTerminal(t),\n-            None    => Raw(Box::new(io::stderr())),\n+            None => Raw(Box::new(io::stderr())),\n         }\n     }\n \n     #[cfg(windows)]\n     /// Return a normal, unbuffered terminal when on Windows.\n     fn from_stderr() -> Destination {\n-        let stderr: Option<Box<term::StderrTerminal>> =\n-            term::TerminfoTerminal::new(io::stderr())\n-                .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n-                .or_else(|| term::WinConsole::new(io::stderr()).ok()\n-                    .map(|t| Box::new(t) as Box<term::StderrTerminal>));\n+        let stderr: Option<Box<term::StderrTerminal>> = term::TerminfoTerminal::new(io::stderr())\n+            .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n+            .or_else(|| {\n+                term::WinConsole::new(io::stderr())\n+                    .ok()\n+                    .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n+            });\n \n         match stderr {\n             Some(t) => Terminal(t),\n-            None    => Raw(Box::new(io::stderr())),\n+            None => Raw(Box::new(io::stderr())),\n         }\n     }\n \n-    fn apply_style(&mut self,\n-                   lvl: Level,\n-                   style: Style)\n-                   -> io::Result<()> {\n+    fn apply_style(&mut self, lvl: Level, style: Style) -> io::Result<()> {\n         match style {\n             Style::FileNameStyle | Style::LineAndColumn => {}\n             Style::LineNumber => {\n@@ -931,18 +917,26 @@ impl Destination {\n \n     fn start_attr(&mut self, attr: term::Attr) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => { t.attr(attr)?; }\n-            BufferedTerminal(ref mut t) => { t.attr(attr)?; }\n-            Raw(_) => { }\n+            Terminal(ref mut t) => {\n+                t.attr(attr)?;\n+            }\n+            BufferedTerminal(ref mut t) => {\n+                t.attr(attr)?;\n+            }\n+            Raw(_) => {}\n         }\n         Ok(())\n     }\n \n     fn reset_attrs(&mut self) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => { t.reset()?; }\n-            BufferedTerminal(ref mut t) => { t.reset()?; }\n-            Raw(_) => { }\n+            Terminal(ref mut t) => {\n+                t.reset()?;\n+            }\n+            BufferedTerminal(ref mut t) => {\n+                t.reset()?;\n+            }\n+            Raw(_) => {}\n         }\n         Ok(())\n     }"}, {"sha": "25b314256b0925e827ae949fed4056b86f174a29", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -28,8 +28,10 @@\n \n extern crate serialize;\n extern crate term;\n-#[macro_use] extern crate log;\n-#[macro_use] extern crate libc;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate libc;\n extern crate rustc_unicode;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate syntax_pos;\n@@ -52,8 +54,8 @@ pub mod registry;\n pub mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n-use syntax_pos::{MacroBacktrace};\n+use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n+use syntax_pos::MacroBacktrace;\n \n #[derive(Clone)]\n pub enum RenderSpan {\n@@ -89,9 +91,11 @@ impl CodeSuggestion {\n     pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n-        fn push_trailing(buf: &mut String, line_opt: Option<&str>,\n-                         lo: &Loc, hi_opt: Option<&Loc>) {\n-            let (lo, hi_opt) = (lo.col.to_usize(), hi_opt.map(|hi|hi.col.to_usize()));\n+        fn push_trailing(buf: &mut String,\n+                         line_opt: Option<&str>,\n+                         lo: &Loc,\n+                         hi_opt: Option<&Loc>) {\n+            let (lo, hi_opt) = (lo.col.to_usize(), hi_opt.map(|hi| hi.col.to_usize()));\n             if let Some(line) = line_opt {\n                 if line.len() > lo {\n                     buf.push_str(match hi_opt {\n@@ -119,7 +123,11 @@ impl CodeSuggestion {\n         // Find the bounding span.\n         let lo = primary_spans.iter().map(|sp| sp.lo).min().unwrap();\n         let hi = primary_spans.iter().map(|sp| sp.hi).min().unwrap();\n-        let bounding_span = Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n+        let bounding_span = Span {\n+            lo: lo,\n+            hi: hi,\n+            expn_id: NO_EXPANSION,\n+        };\n         let lines = cm.span_to_lines(bounding_span).unwrap();\n         assert!(!lines.lines.is_empty());\n \n@@ -153,7 +161,7 @@ impl CodeSuggestion {\n                     }\n                 }\n                 if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n-                    buf.push_str(&cur_line[.. cur_lo.col.to_usize()]);\n+                    buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n                 }\n             }\n             buf.push_str(substitute);\n@@ -263,8 +271,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n-                      -> &mut DiagnosticBuilder<'a> {\n+    pub fn span_label(&mut self, span: Span, label: &fmt::Display) -> &mut DiagnosticBuilder<'a> {\n         self.span.push_span_label(span, format!(\"{}\", label));\n         self\n     }\n@@ -273,8 +280,7 @@ impl<'a> DiagnosticBuilder<'a> {\n                                label: &fmt::Display,\n                                expected: &fmt::Display,\n                                found: &fmt::Display)\n-                               -> &mut DiagnosticBuilder<'a>\n-    {\n+                               -> &mut DiagnosticBuilder<'a> {\n         self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n     }\n \n@@ -284,8 +290,7 @@ impl<'a> DiagnosticBuilder<'a> {\n                                      found: &fmt::Display,\n                                      expected_extra: &fmt::Display,\n                                      found_extra: &fmt::Display)\n-                                     -> &mut DiagnosticBuilder<'a>\n-    {\n+                                     -> &mut DiagnosticBuilder<'a> {\n         // For now, just attach these as notes\n         self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n         self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n@@ -314,7 +319,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n-    pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n+    pub fn help(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n@@ -333,10 +338,13 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                msg: &str,\n                                                suggestion: String)\n                                                -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, MultiSpan::new(), Some(Suggestion(CodeSuggestion {\n-            msp: sp.into(),\n-            substitutes: vec![suggestion],\n-        })));\n+        self.sub(Level::Help,\n+                 msg,\n+                 MultiSpan::new(),\n+                 Some(Suggestion(CodeSuggestion {\n+                     msp: sp.into(),\n+                     substitutes: vec![suggestion],\n+                 })));\n         self\n     }\n \n@@ -360,18 +368,17 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n-    fn new(handler: &'a Handler,\n-           level: Level,\n-           message: &str) -> DiagnosticBuilder<'a> {\n+    fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder::new_with_code(handler, level, None, message)\n     }\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n     fn new_with_code(handler: &'a Handler,\n-           level: Level,\n-           code: Option<String>,\n-           message: &str) -> DiagnosticBuilder<'a> {\n+                     level: Level,\n+                     code: Option<String>,\n+                     message: &str)\n+                     -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder {\n             handler: handler,\n             level: level,\n@@ -410,9 +417,8 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n-            let mut db = DiagnosticBuilder::new(self.handler,\n-                                                Bug,\n-                                                \"Error constructed but not emitted\");\n+            let mut db =\n+                DiagnosticBuilder::new(self.handler, Bug, \"Error constructed but not emitted\");\n             db.emit();\n             panic!();\n         }\n@@ -443,7 +449,8 @@ impl Handler {\n \n     pub fn with_emitter(can_emit_warnings: bool,\n                         treat_err_as_bug: bool,\n-                        e: Box<Emitter>) -> Handler {\n+                        e: Box<Emitter>)\n+                        -> Handler {\n         Handler {\n             err_count: Cell::new(0),\n             emitter: RefCell::new(e),\n@@ -544,10 +551,10 @@ impl Handler {\n \n     pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n         if err.level == Level::Error || err.level == Level::Fatal {\n-            self.err_count.set(\n-                self.err_count.get().checked_sub(1)\n-                    .expect(\"cancelled an error but err_count is 0\")\n-            );\n+            self.err_count.set(self.err_count\n+                .get()\n+                .checked_sub(1)\n+                .expect(\"cancelled an error but err_count is 0\"));\n         }\n         err.cancel();\n     }\n@@ -558,14 +565,16 @@ impl Handler {\n         }\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str)\n-                                          -> FatalError {\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         self.emit(&sp.into(), msg, Fatal);\n         self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n-    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str)\n+    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n+                                                    sp: S,\n+                                                    msg: &str,\n+                                                    code: &str)\n                                                     -> FatalError {\n         self.emit_with_code(&sp.into(), msg, code, Fatal);\n         self.bump_err_count();\n@@ -619,9 +628,7 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Fatal,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Fatal, msg);\n         db.emit();\n         self.bump_err_count();\n         FatalError\n@@ -630,28 +637,20 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Error,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Error, msg);\n         db.emit();\n         self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Warning,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n     pub fn note_without_error(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Note,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.emit();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        let mut db = DiagnosticBuilder::new(self,\n-                                            Bug,\n-                                            msg);\n+        let mut db = DiagnosticBuilder::new(self, Bug, msg);\n         db.emit();\n         panic!(ExplicitBug);\n     }\n@@ -678,44 +677,41 @@ impl Handler {\n                 match *delayed_bug {\n                     Some((ref span, ref errmsg)) => {\n                         self.span_bug(span.clone(), errmsg);\n-                    },\n+                    }\n                     _ => {}\n                 }\n \n                 return;\n             }\n             1 => s = \"aborting due to previous error\".to_string(),\n-            _  => {\n-                s = format!(\"aborting due to {} previous errors\",\n-                            self.err_count.get());\n+            _ => {\n+                s = format!(\"aborting due to {} previous errors\", self.err_count.get());\n             }\n         }\n \n         panic!(self.fatal(&s));\n     }\n-    pub fn emit(&self,\n-                msp: &MultiSpan,\n-                msg: &str,\n-                lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n+    pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings {\n+            return;\n+        }\n         let mut db = DiagnosticBuilder::new(self, lvl, msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() { self.abort_if_errors(); }\n-    }\n-    pub fn emit_with_code(&self,\n-                          msp: &MultiSpan,\n-                          msg: &str,\n-                          code: &str,\n-                          lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        let mut db = DiagnosticBuilder::new_with_code(self,\n-                                                      lvl,\n-                                                      Some(code.to_owned()),\n-                                                      msg);\n+        if !self.continue_after_error.get() {\n+            self.abort_if_errors();\n+        }\n+    }\n+    pub fn emit_with_code(&self, msp: &MultiSpan, msg: &str, code: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings {\n+            return;\n+        }\n+        let mut db = DiagnosticBuilder::new_with_code(self, lvl, Some(code.to_owned()), msg);\n         db.set_span(msp.clone());\n         db.emit();\n-        if !self.continue_after_error.get() { self.abort_if_errors(); }\n+        if !self.continue_after_error.get() {\n+            self.abort_if_errors();\n+        }\n     }\n }\n \n@@ -750,7 +746,7 @@ impl Level {\n                 } else {\n                     term::color::YELLOW\n                 }\n-            },\n+            }\n             Note => term::color::BRIGHT_GREEN,\n             Help => term::color::BRIGHT_CYAN,\n             Cancelled => unreachable!(),\n@@ -769,8 +765,8 @@ impl Level {\n     }\n }\n \n-pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n+pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T\n+    where M: FnOnce() -> String\n {\n     match opt {\n         Some(t) => t,"}, {"sha": "4c298228c37c7f4b2fa9abf52cbccdf6380d4f93", "filename": "src/librustc_errors/lock.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -40,9 +40,9 @@ pub fn acquire_global_lock(name: &str) -> Box<Any> {\n     extern \"system\" {\n         fn CreateMutexA(lpMutexAttributes: LPSECURITY_ATTRIBUTES,\n                         bInitialOwner: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn WaitForSingleObject(hHandle: HANDLE,\n-                               dwMilliseconds: DWORD) -> DWORD;\n+                        lpName: LPCSTR)\n+                        -> HANDLE;\n+        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n         fn ReleaseMutex(hMutex: HANDLE) -> BOOL;\n         fn CloseHandle(hObject: HANDLE) -> BOOL;\n     }\n@@ -76,7 +76,8 @@ pub fn acquire_global_lock(name: &str) -> Box<Any> {\n         // open up a handle to one if it already exists.\n         let mutex = CreateMutexA(0 as *mut _, 0, cname.as_ptr() as *const u8);\n         if mutex.is_null() {\n-            panic!(\"failed to create global mutex named `{}`: {}\", name,\n+            panic!(\"failed to create global mutex named `{}`: {}\",\n+                   name,\n                    io::Error::last_os_error());\n         }\n         let mutex = Handle(mutex);\n@@ -96,8 +97,10 @@ pub fn acquire_global_lock(name: &str) -> Box<Any> {\n             WAIT_OBJECT_0 | WAIT_ABANDONED => {}\n             code => {\n                 panic!(\"WaitForSingleObject failed on global mutex named \\\n-                        `{}`: {} (ret={:x})\", name,\n-                       io::Error::last_os_error(), code);\n+                        `{}`: {} (ret={:x})\",\n+                       name,\n+                       io::Error::last_os_error(),\n+                       code);\n             }\n         }\n "}, {"sha": "83737681471e2f6fd9e1db306940e9aee0f9ce60", "filename": "src/librustc_errors/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fregistry.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -12,7 +12,7 @@ use std::collections::HashMap;\n \n #[derive(Clone)]\n pub struct Registry {\n-    descriptions: HashMap<&'static str, &'static str>\n+    descriptions: HashMap<&'static str, &'static str>,\n }\n \n impl Registry {"}, {"sha": "abfb71c861b2542239200d916705b86b4f8aa4f7", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -13,12 +13,12 @@\n use syntax_pos::{Span, FileMap};\n use CodeMapper;\n use std::rc::Rc;\n-use {Level};\n+use Level;\n \n #[derive(Clone)]\n pub struct SnippetData {\n     codemap: Rc<CodeMapper>,\n-    files: Vec<FileInfo>\n+    files: Vec<FileInfo>,\n }\n \n #[derive(Clone)]\n@@ -84,4 +84,4 @@ pub enum Style {\n     NoStyle,\n     ErrorCode,\n     Level(Level),\n-}\n\\ No newline at end of file\n+}"}, {"sha": "dfc7c64de019746710c89c9bd1917eae22cd7c39", "filename": "src/librustc_errors/styled_buffer.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -28,10 +28,9 @@ impl StyledBuffer {\n \n     pub fn copy_tabs(&mut self, row: usize) {\n         if row < self.text.len() {\n-            for i in row+1..self.text.len() {\n+            for i in row + 1..self.text.len() {\n                 for j in 0..self.text[i].len() {\n-                    if self.text[row].len() > j &&\n-                       self.text[row][j] == '\\t' &&\n+                    if self.text[row].len() > j && self.text[row][j] == '\\t' &&\n                        self.text[i][j] == ' ' {\n                         self.text[i][j] = '\\t';\n                     }\n@@ -44,7 +43,7 @@ impl StyledBuffer {\n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        //before we render, do a little patch-up work to support tabs\n+        // before we render, do a little patch-up work to support tabs\n         self.copy_tabs(3);\n \n         for (row, row_style) in self.text.iter().zip(&self.styles) {"}, {"sha": "d92a8d375e0d3d76d1ec52560c30f38fc40627c4", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,38 +9,64 @@\n // except according to those terms.\n \n use std::hash::Hasher;\n-use std::collections::hash_map::DefaultHasher;\n+use std::mem;\n+use rustc_data_structures::blake2b;\n+use ich::Fingerprint;\n \n #[derive(Debug)]\n pub struct IchHasher {\n-    // FIXME: this should use SHA1, not DefaultHasher. DefaultHasher is not\n-    // built to avoid collisions.\n-    state: DefaultHasher,\n+    state: blake2b::Blake2bCtx,\n     bytes_hashed: u64,\n }\n \n impl IchHasher {\n     pub fn new() -> IchHasher {\n         IchHasher {\n-            state: DefaultHasher::new(),\n+            state: blake2b::blake2b_new(mem::size_of::<Fingerprint>(), &[]),\n             bytes_hashed: 0\n         }\n     }\n \n     pub fn bytes_hashed(&self) -> u64 {\n         self.bytes_hashed\n     }\n+\n+    pub fn finish(self) -> Fingerprint {\n+        let mut fingerprint = Fingerprint::zero();\n+        blake2b::blake2b_final(self.state, &mut fingerprint.0);\n+        fingerprint\n+    }\n }\n \n impl Hasher for IchHasher {\n-    #[inline]\n     fn finish(&self) -> u64 {\n-        self.state.finish()\n+        bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n \n     #[inline]\n     fn write(&mut self, bytes: &[u8]) {\n-        self.state.write(bytes);\n+        blake2b::blake2b_update(&mut self.state, bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i.to_le()) })\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i.to_le()) })\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i.to_le()) })\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        // always hash as u64, so we don't depend on the size of `usize`\n+        self.write_u64(i as u64);\n+    }\n }"}, {"sha": "3b0b37bb01ce31a57f76890506572b0dbd76d715", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -29,7 +29,7 @@\n \n use syntax::ast;\n use std::cell::RefCell;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n@@ -43,21 +43,22 @@ use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n use self::caching_codemap_view::CachingCodemapView;\n use self::hasher::IchHasher;\n+use ich::Fingerprint;\n \n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n-mod hasher;\n+pub mod hasher;\n \n pub struct IncrementalHashesMap {\n-    hashes: FnvHashMap<DepNode<DefId>, u64>,\n+    hashes: FnvHashMap<DepNode<DefId>, Fingerprint>,\n \n     // These are the metadata hashes for the current crate as they were stored\n     // during the last compilation session. They are only loaded if\n     // -Z query-dep-graph was specified and are needed for auto-tests using\n     // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n     // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, u64>>,\n+    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, Fingerprint>>,\n }\n \n impl IncrementalHashesMap {\n@@ -68,11 +69,12 @@ impl IncrementalHashesMap {\n         }\n     }\n \n-    pub fn insert(&mut self, k: DepNode<DefId>, v: u64) -> Option<u64> {\n+    pub fn insert(&mut self, k: DepNode<DefId>, v: Fingerprint) -> Option<Fingerprint> {\n         self.hashes.insert(k, v)\n     }\n \n-    pub fn iter<'a>(&'a self) -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, u64> {\n+    pub fn iter<'a>(&'a self)\n+                    -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, Fingerprint> {\n         self.hashes.iter()\n     }\n \n@@ -82,9 +84,9 @@ impl IncrementalHashesMap {\n }\n \n impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n-    type Output = u64;\n+    type Output = Fingerprint;\n \n-    fn index(&self, index: &'a DepNode<DefId>) -> &u64 {\n+    fn index(&self, index: &'a DepNode<DefId>) -> &Fingerprint {\n         &self.hashes[index]\n     }\n }\n@@ -141,12 +143,13 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n                                                    &mut self.def_path_hashes,\n                                                    &mut self.codemap,\n                                                    self.hash_spans));\n+        let bytes_hashed = state.bytes_hashed();\n         let item_hash = state.finish();\n         self.hashes.insert(DepNode::Hir(def_id), item_hash);\n         debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n \n         let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n-                           state.bytes_hashed();\n+                           bytes_hashed;\n         self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n "}, {"sha": "005ac3896ce4c19a0ee5edb7271be5946a3d3a17", "filename": "src/librustc_incremental/ich/fingerprint.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fich%2Ffingerprint.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+const FINGERPRINT_LENGTH: usize = 16;\n+\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy)]\n+pub struct Fingerprint(pub [u8; FINGERPRINT_LENGTH]);\n+\n+impl Fingerprint {\n+    #[inline]\n+    pub fn zero() -> Fingerprint {\n+        Fingerprint([0; FINGERPRINT_LENGTH])\n+    }\n+\n+    pub fn from_smaller_hash(hash: u64) -> Fingerprint {\n+        let mut result = Fingerprint::zero();\n+        result.0[0] = (hash >>  0) as u8;\n+        result.0[1] = (hash >>  8) as u8;\n+        result.0[2] = (hash >> 16) as u8;\n+        result.0[3] = (hash >> 24) as u8;\n+        result.0[4] = (hash >> 32) as u8;\n+        result.0[5] = (hash >> 40) as u8;\n+        result.0[6] = (hash >> 48) as u8;\n+        result.0[7] = (hash >> 56) as u8;\n+        result\n+    }\n+\n+    pub fn to_smaller_hash(&self) -> u64 {\n+        ((self.0[0] as u64) <<  0) |\n+        ((self.0[1] as u64) <<  8) |\n+        ((self.0[2] as u64) << 16) |\n+        ((self.0[3] as u64) << 24) |\n+        ((self.0[4] as u64) << 32) |\n+        ((self.0[5] as u64) << 40) |\n+        ((self.0[6] as u64) << 48) |\n+        ((self.0[7] as u64) << 56)\n+    }\n+}\n+\n+impl Encodable for Fingerprint {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        for &byte in &self.0[..] {\n+            s.emit_u8(byte)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Decodable for Fingerprint {\n+    #[inline]\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Fingerprint, D::Error> {\n+        let mut result = Fingerprint([0u8; FINGERPRINT_LENGTH]);\n+        for byte in &mut result.0[..] {\n+            *byte = d.read_u8()?;\n+        }\n+        Ok(result)\n+    }\n+}\n+\n+impl ::std::fmt::Display for Fingerprint {\n+    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        for i in 0 .. self.0.len() {\n+            if i > 0 {\n+                write!(formatter, \"::\")?;\n+            }\n+\n+            write!(formatter, \"{}\", self.0[i])?;\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "8edd04322d7f65302059a6930597008840dcf702", "filename": "src/librustc_incremental/ich/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fich%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::fingerprint::Fingerprint;\n+\n+mod fingerprint;"}, {"sha": "577e50699bffd5310d0011feb112ea830a84fed9", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -45,6 +45,7 @@ const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n mod assert_dep_graph;\n mod calculate_svh;\n mod persist;\n+pub mod ich;\n \n pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::compute_incremental_hashes_map;"}, {"sha": "734ffe6a94412024405564a6685cc5048ede21da", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -14,6 +14,7 @@ use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use std::sync::Arc;\n use rustc_data_structures::fnv::FnvHashMap;\n+use ich::Fingerprint;\n \n use super::directory::DefPathIndex;\n \n@@ -60,7 +61,7 @@ pub struct SerializedHash {\n \n     /// the hash as of previous compilation, computed by code in\n     /// `hash` module\n-    pub hash: u64,\n+    pub hash: Fingerprint,\n }\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n@@ -116,5 +117,5 @@ pub struct SerializedMetadataHash {\n     pub def_index: DefIndex,\n \n     /// the hash itself, computed by `calculate_item_hash`\n-    pub hash: u64,\n+    pub hash: Fingerprint,\n }"}, {"sha": "0418148ffc7df6f374e559b26bd654b316092a68", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -51,6 +51,7 @@ use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n+use ich::Fingerprint;\n \n use {ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA};\n \n@@ -186,8 +187,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  prev_metadata_hashes: &FnvHashMap<DefId, u64>,\n-                                  current_metadata_hashes: &FnvHashMap<DefId, u64>) {\n+                                  prev_metadata_hashes: &FnvHashMap<DefId, Fingerprint>,\n+                                  current_metadata_hashes: &FnvHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n@@ -204,8 +205,8 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &'m FnvHashMap<DefId, u64>,\n-    current_metadata_hashes: &'m FnvHashMap<DefId, u64>,\n+    prev_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n+    current_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n }\n \n impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "e365cbbd3a9a10b417a4301cf77f96eaab44e1f9", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -18,14 +18,15 @@ use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n \n use IncrementalHashesMap;\n+use ich::Fingerprint;\n use super::data::*;\n use super::fs::*;\n use super::file_format;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n-    item_metadata_hashes: FnvHashMap<DefId, u64>,\n+    item_metadata_hashes: FnvHashMap<DefId, Fingerprint>,\n     crate_hashes: FnvHashMap<CrateNum, Svh>,\n }\n \n@@ -50,7 +51,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<Fingerprint> {\n         match *dep_node {\n             DepNode::Krate => {\n                 Some(self.incremental_hashes_map[dep_node])\n@@ -89,7 +90,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn metadata_hash(&mut self, def_id: DefId) -> u64 {\n+    fn metadata_hash(&mut self, def_id: DefId) -> Fingerprint {\n         debug!(\"metadata_hash(def_id={:?})\", def_id);\n \n         assert!(!def_id.is_local());\n@@ -102,14 +103,15 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n \n             // check whether we did not find detailed metadata for this\n             // krate; in that case, we just use the krate's overall hash\n-            if let Some(&hash) = self.crate_hashes.get(&def_id.krate) {\n-                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, hash);\n+            if let Some(&svh) = self.crate_hashes.get(&def_id.krate) {\n+                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, svh);\n \n                 // micro-\"optimization\": avoid a cache miss if we ask\n                 // for metadata from this particular def-id again.\n-                self.item_metadata_hashes.insert(def_id, hash.as_u64());\n+                let fingerprint = svh_to_fingerprint(svh);\n+                self.item_metadata_hashes.insert(def_id, fingerprint);\n \n-                return hash.as_u64();\n+                return fingerprint;\n             }\n \n             // otherwise, load the data and repeat.\n@@ -206,3 +208,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         Ok(())\n     }\n }\n+\n+fn svh_to_fingerprint(svh: Svh) -> Fingerprint {\n+    Fingerprint::from_smaller_hash(svh.as_u64())\n+}"}, {"sha": "1f43e79ace3ae67a6df3f2473770689c06d9a88f", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -22,6 +22,7 @@ use std::fs;\n use std::path::{Path};\n \n use IncrementalHashesMap;\n+use ich::Fingerprint;\n use super::data::*;\n use super::directory::*;\n use super::dirty_clean;\n@@ -315,7 +316,7 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n \n fn load_prev_metadata_hashes(tcx: TyCtxt,\n                              retraced: &RetracedDefIdDirectory,\n-                             output: &mut FnvHashMap<DefId, u64>) {\n+                             output: &mut FnvHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return\n     }"}, {"sha": "fe1d627253f286a16c455bae6450be9dfb5cbdfe", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -14,6 +14,7 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n \n use super::hash::*;\n+use ich::Fingerprint;\n \n /// A data-structure that makes it easy to enumerate the hashable\n /// predecessors of any given dep-node.\n@@ -26,7 +27,7 @@ pub struct Predecessors<'query> {\n \n     // - Keys: some hashable node\n     // - Values: the hash thereof\n-    pub hashes: FnvHashMap<&'query DepNode<DefId>, u64>,\n+    pub hashes: FnvHashMap<&'query DepNode<DefId>, Fingerprint>,\n }\n \n impl<'q> Predecessors<'q> {"}, {"sha": "bc156b0e8913b21a159a1825eb43ecd93858ad82", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -16,20 +16,21 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n-use std::collections::hash_map::DefaultHasher;\n \n use IncrementalHashesMap;\n+use ich::Fingerprint;\n use super::data::*;\n use super::directory::*;\n use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n use super::file_format;\n+use calculate_svh::hasher::IchHasher;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n@@ -185,7 +186,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               preds: &Predecessors,\n                               builder: &mut DefIdDirectoryBuilder,\n-                              current_metadata_hashes: &mut FnvHashMap<DefId, u64>,\n+                              current_metadata_hashes: &mut FnvHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     // For each `MetaData(X)` node where `X` is local, accumulate a\n@@ -233,7 +234,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n         // is the det. hash of the def-path. This is convenient\n         // because we can sort this to get a stable ordering across\n         // compilations, even if the def-ids themselves have changed.\n-        let mut hashes: Vec<(DepNode<u64>, u64)> = sources.iter()\n+        let mut hashes: Vec<(DepNode<u64>, Fingerprint)> = sources.iter()\n             .map(|dep_node| {\n                 let hash_dep_node = dep_node.map_def(|&def_id| Some(def_id_hash(def_id))).unwrap();\n                 let hash = preds.hashes[dep_node];\n@@ -242,7 +243,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n             .collect();\n \n         hashes.sort();\n-        let mut state = DefaultHasher::new();\n+        let mut state = IchHasher::new();\n         hashes.hash(&mut state);\n         let hash = state.finish();\n "}, {"sha": "3b1b2a4cd27e432c13763072f7640cc4e2857d2c", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,6 @@\n //! Used by `rustc` when loading a crate with exported macros.\n \n use std::collections::HashSet;\n-use std::rc::Rc;\n use std::env;\n use std::mem;\n \n@@ -212,7 +211,7 @@ impl<'a> CrateLoader<'a> {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream) {\n-                let derive = Rc::new(CustomDerive::new(expand));\n+                let derive = Box::new(CustomDerive::new(expand));\n                 self.0.push(LoadedMacro {\n                     kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n                     import_site: self.1,"}, {"sha": "e0abe8da82b9c26b9b256a28b6627e772e40be79", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ext::base::{MultiItemModifier, Resolver as SyntaxResolver};\n+use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::hygiene::Mark;\n use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n@@ -195,33 +195,45 @@ impl<'b> Resolver<'b> {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n                 let is_crate_root = self.current_module.parent.is_none();\n+                let import_macro = |this: &mut Self, name, ext, span| {\n+                    let shadowing = this.builtin_macros.insert(name, Rc::new(ext)).is_some();\n+                    if shadowing && expansion != Mark::root() {\n+                        let msg = format!(\"`{}` is already in scope\", name);\n+                        this.session.struct_span_err(span, &msg)\n+                            .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n+                                   existing macros (see RFC 1560)\")\n+                            .emit();\n+                    }\n+                };\n+\n+                let mut custom_derive_crate = false;\n                 for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n                     match loaded_macro.kind {\n                         LoadedMacroKind::Def(mut def) => {\n-                            let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext =\n-                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n-                                if self.builtin_macros.insert(name, ext).is_some() &&\n-                                   expansion != Mark::root() {\n-                                    let msg = format!(\"`{}` is already in scope\", name);\n-                                    self.session.struct_span_err(loaded_macro.import_site, &msg)\n-                                        .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n-                                               existing macros (see RFC 1560)\")\n-                                        .emit();\n-                                }\n-                                self.macro_names.insert(name);\n+                                self.macro_names.insert(def.ident.name);\n+                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+                                import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n                             }\n                             if def.export {\n                                 def.id = self.next_node_id();\n                                 self.exported_macros.push(def);\n                             }\n                         }\n                         LoadedMacroKind::CustomDerive(name, ext) => {\n-                            self.insert_custom_derive(&name, ext, item.span);\n+                            custom_derive_crate = true;\n+                            let ext = SyntaxExtension::CustomDerive(ext);\n+                            import_macro(self, token::intern(&name), ext, loaded_macro.import_site);\n                         }\n                     }\n                 }\n+\n+                if custom_derive_crate && !self.session.features.borrow().proc_macro {\n+                    let issue = feature_gate::GateIssue::Language;\n+                    let msg = \"loading custom derive macro crates is experimentally supported\";\n+                    emit_feature_err(&self.session.parse_sess, \"proc_macro\", item.span, issue, msg);\n+                }\n+\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n@@ -238,6 +250,12 @@ impl<'b> Resolver<'b> {\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n                     self.populate_module_if_necessary(module);\n+                } else if custom_derive_crate {\n+                    // Define an empty module\n+                    let def = Def::Mod(self.definitions.local_def_id(item.id));\n+                    let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n+                    let module = self.arenas.alloc_module(module);\n+                    self.define(parent, name, TypeNS, (module, sp, vis));\n                 }\n             }\n \n@@ -504,17 +522,6 @@ impl<'b> Resolver<'b> {\n \n         false\n     }\n-\n-    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n-        if !self.session.features.borrow().proc_macro {\n-            let sess = &self.session.parse_sess;\n-            let msg = \"loading custom derive macro crates is experimentally supported\";\n-            emit_feature_err(sess, \"proc_macro\", sp, feature_gate::GateIssue::Language, msg);\n-        }\n-        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n-            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n-        }\n-    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {"}, {"sha": "298f41b971d062b08b7ac9c9ac38ed758a3860bd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -53,7 +53,6 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n@@ -1082,7 +1081,6 @@ pub struct Resolver<'a> {\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n-    pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n     builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n@@ -1273,7 +1271,6 @@ impl<'a> Resolver<'a> {\n             new_import_semantics: session.features.borrow().item_like_imports,\n \n             exported_macros: Vec::new(),\n-            derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n             builtin_macros: FnvHashMap(),"}, {"sha": "cf5ea236b3ec7e845eee8d9bcd01c1d5c3b0bf30", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -17,9 +17,9 @@ use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n-use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n+use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n@@ -162,30 +162,22 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        let (name, span) = match invoc.kind {\n-            InvocationKind::Bang { ref mac, .. } => {\n-                let path = &mac.node.path;\n-                if path.segments.len() > 1 || path.global ||\n-                   !path.segments[0].parameters.is_empty() {\n-                    self.session.span_err(path.span,\n-                                          \"expected macro name without module separators\");\n-                    return Err(Determinacy::Determined);\n-                }\n-                (path.segments[0].identifier.name, path.span)\n-            }\n-            InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n-        };\n+        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n+            self.session.span_err(path.span, \"expected macro name without module separators\");\n+            return Err(Determinacy::Determined);\n+        }\n+        let name = path.segments[0].identifier.name;\n \n         let invocation = self.invocations[&scope];\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n         self.resolve_macro_name(invocation.legacy_scope.get(), name, true).ok_or_else(|| {\n             if force {\n-                let mut err =\n-                    self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+                let msg = format!(\"macro undefined: '{}!'\", name);\n+                let mut err = self.session.struct_span_err(path.span, &msg);\n                 self.suggest_macro_name(&name.as_str(), &mut err);\n                 err.emit();\n                 Determinacy::Determined\n@@ -194,10 +186,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         })\n     }\n-\n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>> {\n-        self.derive_modes.get(&ident.name).cloned()\n-    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "e46bdbb5ccf4ae9399151e621a7caacd548afeca", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -130,7 +130,7 @@ pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n                        -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate]),\n+        crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "02aa7c069f9b3d478a2fc1ba5d38ca37fb85115c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1250,12 +1250,27 @@ fn write_metadata(cx: &SharedCrateContext,\n                   reachable_ids: &NodeSet) -> Vec<u8> {\n     use flate;\n \n-    let any_library = cx.sess()\n-                        .crate_types\n-                        .borrow()\n-                        .iter()\n-                        .any(|ty| *ty != config::CrateTypeExecutable);\n-    if !any_library {\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    enum MetadataKind {\n+        None,\n+        Uncompressed,\n+        Compressed\n+    }\n+\n+    let kind = cx.sess().crate_types.borrow().iter().map(|ty| {\n+        match *ty {\n+            config::CrateTypeExecutable |\n+            config::CrateTypeStaticlib |\n+            config::CrateTypeCdylib => MetadataKind::None,\n+\n+            config::CrateTypeRlib => MetadataKind::Uncompressed,\n+\n+            config::CrateTypeDylib |\n+            config::CrateTypeProcMacro => MetadataKind::Compressed,\n+        }\n+    }).max().unwrap();\n+\n+    if kind == MetadataKind::None {\n         return Vec::new();\n     }\n \n@@ -1265,6 +1280,11 @@ fn write_metadata(cx: &SharedCrateContext,\n                                           cx.link_meta(),\n                                           reachable_ids,\n                                           cx.mir_map());\n+    if kind == MetadataKind::Uncompressed {\n+        return metadata;\n+    }\n+\n+    assert!(kind == MetadataKind::Compressed);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n "}, {"sha": "c9ce320988c477e85107ce4d187dfa970329bebd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -2218,10 +2218,12 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n         } else {\n             \"expected\"\n         };\n+        let arguments_plural = if required == 1 { \"\" } else { \"s\" };\n         struct_span_err!(tcx.sess, span, E0243, \"wrong number of type arguments\")\n             .span_label(\n                 span,\n-                &format!(\"{} {} type arguments, found {}\", expected, required, supplied)\n+                &format!(\"{} {} type argument{}, found {}\",\n+                         expected, required, arguments_plural, supplied)\n             )\n             .emit();\n     } else if supplied > accepted {\n@@ -2232,11 +2234,12 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n         } else {\n             format!(\"expected {}\", accepted)\n         };\n+        let arguments_plural = if accepted == 1 { \"\" } else { \"s\" };\n \n         struct_span_err!(tcx.sess, span, E0244, \"wrong number of type arguments\")\n             .span_label(\n                 span,\n-                &format!(\"{} type arguments, found {}\", expected, supplied)\n+                &format!(\"{} type argument{}, found {}\", expected, arguments_plural, supplied)\n             )\n             .emit();\n     }"}, {"sha": "5e2b49bac1b2fb6619a843cbc2038d4369ad65b7", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 157, "deletions": 18, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -71,7 +71,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n-    self_type_did: DefId) -> Result<(), ()>\n+    self_type_did: DefId)\n+    -> Result<(), ()>\n {\n     let tcx = ccx.tcx;\n     let drop_impl_node_id = tcx.map.as_local_node_id(drop_impl_did).unwrap();\n@@ -123,7 +124,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n-    self_to_impl_substs: &Substs<'tcx>) -> Result<(), ()> {\n+    self_to_impl_substs: &Substs<'tcx>)\n+    -> Result<(), ()>\n+{\n \n     // Here is an example, analogous to that from\n     // `compare_impl_method`.\n@@ -350,7 +353,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     cx: &mut DropckContext<'a, 'b, 'gcx, 'tcx>,\n     context: TypeContext,\n     ty: Ty<'tcx>,\n-    depth: usize) -> Result<(), Error<'tcx>>\n+    depth: usize)\n+    -> Result<(), Error<'tcx>>\n {\n     let tcx = cx.rcx.tcx;\n     // Issue #22443: Watch out for overflow. While we are careful to\n@@ -402,16 +406,27 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     // unbounded type parameter `T`, we must resume the recursive\n     // analysis on `T` (since it would be ignored by\n     // type_must_outlive).\n-    if has_dtor_of_interest(tcx, ty) {\n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}ty: {} - is a dtorck type!\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               ty);\n-\n-        cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                 ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n-\n-        return Ok(());\n+    let dropck_kind = has_dtor_of_interest(tcx, ty);\n+    debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+            ty: {:?} dropck_kind: {:?}\", ty, dropck_kind);\n+    match dropck_kind {\n+        DropckKind::NoBorrowedDataAccessedInMyDtor => {\n+            // The maximally blind attribute.\n+        }\n+        DropckKind::BorrowedDataMustStrictlyOutliveSelf => {\n+            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n+                                     ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n+            return Ok(());\n+        }\n+        DropckKind::RevisedSelf(revised_ty) => {\n+            cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n+                                     revised_ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n+            // Do not return early from this case; we want\n+            // to recursively process the internal structure of Self\n+            // (because even though the Drop for Self has been asserted\n+            //  safe, the types instantiated for the generics of Self\n+            //  may themselves carry dropck constraints.)\n+        }\n     }\n \n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n@@ -492,16 +507,140 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum DropckKind<'tcx> {\n+    /// The \"safe\" kind; i.e. conservatively assume any borrow\n+    /// accessed by dtor, and therefore such data must strictly\n+    /// outlive self.\n+    ///\n+    /// Equivalent to RevisedTy with no change to the self type.\n+    BorrowedDataMustStrictlyOutliveSelf,\n+\n+    /// The nearly completely-unsafe kind.\n+    ///\n+    /// Equivalent to RevisedSelf with *all* parameters remapped to ()\n+    /// (maybe...?)\n+    NoBorrowedDataAccessedInMyDtor,\n+\n+    /// Assume all borrowed data access by dtor occurs as if Self has the\n+    /// type carried by this variant. In practice this means that some\n+    /// of the type parameters are remapped to `()` (and some lifetime\n+    /// parameters remapped to `'static`), because the developer has asserted\n+    /// that the destructor will not access their contents.\n+    RevisedSelf(Ty<'tcx>),\n+}\n+\n+/// Returns the classification of what kind of check should be applied\n+/// to `ty`, which may include a revised type where some of the type\n+/// parameters are re-mapped to `()` to reflect the destructor's\n+/// \"purity\" with respect to their actual contents.\n fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        ty: Ty<'tcx>) -> bool {\n+                                        ty: Ty<'tcx>)\n+                                        -> DropckKind<'tcx> {\n     match ty.sty {\n-        ty::TyAdt(def, _) => {\n-            def.is_dtorck(tcx)\n+        ty::TyAdt(adt_def, substs) => {\n+            if !adt_def.is_dtorck(tcx) {\n+                return DropckKind::NoBorrowedDataAccessedInMyDtor;\n+            }\n+\n+            // Find the `impl<..> Drop for _` to inspect any\n+            // attributes attached to the impl's generics.\n+            let dtor_method = adt_def.destructor()\n+                .expect(\"dtorck type without destructor impossible\");\n+            let method = tcx.impl_or_trait_item(dtor_method);\n+            let impl_id: DefId = method.container().id();\n+            let revised_ty = revise_self_ty(tcx, adt_def, impl_id, substs);\n+            return DropckKind::RevisedSelf(revised_ty);\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n-            true\n+            return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n         },\n-        _ => false\n+        _ => {\n+            return DropckKind::NoBorrowedDataAccessedInMyDtor;\n+        }\n     }\n }\n+\n+// Constructs new Ty just like the type defined by `adt_def` coupled\n+// with `substs`, except each type and lifetime parameter marked as\n+// `#[may_dangle]` in the Drop impl (identified by `impl_id`) is\n+// respectively mapped to `()` or `'static`.\n+//\n+// For example: If the `adt_def` maps to:\n+//\n+//   enum Foo<'a, X, Y> { ... }\n+//\n+// and the `impl_id` maps to:\n+//\n+//   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n+//\n+// then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n+fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  adt_def: ty::AdtDef<'tcx>,\n+                                  impl_id: DefId,\n+                                  substs: &Substs<'tcx>)\n+                                  -> Ty<'tcx> {\n+    // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n+    let impl_bindings = tcx.lookup_generics(impl_id);\n+\n+    // Get Substs attached to Self on `impl Drop`; process in parallel\n+    // with `substs`, replacing dangling entries as appropriate.\n+    let self_substs = {\n+        let impl_self_ty: Ty<'tcx> = tcx.lookup_item_type(impl_id).ty;\n+        if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n+            assert_eq!(adt_def, self_adt_def);\n+            self_substs\n+        } else {\n+            bug!(\"Self in `impl Drop for _` must be an Adt.\");\n+        }\n+    };\n+\n+    // Walk `substs` + `self_substs`, build new substs appropriate for\n+    // `adt_def`; each non-dangling param reuses entry from `substs`.\n+    //\n+    // Note: The manner we map from a right-hand side (i.e. Region or\n+    // Ty) for a given `def` to generic parameter associated with that\n+    // right-hand side is tightly coupled to `Drop` impl constraints.\n+    //\n+    // E.g. we know such a Ty must be `TyParam`, because a destructor\n+    // for `struct Foo<X>` is defined via `impl<Y> Drop for Foo<Y>`,\n+    // and never by (for example) `impl<Z> Drop for Foo<Vec<Z>>`.\n+    let substs = Substs::for_item(\n+        tcx,\n+        adt_def.did,\n+        |def, _| {\n+            let r_orig = substs.region_for_def(def);\n+            let impl_self_orig = self_substs.region_for_def(def);\n+            let r = if let ty::Region::ReEarlyBound(ref ebr) = *impl_self_orig {\n+                if impl_bindings.region_param(ebr).pure_wrt_drop {\n+                    tcx.mk_region(ty::ReStatic)\n+                } else {\n+                    r_orig\n+                }\n+            } else {\n+                bug!(\"substs for an impl must map regions to ReEarlyBound\");\n+            };\n+            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} to {:?}\",\n+                   def, r_orig, r);\n+            r\n+        },\n+        |def, _| {\n+            let t_orig = substs.type_for_def(def);\n+            let impl_self_orig = self_substs.type_for_def(def);\n+            let t = if let ty::TypeVariants::TyParam(ref pt) = impl_self_orig.sty {\n+                if impl_bindings.type_param(pt).pure_wrt_drop {\n+                    tcx.mk_nil()\n+                } else {\n+                    t_orig\n+                }\n+            } else {\n+                bug!(\"substs for an impl must map types to TyParam\");\n+            };\n+            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} {:?} to {:?} {:?}\",\n+                   def, t_orig, t_orig.sty, t, t.sty);\n+            t\n+        });\n+\n+    return tcx.mk_adt(adt_def, &substs);\n+}"}, {"sha": "cca6c884306725c1342e72df83ca5df3b75e4363", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -13,7 +13,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::hir::intravisit;\n-use rustc::hir;\n+use rustc::hir::{self, Unsafety};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n@@ -27,6 +27,7 @@ struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self,\n                                 item: &'v hir::Item,\n+                                impl_generics: Option<&hir::Generics>,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n         match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n@@ -47,33 +48,44 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n \n             Some(trait_ref) => {\n                 let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n-                match (trait_def.unsafety, unsafety, polarity) {\n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n+                let unsafe_attr = impl_generics.and_then(|g| g.carries_unsafe_attr());\n+                match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n+                    (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0198,\n                                   \"negative implementations are not unsafe\");\n                     }\n \n-                    (hir::Unsafety::Normal, hir::Unsafety::Unsafe, _) => {\n+                    (Unsafety::Normal, None, Unsafety::Unsafe, _) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                    (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Negative) |\n-                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n-                    (hir::Unsafety::Normal, hir::Unsafety::Normal, _) => {\n+                    (Unsafety::Normal, Some(g), Unsafety::Normal, hir::ImplPolarity::Positive) =>\n+                    {\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0569,\n+                                  \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n+                                  g.attr_name());\n+                    }\n+\n+                    (_, _, Unsafety::Normal, hir::ImplPolarity::Negative) |\n+                    (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                    (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                    (Unsafety::Normal, None, Unsafety::Normal, _) => {\n                         // OK\n                     }\n                 }\n@@ -86,10 +98,10 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n-                self.check_unsafety_coherence(item, unsafety, hir::ImplPolarity::Positive);\n+                self.check_unsafety_coherence(item, None, unsafety, hir::ImplPolarity::Positive);\n             }\n-            hir::ItemImpl(unsafety, polarity, ..) => {\n-                self.check_unsafety_coherence(item, unsafety, polarity);\n+            hir::ItemImpl(unsafety, polarity, ref generics, ..) => {\n+                self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n             }\n             _ => {}\n         }"}, {"sha": "6e47f4ed8c6be5377805af332ded522cef221672", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1482,6 +1482,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             default_def_id: tcx.map.local_def_id(parent),\n                             default: None,\n                             object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                            pure_wrt_drop: false,\n                         };\n                         tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n                         opt_self = Some(def);\n@@ -1526,7 +1527,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 def_id: tcx.map.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n                     ast_region_to_region(tcx, l)\n-                }).collect()\n+                }).collect(),\n+                pure_wrt_drop: l.pure_wrt_drop,\n             }\n         }).collect::<Vec<_>>();\n \n@@ -1926,6 +1928,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n+        pure_wrt_drop: param.pure_wrt_drop,\n     };\n \n     if def.name == keywords::SelfType.name() {"}, {"sha": "16f915c0011cb1dd28f02501bfa52a89deff4fbf", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -2819,6 +2819,26 @@ not a distinct static type. Likewise, it's not legal to attempt to\n behavior for specific enum variants.\n \"##,\n \n+E0569: r##\"\n+If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n+that impl must be declared as an `unsafe impl. For example:\n+\n+```compile_fail,E0569\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+struct Foo<X>(X);\n+impl<#[may_dangle] X> Drop for Foo<X> {\n+    fn drop(&mut self) { }\n+}\n+```\n+\n+In this example, we are asserting that the destructor for `Foo` will not\n+access any data of type `X`, and require this assertion to be true for\n+overall safety in our program. The compiler does not currently attempt to\n+verify this assertion; therefore we must tag this `impl` as unsafe.\n+\"##,\n+\n E0318: r##\"\n Default impls for a trait must be located in the same crate where the trait was\n defined. For more information see the [opt-in builtin traits RFC](https://github"}, {"sha": "504b3a76bd295be5152cc6a4c0adf1cd9e0e7f46", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -425,6 +425,9 @@ pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_set::HashSet;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::range;\n+\n mod hash;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "df5741d00a2c10b08dce46127377e6a8cebf2cf7", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -83,6 +83,7 @@ pub struct Metadata(fs_imp::FileAttr);\n ///\n /// [`io::Result`]: ../io/type.Result.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct ReadDir(fs_imp::ReadDir);\n \n /// Entries returned by the [`ReadDir`] iterator."}, {"sha": "71e0ab0388f5bbdd0cf77703d273750ddb491b84", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -224,6 +224,7 @@\n #![feature(char_internals)]\n #![feature(collections)]\n #![feature(collections_bound)]\n+#![feature(collections_range)]\n #![feature(compiler_builtins_lib)]\n #![feature(const_fn)]\n #![feature(core_float)]"}, {"sha": "b77008676b16f9741eb5c2e50d5273450143321b", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -193,6 +193,14 @@ impl FromInner<u32> for FilePermissions {\n     }\n }\n \n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n+        // Thus the result will be e g 'ReadDir(\"/home\")'\n+        fmt::Debug::fmt(&*self.root, f)\n+    }\n+}\n+\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n "}, {"sha": "98fd15f863ba10ad0c18a1f404d00db98a6e88b7", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -81,6 +81,14 @@ pub struct FilePermissions { attrs: c::DWORD }\n \n pub struct DirBuilder;\n \n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n+        // Thus the result will be e g 'ReadDir(\"C:\\\")'\n+        fmt::Debug::fmt(&*self.root, f)\n+    }\n+}\n+\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {"}, {"sha": "01f81e5e2de17312f56df60d53cbd7e1e7f2657d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use attr::HasAttrs;\n-use feature_gate::{emit_feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n+use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use {fold, attr};\n use ast;\n use codemap::{Spanned, respan};\n@@ -157,11 +157,15 @@ impl<'a> StripUnconfigured<'a> {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n-                emit_feature_err(&self.sess,\n-                                 \"stmt_expr_attributes\",\n-                                 attr.span,\n-                                 GateIssue::Language,\n-                                 EXPLAIN_STMT_ATTR_SYNTAX);\n+                let mut err = feature_err(&self.sess,\n+                                          \"stmt_expr_attributes\",\n+                                          attr.span,\n+                                          GateIssue::Language,\n+                                          EXPLAIN_STMT_ATTR_SYNTAX);\n+                if attr.node.is_sugared_doc {\n+                    err.help(\"`///` is for documentation comments. For a plain comment, use `//`.\");\n+                }\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "f3272960e8313cfc6d7649e8fe01c2039a9e4770", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -15,7 +15,7 @@ use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n-use ext::expand::{self, Invocation, Expansion};\n+use ext::expand::{self, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n use parse::{self, parser};\n@@ -508,6 +508,8 @@ pub enum SyntaxExtension {\n     /// the block.\n     ///\n     IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n+\n+    CustomDerive(Box<MultiItemModifier>),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -522,9 +524,8 @@ pub trait Resolver {\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -545,8 +546,7 @@ impl Resolver for DummyResolver {\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n-    fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n-    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation, _force: bool)\n+    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n@@ -617,11 +617,11 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n-        parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n+        parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg().clone())\n     }\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n-    pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n+    pub fn cfg(&self) -> &ast::CrateConfig { &self.cfg }\n     pub fn call_site(&self) -> Span {\n         self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n             Some(expn_info) => expn_info.call_site,"}, {"sha": "6aeb46fd52276126f5d91aca2812a36be174128e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -240,7 +240,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let ext = match self.cx.resolver.resolve_invoc(scope, &invoc, force) {\n+            let resolution = match invoc.kind {\n+                InvocationKind::Bang { ref mac, .. } => {\n+                    self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n+                }\n+                InvocationKind::Attr { ref attr, .. } => {\n+                    let ident = ast::Ident::with_empty_ctxt(intern(&*attr.name()));\n+                    let path = ast::Path::from_ident(attr.span, ident);\n+                    self.cx.resolver.resolve_macro(scope, &path, force)\n+                }\n+            };\n+            let ext = match resolution {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n@@ -354,7 +364,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n                 self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n-            _ => unreachable!(),\n+            SyntaxExtension::CustomDerive(_) => {\n+                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n+                kind.dummy(attr.span)\n+            }\n+            _ => {\n+                let msg = &format!(\"macro `{}` may not be used in attributes\", name);\n+                self.cx.span_err(attr.span, &msg);\n+                kind.dummy(attr.span)\n+            }\n         }\n     }\n \n@@ -429,6 +447,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n \n+            SyntaxExtension::CustomDerive(..) => {\n+                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n+                return kind.dummy(span);\n+            }\n+\n             SyntaxExtension::ProcMacro(ref expandfun) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg ="}, {"sha": "7f002d281667980fb516ad868f41934a0cbfda4c", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -331,31 +331,31 @@ pub mod rt {\n             panictry!(parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg(),\n+                self.cfg().clone(),\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> ast::Stmt {\n             panictry!(parse::parse_stmt_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg(),\n+                self.cfg().clone(),\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_expr(&self, s: String) -> P<ast::Expr> {\n             panictry!(parse::parse_expr_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg(),\n+                self.cfg().clone(),\n                 self.parse_sess()))\n         }\n \n         fn parse_tts(&self, s: String) -> Vec<TokenTree> {\n             panictry!(parse::parse_tts_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg(),\n+                self.cfg().clone(),\n                 self.parse_sess()))\n         }\n     }\n@@ -924,14 +924,18 @@ fn expand_parse_call(cx: &ExtCtxt,\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"cfg\"), Vec::new());\n \n+    let cfg_clone_call = || cx.expr_method_call(\n+        sp, cfg_call(),\n+        id_ext(\"clone\"), Vec::new());\n+\n     let parse_sess_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"parse_sess\"), Vec::new());\n \n     let new_parser_call =\n         cx.expr_call(sp,\n                      cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     vec!(parse_sess_call(), cfg_call(), tts_expr));\n+                     vec!(parse_sess_call(), cfg_clone_call(), tts_expr));\n \n     let path = vec![id_ext(\"syntax\"), id_ext(\"ext\"), id_ext(\"quote\"), id_ext(parse_method)];\n     let mut args = vec![cx.expr_mut_addr_of(sp, new_parser_call)];"}, {"sha": "30dc1823b370a15df4288e45c5814269640dea5b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -94,7 +94,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n     // The file will be added to the code map by the parser\n     let p =\n         parse::new_sub_parser_from_file(cx.parse_sess(),\n-                                        cx.cfg(),\n+                                        cx.cfg().clone(),\n                                         &res_rel_file(cx,\n                                                       sp,\n                                                       Path::new(&file)),"}, {"sha": "ef2e466a04398ae6f47751738f7d9a5b97940394", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -272,7 +272,7 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n }\n \n pub fn parse(sess: &ParseSess,\n-             cfg: ast::CrateConfig,\n+             cfg: &ast::CrateConfig,\n              mut rdr: TtReader,\n              ms: &[TokenTree])\n              -> NamedParseResult {\n@@ -476,24 +476,21 @@ pub fn parse(sess: &ParseSess,\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let mut rust_parser = Parser::new(sess, cfg.clone(), Box::new(rdr.clone()));\n-\n-                let mut ei = bb_eis.pop().unwrap();\n-                match ei.top_elts.get_tt(ei.idx) {\n-                    TokenTree::Token(span, MatchNt(_, ident)) => {\n+                rdr.next_tok = {\n+                    let mut rust_parser = Parser::new(sess, cfg.clone(), Box::new(&mut rdr));\n+                    let mut ei = bb_eis.pop().unwrap();\n+                    if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n                         let match_cur = ei.match_cur;\n                         (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                             parse_nt(&mut rust_parser, span, &ident.name.as_str()))));\n                         ei.idx += 1;\n                         ei.match_cur += 1;\n+                    } else {\n+                        unreachable!()\n                     }\n-                    _ => panic!()\n-                }\n-                cur_eis.push(ei);\n-\n-                for _ in 0..rust_parser.tokens_consumed {\n-                    let _ = rdr.next_token();\n-                }\n+                    cur_eis.push(ei);\n+                    Some(TokenAndSpan { tok: rust_parser.token, sp: rust_parser.span })\n+                };\n             }\n         }\n "}, {"sha": "a74d335d6046da3211ca0e4e0d3223cad5a06d27", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -120,7 +120,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            Some(named_matches),\n                                            imported_from,\n                                            rhs);\n-                let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n+                let mut p = Parser::new(cx.parse_sess(), cx.cfg().clone(), Box::new(trncbr));\n                 p.directory = cx.current_expansion.module.directory.clone();\n                 p.restrictions = match cx.current_expansion.no_noninline_mod {\n                     true => Restrictions::NO_NONINLINE_MOD,\n@@ -225,7 +225,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&sess.span_diagnostic, None, None, def.body.clone());\n \n-    let argument_map = match parse(sess, Vec::new(), arg_reader, &argument_gram) {\n+    let argument_map = match parse(sess, &Vec::new(), arg_reader, &argument_gram) {\n         Success(m) => m,\n         Failure(sp, str) | Error(sp, str) => {\n             panic!(sess.span_diagnostic.span_fatal(sp.substitute_dummy(def.span), &str));"}, {"sha": "205c709d6cb40deb67134614e56d47a901e215fa", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -48,6 +48,7 @@ pub struct TtReader<'a> {\n     /* cached: */\n     pub cur_tok: Token,\n     pub cur_span: Span,\n+    pub next_tok: Option<TokenAndSpan>,\n     /// Transform doc comments. Only useful in macro invocations\n     pub desugar_doc_comments: bool,\n     pub fatal_errs: Vec<DiagnosticBuilder<'a>>,\n@@ -100,6 +101,7 @@ pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n         /* dummy values, never read: */\n         cur_tok: token::Eof,\n         cur_span: DUMMY_SP,\n+        next_tok: None,\n         fatal_errs: Vec::new(),\n     };\n     tt_next_token(&mut r); /* get cur_tok and cur_span set up */\n@@ -178,6 +180,9 @@ fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n /// Return the next token from the TtReader.\n /// EFFECT: advances the reader's token field\n pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n+    if let Some(tok) = r.next_tok.take() {\n+        return tok;\n+    }\n     // FIXME(pcwalton): Bad copy?\n     let ret_val = TokenAndSpan {\n         tok: r.cur_tok.clone(),"}, {"sha": "954fe330b54cae28613e5478a1896bde0b1239ad", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -30,7 +30,7 @@ use ast::{self, NodeId, PatKind};\n use attr;\n use codemap::{CodeMap, Spanned};\n use syntax_pos::Span;\n-use errors::Handler;\n+use errors::{DiagnosticBuilder, Handler};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use parse::token::InternedString;\n@@ -167,6 +167,9 @@ declare_features! (\n     // RFC 1238\n     (active, dropck_parametricity, \"1.3.0\", Some(28498)),\n \n+    // Allows using the may_dangle attribute; RFC 1327\n+    (active, dropck_eyepatch, \"1.10.0\", Some(34761)),\n+\n     // Allows the use of custom attributes; RFC 572\n     (active, custom_attribute, \"1.0.0\", Some(29642)),\n \n@@ -616,6 +619,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n            \"unsafe_destructor_blind_to_params has unstable semantics \\\n             and may be removed in the future\",\n            cfg_fn!(dropck_parametricity))),\n+    (\"may_dangle\",\n+     Normal,\n+     Gated(\"dropck_eyepatch\",\n+           \"may_dangle has unstable semantics and may be removed in the future\",\n+           cfg_fn!(dropck_eyepatch))),\n     (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\",\n                                   cfg_fn!(unwind_attributes))),\n \n@@ -792,6 +800,11 @@ pub enum GateIssue {\n \n pub fn emit_feature_err(sess: &ParseSess, feature: &str, span: Span, issue: GateIssue,\n                         explain: &str) {\n+    feature_err(sess, feature, span, issue, explain).emit();\n+}\n+\n+pub fn feature_err<'a>(sess: &'a ParseSess, feature: &str, span: Span, issue: GateIssue,\n+                   explain: &str) -> DiagnosticBuilder<'a> {\n     let diag = &sess.span_diagnostic;\n \n     let issue = match issue {\n@@ -812,7 +825,7 @@ pub fn emit_feature_err(sess: &ParseSess, feature: &str, span: Span, issue: Gate\n                           feature));\n     }\n \n-    err.emit();\n+    err\n }\n \n const EXPLAIN_BOX_SYNTAX: &'static str =\n@@ -1317,15 +1330,12 @@ impl UnstableFeatures {\n     pub fn from_environment() -> UnstableFeatures {\n         // Whether this is a feature-staged build, i.e. on the beta or stable channel\n         let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n-        // The secret key needed to get through the rustc build itself by\n-        // subverting the unstable features lints\n-        let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n-        // The matching key to the above, only known by the build system\n-        let bootstrap_provided_key = env::var(\"RUSTC_BOOTSTRAP_KEY\").ok();\n-        match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n-            (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n-            (true, _, _) => UnstableFeatures::Disallow,\n-            (false, _, _) => UnstableFeatures::Allow\n+        // Whether we should enable unstable features for bootstrapping\n+        let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+        match (disable_unstable_features, bootstrap) {\n+            (_, true) => UnstableFeatures::Cheat,\n+            (true, _) => UnstableFeatures::Disallow,\n+            (false, _) => UnstableFeatures::Allow\n         }\n     }\n "}, {"sha": "ba83a55ea7937c1321baf60568cbf729b24b9b91", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -24,7 +24,7 @@ use str::char_at;\n use std::io::Read;\n use std::usize;\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum CommentStyle {\n     /// No code on either side of each line of the comment\n     Isolated,\n@@ -155,14 +155,13 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n \n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader, comments: &mut Vec<Comment>) {\n     while is_pattern_whitespace(rdr.ch) && !rdr.is_eof() {\n-        if rdr.col == CharPos(0) && rdr.ch_is('\\n') {\n+        if rdr.ch_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         rdr.bump();\n     }\n }\n \n-\n fn read_shebang_comment(rdr: &mut StringReader,\n                         code_to_the_left: bool,\n                         comments: &mut Vec<Comment>) {\n@@ -317,14 +316,22 @@ fn read_block_comment(rdr: &mut StringReader,\n }\n \n \n-fn consume_comment(rdr: &mut StringReader, code_to_the_left: bool, comments: &mut Vec<Comment>) {\n+fn consume_comment(rdr: &mut StringReader,\n+                   comments: &mut Vec<Comment>,\n+                   code_to_the_left: &mut bool,\n+                   anything_to_the_left: &mut bool) {\n     debug!(\">>> consume comment\");\n     if rdr.ch_is('/') && rdr.nextch_is('/') {\n-        read_line_comments(rdr, code_to_the_left, comments);\n+        read_line_comments(rdr, *code_to_the_left, comments);\n+        *code_to_the_left = false;\n+        *anything_to_the_left = false;\n     } else if rdr.ch_is('/') && rdr.nextch_is('*') {\n-        read_block_comment(rdr, code_to_the_left, comments);\n+        read_block_comment(rdr, *code_to_the_left, comments);\n+        *anything_to_the_left = true;\n     } else if rdr.ch_is('#') && rdr.nextch_is('!') {\n-        read_shebang_comment(rdr, code_to_the_left, comments);\n+        read_shebang_comment(rdr, *code_to_the_left, comments);\n+        *code_to_the_left = false;\n+        *anything_to_the_left = false;\n     } else {\n         panic!();\n     }\n@@ -352,23 +359,29 @@ pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n \n     let mut comments: Vec<Comment> = Vec::new();\n     let mut literals: Vec<Literal> = Vec::new();\n-    let mut first_read: bool = true;\n+    let mut code_to_the_left = false; // Only code\n+    let mut anything_to_the_left = false; // Code or comments\n     while !rdr.is_eof() {\n         loop {\n-            let mut code_to_the_left = !first_read;\n+            // Eat all the whitespace and count blank lines.\n             rdr.consume_non_eol_whitespace();\n             if rdr.ch_is('\\n') {\n-                code_to_the_left = false;\n+                if anything_to_the_left {\n+                    rdr.bump(); // The line is not blank, do not count.\n+                }\n                 consume_whitespace_counting_blank_lines(&mut rdr, &mut comments);\n+                code_to_the_left = false;\n+                anything_to_the_left = false;\n             }\n-            while rdr.peeking_at_comment() {\n-                consume_comment(&mut rdr, code_to_the_left, &mut comments);\n-                consume_whitespace_counting_blank_lines(&mut rdr, &mut comments);\n+            // Eat one comment group\n+            if rdr.peeking_at_comment() {\n+                consume_comment(&mut rdr, &mut comments,\n+                                &mut code_to_the_left, &mut anything_to_the_left);\n+            } else {\n+                break\n             }\n-            break;\n         }\n \n-\n         let bstart = rdr.pos;\n         rdr.next_token();\n         // discard, and look ahead; we're working with internal state\n@@ -384,7 +397,8 @@ pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n         } else {\n             debug!(\"tok: {}\", pprust::token_to_string(&tok));\n         }\n-        first_read = false;\n+        code_to_the_left = true;\n+        anything_to_the_left = true;\n     }\n \n     (comments, literals)"}, {"sha": "e62d0d925cd4fa715b5e09e3d4edb979c50cc9aa", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -144,7 +144,7 @@ impl<'a> Reader for StringReader<'a> {\n \n impl<'a> Reader for TtReader<'a> {\n     fn is_eof(&self) -> bool {\n-        self.cur_tok == token::Eof\n+        self.peek().tok == token::Eof\n     }\n     fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n         assert!(self.fatal_errs.is_empty());\n@@ -165,10 +165,31 @@ impl<'a> Reader for TtReader<'a> {\n         self.fatal_errs.clear();\n     }\n     fn peek(&self) -> TokenAndSpan {\n-        TokenAndSpan {\n+        self.next_tok.clone().unwrap_or(TokenAndSpan {\n             tok: self.cur_tok.clone(),\n             sp: self.cur_span,\n-        }\n+        })\n+    }\n+}\n+\n+impl<'a, 'b> Reader for &'b mut TtReader<'a> {\n+    fn is_eof(&self) -> bool {\n+        (**self).is_eof()\n+    }\n+    fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n+        (**self).try_next_token()\n+    }\n+    fn fatal(&self, m: &str) -> FatalError {\n+        (**self).fatal(m)\n+    }\n+    fn err(&self, m: &str) {\n+        (**self).err(m)\n+    }\n+    fn emit_fatal_errors(&mut self) {\n+        (**self).emit_fatal_errors()\n+    }\n+    fn peek(&self) -> TokenAndSpan {\n+        (**self).peek()\n     }\n }\n "}, {"sha": "89834da28219cab33f7e5f527e46a2f4722f5c4a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -545,15 +545,12 @@ pub trait PrintState<'a> {\n     }\n \n     fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n-        loop {\n-            match self.next_comment() {\n-                Some(ref cmnt) => {\n-                    if (*cmnt).pos < pos {\n-                        try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit().cur_cmnt += 1;\n-                    } else { break; }\n-                }\n-                _ => break\n+        while let Some(ref cmnt) = self.next_comment() {\n+            if cmnt.pos < pos {\n+                try!(self.print_comment(cmnt));\n+                self.cur_cmnt_and_lit().cur_cmnt += 1;\n+            } else {\n+                break\n             }\n         }\n         Ok(())\n@@ -581,7 +578,9 @@ pub trait PrintState<'a> {\n                 Ok(())\n             }\n             comments::Trailing => {\n-                try!(word(self.writer(), \" \"));\n+                if !self.is_bol() {\n+                    try!(word(self.writer(), \" \"));\n+                }\n                 if cmnt.lines.len() == 1 {\n                     try!(word(self.writer(), &cmnt.lines[0]));\n                     hardbreak(self.writer())\n@@ -1361,6 +1360,7 @@ impl<'a> State<'a> {\n                 if comma {\n                     try!(self.word_space(\",\"))\n                 }\n+                try!(self.print_outer_attributes_inline(&lifetime_def.attrs));\n                 try!(self.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds));\n                 comma = true;\n             }\n@@ -1715,6 +1715,7 @@ impl<'a> State<'a> {\n         for (i, st) in blk.stmts.iter().enumerate() {\n             match st.node {\n                 ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n+                    try!(self.maybe_print_comment(st.span.lo));\n                     try!(self.space_if_not_bol());\n                     try!(self.print_expr_outer_attr_style(&expr, false));\n                     try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n@@ -2604,6 +2605,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.cbox(INDENT_UNIT));\n         try!(self.ibox(0));\n+        try!(self.maybe_print_comment(arm.pats[0].span.lo));\n         try!(self.print_outer_attributes(&arm.attrs));\n         let mut first = true;\n         for p in &arm.pats {\n@@ -2803,6 +2805,7 @@ impl<'a> State<'a> {\n         try!(self.commasep(Inconsistent, &ints[..], |s, &idx| {\n             if idx < generics.lifetimes.len() {\n                 let lifetime_def = &generics.lifetimes[idx];\n+                try!(s.print_outer_attributes_inline(&lifetime_def.attrs));\n                 s.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n@@ -2816,6 +2819,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> io::Result<()> {\n+        try!(self.print_outer_attributes_inline(&param.attrs));\n         try!(self.print_ident(param.ident));\n         try!(self.print_bounds(\":\", &param.bounds));\n         match param.default {\n@@ -3007,15 +3011,11 @@ impl<'a> State<'a> {\n             _ => return Ok(())\n         };\n         if let Some(ref cmnt) = self.next_comment() {\n-            if (*cmnt).style != comments::Trailing { return Ok(()) }\n+            if cmnt.style != comments::Trailing { return Ok(()) }\n             let span_line = cm.lookup_char_pos(span.hi);\n-            let comment_line = cm.lookup_char_pos((*cmnt).pos);\n-            let mut next = (*cmnt).pos + BytePos(1);\n-            if let Some(p) = next_pos {\n-                next = p;\n-            }\n-            if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n-               span_line.line == comment_line.line {\n+            let comment_line = cm.lookup_char_pos(cmnt.pos);\n+            let next = next_pos.unwrap_or(cmnt.pos + BytePos(1));\n+            if span.hi < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n                 self.print_comment(cmnt)?;\n                 self.cur_cmnt_and_lit.cur_cmnt += 1;\n             }"}, {"sha": "1c97099d387f98ba9fdf331f38c8139e90073d3c", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -107,7 +107,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 if p2.token != token::Eof {\n                     let mut extra_tts = panictry!(p2.parse_all_token_trees());\n                     extra_tts.extend(tts[first_colon..].iter().cloned());\n-                    p = parse::tts_to_parser(cx.parse_sess, extra_tts, cx.cfg());\n+                    p = parse::tts_to_parser(cx.parse_sess, extra_tts, cx.cfg().clone());\n                 }\n \n                 asm = s;"}, {"sha": "07401d59a15db2678321832b809035b20808756d", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -12,7 +12,7 @@\n \n use syntax::ast::{self, MetaItem};\n use syntax::attr::HasAttrs;\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -158,10 +158,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         let tword = titem.word().unwrap();\n         let tname = tword.name();\n \n-        let derive_mode = ast::Ident::with_empty_ctxt(intern(&tname));\n-        let derive_mode = cx.resolver.resolve_derive_mode(derive_mode);\n-        if is_builtin_trait(&tname) || derive_mode.is_some() {\n-            return true\n+        if is_builtin_trait(&tname) || {\n+            let derive_mode =\n+                ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(intern(&tname)));\n+            cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n+                if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n+            }).unwrap_or(false)\n+        } {\n+            return true;\n         }\n \n         if !cx.ecfg.enable_custom_derive() {\n@@ -216,7 +220,9 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n         let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n-        let ext = cx.resolver.resolve_derive_mode(tname).unwrap();\n+        let path = ast::Path::from_ident(titem.span, tname);\n+        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n+\n         traits.remove(i);\n         if traits.len() > 0 {\n             item = item.map(|mut i| {\n@@ -232,7 +238,11 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  intern_and_get_ident(\"derive\"),\n                                  vec![titem]);\n         let item = Annotatable::Item(item);\n-        return ext.expand(cx, mitem.span, &mitem, item)\n+        if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n+            return ext.expand(cx, mitem.span, &mitem, item);\n+        } else {\n+            unreachable!()\n+        }\n     }\n \n     // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor"}, {"sha": "f4b5ca7a157244d5f4e46b7739dd6db85d5c1169", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-10-10\n+2016-10-10b"}, {"sha": "ac2050a6fc8f1e318b5454d3f7990f675af21d63", "filename": "src/stage0.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -13,5 +13,4 @@\n # released on `$date`\n \n rustc: beta-2016-09-28\n-rustc_key: 62b3e239\n cargo: nightly-2016-09-26"}, {"sha": "d0051c5165fe139253700b111cb7d8e64c506e8d", "filename": "src/test/codegen/zip.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcodegen%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcodegen%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fzip.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -20,3 +20,12 @@ pub fn zip_copy(xs: &[u8], ys: &mut [u8]) {\n         *y = *x;\n     }\n }\n+\n+// CHECK-LABEL: @zip_copy_mapped\n+#[no_mangle]\n+pub fn zip_copy_mapped(xs: &[u8], ys: &mut [u8]) {\n+// CHECK: memcpy\n+    for (x, y) in xs.iter().map(|&x| x).zip(ys) {\n+        *y = x;\n+    }\n+}"}, {"sha": "2041abcf82c99ce052a783ac3b2341435fa664b4", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -57,7 +57,7 @@ fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n                    -> Box<MacResult+'static> {\n     // Parse an expression and emit it unchanged.\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg(), tts.to_vec());\n+        cx.cfg().clone(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "a04756ca19ba7e225a9fe0751b173298c0246b3a", "filename": "src/test/compile-fail-fulldeps/proc-macro/shadow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n // aux-build:derive-a.rs\n-// aux-build:derive-a-2.rs\n \n #![feature(proc_macro)]\n \n #[macro_use]\n extern crate derive_a;\n #[macro_use]\n-extern crate derive_a_2; //~ ERROR: cannot shadow existing derive mode `A`\n+extern crate derive_a; //~ ERROR `derive_a` has already been defined\n \n fn main() {}"}, {"sha": "892989cc6a080132c0dbdbc64e2f32c4f1ec6f9f", "filename": "src/test/compile-fail/E0198.rs", "status": "renamed", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2FE0198.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2FE0198.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0198.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,18 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// force-host\n-// no-prefer-dynamic\n+#![feature(optin_builtin_traits)]\n \n-#![feature(proc_macro)]\n-#![feature(proc_macro_lib)]\n-#![crate_type = \"proc-macro\"]\n+struct Foo;\n \n-extern crate proc_macro;\n+unsafe impl !Clone for Foo { } //~ ERROR negative implementations are not unsafe [E0198]\n \n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(A)]\n-pub fn derive_a(input: TokenStream) -> TokenStream {\n-    input\n+fn main() {\n }", "previous_filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-a-2.rs"}, {"sha": "1a5cd1941a9d12f5576f3ca616addc59feecd064", "filename": "src/test/compile-fail/E0199.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2FE0199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2FE0199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0199.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -12,7 +12,8 @@\n \n struct Foo;\n \n-unsafe impl !Clone for Foo { } //~ ERROR E0199\n+trait Bar { }\n+unsafe impl Bar for Foo { } //~ ERROR implementing the trait `Bar` is not unsafe [E0199]\n \n fn main() {\n }"}, {"sha": "4434723e12f8293dba3d3535e0d22e8ae8a54b41", "filename": "src/test/compile-fail/E0243.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2FE0243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2FE0243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0243.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,7 @@\n struct Foo<T> { x: T }\n struct Bar { x: Foo }\n                 //~^ ERROR E0243\n-                //~| NOTE expected 1 type arguments, found 0\n+                //~| NOTE expected 1 type argument, found 0\n \n fn main() {\n }"}, {"sha": "3f429bbd4b63473016bd91ff94b29bcce3fa119e", "filename": "src/test/compile-fail/borrowck/borrowck-use-uninitialized-in-cast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -12,8 +12,6 @@\n // The problem was specified to casting to `*`, as creating unsafe\n // pointers was not being fully checked. Issue #20791.\n \n-// pretty-expanded FIXME #23616\n-\n fn main() {\n     let x: &i32;\n     let y = x as *const i32; //~ ERROR use of possibly uninitialized variable: `*x`"}, {"sha": "86ae5b44d9db02bc9326827268d255d6fce7dbc2", "filename": "src/test/compile-fail/coherence-cow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fcoherence-cow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fcoherence-cow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:coherence_lib.rs\n \n-// pretty-expanded FIXME #23616\n-\n // Test that the `Pair` type reports an error if it contains type\n // parameters, even when they are covered by local types. This test\n // was originally intended to test the opposite, but the rules changed"}, {"sha": "196c2f4ee3cd345feb5d022c599b6e0305d289a3", "filename": "src/test/compile-fail/coherence-vec-local-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -13,8 +13,6 @@\n \n // aux-build:coherence_lib.rs\n \n-// pretty-expanded FIXME #23616\n-\n extern crate coherence_lib as lib;\n use lib::Remote;\n "}, {"sha": "49822dcfcb3f0e049d3308c6bea7e3e5063df540", "filename": "src/test/compile-fail/coherence-vec-local.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -13,8 +13,6 @@\n \n // aux-build:coherence_lib.rs\n \n-// pretty-expanded FIXME #23616\n-\n extern crate coherence_lib as lib;\n use lib::Remote;\n "}, {"sha": "23f8ead0ca9dc497b37ceddaa5d1f6ccf3314611", "filename": "src/test/compile-fail/feature-gate-may-dangle.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `may_dangle` is rejected if `dropck_eyepatch` feature gate is absent.\n+\n+#![feature(generic_param_attrs)]\n+\n+struct Pt<A>(A);\n+impl<#[may_dangle] A> Drop for Pt<A> {\n+    //~^ ERROR may_dangle has unstable semantics and may be removed in the future\n+    //~| HELP add #![feature(dropck_eyepatch)] to the crate attributes to enable\n+    fn drop(&mut self) { }\n+}"}, {"sha": "9b1f3e51647cb7b325a1650511be3106768d4b6d", "filename": "src/test/compile-fail/generic-type-less-params-with-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fgeneric-type-less-params-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fgeneric-type-less-params-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-less-params-with-defaults.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -18,5 +18,5 @@ struct Vec<T, A = Heap>(\n fn main() {\n     let _: Vec;\n     //~^ ERROR E0243\n-    //~| NOTE expected at least 1 type arguments, found 0\n+    //~| NOTE expected at least 1 type argument, found 0\n }"}, {"sha": "0c446f5fe47031644cf5404e49a9f7a1609044ed", "filename": "src/test/compile-fail/issue-13352.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n fn foo(_: Box<FnMut()>) {}\n \n fn main() {"}, {"sha": "df8707ab823e52151fd7092ae6dec8646bb18790", "filename": "src/test/compile-fail/issue-14092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,6 +10,6 @@\n \n fn fn1(0: Box) {}\n         //~^ ERROR E0243\n-        //~| NOTE expected 1 type arguments, found 0\n+        //~| NOTE expected 1 type argument, found 0\n \n fn main() {}"}, {"sha": "b54f008f8ce3abfa986a0e47cfa4e4f7114c3f60", "filename": "src/test/compile-fail/issue-19482.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fissue-19482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fissue-19482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19482.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,8 +11,6 @@\n // Test that a partially specified trait object with unspecified associated\n // type does not type-check.\n \n-// pretty-expanded FIXME #23616\n-\n trait Foo {\n     type A;\n "}, {"sha": "bd70879d13e5fe0cae7328197603f1d094c068ac", "filename": "src/test/compile-fail/meta-expected-error-correct-rev.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-correct-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-correct-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-correct-rev.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // revisions: a\n-// pretty-expanded FIXME #23616\n \n // Counterpart to `meta-expected-error-wrong-rev.rs`\n "}, {"sha": "3c13050812c9326369dfbbc01063c2ec3b8a375f", "filename": "src/test/compile-fail/meta-expected-error-wrong-rev.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-wrong-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-wrong-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmeta-expected-error-wrong-rev.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,7 +10,6 @@\n \n // revisions: a\n // should-fail\n-// pretty-expanded FIXME #23616\n \n // This is a \"meta-test\" of the compilertest framework itself.  In\n // particular, it includes the right error message, but the message"}, {"sha": "98301ef1a0a1dea0701e0b6cf051b9d625189f82", "filename": "src/test/compile-fail/object-lifetime-default-from-rptr-box-error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-rptr-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-rptr-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-rptr-box-error.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,8 +11,6 @@\n // Test that the lifetime from the enclosing `&` is \"inherited\"\n // through the `Box` struct.\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(dead_code)]\n \n trait Test {"}, {"sha": "836e4fa114263541e435bff1e182c54bea274755", "filename": "src/test/compile-fail/object-lifetime-default-from-rptr-struct-error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-rptr-struct-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-rptr-struct-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-rptr-struct-error.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,8 +11,6 @@\n // Test that the lifetime from the enclosing `&` is \"inherited\"\n // through the `MyBox` struct.\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(dead_code)]\n #![feature(rustc_error)]\n "}, {"sha": "f40445a030e013bc48ecc2a927ee20216eedc5dd", "filename": "src/test/compile-fail/typeck_type_placeholder_lifetime_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_1.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -18,5 +18,5 @@ struct Foo<'a, T:'a> {\n pub fn main() {\n     let c: Foo<_, _> = Foo { r: &5 };\n     //~^ ERROR E0244\n-    //~| NOTE expected 1 type arguments, found 2\n+    //~| NOTE expected 1 type argument, found 2\n }"}, {"sha": "47898690fcce46f033a0289e5def29ca69b85192", "filename": "src/test/compile-fail/typeck_type_placeholder_lifetime_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_lifetime_2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -18,5 +18,5 @@ struct Foo<'a, T:'a> {\n pub fn main() {\n     let c: Foo<_, usize> = Foo { r: &5 };\n     //~^ ERROR E0244\n-    //~| NOTE expected 1 type arguments, found 2\n+    //~| NOTE expected 1 type argument, found 2\n }"}, {"sha": "2d78940ce4b9d195d18ed24112b54acae7a0b6a2", "filename": "src/test/compile-fail/variance-trait-matching.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![allow(dead_code)]\n \n // Get<T> is covariant in T"}, {"sha": "8fa34bde17053ed59ef3ee69e252176ddb09ac12", "filename": "src/test/incremental/change_private_impl_method/struct_point.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change the body of a private method in an impl.\n+// We then test what sort of functions must be rebuilt as a result.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![allow(dead_code)]\n+\n+#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n+\n+// FIXME(#37121) -- the following two modules *should* be reused but are not\n+#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+mod point {\n+    pub struct Point {\n+        pub x: f32,\n+        pub y: f32,\n+    }\n+\n+    impl Point {\n+        fn distance_squared(&self) -> f32 {\n+            #[cfg(rpass1)]\n+            return self.x + self.y;\n+\n+            #[cfg(rpass2)]\n+            return self.x * self.x + self.y * self.y;\n+        }\n+\n+        pub fn distance_from_origin(&self) -> f32 {\n+            self.distance_squared().sqrt()\n+        }\n+    }\n+\n+    impl Point {\n+        pub fn translate(&mut self, x: f32, y: f32) {\n+            self.x += x;\n+            self.y += y;\n+        }\n+    }\n+\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from the same impl which changed\n+mod fn_calls_methods_in_same_impl {\n+    use point::Point;\n+\n+    // FIXME(#37121) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let x = Point { x: 2.0, y: 2.0 };\n+        x.distance_from_origin();\n+    }\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from another impl\n+mod fn_calls_methods_in_another_impl {\n+    use point::Point;\n+\n+    // FIXME(#37121) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let mut x = Point { x: 2.0, y: 2.0 };\n+        x.translate(3.0, 3.0);\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "32837fbcf87bc39cede7ce28c31c8dd26e298beb", "filename": "src/test/pretty/for-comment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fpretty%2Ffor-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fpretty%2Ffor-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffor-comment.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -17,6 +17,5 @@ fn f(v: &[isize]) -> isize {\n     for e in v {\n         n = *e; // This comment once triggered pretty printer bug\n     }\n-\n     n\n }"}, {"sha": "1f9e069526ce9b28d07452f26782ab84098561d0", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:attempt to divide by zero\n \n fn main() {"}, {"sha": "a7ba283b25af37181e6f9a20eebade64735fab9e", "filename": "src/test/run-fail/glob-use-std.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fglob-use-std.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,10 +10,6 @@\n \n // Issue #7580\n \n-// ignore-pretty\n-//\n-// Expanded pretty printing causes resolve conflicts.\n-\n // error-pattern:panic works\n \n use std::*;"}, {"sha": "641d39e2324b8a509aa4e2d7c39c61a9724cb17e", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:attempt to calculate the remainder with a divisor of zero\n \n fn main() {"}, {"sha": "250f0726dc9d61d0e83f547e0e40e58e2b94a0f4", "filename": "src/test/run-fail/overflowing-add.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-add.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to add with overflow'\n // compile-flags: -C debug-assertions\n \n-\n fn main() {\n     let _x = 200u8 + 200u8 + 200u8;\n }"}, {"sha": "baa1e05d559b6d2aed7535db85f265f5ecc0e3a2", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "3438ed2c77c1835c22c45833a7a8e2eb4276cd28", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "ef5c43db6e285f30b5026a45fd6c7463f58f9cf3", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "226ece6020db4e862d7e0b6e705fe191633dc8e0", "filename": "src/test/run-fail/overflowing-lsh-4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift left with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "b47d0fc4136ccaf316f07f26bc0bdc71364c7ef6", "filename": "src/test/run-fail/overflowing-mul.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to multiply with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "836d7e37319e941dcbda0ecbf1a6a7794f8d3cfc", "filename": "src/test/run-fail/overflowing-neg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to negate with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "8f198c887e491c9dcd32084fc0de8d86eefa7f6c", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "e4f260b2bbbbb130ff6f3065796b6e21e20f031d", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "11aa98a0c3cbc1d3f210cc120fdfcb63901f3ddc", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "742720e83c10cac96ff464efe0d7331a2353beaa", "filename": "src/test/run-fail/overflowing-rsh-4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "6106fdcb16a46076c8d267480b596b9cf61d34a7", "filename": "src/test/run-fail/overflowing-rsh-5.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "d419550fcc5700547bac8c3adf106e46922d1404", "filename": "src/test/run-fail/overflowing-rsh-6.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to shift right with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "f94cb31b16884cab216e40a23652d47dad572e27", "filename": "src/test/run-fail/overflowing-sub.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // error-pattern:thread 'main' panicked at 'attempt to subtract with overflow'\n // compile-flags: -C debug-assertions\n "}, {"sha": "3f75229948df0782c03cdb6a0163efe8c6206d5d", "filename": "src/test/run-fail/run-unexported-tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,6 @@\n // error-pattern:runned an unexported test\n // compile-flags:--test\n // check-stdout\n-// ignore-pretty: does not work well with `--test`\n \n mod m {\n     pub fn exported() {}"}, {"sha": "bb6f4abe1fc969d4428f85da4fddb4b9972c2003", "filename": "src/test/run-fail/test-panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Ftest-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Ftest-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-panic.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,6 @@\n // check-stdout\n // error-pattern:thread 'test_foo' panicked at\n // compile-flags: --test\n-// ignore-pretty: does not work well with `--test`\n // ignore-emscripten\n \n #[test]"}, {"sha": "eac9813f180aee53478f590ba79c00383d8080e8", "filename": "src/test/run-fail/test-should-fail-bad-message.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-should-fail-bad-message.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,6 @@\n // check-stdout\n // error-pattern:thread 'test_foo' panicked at\n // compile-flags: --test\n-// ignore-pretty: does not work well with `--test`\n // ignore-emscripten\n \n #[test]"}, {"sha": "fcf3559e7da66b3258471c877870ce225a212baa", "filename": "src/test/run-fail/test-tasks-invalid-value.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Ftest-tasks-invalid-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-fail%2Ftest-tasks-invalid-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftest-tasks-invalid-value.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -14,7 +14,6 @@\n // error-pattern:should be a positive integer\n // compile-flags: --test\n // exec-env:RUST_TEST_THREADS=foo\n-// ignore-pretty: does not work well with `--test`\n // ignore-emscripten\n \n #[test]"}, {"sha": "82686ffdd9d93d3c47ee8bfff16383e3f9ea0aee", "filename": "src/test/run-make/dep-info-spaces/Makefile", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Fdep-info-spaces%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Fdep-info-spaces%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info-spaces%2FMakefile?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -5,9 +5,12 @@\n ifneq ($(shell uname),FreeBSD)\n ifndef IS_WINDOWS\n all:\n-\t$(RUSTC) --emit link,dep-info --crate-type=lib lib.rs\n+\tcp lib.rs $(TMPDIR)/\n+\tcp 'foo foo.rs' $(TMPDIR)/\n+\tcp bar.rs $(TMPDIR)/\n+\t$(RUSTC) --emit link,dep-info --crate-type=lib $(TMPDIR)/lib.rs\n \tsleep 1\n-\ttouch 'foo foo.rs'\n+\ttouch $(TMPDIR)/'foo foo.rs'\n \t-rm -f $(TMPDIR)/done\n \t$(MAKE) -drf Makefile.foo\n \trm $(TMPDIR)/done"}, {"sha": "80a5d4333cdc22f4d4766c3a0a0291c232b6d55a", "filename": "src/test/run-make/dep-info-spaces/Makefile.foo", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Fdep-info-spaces%2FMakefile.foo", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Fdep-info-spaces%2FMakefile.foo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info-spaces%2FMakefile.foo?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1,7 +1,7 @@\n-LIB := $(shell $(RUSTC) --print file-names --crate-type=lib lib.rs)\n+LIB := $(shell $(RUSTC) --print file-names --crate-type=lib $(TMPDIR)/lib.rs)\n \n $(TMPDIR)/$(LIB):\n-\t$(RUSTC) --emit link,dep-info --crate-type=lib lib.rs\n+\t$(RUSTC) --emit link,dep-info --crate-type=lib $(TMPDIR)/lib.rs\n \ttouch $(TMPDIR)/done\n \n -include $(TMPDIR)/lib.d"}, {"sha": "ca58e007852bd53fe0216330256284544bbe33da", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -22,6 +22,7 @@ use rustc_driver::driver::CompileController;\n use rustc_trans::ModuleSource;\n use rustc::session::Session;\n use syntax::codemap::FileLoader;\n+use std::env;\n use std::io;\n use std::path::{PathBuf, Path};\n \n@@ -75,9 +76,11 @@ fn main() {\n     path.pop();\n     path.pop();\n \n-    let args: Vec<String> =\n+    let mut args: Vec<String> =\n         format!(\"_ _ --sysroot {} --crate-type dylib\", path.to_str().unwrap())\n         .split(' ').map(|s| s.to_string()).collect();\n+    args.push(\"--out-dir\".to_string());\n+    args.push(env::var(\"TMPDIR\").unwrap());\n \n     let (result, _) = rustc_driver::run_compiler(\n         &args, &mut JitCalls, Some(box JitLoader), None);"}, {"sha": "1db87d474bd72d185d395507d511f4b0a5f623e6", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -22,9 +22,6 @@ RLIB_GLOB = lib$(1)*.rlib\n BIN = $(1)\n \n UNAME = $(shell uname)\n-ifneq (,$(findstring MINGW,$(UNAME)))\n-IS_WINDOWS=1\n-endif\n \n ifeq ($(UNAME),Darwin)\n RUN = $(TARGET_RPATH_ENV) $(RUN_BINFILE)"}, {"sha": "2c814a5433baa1e88fa69e957adb295e4dbb593f", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -60,7 +60,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResu\n // See Issue #15750\n fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg().clone(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "47f5f8397d1c54cfda8179ae1cc6d08e77949b3e", "filename": "src/test/run-pass-fulldeps/custom-derive-partial-eq.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:custom_derive_partial_eq.rs\n // ignore-stage1\n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n #![feature(plugin, custom_derive)]\n #![plugin(custom_derive_partial_eq)]\n #![allow(unused)]"}, {"sha": "3ab7f8429e60177f41d3b0bf589902b458c7d962", "filename": "src/test/run-pass-fulldeps/issue-16992.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n // ignore-cross-compile\n \n #![feature(quote, rustc_private)]"}, {"sha": "03311d76e46d43619f6c3a1731bcbbf68eb1e68c", "filename": "src/test/run-pass-fulldeps/issue-18763-quote-token-tree.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-18763-quote-token-tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fissue-18763-quote-token-tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-18763-quote-token-tree.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // ignore-cross-compile\n-// ignore-pretty: does not work well with `--test`\n-\n #![feature(quote, rustc_private)]\n \n extern crate syntax;"}, {"sha": "978a78cee4f1eeb7405e1d1a5c9e1d993675a1d3", "filename": "src/test/run-pass-fulldeps/lint-group-plugin.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Flint-group-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Flint-group-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-group-plugin.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:lint_group_plugin_test.rs\n // ignore-stage1\n-// ignore-pretty\n-\n #![feature(plugin)]\n #![plugin(lint_group_plugin_test)]\n #![allow(dead_code)]"}, {"sha": "2e86e11bd6a5fbe757dee9e239ed244702877093", "filename": "src/test/run-pass-fulldeps/lint-plugin-cmdline-load.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline-load.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:lint_plugin_test.rs\n // ignore-stage1\n-// ignore-pretty: Random space appears with the pretty test\n // compile-flags: -Z extra-plugins=lint_plugin_test\n \n #![allow(dead_code)]"}, {"sha": "753ad33bd01e9c83be310b237597c8c020025d73", "filename": "src/test/run-pass-fulldeps/lint-plugin.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:lint_plugin_test.rs\n // ignore-stage1\n-// ignore-pretty\n-\n #![feature(plugin)]\n #![plugin(lint_plugin_test)]\n #![allow(dead_code)]"}, {"sha": "9e9b7ce5bf29d2f80de3631ea1b6da9624991272", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // ignore-cross-compile\n-// ignore-pretty: does not work well with `--test`\n-\n #![feature(quote, rustc_private)]\n \n extern crate syntax;"}, {"sha": "d3be1ddcb8c32f274983f7b1649e0b8a83ba0853", "filename": "src/test/run-pass-fulldeps/quote-unused-sp-no-warning.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // ignore-cross-compile\n-// ignore-pretty: does not work well with `--test`\n-\n #![feature(quote, rustc_private)]\n #![deny(unused_variables)]\n "}, {"sha": "2815863fe9961ed41a390abbd0dfc2be231b456b", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // no-prefer-dynamic\n \n #![allow(dead_code)]"}, {"sha": "1266e589b127e54b62928fade13422c992ada1dd", "filename": "src/test/run-pass/auxiliary/dropck_eyepatch_extern_crate.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attributes effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::cell::RefCell;\n+\n+pub trait Foo { fn foo(&self, _: &str); }\n+\n+pub struct Dt<A: Foo>(pub &'static str, pub A);\n+pub struct Dr<'a, B:'a+Foo>(pub &'static str, pub &'a B);\n+pub struct Pt<A,B: Foo>(pub &'static str, pub A, pub B);\n+pub struct Pr<'a, 'b, B:'a+'b+Foo>(pub &'static str, pub &'a B, pub &'b B);\n+pub struct St<A: Foo>(pub &'static str, pub A);\n+pub struct Sr<'a, B:'a+Foo>(pub &'static str, pub &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] A, B: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+impl Foo for RefCell<String> {\n+    fn foo(&self, s: &str) {\n+        let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+        *self.borrow_mut() = s2;\n+    }\n+}\n+\n+impl<'a, T:Foo> Foo for &'a T {\n+    fn foo(&self, s: &str) {\n+        (*self).foo(s);\n+    }\n+}"}, {"sha": "72cf109fd5974e972f3fc8537dd1be0af9cb5744", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -16,7 +16,7 @@\n // \"enable\" to 0 instead.\n \n // compile-flags:-g -Cllvm-args=-enable-tail-merge=0\n-// ignore-pretty as this critically relies on line numbers\n+// ignore-pretty issue #37195\n // ignore-emscripten spawning processes is not supported\n \n use std::io;"}, {"sha": "c438c17f51e3a61a53303f3eef45be12a4d96bb5", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-pretty-expanded FIXME #15189\n // ignore-android FIXME #17520\n // ignore-emscripten spawning processes is not supported\n // compile-flags:-g"}, {"sha": "8de45e4205dfb9a7afd3db6957c8a08611870d4d", "filename": "src/test/run-pass/borrowck/borrowck-pat-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-pat-enum.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37199\n \n fn match_ref(v: Option<isize>) -> isize {\n     match v {"}, {"sha": "5dd6fa45bb96e457f42657c340d625ebd445124d", "filename": "src/test/run-pass/cfg-in-crate-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fcfg-in-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fcfg-in-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-in-crate-1.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // compile-flags: --cfg bar -D warnings\n-// ignore-pretty\n-\n #![cfg(bar)]\n \n fn main() {}"}, {"sha": "5be9b97aac7e6ac6f3a432f37c46cbf8353edda7", "filename": "src/test/run-pass/command-exec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-exec.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n // ignore-windows - this is a unix-specific test\n+// ignore-pretty issue #37199\n // ignore-emscripten\n-// ignore-pretty\n-\n #![feature(process_exec)]\n \n use std::env;"}, {"sha": "c5b5b6b24ab1cd72733cb654a5de9e2830eae0b9", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n // compile-flags:--test\n // ignore-emscripten\n "}, {"sha": "1a2be7a719e1767dc08c81f183fe4b0cd1b9ba6b", "filename": "src/test/run-pass/deprecated-macro_escape-inner.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape-inner.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n mod foo {\n     #![macro_escape] //~ WARNING macro_escape is a deprecated synonym for macro_use\n     //~^ HELP consider an outer attribute"}, {"sha": "b9f756cc79c8f93e9a16ab2e9b25fe70b880ad40", "filename": "src/test/run-pass/deprecated-macro_escape.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n #[macro_escape] //~ WARNING macro_escape is a deprecated synonym for macro_use\n mod foo {\n }"}, {"sha": "b2add21dcd487f40ebc378ed108512366dd5ada1", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-pretty-expanded FIXME #15189\n-\n-\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n enum E<T> {\n     E0,"}, {"sha": "ed8a50998daeefc57680e26433391d917df813d1", "filename": "src/test/run-pass/deriving-meta-empty-trait-list.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fderiving-meta-empty-trait-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fderiving-meta-empty-trait-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-empty-trait-list.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -1,5 +1,3 @@\n-// ignore-pretty\n-\n // Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "20f069f77ea1574648aaa5daed1b232eef465e4f", "filename": "src/test/run-pass/dropck-eyepatch-extern-crate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:dropck_eyepatch_extern_crate.rs\n+\n+extern crate dropck_eyepatch_extern_crate as other;\n+\n+use other::{Dt,Dr,Pt,Pr,St,Sr};\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "bbf8bb8c352389f2c246b5ea44b3c0f7c5930645", "filename": "src/test/run-pass/dropck-eyepatch-reorder.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to test uses of `#[may_dangle]` attribute\n+// where the formal declaration order (in the impl generics) does not\n+// match the actual usage order (in the type instantiation).\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+trait Foo { fn foo(&self, _: &str); }\n+\n+struct Dt<A: Foo>(&'static str, A);\n+struct Dr<'a, B:'a+Foo>(&'static str, &'a B);\n+struct Pt<A: Foo, B: Foo>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+Foo>(&'static str, &'a B, &'b B);\n+struct St<A: Foo>(&'static str, A);\n+struct Sr<'a, B:'a+Foo>(&'static str, &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<B: Foo, #[may_dangle] A: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<'b, #[may_dangle] 'a, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    impl Foo for RefCell<String> {\n+        fn foo(&self, s: &str) {\n+            let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+            *self.borrow_mut() = s2;\n+        }\n+    }\n+\n+    impl<'a, T:Foo> Foo for &'a T {\n+        fn foo(&self, s: &str) {\n+            (*self).foo(s);\n+        }\n+    }\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "4a09ba05dff5eec3af108c0cbc21d759d4655f34", "filename": "src/test/run-pass/dropck-eyepatch.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself.\n+//\n+// Here we test that a model use of `#[may_dangle]` will compile and run.\n+//\n+// The illustration is made concrete by comparison with two variations\n+// on the type with `#[may_dangle]`:\n+//\n+//   1. an analogous type that does not implement `Drop` (and thus\n+//      should exhibit maximal flexibility with respect to dropck), and\n+//\n+//   2. an analogous type that does not use `#[may_dangle]` (and thus\n+//      should exhibit the standard limitations imposed by dropck.\n+//\n+// The types in this file follow a pattern, {D,P,S}{t,r}, where:\n+//\n+// - D means \"I implement Drop\"\n+//\n+// - P means \"I implement Drop but guarantee my (first) parameter is\n+//     pure, i.e. not accessed from the destructor\"; no other parameters\n+//     are pure.\n+//\n+// - S means \"I do not implement Drop\"\n+//\n+// - t suffix is used when the first generic is a type\n+//\n+// - r suffix is used when the first generic is a lifetime.\n+\n+trait Foo { fn foo(&self, _: &str); }\n+\n+struct Dt<A: Foo>(&'static str, A);\n+struct Dr<'a, B:'a+Foo>(&'static str, &'a B);\n+struct Pt<A,B: Foo>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+Foo>(&'static str, &'a B, &'b B);\n+struct St<A: Foo>(&'static str, A);\n+struct Sr<'a, B:'a+Foo>(&'static str, &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] A, B: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    impl Foo for RefCell<String> {\n+        fn foo(&self, s: &str) {\n+            let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+            *self.borrow_mut() = s2;\n+        }\n+    }\n+\n+    impl<'a, T:Foo> Foo for &'a T {\n+        fn foo(&self, s: &str) {\n+            (*self).foo(s);\n+        }\n+    }\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "26deb0ed72adec4414b34aea0a7382a7f227713b", "filename": "src/test/run-pass/enum-size-variance.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n //\n-// ignore-pretty\n-\n #![warn(variant_size_differences)]\n #![allow(dead_code)]\n "}, {"sha": "2aa5f59cda62d4286a44cea7324542d6bd9db1d0", "filename": "src/test/run-pass/hygienic-labels-in-let.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty: pprust doesn't print hygiene output\n-\n // Test that labels injected by macros do not break hygiene.  This\n // checks cases where the macros invocations are under the rhs of a\n // let statement."}, {"sha": "c9af2b190b21c781bc491cccefc3fb1fcbdeee64", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-pretty-expanded unnecessary unsafe block generated\n-\n #![deny(warnings)]\n #![allow(unused_must_use)]\n #![allow(unused_features)]"}, {"sha": "195b99c9788e893ccdf0ca67649df55ce3c6650b", "filename": "src/test/run-pass/imports.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimports.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when ending with // comments\n-\n #![feature(item_like_imports)]\n #![allow(unused)]\n "}, {"sha": "88d74a65813be014e3aee538f67a4c6cffd908af", "filename": "src/test/run-pass/issue-11709.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11709.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37199\n \n // Don't panic on blocks without results\n // There are several tests in this run-pass that raised"}, {"sha": "35faa5789a9c87aa96a27b8c91e41fb5d4bc3c44", "filename": "src/test/run-pass/issue-15189.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15189.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n macro_rules! third {\n     ($e:expr) => ({let x = 2; $e[x]})\n }"}, {"sha": "177550a0dd4a1c9b484e2eedb5d1fed42dd5c7cc", "filename": "src/test/run-pass/issue-16492.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16492.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16492.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16492.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n use std::rc::Rc;\n use std::cell::Cell;\n "}, {"sha": "c51e33c01040bb3eb2412e9a0dc7ae6377a3fe60", "filename": "src/test/run-pass/issue-16597-empty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16597-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16597-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16597-empty.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // compile-flags:--test\n-// no-pretty-expanded\n \n // This verifies that the test generation doesn't crash when we have\n // no tests - for more information, see PR #16892."}, {"sha": "583d8d46235d6290cddb3a550b5f5f7125266c2d", "filename": "src/test/run-pass/issue-16597.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16597.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16597.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16597.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // compile-flags:--test\n-// ignore-pretty turns out the pretty-printer doesn't handle gensym'd things...\n \n mod tests {\n     use super::*;"}, {"sha": "18861feb1997aabe999d367f332806791b0719c7", "filename": "src/test/run-pass/issue-16668.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16668.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n #![allow(unknown_features)]\n \n struct Parser<'a, I, O> {"}, {"sha": "dff86bc1b4527ea583ce85e1bec2608775a302db", "filename": "src/test/run-pass/issue-18464.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-18464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-18464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18464.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n #![deny(dead_code)]\n \n const LOW_RANGE: char = '0';"}, {"sha": "985ca067350a35a3a253a02ef0604a1312dd70cc", "filename": "src/test/run-pass/issue-20427.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20427.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // aux-build:i8.rs\n-// ignore-pretty (#23623)\n+// ignore-pretty issue #37201\n \n extern crate i8;\n use std::string as i16;"}, {"sha": "4d31d0cedb6d5bcbe8bab087c3276c9133510ab4", "filename": "src/test/run-pass/issue-20823.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-20823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-20823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20823.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // compile-flags: --test\n-// no-pretty-expanded\n \n #![deny(unstable)]\n "}, {"sha": "dc612fc0bc71c294af7a3890cf9b0fb6f1352adc", "filename": "src/test/run-pass/issue-22992.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-22992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-22992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22992.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37201\n \n struct X { val: i32 }\n impl std::ops::Deref for X {"}, {"sha": "9d0612f2a8daa75bdaa2d154be0b6626c3d49604", "filename": "src/test/run-pass/issue-23338-ensure-param-drop-order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n+// ignore-pretty issue #37201\n \n // This test is ensuring that parameters are indeed dropped after\n // temporaries in a fn body."}, {"sha": "51bf4bfe0e13e7bff26cb5f113ef11e5cad3ed0f", "filename": "src/test/run-pass/issue-26873-multifile.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-26873-multifile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-26873-multifile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-26873-multifile.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -7,10 +7,9 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-//\n-// ignore-pretty\n+\n+// ignore-pretty issue #37195\n \n mod issue_26873_multifile;\n \n fn main() {}\n-"}, {"sha": "37dc060d5d64d4238c3147a9bd818162f4b08d8b", "filename": "src/test/run-pass/issue-27401-dropflag-reinit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-27401-dropflag-reinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-27401-dropflag-reinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27401-dropflag-reinit.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty #27582\n+// ignore-pretty issue #37201\n \n // Check that when a `let`-binding occurs in a loop, its associated\n // drop-flag is reinitialized (to indicate \"needs-drop\" at the end of"}, {"sha": "ce1abb163d53b3d046c8bd206d7ab4daf8b3d7d3", "filename": "src/test/run-pass/issue-27639.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-27639.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-27639.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27639.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n fn main() {\n     const iter: i32 = 0;\n "}, {"sha": "2ff4403a42f9781c98f3005b6a9fd5fe3e5b234c", "filename": "src/test/run-pass/issue-28839.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-28839.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-28839.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28839.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems with newlines before // comments\n+// ignore-pretty issue #37199\n \n pub struct Foo;\n "}, {"sha": "eb7b740db6e4bf74f52906c36a1d6256f01d3723", "filename": "src/test/run-pass/issue-29740.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-29740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-29740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29740.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,8 +11,6 @@\n // Regression test for #29740. Inefficient MIR matching algorithms\n // generated way too much code for this sort of case, leading to OOM.\n \n-// ignore-pretty\n-\n pub mod KeyboardEventConstants {\n     pub const DOM_KEY_LOCATION_STANDARD: u32 = 0;\n     pub const DOM_KEY_LOCATION_LEFT: u32 = 1;"}, {"sha": "dca387dcc2117ce549e00b2ea1b7dc094c83b602", "filename": "src/test/run-pass/issue-34932.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-34932.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-34932.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34932.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,8 +10,6 @@\n \n // compile-flags:--test\n // rustc-env:RUSTC_BOOTSTRAP_KEY=\n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n #![cfg(any())] // This test should be configured away\n #![feature(rustc_attrs)] // Test that this is allowed on stable/beta\n #![feature(iter_arith_traits)] // Test that this is not unused"}, {"sha": "0d3613b573e12925c51da29f56ee662e875c1779", "filename": "src/test/run-pass/issue-37175.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-37175.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-37175.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37175.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m { (<$t:ty>) => { stringify!($t) } }\n+fn main() {\n+    println!(\"{}\", m!(<Vec<i32>>));\n+}"}, {"sha": "764d6fa7918052083b398044a5b6fbf46a111137", "filename": "src/test/run-pass/issue-7911.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7911.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n // (Closes #7911) Test that we can use the same self expression\n // with different mutability in macro in two methods\n "}, {"sha": "5148be5af8307b208c504157c5eab6756e1312ba", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // ignore-emscripten no threads support\n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n #![feature(rustc_attrs, zero_one)]\n \n use std::num::Zero;"}, {"sha": "c46e8494e73b8dd38f7182307c94e637593c9764", "filename": "src/test/run-pass/issue-9129.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9129.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty unreported\n \n #![allow(unknown_features)]\n #![feature(box_syntax)]"}, {"sha": "b0503bc2048e7b626af1713c62d789fe778b4a5c", "filename": "src/test/run-pass/iter-zip.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fiter-zip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fiter-zip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-zip.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that .zip() specialization preserves side effects\n+// in sideeffectful iterator adaptors.\n+\n+use std::cell::Cell;\n+\n+#[derive(Debug)]\n+struct CountClone(Cell<i32>);\n+\n+fn count_clone() -> CountClone { CountClone(Cell::new(0)) }\n+\n+impl PartialEq<i32> for CountClone {\n+    fn eq(&self, rhs: &i32) -> bool {\n+        self.0.get() == *rhs\n+    }\n+}\n+\n+impl Clone for CountClone {\n+    fn clone(&self) -> Self {\n+        let ret = CountClone(self.0.clone());\n+        let n = self.0.get();\n+        self.0.set(n + 1);\n+        ret\n+    }\n+}\n+\n+fn test_zip_cloned_sideffectful() {\n+    let xs = [count_clone(), count_clone(), count_clone(), count_clone()];\n+    let ys = [count_clone(), count_clone()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) { }\n+\n+    assert_eq!(&xs, &[1, 1, 1, 0][..]);\n+    assert_eq!(&ys, &[1, 1][..]);\n+\n+    let xs = [count_clone(), count_clone()];\n+    let ys = [count_clone(), count_clone(), count_clone(), count_clone()];\n+\n+    for _ in xs.iter().cloned().zip(ys.iter().cloned()) { }\n+\n+    assert_eq!(&xs, &[1, 1][..]);\n+    assert_eq!(&ys, &[1, 1, 0, 0][..]);\n+}\n+\n+fn test_zip_map_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) { }\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+\n+    let mut xs = [0; 4];\n+    let mut ys = [0; 6];\n+\n+    for _ in xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1)) { }\n+\n+    assert_eq!(&xs, &[1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1, 0, 0]);\n+}\n+\n+fn test_zip_map_rev_sideffectful() {\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[0, 0, 0, 1, 1, 1]);\n+    assert_eq!(&ys, &[0, 0, 0, 1]);\n+\n+    let mut xs = [0; 6];\n+    let mut ys = [0; 4];\n+\n+    {\n+        let mut it = xs.iter_mut().map(|x| *x += 1).zip(ys.iter_mut().map(|y| *y += 1));\n+        (&mut it).take(5).count();\n+        it.next_back();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 1]);\n+    assert_eq!(&ys, &[1, 1, 1, 1]);\n+}\n+\n+fn test_zip_nested_sideffectful() {\n+    let mut xs = [0; 6];\n+    let ys = [0; 4];\n+\n+    {\n+        // test that it has the side effect nested inside enumerate\n+        let it = xs.iter_mut().map(|x| *x = 1).enumerate().zip(&ys);\n+        it.count();\n+    }\n+    assert_eq!(&xs, &[1, 1, 1, 1, 1, 0]);\n+}\n+\n+fn main() {\n+    test_zip_cloned_sideffectful();\n+    test_zip_map_sideffectful();\n+    test_zip_map_rev_sideffectful();\n+    test_zip_nested_sideffectful();\n+}"}, {"sha": "05f1f1bfea0fb03318f47a1b52d566aa5479140c", "filename": "src/test/run-pass/lexer-crlf-line-endings-string-literal-doc-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -15,7 +15,7 @@\n // NB: this file needs CRLF line endings. The .gitattributes file in\r\n // this directory should enforce it.\r\n \r\n-// ignore-pretty\r\n+// ignore-pretty issue #37195\r\n \r\n /// Doc comment that ends in CRLF\r\n pub fn foo() {}\r"}, {"sha": "3da2fc8ceacf73eb9c6f2ccf4341c076720371cf", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-pretty-expanded FIXME #15189\n-\n pub fn main() {\n     let x = vec!(1, 2, 3);\n     let mut y = 0;"}, {"sha": "801d92b6dcb160d10a8023ff3e8d9b9700375fb5", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - token trees can't pretty print\n-\n pub fn main() {\n \n     macro_rules! mylambda_tt {"}, {"sha": "c3de9f736fbe50fb5e01f69071812a9a0eb70a41", "filename": "src/test/run-pass/macro-attribute-expansion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - token trees can't pretty print\n-\n macro_rules! descriptions {\n     ($name:ident is $desc:expr) => {\n         // Check that we will correctly expand attributes"}, {"sha": "839fee3a2d214484fe5b86bf641b39b394b130ca", "filename": "src/test/run-pass/macro-attributes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - token trees can't pretty print\n-\n #![feature(custom_attribute)]\n \n macro_rules! compiles_fine {"}, {"sha": "f8728ebb91517e3c6f731f016f5d1e8ddcb62b72", "filename": "src/test/run-pass/macro-include-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n fn bar() {}\n "}, {"sha": "9c1e1fca3413ef0443f378470aae83d04ddc884c", "filename": "src/test/run-pass/macro-meta-items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - token trees can't pretty print\n // compile-flags: --cfg foo\n \n macro_rules! compiles_fine {"}, {"sha": "190bfc53a9edb6db68e6875726b38c70d87d00e9", "filename": "src/test/run-pass/macro-multiple-items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - token trees can't pretty print\n-\n macro_rules! make_foo {\n     () => (\n         struct Foo;"}, {"sha": "027df9f93a88dc5101cdb66cd04ee556aa80fdd7", "filename": "src/test/run-pass/macro-stmt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty - token trees can't pretty print\n-\n macro_rules! myfn {\n     ( $f:ident, ( $( $x:ident ),* ), $body:block ) => (\n         fn $f( $( $x : isize),* ) -> isize $body"}, {"sha": "846318ec4fd347d7fe265f9cdbdc2645fd5a04bd", "filename": "src/test/run-pass/mir_raw_fat_ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n // check raw fat pointer ops in mir\n // FIXME: please improve this when we get monomorphization support\n "}, {"sha": "f8034f9e0738613824b81dad88f8af3d12d5ad84", "filename": "src/test/run-pass/mod_dir_implicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_implicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_implicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_implicit.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n mod mod_dir_implicit_aux;\n "}, {"sha": "e2f33963c4bad25318bc35eabe38dd7236fc9d26", "filename": "src/test/run-pass/mod_dir_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_path.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n mod mod_dir_simple {\n     #[path = \"test.rs\"]"}, {"sha": "b96c1ae072243c0322268b4dabd450b0f3edad0b", "filename": "src/test/run-pass/mod_dir_path2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_path2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n #[path = \"mod_dir_simple\"]\n mod pancakes {"}, {"sha": "3160064d7c2447505ee27aa8042100c9d7680621", "filename": "src/test/run-pass/mod_dir_path3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_path3.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n #[path = \"mod_dir_simple\"]\n mod pancakes {"}, {"sha": "12b28cf98af0ba2139961cfe57de392c330e601a", "filename": "src/test/run-pass/mod_dir_path_multi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path_multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_path_multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_path_multi.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n #[path = \"mod_dir_simple\"]\n mod biscuits {"}, {"sha": "8964d9ccd2527d4cf71523b3526c99fb3ee598af", "filename": "src/test/run-pass/mod_dir_recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_recursive.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n // Testing that the parser for each file tracks its modules\n // and paths independently. The load_another_mod module should"}, {"sha": "429b4ebe63970a407c594f898f5b97f4055f1d12", "filename": "src/test/run-pass/mod_dir_simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_dir_simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_dir_simple.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n mod mod_dir_simple {\n     pub mod test;"}, {"sha": "c18fecd7c569e09e469cee74d3c5dd981130e285", "filename": "src/test/run-pass/mod_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_file.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n // Testing that a plain .rs file can load modules from other source files\n "}, {"sha": "d9f28ceb0ecacaf93cc99836ca96f10bd6e4787c", "filename": "src/test/run-pass/mod_file_with_path_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_file_with_path_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fmod_file_with_path_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod_file_with_path_attr.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n+// ignore-pretty issue #37195\n \n // Testing that a plain .rs file can load modules from other source files\n "}, {"sha": "266506e04b74d0360a8fa33947b8b97d0135d875", "filename": "src/test/run-pass/nonzero-enum.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fnonzero-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fnonzero-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnonzero-enum.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem::size_of;\n+\n+enum E {\n+    A = 1,\n+    B = 2,\n+    C = 3,\n+}\n+\n+struct S {\n+    a: u16,\n+    b: u8,\n+    e: E,\n+}\n+\n+fn main() {\n+    assert_eq!(size_of::<E>(), 1);\n+    assert_eq!(size_of::<Option<E>>(), 1);\n+    assert_eq!(size_of::<Result<E, ()>>(), 1);\n+    assert_eq!(size_of::<S>(), 4);\n+    assert_eq!(size_of::<Option<S>>(), 4);\n+    let enone = None::<E>;\n+    let esome = Some(E::A);\n+    if let Some(..) = enone {\n+        panic!();\n+    }\n+    if let None = esome {\n+        panic!();\n+    }\n+}"}, {"sha": "15ece09abd80f4091b287bcd73a78fa91640547c", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-pretty-expanded\n-\n // This file is intended to test only that methods are automatically\n // reachable for each numeric type, for each exported impl, with no imports\n // necessary. Testing the methods of the impls is done within the source"}, {"sha": "88e3e6ba4acd3480ebffb5d12cab049a8fd254f3", "filename": "src/test/run-pass/reexport-test-harness-main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Freexport-test-harness-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Freexport-test-harness-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexport-test-harness-main.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n // compile-flags:--test\n \n #![reexport_test_harness_main = \"test_main\"]"}, {"sha": "47d2fe363d3694df3668d34dddcacfac93bd2808", "filename": "src/test/run-pass/regions-bound-lists-feature-gate-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fregions-bound-lists-feature-gate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fregions-bound-lists-feature-gate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-bound-lists-feature-gate-2.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n #![feature(issue_5723_bootstrap)]\n \n trait Foo {"}, {"sha": "72db92aa93ce04264c01ec5c107ab1dc5dd493cb", "filename": "src/test/run-pass/regions-bound-lists-feature-gate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fregions-bound-lists-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fregions-bound-lists-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-bound-lists-feature-gate.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n #![feature(issue_5723_bootstrap)]\n \n trait Foo {"}, {"sha": "a0947cd49a42d6b9e989ef604a3b1ba3330bfb2e", "filename": "src/test/run-pass/shebang.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fshebang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fshebang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshebang.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,7 +9,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty: `expand` adds some preludes before shebang\n-//\n-\n pub fn main() { println!(\"Hello World\"); }"}, {"sha": "f0444c27170561550a80c85b48e8e4f3f17dd2c1", "filename": "src/test/run-pass/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(repr_simd, platform_intrinsics)]\n \n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n #[repr(simd)]\n #[derive(Copy, Clone, Debug, PartialEq)]\n #[allow(non_camel_case_types)]"}, {"sha": "a1bbd190211272170958c3b7a4a4a401edf85529", "filename": "src/test/run-pass/super-fast-paren-parsing.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-//\n // exec-env:RUST_MIN_STACK=16000000\n // rustc-env:RUST_MIN_STACK=16000000\n //"}, {"sha": "3b5f033d07b7d3101598d4e2fc4a9223a2ff2e13", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-// This test is brittle!\n-// ignore-pretty - the pretty tests lose path information, breaking include!\n+// ignore-pretty issue #37195\n \n pub mod m1 {\n     pub mod m2 {\n@@ -24,9 +21,9 @@ pub mod m1 {\n macro_rules! indirect_line { () => ( line!() ) }\n \n pub fn main() {\n-    assert_eq!(line!(), 27);\n+    assert_eq!(line!(), 24);\n     assert_eq!(column!(), 4);\n-    assert_eq!(indirect_line!(), 29);\n+    assert_eq!(indirect_line!(), 26);\n     assert!((file!().ends_with(\"syntax-extension-source-utils.rs\")));\n     assert_eq!(stringify!((2*3) + 5).to_string(), \"( 2 * 3 ) + 5\".to_string());\n     assert!(include!(\"syntax-extension-source-utils-files/includeme.\\\n@@ -43,5 +40,5 @@ pub fn main() {\n     // The Windows tests are wrapped in an extra module for some reason\n     assert!((m1::m2::where_am_i().ends_with(\"m1::m2\")));\n \n-    assert_eq!((46, \"( 2 * 3 ) + 5\"), (line!(), stringify!((2*3) + 5)));\n+    assert_eq!((43, \"( 2 * 3 ) + 5\"), (line!(), stringify!((2*3) + 5)));\n }"}, {"sha": "78f29f46edf4a08b2bb4cd64c8d3b36129a7e612", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,6 @@\n #![feature(std_misc)]\n \n // ignore-emscripten no threads support\n-// no-pretty-expanded FIXME #15189\n \n use std::thread;\n use std::sync::mpsc::{channel, Sender};"}, {"sha": "10ad838d3cb87cc9f29db32fe176554ab3a643e6", "filename": "src/test/run-pass/test-fn-signature-verification-for-explicit-return-type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -11,7 +11,6 @@\n #![feature(test)]\n \n // compile-flags: --test\n-// no-pretty-expanded\n extern crate test;\n \n #[bench]"}, {"sha": "7b696c1f8d27c52b5f5830b7d4131ef5999b1d54", "filename": "src/test/run-pass/test-runner-hides-main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-runner-hides-main.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // compile-flags:--test\n-// ignore-pretty: does not work well with `--test`\n-\n // Building as a test runner means that a synthetic main will be run,\n // not ours\n pub fn main() { panic!(); }"}, {"sha": "e665fa4fc7b58e5cff0f0374a1b82cd6612170b6", "filename": "src/test/run-pass/test-should-fail-good-message.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n // compile-flags: --test\n-// ignore-pretty: does not work well with `--test`\n-\n #[test]\n #[should_panic(expected = \"foo\")]\n pub fn test_foo() {"}, {"sha": "f7fd86c9570703cc8fe7454f53094608479f9c9c", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -12,8 +12,6 @@\n // and shared between threads as long as all types fulfill Send.\n \n // ignore-emscripten no threads support\n-// ignore-pretty\n-\n #![allow(unknown_features)]\n #![feature(box_syntax, std_misc)]\n "}, {"sha": "6cb7e82d6b740546bc4380150b1d9a23fc08bac0", "filename": "src/test/run-pass/union/union-with-drop-fields-lint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Funion%2Funion-with-drop-fields-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Frun-pass%2Funion%2Funion-with-drop-fields-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-with-drop-fields-lint.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-pretty\n-\n #![feature(untagged_unions)]\n #![allow(dead_code)]\n #![allow(unions_with_drop_fields)]"}, {"sha": "1b00d88dcb3dfd78d9fba23aab85499ff10d220b", "filename": "src/test/ui/dropck/auxiliary/dropck_eyepatch_extern_crate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// This is a support file for ../dropck-eyepatch-extern-crate.rs\n+//\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attribute's effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also ../dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::fmt;\n+\n+pub struct Dt<A: fmt::Debug>(pub &'static str, pub A);\n+pub struct Dr<'a, B:'a+fmt::Debug>(pub &'static str, pub &'a B);\n+pub struct Pt<A,B: fmt::Debug>(pub &'static str, pub A, pub B);\n+pub struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(pub &'static str, pub &'a B, pub &'b B);\n+pub struct St<A: fmt::Debug>(pub &'static str, pub A);\n+pub struct Sr<'a, B:'a+fmt::Debug>(pub &'static str, pub &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}"}, {"sha": "5e200dbdbfa0195a23874498eb97cdb017495b1a", "filename": "src/test/ui/dropck/dropck-eyepatch-extern-crate.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:dropck_eyepatch_extern_crate.rs\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attribute's effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+extern crate dropck_eyepatch_extern_crate as other;\n+\n+use other::{Dt,Dr,Pt,Pr,St,Sr};\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "5d2096e8b07a45126670f4a4c55793a0dbc32769", "filename": "src/test/ui/dropck/dropck-eyepatch-extern-crate.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.stderr?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,46 @@\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:39:20\n+   |\n+39 |     dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:40:20\n+   |\n+40 |     dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:47:29\n+   |\n+47 |     pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-extern-crate.rs:48:29\n+   |\n+48 |     pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+55 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f92c8703dc9273b9ddb3055db23b98aab705ae43", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// This test ensures that a use of `#[may_dangle]` is rejected if\n+// it is not attached to an `unsafe impl`.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A,B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+}"}, {"sha": "c53cf020a9bc52d75110c3753fb72b591938505e", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,14 @@\n+error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+  --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:32:1\n+   |\n+32 | impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+   | ^\n+\n+error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+  --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:38:1\n+   |\n+38 | impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+   | ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "68b0ff3b5f096f76672d3f57e439a56732f73cbc", "filename": "src/test/ui/dropck/dropck-eyepatch-reorder.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to test uses of `#[may_dangle]` attribute\n+// where the formal declaration order (in the impl generics) does not\n+// match the actual usage order (in the type instantiation).\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A: fmt::Debug, B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<B: fmt::Debug, #[may_dangle] A: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<'b, #[may_dangle] 'a, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "33b18f6f02e0f180b479b90364ace3f903088259", "filename": "src/test/ui/dropck/dropck-eyepatch-reorder.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.stderr?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,46 @@\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:57:20\n+   |\n+57 |     dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:58:20\n+   |\n+58 |     dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:65:29\n+   |\n+65 |     pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch-reorder.rs:66:29\n+   |\n+66 |     pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+73 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e442fade1973025d25f2d82ce9085e5b41dcf978", "filename": "src/test/ui/dropck/dropck-eyepatch.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself.\n+//\n+// Here we test that only the expected errors are issued.\n+//\n+// The illustration is made concrete by comparison with two variations\n+// on the type with `#[may_dangle]`:\n+//\n+//   1. an analogous type that does not implement `Drop` (and thus\n+//      should exhibit maximal flexibility with respect to dropck), and\n+//\n+//   2. an analogous type that does not use `#[may_dangle]` (and thus\n+//      should exhibit the standard limitations imposed by dropck.\n+//\n+// The types in this file follow a pattern, {D,P,S}{t,r}, where:\n+//\n+// - D means \"I implement Drop\"\n+//\n+// - P means \"I implement Drop but guarantee my (first) parameter is\n+//     pure, i.e. not accessed from the destructor\"; no other parameters\n+//     are pure.\n+//\n+// - S means \"I do not implement Drop\"\n+//\n+// - t suffix is used when the first generic is a type\n+//\n+// - r suffix is used when the first generic is a lifetime.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A,B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "75e612ca9c8f181ae860aac9e45d5e7d6065b644", "filename": "src/test/ui/dropck/dropck-eyepatch.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.stderr?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -0,0 +1,46 @@\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:80:20\n+   |\n+80 |     dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:81:20\n+   |\n+81 |     dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+   |                    ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:88:29\n+   |\n+88 |     pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: `c` does not live long enough\n+  --> $DIR/dropck-eyepatch.rs:89:29\n+   |\n+89 |     pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+   |                             ^ does not live long enough\n+...\n+96 | }\n+   | - borrowed value dropped before borrower\n+   |\n+   = note: values in a scope are dropped in the opposite order they are created\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "978e991d50874be47d78e89dc6e051c5a9547742", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -36,6 +36,20 @@ const TEST_REPOS: &'static [Test] = &[Test {\n \n \n fn main() {\n+    // One of the projects being tested here is Cargo, and when being tested\n+    // Cargo will at some point call `nmake.exe` on Windows MSVC. Unfortunately\n+    // `nmake` will read these two environment variables below and try to\n+    // intepret them. We're likely being run, however, from MSYS `make` which\n+    // uses the same variables.\n+    //\n+    // As a result, to prevent confusion and errors, we remove these variables\n+    // from our environment to prevent passing MSYS make flags to nmake, causing\n+    // it to blow up.\n+    if cfg!(target_env = \"msvc\") {\n+        env::remove_var(\"MAKE\");\n+        env::remove_var(\"MAKEFLAGS\");\n+    }\n+\n     let args = env::args().collect::<Vec<_>>();\n     let ref cargo = args[1];\n     let out_dir = Path::new(&args[2]);"}, {"sha": "e10420bf291e703d67adc547786ca8fbb98cd01f", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c429872a32c3005cf2b347025163361218634a4/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c429872a32c3005cf2b347025163361218634a4/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=0c429872a32c3005cf2b347025163361218634a4", "patch": "@@ -2105,12 +2105,17 @@ actual:\\n\\\n                                                  .collect::<Vec<_>>().join(\" \");\n \n             cmd.env(\"IS_MSVC\", \"1\")\n+               .env(\"IS_WINDOWS\", \"1\")\n                .env(\"MSVC_LIB\", format!(\"'{}' -nologo\", lib.display()))\n                .env(\"CC\", format!(\"'{}' {}\", self.config.cc, cflags))\n                .env(\"CXX\", &self.config.cxx);\n         } else {\n             cmd.env(\"CC\", format!(\"{} {}\", self.config.cc, self.config.cflags))\n                .env(\"CXX\", format!(\"{} {}\", self.config.cxx, self.config.cflags));\n+\n+            if self.config.target.contains(\"windows\") {\n+                cmd.env(\"IS_WINDOWS\", \"1\");\n+            }\n         }\n \n         let output = cmd.output().expect(\"failed to spawn `make`\");"}]}