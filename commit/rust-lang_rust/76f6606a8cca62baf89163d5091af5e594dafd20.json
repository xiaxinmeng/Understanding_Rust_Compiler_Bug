{"sha": "76f6606a8cca62baf89163d5091af5e594dafd20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZjY2MDZhOGNjYTYyYmFmODkxNjNkNTA5MWFmNWU1OTRkYWZkMjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-12T22:14:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-12T22:14:24Z"}, "message": "auto merge of #5827 : nikomatsakis/rust/issue-5656-change-meaning-of-borrowed-self, r=pcwalton\n\nSee #5656 for details.\r\n\r\nr? @pcwalton", "tree": {"sha": "9ea72645e98888bf5e1e4cf58e4055c7c5c57a2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ea72645e98888bf5e1e4cf58e4055c7c5c57a2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76f6606a8cca62baf89163d5091af5e594dafd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76f6606a8cca62baf89163d5091af5e594dafd20", "html_url": "https://github.com/rust-lang/rust/commit/76f6606a8cca62baf89163d5091af5e594dafd20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76f6606a8cca62baf89163d5091af5e594dafd20/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bb2e8f62c5666f61db0b670f80f64ca673d22d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bb2e8f62c5666f61db0b670f80f64ca673d22d6", "html_url": "https://github.com/rust-lang/rust/commit/5bb2e8f62c5666f61db0b670f80f64ca673d22d6"}, {"sha": "c97c03cd6a5c4ac37f2e68226c9f8ec49c786fcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97c03cd6a5c4ac37f2e68226c9f8ec49c786fcf", "html_url": "https://github.com/rust-lang/rust/commit/c97c03cd6a5c4ac37f2e68226c9f8ec49c786fcf"}], "stats": {"total": 3245, "additions": 2463, "deletions": 782}, "files": [{"sha": "b5a5ed7c9f41ed3c3c7e0be1aa96b829659c8b2d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -116,6 +116,19 @@ totalord_impl!(i64)\n totalord_impl!(int)\n totalord_impl!(uint)\n \n+pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n+    a1: &A, b1: &B,\n+    a2: &A, b2: &B) -> Ordering\n+{\n+    //! Compares (a1, b1) against (a2, b2), where the a values are more significant.\n+\n+    match a1.cmp(a2) {\n+        Less => Less,\n+        Greater => Greater,\n+        Equal => b1.cmp(b2)\n+    }\n+}\n+\n /**\n Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n lexical ordering on a type `(int, int)`.\n@@ -208,6 +221,14 @@ mod test {\n         assert_eq!(12.cmp(-5), Greater);\n     }\n \n+    #[test]\n+    fn test_cmp2() {\n+        assert_eq!(cmp2(1, 2, 3, 4), Less);\n+        assert_eq!(cmp2(3, 2, 3, 4), Less);\n+        assert_eq!(cmp2(5, 2, 3, 4), Greater);\n+        assert_eq!(cmp2(5, 5, 5, 4), Greater);\n+    }\n+\n     #[test]\n     fn test_int_totaleq() {\n         assert!(5.equals(&5));"}, {"sha": "dc6c80228dd74e7ee36248bd5c3c63ae3aef1c99", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -28,7 +28,7 @@ pub struct Condition<'self, T, U> {\n }\n \n pub impl<'self, T, U> Condition<'self, T, U> {\n-    fn trap(&self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n+    fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = task::local_data::local_data_get(self.key);"}, {"sha": "88c78aebfc5c7dbabb7a7196aa9903760c4d8119", "filename": "src/libcore/container.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -25,6 +25,7 @@ pub trait Mutable: Container {\n     fn clear(&mut self);\n }\n \n+#[cfg(stage0)]\n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;\n@@ -57,6 +58,41 @@ pub trait Map<K, V>: Mutable {\n     fn remove(&mut self, key: &K) -> bool;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait Map<K, V>: Mutable {\n+    /// Return true if the map contains a value for the specified key\n+    fn contains_key(&self, key: &K) -> bool;\n+\n+    // Visits all keys and values\n+    fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool);\n+\n+    /// Visit all keys\n+    fn each_key(&self, f: &fn(&K) -> bool);\n+\n+    /// Visit all values\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool);\n+\n+    /// Iterate over the map and mutate the contained values\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n+\n+    /// Return a reference to the value corresponding to the key\n+    fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n+\n+    /// Return a mutable reference to the value corresponding to the key\n+    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool;\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool;\n+}\n+\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;"}, {"sha": "2869c198ca2fc7882da5ee5edb946c07c5c400a7", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 171, "deletions": 2, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -186,6 +186,7 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn value_for_bucket(&self, idx: uint) -> &'self V {\n         match self.buckets[idx] {\n@@ -194,6 +195,18 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n+        match self.buckets[idx] {\n+            Some(ref bkt) => &bkt.value,\n+            None => fail!(~\"HashMap::find: internal logic error\"),\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n         match self.buckets[idx] {\n@@ -202,6 +215,17 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n+        match self.buckets[idx] {\n+            Some(ref mut bkt) => &mut bkt.value,\n+            None => unreachable()\n+        }\n+    }\n+\n     /// Inserts the key value pair into the buckets.\n     /// Assumes that there will be a bucket.\n     /// True if there was no previous entry with that key\n@@ -307,6 +331,7 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n+    #[cfg(stage0)]\n     fn each(&self, blk: &fn(&'self K, &'self V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n@@ -317,19 +342,41 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Visit all key-value pairs\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, blk: &fn(&'a K, &'a V) -> bool) {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            for self.buckets[i].each |bucket| {\n+                if !blk(&bucket.key, &bucket.value) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n     /// Visit all keys\n     fn each_key(&self, blk: &fn(k: &K) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values\n+    #[cfg(stage0)]\n     fn each_value(&self, blk: &fn(v: &V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, blk: &fn(&'self K,\n-                          &'self mut V) -> bool) {\n+    fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             match self.buckets[i] {\n               Some(Bucket{key: ref key, value: ref mut value, _}) => {\n@@ -341,14 +388,27 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find(&self, k: &K) -> Option<&'self V> {\n         match self.bucket_for_key(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+        match self.bucket_for_key(k) {\n+            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+            TableFull | FoundHole(_) => None,\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n@@ -359,6 +419,20 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+        let idx = match self.bucket_for_key(k) {\n+            FoundEntry(idx) => idx,\n+            TableFull | FoundHole(_) => return None\n+        };\n+        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+            Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n+        }\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -431,6 +505,7 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -459,8 +534,42 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+            ::cast::transmute_region(self.value_for_bucket(idx))\n+        }\n+    }\n+\n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -490,6 +599,40 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or create,\n+    /// insert, and return a new value if it doesn't exist.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                let v = f(&k);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+            ::cast::transmute_region(self.value_for_bucket(idx))\n+        }\n+    }\n+\n     fn consume(&mut self, f: &fn(K, V)) {\n         let mut buckets = ~[];\n         self.buckets <-> buckets;\n@@ -506,13 +649,24 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn get(&self, k: &K) -> &'self V {\n         match self.find(k) {\n             Some(v) => v,\n             None => fail!(fmt!(\"No entry found for key: %?\", k)),\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, k: &K) -> &'a V {\n+        match self.find(k) {\n+            Some(v) => v,\n+            None => fail!(fmt!(\"No entry found for key: %?\", k)),\n+        }\n+    }\n+\n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence\n     fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n@@ -525,13 +679,28 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n+    #[cfg(stage0)]\n     fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n                                               -> Option<&'self V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n+\n+    /// Return the value corresponding to the key in the map, using\n+    /// equivalence\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_equiv<'a, Q:Hash + IterBytes + Equiv<K>>(\n+        &'a self, k: &Q) -> Option<&'a V>\n+    {\n+        match self.bucket_for_key_equiv(k) {\n+            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+            TableFull | FoundHole(_) => None,\n+        }\n+    }\n }\n \n impl<K:Hash + IterBytes + Eq,V:Eq> Eq for HashMap<K, V> {"}, {"sha": "9b7276879c1232f09622894a4e37e46052ea6b39", "filename": "src/libcore/option.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -101,22 +101,41 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n \n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each(&self, f: &fn(x: &'self T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n+    /// Performs an operation on the contained value by reference\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n+        match *self { None => (), Some(ref t) => { f(t); } }\n+    }\n+\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> {\n         if self.is_some() { Some(1) } else { Some(0) }\n     }\n }\n \n impl<T> MutableIter<T> for Option<T> {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut(&mut self, f: &fn(&'self mut T) -> bool) {\n         match *self { None => (), Some(ref mut t) => { f(t); } }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n+        match *self { None => (), Some(ref mut t) => { f(t); } }\n+    }\n }\n \n impl<A> ExtendedIter<A> for Option<A> {\n@@ -182,17 +201,40 @@ pub impl<T> Option<T> {\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn chain_ref<U>(&self, f: &fn(x: &'self T) -> Option<U>) -> Option<U> {\n         match *self { Some(ref x) => f(x), None => None }\n     }\n \n+    /**\n+     * Update an optional value by optionally running its content by reference\n+     * through a function that returns an option.\n+     */\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n+        match *self { Some(ref x) => f(x), None => None }\n+    }\n+\n     /// Maps a `some` value from one type to another by reference\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n     }\n \n+    /// Maps a `some` value from one type to another by reference\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n+        match *self { Some(ref x) => Some(f(x)), None => None }\n+    }\n+\n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n@@ -201,11 +243,21 @@ pub impl<T> Option<T> {\n     }\n \n     /// Applies a function to the contained value or returns a default\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n     }\n \n+    /// Applies a function to the contained value or returns a default\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n+        match *self { None => def, Some(ref t) => f(t) }\n+    }\n+\n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n@@ -244,13 +296,39 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn get_ref(&self) -> &'self T {\n         match *self {\n           Some(ref x) => x,\n           None => fail!(~\"option::get_ref none\")\n         }\n     }\n \n+    /**\n+    Gets an immutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_ref<'a>(&'a self) -> &'a T {\n+        match *self {\n+          Some(ref x) => x,\n+          None => fail!(~\"option::get_ref none\")\n+        }\n+    }\n+\n     /**\n     Gets a mutable reference to the value inside an option.\n \n@@ -266,13 +344,39 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn get_mut_ref(&mut self) -> &'self mut T {\n         match *self {\n           Some(ref mut x) => x,\n           None => fail!(~\"option::get_mut_ref none\")\n         }\n     }\n \n+    /**\n+    Gets a mutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n+        match *self {\n+          Some(ref mut x) => x,\n+          None => fail!(~\"option::get_mut_ref none\")\n+        }\n+    }\n+\n     #[inline(always)]\n     fn unwrap(self) -> T {\n         /*!"}, {"sha": "58e281c29c60565f2e5d640ed2106dae8ca34fbe", "filename": "src/libcore/result.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -226,9 +226,16 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n }\n \n pub impl<T, E> Result<T, E> {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn get_ref(&self) -> &'self T { get_ref(self) }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n+\n     #[inline(always)]\n     fn is_ok(&self) -> bool { is_ok(self) }\n "}, {"sha": "6a7c3970c0091341c001ef1b36362c3ec8c3d266", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -22,7 +22,12 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n+    #[cfg(stage0)]\n     fn io(&mut self) -> Option<&'self mut IoFactoryObject>;\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n pub trait IoFactory {"}, {"sha": "25f446fb86d19169e8b099791f82370c63e65eaf", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -272,6 +272,7 @@ pub impl Scheduler {\n \n     // XXX: Hack. This should return &'self mut but I don't know how to\n     // make the borrowcheck happy\n+    #[cfg(stage0)]\n     fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n         assert!(!self.cleanup_jobs.is_empty());\n         let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n@@ -285,6 +286,25 @@ pub impl Scheduler {\n         // borrows\n         return unsafe { transmute::<&Task, &mut Task>(last_task) };\n     }\n+\n+    // XXX: Hack. This should return &'self mut but I don't know how to\n+    // make the borrowcheck happy\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn task_from_last_cleanup_job<'a>(&'a mut self) -> &mut Task {\n+        assert!(!self.cleanup_jobs.is_empty());\n+        let last_job: &'a mut CleanupJob = &mut self.cleanup_jobs[0];\n+        let last_task: &'a Task = match last_job {\n+            &RescheduleTask(~ref task) => task,\n+            &RecycleTask(~ref task) => task,\n+            &GiveTask(~ref task, _) => task,\n+        };\n+        // XXX: Pattern matching mutable pointers above doesn't work\n+        // because borrowck thinks the three patterns are conflicting\n+        // borrows\n+        return unsafe { transmute::<&Task, &mut Task>(last_task) };\n+    }\n }\n \n static TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n@@ -354,6 +374,7 @@ impl ThreadLocalScheduler {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn get_scheduler(&mut self) -> &'self mut Scheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };\n@@ -370,6 +391,25 @@ impl ThreadLocalScheduler {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_scheduler<'a>(&'a mut self) -> &'a mut Scheduler {\n+        unsafe {\n+            let key = match self { &ThreadLocalScheduler(key) => key };\n+            let mut value: *mut c_void = tls::get(key);\n+            assert!(value.is_not_null());\n+            {\n+                let value_ptr = &mut value;\n+                let sched: &mut ~Scheduler = {\n+                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr)\n+                };\n+                let sched: &mut Scheduler = &mut **sched;\n+                return sched;\n+            }\n+        }\n+    }\n+\n     fn take_scheduler(&mut self) -> ~Scheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };"}, {"sha": "7162ed27a9d77df82dcbf9062abb8c99db1b7e5a", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -67,9 +67,17 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn io(&mut self) -> Option<&'self mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n+        Some(&mut self.uvio)\n+    }\n }\n \n #[test]\n@@ -89,9 +97,17 @@ fn test_callback_run_once() {\n pub struct UvIoFactory(Loop);\n \n pub impl UvIoFactory {\n+    #[cfg(stage0)]\n     fn uv_loop(&mut self) -> &'self mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n+        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    }\n }\n \n impl IoFactory for UvIoFactory {"}, {"sha": "521c8266e050563b01a493227cf7e4c60cadb508", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -318,7 +318,11 @@ pub fn slice_shift_char<'a>(s: &'a str) -> (char, &'a str) {\n \n /// Prepend a char to a string\n pub fn unshift_char(s: &mut ~str, ch: char) {\n-    *s = from_char(ch) + *s;\n+    // This could be more efficient.\n+    let mut new_str = ~\"\";\n+    new_str.push_char(ch);\n+    new_str.push_str(*s);\n+    *s = new_str;\n }\n \n /**"}, {"sha": "e4ee430cdda64dc2d4f2f23b4512ab6b0455a667", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -39,7 +39,7 @@ use result::Result;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use prelude::*;\n use result;\n-use task::rt::{task_id, sched_id, rust_task};\n+use task::rt::{task_id, sched_id};\n use util;\n use util::replace;\n use unstable::finally::Finally;"}, {"sha": "f4e9ddbdd90a11bc67bb0a1190353af13eb823f8", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -56,10 +56,20 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&uint, &'self T) -> bool) {\n         self.root.each(f);\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n+        self.root.each(f);\n+    }\n+\n     /// Visit all keys in order\n     #[inline(always)]\n     fn each_key(&self, f: &fn(&uint) -> bool) {\n@@ -68,17 +78,28 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_value(&self, f: &fn(&T) -> bool) {\n         self.each(|_, v| f(v))\n     }\n \n+    /// Visit all values in order\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n+        self.each(|_, v| f(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n     #[inline(always)]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) {\n         self.root.mutate_values(f);\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     #[inline(hint)]\n     fn find(&self, key: &uint) -> Option<&'self T> {\n         let mut node: &'self TrieNode<T> = &self.root;\n@@ -99,12 +120,46 @@ impl<T> Map<uint, T> for TrieMap<T> {\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(hint)]\n+    fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n+        let mut node: &'a TrieNode<T> = &self.root;\n+        let mut idx = 0;\n+        loop {\n+            match node.children[chunk(*key, idx)] {\n+              Internal(ref x) => node = &**x,\n+              External(stored, ref value) => {\n+                if stored == *key {\n+                    return Some(value)\n+                } else {\n+                    return None\n+                }\n+              }\n+              Nothing => return None\n+            }\n+            idx += 1;\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn find_mut(&mut self, key: &uint) -> Option<&'self mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n+        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -138,10 +193,20 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) {\n         self.root.each_reverse(f);\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n+        self.root.each_reverse(f);\n+    }\n+\n     /// Visit all keys in reverse order\n     #[inline(always)]\n     fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n@@ -233,6 +298,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n@@ -244,6 +310,21 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        for uint::range(0, self.children.len()) |idx| {\n+            match self.children[idx] {\n+                Internal(ref x) => if !x.each(f) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n+                Nothing => ()\n+            }\n+        }\n+        true\n+    }\n+\n+    #[cfg(stage0)]\n     fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n@@ -255,7 +336,21 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        for uint::range_rev(self.children.len(), 0) |idx| {\n+            match self.children[idx - 1] {\n+                Internal(ref x) => if !x.each_reverse(f) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n+                Nothing => ()\n+            }\n+        }\n+        true\n+    }\n+\n+    fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         for vec::each_mut(self.children) |child| {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(f) {"}, {"sha": "8e908435f3543fff15fea09f69d6d762f9ee5b5d", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -56,11 +56,13 @@ impl<T:Clone,U:Clone> Clone for (T, U) {\n     }\n }\n \n+#[cfg(stage0)]\n pub trait ImmutableTuple<T, U> {\n     fn first_ref(&self) -> &'self T;\n     fn second_ref(&self) -> &'self U;\n }\n \n+#[cfg(stage0)]\n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n     fn first_ref(&self) -> &'self T {\n@@ -76,6 +78,32 @@ impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait ImmutableTuple<T, U> {\n+    fn first_ref<'a>(&'a self) -> &'a T;\n+    fn second_ref<'a>(&'a self) -> &'a U;\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<T, U> ImmutableTuple<T, U> for (T, U) {\n+    #[inline(always)]\n+    fn first_ref<'a>(&'a self) -> &'a T {\n+        match *self {\n+            (ref t, _) => t,\n+        }\n+    }\n+    #[inline(always)]\n+    fn second_ref<'a>(&'a self) -> &'a U {\n+        match *self {\n+            (_, ref u) => u,\n+        }\n+    }\n+}\n+\n pub trait ExtendedTupleOps<A,B> {\n     fn zip(&self) -> ~[(A, B)];\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n@@ -161,7 +189,6 @@ impl<A:Ord> Ord for (A,) {\n     fn gt(&self, other: &(A,)) -> bool { other.lt(&(*self))  }\n }\n \n-\n #[cfg(notest)]\n impl<A:Eq,B:Eq> Eq for (A, B) {\n     #[inline(always)]"}, {"sha": "7940502d27e48bd28653d1cfe5dbf9756870ca12", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -1763,6 +1763,7 @@ impl<'self,T:Copy> CopyableVector<T> for &'self const [T] {\n     }\n }\n \n+#[cfg(stage0)]\n pub trait ImmutableVector<T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn head(&self) -> &'self T;\n@@ -1785,6 +1786,7 @@ pub trait ImmutableVector<T> {\n }\n \n /// Extension methods for vectors\n+#[cfg(stage0)]\n impl<'self,T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n@@ -1893,6 +1895,142 @@ impl<'self,T> ImmutableVector<T> for &'self [T] {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait ImmutableVector<'self, T> {\n+    fn slice(&self, start: uint, end: uint) -> &'self [T];\n+    fn head(&self) -> &'self T;\n+    fn head_opt(&self) -> Option<&'self T>;\n+    fn tail(&self) -> &'self [T];\n+    fn tailn(&self, n: uint) -> &'self [T];\n+    fn init(&self) -> &'self [T];\n+    fn initn(&self, n: uint) -> &'self [T];\n+    fn last(&self) -> &'self T;\n+    fn last_opt(&self) -> Option<&'self T>;\n+    fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n+    fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+}\n+\n+/// Extension methods for vectors\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n+    /// Return a slice that points into another slice.\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+        slice(*self, start, end)\n+    }\n+\n+    /// Returns the first element of a vector, failing if the vector is empty.\n+    #[inline]\n+    fn head(&self) -> &'self T { head(*self) }\n+\n+    /// Returns the first element of a vector\n+    #[inline]\n+    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n+\n+    /// Returns all but the first element of a vector\n+    #[inline]\n+    fn tail(&self) -> &'self [T] { tail(*self) }\n+\n+    /// Returns all but the first `n' elements of a vector\n+    #[inline]\n+    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n+\n+    /// Returns all but the last elemnt of a vector\n+    #[inline]\n+    fn init(&self) -> &'self [T] { init(*self) }\n+\n+    /// Returns all but the last `n' elemnts of a vector\n+    #[inline]\n+    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n+\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n+    #[inline]\n+    fn last(&self) -> &'self T { last(*self) }\n+\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n+    #[inline]\n+    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n+\n+    /// Iterates over a vector's elements in reverse.\n+    #[inline]\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n+        each_reverse(*self, blk)\n+    }\n+\n+    /// Iterates over a vector's elements and indices in reverse.\n+    #[inline]\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n+        eachi_reverse(*self, blk)\n+    }\n+\n+    /// Reduce a vector from right to left\n+    #[inline]\n+    fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n+        foldr(*self, z, p)\n+    }\n+\n+    /// Apply a function to each element of a vector and return the results\n+    #[inline]\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n+\n+    /**\n+     * Apply a function to the index and value of each element in the vector\n+     * and return the results\n+     */\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n+        mapi(*self, f)\n+    }\n+\n+    #[inline]\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n+        let mut r = ~[];\n+        let mut i = 0;\n+        while i < self.len() {\n+            r.push(f(&self[i]));\n+            i += 1;\n+        }\n+        r\n+    }\n+\n+    /**\n+     * Returns true if the function returns true for all elements.\n+     *\n+     *     If the vector is empty, true is returned.\n+     */\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n+        alli(*self, f)\n+    }\n+    /**\n+     * Apply a function to each element of a vector and return a concatenation\n+     * of each result vector\n+     */\n+    #[inline]\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+        flat_map(*self, f)\n+    }\n+    /**\n+     * Apply a function to each element of a vector and return the results\n+     *\n+     * If function `f` returns `none` then that element is excluded from\n+     * the resulting vector.\n+     */\n+    #[inline]\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n+        filter_mapped(*self, f)\n+    }\n+}\n+\n pub trait ImmutableEqVector<T:Eq> {\n     fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn position_elem(&self, t: &T) -> Option<uint>;\n@@ -2353,14 +2491,26 @@ pub mod bytes {\n // ___________________________________________________________________________\n // ITERATION TRAIT METHODS\n \n+#[cfg(stage0)]\n impl<'self,A> iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<'self,A> iter::BaseIter<A> for &'self [A] {\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n // FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n@@ -2369,28 +2519,73 @@ impl<A> iter::BaseIter<A> for ~[A] {\n }\n \n // FIXME(#4148): This should be redundant\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<A> iter::BaseIter<A> for ~[A] {\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+// FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n+// FIXME(#4148): This should be redundant\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<A> iter::BaseIter<A> for @[A] {\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+#[cfg(stage0)]\n impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n+        each_mut(*self, blk)\n+    }\n+}\n+\n // FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> iter::MutableIter<A> for ~[A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<A> iter::MutableIter<A> for ~[A] {\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n+        each_mut(*self, blk)\n+    }\n+}\n+\n // FIXME(#4148): This should be redundant\n impl<A> iter::MutableIter<A> for @mut [A] {\n     #[inline(always)]"}, {"sha": "f52ff056472f99024ab0be7e35babb959c8f2848", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -239,7 +239,8 @@ fn parse_region(st: @mut PState) -> ty::Region {\n         assert!(next(st) == '|');\n         let br = parse_bound_region(st);\n         assert!(next(st) == ']');\n-        ty::re_free(id, br)\n+        ty::re_free(ty::FreeRegion {scope_id: id,\n+                                    bound_region: br})\n       }\n       's' => {\n         let id = parse_uint(st) as int;"}, {"sha": "2e1dd8b6dad86a5095481e56a3b5447bcf093a97", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -146,12 +146,12 @@ fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n         w.write_char('b');\n         enc_bound_region(w, cx, br);\n       }\n-      ty::re_free(id, br) => {\n+      ty::re_free(ref fr) => {\n         w.write_char('f');\n         w.write_char('[');\n-        w.write_int(id);\n+        w.write_int(fr.scope_id);\n         w.write_char('|');\n-        enc_bound_region(w, cx, br);\n+        enc_bound_region(w, cx, fr.bound_region);\n         w.write_char(']');\n       }\n       ty::re_scope(nid) => {"}, {"sha": "a67be995171ffab8c8b6e279fe6785e8511735f4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -475,9 +475,12 @@ impl tr for ty::Region {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n         match *self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n-            ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n             ty::re_static | ty::re_infer(*) => *self,\n+            ty::re_free(ref fr) => {\n+                ty::re_free(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n+                                            bound_region: fr.bound_region.tr(xcx)})\n+            }\n         }\n     }\n }"}, {"sha": "721bb99626249a02599d5a3c3ae7d3f6cb1d7e15", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -128,9 +128,9 @@ pub impl CheckLoanCtxt {\n               Some(e) => return Some(pc_cmt(*e))\n             }\n \n-            match self.tcx().region_map.find(&scope_id) {\n+            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n               None => return default_purity,\n-              Some(&next_scope_id) => scope_id = next_scope_id\n+              Some(next_scope_id) => scope_id = next_scope_id\n             }\n         }\n     }\n@@ -146,9 +146,9 @@ pub impl CheckLoanCtxt {\n                 }\n             }\n \n-            match self.tcx().region_map.find(&scope_id) {\n+            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n               None => return,\n-              Some(&next_scope_id) => scope_id = next_scope_id,\n+              Some(next_scope_id) => scope_id = next_scope_id,\n             }\n         }\n     }\n@@ -270,7 +270,7 @@ pub impl CheckLoanCtxt {\n \n         debug!(\"new_loans has length %?\", new_loans.len());\n \n-        let par_scope_id = *self.tcx().region_map.get(&scope_id);\n+        let par_scope_id = self.tcx().region_maps.encl_scope(scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n             debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n "}, {"sha": "4e61b5738912f380598ac61b7148e5dfff71b302", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -242,7 +242,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // (if used like `a.b(...)`), the call where it's an argument\n         // (if used like `x(a.b)`), or the block (if used like `let x\n         // = a.b`).\n-        let scope_r = ty::re_scope(*self.tcx().region_map.get(&ex.id));\n+        let scope_r = self.tcx().region_maps.encl_region(ex.id);\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n         visit::visit_expr(ex, self, vt);\n@@ -524,7 +524,10 @@ pub impl GatherLoanCtxt {\n         // immutable structures, this is just the converse I suppose)\n \n         let scope_id = match scope_r {\n-            ty::re_scope(scope_id) | ty::re_free(scope_id, _) => scope_id,\n+            ty::re_scope(scope_id) |\n+            ty::re_free(ty::FreeRegion {scope_id, _}) => {\n+                scope_id\n+            }\n             _ => {\n                 self.bccx.tcx.sess.span_bug(\n                     cmt.span,"}, {"sha": "a38cd015654b526a3784eb3faefd0be7a28b833e", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -130,8 +130,8 @@ pub impl LoanContext {\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n               // FIXME(#4903)\n-            let local_scope_id = *self.bccx.tcx.region_map.get(&local_id);\n-            self.issue_loan(cmt, ty::re_scope(local_scope_id), loan_kind,\n+            let local_region = self.bccx.tcx.region_maps.encl_region(local_id);\n+            self.issue_loan(cmt, local_region, loan_kind,\n                             owns_lent_data)\n           }\n           cat_stack_upvar(cmt) => {"}, {"sha": "01fea2a960d4b1c617154fc96145efdf35d49e89", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -227,7 +227,6 @@ Borrowck results in two maps.\n use core::prelude::*;\n \n use middle::mem_categorization::*;\n-use middle::region;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n@@ -458,7 +457,7 @@ pub fn root_map() -> root_map {\n \n pub impl BorrowckCtxt {\n     fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n-        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n+        self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n     fn cat_expr(&self, expr: @ast::expr) -> cmt {"}, {"sha": "40a59e2f89f26898965cb0bb54adc6a144837032", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -108,7 +108,7 @@ pub impl<'self> PreserveCtxt<'self> {\n                 // Maybe if we pass in the parent instead here,\n                 // we can prevent the \"scope not found\" error\n                 debug!(\"scope_region thing: %? \", cmt.id);\n-                ty::re_scope(*self.tcx().region_map.get(&cmt.id))\n+                self.tcx().region_maps.encl_region(cmt.id)\n             };\n \n             self.compare_scope(cmt, scope_region)\n@@ -128,27 +128,27 @@ pub impl<'self> PreserveCtxt<'self> {\n                     cmt.span,\n                     ~\"preserve() called with local and !root_managed_data\");\n             }\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_binding(local_id) => {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_arg(local_id) => {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability\n             // for at least the scope of the fn.  This is basically a\n             // deref of a region ptr.\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_self(local_id) => {\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |"}, {"sha": "6898dcca45dd8a629a387ee03f119dbd236b4d12", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -596,8 +596,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                                              class_id);\n                             }\n                             _ => {\n-                                cx.tcx.sess.span_bug(pat_span,\n-                                ~\"struct pattern didn't resolve to a struct\");\n+                                cx.tcx.sess.span_bug(\n+                                    pat_span,\n+                                    fmt!(\"struct pattern resolved to %s, \\\n+                                          not a struct\",\n+                                         ty_to_str(cx.tcx, left_ty)));\n                             }\n                         }\n                         let args = vec::map(class_fields, |class_field| {"}, {"sha": "e5fc9f2d60391ec7aab71c3b9e9528f424c4db58", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -16,7 +16,7 @@ use middle::liveness;\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{Repr, ty_to_str, tys_to_str};\n+use util::ppaux::{Repr, ty_to_str};\n \n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n@@ -478,13 +478,13 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     }\n }\n \n-/// This is rather subtle.  When we are casting a value to a\n-/// instantiated trait like `a as trait<'r>`, regionck already ensures\n-/// that any borrowed pointers that appear in the type of `a` are\n-/// bounded by `&r`.  However, it is possible that there are *type\n-/// parameters* in the type of `a`, and those *type parameters* may\n-/// have borrowed pointers within them.  We have to guarantee that the\n-/// regions which appear in those type parameters are not obscured.\n+/// This is rather subtle.  When we are casting a value to a instantiated\n+/// trait like `a as trait<'r>`, regionck already ensures that any borrowed\n+/// pointers that appear in the type of `a` are bounded by `'r` (ed.: modulo\n+/// FIXME(#5723)).  However, it is possible that there are *type parameters*\n+/// in the type of `a`, and those *type parameters* may have borrowed pointers\n+/// within them.  We have to guarantee that the regions which appear in those\n+/// type parameters are not obscured.\n ///\n /// Therefore, we ensure that one of three conditions holds:\n ///\n@@ -501,6 +501,8 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n ///\n /// (3) The type parameter is owned (and therefore does not contain\n /// borrowed ptrs).\n+///\n+/// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n     cx: Context,\n     source: @expr,\n@@ -509,40 +511,78 @@ pub fn check_cast_for_escaping_regions(\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n-    let target_substs = match ty::get(target_ty).sty {\n-      ty::ty_trait(_, ref substs, _) => {(/*bad*/copy *substs)}\n-      _ => { return; /* not a cast to a trait */ }\n-    };\n+    match ty::get(target_ty).sty {\n+        ty::ty_trait(*) => {}\n+        _ => { return; }\n+    }\n+\n+    // Collect up the regions that appear in the target type.  We want to\n+    // ensure that these lifetimes are shorter than all lifetimes that are in\n+    // the source type.  See test `src/test/compile-fail/regions-trait-2.rs`\n+    let mut target_regions = ~[];\n+    ty::walk_regions_and_ty(\n+        cx.tcx,\n+        target_ty,\n+        |r| {\n+            if !r.is_bound() {\n+                target_regions.push(r);\n+            }\n+        },\n+        |_| true);\n \n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n-    // must have been declared on the enclosing fn item):\n-    match target_substs.self_r {\n-      Some(ty::re_scope(*)) => { return; /* case (1) */ }\n-      None | Some(ty::re_static) | Some(ty::re_free(*)) => {}\n-      Some(ty::re_bound(*)) | Some(ty::re_infer(*)) => {\n-        cx.tcx.sess.span_bug(\n-            source.span,\n-            fmt!(\"bad region found in kind: %?\", target_substs.self_r));\n-      }\n+    // must have been declared on the enclosing fn item).\n+    if target_regions.any(|r| is_re_scope(*r)) {\n+        return; /* case (1) */\n     }\n \n     // Assuming the trait instance can escape, then ensure that each parameter\n-    // either appears in the trait type or is owned:\n+    // either appears in the trait type or is owned.\n     let target_params = ty::param_tys_in_type(target_ty);\n     let source_ty = ty::expr_ty(cx.tcx, source);\n-    do ty::walk_ty(source_ty) |ty| {\n-        match ty::get(ty).sty {\n-          ty::ty_param(source_param) => {\n-            if target_params.contains(&source_param) {\n-                /* case (2) */\n-            } else {\n-                check_durable(cx.tcx, ty, source.span); /* case (3) */\n+    ty::walk_regions_and_ty(\n+        cx.tcx,\n+        source_ty,\n+\n+        |_r| {\n+            // FIXME(#5723) --- turn this check on once &Objects are usable\n+            //\n+            // if !target_regions.any(|t_r| is_subregion_of(cx, *t_r, r)) {\n+            //     cx.tcx.sess.span_err(\n+            //         source.span,\n+            //         fmt!(\"source contains borrowed pointer with lifetime \\\n+            //               not found in the target type `%s`\",\n+            //              ty_to_str(cx.tcx, target_ty)));\n+            //     note_and_explain_region(\n+            //         cx.tcx, \"source data is only valid for \", r, \"\");\n+            // }\n+        },\n+\n+        |ty| {\n+            match ty::get(ty).sty {\n+                ty::ty_param(source_param) => {\n+                    if target_params.contains(&source_param) {\n+                        /* case (2) */\n+                    } else {\n+                        check_durable(cx.tcx, ty, source.span); /* case (3) */\n+                    }\n+                }\n+                _ => {}\n             }\n-          }\n-          _ => {}\n+            true\n+        });\n+\n+    fn is_re_scope(+r: ty::Region) -> bool {\n+        match r {\n+            ty::re_scope(*) => true,\n+            _ => false\n         }\n     }\n+\n+    fn is_subregion_of(cx: Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+        cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n+    }\n }\n \n /// Ensures that values placed into a ~Trait are copyable and sendable."}, {"sha": "ecb9fc2cd08b8309888889541693ab91dec99f4b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 227, "deletions": 110, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -11,7 +11,7 @@\n /*!\n \n This file actually contains two passes related to regions.  The first\n-pass builds up the `region_map`, which describes the parent links in\n+pass builds up the `scope_map`, which describes the parent links in\n the region hierarchy.  The second pass infers which types must be\n region parameterized.\n \n@@ -23,7 +23,7 @@ use driver::session::Session;\n use metadata::csearch;\n use middle::resolve;\n use middle::ty::{region_variance, rv_covariant, rv_invariant};\n-use middle::ty::{rv_contravariant};\n+use middle::ty::{rv_contravariant, FreeRegion};\n use middle::ty;\n \n use core::hashmap::{HashMap, HashSet};\n@@ -37,23 +37,31 @@ use syntax::{ast, visit};\n pub type parent = Option<ast::node_id>;\n \n /**\n-Encodes the bounding lifetime for a given AST node:\n-\n-- Expressions are mapped to the expression or block encoding the maximum\n-  (static) lifetime of a value produced by that expression.  This is\n-  generally the innermost call, statement, match, or block.\n-\n-- Variables and bindings are mapped to the block in which they are declared.\n-\n+The region maps encode information about region relationships.\n+\n+- `scope_map` maps from:\n+  - an expression to the expression or block encoding the maximum\n+    (static) lifetime of a value produced by that expression.  This is\n+    generally the innermost call, statement, match, or block.\n+  - a variable or binding id to the block in which that variable is declared.\n+- `free_region_map` maps from:\n+  - a free region `a` to a list of free regions `bs` such that\n+    `a <= b for all b in bs`\n+  - the free region map is populated during type check as we check\n+    each function. See the function `relate_free_regions` for\n+    more information.\n */\n-pub type region_map = @mut HashMap<ast::node_id, ast::node_id>;\n+pub struct RegionMaps {\n+    priv scope_map: HashMap<ast::node_id, ast::node_id>,\n+    priv free_region_map: HashMap<FreeRegion, ~[FreeRegion]>,\n+}\n \n pub struct ctxt {\n     sess: Session,\n     def_map: resolve::DefMap,\n \n     // Generated maps:\n-    region_map: region_map,\n+    region_maps: @mut RegionMaps,\n \n     // Generally speaking, expressions are parented to their innermost\n     // enclosing block. But some kinds of expressions serve as\n@@ -98,94 +106,215 @@ pub struct ctxt {\n     parent: parent,\n }\n \n-/// Returns true if `subscope` is equal to or is lexically nested inside\n-/// `superscope` and false otherwise.\n-pub fn scope_contains(region_map: region_map, superscope: ast::node_id,\n-                      subscope: ast::node_id) -> bool {\n-    let mut subscope = subscope;\n-    while superscope != subscope {\n-        match region_map.find(&subscope) {\n-            None => return false,\n-            Some(&scope) => subscope = scope\n+pub impl RegionMaps {\n+    fn relate_free_regions(&mut self,\n+                           sub: FreeRegion,\n+                           sup: FreeRegion)\n+    {\n+        match self.free_region_map.find_mut(&sub) {\n+            Some(sups) => {\n+                if !sups.contains(&sup) {\n+                    sups.push(sup);\n+                }\n+                return;\n+            }\n+            None => {}\n         }\n+\n+        debug!(\"relate_free_regions(sub=%?, sup=%?)\", sub, sup);\n+\n+        self.free_region_map.insert(sub, ~[sup]);\n     }\n-    return true;\n-}\n \n-/// Determines whether one region is a subregion of another.  This is\n-/// intended to run *after inference* and sadly the logic is somewhat\n-/// duplicated with the code in infer.rs.\n-pub fn is_subregion_of(region_map: region_map,\n-                       sub_region: ty::Region,\n-                       super_region: ty::Region) -> bool {\n-    sub_region == super_region ||\n-        match (sub_region, super_region) {\n-            (_, ty::re_static) => {\n-                true\n-            }\n+    fn record_parent(&mut self,\n+                     sub: ast::node_id,\n+                     sup: ast::node_id)\n+    {\n+        debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n \n-            (ty::re_scope(sub_scope), ty::re_scope(super_scope)) |\n-            (ty::re_scope(sub_scope), ty::re_free(super_scope, _)) => {\n-                scope_contains(region_map, super_scope, sub_scope)\n-            }\n+        self.scope_map.insert(sub, sup);\n+    }\n \n-            _ => {\n-                false\n+    fn opt_encl_scope(&self,\n+                      id: ast::node_id) -> Option<ast::node_id>\n+    {\n+        //! Returns the narrowest scope that encloses `id`, if any.\n+\n+        self.scope_map.find(&id).map(|&x| *x)\n+    }\n+\n+    fn encl_scope(&self,\n+                  id: ast::node_id) -> ast::node_id\n+    {\n+        //! Returns the narrowest scope that encloses `id`, if any.\n+\n+        match self.scope_map.find(&id) {\n+            Some(&r) => r,\n+            None => { fail!(fmt!(\"No enclosing scope for id %?\", id)); }\n+        }\n+    }\n+\n+    fn encl_region(&self,\n+                   id: ast::node_id) -> ty::Region\n+    {\n+        //! Returns the narrowest scope region that encloses `id`, if any.\n+\n+        ty::re_scope(self.encl_scope(id))\n+    }\n+\n+    fn is_sub_scope(&self,\n+                    sub_scope: ast::node_id,\n+                    superscope: ast::node_id) -> bool\n+    {\n+        /*!\n+         * Returns true if `sub_scope` is equal to or is lexically\n+         * nested inside `superscope` and false otherwise.\n+         */\n+\n+        let mut sub_scope = sub_scope;\n+        while superscope != sub_scope {\n+            match self.scope_map.find(&sub_scope) {\n+                None => return false,\n+                Some(&scope) => sub_scope = scope\n             }\n         }\n-}\n+        return true;\n+    }\n \n-/// Finds the nearest common ancestor (if any) of two scopes.  That\n-/// is, finds the smallest scope which is greater than or equal to\n-/// both `scope_a` and `scope_b`.\n-pub fn nearest_common_ancestor(region_map: region_map,\n-                               scope_a: ast::node_id,\n-                               scope_b: ast::node_id)\n-                            -> Option<ast::node_id> {\n+    fn sub_free_region(&self,\n+                       sub: FreeRegion,\n+                       sup: FreeRegion) -> bool\n+    {\n+        /*!\n+         * Determines whether two free regions have a subregion relationship\n+         * by walking the graph encoded in `free_region_map`.  Note that\n+         * it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n+         * (that is, the user can give two different names to the same lifetime).\n+         */\n+\n+        if sub == sup {\n+            return true;\n+        }\n \n-    fn ancestors_of(region_map: region_map, scope: ast::node_id)\n-                    -> ~[ast::node_id] {\n-        let mut result = ~[scope];\n-        let mut scope = scope;\n-        loop {\n-            match region_map.find(&scope) {\n-                None => return result,\n-                Some(&superscope) => {\n-                    result.push(superscope);\n-                    scope = superscope;\n+        // Do a little breadth-first-search here.  The `queue` list\n+        // doubles as a way to detect if we've seen a particular FR\n+        // before.  Note that we expect this graph to be an *extremely\n+        // shallow* tree.\n+        let mut queue = ~[sub];\n+        let mut i = 0;\n+        while i < queue.len() {\n+            match self.free_region_map.find(&queue[i]) {\n+                Some(parents) => {\n+                    for parents.each |parent| {\n+                        if *parent == sup {\n+                            return true;\n+                        }\n+\n+                        if !queue.contains(parent) {\n+                            queue.push(*parent);\n+                        }\n+                    }\n                 }\n+                None => {}\n             }\n+            i += 1;\n         }\n+        return false;\n     }\n \n-    if scope_a == scope_b { return Some(scope_a); }\n+    fn is_subregion_of(&self,\n+                       sub_region: ty::Region,\n+                       super_region: ty::Region) -> bool\n+    {\n+        /*!\n+         * Determines whether one region is a subregion of another.  This is\n+         * intended to run *after inference* and sadly the logic is somewhat\n+         * duplicated with the code in infer.rs.\n+         */\n+\n+        debug!(\"is_subregion_of(sub_region=%?, super_region=%?)\",\n+               sub_region, super_region);\n+\n+        sub_region == super_region || {\n+            match (sub_region, super_region) {\n+                (_, ty::re_static) => {\n+                    true\n+                }\n \n-    let a_ancestors = ancestors_of(region_map, scope_a);\n-    let b_ancestors = ancestors_of(region_map, scope_b);\n-    let mut a_index = vec::len(a_ancestors) - 1u;\n-    let mut b_index = vec::len(b_ancestors) - 1u;\n+                (ty::re_scope(sub_scope), ty::re_scope(super_scope)) => {\n+                    self.is_sub_scope(sub_scope, super_scope)\n+                }\n \n-    // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n-    // The end of each vector will be the item where the scope is\n-    // defined; if there are any common ancestors, then the tails of\n-    // the vector will be the same.  So basically we want to walk\n-    // backwards from the tail of each vector and find the first point\n-    // where they diverge.  If one vector is a suffix of the other,\n-    // then the corresponding scope is a superscope of the other.\n+                (ty::re_scope(sub_scope), ty::re_free(ref fr)) => {\n+                    self.is_sub_scope(sub_scope, fr.scope_id)\n+                }\n+\n+                (ty::re_free(sub_fr), ty::re_free(super_fr)) => {\n+                    self.sub_free_region(sub_fr, super_fr)\n+                }\n \n-    if a_ancestors[a_index] != b_ancestors[b_index] {\n-        return None;\n+                _ => {\n+                    false\n+                }\n+            }\n+        }\n     }\n \n-    loop {\n-        // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n-        // for all indices between a_index and the end of the array\n-        if a_index == 0u { return Some(scope_a); }\n-        if b_index == 0u { return Some(scope_b); }\n-        a_index -= 1u;\n-        b_index -= 1u;\n+    fn nearest_common_ancestor(&self,\n+                               scope_a: ast::node_id,\n+                               scope_b: ast::node_id) -> Option<ast::node_id>\n+    {\n+        /*!\n+         * Finds the nearest common ancestor (if any) of two scopes.  That\n+         * is, finds the smallest scope which is greater than or equal to\n+         * both `scope_a` and `scope_b`.\n+         */\n+\n+        if scope_a == scope_b { return Some(scope_a); }\n+\n+        let a_ancestors = ancestors_of(self, scope_a);\n+        let b_ancestors = ancestors_of(self, scope_b);\n+        let mut a_index = vec::len(a_ancestors) - 1u;\n+        let mut b_index = vec::len(b_ancestors) - 1u;\n+\n+        // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n+        // The end of each vector will be the item where the scope is\n+        // defined; if there are any common ancestors, then the tails of\n+        // the vector will be the same.  So basically we want to walk\n+        // backwards from the tail of each vector and find the first point\n+        // where they diverge.  If one vector is a suffix of the other,\n+        // then the corresponding scope is a superscope of the other.\n+\n         if a_ancestors[a_index] != b_ancestors[b_index] {\n-            return Some(a_ancestors[a_index + 1u]);\n+            return None;\n+        }\n+\n+        loop {\n+            // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n+            // for all indices between a_index and the end of the array\n+            if a_index == 0u { return Some(scope_a); }\n+            if b_index == 0u { return Some(scope_b); }\n+            a_index -= 1u;\n+            b_index -= 1u;\n+            if a_ancestors[a_index] != b_ancestors[b_index] {\n+                return Some(a_ancestors[a_index + 1u]);\n+            }\n+        }\n+\n+        fn ancestors_of(self: &RegionMaps, scope: ast::node_id)\n+            -> ~[ast::node_id]\n+        {\n+            let mut result = ~[scope];\n+            let mut scope = scope;\n+            loop {\n+                match self.scope_map.find(&scope) {\n+                    None => return result,\n+                    Some(&superscope) => {\n+                        result.push(superscope);\n+                        scope = superscope;\n+                    }\n+                }\n+            }\n         }\n     }\n }\n@@ -205,8 +334,7 @@ pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n /// Records the current parent (if any) as the parent of `child_id`.\n pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n-        debug!(\"parent of node %d is node %d\", child_id, *parent_id);\n-        cx.region_map.insert(child_id, *parent_id);\n+        cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n@@ -328,7 +456,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n     // Record the ID of `self`.\n     match *fk {\n         visit::fk_method(_, _, method) => {\n-            cx.region_map.insert(method.self_id, body.node.id);\n+            cx.region_maps.record_parent(method.self_id, body.node.id);\n         }\n         _ => {}\n     }\n@@ -338,19 +466,23 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n            body.node.id, cx.parent, fn_cx.parent);\n \n     for decl.inputs.each |input| {\n-        cx.region_map.insert(input.id, body.node.id);\n+        cx.region_maps.record_parent(input.id, body.node.id);\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n }\n \n pub fn resolve_crate(sess: Session,\n                      def_map: resolve::DefMap,\n-                     crate: @ast::crate)\n-                  -> region_map {\n+                     crate: @ast::crate) -> @mut RegionMaps\n+{\n+    let region_maps = @mut RegionMaps {\n+        scope_map: HashMap::new(),\n+        free_region_map: HashMap::new()\n+    };\n     let cx: ctxt = ctxt {sess: sess,\n                          def_map: def_map,\n-                         region_map: @mut HashMap::new(),\n+                         region_maps: region_maps,\n                          root_exprs: @mut HashSet::new(),\n                          parent: None};\n     let visitor = visit::mk_vt(@visit::Visitor {\n@@ -365,7 +497,7 @@ pub fn resolve_crate(sess: Session,\n         .. *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, cx, visitor);\n-    return cx.region_map;\n+    return region_maps;\n }\n \n // ___________________________________________________________________________\n@@ -412,10 +544,6 @@ pub struct DetermineRpCtxt {\n     // see long discussion on region_is_relevant().\n     anon_implies_rp: bool,\n \n-    // true when we are not within an &self method.\n-    // see long discussion on region_is_relevant().\n-    self_implies_rp: bool,\n-\n     // encodes the context of the current type; invariant if\n     // mutable, covariant otherwise\n     ambient_variance: region_variance,\n@@ -557,7 +685,7 @@ pub impl DetermineRpCtxt {\n                 false\n             }\n             Some(ref l) if l.ident == special_idents::self_ => {\n-                self.self_implies_rp\n+                true\n             }\n             Some(_) => {\n                 false\n@@ -568,23 +696,18 @@ pub impl DetermineRpCtxt {\n     fn with(@mut self,\n             item_id: ast::node_id,\n             anon_implies_rp: bool,\n-            self_implies_rp: bool,\n             f: &fn()) {\n         let old_item_id = self.item_id;\n         let old_anon_implies_rp = self.anon_implies_rp;\n-        let old_self_implies_rp = self.self_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        self.self_implies_rp = self_implies_rp;\n-        debug!(\"with_item_id(%d, %b, %b)\",\n+        debug!(\"with_item_id(%d, %b)\",\n                item_id,\n-               anon_implies_rp,\n-               self_implies_rp);\n+               anon_implies_rp);\n         let _i = ::util::common::indenter();\n         f();\n         self.item_id = old_item_id;\n         self.anon_implies_rp = old_anon_implies_rp;\n-        self.self_implies_rp = old_self_implies_rp;\n     }\n \n     fn with_ambient_variance(@mut self, variance: region_variance, f: &fn()) {\n@@ -598,7 +721,7 @@ pub impl DetermineRpCtxt {\n pub fn determine_rp_in_item(item: @ast::item,\n                             &&cx: @mut DetermineRpCtxt,\n                             visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(item.id, true, true) {\n+    do cx.with(item.id, true) {\n         visit::visit_item(item, cx, visitor);\n     }\n }\n@@ -610,12 +733,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           _: ast::node_id,\n                           &&cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    let self_implies_rp = match fk {\n-        &visit::fk_method(_, _, m) => !m.self_ty.node.is_borrowed(),\n-        _ => true\n-    };\n-\n-    do cx.with(cx.item_id, false, self_implies_rp) {\n+    do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.each |a| {\n                 (visitor.visit_ty)(a.ty, cx, visitor);\n@@ -631,7 +749,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n                                  &&cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n-    do cx.with(cx.item_id, false, !ty_m.self_ty.node.is_borrowed()) {\n+    do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n@@ -736,7 +854,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n       ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n-        do cx.with(cx.item_id, false, true) {\n+        do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.each |a| {\n@@ -797,7 +915,6 @@ pub fn determine_rp_in_crate(sess: Session,\n         worklist: ~[],\n         item_id: 0,\n         anon_implies_rp: false,\n-        self_implies_rp: true,\n         ambient_variance: rv_covariant\n     };\n "}, {"sha": "35257f9574c366a33815214613a8f8492d92262d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -62,22 +62,7 @@ impl EffectfulSubst for ty::t {\n             _ => {\n                 ty::fold_regions_and_ty(\n                     tcx, *self,\n-                    |r| match r {\n-                        ty::re_bound(ty::br_self) => {\n-                            match substs.self_r {\n-                                None => {\n-                                    tcx.sess.bug(\n-                                        fmt!(\"ty::subst: \\\n-                                              Reference to self region when \\\n-                                              given substs with no self region, \\\n-                                              ty = %s\",\n-                                             self.repr(tcx)));\n-                                }\n-                                Some(self_r) => self_r\n-                            }\n-                        }\n-                        _ => r\n-                    },\n+                    |r| r.subst(tcx, substs),\n                     |t| t.effectfulSubst(tcx, substs),\n                     |t| t.effectfulSubst(tcx, substs))\n             }\n@@ -118,7 +103,7 @@ impl Subst for ty::TraitRef {\n impl Subst for ty::substs {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::substs {\n         ty::substs {\n-            self_r: self.self_r,\n+            self_r: self.self_r.subst(tcx, substs),\n             self_ty: self.self_ty.map(|typ| typ.subst(tcx, substs)),\n             tps: self.tps.map(|typ| typ.subst(tcx, substs))\n         }\n@@ -166,6 +151,34 @@ impl Subst for ty::Generics {\n     }\n }\n \n+impl Subst for ty::Region {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n+        // Note: This routine only handles the self region, because it\n+        // is only concerned with substitutions of regions that appear\n+        // in types. Region substitution of the bound regions that\n+        // appear in a function signature is done using the\n+        // specialized routine\n+        // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n+        // As we transition to the new region syntax this distinction\n+        // will most likely disappear.\n+        match self {\n+            &ty::re_bound(ty::br_self) => {\n+                match substs.self_r {\n+                    None => {\n+                        tcx.sess.bug(\n+                            fmt!(\"ty::Region#subst(): \\\n+                                  Reference to self region when \\\n+                                  given substs with no self region: %s\",\n+                                 substs.repr(tcx)));\n+                    }\n+                    Some(self_r) => self_r\n+                }\n+            }\n+            _ => *self\n+        }\n+    }\n+}\n+\n impl Subst for ty::ty_param_bounds_and_ty {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::ty_param_bounds_and_ty {\n         ty::ty_param_bounds_and_ty {"}, {"sha": "a26c1c1e766359044653fc1bc843d3d33b40dae3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -24,8 +24,7 @@ use middle::subst::Subst;\n use middle::typeck;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n-use util::ppaux::{region_to_str, vstore_to_str};\n-use util::ppaux::{trait_store_to_str, ty_to_str, tys_to_str};\n+use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::Repr;\n use util::common::{indenter};\n \n@@ -241,7 +240,7 @@ struct ctxt_ {\n     sess: session::Session,\n     def_map: resolve::DefMap,\n \n-    region_map: middle::region::region_map,\n+    region_maps: @mut middle::region::RegionMaps,\n     region_paramd_items: middle::region::region_paramd_items,\n \n     // Stores the types for various nodes in the AST.  Note that this table\n@@ -411,7 +410,7 @@ pub struct param_ty {\n /// Representation of regions:\n #[auto_encode]\n #[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -427,7 +426,7 @@ pub enum Region {\n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    re_free(node_id, bound_region),\n+    re_free(FreeRegion),\n \n     /// A concrete region naming some expression within the current function.\n     re_scope(node_id),\n@@ -439,9 +438,26 @@ pub enum Region {\n     re_infer(InferRegion)\n }\n \n+pub impl Region {\n+    fn is_bound(&self) -> bool {\n+        match self {\n+            &re_bound(*) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n #[auto_encode]\n #[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n+pub struct FreeRegion {\n+    scope_id: node_id,\n+    bound_region: bound_region\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving(Eq, IterBytes)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -811,7 +827,7 @@ pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n-               region_map: middle::region::region_map,\n+               region_maps: @mut middle::region::RegionMaps,\n                region_paramd_items: middle::region::region_paramd_items,\n                +lang_items: middle::lang_items::LanguageItems,\n                crate: @ast::crate)\n@@ -838,7 +854,7 @@ pub fn mk_ctxt(s: session::Session,\n         cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n-        region_map: region_map,\n+        region_maps: region_maps,\n         region_paramd_items: region_paramd_items,\n         node_types: @mut SmallIntMap::new(),\n         node_type_substs: @mut HashMap::new(),\n@@ -1177,15 +1193,6 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n     }\n }\n \n-// Returns the narrowest lifetime enclosing the evaluation of the expression\n-// with id `id`.\n-pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n-    match cx.region_map.find(&id) {\n-      Some(&encl_scope) => ty::re_scope(encl_scope),\n-      None => ty::re_static\n-    }\n-}\n-\n pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1309,8 +1316,8 @@ pub fn walk_regions_and_ty(\n         fold_regions_and_ty(\n             cx, ty,\n             |r| { walkr(r); r },\n-            |t| { walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t },\n-            |t| { walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t });\n+            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t },\n+            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t });\n     }\n }\n \n@@ -2507,43 +2514,52 @@ pub fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     }\n }\n \n-impl to_bytes::IterBytes for bound_region {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          ty::br_self => 0u8.iter_bytes(lsb0, f),\n-\n-          ty::br_anon(ref idx) =>\n-          to_bytes::iter_bytes_2(&1u8, idx, lsb0, f),\n-\n-          ty::br_named(ref ident) =>\n-          to_bytes::iter_bytes_2(&2u8, ident, lsb0, f),\n+/**\n+ * Enforces an arbitrary but consistent total ordering over\n+ * free regions.  This is needed for establishing a consistent\n+ * LUB in region_inference. */\n+impl cmp::TotalOrd for FreeRegion {\n+    fn cmp(&self, other: &FreeRegion) -> Ordering {\n+        cmp::cmp2(&self.scope_id, &self.bound_region,\n+                  &other.scope_id, &other.bound_region)\n+    }\n+}\n \n-          ty::br_cap_avoid(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f),\n+impl cmp::TotalEq for FreeRegion {\n+    fn equals(&self, other: &FreeRegion) -> bool {\n+        *self == *other\n+    }\n+}\n \n-          ty::br_fresh(ref x) =>\n-          to_bytes::iter_bytes_2(&4u8, x, lsb0, f)\n+/**\n+ * Enforces an arbitrary but consistent total ordering over\n+ * bound regions.  This is needed for establishing a consistent\n+ * LUB in region_inference. */\n+impl cmp::TotalOrd for bound_region {\n+    fn cmp(&self, other: &bound_region) -> Ordering {\n+        match (self, other) {\n+            (&ty::br_self, &ty::br_self) => cmp::Equal,\n+            (&ty::br_self, _) => cmp::Less,\n+\n+            (&ty::br_anon(ref a1), &ty::br_anon(ref a2)) => a1.cmp(a2),\n+            (&ty::br_anon(*), _) => cmp::Less,\n+\n+            (&ty::br_named(ref a1), &ty::br_named(ref a2)) => a1.repr.cmp(&a2.repr),\n+            (&ty::br_named(*), _) => cmp::Less,\n+\n+            (&ty::br_cap_avoid(ref a1, @ref b1),\n+             &ty::br_cap_avoid(ref a2, @ref b2)) => cmp::cmp2(a1, b1, a2, b2),\n+            (&ty::br_cap_avoid(*), _) => cmp::Less,\n+\n+            (&ty::br_fresh(ref a1), &ty::br_fresh(ref a2)) => a1.cmp(a2),\n+            (&ty::br_fresh(*), _) => cmp::Less,\n         }\n     }\n }\n \n-impl to_bytes::IterBytes for Region {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          re_bound(ref br) =>\n-          to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n-\n-          re_free(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&1u8, id, br, lsb0, f),\n-\n-          re_scope(ref id) =>\n-          to_bytes::iter_bytes_2(&2u8, id, lsb0, f),\n-\n-          re_infer(ref id) =>\n-          to_bytes::iter_bytes_2(&3u8, id, lsb0, f),\n-\n-          re_static => 4u8.iter_bytes(lsb0, f)\n-        }\n+impl cmp::TotalEq for bound_region {\n+    fn equals(&self, other: &bound_region) -> bool {\n+        *self == *other\n     }\n }\n \n@@ -2857,8 +2873,17 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n      */\n \n     let unadjusted_ty = expr_ty(cx, expr);\n+    adjust_ty(cx, expr.span, unadjusted_ty, cx.adjustments.find(&expr.id))\n+}\n+\n+pub fn adjust_ty(cx: ctxt,\n+                 span: span,\n+                 unadjusted_ty: ty::t,\n+                 adjustment: Option<&@AutoAdjustment>) -> ty::t\n+{\n+    /*! See `expr_ty_adjusted` */\n \n-    return match cx.adjustments.find(&expr.id) {\n+    return match adjustment {\n         None => unadjusted_ty,\n \n         Some(&@AutoAddEnv(r, s)) => {\n@@ -2887,7 +2912,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n                     Some(mt) => { adjusted_ty = mt.ty; }\n                     None => {\n                         cx.sess.span_bug(\n-                            expr.span,\n+                            span,\n                             fmt!(\"The %uth autoderef failed: %s\",\n                                  i, ty_to_str(cx,\n                                               adjusted_ty)));\n@@ -2906,26 +2931,26 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n                         }\n \n                         AutoBorrowVec => {\n-                            borrow_vec(cx, expr, autoref, adjusted_ty)\n+                            borrow_vec(cx, span, autoref, adjusted_ty)\n                         }\n \n                         AutoBorrowVecRef => {\n-                            adjusted_ty = borrow_vec(cx, expr, autoref,\n+                            adjusted_ty = borrow_vec(cx, span, autoref,\n                                                      adjusted_ty);\n                             mk_rptr(cx, autoref.region,\n                                     mt {ty: adjusted_ty, mutbl: ast::m_imm})\n                         }\n \n                         AutoBorrowFn => {\n-                            borrow_fn(cx, expr, autoref, adjusted_ty)\n+                            borrow_fn(cx, span, autoref, adjusted_ty)\n                         }\n                     }\n                 }\n             }\n         }\n     };\n \n-    fn borrow_vec(cx: ctxt, expr: @ast::expr,\n+    fn borrow_vec(cx: ctxt, span: span,\n                   autoref: &AutoRef, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_evec(mt, _) => {\n@@ -2939,14 +2964,14 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n \n             ref s => {\n                 cx.sess.span_bug(\n-                    expr.span,\n+                    span,\n                     fmt!(\"borrow-vec associated with bad sty: %?\",\n                          s));\n             }\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, expr: @ast::expr,\n+    fn borrow_fn(cx: ctxt, span: span,\n                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n@@ -2959,7 +2984,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n \n             ref s => {\n                 cx.sess.span_bug(\n-                    expr.span,\n+                    span,\n                     fmt!(\"borrow-fn associated with bad sty: %?\",\n                          s));\n             }"}, {"sha": "6b09133e73a11d04f902cd7561c8f21e11f747d2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 133, "deletions": 150, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -178,15 +178,6 @@ pub struct Candidate {\n     origin: method_origin,\n }\n \n-/**\n- * How the self type should be transformed according to the form of explicit\n- * self provided by the method.\n- */\n-pub enum TransformTypeFlag {\n-    TransformTypeNormally,\n-    TransformTypeForObject,\n-}\n-\n pub impl<'self> LookupContext<'self> {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let mut self_ty = structurally_resolved_type(self.fcx,\n@@ -285,13 +276,13 @@ pub impl<'self> LookupContext<'self> {\n \n     fn push_inherent_candidates(&self, self_ty: ty::t) {\n         /*!\n-         *\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n          * the file.  To find the inherent candidates, we repeatedly\n          * deref the self-ty to find the \"base-type\".  So, for\n          * example, if the receiver is @@C where `C` is a struct type,\n-         * we'll want to find the inherent impls for `C`. */\n+         * we'll want to find the inherent impls for `C`.\n+         */\n \n         let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n@@ -407,16 +398,9 @@ pub impl<'self> LookupContext<'self> {\n             };\n             let method = trait_methods[pos];\n \n-            let (rcvr_ty, rcvr_substs) =\n-                self.create_rcvr_ty_and_substs_for_method(\n-                    method.self_ty,\n-                    rcvr_ty,\n-                    copy bound_trait_ref.substs,\n-                    TransformTypeNormally);\n-\n             let cand = Candidate {\n                 rcvr_ty: rcvr_ty,\n-                rcvr_substs: rcvr_substs,\n+                rcvr_substs: copy bound_trait_ref.substs,\n                 method_ty: method,\n                 origin: method_param(\n                     method_param {\n@@ -476,14 +460,8 @@ pub impl<'self> LookupContext<'self> {\n             ../*bad*/copy *substs\n         };\n \n-        let (rcvr_ty, rcvr_substs) =\n-            self.create_rcvr_ty_and_substs_for_method(method.self_ty,\n-                                                      self_ty,\n-                                                      rcvr_substs,\n-                                                      TransformTypeForObject);\n-\n         self.inherent_candidates.push(Candidate {\n-            rcvr_ty: rcvr_ty,\n+            rcvr_ty: self_ty,\n             rcvr_substs: rcvr_substs,\n             method_ty: method,\n             origin: method_trait(did, index, store)\n@@ -538,19 +516,13 @@ pub impl<'self> LookupContext<'self> {\n                 // We've found a method -- return it\n                 let rcvr_substs = substs {self_ty: Some(self_ty),\n                                           ..copy *substs };\n-                let (rcvr_ty, rcvr_substs) =\n-                    self.create_rcvr_ty_and_substs_for_method(\n-                        info.method_ty.self_ty,\n-                        self_ty,\n-                        rcvr_substs,\n-                        TransformTypeNormally);\n                 let origin = if did == info.trait_def_id {\n                     method_self(info.trait_def_id, info.index)\n                 } else {\n                     method_super(info.trait_def_id, info.index)\n                 };\n                 self.inherent_candidates.push(Candidate {\n-                    rcvr_ty: rcvr_ty,\n+                    rcvr_ty: self_ty,\n                     rcvr_substs: rcvr_substs,\n                     method_ty: info.method_ty,\n                     origin: origin\n@@ -598,13 +570,6 @@ pub impl<'self> LookupContext<'self> {\n             ty: impl_ty\n         } = impl_self_ty(&vcx, location_info, impl_info.did);\n \n-        let (impl_ty, impl_substs) =\n-            self.create_rcvr_ty_and_substs_for_method(\n-                method.self_ty,\n-                impl_ty,\n-                impl_substs,\n-                TransformTypeNormally);\n-\n         candidates.push(Candidate {\n             rcvr_ty: impl_ty,\n             rcvr_substs: impl_substs,\n@@ -639,69 +604,16 @@ pub impl<'self> LookupContext<'self> {\n                 self_ty: None,\n                 tps: ~[]\n             };\n-            let (impl_ty, impl_substs) =\n-                self.create_rcvr_ty_and_substs_for_method(\n-                    method.self_ty,\n-                    self_ty,\n-                    dummy_substs,\n-                    TransformTypeNormally);\n \n             candidates.push(Candidate {\n-                rcvr_ty: impl_ty,\n-                rcvr_substs: impl_substs,\n+                rcvr_ty: self_ty,\n+                rcvr_substs: dummy_substs,\n                 method_ty: method,\n                 origin: method_static(provided_method_info.method_info.did)\n             });\n         }\n     }\n \n-    fn create_rcvr_ty_and_substs_for_method(&self,\n-                                            self_decl: ast::self_ty_,\n-                                            self_ty: ty::t,\n-                                            +self_substs: ty::substs,\n-                                            transform_type: TransformTypeFlag)\n-                                         -> (ty::t, ty::substs) {\n-        // If the self type includes a region (like &self), we need to\n-        // ensure that the receiver substitutions have a self region.\n-        // If the receiver type does not itself contain borrowed\n-        // pointers, there may not be one yet.\n-        //\n-        // FIXME(#3446)--this awkward situation comes about because\n-        // the regions in the receiver are substituted before (and\n-        // differently from) those in the argument types.  This\n-        // shouldn't really have to be.\n-        let rcvr_substs = {\n-            match self_decl {\n-                sty_static | sty_value |\n-                sty_box(_) | sty_uniq(_) => {\n-                    self_substs\n-                }\n-                sty_region(*) if self_substs.self_r.is_some() => {\n-                    // FIXME(#4846) ignoring expl lifetime here\n-                    self_substs\n-                }\n-                sty_region(*) => {\n-                    // FIXME(#4846) ignoring expl lifetime here\n-                    substs {\n-                        self_r:\n-                             Some(self.infcx().next_region_var(\n-                                 self.expr.span,\n-                                 self.expr.id)),\n-                        ..self_substs\n-                    }\n-                }\n-            }\n-        };\n-\n-        let rcvr_ty = transform_self_type_for_method(self.tcx(),\n-                                                     rcvr_substs.self_r,\n-                                                     self_ty,\n-                                                     self_decl,\n-                                                     transform_type);\n-\n-        (rcvr_ty, rcvr_substs)\n-    }\n-\n     // ______________________________________________________________________\n     // Candidate selection (see comment at start of file)\n \n@@ -1036,20 +948,34 @@ pub impl<'self> LookupContext<'self> {\n         self.enforce_trait_instance_limitations(fty, candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n-        // before we only checked whether self_ty could be a subtype\n-        // of rcvr_ty; now we actually make it so (this may cause\n-        // variables to unify etc).  Since we checked beforehand, and\n-        // nothing has changed in the meantime, this unification\n-        // should never fail.\n-        match self.fcx.mk_subty(false, self.self_expr.span,\n-                                self_ty, candidate.rcvr_ty) {\n-            result::Ok(_) => (),\n-            result::Err(_) => {\n-                self.bug(fmt!(\"%s was assignable to %s but now is not?\",\n-                              self.ty_to_str(self_ty),\n-                              self.ty_to_str(candidate.rcvr_ty)));\n+        // static methods should never have gotten this far:\n+        assert!(candidate.method_ty.self_ty != sty_static);\n+\n+        let transformed_self_ty = match candidate.origin {\n+            method_trait(*) => {\n+                match candidate.method_ty.self_ty {\n+                    sty_region(*) => {\n+                        // FIXME(#5762) again, preserving existing\n+                        // behavior here which (for &self) desires\n+                        // &@Trait where @Trait is the type of the\n+                        // receiver.  Here we fetch the method's\n+                        // transformed_self_ty which will be something\n+                        // like &'a Self.  We then perform a\n+                        // substitution which will replace Self with\n+                        // @Trait.\n+                        let t = candidate.method_ty.transformed_self_ty.get();\n+                        ty::subst(tcx, &candidate.rcvr_substs, t)\n+                    }\n+                    _ => {\n+                        candidate.rcvr_ty\n+                    }\n+                }\n             }\n-        }\n+            _ => {\n+                let t = candidate.method_ty.transformed_self_ty.get();\n+                ty::subst(tcx, &candidate.rcvr_substs, t)\n+            }\n+        };\n \n         // Determine the values for the type parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -1100,16 +1026,32 @@ pub impl<'self> LookupContext<'self> {\n                     fmt!(\"Invoking method with non-bare-fn ty: %?\", s));\n             }\n         };\n-        let (_, _, fn_sig) =\n+        let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n-                tcx, @Nil, None, &bare_fn_ty.sig,\n+                tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n                 |_br| self.fcx.infcx().next_region_var(\n                     self.expr.span, self.expr.id));\n+        let transformed_self_ty = opt_transformed_self_ty.get();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n \n         let self_mode = get_mode_from_self_type(candidate.method_ty.self_ty);\n \n+        // before we only checked whether self_ty could be a subtype\n+        // of rcvr_ty; now we actually make it so (this may cause\n+        // variables to unify etc).  Since we checked beforehand, and\n+        // nothing has changed in the meantime, this unification\n+        // should never fail.\n+        match self.fcx.mk_subty(false, self.self_expr.span,\n+                                self_ty, transformed_self_ty) {\n+            result::Ok(_) => (),\n+            result::Err(_) => {\n+                self.bug(fmt!(\"%s was a subtype of %s but now is not?\",\n+                              self.ty_to_str(self_ty),\n+                              self.ty_to_str(transformed_self_ty)));\n+            }\n+        }\n+\n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n@@ -1180,7 +1122,87 @@ pub impl<'self> LookupContext<'self> {\n         debug!(\"is_relevant(self_ty=%s, candidate=%s)\",\n                self.ty_to_str(self_ty), self.cand_to_str(candidate));\n \n-        self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n+        // Check for calls to object methods.  We resolve these differently.\n+        //\n+        // FIXME(#5762)---we don't check that an @self method is only called\n+        // on an @Trait object here and so forth\n+        match candidate.origin {\n+            method_trait(*) => {\n+                match candidate.method_ty.self_ty {\n+                    sty_static | sty_value => {\n+                        return false;\n+                    }\n+                    sty_region(*) => {\n+                        // just echoing current behavior here, which treats\n+                        // an &self method on an @Trait object as requiring\n+                        // an &@Trait receiver (wacky)\n+                    }\n+                    sty_box(*) | sty_uniq(*) => {\n+                        return self.fcx.can_mk_subty(self_ty,\n+                                                     candidate.rcvr_ty).is_ok();\n+                    }\n+                };\n+            }\n+            _ => {}\n+        }\n+\n+        return match candidate.method_ty.self_ty {\n+            sty_static => {\n+                false\n+            }\n+\n+            sty_value => {\n+                self.fcx.can_mk_subty(self_ty, candidate.rcvr_ty).is_ok()\n+            }\n+\n+            sty_region(_, m) => {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_rptr(_, mt) => {\n+                        mutability_matches(mt.mutbl, m) &&\n+                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                    }\n+\n+                    _ => false\n+                }\n+            }\n+\n+            sty_box(m) => {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_box(mt) => {\n+                        mutability_matches(mt.mutbl, m) &&\n+                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                    }\n+\n+                    _ => false\n+                }\n+            }\n+\n+            sty_uniq(m) => {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_uniq(mt) => {\n+                        mutability_matches(mt.mutbl, m) &&\n+                        self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n+                    }\n+\n+                    _ => false\n+                }\n+            }\n+        };\n+\n+        fn mutability_matches(self_mutbl: ast::mutability,\n+                              candidate_mutbl: ast::mutability) -> bool {\n+            //! True if `self_mutbl <: candidate_mutbl`\n+\n+            match (self_mutbl, candidate_mutbl) {\n+                (_, m_const) => true,\n+                (m_mutbl, m_mutbl) => true,\n+                (m_imm, m_imm) => true,\n+                (m_mutbl, m_imm) => false,\n+                (m_imm, m_mutbl) => false,\n+                (m_const, m_imm) => false,\n+                (m_const, m_mutbl) => false,\n+            }\n+        }\n     }\n \n     fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n@@ -1281,45 +1303,6 @@ pub impl<'self> LookupContext<'self> {\n     }\n }\n \n-pub fn transform_self_type_for_method(tcx: ty::ctxt,\n-                                      self_region: Option<ty::Region>,\n-                                      impl_ty: ty::t,\n-                                      self_type: ast::self_ty_,\n-                                      flag: TransformTypeFlag)\n-                                   -> ty::t {\n-    match self_type {\n-      sty_static => {\n-        tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n-                       static method\");\n-      }\n-      sty_value => {\n-        impl_ty\n-      }\n-      sty_region(_, mutability) => {\n-        // FIXME(#4846) ignoring expl lifetime here\n-        mk_rptr(tcx,\n-                self_region.expect(~\"self region missing for &self param\"),\n-                ty::mt { ty: impl_ty, mutbl: mutability })\n-      }\n-      sty_box(mutability) => {\n-        match flag {\n-            TransformTypeNormally => {\n-                mk_box(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n-            }\n-            TransformTypeForObject => impl_ty\n-        }\n-      }\n-      sty_uniq(mutability) => {\n-        match flag {\n-            TransformTypeNormally => {\n-                mk_uniq(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n-            }\n-            TransformTypeForObject => impl_ty\n-        }\n-      }\n-    }\n-}\n-\n pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n     match self_type { sty_value => by_copy, _ => by_ref }\n }"}, {"sha": "2d1c940103a7acc7d8875dfdb1659165dd4fec75", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -93,16 +93,15 @@ use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{CheckTraitsOnly, DontAutoderefReceiver};\n-use middle::typeck::check::method::{TransformTypeNormally};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::bound_self_region;\n-use middle::typeck::rscope::{RegionError, RegionParameterization};\n+use middle::typeck::rscope::{RegionError};\n use middle::typeck::rscope::region_scope;\n-use middle::typeck::rscope;\n use middle::typeck::{isr_alist, lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n@@ -279,7 +278,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n }\n \n pub fn check_fn(ccx: @mut CrateCtxt,\n-                +self_info: Option<SelfInfo>,\n+                opt_self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n@@ -306,19 +305,28 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     // First, we have to replace any bound regions in the fn and self\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n-\n-    let (isr, self_info, fn_sig) = {\n-        replace_bound_regions_in_fn_sig(tcx, inherited_isr, self_info, fn_sig,\n-                                        |br| ty::re_free(body.node.id, br))\n+    let (isr, opt_self_info, fn_sig) = {\n+        let opt_self_ty = opt_self_info.map(|i| i.self_ty);\n+        let (isr, opt_self_ty, fn_sig) =\n+            replace_bound_regions_in_fn_sig(\n+                tcx, inherited_isr, opt_self_ty, fn_sig,\n+                |br| ty::re_free(ty::FreeRegion {scope_id: body.node.id,\n+                                                 bound_region: br}));\n+        let opt_self_info =\n+            opt_self_info.map(\n+                |si| SelfInfo {self_ty: opt_self_ty.get(), ..*si});\n+        (isr, opt_self_info, fn_sig)\n     };\n \n+    relate_free_regions(tcx, opt_self_info.map(|s| s.self_ty), &fn_sig);\n+\n     let arg_tys = fn_sig.inputs.map(|a| a.ty);\n     let ret_ty = fn_sig.output;\n \n-    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n-           arg_tys.map(|a| ppaux::ty_to_str(tcx, *a)),\n+    debug!(\"check_fn(arg_tys=%?, ret_ty=%?, opt_self_ty=%?)\",\n+           arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n            ppaux::ty_to_str(tcx, ret_ty),\n-           self_info.map(|s| ppaux::ty_to_str(tcx, s.self_ty)));\n+           opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -343,7 +351,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         }\n     };\n \n-    gather_locals(fcx, decl, body, arg_tys, self_info);\n+    gather_locals(fcx, decl, body, arg_tys, opt_self_info);\n     check_block_with_expected(fcx, body, Some(ret_ty));\n \n     // We unify the tail expr's type with the\n@@ -361,7 +369,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n       None => ()\n     }\n \n-    for self_info.each |self_info| {\n+    for opt_self_info.each |self_info| {\n         fcx.write_ty(self_info.self_id, self_info.self_ty);\n     }\n     for vec::each2(decl.inputs, arg_tys) |input, arg| {\n@@ -374,7 +382,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      arg_tys: &[ty::t],\n-                     self_info: Option<SelfInfo>) {\n+                     opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n \n         let assign: @fn(ast::node_id, Option<ty::t>) = |nid, ty_opt| {\n@@ -393,7 +401,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add the self parameter\n-        for self_info.each |self_info| {\n+        for opt_self_info.each |self_info| {\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n@@ -479,26 +487,22 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n }\n \n pub fn check_method(ccx: @mut CrateCtxt,\n-                    method: @ast::method,\n-                    self_ty: ty::t)\n+                    method: @ast::method)\n {\n-    let self_info = if method.self_ty.node == ast::sty_static {None} else {\n-        let ty = method::transform_self_type_for_method(\n-            ccx.tcx,\n-            Some(ty::re_bound(ty::br_self)),\n-            self_ty,\n-            method.self_ty.node,\n-            TransformTypeNormally);\n-        Some(SelfInfo {self_ty: ty, self_id: method.self_id,\n-                       span: method.self_ty.span})\n-    };\n+    let method_def_id = local_def(method.id);\n+    let method_ty = ty::method(ccx.tcx, method_def_id);\n+    let opt_self_info = method_ty.transformed_self_ty.map(|&ty| {\n+        SelfInfo {self_ty: ty,\n+                  self_id: method.self_id,\n+                  span: method.self_ty.span}\n+    });\n \n     check_bare_fn(\n         ccx,\n         &method.decl,\n         &method.body,\n         method.id,\n-        self_info\n+        opt_self_info\n     );\n }\n \n@@ -570,15 +574,12 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_fn(ref decl, _, _, _, ref body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n-      ast::item_impl(ref generics, _, ty, ref ms) => {\n+      ast::item_impl(_, _, _, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n-        let rp = RegionParameterization::from_variance_and_generics(\n-            rp, generics);\n-        let self_ty = ccx.to_ty(&rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n-            check_method(ccx, *m, self_ty);\n+            check_method(ccx, *m);\n         }\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n@@ -589,8 +590,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                 // bodies to check.\n               }\n               provided(m) => {\n-                let self_ty = ty::mk_self(ccx.tcx, local_def(it.id));\n-                check_method(ccx, m, self_ty);\n+                check_method(ccx, m);\n               }\n             }\n         }\n@@ -2841,8 +2841,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n         _ => {}\n     }\n \n-    let region =\n-        ty::re_scope(*tcx.region_map.get(&local.node.id));\n+    let region = tcx.region_maps.encl_region(local.node.id);\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),"}, {"sha": "5594f2a0f658b0e15eb77658ac66a55c5283114e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 234, "deletions": 71, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -31,13 +31,15 @@ use core::prelude::*;\n \n use middle::freevars::get_freevars;\n use middle::pat_util::pat_bindings;\n-use middle::ty::{encl_region, re_scope};\n+use middle::ty::{re_scope};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::lookup_def;\n+use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n-use util::ppaux::{note_and_explain_region, ty_to_str};\n+use util::ppaux::{note_and_explain_region, ty_to_str,\n+                  region_to_str};\n \n use core::result;\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n@@ -53,12 +55,13 @@ pub struct Rcx {\n \n pub type rvt = visit::vt<@mut Rcx>;\n \n-pub fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n+fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         def_local(node_id, _) | def_arg(node_id, _, _) |\n-        def_self(node_id, _) | def_binding(node_id, _) =>\n-            return encl_region(tcx, node_id),\n+        def_self(node_id, _) | def_binding(node_id, _) => {\n+            tcx.region_maps.encl_region(node_id)\n+        }\n         def_upvar(_, subdef, closure_id, body_id) => {\n             match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n                 BorrowedSigil => encl_region_of_def(fcx, *subdef),\n@@ -113,6 +116,24 @@ pub impl Rcx {\n     fn resolve_node_type(@mut self, id: ast::node_id) -> ty::t {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n+\n+    /// Try to resolve the type for the given node.\n+    fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n+        let ty_unadjusted = self.resolve_node_type(expr.id);\n+        if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n+            ty_unadjusted\n+        } else {\n+            let tcx = self.fcx.tcx();\n+            let adjustments = self.fcx.inh.adjustments;\n+            match adjustments.find(&expr.id) {\n+                None => ty_unadjusted,\n+                Some(&adjustment) => {\n+                    // FIXME(#3850) --- avoid region scoping errors\n+                    ty::adjust_ty(tcx, expr.span, ty_unadjusted, Some(&adjustment))\n+                }\n+            }\n+        }\n+    }\n }\n \n pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n@@ -129,7 +150,7 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_visitor() -> rvt {\n+fn regionck_visitor() -> rvt {\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n                                   visit_stmt: visit_stmt,\n                                   visit_expr: visit_expr,\n@@ -138,11 +159,11 @@ pub fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-pub fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n+fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     // Check to make sure that the regions in all local variables are\n     // within scope.\n     //\n@@ -173,19 +194,24 @@ pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     }\n }\n \n-pub fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n-    debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n+fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n+    debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n+        debug!(\"adjustment=%?\", adjustment);\n         match *adjustment {\n             @ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoderefs: autoderefs, autoref: Some(ref autoref)}) => {\n-                guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+                ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n+            {\n+                let expr_ty = rcx.resolve_node_type(expr.id);\n+                constrain_derefs(rcx, expr, autoderefs, expr_ty);\n+                for opt_autoref.each |autoref| {\n+                    guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+                }\n             }\n             _ => {}\n         }\n@@ -271,6 +297,16 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n             }\n         }\n \n+        ast::expr_index(vec_expr, _) => {\n+            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n+            constrain_index(rcx, expr, vec_type);\n+        }\n+\n+        ast::expr_unary(ast::deref, base) => {\n+            let base_ty = rcx.resolve_node_type(base.id);\n+            constrain_derefs(rcx, expr, 1, base_ty);\n+        }\n+\n         ast::expr_addr_of(_, base) => {\n             guarantor::for_addr_of(rcx, expr, base);\n         }\n@@ -297,11 +333,11 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_expr(expr, rcx, v);\n }\n \n-pub fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n-pub fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n+fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n     /*!\n      *\n      * checks the type of the node `id` and reports an error if it\n@@ -314,13 +350,119 @@ pub fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n \n     // find the region where this expr evaluation is taking place\n     let tcx = fcx.ccx.tcx;\n-    let encl_region = ty::encl_region(tcx, id);\n+    let encl_region = match tcx.region_maps.opt_encl_scope(id) {\n+        None => ty::re_static,\n+        Some(r) => ty::re_scope(r)\n+    };\n \n     // Otherwise, look at the type and see if it is a region pointer.\n     constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n }\n \n-pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n+fn encl_region_or_static(rcx: @mut Rcx, expr: @ast::expr) -> ty::Region {\n+    // FIXME(#3850) --- interactions with modes compel overly large granularity\n+    // that is, we would probably prefer to just return re_scope(expr.id)\n+    // here but we cannot just yet.\n+\n+    let tcx = rcx.fcx.tcx();\n+    match tcx.region_maps.opt_encl_scope(expr.id) {\n+        Some(s) => ty::re_scope(s),\n+        None => ty::re_static // occurs in constants\n+    }\n+}\n+\n+fn constrain_derefs(rcx: @mut Rcx,\n+                    deref_expr: @ast::expr,\n+                    derefs: uint,\n+                    mut derefd_ty: ty::t)\n+{\n+    /*!\n+     * Invoked on any dereference that occurs, whether explicitly\n+     * or through an auto-deref.  Checks that if this is a region\n+     * pointer being derefenced, the lifetime of the pointer includes\n+     * the deref expr.\n+     */\n+\n+    let tcx = rcx.fcx.tcx();\n+    let r_deref_expr = encl_region_or_static(rcx, deref_expr);\n+    for uint::range(0, derefs) |i| {\n+        debug!(\"constrain_derefs(deref_expr=%s, derefd_ty=%s, derefs=%?/%?\",\n+               rcx.fcx.expr_to_str(deref_expr),\n+               rcx.fcx.infcx().ty_to_str(derefd_ty),\n+               i, derefs);\n+\n+        match ty::get(derefd_ty).sty {\n+            ty::ty_rptr(r_ptr, _) => {\n+                match rcx.fcx.mk_subr(true, deref_expr.span, r_deref_expr, r_ptr) {\n+                    result::Ok(*) => {}\n+                    result::Err(*) => {\n+                        tcx.sess.span_err(\n+                            deref_expr.span,\n+                            fmt!(\"dereference of reference outside its lifetime\"));\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"the reference is only valid for \",\n+                            r_ptr,\n+                            \"\");\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        match ty::deref(tcx, derefd_ty, true) {\n+            Some(mt) => derefd_ty = mt.ty,\n+            None => {\n+                tcx.sess.span_bug(\n+                    deref_expr.span,\n+                    fmt!(\"%?'th deref is of a non-deref'able type `%s`\",\n+                         i, rcx.fcx.infcx().ty_to_str(derefd_ty)));\n+            }\n+        }\n+    }\n+}\n+\n+fn constrain_index(rcx: @mut Rcx,\n+                   index_expr: @ast::expr,\n+                   indexed_ty: ty::t)\n+{\n+    /*!\n+     * Invoked on any index expression that occurs.  Checks that if\n+     * this is a slice being indexed, the lifetime of the pointer\n+     * includes the deref expr.\n+     */\n+\n+    let tcx = rcx.fcx.tcx();\n+\n+    debug!(\"constrain_index(index_expr=%s, indexed_ty=%s\",\n+           rcx.fcx.expr_to_str(index_expr),\n+           rcx.fcx.infcx().ty_to_str(indexed_ty));\n+\n+    let r_index_expr = encl_region_or_static(rcx, index_expr);\n+    match ty::get(indexed_ty).sty {\n+        ty::ty_estr(ty::vstore_slice(r_ptr)) |\n+        ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n+            match rcx.fcx.mk_subr(true, index_expr.span, r_index_expr, r_ptr) {\n+                result::Ok(*) => {}\n+                result::Err(*) => {\n+                    tcx.sess.span_err(\n+                        index_expr.span,\n+                        fmt!(\"index of slice outside its lifetime\"));\n+                    note_and_explain_region(\n+                        tcx,\n+                        \"the slice is only valid for \",\n+                        r_ptr,\n+                        \"\");\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+}\n+\n+fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     /*!\n      *\n      * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n@@ -340,7 +482,7 @@ pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     };\n \n     let tcx = rcx.fcx.tcx();\n-    let encl_region = ty::encl_region(tcx, expr.id);\n+    let encl_region = tcx.region_maps.encl_region(expr.id);\n     match rcx.fcx.mk_subr(true, expr.span, encl_region, region) {\n         result::Ok(()) => {}\n         result::Err(_) => {\n@@ -366,7 +508,7 @@ pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     }\n }\n \n-pub fn constrain_free_variables(\n+fn constrain_free_variables(\n     rcx: @mut Rcx,\n     region: ty::Region,\n     expr: @ast::expr) {\n@@ -402,81 +544,103 @@ pub fn constrain_free_variables(\n     }\n }\n \n-pub fn constrain_regions_in_type_of_node(\n+fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n     id: ast::node_id,\n     encl_region: ty::Region,\n-    span: span) -> bool {\n+    span: span) -> bool\n+{\n     let tcx = rcx.fcx.tcx();\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    let ty = rcx.resolve_node_type(id);\n+    let ty0 = rcx.resolve_node_type(id);\n+    let adjustment = rcx.fcx.inh.adjustments.find(&id);\n+    let ty = ty::adjust_ty(tcx, span, ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty=%s, id=%d, encl_region=%?)\",\n-           ty_to_str(tcx, ty), id, encl_region);\n+            ty=%s, ty0=%s, id=%d, encl_region=%?, adjustment=%?)\",\n+           ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n+           id, encl_region, adjustment);\n     constrain_regions_in_type(rcx, encl_region, span, ty)\n }\n \n-pub fn constrain_regions_in_type(\n+fn constrain_regions_in_type(\n     rcx: @mut Rcx,\n     encl_region: ty::Region,\n     span: span,\n-    ty: ty::t) -> bool {\n+    ty: ty::t) -> bool\n+{\n     /*!\n      *\n      * Requires that any regions which appear in `ty` must be\n-     * superregions of `encl_region`.  This prevents regions from\n-     * being used outside of the block in which they are valid.\n-     * Recall that regions represent blocks of code or expressions:\n-     * this requirement basically says \"any place that uses or may use\n-     * a region R must be within the block of code that R corresponds\n-     * to.\" */\n+     * superregions of `encl_region`.  Also enforces the constraint\n+     * that given a pointer type `&'r T`, T must not contain regions\n+     * that outlive 'r, as well as analogous constraints for other\n+     * lifetime'd types.\n+     *\n+     * This check prevents regions from being used outside of the block in\n+     * which they are valid.  Recall that regions represent blocks of\n+     * code or expressions: this requirement basically says \"any place\n+     * that uses or may use a region R must be within the block of\n+     * code that R corresponds to.\"\n+     */\n \n     let e = rcx.errors_reported;\n-    ty::walk_regions_and_ty(\n-        rcx.fcx.ccx.tcx, ty,\n-        |r| constrain_region(rcx, encl_region, span, r),\n-        |t| ty::type_has_regions(t));\n-    return (e == rcx.errors_reported);\n+    let tcx = rcx.fcx.ccx.tcx;\n \n-    fn constrain_region(rcx: @mut Rcx,\n-                        encl_region: ty::Region,\n-                        span: span,\n-                        region: ty::Region) {\n-        let tcx = rcx.fcx.ccx.tcx;\n+    debug!(\"constrain_regions_in_type(encl_region=%s, ty=%s)\",\n+           region_to_str(tcx, encl_region),\n+           ty_to_str(tcx, ty));\n \n-        debug!(\"constrain_region(encl_region=%?, region=%?)\",\n-               encl_region, region);\n+    do relate_nested_regions(tcx, Some(encl_region), ty) |r_sub, r_sup| {\n+        debug!(\"relate(r_sub=%s, r_sup=%s)\",\n+               region_to_str(tcx, r_sub),\n+               region_to_str(tcx, r_sup));\n \n-        match region {\n-          ty::re_bound(_) => {\n+        if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type.\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n             // constrained by `encl_region` as they are placeholders\n             // for regions that are as-yet-unknown.\n-            return;\n-          }\n-          _ => ()\n-        }\n-\n-        match rcx.fcx.mk_subr(true, span, encl_region, region) {\n-          result::Err(_) => {\n-            tcx.sess.span_err(\n-                span,\n-                fmt!(\"reference is not valid outside of its lifetime\"));\n-            note_and_explain_region(\n-                tcx,\n-                ~\"the reference is only valid for \",\n-                region,\n-                ~\"\");\n-            rcx.errors_reported += 1u;\n-          }\n-          result::Ok(()) => {\n-          }\n+        } else {\n+            match rcx.fcx.mk_subr(true, span, r_sub, r_sup) {\n+                result::Err(_) => {\n+                    if r_sub == encl_region {\n+                        tcx.sess.span_err(\n+                            span,\n+                            fmt!(\"reference is not valid outside of its lifetime\"));\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"the reference is only valid for \",\n+                            r_sup,\n+                            \"\");\n+                    } else {\n+                        tcx.sess.span_err(\n+                            span,\n+                            fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n+                                  the data it references\",\n+                                 rcx.fcx.infcx().ty_to_str(ty)));\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"the pointer is valid for \",\n+                            r_sub,\n+                            \"\");\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"but the referenced data is only valid for \",\n+                            r_sup,\n+                            \"\");\n+                    }\n+                    rcx.errors_reported += 1u;\n+                }\n+                result::Ok(()) => {\n+                }\n+            }\n         }\n     }\n+\n+    return (e == rcx.errors_reported);\n }\n \n pub mod guarantor {\n@@ -577,10 +741,12 @@ pub mod guarantor {\n          * region pointers.\n          */\n \n-        debug!(\"guarantor::for_autoref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        debug!(\"guarantor::for_autoref(expr=%s, autoref=%?)\",\n+               rcx.fcx.expr_to_str(expr), autoref);\n         let _i = ::util::common::indenter();\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n+        debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n@@ -626,7 +792,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"opt_constrain_region(id=%?, guarantor=%?)\", id, guarantor);\n+        debug!(\"link(id=%?, guarantor=%?)\", id, guarantor);\n \n         let bound = match guarantor {\n             None => {\n@@ -860,8 +1026,6 @@ pub mod guarantor {\n                 match closure_ty.sigil {\n                     ast::BorrowedSigil => BorrowedPointer(closure_ty.region),\n                     ast::OwnedSigil => OwnedPointer,\n-\n-                    // NOTE This is...not quite right.  Deduce a test etc.\n                     ast::ManagedSigil => OtherPointer,\n                 }\n             }\n@@ -972,7 +1136,6 @@ pub fn infallibly_mk_subr(rcx: @mut Rcx,\n                           a: ty::Region,\n                           b: ty::Region) {\n     /*!\n-     *\n      * Constrains `a` to be a subregion of `b`.  In many cases, we\n      * know that this can never yield an error due to the way that\n      * region inferencing works.  Therefore just report a bug if we"}, {"sha": "1abcefeefac8cdd462848b21ceebbac419e0621c", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 132, "deletions": 27, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -13,7 +13,7 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::typeck::check::SelfInfo;\n+\n use middle::typeck::isr_alist;\n use util::common::indenter;\n use util::ppaux::region_to_str;\n@@ -26,29 +26,24 @@ use std::list::Cons;\n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n-    self_info: Option<SelfInfo>,\n+    opt_self_ty: Option<ty::t>,\n     fn_sig: &ty::FnSig,\n     mapf: &fn(ty::bound_region) -> ty::Region)\n-    -> (isr_alist, Option<SelfInfo>, ty::FnSig)\n+    -> (isr_alist, Option<ty::t>, ty::FnSig)\n {\n-    // Take self_info apart; the self_ty part is the only one we want\n-    // to update here.\n-    let self_ty = self_info.map(|s| s.self_ty);\n-    let rebuild_self_info = |t| self_info.map(|s| SelfInfo{self_ty: t, ..*s});\n-\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n-    for self_info.each |self_info| {\n-        all_tys.push(self_info.self_ty);\n+    for opt_self_ty.each |&self_ty| {\n+        all_tys.push(self_ty);\n     }\n \n-    for self_ty.each |t| { all_tys.push(*t) }\n+    for opt_self_ty.each |&t| { all_tys.push(t) }\n \n-    debug!(\"replace_bound_regions_in_fn_sig(self_info.self_ty=%?, fn_sig=%s, \\\n+    debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n             all_tys=%?)\",\n-           self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n+           opt_self_ty.map(|&t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n-           all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n+           all_tys.map(|&t| ppaux::ty_to_str(tcx, t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n@@ -58,20 +53,15 @@ pub fn replace_bound_regions_in_fn_sig(\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n-    let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n+    let new_self_ty = opt_self_ty.map(|&t| replace_bound_regions(tcx, isr, t));\n \n-    debug!(\"result of replace_bound_regions_in_fn_sig: self_info.self_ty=%?, \\\n-                fn_sig=%s\",\n-           t_self.map(|t| ppaux::ty_to_str(tcx, *t)),\n+    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n+            new_self_ty=%?, \\\n+            fn_sig=%s\",\n+           new_self_ty.map(|&t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n-    // Glue updated self_ty back together with its original def_id.\n-    let new_self_info: Option<SelfInfo> = match t_self {\n-      None    => None,\n-      Some(t) => rebuild_self_info(t)\n-    };\n-\n-    return (isr, new_self_info, new_fn_sig);\n+    return (isr, new_self_ty, new_fn_sig);\n \n     // Takes `isr`, a (possibly empty) mapping from in-scope region\n     // names (\"isr\"s) to their corresponding regions; `tys`, a list of\n@@ -99,7 +89,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                       to_r: &fn(ty::bound_region) -> ty::Region,\n                       r: ty::Region) -> isr_alist {\n             match r {\n-              ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n+              ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n               ty::re_infer(_) => {\n                 isr\n               }\n@@ -167,10 +157,125 @@ pub fn replace_bound_regions_in_fn_sig(\n               // Free regions like these just stay the same:\n               ty::re_static |\n               ty::re_scope(_) |\n-              ty::re_free(_, _) |\n+              ty::re_free(*) |\n               ty::re_infer(_) => r\n             };\n             r1\n         }\n     }\n }\n+\n+pub fn relate_nested_regions(\n+    tcx: ty::ctxt,\n+    opt_region: Option<ty::Region>,\n+    ty: ty::t,\n+    relate_op: &fn(ty::Region, ty::Region))\n+{\n+    /*!\n+     *\n+     * This rather specialized function walks each region `r` that appear\n+     * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`\n+     * here is the region of any enclosing `&'r T` pointer.  If there is\n+     * no enclosing pointer, and `opt_region` is Some, then `opt_region.get()`\n+     * is used instead.  Otherwise, no callback occurs at all).\n+     *\n+     * Here are some examples to give you an intution:\n+     *\n+     * - `relate_nested_regions(Some('r1), &'r2 uint)` invokes\n+     *   - `relate_op('r1, 'r2)`\n+     * - `relate_nested_regions(Some('r1), &'r2 &'r3 uint)` invokes\n+     *   - `relate_op('r1, 'r2)`\n+     *   - `relate_op('r2, 'r3)`\n+     * - `relate_nested_regions(None, &'r2 &'r3 uint)` invokes\n+     *   - `relate_op('r2, 'r3)`\n+     * - `relate_nested_regions(None, &'r2 &'r3 &'r4 uint)` invokes\n+     *   - `relate_op('r2, 'r3)`\n+     *   - `relate_op('r2, 'r4)`\n+     *   - `relate_op('r3, 'r4)`\n+     *\n+     * This function is used in various pieces of code because we enforce the\n+     * constraint that a region pointer cannot outlive the things it points at.\n+     * Hence, in the second example above, `'r2` must be a subregion of `'r3`.\n+     */\n+\n+    let mut the_stack = ~[];\n+    for opt_region.each |&r| { the_stack.push(r); }\n+    walk_ty(tcx, &mut the_stack, ty, relate_op);\n+\n+    fn walk_ty(tcx: ty::ctxt,\n+               the_stack: &mut ~[ty::Region],\n+               ty: ty::t,\n+               relate_op: &fn(ty::Region, ty::Region))\n+    {\n+        match ty::get(ty).sty {\n+            ty::ty_rptr(r, ref mt) |\n+            ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n+                relate(*the_stack, r, relate_op);\n+                the_stack.push(r);\n+                walk_ty(tcx, the_stack, mt.ty, relate_op);\n+                the_stack.pop();\n+            }\n+            _ => {\n+                ty::fold_regions_and_ty(\n+                    tcx,\n+                    ty,\n+                    |r| { relate(*the_stack, r, relate_op); r },\n+                    |t| { walk_ty(tcx, the_stack, t, relate_op); t },\n+                    |t| { walk_ty(tcx, the_stack, t, relate_op); t });\n+            }\n+        }\n+    }\n+\n+    fn relate(the_stack: &[ty::Region],\n+              r_sub: ty::Region,\n+              relate_op: &fn(ty::Region, ty::Region))\n+    {\n+        for the_stack.each |&r| {\n+            if !r.is_bound() && !r_sub.is_bound() {\n+                relate_op(r, r_sub);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn relate_free_regions(\n+    tcx: ty::ctxt,\n+    self_ty: Option<ty::t>,\n+    fn_sig: &ty::FnSig)\n+{\n+    /*!\n+     * This function populates the region map's `free_region_map`.\n+     * It walks over the transformed self type and argument types\n+     * for each function just before we check the body of that\n+     * function, looking for types where you have a borrowed\n+     * pointer to other borrowed data (e.g., `&'a &'b [uint]`.\n+     * We do not allow borrowed pointers to outlive the things they\n+     * point at, so we can assume that `'a <= 'b`.\n+     *\n+     * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+     */\n+\n+    debug!(\"relate_free_regions >>\");\n+\n+    let mut all_tys = ~[];\n+    for fn_sig.inputs.each |arg| {\n+        all_tys.push(arg.ty);\n+    }\n+    for self_ty.each |&t| {\n+        all_tys.push(t);\n+    }\n+\n+    for all_tys.each |&t| {\n+        debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n+        relate_nested_regions(tcx, None, t, |a, b| {\n+            match (&a, &b) {\n+                (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n+                    tcx.region_maps.relate_free_regions(free_a, free_b);\n+                }\n+                _ => {}\n+            }\n+        })\n+    }\n+\n+    debug!(\"<< relate_free_regions\");\n+}"}, {"sha": "8245dc88114c8aca24cfd007fde7935dd13110a6", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use middle::resolve::Impl;\n-use middle::ty::{param_ty, substs};\n+use middle::ty::{param_ty};\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n@@ -489,6 +489,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n     match ex.node {\n       ast::expr_path(*) => {\n         for fcx.opt_node_ty_substs(ex.id) |substs| {\n+            debug!(\"vtable resolution on parameter bounds for expr %s\",\n+                   ex.repr(fcx.tcx()));\n             let def = *cx.tcx.def_map.get(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n@@ -518,6 +520,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       ast::expr_index(*) | ast::expr_method_call(*) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n+            debug!(\"vtable resolution on parameter bounds for method call %s\",\n+                   ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let callee_id = match ex.node {\n                   ast::expr_field(_, _, _) => ex.id,\n@@ -537,6 +541,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n         }\n       }\n       ast::expr_cast(src, _) => {\n+          debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n               ty::ty_trait(target_def_id, ref target_substs, store) => {"}, {"sha": "247b8eae2a8db67d5238814c04318baa0f83b2b0", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -24,7 +24,7 @@ use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n-use middle::ty::{lookup_item_type, param_bounds, subst};\n+use middle::ty::{lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};"}, {"sha": "59ea8ea039e1f1c474f9eda323c4f7ac05337cc4", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 74, "deletions": 26, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -55,7 +55,7 @@ use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust::path_to_str;\n+use syntax::print::pprust::{path_to_str, self_ty_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -453,31 +453,35 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n \n     let impl_m = &cm.mty;\n \n-    // FIXME(#2687)---this check is too strict.  For example, a trait\n-    // method with self type `&self` or `&mut self` should be\n-    // implementable by an `&const self` method (the impl assumes less\n-    // than the trait provides).\n-    if impl_m.self_ty != trait_m.self_ty {\n-        if impl_m.self_ty == ast::sty_static {\n-            // Needs to be a fatal error because otherwise,\n-            // method::transform_self_type_for_method ICEs\n-            tcx.sess.span_fatal(cm.span,\n-                 fmt!(\"method `%s` is declared as \\\n-                       static in its impl, but not in \\\n-                       its trait\", *tcx.sess.str_of(impl_m.ident)));\n-        }\n-        else if trait_m.self_ty == ast::sty_static {\n-            tcx.sess.span_fatal(cm.span,\n-                 fmt!(\"method `%s` is declared as \\\n-                       static in its trait, but not in \\\n-                       its impl\", *tcx.sess.str_of(impl_m.ident)));\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.self_ty, &impl_m.self_ty) {\n+        (&ast::sty_static, &ast::sty_static) => {}\n+        (&ast::sty_static, _) => {\n+            tcx.sess.span_err(\n+                cm.span,\n+                fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n+                      but not in the trait\",\n+                     *tcx.sess.str_of(trait_m.ident),\n+                     self_ty_to_str(impl_m.self_ty, tcx.sess.intr())));\n+            return;\n         }\n-        else {\n+        (_, &ast::sty_static) => {\n             tcx.sess.span_err(\n                 cm.span,\n-                fmt!(\"method `%s`'s self type does \\\n-                      not match the trait method's \\\n-                      self type\", *tcx.sess.str_of(impl_m.ident)));\n+                fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n+                      but not in the impl\",\n+                     *tcx.sess.str_of(trait_m.ident),\n+                     self_ty_to_str(trait_m.self_ty, tcx.sess.intr())));\n+            return;\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n         }\n     }\n \n@@ -535,9 +539,55 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // a free region.  So, for example, if the impl type is\n     // \"&'self str\", then this would replace the self type with a free\n     // region `self`.\n-    let dummy_self_r = ty::re_free(cm.body_id, ty::br_self);\n+    let dummy_self_r = ty::re_free(ty::FreeRegion {scope_id: cm.body_id,\n+                                                   bound_region: ty::br_self});\n     let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n \n+    // We are going to create a synthetic fn type that includes\n+    // both the method's self argument and its normal arguments.\n+    // So a method like `fn(&self, a: uint)` would be converted\n+    // into a function `fn(self: &T, a: uint)`.\n+    let mut trait_fn_args = ~[];\n+    let mut impl_fn_args = ~[];\n+\n+    // For both the trait and the impl, create an argument to\n+    // represent the self argument (unless this is a static method).\n+    // This argument will have the *transformed* self type.\n+    for trait_m.transformed_self_ty.each |&t| {\n+        trait_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+    }\n+    for impl_m.transformed_self_ty.each |&t| {\n+        impl_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+    }\n+\n+    // Add in the normal arguments.\n+    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n+    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n+\n+    // Create a bare fn type for trait/impl that includes self argument\n+    let trait_fty =\n+        ty::mk_bare_fn(\n+            tcx,\n+            ty::BareFnTy {purity: trait_m.fty.purity,\n+                          abis: trait_m.fty.abis,\n+                          sig: ty::FnSig {\n+                              bound_lifetime_names:\n+                                  copy trait_m.fty.sig.bound_lifetime_names,\n+                              inputs: trait_fn_args,\n+                              output: trait_m.fty.sig.output\n+                          }});\n+    let impl_fty =\n+        ty::mk_bare_fn(\n+            tcx,\n+            ty::BareFnTy {purity: impl_m.fty.purity,\n+                          abis: impl_m.fty.abis,\n+                          sig: ty::FnSig {\n+                              bound_lifetime_names:\n+                                  copy impl_m.fty.sig.bound_lifetime_names,\n+                              inputs: impl_fn_args,\n+                              output: impl_m.fty.sig.output\n+                          }});\n+\n     // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n     // - replace trait type parameters with those from `trait_substs`,\n@@ -546,7 +596,6 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        let impl_fty = ty::mk_bare_fn(tcx, copy impl_m.fty);\n         debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n@@ -564,7 +613,6 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        let trait_fty = ty::mk_bare_fn(tcx, copy trait_m.fty);\n         debug!(\"trait_fty (pre-subst): %s substs=%s\",\n                trait_fty.repr(tcx), substs.repr(tcx));\n         ty::subst(tcx, &substs, trait_fty)"}, {"sha": "7252566d84c17d0ddaaa73031ea3fb06aba122a8", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 121, "deletions": 44, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -538,10 +538,9 @@ more convincing in the future.\n \n use core::prelude::*;\n \n-use middle::region::is_subregion_of;\n-use middle::region;\n use middle::ty;\n-use middle::ty::{Region, RegionVid, re_static, re_infer, re_free, re_bound};\n+use middle::ty::{FreeRegion, Region, RegionVid};\n+use middle::ty::{re_static, re_infer, re_free, re_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use util::common::indenter;\n@@ -554,6 +553,7 @@ use core::to_bytes;\n use core::uint;\n use core::vec;\n use syntax::codemap::span;\n+use syntax::ast;\n \n #[deriving(Eq)]\n enum Constraint {\n@@ -1025,11 +1025,12 @@ pub impl RegionVarBindings {\n }\n \n priv impl RegionVarBindings {\n-    fn is_subregion_of(&mut self, sub: Region, sup: Region) -> bool {\n-        is_subregion_of(self.tcx.region_map, sub, sup)\n+    fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n+        let rm = self.tcx.region_maps;\n+        rm.is_subregion_of(sub, sup)\n     }\n \n-    fn lub_concrete_regions(&mut self, +a: Region, +b: Region) -> Region {\n+    fn lub_concrete_regions(&self, +a: Region, +b: Region) -> Region {\n         match (a, b) {\n           (re_static, _) | (_, re_static) => {\n             re_static // nothing lives longer than static\n@@ -1042,17 +1043,17 @@ priv impl RegionVarBindings {\n                       non-concrete regions: %?, %?\", a, b));\n           }\n \n-          (f @ re_free(f_id, _), re_scope(s_id)) |\n-          (re_scope(s_id), f @ re_free(f_id, _)) => {\n+          (f @ re_free(ref fr), re_scope(s_id)) |\n+          (re_scope(s_id), f @ re_free(ref fr)) => {\n             // A \"free\" region can be interpreted as \"some region\n-            // at least as big as the block f_id\".  So, we can\n+            // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            let rm = self.tcx.region_map;\n-            match region::nearest_common_ancestor(rm, f_id, s_id) {\n-              // if the free region's scope `f_id` is bigger than\n+            let rm = self.tcx.region_maps;\n+            match rm.nearest_common_ancestor(fr.scope_id, s_id) {\n+              // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n-              Some(r_id) if r_id == f_id => f,\n+              Some(r_id) if r_id == fr.scope_id => f,\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n@@ -1064,32 +1065,67 @@ priv impl RegionVarBindings {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n-            let rm = self.tcx.region_map;\n-            match region::nearest_common_ancestor(rm, a_id, b_id) {\n+            let rm = self.tcx.region_maps;\n+            match rm.nearest_common_ancestor(a_id, b_id) {\n               Some(r_id) => re_scope(r_id),\n               _ => re_static\n             }\n           }\n \n+          (re_free(ref a_fr), re_free(ref b_fr)) => {\n+             self.lub_free_regions(a_fr, b_fr)\n+          }\n+\n           // For these types, we cannot define any additional\n           // relationship:\n           (re_infer(ReSkolemized(*)), _) |\n           (_, re_infer(ReSkolemized(*))) |\n-          (re_free(_, _), re_free(_, _)) |\n           (re_bound(_), re_bound(_)) |\n-          (re_bound(_), re_free(_, _)) |\n+          (re_bound(_), re_free(_)) |\n           (re_bound(_), re_scope(_)) |\n-          (re_free(_, _), re_bound(_)) |\n+          (re_free(_), re_bound(_)) |\n           (re_scope(_), re_bound(_)) => {\n             if a == b {a} else {re_static}\n           }\n         }\n     }\n \n-    fn glb_concrete_regions(&mut self,\n+    fn lub_free_regions(&self,\n+                        a: &FreeRegion,\n+                        b: &FreeRegion) -> ty::Region\n+    {\n+        /*!\n+         * Computes a region that encloses both free region arguments.\n+         * Guarantee that if the same two regions are given as argument,\n+         * in any order, a consistent result is returned.\n+         */\n+\n+        return match a.cmp(b) {\n+            Less => helper(self, a, b),\n+            Greater => helper(self, b, a),\n+            Equal => ty::re_free(*a)\n+        };\n+\n+        fn helper(self: &RegionVarBindings,\n+                  a: &FreeRegion,\n+                  b: &FreeRegion) -> ty::Region\n+        {\n+            let rm = self.tcx.region_maps;\n+            if rm.sub_free_region(*a, *b) {\n+                ty::re_free(*b)\n+            } else if rm.sub_free_region(*b, *a) {\n+                ty::re_free(*a)\n+            } else {\n+                ty::re_static\n+            }\n+        }\n+    }\n+\n+    fn glb_concrete_regions(&self,\n                             +a: Region,\n                             +b: Region)\n                          -> cres<Region> {\n+        debug!(\"glb_concrete_regions(%?, %?)\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -1104,47 +1140,36 @@ priv impl RegionVarBindings {\n                           non-concrete regions: %?, %?\", a, b));\n             }\n \n-            (re_free(f_id, _), s @ re_scope(s_id)) |\n-            (s @ re_scope(s_id), re_free(f_id, _)) => {\n+            (re_free(ref fr), s @ re_scope(s_id)) |\n+            (s @ re_scope(s_id), re_free(ref fr)) => {\n                 // Free region is something \"at least as big as\n-                // `f_id`.\"  If we find that the scope `f_id` is bigger\n+                // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                let rm = self.tcx.region_map;\n-                match region::nearest_common_ancestor(rm, f_id, s_id) {\n-                    Some(r_id) if r_id == f_id => Ok(s),\n+                let rm = self.tcx.region_maps;\n+                match rm.nearest_common_ancestor(fr.scope_id, s_id) {\n+                    Some(r_id) if r_id == fr.scope_id => Ok(s),\n                     _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n \n-            (re_scope(a_id), re_scope(b_id)) |\n-            (re_free(a_id, _), re_free(b_id, _)) => {\n-                if a == b {\n-                    // Same scope or same free identifier, easy case.\n-                    Ok(a)\n-                } else {\n-                    // We want to generate the intersection of two\n-                    // scopes or two free regions.  So, if one of\n-                    // these scopes is a subscope of the other, return\n-                    // it.  Otherwise fail.\n-                    let rm = self.tcx.region_map;\n-                    match region::nearest_common_ancestor(rm, a_id, b_id) {\n-                        Some(r_id) if a_id == r_id => Ok(re_scope(b_id)),\n-                        Some(r_id) if b_id == r_id => Ok(re_scope(a_id)),\n-                        _ => Err(ty::terr_regions_no_overlap(b, a))\n-                    }\n-                }\n+            (re_scope(a_id), re_scope(b_id)) => {\n+                self.intersect_scopes(a, b, a_id, b_id)\n+            }\n+\n+            (re_free(ref a_fr), re_free(ref b_fr)) => {\n+                self.glb_free_regions(a_fr, b_fr)\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n             (re_infer(ReSkolemized(*)), _) |\n             (_, re_infer(ReSkolemized(*))) |\n             (re_bound(_), re_bound(_)) |\n-            (re_bound(_), re_free(_, _)) |\n+            (re_bound(_), re_free(_)) |\n             (re_bound(_), re_scope(_)) |\n-            (re_free(_, _), re_bound(_)) |\n+            (re_free(_), re_bound(_)) |\n             (re_scope(_), re_bound(_)) => {\n                 if a == b {\n                     Ok(a)\n@@ -1155,10 +1180,62 @@ priv impl RegionVarBindings {\n         }\n     }\n \n+    fn glb_free_regions(&self,\n+                        a: &FreeRegion,\n+                        b: &FreeRegion) -> cres<ty::Region>\n+    {\n+        /*!\n+         * Computes a region that is enclosed by both free region arguments,\n+         * if any. Guarantees that if the same two regions are given as argument,\n+         * in any order, a consistent result is returned.\n+         */\n+\n+        return match a.cmp(b) {\n+            Less => helper(self, a, b),\n+            Greater => helper(self, b, a),\n+            Equal => Ok(ty::re_free(*a))\n+        };\n+\n+        fn helper(self: &RegionVarBindings,\n+                  a: &FreeRegion,\n+                  b: &FreeRegion) -> cres<ty::Region>\n+        {\n+            let rm = self.tcx.region_maps;\n+            if rm.sub_free_region(*a, *b) {\n+                Ok(ty::re_free(*a))\n+            } else if rm.sub_free_region(*b, *a) {\n+                Ok(ty::re_free(*b))\n+            } else {\n+                self.intersect_scopes(ty::re_free(*a), ty::re_free(*b),\n+                                      a.scope_id, b.scope_id)\n+            }\n+        }\n+    }\n+\n     fn report_type_error(&mut self, span: span, terr: &ty::type_err) {\n         let terr_str = ty::type_err_to_str(self.tcx, terr);\n         self.tcx.sess.span_err(span, terr_str);\n     }\n+\n+    fn intersect_scopes(&self,\n+                        region_a: ty::Region,\n+                        region_b: ty::Region,\n+                        scope_a: ast::node_id,\n+                        scope_b: ast::node_id) -> cres<Region>\n+    {\n+        // We want to generate the intersection of two\n+        // scopes or two free regions.  So, if one of\n+        // these scopes is a subscope of the other, return\n+        // it.  Otherwise fail.\n+        debug!(\"intersect_scopes(scope_a=%?, scope_b=%?, region_a=%?, region_b=%?)\",\n+               scope_a, scope_b, region_a, region_b);\n+        let rm = self.tcx.region_maps;\n+        match rm.nearest_common_ancestor(scope_a, scope_b) {\n+            Some(r_id) if scope_a == r_id => Ok(re_scope(scope_b)),\n+            Some(r_id) if scope_b == r_id => Ok(re_scope(scope_a)),\n+            _ => Err(ty::terr_regions_no_overlap(region_a, region_b))\n+        }\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "bf607e2c3624678fcc5e52b511f1cfd357ae9449", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -210,7 +210,9 @@ pub impl Env {\n     }\n \n     fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_free(nid, ty::br_anon(id)),\n+        ty::mk_imm_rptr(self.tcx,\n+                        ty::re_free(ty::FreeRegion {scope_id: nid,\n+                                                    bound_region: ty::br_anon(id)}),\n                         self.t_int())\n     }\n "}, {"sha": "3ff36a409a71f4ea8ee9fcf71c3479432e0ab2a9", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -180,12 +180,11 @@ impl region_scope for MethodRscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        assert!(self.variance.is_some() || self.self_ty.is_borrowed());\n+        assert!(self.variance.is_some());\n         match self.variance {\n             None => {}  // must be borrowed self, so this is OK\n             Some(_) => {\n-                if !self.self_ty.is_borrowed() &&\n-                        !self.region_param_names.has_self() {\n+                if !self.region_param_names.has_self() {\n                     return Err(RegionError {\n                         msg: ~\"the `self` lifetime must be declared\",\n                         replacement: ty::re_bound(ty::br_self)"}, {"sha": "9b9e0e81b434684554c454ba130f483992ca3b6e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -41,9 +41,9 @@ pub trait Repr {\n }\n \n pub fn note_and_explain_region(cx: ctxt,\n-                               prefix: ~str,\n+                               prefix: &str,\n                                region: ty::Region,\n-                               suffix: ~str) {\n+                               suffix: &str) {\n     match explain_region_and_span(cx, region) {\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n@@ -98,23 +98,23 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         }\n       }\n \n-      re_free(id, br) => {\n-        let prefix = match br {\n+      re_free(ref fr) => {\n+        let prefix = match fr.bound_region {\n           br_anon(idx) => fmt!(\"the anonymous lifetime #%u defined on\",\n                                idx + 1),\n           br_fresh(_) => fmt!(\"an anonymous lifetime defined on\"),\n           _ => fmt!(\"the lifetime %s as defined on\",\n-                    bound_region_to_str(cx, br))\n+                    bound_region_to_str(cx, fr.bound_region))\n         };\n \n-        match cx.items.find(&id) {\n+        match cx.items.find(&fr.scope_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (fmt!(\"%s node %d\", prefix, id), None)\n+            (fmt!(\"%s node %d\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n@@ -215,7 +215,7 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n     match region {\n         re_scope(_) => prefix.to_str(),\n         re_bound(br) => bound_region_to_str_space(cx, prefix, br),\n-        re_free(_, br) => bound_region_to_str_space(cx, prefix, br),\n+        re_free(ref fr) => bound_region_to_str_space(cx, prefix, fr.bound_region),\n         re_infer(ReSkolemized(_, br)) => {\n             bound_region_to_str_space(cx, prefix, br)\n         }\n@@ -225,12 +225,16 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n }\n \n pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n+    mt_to_str_wrapped(cx, \"\", m, \"\")\n+}\n+\n+pub fn mt_to_str_wrapped(cx: ctxt, before: &str, m: &mt, after: &str) -> ~str {\n     let mstr = match m.mutbl {\n       ast::m_mutbl => \"mut \",\n       ast::m_imm => \"\",\n       ast::m_const => \"const \"\n     };\n-    return fmt!(\"%s%s\", mstr, ty_to_str(cx, m.ty));\n+    return fmt!(\"%s%s%s%s\", mstr, before, ty_to_str(cx, m.ty), after);\n }\n \n pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n@@ -250,15 +254,14 @@ pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n     }\n }\n \n-pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n+pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     match vs {\n-      ty::vstore_fixed(_) => {\n-        fmt!(\"[%s, .. %s]\", ty, vstore_to_str(cx, vs))\n-      }\n-      ty::vstore_slice(_) => {\n-        fmt!(\"%s %s\", vstore_to_str(cx, vs), ty)\n-      }\n-      _ => fmt!(\"%s[%s]\", vstore_to_str(cx, vs), ty)\n+        ty::vstore_fixed(_) => {\n+            fmt!(\"[%s, .. %s]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n+        }\n+        _ => {\n+            fmt!(\"%s%s\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n+        }\n     }\n }\n \n@@ -460,7 +463,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         fmt!(\"%s%s\", trait_store_to_str(cx, s), ty)\n       }\n       ty_evec(ref mt, vs) => {\n-        vstore_ty_to_str(cx, fmt!(\"%s\", mt_to_str(cx, mt)), vs)\n+        vstore_ty_to_str(cx, mt, vs)\n       }\n       ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), ~\"str\"),\n       ty_opaque_box => ~\"@?\",\n@@ -747,6 +750,12 @@ impl Repr for ty::TraitStore {\n     }\n }\n \n+impl Repr for ty::vstore {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        vstore_to_str(tcx, *self)\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "3d2c3ac70b610908e28c55c85141c288c66657b9", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -171,7 +171,7 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n \n pub impl Arena {\n     // Functions for the POD part of the arena\n-    fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n+    priv fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -183,7 +183,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n+    priv fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n         let head = &mut self.pod_head;\n \n         let start = round_up_to(head.fill, align);\n@@ -202,7 +202,22 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n+    #[cfg(stage0)]\n+    priv fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n+            let ptr: *mut T = reinterpret_cast(&ptr);\n+            rusti::move_val_init(&mut (*ptr), op());\n+            return reinterpret_cast(&ptr);\n+        }\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    priv fn alloc_pod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -213,7 +228,7 @@ pub impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    priv fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -225,7 +240,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    priv fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         let head = &mut self.head;\n \n         let tydesc_start = head.fill;\n@@ -247,7 +262,32 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n+    #[cfg(stage0)]\n+    priv fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let (ty_ptr, ptr) =\n+                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n+            let ty_ptr: *mut uint = reinterpret_cast(&ty_ptr);\n+            let ptr: *mut T = reinterpret_cast(&ptr);\n+            // Write in our tydesc along with a bit indicating that it\n+            // has *not* been initialized yet.\n+            *ty_ptr = reinterpret_cast(&tydesc);\n+            // Actually initialize it\n+            rusti::move_val_init(&mut(*ptr), op());\n+            // Now that we are done, update the tydesc to indicate that\n+            // the object is there.\n+            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n+\n+            return reinterpret_cast(&ptr);\n+        }\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    priv fn alloc_nonpod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -269,6 +309,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn alloc<T>(&self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {\n@@ -278,6 +319,21 @@ pub impl Arena {\n             }\n         }\n     }\n+\n+    // The external interface\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+        unsafe {\n+            if !rusti::needs_drop::<T>() {\n+                self.alloc_pod(op)\n+            } else {\n+                self.alloc_nonpod(op)\n+            }\n+        }\n+    }\n }\n \n #[test]"}, {"sha": "632a38e8ca2d8fc484a478dce07dc1994f7ee9ac", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -437,8 +437,7 @@ pub impl Bitv {\n             if offset >= bitv.nbits {\n                 0\n             } else {\n-                // NOTE cannot use bitv[offset] until snapshot\n-                bitv.index(&offset) as u8 << (7 - bit)\n+                bitv[offset] as u8 << (7 - bit)\n             }\n         }\n \n@@ -460,8 +459,7 @@ pub impl Bitv {\n      * Transform self into a [bool] by turning each bit into a bool\n      */\n     fn to_bools(&self) -> ~[bool] {\n-        // NOTE cannot use self[i] until snapshot\n-        vec::from_fn(self.nbits, |i| self.index(&i))\n+        vec::from_fn(self.nbits, |i| self[i])\n     }\n \n     /**"}, {"sha": "a88d13fda66210a11ede2925570a37cd1a920a31", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -41,6 +41,7 @@ impl<T> Mutable for Deque<T> {\n     }\n }\n \n+#[cfg(stage0)]\n pub impl<T> Deque<T> {\n     /// Create an empty Deque\n     fn new() -> Deque<T> {\n@@ -51,21 +52,142 @@ pub impl<T> Deque<T> {\n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n+    #[cfg(stage0)]\n     fn peek_front(&self) -> &'self T { get(self.elts, self.lo) }\n \n+    /// Return a reference to the first element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+\n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n+    #[cfg(stage0)]\n     fn peek_back(&self) -> &'self T { get(self.elts, self.hi - 1u) }\n \n+    /// Return a reference to the last element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+\n     /// Retrieve an element in the deque by index\n     ///\n     /// Fails if there is no element with the given index\n+    #[cfg(stage0)]\n     fn get(&self, i: int) -> &'self T {\n         let idx = (self.lo + (i as uint)) % self.elts.len();\n         get(self.elts, idx)\n     }\n \n+    /// Retrieve an element in the deque by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, i: int) -> &'a T {\n+        let idx = (self.lo + (i as uint)) % self.elts.len();\n+        get(self.elts, idx)\n+    }\n+\n+    /// Iterate over the elements in the deque\n+    fn each(&self, f: &fn(&T) -> bool) {\n+        self.eachi(|_i, e| f(e))\n+    }\n+\n+    /// Iterate over the elements in the deque by index\n+    fn eachi(&self, f: &fn(uint, &T) -> bool) {\n+        for uint::range(0, self.nelts) |i| {\n+            if !f(i, self.get(i as int)) { return; }\n+        }\n+    }\n+\n+    /// Remove and return the first element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn pop_front(&mut self) -> T {\n+        let mut result = self.elts[self.lo].swap_unwrap();\n+        self.lo = (self.lo + 1u) % self.elts.len();\n+        self.nelts -= 1u;\n+        result\n+    }\n+\n+    /// Remove and return the last element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn pop_back(&mut self) -> T {\n+        if self.hi == 0u {\n+            self.hi = self.elts.len() - 1u;\n+        } else { self.hi -= 1u; }\n+        let mut result = self.elts[self.hi].swap_unwrap();\n+        self.elts[self.hi] = None;\n+        self.nelts -= 1u;\n+        result\n+    }\n+\n+    /// Prepend an element to the deque\n+    fn add_front(&mut self, t: T) {\n+        let oldlo = self.lo;\n+        if self.lo == 0u {\n+            self.lo = self.elts.len() - 1u;\n+        } else { self.lo -= 1u; }\n+        if self.lo == self.hi {\n+            self.elts = grow(self.nelts, oldlo, self.elts);\n+            self.lo = self.elts.len() - 1u;\n+            self.hi = self.nelts;\n+        }\n+        self.elts[self.lo] = Some(t);\n+        self.nelts += 1u;\n+    }\n+\n+    /// Append an element to the deque\n+    fn add_back(&mut self, t: T) {\n+        if self.lo == self.hi && self.nelts != 0u {\n+            self.elts = grow(self.nelts, self.lo, self.elts);\n+            self.lo = 0u;\n+            self.hi = self.nelts;\n+        }\n+        self.elts[self.hi] = Some(t);\n+        self.hi = (self.hi + 1u) % self.elts.len();\n+        self.nelts += 1u;\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub impl<T> Deque<T> {\n+    /// Create an empty Deque\n+    fn new() -> Deque<T> {\n+        Deque{nelts: 0, lo: 0, hi: 0,\n+              elts: vec::from_fn(initial_capacity, |_| None)}\n+    }\n+\n+    /// Return a reference to the first element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+\n+    /// Return a reference to the last element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+\n+    /// Retrieve an element in the deque by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    fn get<'a>(&'a self, i: int) -> &'a T {\n+        let idx = (self.lo + (i as uint)) % self.elts.len();\n+        get(self.elts, idx)\n+    }\n+\n     /// Iterate over the elements in the deque\n     fn each(&self, f: &fn(&T) -> bool) {\n         self.eachi(|_i, e| f(e))"}, {"sha": "feea8fb4fcda73254a24d1240f064a61ef6a37a6", "filename": "src/libstd/future.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -55,7 +55,7 @@ pub impl<A:Copy> Future<A> {\n }\n \n pub impl<A> Future<A> {\n-\n+    #[cfg(stage0)]\n     fn get_ref(&self) -> &'self A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n@@ -80,6 +80,34 @@ pub impl<A> Future<A> {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_ref<'a>(&'a self) -> &'a A {\n+        /*!\n+        * Executes the future's closure and then returns a borrowed\n+        * pointer to the result.  The borrowed pointer lasts as long as\n+        * the future.\n+        */\n+        unsafe {\n+            match self.state {\n+                Forced(ref mut v) => { return cast::transmute(v); }\n+                Evaluating => fail!(~\"Recursive forcing of future!\"),\n+                Pending(_) => {}\n+            }\n+\n+            let mut state = Evaluating;\n+            self.state <-> state;\n+            match state {\n+                Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n+                Pending(f) => {\n+                    self.state = Forced(f());\n+                    self.get_ref()\n+                }\n+            }\n+        }\n+    }\n }\n \n pub fn from_value<A>(val: A) -> Future<A> {"}, {"sha": "c8d250f90f6c47438cd675af93f1b4947d5e203c", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -50,13 +50,29 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n+    #[cfg(stage0)]\n     fn top(&self) -> &'self T { &self.data[0] }\n \n+    /// Returns the greatest item in the queue - fails if empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n+\n     /// Returns the greatest item in the queue - None if empty\n+    #[cfg(stage0)]\n     fn maybe_top(&self) -> Option<&'self T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n+    /// Returns the greatest item in the queue - None if empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n+        if self.is_empty() { None } else { Some(self.top()) }\n+    }\n+\n     /// Returns the number of elements the queue can hold without reallocating\n     fn capacity(&self) -> uint { vec::capacity(&self.data) }\n "}, {"sha": "d50804ba47b598aeb6f4a3382aabf1dc614befbf", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -51,6 +51,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each(&self, it: &fn(&uint, &'self V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -60,18 +61,40 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n     /// Visit all keys in order\n     fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value(&self, blk: &fn(value: &V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, it: &fn(&uint, &'self mut V) -> bool) {\n+    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref mut elt) => if !it(&i, elt) { break },\n@@ -81,6 +104,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find(&self, key: &uint) -> Option<&'self V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -92,7 +116,23 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find_mut(&mut self, key: &uint) -> Option<&'self mut V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -104,6 +144,21 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref mut value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -134,6 +189,7 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n+    #[cfg(stage0)]\n     fn each_reverse(&self, it: &fn(uint, &'self V) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n@@ -143,9 +199,30 @@ pub impl<V> SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n+        for uint::range_rev(self.v.len(), 0) |i| {\n+            match self.v[i - 1] {\n+              Some(ref elt) => if !it(i - 1, elt) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn get(&self, key: &uint) -> &'self V {\n         self.find(key).expect(\"key not present\")\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, key: &uint) -> &'a V {\n+        self.find(key).expect(\"key not present\")\n+    }\n }\n \n pub impl<V:Copy> SmallIntMap<V> {"}, {"sha": "006455c44e429c1fcd6caddd097518024b02475f", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -105,26 +105,45 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&'self K, &'self V) -> bool) {\n         each(&self.root, f)\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n+        each(&self.root, f)\n+    }\n+\n     /// Visit all keys in order\n     fn each_key(&self, f: &fn(&K) -> bool) {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value(&self, f: &fn(&V) -> bool) {\n         self.each(|_, v| f(v))\n     }\n \n+    /// Visit all values in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) {\n+        self.each(|_, v| f(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&'self K, &'self mut V) -> bool) {\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) {\n         mutate_values(&mut self.root, f);\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find(&self, key: &K) -> Option<&'self V> {\n         let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n         loop {\n@@ -141,12 +160,42 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n+        let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n+        loop {\n+            match *current {\n+              Some(ref r) => {\n+                match key.cmp(&r.key) {\n+                  Less => current = &r.left,\n+                  Greater => current = &r.right,\n+                  Equal => return Some(&r.value)\n+                }\n+              }\n+              None => return None\n+            }\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn find_mut(&mut self, key: &K) -> Option<&'self mut V> {\n         find_mut(&mut self.root, key)\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n+        find_mut(&mut self.root, key)\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -170,7 +219,16 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all key-value pairs in reverse order\n-    fn each_reverse(&'self self, f: &fn(&'self K, &'self V) -> bool) {\n+    #[cfg(stage0)]\n+    fn each_reverse(&self, f: &fn(&'self K, &'self V) -> bool) {\n+        each_reverse(&self.root, f);\n+    }\n+\n+    /// Visit all key-value pairs in reverse order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n         each_reverse(&self.root, f);\n     }\n \n@@ -186,9 +244,19 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n+    #[cfg(stage0)]\n     fn iter(&self) -> TreeMapIterator<'self, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n+\n+    /// Get a lazy iterator over the key-value pairs in the map.\n+    /// Requires that it be frozen (immutable).\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+        TreeMapIterator{stack: ~[], node: &self.root}\n+    }\n }\n \n /// Lazy forward iterator over a map\n@@ -490,9 +558,20 @@ pub impl <T: TotalOrd> TreeSet<T> {\n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn iter(&self) -> TreeSetIterator<'self, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n+\n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.iter()}\n+    }\n }\n \n /// Lazy forward iterator over a set"}, {"sha": "9c20012d42e6b0e0fc03aaf18a0e531ba361e26d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -1002,15 +1002,6 @@ pub enum self_ty_ {\n     sty_uniq(mutability)                       // `~self`\n }\n \n-impl self_ty_ {\n-    fn is_borrowed(&self) -> bool {\n-        match *self {\n-            sty_region(*) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n pub type self_ty = spanned<self_ty_>;\n \n #[auto_encode]"}, {"sha": "886af694920f73bd05709b9324e96269f36e53f6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -454,13 +454,26 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n+    #[cfg(stage0)]\n     fn get_map(&self) -> &'self HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,\n             ConsMapChain (~ref map,_) => map\n         }\n     }\n \n+    // ugh: can't get this to compile with mut because of the\n+    // lack of flow sensitivity.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n+        match *self {\n+            BaseMapChain (~ref map) => map,\n+            ConsMapChain (~ref map,_) => map\n+        }\n+    }\n+\n // traits just don't work anywhere...?\n //pub impl Map<Name,SyntaxExtension> for MapChain {\n "}, {"sha": "1604c40f917635396868537979f561048f269d95", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -61,13 +61,24 @@ impl<T> OptVec<T> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn get(&self, i: uint) -> &'self T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),\n             Vec(ref v) => &v[i]\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, i: uint) -> &'a T {\n+        match *self {\n+            Empty => fail!(fmt!(\"Invalid index %u\", i)),\n+            Vec(ref v) => &v[i]\n+        }\n+    }\n+\n     fn is_empty(&self) -> bool {\n         self.len() == 0\n     }"}, {"sha": "cf29f170f4061405122a159645cf69331573e587", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -1632,6 +1632,10 @@ pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n+pub fn self_ty_to_str(self_ty: ast::self_ty_, intr: @ident_interner) -> ~str {\n+    to_str(self_ty, |a, b| { print_self_ty(a, b); () }, intr)\n+}\n+\n // Returns whether it printed anything\n pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n     match self_ty {"}, {"sha": "67059e4623e8f836bdc8f72dd3c9ec4a335d1aaa", "filename": "src/test/compile-fail/issue-3311.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5bb2e8f62c5666f61db0b670f80f64ca673d22d6/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb2e8f62c5666f61db0b670f80f64ca673d22d6/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs?ref=5bb2e8f62c5666f61db0b670f80f64ca673d22d6", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[legacy_mode]\n-struct Foo<'self> {\n-    s: &'self str,\n-    u: ~()\n-}\n-\n-pub impl<'self> Foo<'self> {\n-    fn get_s(&self) -> &'self str {\n-        self.s\n-    }\n-}\n-\n-fn bar(s: &str, f: &fn(Option<Foo>)) {\n-    f(Some(Foo {s: s, u: ~()}));\n-}\n-\n-fn main() {\n-    do bar(~\"testing\") |opt| {\n-        io::println(opt.unwrap().get_s()); //~ ERROR illegal borrow:\n-    };\n-}"}, {"sha": "38f28bd79dfa1905d9ed09d82583c03d4b5f1ee4", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -10,7 +10,7 @@\n \n trait A {\n   fn a(&self) {\n-      || self.b() //~ ERROR type `&'self Self` does not implement any method in scope named `b`\n+      || self.b() //~ ERROR type `&Self` does not implement any method in scope named `b`\n   }\n }\n fn main() {}"}, {"sha": "35f8557c32b608ff7bd1626aa446bff00b74bb23", "filename": "src/test/compile-fail/issue-3888.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5bb2e8f62c5666f61db0b670f80f64ca673d22d6/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb2e8f62c5666f61db0b670f80f64ca673d22d6/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=5bb2e8f62c5666f61db0b670f80f64ca673d22d6", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// n.b. This should be a run-pass test, but for now I'm testing\n-// that we don't see an \"unknown scope\" error.\n-fn vec_peek<'r, T>(v: &'r [T]) -> Option< (&'r T, &'r [T]) > {\n-    if v.len() == 0 {\n-        None\n-    } else {\n-        let vec_len = v.len();\n-        let head = &v[0];\n-        // note: this *shouldn't* be an illegal borrow! See #3888\n-        let tail = v.slice(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n-        Some( (head, tail) )\n-    }\n-}\n-\n-\n-fn test_peek_empty_stack() {\n-    let v : &[int] = &[];\n-    assert!((None == vec_peek(v)));\n-}\n-\n-fn test_peek_empty_unique() {\n-    let v : ~[int] = ~[];\n-    assert!((None == vec_peek(v)));\n-}\n-\n-fn test_peek_empty_managed() {\n-    let v : @[int] = @[];\n-    assert!((None == vec_peek(v)));\n-}\n-\n-\n-fn main() {}"}, {"sha": "b60a54a44bbfdf853fe8874151597b6688813439", "filename": "src/test/compile-fail/issue-3969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3969.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -18,7 +18,7 @@ trait BikeMethods {\n \n impl BikeMethods for Bike {\n     fn woops() -> ~str { ~\"foo\" }\n-    //~^ ERROR method `woops` is declared as static in its impl, but not in its trait\n+    //~^ ERROR has a `&const self` declaration in the trait, but not in the impl\n }\n \n pub fn main() {"}, {"sha": "54ee8bcc70e3774a5974bc6365b898dbe800896e", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -27,5 +27,6 @@ fn main() {\n         let x: &'blk int = &3;\n         repeater(@x)\n     };\n-    assert!(3 == *(y.get())); //~ ERROR reference is not valid\n+    assert!(3 == *(y.get())); //~ ERROR dereference of reference outside its lifetime\n+    //~^ ERROR reference is not valid outside of its lifetime\n }"}, {"sha": "f7165784c79754bc574cf71baa380b56a4124acc", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -24,9 +24,9 @@ fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n \n fn return_it() -> int {\n     with(|o| o)\n-    //~^ ERROR reference is not valid outside of its lifetime\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n     //~^^ ERROR reference is not valid outside of its lifetime\n-    //~^^^ ERROR cannot infer an appropriate lifetime\n+    //~^^^ ERROR reference is not valid outside of its lifetime\n }\n \n fn main() {"}, {"sha": "e5399fc7fa3b9332e1b91723b494d6382e5b7893", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that callees correctly infer an ordering between free regions\n+// that appear in their parameter list.  See also\n+// regions-free-region-ordering-caller.rs\n+\n+fn ordering1<'a, 'b>(x: &'a &'b uint) -> &'a uint {\n+    // It is safe to assume that 'a <= 'b due to the type of x\n+    let y: &'b uint = &**x;\n+    return y;\n+}\n+\n+fn ordering2<'a, 'b>(x: &'a &'b uint, y: &'a uint) -> &'b uint {\n+    // However, it is not safe to assume that 'b <= 'a\n+    &*y //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn ordering3<'a, 'b>(x: &'a uint, y: &'b uint) -> &'a &'b uint {\n+    // Do not infer an ordering from the return value.\n+    let z: &'b uint = &*x;\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    fail!();\n+}\n+\n+fn ordering4<'a, 'b>(a: &'a uint, b: &'b uint, x: &fn(&'a &'b uint)) {\n+    let z: Option<&'a &'b uint> = None;\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "d06dcd8aa86b81d4dab0a01ea03f629f66f7fb34", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various ways to construct a pointer with a longer lifetime\n+// than the thing it points at and ensure that they result in\n+// errors. See also regions-free-region-ordering-callee.rs\n+\n+struct Paramd<'self> { x: &'self uint }\n+\n+fn call1<'a>(x: &'a uint) {\n+    let y: uint = 3;\n+    let z: &'a &'blk uint = &(&y);\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+fn call2<'a, 'b>(a: &'a uint, b: &'b uint) {\n+    let z: Option<&'b &'a uint> = None;\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+fn call3<'a, 'b>(a: &'a uint, b: &'b uint) {\n+    let y: Paramd<'a> = Paramd { x: a };\n+    let z: Option<&'b Paramd<'a>> = None;\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+fn call4<'a, 'b>(a: &'a uint, b: &'b uint) {\n+    let z: Option<&fn(&'a &'b uint)> = None;\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "e8d66ab297b71852a5f9490e89cebcd0646fa8c7", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -18,12 +18,12 @@ struct c<'self> {\n     f: @b<'self>\n }\n \n-trait set_f {\n+trait set_f<'self> {\n     fn set_f_ok(&self, b: @b<'self>);\n     fn set_f_bad(&self, b: @b);\n }\n \n-impl<'self> set_f for c<'self> {\n+impl<'self> set_f<'self> for c<'self> {\n     fn set_f_ok(&self, b: @b<'self>) {\n         self.f = b;\n     }"}, {"sha": "9855a234618ab872f64f69c6aea3291f64965a8a", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test #5723\n+\n+// Test that you cannot escape a borrowed pointer\n+// into a trait.\n+\n struct ctxt { v: uint }\n \n trait get_ctxt {\n@@ -24,8 +29,9 @@ fn make_gc() -> @get_ctxt  {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n     return @hc as @get_ctxt;\n+    //^~ ERROR source contains borrowed pointer\n }\n \n fn main() {\n-    make_gc().get_ctxt().v; //~ ERROR illegal borrow\n+    make_gc().get_ctxt().v;\n }"}, {"sha": "9bcf0777bbd349ae3d35ccc482c9381bab14620c", "filename": "src/test/compile-fail/staticness-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -14,7 +14,7 @@ trait foo {\n }\n \n impl foo for int {\n-    fn bar(&self) {} //~ ERROR method `bar` is declared as static in its trait, but not in its impl\n+    fn bar(&self) {} //~ ERROR method `bar` has a `&self` declaration in the impl, but not in the trait\n }\n \n fn main() {}"}, {"sha": "e4374e4d225a7b453e1157feb1b8b1e9c3849a94", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -59,7 +59,7 @@ impl<T> Mutable for cat<T> {\n }\n \n impl<T> Map<int, T> for cat<T> {\n-    fn each(&self, f: &fn(&int, &T) -> bool) {\n+    fn each<'a>(&'a self, f: &fn(&int, &'a T) -> bool) {\n         let mut n = int::abs(self.meows);\n         while n > 0 {\n             if !f(&n, &self.name) { break; }\n@@ -73,7 +73,7 @@ impl<T> Map<int, T> for cat<T> {\n         for self.each |k, _| { if !f(k) { break; } loop;};\n     }\n \n-    fn each_value(&self, f: &fn(v: &T) -> bool) {\n+    fn each_value<'a>(&'a self, f: &fn(v: &'a T) -> bool) {\n         for self.each |_, v| { if !f(v) { break; } loop;};\n     }\n \n@@ -86,15 +86,15 @@ impl<T> Map<int, T> for cat<T> {\n         true\n     }\n \n-    fn find(&self, k: &int) -> Option<&'self T> {\n+    fn find<'a>(&'a self, k: &int) -> Option<&'a T> {\n         if *k <= self.meows {\n             Some(&self.name)\n         } else {\n             None\n         }\n     }\n \n-    fn find_mut(&mut self, _k: &int) -> Option<&'self mut T> { fail!() }\n+    fn find_mut<'a>(&'a mut self, _k: &int) -> Option<&'a mut T> { fail!() }\n \n     fn remove(&mut self, k: &int) -> bool {\n         if self.find(k).is_some() {\n@@ -106,7 +106,7 @@ impl<T> Map<int, T> for cat<T> {\n }\n \n pub impl<T> cat<T> {\n-    fn get(&self, k: &int) -> &'self T {\n+    fn get<'a>(&'a self, k: &int) -> &'a T {\n         match self.find(k) {\n           Some(v) => { v }\n           None    => { fail!(~\"epic fail\"); }"}, {"sha": "7e46bf22c4d92f40b0ea3a02ba09d584b0ac5032", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -58,7 +58,7 @@ pub impl thing {\n     fn foo(@self) -> int { *self.x.a }\n     fn bar(~self) -> int { *self.x.a }\n     fn quux(&self) -> int { *self.x.a }\n-    fn baz(&self) -> &'self A { &self.x }\n+    fn baz<'a>(&'a self) -> &'a A { &self.x }\n     fn spam(self) -> int { *self.x.a }\n }\n "}, {"sha": "46aa7187c9a02af6785fe263ad4caa557046eb32", "filename": "src/test/run-pass/issue-3860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fissue-3860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3860.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -11,7 +11,7 @@\n struct Foo { x: int }\n \n pub impl Foo {\n-    fn stuff(&mut self) -> &'self mut Foo {\n+    fn stuff<'a>(&'a mut self) -> &'a mut Foo {\n         return self;\n     }\n }"}, {"sha": "346a0fcfe07939c4ac9c592fa1bbbd9221eee40f", "filename": "src/test/run-pass/regions-parameterization-self-types-issue-5224.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5bb2e8f62c5666f61db0b670f80f64ca673d22d6/src%2Ftest%2Frun-pass%2Fregions-parameterization-self-types-issue-5224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb2e8f62c5666f61db0b670f80f64ca673d22d6/src%2Ftest%2Frun-pass%2Fregions-parameterization-self-types-issue-5224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-parameterization-self-types-issue-5224.rs?ref=5bb2e8f62c5666f61db0b670f80f64ca673d22d6", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test how region-parameterization inference\n-// interacts with explicit self types.\n-//\n-// Issue #5224.\n-\n-trait Getter {\n-    // This trait does not need to be\n-    // region-parameterized, because 'self\n-    // is bound in the self type:\n-    fn get(&self) -> &'self int;\n-}\n-\n-struct Foo {\n-    field: int\n-}\n-\n-impl Getter for Foo {\n-    fn get(&self) -> &'self int { &self.field }\n-}\n-\n-fn get_int<G: Getter>(g: &G) -> int {\n-    *g.get()\n-}\n-\n-pub fn main() {\n-    let foo = Foo { field: 22 };\n-    assert!(get_int(&foo) == 22);\n-}"}, {"sha": "2f4eefe5243add3c61d4ab7ad230b3f29f90259c", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -16,7 +16,7 @@ trait get_chowder<'self> {\n     fn get_chowder(&self) -> &'self int;\n }\n \n-impl<'self> get_chowder for Clam<'self> {\n+impl<'self> get_chowder<'self> for Clam<'self> {\n     fn get_chowder(&self) -> &'self int { return self.chowder; }\n }\n "}, {"sha": "a2ed9da67f264d002e4bb879476e745e79bed72a", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f6606a8cca62baf89163d5091af5e594dafd20/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=76f6606a8cca62baf89163d5091af5e594dafd20", "patch": "@@ -16,7 +16,7 @@ trait get_ctxt<'self> {\n \n struct HasCtxt<'self> { c: &'self Ctxt }\n \n-impl<'self> get_ctxt for HasCtxt<'self> {\n+impl<'self> get_ctxt<'self> for HasCtxt<'self> {\n     fn get_ctxt(&self) -> &'self Ctxt {\n         self.c\n     }"}]}