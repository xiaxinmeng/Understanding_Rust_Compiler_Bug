{"sha": "f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZWNjMWY1MjFlODNjMzBkMGM2YmViM2NjYjkzMDdjZmExMmFlOWM=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-15T10:04:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-15T10:04:27Z"}, "message": "Rollup merge of #55182 - jD91mZM2:rebased, r=alexcrichton\n\nRedox: Update to new changes\n\nThese are all cherry-picked from our fork:\n\n - Remove the `env:` scheme\n - Update `execve` system call to `fexec`\n - Interpret shebangs: these are no longer handled by the kernel, which like usual tries to be as minimal as possible", "tree": {"sha": "098f9ce2fb23b287f7cff290c9432b4a664fcd56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/098f9ce2fb23b287f7cff290c9432b4a664fcd56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb7USrCRBK7hj4Ov3rIwAAdHIIAGA9isn447Yel/ByfoLQ5q8x\nGTgwObeM6/lc+J1lOejsVr6KM9vw7Ybn/FXmLMknVKZ8FL9PP4Gp1NaY/vUDeqcE\n8OAjjsdOYdvBN24sCxNHrhJeY3kRz2/o6uYeElJ66yCNqY3QntdqE/rPYs4dJkRY\nOOBUl9SQ0oM6KVAYqn7b5fLYOSEcdNJvIZZCXvxLyZjkWS85Y/P1oFGC3Rq+uvDE\nsPhWqxi1YImp7pxs9ILxDGAOnofGWNmB9fTl+Gw7O63Fy7dtYTCvK+BNoSkDi5gg\nQgT3g+4mwJTUeuLMy8z8U0jRJ+nHDa/niYW4Xt/xpoJCsttUNOIFuhmy6BqIVOk=\n=ZCC/\n-----END PGP SIGNATURE-----\n", "payload": "tree 098f9ce2fb23b287f7cff290c9432b4a664fcd56\nparent 4ec0ba9545f7c848aafc0bc1b8762507395edd41\nparent 51e2a63fafba5ab38f8ebfea803daaef2ec87d02\nauthor Pietro Albini <pietro@pietroalbini.org> 1542276267 +0100\ncommitter GitHub <noreply@github.com> 1542276267 +0100\n\nRollup merge of #55182 - jD91mZM2:rebased, r=alexcrichton\n\nRedox: Update to new changes\n\nThese are all cherry-picked from our fork:\n\n - Remove the `env:` scheme\n - Update `execve` system call to `fexec`\n - Interpret shebangs: these are no longer handled by the kernel, which like usual tries to be as minimal as possible\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "html_url": "https://github.com/rust-lang/rust/commit/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ec0ba9545f7c848aafc0bc1b8762507395edd41", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec0ba9545f7c848aafc0bc1b8762507395edd41", "html_url": "https://github.com/rust-lang/rust/commit/4ec0ba9545f7c848aafc0bc1b8762507395edd41"}, {"sha": "51e2a63fafba5ab38f8ebfea803daaef2ec87d02", "url": "https://api.github.com/repos/rust-lang/rust/commits/51e2a63fafba5ab38f8ebfea803daaef2ec87d02", "html_url": "https://github.com/rust-lang/rust/commit/51e2a63fafba5ab38f8ebfea803daaef2ec87d02"}], "stats": {"total": 300, "additions": 236, "deletions": 64}, "files": [{"sha": "c75ca6465a139704e00295be355b1f067af2f535", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -1 +1 @@\n-Subproject commit 1844a772b60771d0124a157019f627d60fea4e73\n+Subproject commit c75ca6465a139704e00295be355b1f067af2f535"}, {"sha": "3543d8f8fa3312e6ac9b4a4e7bde64882c5a4ca1", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -77,6 +77,29 @@ pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> {\n     result.map_err(|err| io::Error::from_raw_os_error(err.errno))\n }\n \n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt_libc<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n /// On Redox, use an illegal instruction to abort\n pub unsafe fn abort_internal() -> ! {\n     ::core::intrinsics::abort();"}, {"sha": "84eb56615b60d8e99a8ea75f984cb253a5a5ab71", "filename": "src/libstd/sys/redox/os.rs", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -12,10 +12,12 @@\n \n #![allow(unused_imports)] // lots of cfg code here\n \n+use libc::{self, c_char};\n+\n use os::unix::prelude::*;\n \n use error::Error as StdError;\n-use ffi::{OsString, OsStr};\n+use ffi::{CStr, CString, OsStr, OsString};\n use fmt;\n use io::{self, Read, Write};\n use iter;\n@@ -27,7 +29,7 @@ use ptr;\n use slice;\n use str;\n use sys_common::mutex::Mutex;\n-use sys::{cvt, fd, syscall};\n+use sys::{cvt, cvt_libc, fd, syscall};\n use vec;\n \n extern {\n@@ -129,6 +131,8 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     Ok(PathBuf::from(path))\n }\n \n+pub static ENV_LOCK: Mutex = Mutex::new();\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -140,52 +144,83 @@ impl Iterator for Env {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { static mut environ: *const *const c_char; }\n+    &mut environ\n+}\n+\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n-    let mut variables: Vec<(OsString, OsString)> = Vec::new();\n-    if let Ok(mut file) = ::fs::File::open(\"env:\") {\n-        let mut string = String::new();\n-        if file.read_to_string(&mut string).is_ok() {\n-            for line in string.lines() {\n-                let mut parts = line.splitn(2, '=');\n-                if let Some(name) = parts.next() {\n-                    let value = parts.next().unwrap_or(\"\");\n-                    variables.push((OsString::from(name.to_string()),\n-                                    OsString::from(value.to_string())));\n-                }\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        let mut environ = *environ();\n+        if environ == ptr::null() {\n+            panic!(\"os::env() failure getting env string from OS: {}\",\n+                   io::Error::last_os_error());\n+        }\n+        let mut result = Vec::new();\n+        while *environ != ptr::null() {\n+            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+                result.push(key_value);\n             }\n+            environ = environ.offset(1);\n+        }\n+        return Env {\n+            iter: result.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+\n+    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n+        // Strategy (copied from glibc): Variable name and value are separated\n+        // by an ASCII equals sign '='. Since a variable name must not be\n+        // empty, allow variable names starting with an equals sign. Skip all\n+        // malformed lines.\n+        if input.is_empty() {\n+            return None;\n         }\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n+        pos.map(|p| (\n+            OsStringExt::from_vec(input[..p].to_vec()),\n+            OsStringExt::from_vec(input[p+1..].to_vec()),\n+        ))\n     }\n-    Env { iter: variables.into_iter(), _dont_send_or_sync_me: PhantomData }\n }\n \n-pub fn getenv(key: &OsStr) -> io::Result<Option<OsString>> {\n-    if ! key.is_empty() {\n-        if let Ok(mut file) = ::fs::File::open(&(\"env:\".to_owned() + key.to_str().unwrap())) {\n-            let mut string = String::new();\n-            file.read_to_string(&mut string)?;\n-            Ok(Some(OsString::from(string)))\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    // environment variables with a nul byte can't be set, so their value is\n+    // always None as well\n+    let k = CString::new(k.as_bytes())?;\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n+        let ret = if s.is_null() {\n+            None\n         } else {\n-            Ok(None)\n-        }\n-    } else {\n-        Ok(None)\n+            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n+        };\n+        Ok(ret)\n     }\n }\n \n-pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> {\n-    if ! key.is_empty() {\n-        let mut file = ::fs::File::create(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n-        file.write_all(value.as_bytes())?;\n-        file.set_len(value.len() as u64)?;\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let k = CString::new(k.as_bytes())?;\n+    let v = CString::new(v.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        cvt_libc(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n     }\n-    Ok(())\n }\n \n-pub fn unsetenv(key: &OsStr) -> io::Result<()> {\n-    ::fs::remove_file(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n-    Ok(())\n+pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n+    let nbuf = CString::new(n.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        cvt_libc(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n+    }\n }\n \n pub fn page_size() -> usize {"}, {"sha": "4370c1e05027bd5552cbe1768b19567631d125c7", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n use env::{split_paths};\n-use ffi::OsStr;\n-use os::unix::ffi::OsStrExt;\n+use ffi::{CStr, OsStr};\n use fmt;\n-use io::{self, Error, ErrorKind};\n-use iter;\n+use fs::File;\n+use io::{self, prelude::*, BufReader, Error, ErrorKind, SeekFrom};\n use libc::{EXIT_SUCCESS, EXIT_FAILURE};\n+use os::unix::ffi::OsStrExt;\n use path::{Path, PathBuf};\n+use ptr;\n+use sys::ext::fs::MetadataExt;\n+use sys::ext::io::AsRawFd;\n use sys::fd::FileDesc;\n-use sys::fs::{File, OpenOptions};\n+use sys::fs::{File as SysFile, OpenOptions};\n+use sys::os::{ENV_LOCK, environ};\n use sys::pipe::{self, AnonPipe};\n use sys::{cvt, syscall};\n use sys_common::process::{CommandEnv, DefaultEnvKey};\n@@ -297,12 +301,6 @@ impl Command {\n             t!(callback());\n         }\n \n-        let args: Vec<[usize; 2]> = iter::once(\n-            [self.program.as_ptr() as usize, self.program.len()]\n-        ).chain(\n-            self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()])\n-        ).collect();\n-\n         self.env.apply();\n \n         let program = if self.program.contains(':') || self.program.contains('/') {\n@@ -321,14 +319,93 @@ impl Command {\n             None\n         };\n \n-        if let Some(program) = program {\n-            if let Err(err) = syscall::execve(program.as_os_str().as_bytes(), &args) {\n-                io::Error::from_raw_os_error(err.errno as i32)\n+        let mut file = if let Some(program) = program {\n+            t!(File::open(program.as_os_str()))\n+        } else {\n+            return io::Error::from_raw_os_error(syscall::ENOENT);\n+        };\n+\n+        // Push all the arguments\n+        let mut args: Vec<[usize; 2]> = Vec::with_capacity(1 + self.args.len());\n+\n+        let interpreter = {\n+            let mut reader = BufReader::new(&file);\n+\n+            let mut shebang = [0; 2];\n+            let mut read = 0;\n+            loop {\n+                match t!(reader.read(&mut shebang[read..])) {\n+                    0 => break,\n+                    n => read += n,\n+                }\n+            }\n+\n+            if &shebang == b\"#!\" {\n+                // This is an interpreted script.\n+                // First of all, since we'll be passing another file to\n+                // fexec(), we need to manually check that we have permission\n+                // to execute this file:\n+                let uid = t!(cvt(syscall::getuid()));\n+                let gid = t!(cvt(syscall::getgid()));\n+                let meta = t!(file.metadata());\n+\n+                let mode = if uid == meta.uid() as usize {\n+                    meta.mode() >> 3*2 & 0o7\n+                } else if gid == meta.gid() as usize {\n+                    meta.mode() >> 3*1 & 0o7\n+                } else {\n+                    meta.mode() & 0o7\n+                };\n+                if mode & 1 == 0 {\n+                    return io::Error::from_raw_os_error(syscall::EPERM);\n+                }\n+\n+                // Second of all, we need to actually read which interpreter it wants\n+                let mut interpreter = Vec::new();\n+                t!(reader.read_until(b'\\n', &mut interpreter));\n+                // Pop one trailing newline, if any\n+                if interpreter.ends_with(&[b'\\n']) {\n+                    interpreter.pop().unwrap();\n+                }\n+\n+                // FIXME: Here we could just reassign `file` directly, if it\n+                // wasn't for lexical lifetimes. Remove the whole `let\n+                // interpreter = { ... };` hack once NLL lands.\n+                // NOTE: Although DO REMEMBER to make sure the interpreter path\n+                // still lives long enough to reach fexec.\n+                Some(interpreter)\n             } else {\n-                panic!(\"return from exec without err\");\n+                None\n+            }\n+        };\n+        if let Some(ref interpreter) = interpreter {\n+            let path: &OsStr = OsStr::from_bytes(&interpreter);\n+            file = t!(File::open(path));\n+\n+            args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n+        } else {\n+            t!(file.seek(SeekFrom::Start(0)));\n+        }\n+\n+        args.push([self.program.as_ptr() as usize, self.program.len()]);\n+        args.extend(self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()]));\n+\n+        // Push all the variables\n+        let mut vars: Vec<[usize; 2]> = Vec::new();\n+        {\n+            let _guard = ENV_LOCK.lock();\n+            let mut environ = *environ();\n+            while *environ != ptr::null() {\n+                let var = CStr::from_ptr(*environ).to_bytes();\n+                vars.push([var.as_ptr() as usize, var.len()]);\n+                environ = environ.offset(1);\n             }\n+        }\n+\n+        if let Err(err) = syscall::fexec(file.as_raw_fd(), &args, &vars) {\n+            io::Error::from_raw_os_error(err.errno as i32)\n         } else {\n-            io::Error::from_raw_os_error(syscall::ENOENT)\n+            panic!(\"return from exec without err\");\n         }\n     }\n \n@@ -392,7 +469,7 @@ impl Stdio {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let fd = File::open(Path::new(\"null:\"), &opts)?;\n+                let fd = SysFile::open(Path::new(\"null:\"), &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n         }\n@@ -405,8 +482,8 @@ impl From<AnonPipe> for Stdio {\n     }\n }\n \n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n+impl From<SysFile> for Stdio {\n+    fn from(file: SysFile) -> Stdio {\n         Stdio::Fd(file.into_fd())\n     }\n }"}, {"sha": "61cd97d6d43858ab6875df067b1618a74a44a101", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -82,12 +82,6 @@ pub fn dup2(fd: usize, newfd: usize, buf: &[u8]) -> Result<usize> {\n     unsafe { syscall4(SYS_DUP2, fd, newfd, buf.as_ptr() as usize, buf.len()) }\n }\n \n-/// Replace the current process with a new executable\n-pub fn execve<T: AsRef<[u8]>>(path: T, args: &[[usize; 2]]) -> Result<usize> {\n-    unsafe { syscall4(SYS_EXECVE, path.as_ref().as_ptr() as usize,\n-                      path.as_ref().len(), args.as_ptr() as usize, args.len()) }\n-}\n-\n /// Exit the current process\n pub fn exit(status: usize) -> Result<usize> {\n     unsafe { syscall1(SYS_EXIT, status) }\n@@ -110,9 +104,10 @@ pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> Result<usize> {\n     unsafe { syscall3(SYS_FCNTL, fd, cmd, arg) }\n }\n \n-/// Register a file for event-based I/O\n-pub fn fevent(fd: usize, flags: usize) -> Result<usize> {\n-    unsafe { syscall2(SYS_FEVENT, fd, flags) }\n+/// Replace the current process with a new executable\n+pub fn fexec(fd: usize, args: &[[usize; 2]], vars: &[[usize; 2]]) -> Result<usize> {\n+    unsafe { syscall5(SYS_FEXEC, fd, args.as_ptr() as usize, args.len(),\n+                      vars.as_ptr() as usize, vars.len()) }\n }\n \n /// Map a file into memory"}, {"sha": "0f1a2c2315973b8e21e49808b9376f5c5aff02df", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -113,4 +113,46 @@ pub const SA_RESTART: usize =   0x10000000;\n pub const SA_NODEFER: usize =   0x40000000;\n pub const SA_RESETHAND: usize = 0x80000000;\n \n-pub const WNOHANG: usize = 1;\n+pub const WNOHANG: usize =    0x01;\n+pub const WUNTRACED: usize =  0x02;\n+pub const WCONTINUED: usize = 0x08;\n+\n+/// True if status indicates the child is stopped.\n+pub fn wifstopped(status: usize) -> bool {\n+    (status & 0xff) == 0x7f\n+}\n+\n+/// If wifstopped(status), the signal that stopped the child.\n+pub fn wstopsig(status: usize) -> usize {\n+    (status >> 8) & 0xff\n+}\n+\n+/// True if status indicates the child continued after a stop.\n+pub fn wifcontinued(status: usize) -> bool {\n+    status == 0xffff\n+}\n+\n+/// True if STATUS indicates termination by a signal.\n+pub fn wifsignaled(status: usize) -> bool {\n+    ((status & 0x7f) + 1) as i8 >= 2\n+}\n+\n+/// If wifsignaled(status), the terminating signal.\n+pub fn wtermsig(status: usize) -> usize {\n+    status & 0x7f\n+}\n+\n+/// True if status indicates normal termination.\n+pub fn wifexited(status: usize) -> bool {\n+    wtermsig(status) == 0\n+}\n+\n+/// If wifexited(status), the exit status.\n+pub fn wexitstatus(status: usize) -> usize {\n+    (status >> 8) & 0xff\n+}\n+\n+/// True if status indicates a core dump was created.\n+pub fn wcoredump(status: usize) -> bool {\n+    (status & 0x80) != 0\n+}"}, {"sha": "1e187565a675c9548c286a07971e4e2254b2c36f", "filename": "src/libstd/sys/redox/syscall/number.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs?ref=f4ecc1f521e83c30d0c6beb3ccb9307cfa12ae9c", "patch": "@@ -36,6 +36,7 @@ pub const SYS_FCHMOD: usize =   SYS_CLASS_FILE | 94;\n pub const SYS_FCHOWN: usize =   SYS_CLASS_FILE | 207;\n pub const SYS_FCNTL: usize =    SYS_CLASS_FILE | 55;\n pub const SYS_FEVENT: usize =   SYS_CLASS_FILE | 927;\n+pub const SYS_FEXEC: usize =    SYS_CLASS_FILE | 11;\n pub const SYS_FMAP: usize =     SYS_CLASS_FILE | 90;\n pub const SYS_FUNMAP: usize =   SYS_CLASS_FILE | 91;\n pub const SYS_FPATH: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 928;\n@@ -50,7 +51,6 @@ pub const SYS_BRK: usize =      45;\n pub const SYS_CHDIR: usize =    12;\n pub const SYS_CLOCK_GETTIME: usize = 265;\n pub const SYS_CLONE: usize =    120;\n-pub const SYS_EXECVE: usize =   11;\n pub const SYS_EXIT: usize =     1;\n pub const SYS_FUTEX: usize =    240;\n pub const SYS_GETCWD: usize =   183;"}]}