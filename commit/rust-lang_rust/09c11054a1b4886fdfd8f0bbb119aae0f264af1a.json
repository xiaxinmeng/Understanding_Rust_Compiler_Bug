{"sha": "09c11054a1b4886fdfd8f0bbb119aae0f264af1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YzExMDU0YTFiNDg4NmZkZmQ4ZjBiYmIxMTlhYWUwZjI2NGFmMWE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-17T00:22:19Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-17T00:57:38Z"}, "message": "Do trait solving in batch", "tree": {"sha": "002d34cf02c156e7301e0e79f9cd127a4204723e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/002d34cf02c156e7301e0e79f9cd127a4204723e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09c11054a1b4886fdfd8f0bbb119aae0f264af1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09c11054a1b4886fdfd8f0bbb119aae0f264af1a", "html_url": "https://github.com/rust-lang/rust/commit/09c11054a1b4886fdfd8f0bbb119aae0f264af1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09c11054a1b4886fdfd8f0bbb119aae0f264af1a/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68626e4ef5acfea05812b68f41efa2bcd5bea448", "url": "https://api.github.com/repos/rust-lang/rust/commits/68626e4ef5acfea05812b68f41efa2bcd5bea448", "html_url": "https://github.com/rust-lang/rust/commit/68626e4ef5acfea05812b68f41efa2bcd5bea448"}], "stats": {"total": 192, "additions": 97, "deletions": 95}, "files": [{"sha": "517abbb4bc0eb41178a5b0fa95d07bf6d4d69e86", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 97, "deletions": 95, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/09c11054a1b4886fdfd8f0bbb119aae0f264af1a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c11054a1b4886fdfd8f0bbb119aae0f264af1a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=09c11054a1b4886fdfd8f0bbb119aae0f264af1a", "patch": "@@ -1,6 +1,6 @@\n //! Look up accessible paths for items.\n use either::Either;\n-use hir::{AsAssocItem, AssocItem, Module, ModuleDef, PrefixKind, Semantics};\n+use hir::{AsAssocItem, AssocItem, Crate, MacroDef, Module, ModuleDef, PrefixKind, Semantics};\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n@@ -168,73 +168,8 @@ impl ImportAssets {\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<hir::PrefixKind>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let db = sema.db;\n-        let mut trait_candidates = FxHashSet::default();\n         let current_crate = self.module_with_candidate.krate();\n \n-        let filter = |candidate: Either<hir::ModuleDef, hir::MacroDef>| {\n-            // TODO kb process all traits at once instead?\n-            trait_candidates.clear();\n-            match &self.import_candidate {\n-                ImportCandidate::TraitAssocItem(trait_candidate) => {\n-                    let canidate_assoc_item = match candidate {\n-                        Either::Left(module_def) => module_def.as_assoc_item(db),\n-                        _ => None,\n-                    }?;\n-                    trait_candidates.insert(canidate_assoc_item.containing_trait(db)?.into());\n-\n-                    trait_candidate\n-                        .receiver_ty\n-                        .iterate_path_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, assoc| {\n-                                if canidate_assoc_item == assoc {\n-                                    if let AssocItem::Function(f) = assoc {\n-                                        if f.self_param(db).is_some() {\n-                                            return None;\n-                                        }\n-                                    }\n-                                    Some(assoc_to_module_def(assoc))\n-                                } else {\n-                                    None\n-                                }\n-                            },\n-                        )\n-                        .map(Either::Left)\n-                }\n-                ImportCandidate::TraitMethod(trait_candidate) => {\n-                    let canidate_assoc_item = match candidate {\n-                        Either::Left(module_def) => module_def.as_assoc_item(db),\n-                        _ => None,\n-                    }?;\n-                    trait_candidates.insert(canidate_assoc_item.containing_trait(db)?.into());\n-\n-                    trait_candidate\n-                        .receiver_ty\n-                        .iterate_method_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, function| {\n-                                let assoc = function.as_assoc_item(db)?;\n-                                if canidate_assoc_item == assoc {\n-                                    Some(assoc_to_module_def(assoc))\n-                                } else {\n-                                    None\n-                                }\n-                            },\n-                        )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                _ => Some(candidate),\n-            }\n-        };\n-\n         let unfiltered_imports = match self.name_to_import() {\n             NameToImport::Exact(exact_name) => {\n                 imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n@@ -261,42 +196,109 @@ impl ImportAssets {\n             }\n         };\n \n-        let mut res = unfiltered_imports\n-            .filter_map(filter)\n-            .filter_map(|candidate| {\n-                let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n+        let db = sema.db;\n+        let mut res =\n+            applicable_defs(self.import_candidate(), current_crate, db, unfiltered_imports)\n+                .filter_map(|candidate| {\n+                    let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n \n-                let item_to_search = match self.import_candidate {\n-                    ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n-                        let canidate_trait = match candidate {\n-                            Either::Left(module_def) => {\n-                                module_def.as_assoc_item(db)?.containing_trait(db)\n-                            }\n-                            _ => None,\n-                        }?;\n-                        ModuleDef::from(canidate_trait).into()\n-                    }\n-                    _ => item,\n-                };\n+                    let item_to_search = match self.import_candidate {\n+                        ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n+                            let canidate_trait = match candidate {\n+                                Either::Left(module_def) => {\n+                                    module_def.as_assoc_item(db)?.containing_trait(db)\n+                                }\n+                                _ => None,\n+                            }?;\n+                            ModuleDef::from(canidate_trait).into()\n+                        }\n+                        _ => item,\n+                    };\n \n-                if let Some(prefix_kind) = prefixed {\n-                    self.module_with_candidate.find_use_path_prefixed(\n-                        db,\n-                        item_to_search,\n-                        prefix_kind,\n-                    )\n-                } else {\n-                    self.module_with_candidate.find_use_path(db, item_to_search)\n-                }\n-                .map(|path| (path, item))\n-            })\n-            .filter(|(use_path, _)| use_path.len() > 1)\n-            .collect::<Vec<_>>();\n+                    if let Some(prefix_kind) = prefixed {\n+                        self.module_with_candidate.find_use_path_prefixed(\n+                            db,\n+                            item_to_search,\n+                            prefix_kind,\n+                        )\n+                    } else {\n+                        self.module_with_candidate.find_use_path(db, item_to_search)\n+                    }\n+                    .map(|path| (path, item))\n+                })\n+                .filter(|(use_path, _)| use_path.len() > 1)\n+                .collect::<Vec<_>>();\n         res.sort_by_cached_key(|(path, _)| path.clone());\n         res\n     }\n }\n \n+fn applicable_defs<'a>(\n+    import_candidate: &ImportCandidate,\n+    current_crate: Crate,\n+    db: &RootDatabase,\n+    unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n+) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n+    let receiver_ty = match import_candidate {\n+        ImportCandidate::Path(_) => return unfiltered_imports,\n+        ImportCandidate::TraitAssocItem(candidate) | ImportCandidate::TraitMethod(candidate) => {\n+            &candidate.receiver_ty\n+        }\n+    };\n+\n+    let mut required_assoc_items = FxHashSet::default();\n+\n+    let trait_candidates = unfiltered_imports\n+        .filter_map(|input| match input {\n+            Either::Left(module_def) => module_def.as_assoc_item(db),\n+            _ => None,\n+        })\n+        .filter_map(|assoc| {\n+            let assoc_item_trait = assoc.containing_trait(db)?;\n+            required_assoc_items.insert(assoc);\n+            Some(assoc_item_trait.into())\n+        })\n+        .collect();\n+\n+    let mut applicable_defs = FxHashSet::default();\n+\n+    match import_candidate {\n+        ImportCandidate::Path(_) => unreachable!(),\n+        ImportCandidate::TraitAssocItem(_) => receiver_ty.iterate_path_candidates(\n+            db,\n+            current_crate,\n+            &trait_candidates,\n+            None,\n+            |_, assoc| {\n+                if required_assoc_items.contains(&assoc) {\n+                    if let AssocItem::Function(f) = assoc {\n+                        if f.self_param(db).is_some() {\n+                            return None;\n+                        }\n+                    }\n+                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                }\n+                None::<()>\n+            },\n+        ),\n+        ImportCandidate::TraitMethod(_) => receiver_ty.iterate_method_candidates(\n+            db,\n+            current_crate,\n+            &trait_candidates,\n+            None,\n+            |_, function| {\n+                let assoc = function.as_assoc_item(db)?;\n+                if required_assoc_items.contains(&assoc) {\n+                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                }\n+                None::<()>\n+            },\n+        ),\n+    };\n+\n+    Box::new(applicable_defs.into_iter())\n+}\n+\n fn assoc_to_module_def(assoc: AssocItem) -> ModuleDef {\n     match assoc {\n         AssocItem::Function(f) => f.into(),"}]}