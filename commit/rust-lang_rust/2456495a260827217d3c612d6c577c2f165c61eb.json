{"sha": "2456495a260827217d3c612d6c577c2f165c61eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NTY0OTVhMjYwODI3MjE3ZDNjNjEyZDZjNTc3YzJmMTY1YzYxZWI=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-05-30T17:25:41Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-07-08T21:55:54Z"}, "message": "Stop generating `alloca`s+`memcmp` for simple array equality", "tree": {"sha": "e85ffd47a15f93a5b6f0a6324bb8b747659a2448", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85ffd47a15f93a5b6f0a6324bb8b747659a2448"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2456495a260827217d3c612d6c577c2f165c61eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2456495a260827217d3c612d6c577c2f165c61eb", "html_url": "https://github.com/rust-lang/rust/commit/2456495a260827217d3c612d6c577c2f165c61eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2456495a260827217d3c612d6c577c2f165c61eb/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d05eafae2fcc05bd64ab094a1352a5c16df3106e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d05eafae2fcc05bd64ab094a1352a5c16df3106e", "html_url": "https://github.com/rust-lang/rust/commit/d05eafae2fcc05bd64ab094a1352a5c16df3106e"}], "stats": {"total": 242, "additions": 238, "deletions": 4}, "files": [{"sha": "d1aecd32e2f2d00cddfc0d24b6329dd7e2b90f28", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -500,6 +500,7 @@ impl CodegenCx<'b, 'tcx> {\n         let t_i32 = self.type_i32();\n         let t_i64 = self.type_i64();\n         let t_i128 = self.type_i128();\n+        let t_isize = self.type_isize();\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n \n@@ -712,6 +713,10 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.assume\", fn(i1) -> void);\n         ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n+        // This isn't an \"LLVM intrinsic\", but LLVM's optimization passes\n+        // recognize it like one and we assume it exists in `core::slice::cmp`\n+        ifn!(\"memcmp\", fn(i8p, i8p, t_isize) -> t_i32);\n+\n         // variadic intrinsics\n         ifn!(\"llvm.va_start\", fn(i8p) -> void);\n         ifn!(\"llvm.va_end\", fn(i8p) -> void);"}, {"sha": "615295e96e116e30b4ed7e74184e7d422be6b8c8", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -296,6 +296,32 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n+            sym::raw_eq => {\n+                let tp_ty = substs.type_at(0);\n+                let (size, align) = self.size_and_align_of(tp_ty);\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                if size.bytes() == 0 {\n+                    self.const_bool(true)\n+                } else if size > self.data_layout().pointer_size * 4 {\n+                    let i8p_ty = self.type_i8p();\n+                    let a_ptr = self.bitcast(a, i8p_ty);\n+                    let b_ptr = self.bitcast(b, i8p_ty);\n+                    let n = self.const_usize(size.bytes());\n+                    let llfn = self.get_intrinsic(\"memcmp\");\n+                    let cmp = self.call(llfn, &[a_ptr, b_ptr, n], None);\n+                    self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))\n+                } else {\n+                    let integer_ty = self.type_ix(size.bits());\n+                    let ptr_ty = self.type_ptr_to(integer_ty);\n+                    let a_ptr = self.bitcast(a, ptr_ty);\n+                    let a_val = self.load(a_ptr, align);\n+                    let b_ptr = self.bitcast(b, ptr_ty);\n+                    let b_val = self.load(b_ptr, align);\n+                    self.icmp(IntPredicate::IntEQ, a_val, b_val)\n+                }\n+            }\n+\n             _ if name_str.starts_with(\"simd_\") => {\n                 match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                     Ok(llval) => llval,"}, {"sha": "5dd679b8912ce0b21dd83489ec8961bd518020a2", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -472,6 +472,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n             }\n+            sym::raw_eq => {\n+                let result = self.raw_eq_intrinsic(&args[0], &args[1])?;\n+                self.write_scalar(result, dest)?;\n+            }\n             _ => return Ok(false),\n         }\n \n@@ -559,4 +563,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.memory.copy(src, align, dst, align, size, nonoverlapping)\n     }\n+\n+    pub(crate) fn raw_eq_intrinsic(\n+        &mut self,\n+        lhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n+        rhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::PointerTag>,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n+\n+        let lhs = self.read_scalar(lhs)?.check_init()?;\n+        let rhs = self.read_scalar(rhs)?.check_init()?;\n+        let lhs_bytes = self.memory.read_bytes(lhs, layout.size)?;\n+        let rhs_bytes = self.memory.read_bytes(rhs, layout.size)?;\n+        Ok(Scalar::Int((lhs_bytes == rhs_bytes).into()))\n+    }\n }"}, {"sha": "3ab32fe418db1ae644d9ff59ae745712c53ee0f7", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -933,6 +933,7 @@ symbols! {\n         quote,\n         range_inclusive_new,\n         raw_dylib,\n+        raw_eq,\n         raw_identifiers,\n         raw_ref_op,\n         re_rebalance_coherence,"}, {"sha": "18ccaf79d32c8f3c84d2e25d77f12f9cd7c13055", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -380,6 +380,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n+            sym::raw_eq => {\n+                let param_count = if intrinsic_name == sym::raw_eq { 2 } else { 1 };\n+                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n+                let param_ty =\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)), param(0));\n+                (1, vec![param_ty; param_count], tcx.types.bool)\n+            }\n+\n             other => {\n                 tcx.sess.emit_err(UnrecognizedIntrinsicFunction { span: it.span, name: other });\n                 return;"}, {"sha": "6d66b9e2f27807b44423dda566c9631d2110f2eb", "filename": "library/core/src/array/equality.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fequality.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -5,11 +5,11 @@ where\n {\n     #[inline]\n     fn eq(&self, other: &[B; N]) -> bool {\n-        self[..] == other[..]\n+        SpecArrayEq::spec_eq(self, other)\n     }\n     #[inline]\n     fn ne(&self, other: &[B; N]) -> bool {\n-        self[..] != other[..]\n+        SpecArrayEq::spec_ne(self, other)\n     }\n }\n \n@@ -109,3 +109,52 @@ where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq, const N: usize> Eq for [T; N] {}\n+\n+trait SpecArrayEq<Other, const N: usize>: Sized {\n+    fn spec_eq(a: &[Self; N], b: &[Other; N]) -> bool;\n+    fn spec_ne(a: &[Self; N], b: &[Other; N]) -> bool;\n+}\n+\n+impl<T: PartialEq<Other>, Other, const N: usize> SpecArrayEq<Other, N> for T {\n+    default fn spec_eq(a: &[Self; N], b: &[Other; N]) -> bool {\n+        a[..] == b[..]\n+    }\n+    default fn spec_ne(a: &[Self; N], b: &[Other; N]) -> bool {\n+        a[..] != b[..]\n+    }\n+}\n+\n+impl<T: PartialEq<U> + IsRawEqComparable<U>, U, const N: usize> SpecArrayEq<U, N> for T {\n+    #[cfg(bootstrap)]\n+    fn spec_eq(a: &[T; N], b: &[U; N]) -> bool {\n+        a[..] == b[..]\n+    }\n+    #[cfg(not(bootstrap))]\n+    fn spec_eq(a: &[T; N], b: &[U; N]) -> bool {\n+        // SAFETY: This is why `IsRawEqComparable` is an `unsafe trait`.\n+        unsafe {\n+            let b = &*b.as_ptr().cast::<[T; N]>();\n+            crate::intrinsics::raw_eq(a, b)\n+        }\n+    }\n+    fn spec_ne(a: &[T; N], b: &[U; N]) -> bool {\n+        !Self::spec_eq(a, b)\n+    }\n+}\n+\n+/// `U` exists on here mostly because `min_specialization` didn't let me\n+/// repeat the `T` type parameter in the above specialization, so instead\n+/// the `T == U` constraint comes from the impls on this.\n+/// # Safety\n+/// - Neither `Self` nor `U` has any padding.\n+/// - `Self` and `U` have the same layout.\n+/// - `Self: PartialEq<U>` is byte-wise (this means no floats, among other things)\n+#[rustc_specialization_trait]\n+unsafe trait IsRawEqComparable<U> {}\n+\n+macro_rules! is_raw_comparable {\n+    ($($t:ty),+) => {$(\n+        unsafe impl IsRawEqComparable<$t> for $t {}\n+    )+};\n+}\n+is_raw_comparable!(bool, char, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);"}, {"sha": "7d2c278aa05233cdb4ddbd4026ab87ca1220165f", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -1913,6 +1913,22 @@ extern \"rust-intrinsic\" {\n     /// Allocate at compile time. Should not be called at runtime.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n+\n+    /// Determines whether the raw bytes of the two values are equal.\n+    ///\n+    /// The is particularly handy for arrays, since it allows things like just\n+    /// comparing `i96`s instead of forcing `alloca`s for `[6 x i16]`.\n+    ///\n+    /// Above some backend-decided threshold this will emit calls to `memcmp`,\n+    /// like slice equality does, instead of causing massive code size.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This doesn't take into account padding, so if `T` has padding\n+    /// the result will be `undef`, which cannot be exposed to safe code.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_intrinsic_raw_eq\", issue = \"none\")]\n+    pub fn raw_eq<T>(a: &T, b: &T) -> bool;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "6a9fb5c8f864dcd0677d16e0ad53d84cf5c078ef", "filename": "src/test/codegen/array-equality.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fcodegen%2Farray-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fcodegen%2Farray-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Farray-equality.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -0,0 +1,36 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @array_eq_value\n+#[no_mangle]\n+pub fn array_eq_value(a: [u16; 6], b: [u16; 6]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: %2 = icmp eq i96 %0, %1\n+    // CHECK-NEXT: ret i1 %2\n+    a == b\n+}\n+\n+// CHECK-LABEL: @array_eq_ref\n+#[no_mangle]\n+pub fn array_eq_ref(a: &[u16; 6], b: &[u16; 6]) -> bool {\n+    // CHECK: start:\n+    // CHECK: load i96, i96* %{{.+}}, align 2\n+    // CHECK: load i96, i96* %{{.+}}, align 2\n+    // CHECK: icmp eq i96\n+    // CHECK-NEXT: ret\n+    a == b\n+}\n+\n+// CHECK-LABEL: @array_eq_long\n+#[no_mangle]\n+pub fn array_eq_long(a: &[u16; 1234], b: &[u16; 1234]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: bitcast\n+    // CHECK-NEXT: bitcast\n+    // CHECK-NEXT: %[[CMP:.+]] = tail call i32 @{{bcmp|memcmp}}(i8* nonnull dereferenceable(2468) %{{.+}}, i8* nonnull dereferenceable(2468) %{{.+}}, i64 2468)\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[CMP]], 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n+    a == b\n+}"}, {"sha": "1f99ac7342b39c5c77779a6a3080c783edc09a5f", "filename": "src/test/codegen/slice-ref-equality.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-ref-equality.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -2,15 +2,30 @@\n \n #![crate_type = \"lib\"]\n \n-// #71602: check that slice equality just generates a single bcmp\n+// #71602 reported a simple array comparison just generating a loop.\n+// This was originally fixed by ensuring it generates a single bcmp,\n+// but we now generate it as a load instead. `is_zero_slice` was\n+// tweaked to still test the case of comparison against a slice,\n+// and `is_zero_array` tests the new array-specific behaviour.\n \n // CHECK-LABEL: @is_zero_slice\n #[no_mangle]\n pub fn is_zero_slice(data: &[u8; 4]) -> bool {\n-    // CHECK: start:\n+    // CHECK: :\n     // CHECK-NEXT: %{{.+}} = getelementptr {{.+}}\n     // CHECK-NEXT: %[[BCMP:.+]] = tail call i32 @{{bcmp|memcmp}}({{.+}})\n     // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[BCMP]], 0\n     // CHECK-NEXT: ret i1 %[[EQ]]\n+    &data[..] == [0; 4]\n+}\n+\n+// CHECK-LABEL: @is_zero_array\n+#[no_mangle]\n+pub fn is_zero_array(data: &[u8; 4]) -> bool {\n+    // CHECK: start:\n+    // CHECK-NEXT: %[[PTR:.+]] = bitcast [4 x i8]* {{.+}} to i32*\n+    // CHECK-NEXT: %[[LOAD:.+]] = load i32, i32* %[[PTR]], align 1\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i32 %[[LOAD]], 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n     *data == [0; 4]\n }"}, {"sha": "ec1c47cfaea9faab644433e74e7a1694c2dc2303", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const-padding.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -0,0 +1,12 @@\n+#![feature(core_intrinsics)]\n+#![feature(const_intrinsic_raw_eq)]\n+#![deny(const_err)]\n+\n+const BAD_RAW_EQ_CALL: bool = unsafe {\n+    std::intrinsics::raw_eq(&(1_u8, 2_u16), &(1_u8, 2_u16))\n+//~^ ERROR any use of this value will cause an error\n+//~| WARNING this was previously accepted by the compiler but is being phased out\n+};\n+\n+pub fn main() {\n+}"}, {"sha": "74df99a69d1faff7bb857b1bdad395c39fd3d468", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const-padding.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -0,0 +1,21 @@\n+error: any use of this value will cause an error\n+  --> $DIR/intrinsic-raw_eq-const-padding.rs:6:5\n+   |\n+LL | / const BAD_RAW_EQ_CALL: bool = unsafe {\n+LL | |     std::intrinsics::raw_eq(&(1_u8, 2_u16), &(1_u8, 2_u16))\n+   | |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ reading 4 bytes of memory starting at alloc2, but 1 byte is uninitialized starting at alloc2+0x1, and this operation requires initialized memory\n+LL | |\n+LL | |\n+LL | | };\n+   | |__-\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intrinsic-raw_eq-const-padding.rs:3:9\n+   |\n+LL | #![deny(const_err)]\n+   |         ^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to previous error\n+"}, {"sha": "8ea954673020e12aa51b7b898086a2b3631baf02", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2456495a260827217d3c612d6c577c2f165c61eb/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const.rs?ref=2456495a260827217d3c612d6c577c2f165c61eb", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+\n+#![feature(core_intrinsics)]\n+#![feature(const_intrinsic_raw_eq)]\n+#![deny(const_err)]\n+\n+pub fn main() {\n+    use std::intrinsics::raw_eq;\n+\n+    const RAW_EQ_I32_TRUE: bool = unsafe { raw_eq(&42_i32, &42) };\n+    assert!(RAW_EQ_I32_TRUE);\n+\n+    const RAW_EQ_I32_FALSE: bool = unsafe { raw_eq(&4_i32, &2) };\n+    assert!(!RAW_EQ_I32_FALSE);\n+\n+    const RAW_EQ_CHAR_TRUE: bool = unsafe { raw_eq(&'a', &'a') };\n+    assert!(RAW_EQ_CHAR_TRUE);\n+\n+    const RAW_EQ_CHAR_FALSE: bool = unsafe { raw_eq(&'a', &'A') };\n+    assert!(!RAW_EQ_CHAR_FALSE);\n+\n+    const RAW_EQ_ARRAY_TRUE: bool = unsafe { raw_eq(&[13_u8, 42], &[13, 42]) };\n+    assert!(RAW_EQ_ARRAY_TRUE);\n+\n+    const RAW_EQ_ARRAY_FALSE: bool = unsafe { raw_eq(&[13_u8, 42], &[42, 13]) };\n+    assert!(!RAW_EQ_ARRAY_FALSE);\n+}"}]}