{"sha": "015300109d96a70d63ee12c012cc5170defbf133", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNTMwMDEwOWQ5NmE3MGQ2M2VlMTJjMDEyY2M1MTcwZGVmYmYxMzM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-06T15:25:15Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-06T15:26:00Z"}, "message": "cache Ty::is_simd", "tree": {"sha": "2ebea89f3f9b434544487ba7b2691383266d4e0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ebea89f3f9b434544487ba7b2691383266d4e0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/015300109d96a70d63ee12c012cc5170defbf133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/015300109d96a70d63ee12c012cc5170defbf133", "html_url": "https://github.com/rust-lang/rust/commit/015300109d96a70d63ee12c012cc5170defbf133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/015300109d96a70d63ee12c012cc5170defbf133/comments", "author": null, "committer": null, "parents": [{"sha": "612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7", "html_url": "https://github.com/rust-lang/rust/commit/612760bea06e55dc4cb7bf7cdf430e8b1ba8d8e7"}], "stats": {"total": 81, "additions": 45, "deletions": 36}, "files": [{"sha": "d54271b753170cff5201e57289b71d3beda9b8d0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -3179,11 +3179,12 @@ impl<'tcx> TraitDef<'tcx> {\n bitflags! {\n     flags ADTFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n-        const IS_FUNDAMENTAL      = 1 << 0,\n-        const IS_PHANTOM_DATA     = 1 << 1,\n-        const IS_DTORCK           = 1 << 2, // is this a dtorck type?\n-        const IS_DTORCK_VALID     = 1 << 3,\n-        const IS_ENUM             = 1 << 4\n+        const IS_ENUM             = 1 << 0,\n+        const IS_DTORCK           = 1 << 1, // is this a dtorck type?\n+        const IS_DTORCK_VALID     = 1 << 2,\n+        const IS_PHANTOM_DATA     = 1 << 3,\n+        const IS_SIMD             = 1 << 4,\n+        const IS_FUNDAMENTAL      = 1 << 5,\n     }\n }\n \n@@ -3244,9 +3245,13 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n            kind: ADTKind,\n            variants: Vec<VariantDef_<'tcx, 'lt>>) -> Self {\n         let mut flags = ADTFlags::NO_ADT_FLAGS;\n-        if tcx.has_attr(did, \"fundamental\") {\n+        let attrs = tcx.get_attrs(did);\n+        if attrs.iter().any(|item| item.check_name(\"fundamental\")) {\n             flags = flags | ADTFlags::IS_FUNDAMENTAL;\n         }\n+        if attrs.iter().any(|item| item.check_name(\"simd\")) {\n+            flags = flags | ADTFlags::IS_SIMD;\n+        }\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | ADTFlags::IS_PHANTOM_DATA;\n         }\n@@ -3289,6 +3294,11 @@ impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n         self.flags.get().intersects(ADTFlags::IS_FUNDAMENTAL)\n     }\n \n+    #[inline]\n+    pub fn is_simd(&self) -> bool {\n+        self.flags.get().intersects(ADTFlags::IS_SIMD)\n+    }\n+\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.get().intersects(ADTFlags::IS_PHANTOM_DATA)\n@@ -4203,9 +4213,10 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_simd(&self, cx: &ctxt) -> bool {\n+    #[inline]\n+    pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyStruct(def, _) => cx.lookup_simd(def.did),\n+            TyStruct(def, _) => def.is_simd(),\n             _ => false\n         }\n     }\n@@ -5979,7 +5990,6 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-        // TODO: remove\n         memoized(&self.repr_hint_cache, did, |did: DefId| {\n             Rc::new(if did.krate == LOCAL_CRATE {\n                 self.get_attrs(did).iter().flat_map(|meta| {"}, {"sha": "a0dd489cd8a9bc332818eed7bc1a4e873a41c685", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -621,7 +621,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n-        ty::TyStruct(_, _) if rhs_t.is_simd(cx.tcx()) => {\n+        ty::TyStruct(def, _) if def.is_simd() => {\n             let mut res = C_bool(cx.ccx(), false);\n             for i in 0 .. rhs_t.simd_size(cx.tcx()) {\n                 res = Or(cx, res,"}, {"sha": "7bc6f4c8fe96ce9483ed07f5355c44752aef6435", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -192,7 +192,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     let simple = ty.is_scalar() ||\n         ty.is_unique() || ty.is_region_ptr() ||\n         type_is_newtype_immediate(ccx, ty) ||\n-        ty.is_simd(tcx);\n+        ty.is_simd();\n     if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n     }"}, {"sha": "7aaed035f21270e0c41b098d7cd03c5af52dd331", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -500,7 +500,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n-            let is_simd = ty.is_simd(cx.tcx());\n+            let is_simd = ty.is_simd();\n             let intype = if is_simd {\n                 ty.simd_type(cx.tcx())\n             } else {\n@@ -754,7 +754,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n                 }\n             }).collect::<Vec<_>>();\n-            if ety.is_simd(cx.tcx()) {\n+            if ety.is_simd() {\n                 C_vector(&cs[..])\n             } else {\n                 adt::trans_const(cx, &*repr, discr, &cs[..])\n@@ -850,7 +850,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n                 }\n                 def::DefStruct(_) => {\n-                    if ety.is_simd(cx.tcx()) {\n+                    if ety.is_simd() {\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);"}, {"sha": "3ca639cc36702645631d9248005841fbf3edf873", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -1175,7 +1175,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         StructMDF(StructMemberDescriptionFactory {\n             variant: variant,\n             substs: substs,\n-            is_simd: struct_type.is_simd(cx.tcx()),\n+            is_simd: struct_type.is_simd(),\n             span: span,\n         })\n     )"}, {"sha": "c5043f867ded09d3e939e697eb9c1ddd84760d7c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -1453,7 +1453,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    if ty.is_simd(bcx.tcx()) {\n+    if ty.is_simd() {\n         // Issue 23112: The original logic appeared vulnerable to same\n         // order-of-eval bug. But, SIMD values are tuple-structs;\n         // i.e. functional record update (FRU) syntax is unavailable.\n@@ -1697,7 +1697,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let tcx = bcx.tcx();\n-    let is_simd = lhs_t.is_simd(tcx);\n+    let is_simd = lhs_t.is_simd();\n     let intype = if is_simd {\n         lhs_t.simd_type(tcx)\n     } else {\n@@ -2502,7 +2502,7 @@ fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n     let tcx = bcx.tcx();\n-    let is_simd = lhs_t.is_simd(tcx);\n+    let is_simd = lhs_t.is_simd();\n     let intype = if is_simd {\n         lhs_t.simd_type(tcx)\n     } else {"}, {"sha": "225ff52a63c5915c99c08abfef507698f8f18e98", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -449,7 +449,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n     if !tcx.sess.features.borrow().simd_ffi {\n         let check = |ast_ty: &ast::Ty, ty: ty::Ty| {\n-            if ty.is_simd(tcx) {\n+            if ty.is_simd() {\n                 tcx.sess.span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\","}, {"sha": "cf3cde8907f7f3e2b4a72190295e38eb6b64b918", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -419,7 +419,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n-            assert!(!t.is_simd(bcx.tcx()));\n+            assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_context_of(ccx, &*repr, true);\n             debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());"}, {"sha": "0b969360f537e04aff52cdfc9b3dcb32c0650c27", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -222,7 +222,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyStruct(..) => {\n-            if t.is_simd(cx.tcx()) {\n+            if t.is_simd() {\n                 let llet = type_of(cx, t.simd_type(cx.tcx()));\n                 let n = t.simd_size(cx.tcx()) as u64;\n                 ensure_array_fits_in_address_space(cx, llet, n, t);\n@@ -404,7 +404,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           adt::type_of(cx, &*repr)\n       }\n       ty::TyStruct(def, ref substs) => {\n-          if t.is_simd(cx.tcx()) {\n+          if t.is_simd() {\n               let llet = in_memory_type_of(cx, t.simd_type(cx.tcx()));\n               let n = t.simd_size(cx.tcx()) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n@@ -436,7 +436,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n         ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n-                if !t.is_simd(cx.tcx()) => {\n+                if !t.is_simd() => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n         }"}, {"sha": "b139cb45bf207519229e1326f7e83d4759773789", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/015300109d96a70d63ee12c012cc5170defbf133/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=015300109d96a70d63ee12c012cc5170defbf133", "patch": "@@ -21,7 +21,7 @@ use super::{\n     structurally_resolved_type,\n };\n use middle::traits;\n-use middle::ty::{self, Ty, HasTypeFlags};\n+use middle::ty::{Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -41,7 +41,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let lhs_ty = structurally_resolved_type(fcx, lhs_expr.span, fcx.expr_ty(lhs_expr));\n     let rhs_ty = structurally_resolved_type(fcx, rhs_expr.span, fcx.expr_ty(rhs_expr));\n \n-    if is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op) {\n+    if is_builtin_binop(lhs_ty, rhs_ty, op) {\n         enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n         fcx.write_nil(expr.id);\n     } else {\n@@ -86,7 +86,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // traits, because their return type is not bool. Perhaps this\n     // should change, but for now if LHS is SIMD we go down a\n     // different path that bypassess all traits.\n-    if lhs_ty.is_simd(fcx.tcx()) {\n+    if lhs_ty.is_simd() {\n         check_expr_coercable_to_type(fcx, rhs_expr, lhs_ty);\n         let rhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n         let return_ty = enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -123,7 +123,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n             if\n                 !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n-                is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op)\n+                is_builtin_binop(lhs_ty, rhs_ty, op)\n             {\n                 let builtin_return_ty =\n                     enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -143,7 +143,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          op: ast::BinOp)\n                                          -> Ty<'tcx>\n {\n-    debug_assert!(is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op));\n+    debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n     let tcx = fcx.tcx();\n     match BinOpCategory::from(op) {\n@@ -156,7 +156,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         BinOpCategory::Shift => {\n             // For integers, the shift amount can be of any integral\n             // type. For simd, the type must match exactly.\n-            if lhs_ty.is_simd(tcx) {\n+            if lhs_ty.is_simd() {\n                 demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n             }\n \n@@ -176,7 +176,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n \n             // if this is simd, result is same as lhs, else bool\n-            if lhs_ty.is_simd(tcx) {\n+            if lhs_ty.is_simd() {\n                 let unit_ty = lhs_ty.simd_type(tcx);\n                 debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n                        lhs_ty,\n@@ -415,8 +415,7 @@ impl BinOpCategory {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/trans after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n-                          lhs: Ty<'tcx>,\n+fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>,\n                           rhs: Ty<'tcx>,\n                           op: ast::BinOp)\n                           -> bool\n@@ -429,28 +428,28 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n         BinOpCategory::Shift => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx)\n+                lhs.is_simd() && rhs.is_simd()\n         }\n \n         BinOpCategory::Math => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n                 lhs.is_floating_point() && rhs.is_floating_point() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx)\n+                lhs.is_simd() && rhs.is_simd()\n         }\n \n         BinOpCategory::Bitwise => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n                 lhs.is_floating_point() && rhs.is_floating_point() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx) ||\n+                lhs.is_simd() && rhs.is_simd() ||\n                 lhs.is_bool() && rhs.is_bool()\n         }\n \n         BinOpCategory::Comparison => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_scalar() && rhs.is_scalar() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx)\n+                lhs.is_simd() && rhs.is_simd()\n         }\n     }\n }"}]}