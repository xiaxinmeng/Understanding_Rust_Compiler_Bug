{"sha": "d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNmY5ZTQyZGY3NjYwM2ZkMjFiMGZlNWRkMWU4MDAxY2FmOWJmODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T00:35:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T00:35:33Z"}, "message": "Auto merge of #49698 - SimonSapin:unicode-for-everyone, r=alexcrichton\n\nMerge the std_unicode crate into the core crate\n\n[The standard library facade](https://github.com/rust-lang/rust/issues/27783) has historically contained a number of crates with different roles, but that number has decreased over time. `rand` and `libc` have moved to crates.io, and [`collections` was merged into `alloc`](https://github.com/rust-lang/rust/pull/42648). Today we have `core` that applies everywhere, `std` that expects a full operating system, and `alloc` in-between that only requires a memory allocator (which can be provided by users)\u2026 and `std_unicode`, which doesn\u2019t really have a reason to be separate anymore. It contains functionality based on Unicode data tables that can be large, but as long as relevant functions are not called the tables should be removed from binaries by linkers.\n\nThis deprecates the unstable `std_unicode` crate and moves all of its contents into `core`, replacing them with `pub use` reexports. The crate can be removed later. This also removes the `CharExt` trait (replaced with inherent methods in libcore) and `UnicodeStr` trait (merged into `StrExt`). There traits were both unstable and not intended to be used or named directly.\n\nA number of new items are newly-available in libcore and instantly stable there, but only if they were already stable in libstd.\n\nFixes #49319.", "tree": {"sha": "ce66073c04b872fdc4bc51d3a7f51fe32bf8a680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce66073c04b872fdc4bc51d3a7f51fe32bf8a680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "html_url": "https://github.com/rust-lang/rust/commit/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e28ef22ae5ef22a48e8582210bb8be9aba116b81", "url": "https://api.github.com/repos/rust-lang/rust/commits/e28ef22ae5ef22a48e8582210bb8be9aba116b81", "html_url": "https://github.com/rust-lang/rust/commit/e28ef22ae5ef22a48e8582210bb8be9aba116b81"}, {"sha": "ef41788cf37074e44f70257508c97efd539a7f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef41788cf37074e44f70257508c97efd539a7f29", "html_url": "https://github.com/rust-lang/rust/commit/ef41788cf37074e44f70257508c97efd539a7f29"}], "stats": {"total": 2935, "additions": 1398, "deletions": 1537}, "files": [{"sha": "6e7c4b67acf24ade2fe82c5e9286830dde9d3e85", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -13,7 +13,6 @@ dependencies = [\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n  \"rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"std_unicode 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "853923ad947cd2ced021be50f5e7ef8e93c73c51", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -34,4 +34,3 @@ ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n   src/test/mir-opt \\\n   src/test/codegen-units \\\n   src/libcore \\\n-  src/libstd_unicode/ \\"}, {"sha": "6a7aea7f1c27e5b60345786c9b6a020315577cd3", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -243,7 +243,7 @@ the source code.\n   - `usize`: `libcore/num/mod.rs`\n   - `f32`: `libstd/f32.rs`\n   - `f64`: `libstd/f64.rs`\n-  - `char`: `libstd_unicode/char.rs`\n+  - `char`: `libcore/char.rs`\n   - `slice`: `liballoc/slice.rs`\n   - `str`: `liballoc/str.rs`\n   - `const_ptr`: `libcore/ptr.rs`"}, {"sha": "6383bd1e941ed48c4ae5c02fbc0c9b9bdfe02720", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -9,7 +9,6 @@ path = \"lib.rs\"\n \n [dependencies]\n core = { path = \"../libcore\" }\n-std_unicode = { path = \"../libstd_unicode\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n \n [dev-dependencies]"}, {"sha": "69fc007ab7c163285d53c6b5297eb12a1759768e", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -113,7 +113,7 @@\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(unicode)]\n+#![feature(unicode_internals)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n@@ -135,8 +135,6 @@ extern crate test;\n #[cfg(test)]\n extern crate rand;\n \n-extern crate std_unicode;\n-\n // Module with internal macros used by other modules (needs to be included before other modules).\n #[macro_use]\n mod macros;"}, {"sha": "65df93bd3bb54da1845a9e61e363471ed1a52e56", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -45,12 +45,10 @@ use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n use core::iter::FusedIterator;\n-use std_unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n use string::String;\n-use std_unicode;\n use vec::Vec;\n use slice::{SliceConcatExt, SliceIndex};\n use boxed::Box;\n@@ -75,7 +73,7 @@ pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use std_unicode::str::SplitWhitespace;\n+pub use core::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n \n@@ -147,7 +145,8 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n #[derive(Clone)]\n #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n pub struct EncodeUtf16<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>,\n+    chars: Chars<'a>,\n+    extra: u16,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -163,12 +162,29 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n \n     #[inline]\n     fn next(&mut self) -> Option<u16> {\n-        self.encoder.next()\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0; 2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n+            buf[0]\n+        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.encoder.size_hint()\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n     }\n }\n \n@@ -801,7 +817,7 @@ impl str {\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     #[inline]\n     pub fn split_whitespace(&self) -> SplitWhitespace {\n-        UnicodeStr::split_whitespace(self)\n+        StrExt::split_whitespace(self)\n     }\n \n     /// An iterator over the lines of a string, as string slices.\n@@ -871,7 +887,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n     pub fn encode_utf16(&self) -> EncodeUtf16 {\n-        EncodeUtf16 { encoder: Utf16Encoder::new(self[..].chars()) }\n+        EncodeUtf16 { chars: self[..].chars(), extra: 0 }\n     }\n \n     /// Returns `true` if the given pattern matches a sub-slice of\n@@ -1571,7 +1587,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim(&self) -> &str {\n-        UnicodeStr::trim(self)\n+        StrExt::trim(self)\n     }\n \n     /// Returns a string slice with leading whitespace removed.\n@@ -1607,7 +1623,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self)\n+        StrExt::trim_left(self)\n     }\n \n     /// Returns a string slice with trailing whitespace removed.\n@@ -1643,7 +1659,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self)\n+        StrExt::trim_right(self)\n     }\n \n     /// Returns a string slice with all prefixes and suffixes that match a\n@@ -1960,7 +1976,7 @@ impl str {\n         }\n \n         fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n-            use std_unicode::derived_property::{Cased, Case_Ignorable};\n+            use core::unicode::derived_property::{Cased, Case_Ignorable};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),\n                 None => false,\n@@ -2142,7 +2158,7 @@ impl str {\n     #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n     #[inline]\n     pub fn is_whitespace(&self) -> bool {\n-        UnicodeStr::is_whitespace(self)\n+        StrExt::is_whitespace(self)\n     }\n \n     /// Returns true if this `str` is entirely alphanumeric, and false otherwise.\n@@ -2161,7 +2177,7 @@ impl str {\n     #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n     #[inline]\n     pub fn is_alphanumeric(&self) -> bool {\n-        UnicodeStr::is_alphanumeric(self)\n+        StrExt::is_alphanumeric(self)\n     }\n \n     /// Checks if all characters in this string are within the ASCII range."}, {"sha": "29d759b1f00070727974cf9450a7d63cbc5ebeda", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -56,15 +56,15 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use core::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::str::pattern::Pattern;\n-use std_unicode::lossy;\n-use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+use core::str::lossy;\n \n use borrow::{Cow, ToOwned};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};"}, {"sha": "32272169307000cf1269593fb6f1dd1a1c5bb7ad", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -24,12 +24,11 @@\n #![feature(string_retain)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(unicode)]\n #![feature(exact_chunks)]\n #![feature(inclusive_range_fields)]\n \n extern crate alloc_system;\n-extern crate std_unicode;\n+extern crate core;\n extern crate rand;\n \n use std::hash::{Hash, Hasher};"}, {"sha": "a3f4c385fe23b731b52f329312790a1ba494253b", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -1204,8 +1204,7 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n #[test]\n fn test_utf16_code_units() {\n-    use std_unicode::str::Utf16Encoder;\n-    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n+    assert_eq!(\"\u00e9\\u{1F4A9}\".encode_utf16().collect::<Vec<u16>>(),\n                [0xE9, 0xD83D, 0xDCA9])\n }\n "}, {"sha": "17d53e4cf3e09c46fc4cdc1905916428816c11bd", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -132,7 +132,7 @@ fn test_from_utf16() {\n         let s_as_utf16 = s.encode_utf16().collect::<Vec<u16>>();\n         let u_as_string = String::from_utf16(&u).unwrap();\n \n-        assert!(::std_unicode::char::decode_utf16(u.iter().cloned()).all(|r| r.is_ok()));\n+        assert!(::core::char::decode_utf16(u.iter().cloned()).all(|r| r.is_ok()));\n         assert_eq!(s_as_utf16, u);\n \n         assert_eq!(u_as_string, s);"}, {"sha": "718c6b893edf229cfecf8ddb9d337521634136fd", "filename": "src/libcore/char.rs", "status": "removed", "additions": 0, "deletions": 918, "changes": 918, "blob_url": "https://github.com/rust-lang/rust/blob/e28ef22ae5ef22a48e8582210bb8be9aba116b81/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28ef22ae5ef22a48e8582210bb8be9aba116b81/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=e28ef22ae5ef22a48e8582210bb8be9aba116b81", "patch": "@@ -1,918 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Character manipulation.\n-//!\n-//! For more details, see ::std_unicode::char (a.k.a. std::char)\n-\n-#![allow(non_snake_case)]\n-#![stable(feature = \"core_char\", since = \"1.2.0\")]\n-\n-use char_private::is_printable;\n-use convert::TryFrom;\n-use fmt::{self, Write};\n-use slice;\n-use str::{from_utf8_unchecked_mut, FromStr};\n-use iter::FusedIterator;\n-use mem::transmute;\n-\n-// UTF-8 ranges and tags for encoding characters\n-const TAG_CONT: u8    = 0b1000_0000;\n-const TAG_TWO_B: u8   = 0b1100_0000;\n-const TAG_THREE_B: u8 = 0b1110_0000;\n-const TAG_FOUR_B: u8  = 0b1111_0000;\n-const MAX_ONE_B: u32   =     0x80;\n-const MAX_TWO_B: u32   =    0x800;\n-const MAX_THREE_B: u32 =  0x10000;\n-\n-/*\n-    Lu  Uppercase_Letter        an uppercase letter\n-    Ll  Lowercase_Letter        a lowercase letter\n-    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n-    Lm  Modifier_Letter         a modifier letter\n-    Lo  Other_Letter            other letters, including syllables and ideographs\n-    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n-    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n-    Me  Enclosing_Mark          an enclosing combining mark\n-    Nd  Decimal_Number          a decimal digit\n-    Nl  Letter_Number           a letterlike numeric character\n-    No  Other_Number            a numeric character of other type\n-    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n-    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n-    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n-    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n-    Pi  Initial_Punctuation     an initial quotation mark\n-    Pf  Final_Punctuation       a final quotation mark\n-    Po  Other_Punctuation       a punctuation mark of other type\n-    Sm  Math_Symbol             a symbol of primarily mathematical use\n-    Sc  Currency_Symbol         a currency sign\n-    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n-    So  Other_Symbol            a symbol of other type\n-    Zs  Space_Separator         a space character (of various non-zero widths)\n-    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n-    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n-    Cc  Control                 a C0 or C1 control code\n-    Cf  Format                  a format control character\n-    Cs  Surrogate               a surrogate code point\n-    Co  Private_Use             a private-use character\n-    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n-*/\n-\n-/// The highest valid code point a `char` can have.\n-///\n-/// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n-/// Point], but only ones within a certain range. `MAX` is the highest valid\n-/// code point that's a valid [Unicode Scalar Value].\n-///\n-/// [`char`]: ../../std/primitive.char.html\n-/// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n-/// [Code Point]: http://www.unicode.org/glossary/#code_point\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: char = '\\u{10ffff}';\n-\n-/// Converts a `u32` to a `char`.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// [`as`]:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n-/// for a [`char`].\n-///\n-/// [`char`]: ../../std/primitive.char.html\n-/// [`u32`]: ../../std/primitive.u32.html\n-/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n-///\n-/// For an unsafe version of this function which ignores these checks, see\n-/// [`from_u32_unchecked`].\n-///\n-/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x2764);\n-///\n-/// assert_eq!(Some('\u2764'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a valid [`char`]:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x110000);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_u32(i: u32) -> Option<char> {\n-    char::try_from(i).ok()\n-}\n-\n-/// Converts a `u32` to a `char`, ignoring validity.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// [`as`]:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n-/// [`char`], possibly creating an invalid one.\n-///\n-/// [`char`]: ../../std/primitive.char.html\n-/// [`u32`]: ../../std/primitive.u32.html\n-/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n-///\n-/// # Safety\n-///\n-/// This function is unsafe, as it may construct invalid `char` values.\n-///\n-/// For a safe version of this function, see the [`from_u32`] function.\n-///\n-/// [`from_u32`]: fn.from_u32.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n-///\n-/// assert_eq!('\u2764', c);\n-/// ```\n-#[inline]\n-#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-    transmute(i)\n-}\n-\n-#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-impl From<char> for u32 {\n-    #[inline]\n-    fn from(c: char) -> Self {\n-        c as u32\n-    }\n-}\n-\n-/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n-///\n-/// Unicode is designed such that this effectively decodes bytes\n-/// with the character encoding that IANA calls ISO-8859-1.\n-/// This encoding is compatible with ASCII.\n-///\n-/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n-/// which leaves some \"blanks\", byte values that are not assigned to any character.\n-/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n-///\n-/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n-/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n-/// to punctuation and various Latin characters.\n-///\n-/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n-/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n-/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n-/// C0 and C1 control codes.\n-#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-impl From<u8> for char {\n-    #[inline]\n-    fn from(i: u8) -> Self {\n-        i as char\n-    }\n-}\n-\n-\n-/// An error which can be returned when parsing a char.\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct ParseCharError {\n-    kind: CharErrorKind,\n-}\n-\n-impl ParseCharError {\n-    #[unstable(feature = \"char_error_internals\",\n-               reason = \"this method should not be available publicly\",\n-               issue = \"0\")]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        match self.kind {\n-            CharErrorKind::EmptyString => {\n-                \"cannot parse char from empty string\"\n-            },\n-            CharErrorKind::TooManyChars => \"too many characters in string\"\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum CharErrorKind {\n-    EmptyString,\n-    TooManyChars,\n-}\n-\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-impl fmt::Display for ParseCharError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.__description().fmt(f)\n-    }\n-}\n-\n-\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-impl FromStr for char {\n-    type Err = ParseCharError;\n-\n-    #[inline]\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        let mut chars = s.chars();\n-        match (chars.next(), chars.next()) {\n-            (None, _) => {\n-                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n-            },\n-            (Some(c), None) => Ok(c),\n-            _ => {\n-                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n-            }\n-        }\n-    }\n-}\n-\n-\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-impl TryFrom<u32> for char {\n-    type Error = CharTryFromError;\n-\n-    #[inline]\n-    fn try_from(i: u32) -> Result<Self, Self::Error> {\n-        if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n-            Err(CharTryFromError(()))\n-        } else {\n-            Ok(unsafe { from_u32_unchecked(i) })\n-        }\n-    }\n-}\n-\n-/// The error type returned when a conversion from u32 to char fails.\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct CharTryFromError(());\n-\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-impl fmt::Display for CharTryFromError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"converted integer out of range for `char`\".fmt(f)\n-    }\n-}\n-\n-/// Converts a digit in the given radix to a `char`.\n-///\n-/// A 'radix' here is sometimes also called a 'base'. A radix of two\n-/// indicates a binary number, a radix of ten, decimal, and a radix of\n-/// sixteen, hexadecimal, to give some common values. Arbitrary\n-/// radices are supported.\n-///\n-/// `from_digit()` will return `None` if the input is not a digit in\n-/// the given radix.\n-///\n-/// # Panics\n-///\n-/// Panics if given a radix larger than 36.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(4, 10);\n-///\n-/// assert_eq!(Some('4'), c);\n-///\n-/// // Decimal 11 is a single digit in base 16\n-/// let c = char::from_digit(11, 16);\n-///\n-/// assert_eq!(Some('b'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a digit:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(20, 10);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-///\n-/// Passing a large radix, causing a panic:\n-///\n-/// ```\n-/// use std::thread;\n-/// use std::char;\n-///\n-/// let result = thread::spawn(|| {\n-///     // this panics\n-///     let c = char::from_digit(1, 37);\n-/// }).join();\n-///\n-/// assert!(result.is_err());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n-    if radix > 36 {\n-        panic!(\"from_digit: radix is too high (maximum 36)\");\n-    }\n-    if num < radix {\n-        let num = num as u8;\n-        if num < 10 {\n-            Some((b'0' + num) as char)\n-        } else {\n-            Some((b'a' + num - 10) as char)\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-// NB: the stabilization and documentation for this trait is in\n-// unicode/char.rs, not here\n-#[allow(missing_docs)] // docs in libunicode/u_char.rs\n-#[doc(hidden)]\n-#[unstable(feature = \"core_char_ext\",\n-           reason = \"the stable interface is `impl char` in later crate\",\n-           issue = \"32110\")]\n-pub trait CharExt {\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn is_digit(self, radix: u32) -> bool;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn to_digit(self, radix: u32) -> Option<u32>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn escape_unicode(self) -> EscapeUnicode;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn escape_default(self) -> EscapeDefault;\n-    #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-    fn escape_debug(self) -> EscapeDebug;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn len_utf8(self) -> usize;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn len_utf16(self) -> usize;\n-    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> &mut str;\n-    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n-}\n-\n-#[stable(feature = \"core\", since = \"1.6.0\")]\n-impl CharExt for char {\n-    #[inline]\n-    fn is_digit(self, radix: u32) -> bool {\n-        self.to_digit(radix).is_some()\n-    }\n-\n-    #[inline]\n-    fn to_digit(self, radix: u32) -> Option<u32> {\n-        if radix > 36 {\n-            panic!(\"to_digit: radix is too high (maximum 36)\");\n-        }\n-        let val = match self {\n-          '0' ... '9' => self as u32 - '0' as u32,\n-          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n-          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n-          _ => return None,\n-        };\n-        if val < radix { Some(val) }\n-        else { None }\n-    }\n-\n-    #[inline]\n-    fn escape_unicode(self) -> EscapeUnicode {\n-        let c = self as u32;\n-\n-        // or-ing 1 ensures that for c==0 the code computes that one\n-        // digit should be printed and (which is the same) avoids the\n-        // (31 - 32) underflow\n-        let msb = 31 - (c | 1).leading_zeros();\n-\n-        // the index of the most significant hex digit\n-        let ms_hex_digit = msb / 4;\n-        EscapeUnicode {\n-            c: self,\n-            state: EscapeUnicodeState::Backslash,\n-            hex_digit_idx: ms_hex_digit as usize,\n-        }\n-    }\n-\n-    #[inline]\n-    fn escape_default(self) -> EscapeDefault {\n-        let init_state = match self {\n-            '\\t' => EscapeDefaultState::Backslash('t'),\n-            '\\r' => EscapeDefaultState::Backslash('r'),\n-            '\\n' => EscapeDefaultState::Backslash('n'),\n-            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n-        };\n-        EscapeDefault { state: init_state }\n-    }\n-\n-    #[inline]\n-    fn escape_debug(self) -> EscapeDebug {\n-        let init_state = match self {\n-            '\\t' => EscapeDefaultState::Backslash('t'),\n-            '\\r' => EscapeDefaultState::Backslash('r'),\n-            '\\n' => EscapeDefaultState::Backslash('n'),\n-            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            c if is_printable(c) => EscapeDefaultState::Char(c),\n-            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n-        };\n-        EscapeDebug(EscapeDefault { state: init_state })\n-    }\n-\n-    #[inline]\n-    fn len_utf8(self) -> usize {\n-        let code = self as u32;\n-        if code < MAX_ONE_B {\n-            1\n-        } else if code < MAX_TWO_B {\n-            2\n-        } else if code < MAX_THREE_B {\n-            3\n-        } else {\n-            4\n-        }\n-    }\n-\n-    #[inline]\n-    fn len_utf16(self) -> usize {\n-        let ch = self as u32;\n-        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n-    }\n-\n-    #[inline]\n-    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n-        let code = self as u32;\n-        unsafe {\n-            let len =\n-            if code < MAX_ONE_B && !dst.is_empty() {\n-                *dst.get_unchecked_mut(0) = code as u8;\n-                1\n-            } else if code < MAX_TWO_B && dst.len() >= 2 {\n-                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n-                2\n-            } else if code < MAX_THREE_B && dst.len() >= 3  {\n-                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n-                3\n-            } else if dst.len() >= 4 {\n-                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n-                4\n-            } else {\n-                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n-                    from_u32_unchecked(code).len_utf8(),\n-                    code,\n-                    dst.len())\n-            };\n-            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n-        }\n-    }\n-\n-    #[inline]\n-    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n-        let mut code = self as u32;\n-        unsafe {\n-            if (code & 0xFFFF) == code && !dst.is_empty() {\n-                // The BMP falls through (assuming non-surrogate, as it should)\n-                *dst.get_unchecked_mut(0) = code as u16;\n-                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n-            } else if dst.len() >= 2 {\n-                // Supplementary planes break into surrogates.\n-                code -= 0x1_0000;\n-                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n-                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n-                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n-            } else {\n-                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n-                    from_u32_unchecked(code).len_utf16(),\n-                    code,\n-                    dst.len())\n-            }\n-        }\n-    }\n-}\n-\n-/// Returns an iterator that yields the hexadecimal Unicode escape of a\n-/// character, as `char`s.\n-///\n-/// This `struct` is created by the [`escape_unicode`] method on [`char`]. See\n-/// its documentation for more.\n-///\n-/// [`escape_unicode`]: ../../std/primitive.char.html#method.escape_unicode\n-/// [`char`]: ../../std/primitive.char.html\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct EscapeUnicode {\n-    c: char,\n-    state: EscapeUnicodeState,\n-\n-    // The index of the next hex digit to be printed (0 if none),\n-    // i.e. the number of remaining hex digits to be printed;\n-    // increasing from the least significant digit: 0x543210\n-    hex_digit_idx: usize,\n-}\n-\n-// The enum values are ordered so that their representation is the\n-// same as the remaining length (besides the hexadecimal digits). This\n-// likely makes `len()` a single load from memory) and inline-worth.\n-#[derive(Clone, Debug)]\n-enum EscapeUnicodeState {\n-    Done,\n-    RightBrace,\n-    Value,\n-    LeftBrace,\n-    Type,\n-    Backslash,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for EscapeUnicode {\n-    type Item = char;\n-\n-    fn next(&mut self) -> Option<char> {\n-        match self.state {\n-            EscapeUnicodeState::Backslash => {\n-                self.state = EscapeUnicodeState::Type;\n-                Some('\\\\')\n-            }\n-            EscapeUnicodeState::Type => {\n-                self.state = EscapeUnicodeState::LeftBrace;\n-                Some('u')\n-            }\n-            EscapeUnicodeState::LeftBrace => {\n-                self.state = EscapeUnicodeState::Value;\n-                Some('{')\n-            }\n-            EscapeUnicodeState::Value => {\n-                let hex_digit = ((self.c as u32) >> (self.hex_digit_idx * 4)) & 0xf;\n-                let c = from_digit(hex_digit, 16).unwrap();\n-                if self.hex_digit_idx == 0 {\n-                    self.state = EscapeUnicodeState::RightBrace;\n-                } else {\n-                    self.hex_digit_idx -= 1;\n-                }\n-                Some(c)\n-            }\n-            EscapeUnicodeState::RightBrace => {\n-                self.state = EscapeUnicodeState::Done;\n-                Some('}')\n-            }\n-            EscapeUnicodeState::Done => None,\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = self.len();\n-        (n, Some(n))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.len()\n-    }\n-\n-    fn last(self) -> Option<char> {\n-        match self.state {\n-            EscapeUnicodeState::Done => None,\n-\n-            EscapeUnicodeState::RightBrace |\n-            EscapeUnicodeState::Value |\n-            EscapeUnicodeState::LeftBrace |\n-            EscapeUnicodeState::Type |\n-            EscapeUnicodeState::Backslash => Some('}'),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n-impl ExactSizeIterator for EscapeUnicode {\n-    #[inline]\n-    fn len(&self) -> usize {\n-        // The match is a single memory access with no branching\n-        self.hex_digit_idx + match self.state {\n-            EscapeUnicodeState::Done => 0,\n-            EscapeUnicodeState::RightBrace => 1,\n-            EscapeUnicodeState::Value => 2,\n-            EscapeUnicodeState::LeftBrace => 3,\n-            EscapeUnicodeState::Type => 4,\n-            EscapeUnicodeState::Backslash => 5,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for EscapeUnicode {}\n-\n-#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n-impl fmt::Display for EscapeUnicode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        for c in self.clone() {\n-            f.write_char(c)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// An iterator that yields the literal escape code of a `char`.\n-///\n-/// This `struct` is created by the [`escape_default`] method on [`char`]. See\n-/// its documentation for more.\n-///\n-/// [`escape_default`]: ../../std/primitive.char.html#method.escape_default\n-/// [`char`]: ../../std/primitive.char.html\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct EscapeDefault {\n-    state: EscapeDefaultState\n-}\n-\n-#[derive(Clone, Debug)]\n-enum EscapeDefaultState {\n-    Done,\n-    Char(char),\n-    Backslash(char),\n-    Unicode(EscapeUnicode),\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for EscapeDefault {\n-    type Item = char;\n-\n-    fn next(&mut self) -> Option<char> {\n-        match self.state {\n-            EscapeDefaultState::Backslash(c) => {\n-                self.state = EscapeDefaultState::Char(c);\n-                Some('\\\\')\n-            }\n-            EscapeDefaultState::Char(c) => {\n-                self.state = EscapeDefaultState::Done;\n-                Some(c)\n-            }\n-            EscapeDefaultState::Done => None,\n-            EscapeDefaultState::Unicode(ref mut iter) => iter.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = self.len();\n-        (n, Some(n))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.len()\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<char> {\n-        match self.state {\n-            EscapeDefaultState::Backslash(c) if n == 0 => {\n-                self.state = EscapeDefaultState::Char(c);\n-                Some('\\\\')\n-            },\n-            EscapeDefaultState::Backslash(c) if n == 1 => {\n-                self.state = EscapeDefaultState::Done;\n-                Some(c)\n-            },\n-            EscapeDefaultState::Backslash(_) => {\n-                self.state = EscapeDefaultState::Done;\n-                None\n-            },\n-            EscapeDefaultState::Char(c) => {\n-                self.state = EscapeDefaultState::Done;\n-\n-                if n == 0 {\n-                    Some(c)\n-                } else {\n-                    None\n-                }\n-            },\n-            EscapeDefaultState::Done => return None,\n-            EscapeDefaultState::Unicode(ref mut i) => return i.nth(n),\n-        }\n-    }\n-\n-    fn last(self) -> Option<char> {\n-        match self.state {\n-            EscapeDefaultState::Unicode(iter) => iter.last(),\n-            EscapeDefaultState::Done => None,\n-            EscapeDefaultState::Backslash(c) | EscapeDefaultState::Char(c) => Some(c),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n-impl ExactSizeIterator for EscapeDefault {\n-    fn len(&self) -> usize {\n-        match self.state {\n-            EscapeDefaultState::Done => 0,\n-            EscapeDefaultState::Char(_) => 1,\n-            EscapeDefaultState::Backslash(_) => 2,\n-            EscapeDefaultState::Unicode(ref iter) => iter.len(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for EscapeDefault {}\n-\n-#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n-impl fmt::Display for EscapeDefault {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        for c in self.clone() {\n-            f.write_char(c)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// An iterator that yields the literal escape code of a `char`.\n-///\n-/// This `struct` is created by the [`escape_debug`] method on [`char`]. See its\n-/// documentation for more.\n-///\n-/// [`escape_debug`]: ../../std/primitive.char.html#method.escape_debug\n-/// [`char`]: ../../std/primitive.char.html\n-#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeDebug(EscapeDefault);\n-\n-#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl Iterator for EscapeDebug {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n-}\n-\n-#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl ExactSizeIterator for EscapeDebug { }\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for EscapeDebug {}\n-\n-#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl fmt::Display for EscapeDebug {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n-    }\n-}\n-\n-\n-\n-/// An iterator over an iterator of bytes of the characters the bytes represent\n-/// as UTF-8\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[derive(Clone, Debug)]\n-pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n-\n-/// Decodes an `Iterator` of bytes as UTF-8.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[inline]\n-pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n-    DecodeUtf8(i.into_iter().peekable())\n-}\n-\n-/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[derive(PartialEq, Eq, Debug)]\n-pub struct InvalidSequence(());\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n-    type Item = Result<char, InvalidSequence>;\n-    #[inline]\n-\n-    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|first_byte| {\n-            // Emit InvalidSequence according to\n-            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n-            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n-\n-            // Roughly: consume at least one byte,\n-            // then validate one byte at a time and stop before the first unexpected byte\n-            // (which might be the valid start of the next byte sequence).\n-\n-            let mut code_point;\n-            macro_rules! first_byte {\n-                ($mask: expr) => {\n-                    code_point = u32::from(first_byte & $mask)\n-                }\n-            }\n-            macro_rules! continuation_byte {\n-                () => { continuation_byte!(0x80...0xBF) };\n-                ($range: pat) => {\n-                    match self.0.peek() {\n-                        Some(&byte @ $range) => {\n-                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n-                            self.0.next();\n-                        }\n-                        _ => return Err(InvalidSequence(()))\n-                    }\n-                }\n-            }\n-\n-            match first_byte {\n-                0x00...0x7F => {\n-                    first_byte!(0b1111_1111);\n-                }\n-                0xC2...0xDF => {\n-                    first_byte!(0b0001_1111);\n-                    continuation_byte!();\n-                }\n-                0xE0 => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n-                    continuation_byte!();\n-                }\n-                0xE1...0xEC | 0xEE...0xEF => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xED => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n-                    continuation_byte!();\n-                }\n-                0xF0 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF1...0xF3 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF4 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n-            }\n-            unsafe {\n-                Ok(from_u32_unchecked(code_point))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.0.size_hint();\n-\n-        // A code point is at most 4 bytes long.\n-        let min_code_points = lower / 4;\n-\n-        (min_code_points, upper)\n-    }\n-}\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}"}, {"sha": "150562a4a9b290019c62835286f05573291b345c", "filename": "src/libcore/char/convert.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Character conversions.\n+\n+use convert::TryFrom;\n+use fmt;\n+use mem::transmute;\n+use str::FromStr;\n+use super::MAX;\n+\n+/// Converts a `u32` to a `char`.\n+///\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n+/// [`as`]:\n+///\n+/// ```\n+/// let c = '\ud83d\udcaf';\n+/// let i = c as u32;\n+///\n+/// assert_eq!(128175, i);\n+/// ```\n+///\n+/// However, the reverse is not true: not all valid [`u32`]s are valid\n+/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n+/// for a [`char`].\n+///\n+/// [`char`]: ../../std/primitive.char.html\n+/// [`u32`]: ../../std/primitive.u32.html\n+/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n+///\n+/// For an unsafe version of this function which ignores these checks, see\n+/// [`from_u32_unchecked`].\n+///\n+/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(0x2764);\n+///\n+/// assert_eq!(Some('\u2764'), c);\n+/// ```\n+///\n+/// Returning `None` when the input is not a valid [`char`]:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(0x110000);\n+///\n+/// assert_eq!(None, c);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_u32(i: u32) -> Option<char> {\n+    char::try_from(i).ok()\n+}\n+\n+/// Converts a `u32` to a `char`, ignoring validity.\n+///\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n+/// [`as`]:\n+///\n+/// ```\n+/// let c = '\ud83d\udcaf';\n+/// let i = c as u32;\n+///\n+/// assert_eq!(128175, i);\n+/// ```\n+///\n+/// However, the reverse is not true: not all valid [`u32`]s are valid\n+/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n+/// [`char`], possibly creating an invalid one.\n+///\n+/// [`char`]: ../../std/primitive.char.html\n+/// [`u32`]: ../../std/primitive.u32.html\n+/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n+///\n+/// # Safety\n+///\n+/// This function is unsafe, as it may construct invalid `char` values.\n+///\n+/// For a safe version of this function, see the [`from_u32`] function.\n+///\n+/// [`from_u32`]: fn.from_u32.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n+///\n+/// assert_eq!('\u2764', c);\n+/// ```\n+#[inline]\n+#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n+pub unsafe fn from_u32_unchecked(i: u32) -> char {\n+    transmute(i)\n+}\n+\n+#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n+impl From<char> for u32 {\n+    #[inline]\n+    fn from(c: char) -> Self {\n+        c as u32\n+    }\n+}\n+\n+/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n+///\n+/// Unicode is designed such that this effectively decodes bytes\n+/// with the character encoding that IANA calls ISO-8859-1.\n+/// This encoding is compatible with ASCII.\n+///\n+/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n+/// which leaves some \"blanks\", byte values that are not assigned to any character.\n+/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n+///\n+/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n+/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n+/// to punctuation and various Latin characters.\n+///\n+/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n+/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n+/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n+/// C0 and C1 control codes.\n+#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n+impl From<u8> for char {\n+    #[inline]\n+    fn from(i: u8) -> Self {\n+        i as char\n+    }\n+}\n+\n+\n+/// An error which can be returned when parsing a char.\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ParseCharError {\n+    kind: CharErrorKind,\n+}\n+\n+impl ParseCharError {\n+    #[unstable(feature = \"char_error_internals\",\n+               reason = \"this method should not be available publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            CharErrorKind::EmptyString => {\n+                \"cannot parse char from empty string\"\n+            },\n+            CharErrorKind::TooManyChars => \"too many characters in string\"\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum CharErrorKind {\n+    EmptyString,\n+    TooManyChars,\n+}\n+\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+impl fmt::Display for ParseCharError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}\n+\n+\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+impl FromStr for char {\n+    type Err = ParseCharError;\n+\n+    #[inline]\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let mut chars = s.chars();\n+        match (chars.next(), chars.next()) {\n+            (None, _) => {\n+                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n+            },\n+            (Some(c), None) => Ok(c),\n+            _ => {\n+                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n+            }\n+        }\n+    }\n+}\n+\n+\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+impl TryFrom<u32> for char {\n+    type Error = CharTryFromError;\n+\n+    #[inline]\n+    fn try_from(i: u32) -> Result<Self, Self::Error> {\n+        if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n+            Err(CharTryFromError(()))\n+        } else {\n+            Ok(unsafe { from_u32_unchecked(i) })\n+        }\n+    }\n+}\n+\n+/// The error type returned when a conversion from u32 to char fails.\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct CharTryFromError(());\n+\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+impl fmt::Display for CharTryFromError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"converted integer out of range for `char`\".fmt(f)\n+    }\n+}\n+\n+/// Converts a digit in the given radix to a `char`.\n+///\n+/// A 'radix' here is sometimes also called a 'base'. A radix of two\n+/// indicates a binary number, a radix of ten, decimal, and a radix of\n+/// sixteen, hexadecimal, to give some common values. Arbitrary\n+/// radices are supported.\n+///\n+/// `from_digit()` will return `None` if the input is not a digit in\n+/// the given radix.\n+///\n+/// # Panics\n+///\n+/// Panics if given a radix larger than 36.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(4, 10);\n+///\n+/// assert_eq!(Some('4'), c);\n+///\n+/// // Decimal 11 is a single digit in base 16\n+/// let c = char::from_digit(11, 16);\n+///\n+/// assert_eq!(Some('b'), c);\n+/// ```\n+///\n+/// Returning `None` when the input is not a digit:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(20, 10);\n+///\n+/// assert_eq!(None, c);\n+/// ```\n+///\n+/// Passing a large radix, causing a panic:\n+///\n+/// ```\n+/// use std::thread;\n+/// use std::char;\n+///\n+/// let result = thread::spawn(|| {\n+///     // this panics\n+///     let c = char::from_digit(1, 37);\n+/// }).join();\n+///\n+/// assert!(result.is_err());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n+    if radix > 36 {\n+        panic!(\"from_digit: radix is too high (maximum 36)\");\n+    }\n+    if num < radix {\n+        let num = num as u8;\n+        if num < 10 {\n+            Some((b'0' + num) as char)\n+        } else {\n+            Some((b'a' + num - 10) as char)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+"}, {"sha": "48b531104f8829f4986ccc56985a486e31d789fc", "filename": "src/libcore/char/decode.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! UTF-8 and UTF-16 decoding iterators\n+\n+use fmt;\n+use iter::FusedIterator;\n+use super::from_u32_unchecked;\n+\n+/// An iterator over an iterator of bytes of the characters the bytes represent\n+/// as UTF-8\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[derive(Clone, Debug)]\n+pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n+\n+/// Decodes an `Iterator` of bytes as UTF-8.\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[inline]\n+pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n+    DecodeUtf8(i.into_iter().peekable())\n+}\n+\n+/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct InvalidSequence(());\n+\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n+    type Item = Result<char, InvalidSequence>;\n+    #[inline]\n+\n+    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n+        self.0.next().map(|first_byte| {\n+            // Emit InvalidSequence according to\n+            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n+            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n+\n+            // Roughly: consume at least one byte,\n+            // then validate one byte at a time and stop before the first unexpected byte\n+            // (which might be the valid start of the next byte sequence).\n+\n+            let mut code_point;\n+            macro_rules! first_byte {\n+                ($mask: expr) => {\n+                    code_point = u32::from(first_byte & $mask)\n+                }\n+            }\n+            macro_rules! continuation_byte {\n+                () => { continuation_byte!(0x80...0xBF) };\n+                ($range: pat) => {\n+                    match self.0.peek() {\n+                        Some(&byte @ $range) => {\n+                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n+                            self.0.next();\n+                        }\n+                        _ => return Err(InvalidSequence(()))\n+                    }\n+                }\n+            }\n+\n+            match first_byte {\n+                0x00...0x7F => {\n+                    first_byte!(0b1111_1111);\n+                }\n+                0xC2...0xDF => {\n+                    first_byte!(0b0001_1111);\n+                    continuation_byte!();\n+                }\n+                0xE0 => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n+                    continuation_byte!();\n+                }\n+                0xE1...0xEC | 0xEE...0xEF => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xED => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n+                    continuation_byte!();\n+                }\n+                0xF0 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF1...0xF3 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF4 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n+            }\n+            unsafe {\n+                Ok(from_u32_unchecked(code_point))\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.0.size_hint();\n+\n+        // A code point is at most 4 bytes long.\n+        let min_code_points = lower / 4;\n+\n+        (min_code_points, upper)\n+    }\n+}\n+\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}\n+\n+/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[derive(Clone, Debug)]\n+pub struct DecodeUtf16<I>\n+    where I: Iterator<Item = u16>\n+{\n+    iter: I,\n+    buf: Option<u16>,\n+}\n+\n+/// An error that can be returned when decoding UTF-16 code points.\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct DecodeUtf16Error {\n+    code: u16,\n+}\n+\n+/// Create an iterator over the UTF-16 encoded code points in `iter`,\n+/// returning unpaired surrogates as `Err`s.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char::decode_utf16;\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+///                            .collect::<Vec<_>>(),\n+///                vec![Ok('\ud834\udd1e'),\n+///                     Ok('m'), Ok('u'), Ok('s'),\n+///                     Err(0xDD1E),\n+///                     Ok('i'), Ok('c'),\n+///                     Err(0xD834)]);\n+/// }\n+/// ```\n+///\n+/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+///\n+/// ```\n+/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///                    .collect::<String>(),\n+///                \"\ud834\udd1emus\ufffdic\ufffd\");\n+/// }\n+/// ```\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+#[inline]\n+pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+    DecodeUtf16 {\n+        iter: iter.into_iter(),\n+        buf: None,\n+    }\n+}\n+\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n+    type Item = Result<char, DecodeUtf16Error>;\n+\n+    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n+        let u = match self.buf.take() {\n+            Some(buf) => buf,\n+            None => self.iter.next()?\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(Err(DecodeUtf16Error { code: u }))\n+        } else {\n+            let u2 = match self.iter.next() {\n+                Some(u2) => u2,\n+                // eof\n+                None => return Some(Err(DecodeUtf16Error { code: u })),\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.buf = Some(u2);\n+                return Some(Err(DecodeUtf16Error { code: u }));\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(Ok(unsafe { from_u32_unchecked(c) }))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+impl DecodeUtf16Error {\n+    /// Returns the unpaired surrogate which caused this error.\n+    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+    pub fn unpaired_surrogate(&self) -> u16 {\n+        self.code\n+    }\n+}\n+\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+impl fmt::Display for DecodeUtf16Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"unpaired surrogate found: {:x}\", self.code)\n+    }\n+}"}, {"sha": "374adafef647db1ee8af4b6813c93ad6fb6ff5d9", "filename": "src/libcore/char/methods.rs", "status": "renamed", "additions": 110, "deletions": 308, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -8,169 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A character type.\n-//!\n-//! The `char` type represents a single character. More specifically, since\n-//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n-//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n-//! point]'.\n-//!\n-//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n-//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n-//!\n-//! This module exists for technical reasons, the primary documentation for\n-//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n-//! itself.\n-//!\n-//! This module is the home of the iterator implementations for the iterators\n-//! implemented on `char`, as well as some useful constants and conversion\n-//! functions that convert various types to `char`.\n+//! impl char {}\n \n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use core::char::CharExt as C;\n-use core::iter::FusedIterator;\n-use core::fmt::{self, Write};\n-use tables::{conversions, derived_property, general_category, property};\n-\n-// stable re-exports\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::char::{MAX, from_digit, from_u32, from_u32_unchecked};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::char::{EscapeDebug, EscapeDefault, EscapeUnicode};\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-pub use core::char::ParseCharError;\n-\n-// unstable re-exports\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-pub use core::char::CharTryFromError;\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-pub use core::char::{DecodeUtf8, decode_utf8};\n-#[unstable(feature = \"unicode\", issue = \"27783\")]\n-pub use tables::{UNICODE_VERSION};\n-#[unstable(feature = \"unicode\", issue = \"27783\")]\n-pub use version::UnicodeVersion;\n-\n-/// Returns an iterator that yields the lowercase equivalent of a `char`.\n-///\n-/// This `struct` is created by the [`to_lowercase`] method on [`char`]. See\n-/// its documentation for more.\n-///\n-/// [`to_lowercase`]: ../../std/primitive.char.html#method.to_lowercase\n-/// [`char`]: ../../std/primitive.char.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug, Clone)]\n-pub struct ToLowercase(CaseMappingIter);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for ToLowercase {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> {\n-        self.0.next()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for ToLowercase {}\n-\n-/// Returns an iterator that yields the uppercase equivalent of a `char`.\n-///\n-/// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n-/// its documentation for more.\n-///\n-/// [`to_uppercase`]: ../../std/primitive.char.html#method.to_uppercase\n-/// [`char`]: ../../std/primitive.char.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug, Clone)]\n-pub struct ToUppercase(CaseMappingIter);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for ToUppercase {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> {\n-        self.0.next()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for ToUppercase {}\n-\n-#[derive(Debug, Clone)]\n-enum CaseMappingIter {\n-    Three(char, char, char),\n-    Two(char, char),\n-    One(char),\n-    Zero,\n-}\n-\n-impl CaseMappingIter {\n-    fn new(chars: [char; 3]) -> CaseMappingIter {\n-        if chars[2] == '\\0' {\n-            if chars[1] == '\\0' {\n-                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n-            } else {\n-                CaseMappingIter::Two(chars[0], chars[1])\n-            }\n-        } else {\n-            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n-        }\n-    }\n-}\n-\n-impl Iterator for CaseMappingIter {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> {\n-        match *self {\n-            CaseMappingIter::Three(a, b, c) => {\n-                *self = CaseMappingIter::Two(b, c);\n-                Some(a)\n-            }\n-            CaseMappingIter::Two(b, c) => {\n-                *self = CaseMappingIter::One(c);\n-                Some(b)\n-            }\n-            CaseMappingIter::One(c) => {\n-                *self = CaseMappingIter::Zero;\n-                Some(c)\n-            }\n-            CaseMappingIter::Zero => None,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for CaseMappingIter {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            CaseMappingIter::Three(a, b, c) => {\n-                f.write_char(a)?;\n-                f.write_char(b)?;\n-                f.write_char(c)\n-            }\n-            CaseMappingIter::Two(b, c) => {\n-                f.write_char(b)?;\n-                f.write_char(c)\n-            }\n-            CaseMappingIter::One(c) => {\n-                f.write_char(c)\n-            }\n-            CaseMappingIter::Zero => Ok(()),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n-impl fmt::Display for ToLowercase {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n-    }\n-}\n-\n-#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n-impl fmt::Display for ToUppercase {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n-    }\n-}\n+use slice;\n+use str::from_utf8_unchecked_mut;\n+use super::*;\n+use unicode::printable::is_printable;\n+use unicode::tables::{conversions, derived_property, general_category, property};\n \n #[lang = \"char\"]\n impl char {\n@@ -223,7 +67,7 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_digit(self, radix: u32) -> bool {\n-        C::is_digit(self, radix)\n+        self.to_digit(radix).is_some()\n     }\n \n     /// Converts a `char` to a digit in the given radix.\n@@ -277,7 +121,17 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_digit(self, radix: u32) -> Option<u32> {\n-        C::to_digit(self, radix)\n+        if radix > 36 {\n+            panic!(\"to_digit: radix is too high (maximum 36)\");\n+        }\n+        let val = match self {\n+          '0' ... '9' => self as u32 - '0' as u32,\n+          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n+          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n+          _ => return None,\n+        };\n+        if val < radix { Some(val) }\n+        else { None }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -317,7 +171,20 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn escape_unicode(self) -> EscapeUnicode {\n-        C::escape_unicode(self)\n+        let c = self as u32;\n+\n+        // or-ing 1 ensures that for c==0 the code computes that one\n+        // digit should be printed and (which is the same) avoids the\n+        // (31 - 32) underflow\n+        let msb = 31 - (c | 1).leading_zeros();\n+\n+        // the index of the most significant hex digit\n+        let ms_hex_digit = msb / 4;\n+        EscapeUnicode {\n+            c: self,\n+            state: EscapeUnicodeState::Backslash,\n+            hex_digit_idx: ms_hex_digit as usize,\n+        }\n     }\n \n     /// Returns an iterator that yields the literal escape code of a character\n@@ -357,7 +224,15 @@ impl char {\n     #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n     #[inline]\n     pub fn escape_debug(self) -> EscapeDebug {\n-        C::escape_debug(self)\n+        let init_state = match self {\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n+            c if is_printable(c) => EscapeDefaultState::Char(c),\n+            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n+        };\n+        EscapeDebug(EscapeDefault { state: init_state })\n     }\n \n     /// Returns an iterator that yields the literal escape code of a character\n@@ -412,7 +287,15 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn escape_default(self) -> EscapeDefault {\n-        C::escape_default(self)\n+        let init_state = match self {\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n+            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n+        };\n+        EscapeDefault { state: init_state }\n     }\n \n     /// Returns the number of bytes this `char` would need if encoded in UTF-8.\n@@ -463,7 +346,16 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn len_utf8(self) -> usize {\n-        C::len_utf8(self)\n+        let code = self as u32;\n+        if code < MAX_ONE_B {\n+            1\n+        } else if code < MAX_TWO_B {\n+            2\n+        } else if code < MAX_THREE_B {\n+            3\n+        } else {\n+            4\n+        }\n     }\n \n     /// Returns the number of 16-bit code units this `char` would need if\n@@ -488,7 +380,8 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn len_utf16(self) -> usize {\n-        C::len_utf16(self)\n+        let ch = self as u32;\n+        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n     }\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n@@ -530,7 +423,35 @@ impl char {\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n-        C::encode_utf8(self, dst)\n+        let code = self as u32;\n+        unsafe {\n+            let len =\n+            if code < MAX_ONE_B && !dst.is_empty() {\n+                *dst.get_unchecked_mut(0) = code as u8;\n+                1\n+            } else if code < MAX_TWO_B && dst.len() >= 2 {\n+                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n+                2\n+            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n+                3\n+            } else if dst.len() >= 4 {\n+                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n+                4\n+            } else {\n+                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf8(),\n+                    code,\n+                    dst.len())\n+            };\n+            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n+        }\n     }\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n@@ -570,7 +491,25 @@ impl char {\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]\n     pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n-        C::encode_utf16(self, dst)\n+        let mut code = self as u32;\n+        unsafe {\n+            if (code & 0xFFFF) == code && !dst.is_empty() {\n+                // The BMP falls through (assuming non-surrogate, as it should)\n+                *dst.get_unchecked_mut(0) = code as u16;\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n+            } else if dst.len() >= 2 {\n+                // Supplementary planes break into surrogates.\n+                code -= 0x1_0000;\n+                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n+                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n+            } else {\n+                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf16(),\n+                    code,\n+                    dst.len())\n+            }\n+        }\n     }\n \n     /// Returns true if this `char` is an alphabetic code point, and false if not.\n@@ -1452,140 +1391,3 @@ impl char {\n         self.is_ascii() && (*self as u8).is_ascii_control()\n     }\n }\n-\n-/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-#[derive(Clone, Debug)]\n-pub struct DecodeUtf16<I>\n-    where I: Iterator<Item = u16>\n-{\n-    iter: I,\n-    buf: Option<u16>,\n-}\n-\n-/// An error that can be returned when decoding UTF-16 code points.\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct DecodeUtf16Error {\n-    code: u16,\n-}\n-\n-/// Create an iterator over the UTF-16 encoded code points in `iter`,\n-/// returning unpaired surrogates as `Err`s.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char::decode_utf16;\n-///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n-///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///                            .collect::<Vec<_>>(),\n-///                vec![Ok('\ud834\udd1e'),\n-///                     Ok('m'), Ok('u'), Ok('s'),\n-///                     Err(0xDD1E),\n-///                     Ok('i'), Ok('c'),\n-///                     Err(0xD834)]);\n-/// }\n-/// ```\n-///\n-/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n-///\n-/// ```\n-/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n-///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n-///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///                    .collect::<String>(),\n-///                \"\ud834\udd1emus\ufffdic\ufffd\");\n-/// }\n-/// ```\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-#[inline]\n-pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n-    DecodeUtf16 {\n-        iter: iter.into_iter(),\n-        buf: None,\n-    }\n-}\n-\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n-    type Item = Result<char, DecodeUtf16Error>;\n-\n-    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n-        let u = match self.buf.take() {\n-            Some(buf) => buf,\n-            None => self.iter.next()?\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(Err(DecodeUtf16Error { code: u }))\n-        } else {\n-            let u2 = match self.iter.next() {\n-                Some(u2) => u2,\n-                // eof\n-                None => return Some(Err(DecodeUtf16Error { code: u })),\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.buf = Some(u2);\n-                return Some(Err(DecodeUtf16Error { code: u }));\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(Ok(unsafe { from_u32_unchecked(c) }))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n-    }\n-}\n-\n-impl DecodeUtf16Error {\n-    /// Returns the unpaired surrogate which caused this error.\n-    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-    pub fn unpaired_surrogate(&self) -> u16 {\n-        self.code\n-    }\n-}\n-\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-impl fmt::Display for DecodeUtf16Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"unpaired surrogate found: {:x}\", self.code)\n-    }\n-}\n-\n-/// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n-/// decoding error.\n-///\n-/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n-/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n-#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';", "previous_filename": "src/libstd_unicode/char.rs"}, {"sha": "9edc0c88756b3c74073dad9e512c512d1a096521", "filename": "src/libcore/char/mod.rs", "status": "added", "additions": 506, "deletions": 0, "changes": 506, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -0,0 +1,506 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A character type.\n+//!\n+//! The `char` type represents a single character. More specifically, since\n+//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n+//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n+//! point]'.\n+//!\n+//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n+//!\n+//! This module exists for technical reasons, the primary documentation for\n+//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n+//! itself.\n+//!\n+//! This module is the home of the iterator implementations for the iterators\n+//! implemented on `char`, as well as some useful constants and conversion\n+//! functions that convert various types to `char`.\n+\n+#![allow(non_snake_case)]\n+#![stable(feature = \"core_char\", since = \"1.2.0\")]\n+\n+mod convert;\n+mod decode;\n+mod methods;\n+\n+// stable re-exports\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::convert::{from_u32, from_digit};\n+#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n+pub use self::convert::from_u32_unchecked;\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+pub use self::convert::ParseCharError;\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+pub use self::convert::CharTryFromError;\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n+\n+// unstable re-exports\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+pub use unicode::tables::UNICODE_VERSION;\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+pub use unicode::version::UnicodeVersion;\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+pub use self::decode::{decode_utf8, DecodeUtf8, InvalidSequence};\n+\n+use fmt::{self, Write};\n+use iter::FusedIterator;\n+\n+// UTF-8 ranges and tags for encoding characters\n+const TAG_CONT: u8    = 0b1000_0000;\n+const TAG_TWO_B: u8   = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8  = 0b1111_0000;\n+const MAX_ONE_B: u32   =     0x80;\n+const MAX_TWO_B: u32   =    0x800;\n+const MAX_THREE_B: u32 =  0x10000;\n+\n+/*\n+    Lu  Uppercase_Letter        an uppercase letter\n+    Ll  Lowercase_Letter        a lowercase letter\n+    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n+    Lm  Modifier_Letter         a modifier letter\n+    Lo  Other_Letter            other letters, including syllables and ideographs\n+    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n+    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n+    Me  Enclosing_Mark          an enclosing combining mark\n+    Nd  Decimal_Number          a decimal digit\n+    Nl  Letter_Number           a letterlike numeric character\n+    No  Other_Number            a numeric character of other type\n+    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n+    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n+    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n+    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n+    Pi  Initial_Punctuation     an initial quotation mark\n+    Pf  Final_Punctuation       a final quotation mark\n+    Po  Other_Punctuation       a punctuation mark of other type\n+    Sm  Math_Symbol             a symbol of primarily mathematical use\n+    Sc  Currency_Symbol         a currency sign\n+    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n+    So  Other_Symbol            a symbol of other type\n+    Zs  Space_Separator         a space character (of various non-zero widths)\n+    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n+    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n+    Cc  Control                 a C0 or C1 control code\n+    Cf  Format                  a format control character\n+    Cs  Surrogate               a surrogate code point\n+    Co  Private_Use             a private-use character\n+    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n+*/\n+\n+/// The highest valid code point a `char` can have.\n+///\n+/// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n+/// Point], but only ones within a certain range. `MAX` is the highest valid\n+/// code point that's a valid [Unicode Scalar Value].\n+///\n+/// [`char`]: ../../std/primitive.char.html\n+/// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+/// [Code Point]: http://www.unicode.org/glossary/#code_point\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MAX: char = '\\u{10ffff}';\n+\n+/// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n+/// decoding error.\n+///\n+/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n+/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n+#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n+pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+\n+/// Returns an iterator that yields the hexadecimal Unicode escape of a\n+/// character, as `char`s.\n+///\n+/// This `struct` is created by the [`escape_unicode`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`escape_unicode`]: ../../std/primitive.char.html#method.escape_unicode\n+/// [`char`]: ../../std/primitive.char.html\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct EscapeUnicode {\n+    c: char,\n+    state: EscapeUnicodeState,\n+\n+    // The index of the next hex digit to be printed (0 if none),\n+    // i.e. the number of remaining hex digits to be printed;\n+    // increasing from the least significant digit: 0x543210\n+    hex_digit_idx: usize,\n+}\n+\n+// The enum values are ordered so that their representation is the\n+// same as the remaining length (besides the hexadecimal digits). This\n+// likely makes `len()` a single load from memory) and inline-worth.\n+#[derive(Clone, Debug)]\n+enum EscapeUnicodeState {\n+    Done,\n+    RightBrace,\n+    Value,\n+    LeftBrace,\n+    Type,\n+    Backslash,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeUnicode {\n+    type Item = char;\n+\n+    fn next(&mut self) -> Option<char> {\n+        match self.state {\n+            EscapeUnicodeState::Backslash => {\n+                self.state = EscapeUnicodeState::Type;\n+                Some('\\\\')\n+            }\n+            EscapeUnicodeState::Type => {\n+                self.state = EscapeUnicodeState::LeftBrace;\n+                Some('u')\n+            }\n+            EscapeUnicodeState::LeftBrace => {\n+                self.state = EscapeUnicodeState::Value;\n+                Some('{')\n+            }\n+            EscapeUnicodeState::Value => {\n+                let hex_digit = ((self.c as u32) >> (self.hex_digit_idx * 4)) & 0xf;\n+                let c = from_digit(hex_digit, 16).unwrap();\n+                if self.hex_digit_idx == 0 {\n+                    self.state = EscapeUnicodeState::RightBrace;\n+                } else {\n+                    self.hex_digit_idx -= 1;\n+                }\n+                Some(c)\n+            }\n+            EscapeUnicodeState::RightBrace => {\n+                self.state = EscapeUnicodeState::Done;\n+                Some('}')\n+            }\n+            EscapeUnicodeState::Done => None,\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.len();\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    fn last(self) -> Option<char> {\n+        match self.state {\n+            EscapeUnicodeState::Done => None,\n+\n+            EscapeUnicodeState::RightBrace |\n+            EscapeUnicodeState::Value |\n+            EscapeUnicodeState::LeftBrace |\n+            EscapeUnicodeState::Type |\n+            EscapeUnicodeState::Backslash => Some('}'),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n+impl ExactSizeIterator for EscapeUnicode {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        // The match is a single memory access with no branching\n+        self.hex_digit_idx + match self.state {\n+            EscapeUnicodeState::Done => 0,\n+            EscapeUnicodeState::RightBrace => 1,\n+            EscapeUnicodeState::Value => 2,\n+            EscapeUnicodeState::LeftBrace => 3,\n+            EscapeUnicodeState::Type => 4,\n+            EscapeUnicodeState::Backslash => 5,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EscapeUnicode {}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n+impl fmt::Display for EscapeUnicode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for c in self.clone() {\n+            f.write_char(c)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// An iterator that yields the literal escape code of a `char`.\n+///\n+/// This `struct` is created by the [`escape_default`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`escape_default`]: ../../std/primitive.char.html#method.escape_default\n+/// [`char`]: ../../std/primitive.char.html\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct EscapeDefault {\n+    state: EscapeDefaultState\n+}\n+\n+#[derive(Clone, Debug)]\n+enum EscapeDefaultState {\n+    Done,\n+    Char(char),\n+    Backslash(char),\n+    Unicode(EscapeUnicode),\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = char;\n+\n+    fn next(&mut self) -> Option<char> {\n+        match self.state {\n+            EscapeDefaultState::Backslash(c) => {\n+                self.state = EscapeDefaultState::Char(c);\n+                Some('\\\\')\n+            }\n+            EscapeDefaultState::Char(c) => {\n+                self.state = EscapeDefaultState::Done;\n+                Some(c)\n+            }\n+            EscapeDefaultState::Done => None,\n+            EscapeDefaultState::Unicode(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.len();\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<char> {\n+        match self.state {\n+            EscapeDefaultState::Backslash(c) if n == 0 => {\n+                self.state = EscapeDefaultState::Char(c);\n+                Some('\\\\')\n+            },\n+            EscapeDefaultState::Backslash(c) if n == 1 => {\n+                self.state = EscapeDefaultState::Done;\n+                Some(c)\n+            },\n+            EscapeDefaultState::Backslash(_) => {\n+                self.state = EscapeDefaultState::Done;\n+                None\n+            },\n+            EscapeDefaultState::Char(c) => {\n+                self.state = EscapeDefaultState::Done;\n+\n+                if n == 0 {\n+                    Some(c)\n+                } else {\n+                    None\n+                }\n+            },\n+            EscapeDefaultState::Done => return None,\n+            EscapeDefaultState::Unicode(ref mut i) => return i.nth(n),\n+        }\n+    }\n+\n+    fn last(self) -> Option<char> {\n+        match self.state {\n+            EscapeDefaultState::Unicode(iter) => iter.last(),\n+            EscapeDefaultState::Done => None,\n+            EscapeDefaultState::Backslash(c) | EscapeDefaultState::Char(c) => Some(c),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n+impl ExactSizeIterator for EscapeDefault {\n+    fn len(&self) -> usize {\n+        match self.state {\n+            EscapeDefaultState::Done => 0,\n+            EscapeDefaultState::Char(_) => 1,\n+            EscapeDefaultState::Backslash(_) => 2,\n+            EscapeDefaultState::Unicode(ref iter) => iter.len(),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EscapeDefault {}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n+impl fmt::Display for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for c in self.clone() {\n+            f.write_char(c)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// An iterator that yields the literal escape code of a `char`.\n+///\n+/// This `struct` is created by the [`escape_debug`] method on [`char`]. See its\n+/// documentation for more.\n+///\n+/// [`escape_debug`]: ../../std/primitive.char.html#method.escape_debug\n+/// [`char`]: ../../std/primitive.char.html\n+#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug(EscapeDefault);\n+\n+#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n+impl Iterator for EscapeDebug {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+}\n+\n+#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n+impl ExactSizeIterator for EscapeDebug { }\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EscapeDebug {}\n+\n+#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n+impl fmt::Display for EscapeDebug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+/// Returns an iterator that yields the lowercase equivalent of a `char`.\n+///\n+/// This `struct` is created by the [`to_lowercase`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`to_lowercase`]: ../../std/primitive.char.html#method.to_lowercase\n+/// [`char`]: ../../std/primitive.char.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug, Clone)]\n+pub struct ToLowercase(CaseMappingIter);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for ToLowercase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for ToLowercase {}\n+\n+/// Returns an iterator that yields the uppercase equivalent of a `char`.\n+///\n+/// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`to_uppercase`]: ../../std/primitive.char.html#method.to_uppercase\n+/// [`char`]: ../../std/primitive.char.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug, Clone)]\n+pub struct ToUppercase(CaseMappingIter);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for ToUppercase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for ToUppercase {}\n+\n+#[derive(Debug, Clone)]\n+enum CaseMappingIter {\n+    Three(char, char, char),\n+    Two(char, char),\n+    One(char),\n+    Zero,\n+}\n+\n+impl CaseMappingIter {\n+    fn new(chars: [char; 3]) -> CaseMappingIter {\n+        if chars[2] == '\\0' {\n+            if chars[1] == '\\0' {\n+                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+            } else {\n+                CaseMappingIter::Two(chars[0], chars[1])\n+            }\n+        } else {\n+            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n+        }\n+    }\n+}\n+\n+impl Iterator for CaseMappingIter {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                *self = CaseMappingIter::Two(b, c);\n+                Some(a)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                *self = CaseMappingIter::One(c);\n+                Some(b)\n+            }\n+            CaseMappingIter::One(c) => {\n+                *self = CaseMappingIter::Zero;\n+                Some(c)\n+            }\n+            CaseMappingIter::Zero => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CaseMappingIter {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                f.write_char(a)?;\n+                f.write_char(b)?;\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                f.write_char(b)?;\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::One(c) => {\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::Zero => Ok(()),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n+impl fmt::Display for ToLowercase {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n+impl fmt::Display for ToUppercase {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}"}, {"sha": "9ff8465bc0f2d87037f00a2c02107266b18c3267", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -180,12 +180,13 @@ pub mod hash;\n pub mod fmt;\n pub mod time;\n \n+pub mod unicode;\n+\n /* Heap memory allocator trait */\n #[allow(missing_docs)]\n pub mod heap;\n \n // note: does not need to be public\n-mod char_private;\n mod iter_private;\n mod tuple;\n mod unit;"}, {"sha": "cc3ad71117a5d34d268811adec3ddb72b372019d", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -62,6 +62,3 @@ pub use slice::SliceExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use str::StrExt;\n-#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)]\n-pub use char::CharExt;"}, {"sha": "30b7267da7c5e09a6bded4d315589f5730e88114", "filename": "src/libcore/str/lossy.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::str as core_str;\n-use core::fmt;\n-use core::fmt::Write;\n use char;\n-use core::mem;\n-\n+use str as core_str;\n+use fmt;\n+use fmt::Write;\n+use mem;\n \n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"0\")]", "previous_filename": "src/libstd_unicode/lossy.rs"}, {"sha": "f1fe23092de93924f2c1549758bcb84462cfc08b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -19,13 +19,17 @@ use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n use fmt;\n-use iter::{Map, Cloned, FusedIterator, TrustedLen};\n+use iter::{Map, Cloned, FusedIterator, TrustedLen, Filter};\n use iter_private::TrustedRandomAccess;\n use slice::{self, SliceIndex};\n use mem;\n \n pub mod pattern;\n \n+#[unstable(feature = \"str_internals\", issue = \"0\")]\n+#[allow(missing_docs)]\n+pub mod lossy;\n+\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n ///\n@@ -2212,6 +2216,18 @@ pub trait StrExt {\n     fn is_empty(&self) -> bool;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    fn is_whitespace(&self) -> bool;\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    fn is_alphanumeric(&self) -> bool;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn trim(&self) -> &str;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn trim_left(&self) -> &str;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn trim_right(&self) -> &str;\n }\n \n // truncate `&str` to length at most equal to `max`\n@@ -2532,6 +2548,36 @@ impl StrExt for str {\n \n     #[inline]\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n+\n+    #[inline]\n+    fn split_whitespace(&self) -> SplitWhitespace {\n+        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(&self) -> bool {\n+        self.chars().all(|c| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_alphanumeric(&self) -> bool {\n+        self.chars().all(|c| c.is_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn trim(&self) -> &str {\n+        self.trim_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn trim_left(&self) -> &str {\n+        self.trim_left_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn trim_right(&self) -> &str {\n+        self.trim_right_matches(|c: char| c.is_whitespace())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2547,3 +2593,75 @@ impl<'a> Default for &'a str {\n     /// Creates an empty str\n     fn default() -> &'a str { \"\" }\n }\n+\n+/// An iterator over the non-whitespace substrings of a string,\n+/// separated by any amount of whitespace.\n+///\n+/// This struct is created by the [`split_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n+/// [`str`]: ../../std/primitive.str.html\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitWhitespace<'a> {\n+    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n+}\n+\n+#[derive(Clone)]\n+struct IsWhitespace;\n+\n+impl FnOnce<(char, )> for IsWhitespace {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl FnMut<(char, )> for IsWhitespace {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n+        arg.0.is_whitespace()\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct IsNotEmpty;\n+\n+impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n+        !arg.0.is_empty()\n+    }\n+}\n+\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> Iterator for SplitWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a> FusedIterator for SplitWhitespace<'a> {}"}, {"sha": "149269263dc8a542b34c1ff36aed75c4e4ca9075", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -33,6 +33,7 @@\n #![feature(sort_internals)]\n #![feature(specialization)]\n #![feature(step_trait)]\n+#![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_trait)]\n@@ -68,4 +69,5 @@ mod ptr;\n mod result;\n mod slice;\n mod str;\n+mod str_lossy;\n mod tuple;"}, {"sha": "69e28256da9c3bd1ec05be2c9d5f213fd8ad228d", "filename": "src/libcore/tests/str_lossy.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Ftests%2Fstr_lossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Ftests%2Fstr_lossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr_lossy.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std_unicode::lossy::*;\n+use core::str::lossy::*;\n \n #[test]\n fn chunks() {", "previous_filename": "src/libstd_unicode/tests/lossy.rs"}, {"sha": "3e45b08f399dca57d0fe3535f211b47a987130e6", "filename": "src/libcore/unicode/bool_trie.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "previous_filename": "src/libstd_unicode/bool_trie.rs"}, {"sha": "b6b033adc046e7a573df6b27c2ffca08d935a90b", "filename": "src/libcore/unicode/mod.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"unicode_internals\", issue = \"0\")]\n+#![allow(missing_docs)]\n+\n+mod bool_trie;\n+pub(crate) mod printable;\n+pub(crate) mod tables;\n+pub(crate) mod version;\n+\n+// For use in liballoc, not re-exported in libstd.\n+pub mod derived_property {\n+    pub use unicode::tables::derived_property::{Case_Ignorable, Cased};\n+}\n+\n+// For use in libsyntax\n+pub mod property {\n+    pub use unicode::tables::property::Pattern_White_Space;\n+}"}, {"sha": "9410dafbbc3649130d23a303fd3c98d32ba405c3", "filename": "src/libcore/unicode/printable.py", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -187,7 +187,7 @@ def main():\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/char_private.py\",\n+// NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n //       do not edit directly!\n \n fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],", "previous_filename": "src/etc/char_private.py"}, {"sha": "4426c32eebceed24f33f87a0ee8f6bca1b836f13", "filename": "src/libcore/unicode/printable.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE: The following code was generated by \"src/etc/char_private.py\",\n+// NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n //       do not edit directly!\n \n fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8],", "previous_filename": "src/libcore/char_private.rs"}, {"sha": "3fbbc011bc41d2998fc10eebb8d8b10645b36831", "filename": "src/libcore/unicode/tables.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -12,11 +12,12 @@\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n-use version::UnicodeVersion;\n-use bool_trie::{BoolTrie, SmallBoolTrie};\n+use unicode::version::UnicodeVersion;\n+use unicode::bool_trie::{BoolTrie, SmallBoolTrie};\n \n /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n-/// `CharExt` and `UnicodeStrPrelude` traits are based on.\n+/// `char` and `str` methods are based on.\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n     major: 10,\n     minor: 0,\n@@ -1138,9 +1139,6 @@ pub mod property {\n }\n \n pub mod conversions {\n-    use core::option::Option;\n-    use core::option::Option::{Some, None};\n-\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n             None        => [c, '\\0', '\\0'],", "previous_filename": "src/libstd_unicode/tables.rs"}, {"sha": "75ec01944bfb9ada86e4a6e91834e8af24cc00b7", "filename": "src/libcore/unicode/unicode.py", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -39,8 +39,8 @@\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n-use version::UnicodeVersion;\n-use bool_trie::{BoolTrie, SmallBoolTrie};\n+use unicode::version::UnicodeVersion;\n+use unicode::bool_trie::{BoolTrie, SmallBoolTrie};\n '''\n \n # Mapping taken from Table 12 from:\n@@ -408,9 +408,6 @@ def emit_property_module(f, mod, tbl, emit):\n def emit_conversions_module(f, to_upper, to_lower, to_title):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n-    use core::option::Option;\n-    use core::option::Option::{Some, None};\n-\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n             None        => [c, '\\\\0', '\\\\0'],\n@@ -473,7 +470,8 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n             unicode_version = re.search(pattern, readme.read()).groups()\n         rf.write(\"\"\"\n /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n-/// `CharExt` and `UnicodeStrPrelude` traits are based on.\n+/// `char` and `str` methods are based on.\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n     major: %s,\n     minor: %s,", "previous_filename": "src/libstd_unicode/unicode.py"}, {"sha": "59ebf5f501269dc23a5b8dfae747374baca18f66", "filename": "src/libcore/unicode/version.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibcore%2Funicode%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fversion.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -12,6 +12,7 @@\n ///\n /// See also: <http://www.unicode.org/versions/>\n #[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub struct UnicodeVersion {\n     /// Major version.\n     pub major: u32,", "previous_filename": "src/libstd_unicode/version.rs"}, {"sha": "8463475afabda4b1f0f7138aad9a1879070f409c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -21,7 +21,6 @@\n #![feature(set_stdio)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n-#![feature(unicode)]\n #![feature(vec_remove_item)]\n #![feature(entry_and_modify)]\n \n@@ -42,7 +41,6 @@ extern crate serialize;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n extern crate test as testing;\n-extern crate std_unicode;\n #[macro_use] extern crate log;\n extern crate rustc_errors as errors;\n extern crate pulldown_cmark;"}, {"sha": "c82d600e4a184ad00e334c8155435281c7576b0c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -307,7 +307,6 @@\n #![feature(toowned_clone_into)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(unicode)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n@@ -354,7 +353,6 @@ extern crate core as __core;\n #[macro_reexport(vec, format)]\n extern crate alloc;\n extern crate alloc_system;\n-extern crate std_unicode;\n #[doc(masked)]\n extern crate libc;\n \n@@ -455,7 +453,7 @@ pub use alloc::string;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc::vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use std_unicode::char;\n+pub use core::char;\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n pub use core::u128;\n "}, {"sha": "eb3a1ead58c94b539ae611c70fd9ef1210deb272", "filename": "src/libstd/sys/redox/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -19,7 +19,7 @@ use rc::Rc;\n use sync::Arc;\n use sys_common::{AsInner, IntoInner};\n use sys_common::bytestring::debug_fmt_bytestring;\n-use std_unicode::lossy::Utf8Lossy;\n+use core::str::lossy::Utf8Lossy;\n \n #[derive(Clone, Hash)]\n pub struct Buf {"}, {"sha": "01c0fb830aadd8a461d110c90e0d5191b76d520a", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -19,7 +19,7 @@ use rc::Rc;\n use sync::Arc;\n use sys_common::{AsInner, IntoInner};\n use sys_common::bytestring::debug_fmt_bytestring;\n-use std_unicode::lossy::Utf8Lossy;\n+use core::str::lossy::Utf8Lossy;\n \n #[derive(Clone, Hash)]\n pub struct Buf {"}, {"sha": "e0da5bdf36c14aa37f654392855850667bc7cd13", "filename": "src/libstd/sys/wasm/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys%2Fwasm%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys%2Fwasm%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos_str.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -19,7 +19,7 @@ use rc::Rc;\n use sync::Arc;\n use sys_common::{AsInner, IntoInner};\n use sys_common::bytestring::debug_fmt_bytestring;\n-use std_unicode::lossy::Utf8Lossy;\n+use core::str::lossy::Utf8Lossy;\n \n #[derive(Clone, Hash)]\n pub struct Buf {"}, {"sha": "971b83938c1678174a6d8ee3624a86b169875dfd", "filename": "src/libstd/sys_common/bytestring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys_common%2Fbytestring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd%2Fsys_common%2Fbytestring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbytestring.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)]\n \n use fmt::{Formatter, Result, Write};\n-use std_unicode::lossy::{Utf8Lossy, Utf8LossyChunk};\n+use core::str::lossy::{Utf8Lossy, Utf8LossyChunk};\n \n pub fn debug_fmt_bytestring(slice: &[u8], f: &mut Formatter) -> Result {\n     // Writes out a valid unicode string with the correct escape sequences"}, {"sha": "b1c55c2e4b6ced7aa3520322031f1e36cba8b4f3", "filename": "src/libstd_unicode/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd_unicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd_unicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2FCargo.toml?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -9,10 +9,6 @@ path = \"lib.rs\"\n test = false\n bench = false\n \n-[[test]]\n-name = \"std_unicode_tests\"\n-path = \"tests/lib.rs\"\n-\n [dependencies]\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "c0d47f1fcb42bbc680d352a1ae86b7f23d34f14d", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -27,38 +27,10 @@\n        html_playground_url = \"https://play.rust-lang.org/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-#![deny(missing_debug_implementations)]\n #![no_std]\n \n-#![feature(ascii_ctype)]\n-#![feature(core_char_ext)]\n-#![feature(str_internals)]\n-#![feature(decode_utf8)]\n-#![feature(fn_traits)]\n-#![feature(lang_items)]\n-#![feature(non_exhaustive)]\n+#![feature(unicode_internals)]\n #![feature(staged_api)]\n-#![feature(unboxed_closures)]\n+#![rustc_deprecated(since = \"1.27.0\", reason = \"moved into libcore\")]\n \n-mod bool_trie;\n-mod tables;\n-mod u_str;\n-mod version;\n-pub mod char;\n-pub mod lossy;\n-\n-#[allow(deprecated)]\n-pub mod str {\n-    pub use u_str::{SplitWhitespace, UnicodeStr};\n-    pub use u_str::Utf16Encoder;\n-}\n-\n-// For use in liballoc, not re-exported in libstd.\n-pub mod derived_property {\n-    pub use tables::derived_property::{Case_Ignorable, Cased};\n-}\n-\n-// For use in libsyntax\n-pub mod property {\n-    pub use tables::property::Pattern_White_Space;\n-}\n+pub use core::unicode::*;"}, {"sha": "9535ec18763e663e4cbc4f5b674571d24bb29170", "filename": "src/libstd_unicode/tests/lib.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e28ef22ae5ef22a48e8582210bb8be9aba116b81/src%2Flibstd_unicode%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28ef22ae5ef22a48e8582210bb8be9aba116b81/src%2Flibstd_unicode%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftests%2Flib.rs?ref=e28ef22ae5ef22a48e8582210bb8be9aba116b81", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(str_internals, unicode)]\n-\n-extern crate std_unicode;\n-\n-mod lossy;"}, {"sha": "a72e1210d93f61c13279025ada8387668c6a8cd8", "filename": "src/libstd_unicode/u_str.rs", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e28ef22ae5ef22a48e8582210bb8be9aba116b81/src%2Flibstd_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28ef22ae5ef22a48e8582210bb8be9aba116b81/src%2Flibstd_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fu_str.rs?ref=e28ef22ae5ef22a48e8582210bb8be9aba116b81", "patch": "@@ -1,189 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unicode-intensive string manipulations.\n-//!\n-//! This module provides functionality to `str` that requires the Unicode\n-//! methods provided by the unicode parts of the CharExt trait.\n-\n-use core::char;\n-use core::iter::{Filter, FusedIterator};\n-use core::str::Split;\n-\n-/// An iterator over the non-whitespace substrings of a string,\n-/// separated by any amount of whitespace.\n-///\n-/// This struct is created by the [`split_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n-/// [`str`]: ../../std/primitive.str.html\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitWhitespace<'a> {\n-    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n-}\n-\n-/// Methods for Unicode string slices\n-#[allow(missing_docs)] // docs in liballoc\n-pub trait UnicodeStr {\n-    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n-    fn is_whitespace(&self) -> bool;\n-    fn is_alphanumeric(&self) -> bool;\n-    fn trim(&self) -> &str;\n-    fn trim_left(&self) -> &str;\n-    fn trim_right(&self) -> &str;\n-}\n-\n-impl UnicodeStr for str {\n-    #[inline]\n-    fn split_whitespace(&self) -> SplitWhitespace {\n-        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n-    }\n-\n-    #[inline]\n-    fn is_whitespace(&self) -> bool {\n-        self.chars().all(|c| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool {\n-        self.chars().all(|c| c.is_alphanumeric())\n-    }\n-\n-    #[inline]\n-    fn trim(&self) -> &str {\n-        self.trim_matches(|c: char| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn trim_left(&self) -> &str {\n-        self.trim_left_matches(|c: char| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn trim_right(&self) -> &str {\n-        self.trim_right_matches(|c: char| c.is_whitespace())\n-    }\n-}\n-\n-/// Iterator adaptor for encoding `char`s to UTF-16.\n-#[derive(Clone)]\n-#[allow(missing_debug_implementations)]\n-pub struct Utf16Encoder<I> {\n-    chars: I,\n-    extra: u16,\n-}\n-\n-impl<I> Utf16Encoder<I> {\n-    /// Create a UTF-16 encoder from any `char` iterator.\n-    pub fn new(chars: I) -> Utf16Encoder<I>\n-        where I: Iterator<Item = char>\n-    {\n-        Utf16Encoder {\n-            chars,\n-            extra: 0,\n-        }\n-    }\n-}\n-\n-impl<I> Iterator for Utf16Encoder<I>\n-    where I: Iterator<Item = char>\n-{\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0; 2];\n-        self.chars.next().map(|ch| {\n-            let n = CharExt::encode_utf16(ch, &mut buf).len();\n-            if n == 2 {\n-                self.extra = buf[1];\n-            }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n-impl<I> FusedIterator for Utf16Encoder<I>\n-    where I: FusedIterator<Item = char> {}\n-\n-#[derive(Clone)]\n-struct IsWhitespace;\n-\n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl FnMut<(char, )> for IsWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n-\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> Iterator for SplitWhitespace<'a> {\n-    type Item = &'a str;\n-\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n-    }\n-}\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a> FusedIterator for SplitWhitespace<'a> {}"}, {"sha": "ad98e2a6b71ad373b2f1d2655e67783ccac026a8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -19,7 +19,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(deny(warnings))))]\n \n-#![feature(unicode)]\n+#![feature(unicode_internals)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(non_exhaustive)]\n@@ -33,9 +33,9 @@\n extern crate rustc_cratesio_shim;\n \n #[macro_use] extern crate bitflags;\n+extern crate core;\n extern crate serialize;\n #[macro_use] extern crate log;\n-extern crate std_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n extern crate rustc_data_structures;"}, {"sha": "cb3323c7eca4e68ab5ae40a2e8e515bc5401123f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -15,7 +15,7 @@ use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n use symbol::{Symbol, keywords};\n-use std_unicode::property::Pattern_White_Space;\n+use core::unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n use std::char;"}, {"sha": "365387c3e5e2759a51be7fe972a55d1a5fdb6253", "filename": "src/test/compile-fail/single-primitive-inherent-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsingle-primitive-inherent-impl.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -15,9 +15,9 @@\n #![no_std]\n \n // OK\n-#[lang = \"char\"]\n-impl char {}\n+#[lang = \"str\"]\n+impl str {}\n \n-impl char {\n-//~^ error: only a single inherent implementation marked with `#[lang = \"char\"]` is allowed for the `char` primitive\n+impl str {\n+//~^ error: only a single inherent implementation marked with `#[lang = \"str\"]` is allowed for the `str` primitive\n }"}, {"sha": "bfc7faac06ebe258c28b17d2dfeeeb06248e26c1", "filename": "src/test/run-pass/char_unicode.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Ftest%2Frun-pass%2Fchar_unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26f9e42df76603fd21b0fe5dd1e8001caf9bf81/src%2Ftest%2Frun-pass%2Fchar_unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchar_unicode.rs?ref=d26f9e42df76603fd21b0fe5dd1e8001caf9bf81", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(unicode)]\n-\n+#![feature(unicode_version)]\n \n /// Tests access to the internal Unicode Version type and value.\n pub fn main() {"}]}