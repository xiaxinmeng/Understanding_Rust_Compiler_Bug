{"sha": "9bc8f1f4f8d7bded19517205f8522a0110204f51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYzhmMWY0ZjhkN2JkZWQxOTUxNzIwNWY4NTIyYTAxMTAyMDRmNTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T14:12:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T14:44:43Z"}, "message": "Store names in TraitData", "tree": {"sha": "e3dbb82ff7586c6a26ff08dc69a75fd16c96c115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3dbb82ff7586c6a26ff08dc69a75fd16c96c115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bc8f1f4f8d7bded19517205f8522a0110204f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8f1f4f8d7bded19517205f8522a0110204f51", "html_url": "https://github.com/rust-lang/rust/commit/9bc8f1f4f8d7bded19517205f8522a0110204f51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8f1f4f8d7bded19517205f8522a0110204f51/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a0792362e2c6cae2809520da454471d5a917384", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0792362e2c6cae2809520da454471d5a917384", "html_url": "https://github.com/rust-lang/rust/commit/4a0792362e2c6cae2809520da454471d5a917384"}], "stats": {"total": 68, "additions": 43, "deletions": 25}, "files": [{"sha": "9e7a1deeccd1419a3ddc2c501fbc0e95d3314b42", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8f1f4f8d7bded19517205f8522a0110204f51/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8f1f4f8d7bded19517205f8522a0110204f51/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=9bc8f1f4f8d7bded19517205f8522a0110204f51", "patch": "@@ -737,14 +737,11 @@ impl Trait {\n     }\n \n     pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.trait_data(self.id).items.iter().map(|it| (*it).into()).collect()\n+        db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n     }\n \n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n-        let trait_data = db.trait_data(self.id);\n-        let res =\n-            trait_data.associated_types().map(TypeAlias::from).find(|t| &t.name(db) == name)?;\n-        Some(res)\n+        db.trait_data(self.id).associated_type_by_name(name).map(TypeAlias::from)\n     }\n \n     pub fn associated_type_by_name_including_super_traits("}, {"sha": "9988570e834dec97401966428a653ee8b4d342f4", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8f1f4f8d7bded19517205f8522a0110204f51/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8f1f4f8d7bded19517205f8522a0110204f51/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=9bc8f1f4f8d7bded19517205f8522a0110204f51", "patch": "@@ -261,8 +261,8 @@ fn iterate_trait_method_candidates<T>(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = false;\n-        for &item in data.items.iter() {\n-            if !is_valid_candidate(db, name, mode, item.into()) {\n+        for (_name, item) in data.items.iter() {\n+            if !is_valid_candidate(db, name, mode, (*item).into()) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -272,7 +272,7 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, item.into()) {\n+            if let Some(result) = callback(&ty.value, (*item).into()) {\n                 return Some(result);\n             }\n         }"}, {"sha": "813099a058ba69f3f7389535cefe04e295c345f6", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8f1f4f8d7bded19517205f8522a0110204f51/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8f1f4f8d7bded19517205f8522a0110204f51/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=9bc8f1f4f8d7bded19517205f8522a0110204f51", "patch": "@@ -87,7 +87,7 @@ impl TypeAliasData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitData {\n     pub name: Option<Name>,\n-    pub items: Vec<AssocItemId>,\n+    pub items: Vec<(Name, AssocItemId)>,\n     pub auto: bool,\n }\n \n@@ -97,28 +97,42 @@ impl TraitData {\n         let name = src.value.name().map(|n| n.as_name());\n         let auto = src.value.is_auto();\n         let ast_id_map = db.ast_id_map(src.file_id);\n+\n+        let container = ContainerId::TraitId(tr);\n         let items = if let Some(item_list) = src.value.item_list() {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::FnDef(it) => {\n+                        let name = it.name().map(|it| it.as_name()).unwrap_or_else(Name::missing);\n+                        let def = FunctionLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::ConstDef(it) => ConstLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::ConstDef(it) => {\n+                        let name = it.name().map(|it| it.as_name()).unwrap_or_else(Name::missing);\n+                        let def = ConstLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        let name = it.name().map(|it| it.as_name()).unwrap_or_else(Name::missing);\n+                        let def = TypeAliasLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n                 })\n                 .collect()\n         } else {\n@@ -128,11 +142,18 @@ impl TraitData {\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n-        self.items.iter().filter_map(|item| match item {\n+        self.items.iter().filter_map(|(_name, item)| match item {\n             AssocItemId::TypeAliasId(t) => Some(*t),\n             _ => None,\n         })\n     }\n+\n+    pub fn associated_type_by_name(&self, name: &Name) -> Option<TypeAliasId> {\n+        self.items.iter().find_map(|(item_name, item)| match item {\n+            AssocItemId::TypeAliasId(t) if item_name == name => Some(*t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}]}