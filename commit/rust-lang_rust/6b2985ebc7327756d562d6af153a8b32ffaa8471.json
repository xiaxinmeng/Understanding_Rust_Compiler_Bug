{"sha": "6b2985ebc7327756d562d6af153a8b32ffaa8471", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMjk4NWViYzczMjc3NTZkNTYyZDZhZjE1M2E4YjMyZmZhYTg0NzE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-02T02:02:17Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-02T02:02:17Z"}, "message": "Remove unused code and add space bewteen tt", "tree": {"sha": "cabe40801059eb5283019982c0091ddb454c6e9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cabe40801059eb5283019982c0091ddb454c6e9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b2985ebc7327756d562d6af153a8b32ffaa8471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2985ebc7327756d562d6af153a8b32ffaa8471", "html_url": "https://github.com/rust-lang/rust/commit/6b2985ebc7327756d562d6af153a8b32ffaa8471", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b2985ebc7327756d562d6af153a8b32ffaa8471/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12629d5e4f2d949eedb707dedad4d75eff09e683", "url": "https://api.github.com/repos/rust-lang/rust/commits/12629d5e4f2d949eedb707dedad4d75eff09e683", "html_url": "https://github.com/rust-lang/rust/commit/12629d5e4f2d949eedb707dedad4d75eff09e683"}], "stats": {"total": 112, "additions": 80, "deletions": 32}, "files": [{"sha": "3521b382adfe14f4450f531fb0850e1307228209", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6b2985ebc7327756d562d6af153a8b32ffaa8471/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2985ebc7327756d562d6af153a8b32ffaa8471/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=6b2985ebc7327756d562d6af153a8b32ffaa8471", "patch": "@@ -148,30 +148,21 @@ fn convert_tt(\n         match child {\n             SyntaxElement::Token(token) => {\n                 if token.kind().is_punct() {\n-                    let mut prev = None;\n-                    for char in token.text().chars() {\n-                        if let Some(char) = prev {\n-                            token_trees.push(\n-                                tt::Leaf::from(tt::Punct { char, spacing: tt::Spacing::Joint })\n-                                    .into(),\n-                            );\n-                        }\n-                        prev = Some(char)\n-                    }\n-                    if let Some(char) = prev {\n-                        let spacing = match child_iter.peek() {\n-                            Some(SyntaxElement::Token(token)) => {\n-                                if token.kind().is_punct() {\n-                                    tt::Spacing::Joint\n-                                } else {\n-                                    tt::Spacing::Alone\n-                                }\n+                    assert!(token.text().len() == 1, \"Input ast::token punct must be single char.\");\n+                    let char = token.text().chars().next().unwrap();\n+\n+                    let spacing = match child_iter.peek() {\n+                        Some(SyntaxElement::Token(token)) => {\n+                            if token.kind().is_punct() {\n+                                tt::Spacing::Joint\n+                            } else {\n+                                tt::Spacing::Alone\n                             }\n-                            _ => tt::Spacing::Alone,\n-                        };\n+                        }\n+                        _ => tt::Spacing::Alone,\n+                    };\n \n-                        token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n-                    }\n+                    token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n                 } else {\n                     let child: tt::TokenTree = if token.kind() == SyntaxKind::TRUE_KW\n                         || token.kind() == SyntaxKind::FALSE_KW\n@@ -224,6 +215,15 @@ impl<'a, Q: Querier> TtTreeSink<'a, Q> {\n     }\n }\n \n+fn is_delimiter(kind: SyntaxKind) -> bool {\n+    use SyntaxKind::*;\n+\n+    match kind {\n+        L_PAREN | L_BRACK | L_CURLY | R_PAREN | R_BRACK | R_CURLY => true,\n+        _ => false,\n+    }\n+}\n+\n impl<'a, Q: Querier> TreeSink for TtTreeSink<'a, Q> {\n     fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n         if kind == L_DOLLAR || kind == R_DOLLAR {\n@@ -240,14 +240,18 @@ impl<'a, Q: Querier> TreeSink for TtTreeSink<'a, Q> {\n         self.buf.clear();\n         self.inner.token(kind, text);\n \n-        // // Add a white space to token\n-        // let (last_kind, _, last_joint_to_next ) = self.src_querier.token(self.token_pos-n_tokens as usize);\n-        // if !last_joint_to_next && last_kind.is_punct() {\n-        //     let (cur_kind, _, _ ) = self.src_querier.token(self.token_pos);\n-        //     if cur_kind.is_punct() {\n-        //         self.inner.token(WHITESPACE, \" \".into());\n-        //     }\n-        // }\n+        // Add a white space between tokens, only if both are not delimiters\n+        if !is_delimiter(kind) {\n+            let (last_kind, _, last_joint_to_next) = self.src_querier.token(self.token_pos - 1);\n+            if !last_joint_to_next && last_kind.is_punct() {\n+                let (cur_kind, _, _) = self.src_querier.token(self.token_pos);\n+                if !is_delimiter(cur_kind) {\n+                    if cur_kind.is_punct() {\n+                        self.inner.token(WHITESPACE, \" \".into());\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     fn start_node(&mut self, kind: SyntaxKind) {"}, {"sha": "53bc305bec0e990ac0e5ad1cafbdb822e0535989", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6b2985ebc7327756d562d6af153a8b32ffaa8471/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b2985ebc7327756d562d6af153a8b32ffaa8471/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=6b2985ebc7327756d562d6af153a8b32ffaa8471", "patch": "@@ -1,6 +1,5 @@\n use crate::ParseError;\n use crate::subtree_parser::Parser;\n-use crate::subtree_source::TokenPeek;\n use smallvec::{SmallVec, smallvec};\n \n #[derive(Debug, Clone)]\n@@ -153,7 +152,7 @@ impl<'a> TtCursor<'a> {\n     pub(crate) fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n         let parser = Parser::new(&mut self.pos, self.subtree);\n         parser.parse_vis()\n-    }\n+        }\n \n     pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ParseError> {\n         if self.at_char(char) {\n@@ -262,3 +261,48 @@ impl<'a> TtCursor<'a> {\n         self.pos = memento.pos;\n     }\n }\n+\n+pub(crate) struct TokenPeek<'a, I>\n+where\n+    I: Iterator<Item = &'a tt::TokenTree>,\n+{\n+    iter: itertools::MultiPeek<I>,\n+}\n+\n+// helper function\n+fn to_punct(tt: &tt::TokenTree) -> Option<&tt::Punct> {\n+    if let tt::TokenTree::Leaf(tt::Leaf::Punct(pp)) = tt {\n+        return Some(pp);\n+    }\n+    None\n+}\n+\n+impl<'a, I> TokenPeek<'a, I>\n+where\n+    I: Iterator<Item = &'a tt::TokenTree>,\n+{\n+    pub fn new(iter: I) -> Self {\n+        TokenPeek { iter: itertools::multipeek(iter) }\n+    }\n+\n+    pub fn current_punct2(&mut self, p: &tt::Punct) -> Option<((char, char), bool)> {\n+        if p.spacing != tt::Spacing::Joint {\n+            return None;\n+        }\n+\n+        self.iter.reset_peek();\n+        let p1 = to_punct(self.iter.peek()?)?;\n+        Some(((p.char, p1.char), p1.spacing == tt::Spacing::Joint))\n+    }\n+\n+    pub fn current_punct3(&mut self, p: &tt::Punct) -> Option<((char, char, char), bool)> {\n+        self.current_punct2(p).and_then(|((p0, p1), last_joint)| {\n+            if !last_joint {\n+                None\n+            } else {\n+                let p2 = to_punct(*self.iter.peek()?)?;\n+                Some(((p0, p1, p2.char), p2.spacing == tt::Spacing::Joint))\n+            }\n+        })\n+    }\n+}"}]}