{"sha": "899ffcf62adde4cef2af0d543fc3fa627396a586", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OWZmY2Y2MmFkZGU0Y2VmMmFmMGQ1NDNmYzNmYTYyNzM5NmE1ODY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-13T15:40:18Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-17T15:51:07Z"}, "message": "Intpocalypse, book edition.\n\nFix all usage of int/uint/i/u in the book.", "tree": {"sha": "a705271031fc4bfb5e3bbccc99c012145088f25b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a705271031fc4bfb5e3bbccc99c012145088f25b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/899ffcf62adde4cef2af0d543fc3fa627396a586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/899ffcf62adde4cef2af0d543fc3fa627396a586", "html_url": "https://github.com/rust-lang/rust/commit/899ffcf62adde4cef2af0d543fc3fa627396a586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/899ffcf62adde4cef2af0d543fc3fa627396a586/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "078bd498b9fa6eab40df147ce6015ab9aae62b40", "url": "https://api.github.com/repos/rust-lang/rust/commits/078bd498b9fa6eab40df147ce6015ab9aae62b40", "html_url": "https://github.com/rust-lang/rust/commit/078bd498b9fa6eab40df147ce6015ab9aae62b40"}], "stats": {"total": 372, "additions": 187, "deletions": 185}, "files": [{"sha": "ab112280a69a5c6d6291e7f747599612fed2b3ea", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -116,11 +116,11 @@ pub fn compress(src: &[u8]) -> Vec<u8> {\n         let psrc = src.as_ptr();\n \n         let mut dstlen = snappy_max_compressed_length(srclen);\n-        let mut dst = Vec::with_capacity(dstlen as uint);\n+        let mut dst = Vec::with_capacity(dstlen as usize);\n         let pdst = dst.as_mut_ptr();\n \n         snappy_compress(psrc, srclen, pdst, &mut dstlen);\n-        dst.set_len(dstlen as uint);\n+        dst.set_len(dstlen as usize);\n         dst\n     }\n }\n@@ -148,11 +148,11 @@ pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n         let mut dstlen: size_t = 0;\n         snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n-        let mut dst = Vec::with_capacity(dstlen as uint);\n+        let mut dst = Vec::with_capacity(dstlen as usize);\n         let pdst = dst.as_mut_ptr();\n \n         if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n-            dst.set_len(dstlen as uint);\n+            dst.set_len(dstlen as usize);\n             Some(dst)\n         } else {\n             None // SNAPPY_INVALID_INPUT"}, {"sha": "74cb4530935dffb849f4a50411cf76358d0ee61f", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -5,7 +5,7 @@ multiple types of arguments. For example, remember our `OptionalInt` type?\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n ```\n@@ -40,26 +40,26 @@ we substitute that type for the same type used in the generic. Here's an\n example of using `Option<T>`, with some extra type annotations:\n \n ```{rust}\n-let x: Option<int> = Some(5i);\n+let x: Option<i32> = Some(5);\n ```\n \n-In the type declaration, we say `Option<int>`. Note how similar this looks to\n-`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n-Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n+In the type declaration, we say `Option<i32>`. Note how similar this looks to\n+`Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n+the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n+Since that's an `i32`, the two sides match, and Rust is happy. If they didn't\n match, we'd get an error:\n \n ```{rust,ignore}\n-let x: Option<f64> = Some(5i);\n-// error: mismatched types: expected `core::option::Option<f64>`\n-// but found `core::option::Option<int>` (expected f64 but found int)\n+let x: Option<f64> = Some(5);\n+// error: mismatched types: expected `core::option::Option<f64>`,\n+// found `core::option::Option<_>` (expected f64 but found integral variable)\n ```\n \n That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n match up:\n \n ```{rust}\n-let x: Option<int> = Some(5i);\n+let x: Option<i32> = Some(5);\n let y: Option<f64> = Some(5.0f64);\n ```\n "}, {"sha": "62cc1d5f62aec53ffea3a4ace7393e2a64db6c7b", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -5,7 +5,7 @@ Let's talk about loops.\n Remember Rust's `for` loop? Here's an example:\n \n ```{rust}\n-for x in range(0i, 10i) {\n+for x in range(0, 10) {\n     println!(\"{}\", x);\n }\n ```\n@@ -17,7 +17,7 @@ call the `.next()` method on repeatedly, and it gives us a sequence of things.\n Like this:\n \n ```{rust}\n-let mut range = range(0i, 10i);\n+let mut range = range(0, 10);\n \n loop {\n     match range.next() {\n@@ -32,8 +32,8 @@ loop {\n We make a mutable binding to the return value of `range`, which is our iterator.\n We then `loop`, with an inner `match`. This `match` is used on the result of\n `range.next()`, which gives us a reference to the next value of the iterator.\n-`next` returns an `Option<int>`, in this case, which will be `Some(int)` when\n-we have a value and `None` once we run out. If we get `Some(int)`, we print it\n+`next` returns an `Option<i32>`, in this case, which will be `Some(i32)` when\n+we have a value and `None` once we run out. If we get `Some(i32)`, we print it\n out, and if we get `None`, we `break` out of the loop.\n \n This code sample is basically the same as our `for` loop version. The `for`\n@@ -50,9 +50,9 @@ primitive. For example, if you needed to iterate over the contents of\n a vector, you may be tempted to write this:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n-for i in range(0u, nums.len()) {\n+for i in range(0, nums.len()) {\n     println!(\"{}\", nums[i]);\n }\n ```\n@@ -62,7 +62,7 @@ vectors returns an iterator which iterates through a reference to each element\n of the vector in turn. So write this:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n     println!(\"{}\", num);\n@@ -79,12 +79,12 @@ very common with iterators: we can ignore unnecessary bounds checks, but still\n know that we're safe.\n \n There's another detail here that's not 100% clear because of how `println!`\n-works. `num` is actually of type `&int`. That is, it's a reference to an `int`,\n-not an `int` itself. `println!` handles the dereferencing for us, so we don't\n+works. `num` is actually of type `&i32`. That is, it's a reference to an `i32`,\n+not an `i32` itself. `println!` handles the dereferencing for us, so we don't\n see it. This code works fine too:\n \n ```{rust}\n-let nums = vec![1i, 2i, 3i];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n     println!(\"{}\", *num);\n@@ -118,7 +118,7 @@ The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n ```{rust,ignore}\n-let one_to_one_hundred = range(1i, 101i).collect();\n+let one_to_one_hundred = range(1, 101).collect();\n ```\n \n As you can see, we call `collect()` on our iterator. `collect()` takes\n@@ -128,7 +128,7 @@ type of things you want to collect, and so you need to let it know.\n Here's the version that does compile:\n \n ```{rust}\n-let one_to_one_hundred = range(1i, 101i).collect::<Vec<int>>();\n+let one_to_one_hundred = range(1, 101).collect::<Vec<i32>>();\n ```\n \n If you remember, the `::<>` syntax allows us to give a type hint,\n@@ -138,7 +138,7 @@ and so we tell it that we want a vector of integers.\n is one:\n \n ```{rust}\n-let greater_than_forty_two = range(0i, 100i)\n+let greater_than_forty_two = range(0, 100)\n                              .find(|x| *x > 42);\n \n match greater_than_forty_two {\n@@ -155,8 +155,8 @@ element, `find` returns an `Option` rather than the element itself.\n Another important consumer is `fold`. Here's what it looks like:\n \n ```{rust}\n-let sum = range(1i, 4i)\n-              .fold(0i, |sum, x| sum + x);\n+let sum = range(1, 4)\n+              .fold(0, |sum, x| sum + x);\n ```\n \n `fold()` is a consumer that looks like this:\n@@ -172,24 +172,24 @@ in this iterator:\n \n | base | accumulator | element | closure result |\n |------|-------------|---------|----------------|\n-| 0i   | 0i          | 1i      | 1i             |\n-| 0i   | 1i          | 2i      | 3i             |\n-| 0i   | 3i          | 3i      | 6i             |\n+| 0    | 0           | 1       | 1              |\n+| 0    | 1           | 2       | 3              |\n+| 0    | 3           | 3       | 6              |\n \n We called `fold()` with these arguments:\n \n ```{rust}\n-# range(1i, 4i)\n-.fold(0i, |sum, x| sum + x);\n+# range(1, 4)\n+.fold(0, |sum, x| sum + x);\n ```\n \n-So, `0i` is our base, `sum` is our accumulator, and `x` is our element.  On the\n-first iteration, we set `sum` to `0i`, and `x` is the first element of `nums`,\n-`1i`. We then add `sum` and `x`, which gives us `0i + 1i = 1i`. On the second\n+So, `0` is our base, `sum` is our accumulator, and `x` is our element.  On the\n+first iteration, we set `sum` to `0`, and `x` is the first element of `nums`,\n+`1`. We then add `sum` and `x`, which gives us `0 + 1 = 1`. On the second\n iteration, that value becomes our accumulator, `sum`, and the element is\n-the second element of the array, `2i`. `1i + 2i = 3i`, and so that becomes\n+the second element of the array, `2`. `1 + 2 = 3`, and so that becomes\n the value of the accumulator for the last iteration. On that iteration,\n-`x` is the last element, `3i`, and `3i + 3i = 6i`, which is our final\n+`x` is the last element, `3`, and `3 + 3 = 6`, which is our final\n result for our sum. `1 + 2 + 3 = 6`, and that's the result we got.\n \n Whew. `fold` can be a bit strange the first few times you see it, but once it\n@@ -210,14 +210,14 @@ This code, for example, does not actually generate the numbers\n `1-100`, and just creates a value that represents the sequence:\n \n ```{rust}\n-let nums = range(1i, 100i);\n+let nums = range(1, 100);\n ```\n \n Since we didn't do anything with the range, it didn't generate the sequence.\n Let's add the consumer:\n \n ```{rust}\n-let nums = range(1i, 100i).collect::<Vec<int>>();\n+let nums = range(1, 100).collect::<Vec<i32>>();\n ```\n \n Now, `collect()` will require that `range()` give it some numbers, and so\n@@ -228,7 +228,7 @@ which you've used before. `iter()` can turn a vector into a simple iterator\n that gives you each element in turn:\n \n ```{rust}\n-let nums = [1i, 2i, 3i];\n+let nums = [1, 2, 3];\n \n for num in nums.iter() {\n    println!(\"{}\", num);\n@@ -239,12 +239,12 @@ These two basic iterators should serve you well. There are some more\n advanced iterators, including ones that are infinite. Like `count`:\n \n ```{rust}\n-std::iter::count(1i, 5i);\n+std::iter::count(1, 5);\n ```\n \n This iterator counts up from one, adding five each time. It will give\n you a new integer every time, forever (well, technically, until it reaches the\n-maximum number representable by an `int`). But since iterators are lazy,\n+maximum number representable by an `i32`). But since iterators are lazy,\n that's okay! You probably don't want to use `collect()` on it, though...\n \n That's enough about iterators. Iterator adapters are the last concept\n@@ -256,7 +256,7 @@ we need to talk about with regards to iterators. Let's get to it!\n a new iterator. The simplest one is called `map`:\n \n ```{rust,ignore}\n-range(1i, 100i).map(|x| x + 1i);\n+range(1, 100).map(|x| x + 1);\n ```\n \n `map` is called upon another iterator, and produces a new iterator where each\n@@ -267,15 +267,15 @@ compile the example, you'll get a warning:\n ```{notrust,ignore}\n warning: unused result which must be used: iterator adaptors are lazy and\n          do nothing unless consumed, #[warn(unused_must_use)] on by default\n- range(1i, 100i).map(|x| x + 1i);\n+ range(1, 100).map(|x| x + 1);\n  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n ```\n \n Laziness strikes again! That closure will never execute. This example\n doesn't print any numbers:\n \n ```{rust,ignore}\n-range(1i, 100i).map(|x| println!(\"{}\", x));\n+range(1, 100).map(|x| println!(\"{}\", x));\n ```\n \n If you are trying to execute a closure on an iterator for its side effects,\n@@ -287,7 +287,7 @@ has no side effect on the original iterator. Let's try it out with our infinite\n iterator from before, `count()`:\n \n ```{rust}\n-for i in std::iter::count(1i, 5i).take(5) {\n+for i in std::iter::count(1, 5).take(5) {\n     println!(\"{}\", i);\n }\n ```\n@@ -307,7 +307,7 @@ returns `true` or `false`. The new iterator `filter()` produces\n only the elements that that closure returns `true` for:\n \n ```{rust}\n-for i in range(1i, 100i).filter(|&x| x % 2 == 0) {\n+for i in range(1, 100).filter(|&x| x % 2 == 0) {\n     println!(\"{}\", i);\n }\n ```\n@@ -322,11 +322,11 @@ You can chain all three things together: start with an iterator, adapt it\n a few times, and then consume the result. Check it out:\n \n ```{rust}\n-range(1i, 1000i)\n+range(1, 1000)\n     .filter(|&x| x % 2 == 0)\n     .filter(|&x| x % 3 == 0)\n     .take(5)\n-    .collect::<Vec<int>>();\n+    .collect::<Vec<i32>>();\n ```\n \n This will give you a vector containing `6`, `12`, `18`, `24`, and `30`."}, {"sha": "c01df64ef8f65e63d8d3bcf93baf31c3bbd078cb", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -54,7 +54,7 @@ The other kind of looping construct in Rust is the `while` loop. It looks like\n this:\n \n ```{rust}\n-let mut x = 5u32;       // mut x: u32\n+let mut x = 5;        // mut x: u32\n let mut done = false; // mut done: bool\n \n while !done {\n@@ -91,7 +91,7 @@ can do with safety and code generation, so you should always prefer\n Let's take a look at that `while` loop we had earlier:\n \n ```{rust}\n-let mut x = 5u32;\n+let mut x = 5;\n let mut done = false;\n \n while !done {\n@@ -108,7 +108,7 @@ modifying iteration: `break` and `continue`.\n In this case, we can write the loop in a better way with `break`:\n \n ```{rust}\n-let mut x = 5u32;\n+let mut x = 5;\n \n loop {\n     x += x - 3;"}, {"sha": "46a4af0d25135baaa9aa01f6a09239809be5dfd8", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -11,8 +11,8 @@ which both pattern-match on their input and both return early in one case,\n doing nothing otherwise:\n \n ~~~~\n-# enum T { SpecialA(uint), SpecialB(uint) }\n-# fn f() -> uint {\n+# enum T { SpecialA(u32), SpecialB(u32) }\n+# fn f() -> u32 {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n match input_1 {\n@@ -24,7 +24,7 @@ match input_2 {\n     T::SpecialB(x) => { return x; }\n     _ => {}\n }\n-# return 0u;\n+# return 0;\n # }\n ~~~~\n \n@@ -37,8 +37,8 @@ lightweight custom syntax extensions, themselves defined using the\n the pattern in the above code:\n \n ~~~~\n-# enum T { SpecialA(uint), SpecialB(uint) }\n-# fn f() -> uint {\n+# enum T { SpecialA(u32), SpecialB(u32) }\n+# fn f() -> u32 {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n@@ -165,8 +165,8 @@ separator token (a comma-separated list could be written `$(...),*`), and `+`\n instead of `*` to mean \"at least one\".\n \n ~~~~\n-# enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)}\n-# fn f() -> uint {\n+# enum T { SpecialA(u32), SpecialB(u32), SpecialC(u32), SpecialD(u32) }\n+# fn f() -> u32 {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n@@ -226,10 +226,10 @@ solves the problem.\n Now consider code like the following:\n \n ~~~~\n-# enum T1 { Good1(T2, uint), Bad1}\n+# enum T1 { Good1(T2, u32), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2}\n-# fn f(x: T1) -> uint {\n+# enum T3 { Good2(u32), Bad2}\n+# fn f(x: T1) -> u32 {\n match x {\n     T1::Good1(g1, val) => {\n         match g1.body {\n@@ -273,10 +273,10 @@ macro_rules! biased_match {\n     )\n }\n \n-# enum T1 { Good1(T2, uint), Bad1}\n+# enum T1 { Good1(T2, u32), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2}\n-# fn f(x: T1) -> uint {\n+# enum T3 { Good2(u32), Bad2}\n+# fn f(x: T1) -> u32 {\n biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n               binds g1, val );\n biased_match!((g1.body) -> (T3::Good2(result) )\n@@ -383,10 +383,10 @@ macro_rules! biased_match {\n }\n \n \n-# enum T1 { Good1(T2, uint), Bad1}\n+# enum T1 { Good1(T2, u32), Bad1}\n # struct T2 { body: T3 }\n-# enum T3 { Good2(uint), Bad2}\n-# fn f(x: T1) -> uint {\n+# enum T3 { Good2(u32), Bad2}\n+# fn f(x: T1) -> u32 {\n biased_match!(\n     (x)       -> (T1::Good1(g1, val)) else { return 0 };\n     (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n@@ -528,7 +528,7 @@ A further difficulty occurs when a macro is used in multiple crates.  Say that\n `mylib` defines\n \n ```rust\n-pub fn increment(x: uint) -> uint {\n+pub fn increment(x: u32) -> u32 {\n     x + 1\n }\n "}, {"sha": "6e125e218eaacf1d60e9b4c22ad1929cba389f93", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -418,7 +418,7 @@ struct Wheel {\n fn main() {\n     let car = Car { name: \"DeLorean\".to_string() };\n \n-    for _ in range(0u, 4) {\n+    for _ in range(0, 4) {\n         Wheel { size: 360, owner: car };\n     }\n }\n@@ -456,7 +456,7 @@ fn main() {\n \n     let car_owner = Rc::new(car);\n \n-    for _ in range(0u, 4) {\n+    for _ in range(0, 4) {\n         Wheel { size: 360, owner: car_owner.clone() };\n     }\n }"}, {"sha": "4992c49c991d73a789f144f033816f0b6e05036e", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -8,7 +8,7 @@ A quick refresher: you can match against literals directly, and `_` acts as an\n *any* case:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 => println!(\"one\"),\n@@ -21,7 +21,7 @@ match x {\n You can match multiple patterns with `|`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 | 2 => println!(\"one or two\"),\n@@ -33,7 +33,7 @@ match x {\n You can match a range of values with `...`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     1 ... 5 => println!(\"one through five\"),\n@@ -47,7 +47,7 @@ If you're matching multiple things, via a `|` or a `...`, you can bind\n the value to a name with `@`:\n \n ```{rust}\n-let x = 1i;\n+let x = 1;\n \n match x {\n     e @ 1 ... 5 => println!(\"got a range element {}\", e),\n@@ -60,11 +60,11 @@ ignore the value and type in the variant:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n-let x = OptionalInt::Value(5i);\n+let x = OptionalInt::Value(5);\n \n match x {\n     OptionalInt::Value(..) => println!(\"Got an int!\"),\n@@ -76,11 +76,11 @@ You can introduce *match guards* with `if`:\n \n ```{rust}\n enum OptionalInt {\n-    Value(int),\n+    Value(i32),\n     Missing,\n }\n \n-let x = OptionalInt::Value(5i);\n+let x = OptionalInt::Value(5);\n \n match x {\n     OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n@@ -93,33 +93,33 @@ If you're matching on a pointer, you can use the same syntax as you declared it\n with. First, `&`:\n \n ```{rust}\n-let x = &5i;\n+let x = &5;\n \n match x {\n     &val => println!(\"Got a value: {}\", val),\n }\n ```\n \n-Here, the `val` inside the `match` has type `int`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5i`, then in `&val`, `val`\n-would be `5i`.\n+Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n+side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n+would be `5`.\n \n If you want to get a reference, use the `ref` keyword:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n \n match x {\n     ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n-Here, the `r` inside the `match` has the type `&int`. In other words, the `ref`\n+Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n keyword _creates_ a reference, for use in the pattern. If you need a mutable\n reference, `ref mut` will work in the same way:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5;\n \n match x {\n     ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n@@ -131,11 +131,11 @@ If you have a struct, you can destructure it inside of a pattern:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { x: x, y: y } => println!(\"({},{})\", x, y),\n@@ -147,11 +147,11 @@ If we only care about some of the values, we don't have to give them all names:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { x: x, .. } => println!(\"x is {}\", x),\n@@ -163,11 +163,11 @@ You can do this kind of match on any member, not just the first:\n ```{rust}\n # #![allow(non_shorthand_field_patterns)]\n struct Point {\n-    x: int,\n-    y: int,\n+    x: i32,\n+    y: i32,\n }\n \n-let origin = Point { x: 0i, y: 0i };\n+let origin = Point { x: 0, y: 0 };\n \n match origin {\n     Point { y: y, .. } => println!(\"y is {}\", y),"}, {"sha": "d710c2fe4e7566c0c6bd25f0433540b98330916a", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -68,7 +68,7 @@ use rustc::plugin::Registry;\n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n \n-    static NUMERALS: &'static [(&'static str, uint)] = &[\n+    static NUMERALS: &'static [(&'static str, u32)] = &[\n         (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n         (\"C\",  100), (\"XC\",  90), (\"L\",  50), (\"XL\",  40),\n         (\"X\",   10), (\"IX\",   9), (\"V\",   5), (\"IV\",   4),\n@@ -83,7 +83,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     };\n \n     let mut text = text.as_slice();\n-    let mut total = 0u;\n+    let mut total = 0;\n     while !text.is_empty() {\n         match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {\n             Some(&(rn, val)) => {\n@@ -118,7 +118,7 @@ fn main() {\n }\n ```\n \n-The advantages over a simple `fn(&str) -> uint` are:\n+The advantages over a simple `fn(&str) -> u32` are:\n \n * The (arbitrarily complex) conversion is done at compile time.\n * Input validation is also performed at compile time."}, {"sha": "c918a80a86f0158f9a8c76a1d09a68f66a684e39", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -28,9 +28,10 @@ question](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-\n as the rest of this guide assumes you know the difference.) Like this:\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n ```\n+\n | location | value |\n |----------|-------|\n | 0xd3e030 | 5\t   |\n@@ -46,10 +47,11 @@ Let's introduce a pointer. In some languages, there is just one type of\n *reference*, which is the simplest kind of pointer.\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n ```\n+\n |location | value    |\n |-------- |----------|\n |0xd3e030 | 5        |\n@@ -58,25 +60,25 @@ let z = &y;\n \n See the difference? Rather than contain a value, the value of a pointer is a\n location in memory. In this case, the location of `y`. `x` and `y` have the\n-type `int`, but `z` has the type `&int`. We can print this location using the\n+type `i32`, but `z` has the type `&i32`. We can print this location using the\n `{:p}` format string:\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n \n println!(\"{:p}\", z);\n ```\n \n This would print `0xd3e028`, with our fictional memory addresses.\n \n-Because `int` and `&int` are different types, we can't, for example, add them\n+Because `i32` and `&i32` are different types, we can't, for example, add them\n together:\n \n ```{rust,ignore}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n \n println!(\"{}\", x + z);\n@@ -85,7 +87,7 @@ println!(\"{}\", x + z);\n This gives us an error:\n \n ```text\n-hello.rs:6:24: 6:25 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)\n+hello.rs:6:24: 6:25 error: mismatched types: expected `i32` but found `&i32` (expected i32 but found &-ptr)\n hello.rs:6     println!(\"{}\", x + z);\n                                   ^\n ```\n@@ -95,8 +97,8 @@ pointer means accessing the value at the location stored in the pointer. This\n will work:\n \n ```{rust}\n-let x = 5i;\n-let y = 8i;\n+let x = 5;\n+let y = 8;\n let z = &y;\n \n println!(\"{}\", x + *z);\n@@ -153,7 +155,7 @@ So what do pointers have to do with this? Well, since pointers point to a\n location in memory...\n \n ```text\n-func foo(&int x) {\n+func foo(&i32 x) {\n     *x = 5\n }\n \n@@ -252,7 +254,7 @@ The most basic type of pointer that Rust has is called a *reference*. Rust\n references look like this:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n \n println!(\"{}\", *y);\n@@ -269,18 +271,18 @@ referent, because `println!` will automatically dereference it for us.\n Here's a function that takes a reference:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n ```\n \n You can also use `&` as an operator to create a reference, so we can\n call this function in two different ways:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n \n fn main() {\n \n-    let x = 5i;\n+    let x = 5;\n     let y = &x;\n \n     println!(\"{}\", succ(y));\n@@ -294,13 +296,13 @@ Of course, if this were real code, we wouldn't bother with the reference, and\n just write:\n \n ```{rust}\n-fn succ(x: int) -> int { x + 1 }\n+fn succ(x: i32) -> i32 { x + 1 }\n ```\n \n References are immutable by default:\n \n ```{rust,ignore}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n \n *y = 5; // error: cannot assign to immutable dereference of `&`-pointer `*y`\n@@ -310,29 +312,29 @@ They can be made mutable with `mut`, but only if its referent is also mutable.\n This works:\n \n ```{rust}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n ```\n \n This does not:\n \n ```{rust,ignore}\n-let x = 5i;\n+let x = 5;\n let y = &mut x; // error: cannot borrow immutable local variable `x` as mutable\n ```\n \n Immutable pointers are allowed to alias:\n \n ```{rust}\n-let x = 5i;\n+let x = 5;\n let y = &x;\n let z = &x;\n ```\n \n Mutable ones, however, are not:\n \n ```{rust,ignore}\n-let mut x = 5i;\n+let mut x = 5;\n let y = &mut x;\n let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time\n ```\n@@ -359,7 +361,7 @@ duration a *lifetime*. Let's try a more complex example:\n \n ```{rust}\n fn main() {\n-    let x = &mut 5i;\n+    let x = &mut 5;\n \n     if *x < 10 {\n         let y = &x;\n@@ -380,7 +382,7 @@ mutated, and therefore, lets us pass. This wouldn't work:\n \n ```{rust,ignore}\n fn main() {\n-    let x = &mut 5i;\n+    let x = &mut 5;\n \n     if *x < 10 {\n         let y = &x;\n@@ -425,43 +427,43 @@ References just borrow ownership, which is more polite if you don't need the\n ownership. In other words, prefer:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n ```\n \n to\n \n ```{rust}\n-fn succ(x: Box<int>) -> int { *x + 1 }\n+fn succ(x: Box<i32>) -> i32 { *x + 1 }\n ```\n \n As a corollary to that rule, references allow you to accept a wide variety of\n other pointers, and so are useful so that you don't have to write a number\n of variants per pointer. In other words, prefer:\n \n ```{rust}\n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n ```\n \n to\n \n ```{rust}\n use std::rc::Rc;\n \n-fn box_succ(x: Box<int>) -> int { *x + 1 }\n+fn box_succ(x: Box<i32>) -> i32 { *x + 1 }\n \n-fn rc_succ(x: Rc<int>) -> int { *x + 1 }\n+fn rc_succ(x: Rc<i32>) -> i32 { *x + 1 }\n ```\n \n Note that the caller of your function will have to modify their calls slightly:\n \n ```{rust}\n use std::rc::Rc;\n \n-fn succ(x: &int) -> int { *x + 1 }\n+fn succ(x: &i32) -> i32 { *x + 1 }\n \n-let ref_x = &5i;\n-let box_x = Box::new(5i);\n-let rc_x  = Rc::new(5i);\n+let ref_x = &5;\n+let box_x = Box::new(5);\n+let rc_x  = Rc::new(5);\n \n succ(ref_x);\n succ(&*box_x);\n@@ -477,15 +479,15 @@ those contents.\n heap allocation in Rust. Creating a box looks like this:\n \n ```{rust}\n-let x = Box::new(5i);\n+let x = Box::new(5);\n ```\n \n Boxes are heap allocated and they are deallocated automatically by Rust when\n they go out of scope:\n \n ```{rust}\n {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     // stuff happens\n \n@@ -505,7 +507,7 @@ boxes, though. As a rough approximation, you can treat this Rust code:\n \n ```{rust}\n {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     // stuff happens\n }\n@@ -544,12 +546,12 @@ for more detail on how lifetimes work.\n Using boxes and references together is very common. For example:\n \n ```{rust}\n-fn add_one(x: &int) -> int {\n+fn add_one(x: &i32) -> i32 {\n     *x + 1\n }\n \n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     println!(\"{}\", add_one(&*x));\n }\n@@ -561,12 +563,12 @@ function, and since it's only reading the value, allows it.\n We can borrow `x` multiple times, as long as it's not simultaneous:\n \n ```{rust}\n-fn add_one(x: &int) -> int {\n+fn add_one(x: &i32) -> i32 {\n     *x + 1\n }\n \n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     println!(\"{}\", add_one(&*x));\n     println!(\"{}\", add_one(&*x));\n@@ -577,12 +579,12 @@ fn main() {\n Or as long as it's not a mutable borrow. This will error:\n \n ```{rust,ignore}\n-fn add_one(x: &mut int) -> int {\n+fn add_one(x: &mut i32) -> i32 {\n     *x + 1\n }\n \n fn main() {\n-    let x = Box::new(5i);\n+    let x = Box::new(5);\n \n     println!(\"{}\", add_one(&*x)); // error: cannot borrow immutable dereference\n                                   // of `&`-pointer as mutable\n@@ -610,7 +612,7 @@ enum List<T> {\n }\n \n fn main() {\n-    let list: List<int> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n+    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n     println!(\"{:?}\", list);\n }\n ```\n@@ -659,10 +661,10 @@ so as to avoid copying a large data structure. For example:\n \n ```{rust}\n struct BigStruct {\n-    one: int,\n-    two: int,\n+    one: i32,\n+    two: i32,\n     // etc\n-    one_hundred: int,\n+    one_hundred: i32,\n }\n \n fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n@@ -687,10 +689,10 @@ This is an antipattern in Rust. Instead, write this:\n \n ```{rust}\n struct BigStruct {\n-    one: int,\n-    two: int,\n+    one: i32,\n+    two: i32,\n     // etc\n-    one_hundred: int,\n+    one_hundred: i32,\n }\n \n fn foo(x: Box<BigStruct>) -> BigStruct {"}, {"sha": "fa40b7e84908eada2622869770e8d1d3cba64768", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -512,7 +512,7 @@ use test::Bencher;\n #[bench]\n fn bench_xor_1000_ints(b: &mut Bencher) {\n     b.iter(|| {\n-        range(0u, 1000).fold(0, |old, new| old ^ new);\n+        range(0, 1000).fold(0, |old, new| old ^ new);\n     });\n }\n ```\n@@ -537,7 +537,7 @@ computation entirely. This could be done for the example above by adjusting the\n # impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n     // note lack of `;` (could also use an explicit `return`).\n-    range(0u, 1000).fold(0, |old, new| old ^ new)\n+    range(0, 1000).fold(0, |old, new| old ^ new)\n });\n ```\n "}, {"sha": "1bad09b4b6e55442be4d5aa2fd14c1e4227f4ec7", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -224,7 +224,7 @@ use std::sync::Future;\n # fn main() {\n # fn make_a_sandwich() {};\n fn fib(n: u64) -> u64 {\n-    // lengthy computation returning an uint\n+    // lengthy computation returning an 64\n     12586269025\n }\n \n@@ -249,7 +249,7 @@ computations. The workload will be distributed on the available cores.\n # #![allow(deprecated)]\n # use std::num::Float;\n # use std::sync::Future;\n-fn partial_sum(start: uint) -> f64 {\n+fn partial_sum(start: u64) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n         local_sum += (num as f64 + 1.0).powf(-2.0);\n@@ -289,15 +289,15 @@ use std::num::Float;\n use std::rand;\n use std::sync::Arc;\n \n-fn pnorm(nums: &[f64], p: uint) -> f64 {\n+fn pnorm(nums: &[f64], p: u64) -> f64 {\n     nums.iter().fold(0.0, |a, b| a + b.powf(p as f64)).powf(1.0 / (p as f64))\n }\n \n fn main() {\n     let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n     let numbers_arc = Arc::new(numbers);\n \n-    for num in range(1u, 10) {\n+    for num in range(1, 10) {\n         let thread_numbers = numbers_arc.clone();\n \n         spawn(move || {\n@@ -328,7 +328,7 @@ if it were local.\n ```{rust,ignore}\n # use std::rand;\n # use std::sync::Arc;\n-# fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n+# fn pnorm(nums: &[f64], p: u64) -> f64 { 4.0 }\n # fn main() {\n # let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n@@ -357,16 +357,16 @@ each other if they panic. The simplest way of handling a panic is with the\n `try` function, which is similar to `spawn`, but immediately blocks and waits\n for the child thread to finish. `try` returns a value of type\n `Result<T, Box<Any + Send>>`. `Result` is an `enum` type with two variants:\n-`Ok` and `Err`. In this case, because the type arguments to `Result` are `int`\n+`Ok` and `Err`. In this case, because the type arguments to `Result` are `i32`\n and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n-result with an `int` field (representing a successful result) or an `Err` result\n+result with an `i32` field (representing a successful result) or an `Err` result\n (representing termination with an error).\n \n ```{rust,ignore}\n # use std::thread::Thread;\n # fn some_condition() -> bool { false }\n-# fn calculate_result() -> int { 0 }\n-let result: Result<int, Box<std::any::Any + Send>> = Thread::spawn(move || {\n+# fn calculate_result() -> i32 { 0 }\n+let result: Result<i32, Box<std::any::Any + Send>> = Thread::spawn(move || {\n     if some_condition() {\n         calculate_result()\n     } else {"}, {"sha": "d12480d7dd9fa9339c6912a6e02abab81531db2d", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -145,7 +145,7 @@ As you can see, `print_area` is now generic, but also ensures that we\n have passed in the correct types. If we pass in an incorrect type:\n \n ```{rust,ignore}\n-print_area(5i);\n+print_area(5);\n ```\n \n We get a compile-time error:\n@@ -156,22 +156,22 @@ error: failed to find an implementation of trait main::HasArea for int\n \n So far, we've only added trait implementations to structs, but you can\n implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `int`:\n+`HasArea` for `i32`:\n \n ```{rust}\n trait HasArea {\n     fn area(&self) -> f64;\n }\n \n-impl HasArea for int {\n+impl HasArea for i32 {\n     fn area(&self) -> f64 {\n         println!(\"this is silly\");\n \n         *self as f64\n     }\n }\n \n-5i.area();\n+5.area();\n ```\n \n It is considered poor style to implement methods on such primitive types, even\n@@ -264,8 +264,8 @@ it won't affect you, unless you `use` that trait.\n \n There's one more restriction on implementing traits. Either the trait or the\n type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n-if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n+implement the `HasArea` type for `i32`, because `HasArea` is in our crate.  But\n+if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n not, because both the trait and the type aren't in our crate.\n \n One last thing about traits: generic functions with a trait bound use"}, {"sha": "ae5df30ff5612adc4e550f67366b2a1dbe2d96af", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/899ffcf62adde4cef2af0d543fc3fa627396a586/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=899ffcf62adde4cef2af0d543fc3fa627396a586", "patch": "@@ -95,7 +95,7 @@ offered by the Rust language and libraries. For example, they\n   use-after-free;\n - are considered sendable (if their contents is considered sendable),\n   so the compiler offers no assistance with ensuring their use is\n-  thread-safe; for example, one can concurrently access a `*mut int`\n+  thread-safe; for example, one can concurrently access a `*mut i32`\n   from two threads without synchronization.\n - lack any form of lifetimes, unlike `&`, and so the compiler cannot\n   reason about dangling pointers; and\n@@ -265,12 +265,12 @@ impl<T: Send> Drop for Unique<T> {\n // A comparison between the built-in `Box` and this reimplementation\n fn main() {\n     {\n-        let mut x = Box::new(5i);\n+        let mut x = Box::new(5);\n         *x = 10;\n     } // `x` is freed here\n \n     {\n-        let mut y = Unique::new(5i);\n+        let mut y = Unique::new(5);\n         *y.borrow_mut() = 10;\n     } // `y` is freed here\n }\n@@ -367,7 +367,7 @@ expressions must be mutable lvalues:\n ```\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: int, b: int) -> int {\n+fn add(a: i32, b: i32) -> i32 {\n     let mut c = 0;\n     unsafe {\n         asm!(\"add $2, $0\"\n@@ -378,7 +378,7 @@ fn add(a: int, b: int) -> int {\n     c\n }\n # #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: int, b: int) -> int { a + b }\n+# fn add(a: i32, b: i32) -> i32 { a + b }\n \n fn main() {\n     assert_eq!(add(3, 14159), 14162)\n@@ -454,7 +454,7 @@ extern crate libc;\n \n // Entry point for this program\n #[start]\n-fn start(_argc: int, _argv: *const *const u8) -> int {\n+fn start(_argc: isize, _argv: *const *const u8) -> isize {\n     0\n }\n \n@@ -480,7 +480,7 @@ compiler's name mangling too:\n extern crate libc;\n \n #[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: int, argv: *const *const u8) -> int {\n+pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n     0\n }\n \n@@ -552,8 +552,8 @@ pub extern fn dot_product(a: *const u32, a_len: u32,\n     // cannot tell the pointers are valid.\n     let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n         mem::transmute((\n-            Slice { data: a, len: a_len as uint },\n-            Slice { data: b, len: b_len as uint },\n+            Slice { data: a, len: a_len as usize },\n+            Slice { data: b, len: b_len as usize },\n         ))\n     };\n \n@@ -568,13 +568,13 @@ pub extern fn dot_product(a: *const u32, a_len: u32,\n #[lang = \"panic_fmt\"]\n extern fn panic_fmt(args: &core::fmt::Arguments,\n                        file: &str,\n-                       line: uint) -> ! {\n+                       line: u32) -> ! {\n     loop {}\n }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: int, argv: *const *const u8) -> int { 0 }\n+# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n # fn main() {}\n ```\n \n@@ -628,7 +628,7 @@ via a declaration like\n extern \"rust-intrinsic\" {\n     fn transmute<T, U>(x: T) -> U;\n \n-    fn offset<T>(dst: *const T, offset: int) -> *const T;\n+    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n }\n ```\n \n@@ -665,24 +665,24 @@ extern {\n pub struct Box<T>(*mut T);\n \n #[lang=\"exchange_malloc\"]\n-unsafe fn allocate(size: uint, _align: uint) -> *mut u8 {\n+unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n     // malloc failed\n-    if p as uint == 0 {\n+    if p as usize == 0 {\n         abort();\n     }\n \n     p\n }\n #[lang=\"exchange_free\"]\n-unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n     libc::free(ptr as *mut libc::c_void)\n }\n \n #[start]\n-fn main(argc: int, argv: *const *const u8) -> int {\n-    let x = box 1i;\n+fn main(argc: isize, argv: *const *const u8) -> isize {\n+    let x = box 1;\n \n     0\n }"}]}