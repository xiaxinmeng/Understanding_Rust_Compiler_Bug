{"sha": "dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZGY5ZDM1OTM2MzJmYWVhN2NjYjJmNzhiZDY1MTdjZTU2YmIwNmQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-20T00:51:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-20T00:51:10Z"}, "message": "Rollup merge of #40554 - nrc:rls-data, r=alexcrichton\n\nUse rls-data crate\n\nThis basically pulls out a bunch of data structures used by save-analysis for serialization into an external crate, and pulls that crate in using Rustbuild. The RLS can then share these data structures with the compiler which in some cases will allow more efficient communication between the compiler and the RLS (i.e., without serialisation).\n\nAlong the way, I have to pull in rls-span, which is the RLS's way of defining spans (more type-safe than the compiler's built-in way). This is basically just to convert from compiler spans to RLS spans.\n\nI also pull in the crates.io version of rustc-serialize, which is a bit annoying, but seems to be the only way to have serialisable data in an external crate. To make this work, all of the save-analysis crate has to use this version too (cc #40527).\n\nFinally I pull in a line from #40347 to make the unstable crate checking stuff working.\n\nThere are a lot of changes to save-analysis but they are all mechanical and trivial - changing from using `From` to `Into` (because of orphan rules) being the main thing.\n\nr? @alexcrichton", "tree": {"sha": "4dce9ecd354050500f5b8f63c3a9fc97f0f17bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dce9ecd354050500f5b8f63c3a9fc97f0f17bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "html_url": "https://github.com/rust-lang/rust/commit/dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7471d9793cf21f89f672eff14e6c529e286c2d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/7471d9793cf21f89f672eff14e6c529e286c2d30", "html_url": "https://github.com/rust-lang/rust/commit/7471d9793cf21f89f672eff14e6c529e286c2d30"}, {"sha": "1d93a6cce0119dfb1248643c7fb701ff1f8d4a50", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d93a6cce0119dfb1248643c7fb701ff1f8d4a50", "html_url": "https://github.com/rust-lang/rust/commit/1d93a6cce0119dfb1248643c7fb701ff1f8d4a50"}], "stats": {"total": 1371, "additions": 558, "deletions": 813}, "files": [{"sha": "a9a6fabb5b23c5ee95e864d79cef0599bf983f83", "filename": "src/Cargo.lock", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -27,7 +27,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -48,14 +48,24 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"arena\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -65,19 +75,19 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -94,25 +104,25 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.20.5\"\n+version = \"2.21.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vec_map 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cmake\"\n version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -130,7 +140,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -140,7 +150,7 @@ dependencies = [\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -186,7 +196,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -195,7 +205,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.43\"\n+version = \"0.3.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -221,7 +231,7 @@ dependencies = [\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -274,7 +284,7 @@ name = \"mdbook\"\n version = \"0.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -397,11 +407,28 @@ name = \"regex-syntax\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rls-data\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rls-span\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -435,7 +462,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.22\"\n+version = \"0.3.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -577,7 +604,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -690,8 +717,10 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rls-data 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"serialize 0.0.0\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -751,7 +780,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -799,7 +828,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -904,7 +933,7 @@ name = \"toml\"\n version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -940,7 +969,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"vec_map\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -961,15 +990,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [metadata]\n \"checksum aho-corasick 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0638fd549427caa90c499814196d1b9e3725eb4d15d7339d6de073a680ed0ca2\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n+\"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n \"checksum bitflags 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23\"\n-\"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n-\"checksum clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7db281b0520e97fbd15cd615dcd8f8bcad0c26f5f7d5effe705f090f39e9a758\"\n+\"checksum bitflags 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e1ab483fc81a8143faa7203c4a3c02888ebd1a782e37e41fa34753ba9a162\"\n+\"checksum clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74a80f603221c9cd9aa27a28f52af452850051598537bb6b359c38a7d61e5cda\"\n \"checksum cmake 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1acc68a3f714627af38f9f5d09706a28584ba60dfe2cca68f40bf779f941b25\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3856f1697098606fc6cb97a93de88ca3f3bc35bb878c725920e6e82ecf05e83\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c07c758b972368e703a562686adb39125707cc1ef3399da8c019fc6c2498a75d\"\n+\"checksum gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a32cd40070d7611ab76343dcb3204b2bb28c8a9450989a83a3d590248142f439\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2249f6f0dc5a3bb2b3b1a8f797dfccbc4b053344d773d654ad565e51427d335\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n@@ -987,7 +1017,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0aad603e8d7fb67da22dbdf1f4b826ce8829e406124109e73cf1b2454b93a71c\"\n \"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n \"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n-\"checksum rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"237546c689f20bb44980270c73c3b9edd0891c1be49cc1274406134a66d3957b\"\n+\"checksum rls-data 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"af1dfff00189fd7b78edb9af131b0de703676c04fa8126aed77fd2c586775a4d\"\n+\"checksum rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8656f7b850ac85fb204ef94318c641bbb15a32766e12f9a589a23e4c0fbc38db\"\n+\"checksum rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684ce48436d6465300c9ea783b6b14c4361d6b8dcbb1375b486a69cc19e2dfb0\"\n \"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n \"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n@@ -1000,7 +1032,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n \"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n-\"checksum vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cac5efe5cb0fa14ec2f84f83c701c562ee63f6dcc680861b21d65c682adfb05f\"\n+\"checksum vec_map 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8cdc8b93bd0198ed872357fb2e667f7125646b1762f16d60b2c96350d361897\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "62b7f6cb72e3baf51199d72942eb65d069a4fa89", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -94,6 +94,13 @@ fn main() {\n             cmd.arg(\"-Cprefer-dynamic\");\n         }\n \n+        // Pass the `rustbuild` feature flag to crates which rustbuild is\n+        // building. See the comment in bootstrap/lib.rs where this env var is\n+        // set for more details.\n+        if env::var_os(\"RUSTBUILD_UNSTABLE\").is_some() {\n+            cmd.arg(\"--cfg\").arg(\"rustbuild\");\n+        }\n+\n         // Help the libc crate compile by assisting it in finding the MUSL\n         // native libraries.\n         if let Some(s) = env::var_os(\"MUSL_ROOT\") {"}, {"sha": "26f3c063061972a96e3547f1ab0387e4f7bbafba", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -180,7 +180,7 @@ struct Crate {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n pub enum Mode {\n     /// This cargo is going to build the standard library, placing output in the\n     /// \"stageN-std\" directory.\n@@ -491,14 +491,35 @@ impl Build {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n-        if let Mode::Libstd = mode {\n+        if mode == Mode::Libstd {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n             cargo.env(\"RUSTC_SNAPSHOT\", self.compiler_path(compiler))\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n+        // There are two invariants we try must maintain:\n+        // * stable crates cannot depend on unstable crates (general Rust rule),\n+        // * crates that end up in the sysroot must be unstable (rustbuild rule).\n+        //\n+        // In order to do enforce the latter, we pass the env var\n+        // `RUSTBUILD_UNSTABLE` down the line for any crates which will end up\n+        // in the sysroot. We read this in bootstrap/bin/rustc.rs and if it is\n+        // set, then we pass the `rustbuild` feature to rustc when building the\n+        // the crate.\n+        //\n+        // In turn, crates that can be used here should recognise the `rustbuild`\n+        // feature and opt-in to `rustc_private`.\n+        //\n+        // We can't always pass `rustbuild` because crates which are outside of\n+        // the comipiler, libs, and tests are stable and we don't want to make\n+        // their deps unstable (since this would break the first invariant\n+        // above).\n+        if mode != Mode::Tool {\n+            cargo.env(\"RUSTBUILD_UNSTABLE\", \"1\");\n+        }\n+\n         // Ignore incremental modes except for stage0, since we're\n         // not guaranteeing correctness acros builds if the compiler\n         // is changing under your feet.`"}, {"sha": "06c5150fd13ade909458604075f3dcacd69a2b9c", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -12,5 +12,8 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n syntax = { path = \"../libsyntax\" }\n-serialize = { path = \"../libserialize\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rls-data = \"0.1\"\n+rls-span = \"0.1\"\n+# FIXME(#40527) should move rustc serialize out of tree\n+rustc-serialize = \"0.3\""}, {"sha": "59340ae87ee5da6e607b7e48ce976efd988b9228", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -13,6 +13,8 @@ use std::io::Write;\n use super::external_data::*;\n use super::dump::Dump;\n \n+use rls_data::{SpanData, CratePreludeData};\n+\n pub struct CsvDumper<'b, W: 'b> {\n     output: &'b mut W\n }\n@@ -429,6 +431,6 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n fn span_extent_str(span: SpanData) -> String {\n     format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n              file_line_end,{},file_col_end,{},byte_end,{}\",\n-             span.file_name, span.line_start, span.column_start, span.byte_start,\n-             span.line_end, span.column_end, span.byte_end)\n+             span.file_name.to_str().unwrap(), span.line_start.0, span.column_start.0,\n+             span.byte_start, span.line_end.0, span.column_end.0, span.byte_end)\n }"}, {"sha": "d4ded71a3339091fa2b53af1e650b0f3770ef25e", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -18,6 +18,8 @@ use rustc::hir::def_id::{CrateNum, DefId};\n use syntax::ast::{self, Attribute, NodeId};\n use syntax_pos::Span;\n \n+use rls_data::ExternalCrateData;\n+\n pub struct CrateData {\n     pub name: String,\n     pub number: u32,\n@@ -26,7 +28,7 @@ pub struct CrateData {\n \n /// Data for any entity in the Rust language. The actual data contained varies\n /// with the kind of entity being queried. See the nested structs for details.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub enum Data {\n     /// Data for Enums.\n     EnumData(EnumData),\n@@ -77,7 +79,7 @@ pub enum Data {\n     VariableRefData(VariableRefData),\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug, RustcEncodable)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n pub enum Visibility {\n     Public,\n     Restricted,\n@@ -107,24 +109,16 @@ impl<'a> From<&'a hir::Visibility> for Visibility {\n }\n \n /// Data for the prelude of a crate.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct CratePreludeData {\n     pub crate_name: String,\n     pub crate_root: String,\n     pub external_crates: Vec<ExternalCrateData>,\n     pub span: Span,\n }\n \n-/// Data for external crates in the prelude of a crate.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ExternalCrateData {\n-    pub name: String,\n-    pub num: CrateNum,\n-    pub file_name: String,\n-}\n-\n /// Data for enum declarations.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct EnumData {\n     pub id: NodeId,\n     pub name: String,\n@@ -140,7 +134,7 @@ pub struct EnumData {\n }\n \n /// Data for extern crates.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ExternCrateData {\n     pub id: NodeId,\n     pub name: String,\n@@ -151,15 +145,15 @@ pub struct ExternCrateData {\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionCallData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n /// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct FunctionData {\n     pub id: NodeId,\n     pub name: String,\n@@ -176,14 +170,14 @@ pub struct FunctionData {\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ImplData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -192,7 +186,7 @@ pub struct ImplData {\n     pub self_ref: Option<DefId>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n // FIXME: this struct should not exist. However, removing it requires heavy\n // refactoring of dump_visitor.rs. See PR 31838 for more info.\n pub struct ImplData2 {\n@@ -206,15 +200,15 @@ pub struct ImplData2 {\n     pub self_ref: Option<TypeRefData>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct InheritanceData {\n     pub span: Span,\n     pub base_id: DefId,\n     pub deriv_id: NodeId\n }\n \n /// Data about a macro declaration.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroData {\n     pub span: Span,\n     pub name: String,\n@@ -223,7 +217,7 @@ pub struct MacroData {\n }\n \n /// Data about a macro use.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroUseData {\n     pub span: Span,\n     pub name: String,\n@@ -236,7 +230,7 @@ pub struct MacroUseData {\n }\n \n /// Data about a method call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MethodCallData {\n     pub span: Span,\n     pub scope: NodeId,\n@@ -245,7 +239,7 @@ pub struct MethodCallData {\n }\n \n /// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct MethodData {\n     pub id: NodeId,\n     pub name: String,\n@@ -262,7 +256,7 @@ pub struct MethodData {\n }\n \n /// Data for modules.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModData {\n     pub id: NodeId,\n     pub name: String,\n@@ -278,15 +272,15 @@ pub struct ModData {\n }\n \n /// Data for a reference to a module.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: Option<DefId>,\n     pub qualname: String\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructData {\n     pub span: Span,\n     pub name: String,\n@@ -302,7 +296,7 @@ pub struct StructData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructVariantData {\n     pub span: Span,\n     pub name: String,\n@@ -317,7 +311,7 @@ pub struct StructVariantData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TraitData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -332,7 +326,7 @@ pub struct TraitData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TupleVariantData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -348,7 +342,7 @@ pub struct TupleVariantData {\n }\n \n /// Data for a typedef.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TypeDefData {\n     pub id: NodeId,\n     pub name: String,\n@@ -363,15 +357,15 @@ pub struct TypeDefData {\n }\n \n /// Data for a reference to a type or trait.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct TypeRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: Option<DefId>,\n     pub qualname: String,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -381,7 +375,7 @@ pub struct UseData {\n     pub visibility: Visibility,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseGlobData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -391,7 +385,7 @@ pub struct UseGlobData {\n }\n \n /// Data for local and global variables (consts and statics).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableData {\n     pub id: NodeId,\n     pub kind: VariableKind,\n@@ -408,7 +402,7 @@ pub struct VariableData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub enum VariableKind {\n     Static,\n     Const,\n@@ -418,7 +412,7 @@ pub enum VariableKind {\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: Span,\n@@ -430,7 +424,7 @@ pub struct VariableRefData {\n /// Encodes information about the signature of a definition. This should have\n /// enough information to create a nice display about a definition without\n /// access to the source code.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct Signature {\n     pub span: Span,\n     pub text: String,\n@@ -444,7 +438,7 @@ pub struct Signature {\n \n /// An element of a signature. `start` and `end` are byte offsets into the `text`\n /// of the parent `Signature`.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct SigElement {\n     pub id: DefId,\n     pub start: usize,"}, {"sha": "84e1fb03f624e821068f2111b3fcefc67ee51eeb", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -10,6 +10,8 @@\n \n use super::external_data::*;\n \n+use rls_data::CratePreludeData;\n+\n pub trait Dump {\n     fn crate_prelude(&mut self, CratePreludeData) {}\n     fn enum_data(&mut self, EnumData) {}"}, {"sha": "f2aa89ba4b66e8bc9bffdb1523c3ac52c6eb58b6", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -29,7 +29,7 @@\n \n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n@@ -54,6 +54,8 @@ use super::external_data::{Lower, make_def_id};\n use super::span_utils::SpanUtils;\n use super::recorder;\n \n+use rls_data::ExternalCrateData;\n+\n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n@@ -137,7 +139,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let lo_loc = self.span.sess.codemap().lookup_char_pos(c.span.lo);\n             ExternalCrateData {\n                 name: c.name,\n-                num: CrateNum::from_u32(c.number),\n+                num: c.number,\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             }\n         }).collect();"}, {"sha": "6fd2de97767e18d318a44257424ee7b379a48843", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 66, "deletions": 93, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -18,6 +18,9 @@ use syntax_pos::Span;\n \n use data::{self, Visibility, SigElement};\n \n+use rls_data::{SpanData, CratePreludeData, Attribute};\n+use rls_span::{Column, Row};\n+\n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n pub trait Lower {\n     type Target;\n@@ -35,41 +38,19 @@ pub fn null_def_id() -> DefId {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct SpanData {\n-    pub file_name: String,\n-    pub byte_start: u32,\n-    pub byte_end: u32,\n-    /// 1-based.\n-    pub line_start: usize,\n-    pub line_end: usize,\n-    /// 1-based, character offset.\n-    pub column_start: usize,\n-    pub column_end: usize,\n-}\n-\n-impl SpanData {\n-    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n-        let start = cm.lookup_char_pos(span.lo);\n-        let end = cm.lookup_char_pos(span.hi);\n-\n-        SpanData {\n-            file_name: start.file.name.clone(),\n-            byte_start: span.lo.0,\n-            byte_end: span.hi.0,\n-            line_start: start.line,\n-            line_end: end.line,\n-            column_start: start.col.0 + 1,\n-            column_end: end.col.0 + 1,\n-        }\n-    }\n-}\n+pub fn span_from_span(span: Span, cm: &CodeMap) -> SpanData {\n+    let start = cm.lookup_char_pos(span.lo);\n+    let end = cm.lookup_char_pos(span.hi);\n \n-/// Represent an arbitrary attribute on a code element\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct Attribute {\n-    value: String,\n-    span: SpanData,\n+    SpanData {\n+        file_name: start.file.name.clone().into(),\n+        byte_start: span.lo.0,\n+        byte_end: span.hi.0,\n+        line_start: Row::new_one_indexed(start.line as u32),\n+        line_end: Row::new_one_indexed(end.line as u32),\n+        column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n+        column_end: Column::new_one_indexed(end.col.0 as u32 + 1),\n+    }\n }\n \n impl Lower for Vec<ast::Attribute> {\n@@ -91,20 +72,12 @@ impl Lower for Vec<ast::Attribute> {\n \n             Attribute {\n                 value: value,\n-                span: SpanData::from_span(attr.span, tcx.sess.codemap()),\n+                span: span_from_span(attr.span, tcx.sess.codemap()),\n             }\n         }).collect()\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-pub struct CratePreludeData {\n-    pub crate_name: String,\n-    pub crate_root: String,\n-    pub external_crates: Vec<data::ExternalCrateData>,\n-    pub span: SpanData,\n-}\n-\n impl Lower for data::CratePreludeData {\n     type Target = CratePreludeData;\n \n@@ -113,13 +86,13 @@ impl Lower for data::CratePreludeData {\n             crate_name: self.crate_name,\n             crate_root: self.crate_root,\n             external_crates: self.external_crates,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n         }\n     }\n }\n \n /// Data for enum declarations.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct EnumData {\n     pub id: DefId,\n     pub value: String,\n@@ -143,7 +116,7 @@ impl Lower for data::EnumData {\n             name: self.name,\n             value: self.value,\n             qualname: self.qualname,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n@@ -155,7 +128,7 @@ impl Lower for data::EnumData {\n }\n \n /// Data for extern crates.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ExternCrateData {\n     pub id: DefId,\n     pub name: String,\n@@ -174,14 +147,14 @@ impl Lower for data::ExternCrateData {\n             name: self.name,\n             crate_num: self.crate_num,\n             location: self.location,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n         }\n     }\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionCallData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -193,15 +166,15 @@ impl Lower for data::FunctionCallData {\n \n     fn lower(self, tcx: TyCtxt) -> FunctionCallData {\n         FunctionCallData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n }\n \n /// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct FunctionData {\n     pub id: DefId,\n     pub name: String,\n@@ -226,7 +199,7 @@ impl Lower for data::FunctionData {\n             name: self.name,\n             qualname: self.qualname,\n             declaration: self.declaration,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n             visibility: self.visibility,\n@@ -239,7 +212,7 @@ impl Lower for data::FunctionData {\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionRefData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -251,13 +224,13 @@ impl Lower for data::FunctionRefData {\n \n     fn lower(self, tcx: TyCtxt) -> FunctionRefData {\n         FunctionRefData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n }\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ImplData {\n     pub id: DefId,\n     pub span: SpanData,\n@@ -272,15 +245,15 @@ impl Lower for data::ImplData {\n     fn lower(self, tcx: TyCtxt) -> ImplData {\n         ImplData {\n             id: make_def_id(self.id, &tcx.hir),\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             trait_ref: self.trait_ref,\n             self_ref: self.self_ref,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct InheritanceData {\n     pub span: SpanData,\n     pub base_id: DefId,\n@@ -292,15 +265,15 @@ impl Lower for data::InheritanceData {\n \n     fn lower(self, tcx: TyCtxt) -> InheritanceData {\n         InheritanceData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             base_id: self.base_id,\n             deriv_id: make_def_id(self.deriv_id, &tcx.hir)\n         }\n     }\n }\n \n /// Data about a macro declaration.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroData {\n     pub span: SpanData,\n     pub name: String,\n@@ -313,7 +286,7 @@ impl Lower for data::MacroData {\n \n     fn lower(self, tcx: TyCtxt) -> MacroData {\n         MacroData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             qualname: self.qualname,\n             docs: self.docs,\n@@ -322,7 +295,7 @@ impl Lower for data::MacroData {\n }\n \n /// Data about a macro use.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroUseData {\n     pub span: SpanData,\n     pub name: String,\n@@ -338,17 +311,17 @@ impl Lower for data::MacroUseData {\n \n     fn lower(self, tcx: TyCtxt) -> MacroUseData {\n         MacroUseData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             qualname: self.qualname,\n-            callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n+            callee_span: span_from_span(self.callee_span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n         }\n     }\n }\n \n /// Data about a method call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MethodCallData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -361,7 +334,7 @@ impl Lower for data::MethodCallData {\n \n     fn lower(self, tcx: TyCtxt) -> MethodCallData {\n         MethodCallData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             decl_id: self.decl_id,\n@@ -370,7 +343,7 @@ impl Lower for data::MethodCallData {\n }\n \n /// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct MethodData {\n     pub id: DefId,\n     pub name: String,\n@@ -391,7 +364,7 @@ impl Lower for data::MethodData {\n \n     fn lower(self, tcx: TyCtxt) -> MethodData {\n         MethodData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             scope: make_def_id(self.scope, &tcx.hir),\n             id: make_def_id(self.id, &tcx.hir),\n@@ -408,7 +381,7 @@ impl Lower for data::MethodData {\n }\n \n /// Data for modules.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModData {\n     pub id: DefId,\n     pub name: String,\n@@ -431,7 +404,7 @@ impl Lower for data::ModData {\n             id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             filename: self.filename,\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n@@ -444,7 +417,7 @@ impl Lower for data::ModData {\n }\n \n /// Data for a reference to a module.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModRefData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -457,15 +430,15 @@ impl Lower for data::ModRefData {\n \n     fn lower(self, tcx: TyCtxt) -> ModRefData {\n         ModRefData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructData {\n     pub span: SpanData,\n     pub name: String,\n@@ -486,7 +459,7 @@ impl Lower for data::StructData {\n \n     fn lower(self, tcx: TyCtxt) -> StructData {\n         StructData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             id: make_def_id(self.id, &tcx.hir),\n             ctor_id: make_def_id(self.ctor_id, &tcx.hir),\n@@ -502,7 +475,7 @@ impl Lower for data::StructData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructVariantData {\n     pub span: SpanData,\n     pub name: String,\n@@ -522,7 +495,7 @@ impl Lower for data::StructVariantData {\n \n     fn lower(self, tcx: TyCtxt) -> StructVariantData {\n         StructVariantData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n@@ -537,7 +510,7 @@ impl Lower for data::StructVariantData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TraitData {\n     pub span: SpanData,\n     pub name: String,\n@@ -557,7 +530,7 @@ impl Lower for data::TraitData {\n \n     fn lower(self, tcx: TyCtxt) -> TraitData {\n         TraitData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n@@ -572,7 +545,7 @@ impl Lower for data::TraitData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TupleVariantData {\n     pub span: SpanData,\n     pub id: DefId,\n@@ -592,7 +565,7 @@ impl Lower for data::TupleVariantData {\n \n     fn lower(self, tcx: TyCtxt) -> TupleVariantData {\n         TupleVariantData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n@@ -608,7 +581,7 @@ impl Lower for data::TupleVariantData {\n }\n \n /// Data for a typedef.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TypeDefData {\n     pub id: DefId,\n     pub name: String,\n@@ -629,7 +602,7 @@ impl Lower for data::TypeDefData {\n         TypeDefData {\n             id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n             value: self.value,\n             visibility: self.visibility,\n@@ -642,7 +615,7 @@ impl Lower for data::TypeDefData {\n }\n \n /// Data for a reference to a type or trait.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct TypeRefData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -655,15 +628,15 @@ impl Lower for data::TypeRefData {\n \n     fn lower(self, tcx: TyCtxt) -> TypeRefData {\n         TypeRefData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseData {\n     pub id: DefId,\n     pub span: SpanData,\n@@ -679,7 +652,7 @@ impl Lower for data::UseData {\n     fn lower(self, tcx: TyCtxt) -> UseData {\n         UseData {\n             id: make_def_id(self.id, &tcx.hir),\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             mod_id: self.mod_id,\n             scope: make_def_id(self.scope, &tcx.hir),\n@@ -688,7 +661,7 @@ impl Lower for data::UseData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseGlobData {\n     pub id: DefId,\n     pub span: SpanData,\n@@ -703,7 +676,7 @@ impl Lower for data::UseGlobData {\n     fn lower(self, tcx: TyCtxt) -> UseGlobData {\n         UseGlobData {\n             id: make_def_id(self.id, &tcx.hir),\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             names: self.names,\n             scope: make_def_id(self.scope, &tcx.hir),\n             visibility: self.visibility,\n@@ -712,7 +685,7 @@ impl Lower for data::UseGlobData {\n }\n \n /// Data for local and global variables (consts and statics).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableData {\n     pub id: DefId,\n     pub name: String,\n@@ -738,7 +711,7 @@ impl Lower for data::VariableData {\n             kind: self.kind,\n             name: self.name,\n             qualname: self.qualname,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n             type_value: self.type_value,\n@@ -753,7 +726,7 @@ impl Lower for data::VariableData {\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: SpanData,\n@@ -767,14 +740,14 @@ impl Lower for data::VariableRefData {\n     fn lower(self, tcx: TyCtxt) -> VariableRefData {\n         VariableRefData {\n             name: self.name,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct Signature {\n     pub span: SpanData,\n     pub text: String,\n@@ -791,7 +764,7 @@ impl Lower for data::Signature {\n \n     fn lower(self, tcx: TyCtxt) -> Signature {\n         Signature {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             text: self.text,\n             ident_start: self.ident_start,\n             ident_end: self.ident_end,"}, {"sha": "41221ad986379b7f720875fa5ce997d95675dd8a", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 147, "deletions": 312, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -10,22 +10,22 @@\n \n use std::io::Write;\n \n-use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use external_data::*;\n-use data::{VariableKind, Visibility, SigElement};\n+use data::{VariableKind, Visibility};\n use dump::Dump;\n-use super::Format;\n+use json_dumper::id_from_def_id;\n+\n+use rls_data::{Analysis, Import, ImportKind, Def, DefKind, CratePreludeData};\n \n \n // A dumper to dump a restricted set of JSON information, designed for use with\n // libraries distributed without their source. Clients are likely to use type\n // information here, and (for example) generate Rustdoc URLs, but don't need\n // information for navigating the source of the crate.\n // Relative to the regular JSON save-analysis info, this form is filtered to\n-// remove non-visible items, but includes some extra info for items (e.g., the\n-// parent field for finding the struct to which a field belongs).\n+// remove non-visible items.\n pub struct JsonApiDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n     result: Analysis,\n@@ -48,7 +48,7 @@ impl<'b, W: Write> Drop for JsonApiDumper<'b, W> {\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            if let Some(datum) = From::from(data) {\n+            if let Some(datum) = data.into() {\n                 self.result.$bucket.push(datum);\n             }\n         }\n@@ -77,11 +77,11 @@ impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n \n     fn impl_data(&mut self, data: ImplData) {\n         if data.self_ref.is_some() {\n-            self.result.relations.push(From::from(data));\n+            self.result.relations.push(data.into());\n         }\n     }\n     fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(From::from(data));\n+        self.result.relations.push(data.into());\n     }\n }\n \n@@ -90,426 +90,261 @@ impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n // method, but not the supplied method). In both cases, we are currently\n // ignoring it.\n \n-#[derive(Debug, RustcEncodable)]\n-struct Analysis {\n-    kind: Format,\n-    prelude: Option<CratePreludeData>,\n-    imports: Vec<Import>,\n-    defs: Vec<Def>,\n-    relations: Vec<Relation>,\n-    // These two fields are dummies so that clients can parse the two kinds of\n-    // JSON data in the same way.\n-    refs: Vec<()>,\n-    macro_refs: Vec<()>,\n-}\n-\n-impl Analysis {\n-    fn new() -> Analysis {\n-        Analysis {\n-            kind: Format::JsonApi,\n-            prelude: None,\n-            imports: vec![],\n-            defs: vec![],\n-            relations: vec![],\n-            refs: vec![],\n-            macro_refs: vec![],\n-        }\n-    }\n-}\n-\n-// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n-// we use our own Id which is the same, but without the newtype.\n-#[derive(Debug, RustcEncodable)]\n-struct Id {\n-    krate: u32,\n-    index: u32,\n-}\n-\n-impl From<DefId> for Id {\n-    fn from(id: DefId) -> Id {\n-        Id {\n-            krate: id.krate.as_u32(),\n-            index: id.index.as_u32(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Import {\n-    kind: ImportKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    value: String,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum ImportKind {\n-    Use,\n-    GlobUse,\n-}\n-\n-impl From<UseData> for Option<Import> {\n-    fn from(data: UseData) -> Option<Import> {\n-        match data.visibility {\n+impl Into<Option<Import>> for UseData {\n+    fn into(self) -> Option<Import> {\n+        match self.visibility {\n             Visibility::Public => Some(Import {\n                 kind: ImportKind::Use,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n+                ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n+                span: self.span,\n+                name: self.name,\n                 value: String::new(),\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<UseGlobData> for Option<Import> {\n-    fn from(data: UseGlobData) -> Option<Import> {\n-        match data.visibility {\n+impl Into<Option<Import>> for UseGlobData {\n+    fn into(self) -> Option<Import> {\n+        match self.visibility {\n             Visibility::Public => Some(Import {\n                 kind: ImportKind::GlobUse,\n-                id: From::from(data.id),\n-                span: data.span,\n+                ref_id: None,\n+                span: self.span,\n                 name: \"*\".to_owned(),\n-                value: data.names.join(\", \"),\n+                value: self.names.join(\", \"),\n             }),\n             _ => None,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Def {\n-    kind: DefKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    qualname: String,\n-    value: String,\n-    parent: Option<Id>,\n-    children: Vec<Id>,\n-    decl_id: Option<Id>,\n-    docs: String,\n-    sig: Option<JsonSignature>,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum DefKind {\n-    // value = variant names\n-    Enum,\n-    // value = enum name + variant name + types\n-    Tuple,\n-    // value = [enum name +] name + fields\n-    Struct,\n-    // value = signature\n-    Trait,\n-    // value = type + generics\n-    Function,\n-    // value = type + generics\n-    Method,\n-    // No id, no value.\n-    Macro,\n-    // value = file_name\n-    Mod,\n-    // value = aliased type\n-    Type,\n-    // value = type and init expression (for all variable kinds).\n-    Static,\n-    Const,\n-    Field,\n-}\n-\n-impl From<EnumData> for Option<Def> {\n-    fn from(data: EnumData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for EnumData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Enum,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 parent: None,\n-                children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+                children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n \n-impl From<TupleVariantData> for Option<Def> {\n-    fn from(data: TupleVariantData) -> Option<Def> {\n+impl Into<Option<Def>> for TupleVariantData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Tuple,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            parent: data.parent.map(|id| From::from(id)),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: self.parent.map(|id| id_from_def_id(id)),\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<StructVariantData> for Option<Def> {\n-    fn from(data: StructVariantData) -> Option<Def> {\n+impl Into<Option<Def>> for StructVariantData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            parent: data.parent.map(|id| From::from(id)),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: self.parent.map(|id| id_from_def_id(id)),\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<StructData> for Option<Def> {\n-    fn from(data: StructData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for StructData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n             parent: None,\n-            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         }),\n             _ => None,\n         }\n     }\n }\n-impl From<TraitData> for Option<Def> {\n-    fn from(data: TraitData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for TraitData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Trait,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n-                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n+                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 parent: None,\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<FunctionData> for Option<Def> {\n-    fn from(data: FunctionData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for FunctionData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Function,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<MethodData> for Option<Def> {\n-    fn from(data: MethodData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for MethodData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Method,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n-                decl_id: data.decl_id.map(|id| From::from(id)),\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n+                decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<MacroData> for Option<Def> {\n-    fn from(data: MacroData) -> Option<Def> {\n+impl Into<Option<Def>> for MacroData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Macro,\n-            id: From::from(null_def_id()),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n+            id: id_from_def_id(null_def_id()),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n             value: String::new(),\n             children: vec![],\n             parent: None,\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<ModData> for Option<Def> {\n-    fn from(data:ModData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for ModData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Mod,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.filename,\n-                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.filename,\n+                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 parent: None,\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<TypeDefData> for Option<Def> {\n-    fn from(data: TypeDefData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for TypeDefData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Type,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n                 docs: String::new(),\n-                sig: data.sig.map(|s| From::from(s)),\n+                sig: self.sig.map(|s| s.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n \n-impl From<VariableData> for Option<Def> {\n-    fn from(data: VariableData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for VariableData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n-                kind: match data.kind {\n+                kind: match self.kind {\n                     VariableKind::Static => DefKind::Static,\n                     VariableKind::Const => DefKind::Const,\n                     VariableKind::Local => { return None }\n                     VariableKind::Field => DefKind::Field,\n                 },\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: data.sig.map(|s| From::from(s)),\n+                docs: self.docs,\n+                sig: self.sig.map(|s| s.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Relation {\n-    span: SpanData,\n-    kind: RelationKind,\n-    from: Id,\n-    to: Id,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum RelationKind {\n-    Impl,\n-    SuperTrait,\n-}\n-\n-impl From<ImplData> for Relation {\n-    fn from(data: ImplData) -> Relation {\n-        Relation {\n-            span: data.span,\n-            kind: RelationKind::Impl,\n-            from: From::from(data.self_ref.unwrap_or(null_def_id())),\n-            to: From::from(data.trait_ref.unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-\n-impl From<InheritanceData> for Relation {\n-    fn from(data: InheritanceData) -> Relation {\n-        Relation {\n-            span: data.span,\n-            kind: RelationKind::SuperTrait,\n-            from: From::from(data.base_id),\n-            to: From::from(data.deriv_id),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSignature {\n-    span: SpanData,\n-    text: String,\n-    ident_start: usize,\n-    ident_end: usize,\n-    defs: Vec<JsonSigElement>,\n-    refs: Vec<JsonSigElement>,\n-}\n-\n-impl From<Signature> for JsonSignature {\n-    fn from(data: Signature) -> JsonSignature {\n-        JsonSignature {\n-            span: data.span,\n-            text: data.text,\n-            ident_start: data.ident_start,\n-            ident_end: data.ident_end,\n-            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n-            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSigElement {\n-    id: Id,\n-    start: usize,\n-    end: usize,\n-}\n-\n-impl From<SigElement> for JsonSigElement {\n-    fn from(data: SigElement) -> JsonSigElement {\n-        JsonSigElement {\n-            id: From::from(data.id),\n-            start: data.start,\n-            end: data.end,\n-        }\n-    }\n-}"}, {"sha": "acc877d3947758fb20a222e51c2f6a896fe5c3e4", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 203, "deletions": 332, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -13,10 +13,14 @@ use std::io::Write;\n use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n+use rls_data::{self, Id, Analysis, Import, ImportKind, Def, DefKind, Ref, RefKind, MacroRef,\n+               Relation, RelationKind, Signature, SigElement, CratePreludeData};\n+use rls_span::{Column, Row};\n+\n+use external_data;\n use external_data::*;\n-use data::{VariableKind, SigElement};\n+use data::{self, VariableKind};\n use dump::Dump;\n-use super::Format;\n \n pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n@@ -40,7 +44,7 @@ impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            self.result.$bucket.push(From::from(data));\n+            self.result.$bucket.push(data.into());\n         }\n     }\n }\n@@ -75,21 +79,22 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n     impl_fn!(macro_use, MacroUseData, macro_refs);\n \n     fn mod_data(&mut self, data: ModData) {\n-        let id: Id = From::from(data.id);\n+        let id: Id = id_from_def_id(data.id);\n         let mut def = Def {\n             kind: DefKind::Mod,\n             id: id,\n-            span: data.span,\n+            span: data.span.into(),\n             name: data.name,\n             qualname: data.qualname,\n             value: data.filename,\n-            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            parent: None,\n+            children: data.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            sig: Some(data.sig.into()),\n+            attributes: data.attributes.into_iter().map(|a| a.into()).collect(),\n         };\n-        if def.span.file_name != def.value {\n+        if def.span.file_name.to_str().unwrap() != def.value {\n             // If the module is an out-of-line defintion, then we'll make the\n             // defintion the first character in the module's file and turn the\n             // the declaration into a reference to it.\n@@ -99,14 +104,14 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n                 ref_id: id,\n             };\n             self.result.refs.push(rf);\n-            def.span = SpanData {\n-                file_name: def.value.clone(),\n+            def.span = rls_data::SpanData {\n+                file_name: def.value.clone().into(),\n                 byte_start: 0,\n                 byte_end: 0,\n-                line_start: 1,\n-                line_end: 1,\n-                column_start: 1,\n-                column_end: 1,\n+                line_start: Row::new_one_indexed(1),\n+                line_end: Row::new_one_indexed(1),\n+                column_start: Column::new_one_indexed(1),\n+                column_end: Column::new_one_indexed(1),\n             }\n         }\n \n@@ -115,11 +120,11 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n \n     fn impl_data(&mut self, data: ImplData) {\n         if data.self_ref.is_some() {\n-            self.result.relations.push(From::from(data));\n+            self.result.relations.push(data.into());\n         }\n     }\n     fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(From::from(data));\n+        self.result.relations.push(data.into());\n     }\n }\n \n@@ -129,476 +134,342 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n // method, but not the supplied method). In both cases, we are currently\n // ignoring it.\n \n-#[derive(Debug, RustcEncodable)]\n-struct Analysis {\n-    kind: Format,\n-    prelude: Option<CratePreludeData>,\n-    imports: Vec<Import>,\n-    defs: Vec<Def>,\n-    refs: Vec<Ref>,\n-    macro_refs: Vec<MacroRef>,\n-    relations: Vec<Relation>,\n-}\n-\n-impl Analysis {\n-    fn new() -> Analysis {\n-        Analysis {\n-            kind: Format::Json,\n-            prelude: None,\n-            imports: vec![],\n-            defs: vec![],\n-            refs: vec![],\n-            macro_refs: vec![],\n-            relations: vec![],\n-        }\n-    }\n-}\n-\n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n // we use our own Id which is the same, but without the newtype.\n-#[derive(Clone, Copy, Debug, RustcEncodable)]\n-struct Id {\n-    krate: u32,\n-    index: u32,\n-}\n-\n-impl From<DefId> for Id {\n-    fn from(id: DefId) -> Id {\n-        Id {\n-            krate: id.krate.as_u32(),\n-            index: id.index.as_u32(),\n-        }\n+pub fn id_from_def_id(id: DefId) -> Id {\n+    Id {\n+        krate: id.krate.as_u32(),\n+        index: id.index.as_u32(),\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Import {\n-    kind: ImportKind,\n-    ref_id: Option<Id>,\n-    span: SpanData,\n-    name: String,\n-    value: String,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum ImportKind {\n-    ExternCrate,\n-    Use,\n-    GlobUse,\n-}\n-\n-impl From<ExternCrateData> for Import {\n-    fn from(data: ExternCrateData) -> Import {\n+impl Into<Import> for ExternCrateData {\n+    fn into(self) -> Import {\n         Import {\n             kind: ImportKind::ExternCrate,\n             ref_id: None,\n-            span: data.span,\n-            name: data.name,\n+            span: self.span,\n+            name: self.name,\n             value: String::new(),\n         }\n     }\n }\n-impl From<UseData> for Import {\n-    fn from(data: UseData) -> Import {\n+impl Into<Import> for UseData {\n+    fn into(self) -> Import {\n         Import {\n             kind: ImportKind::Use,\n-            ref_id: data.mod_id.map(|id| From::from(id)),\n-            span: data.span,\n-            name: data.name,\n+            ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n+            span: self.span,\n+            name: self.name,\n             value: String::new(),\n         }\n     }\n }\n-impl From<UseGlobData> for Import {\n-    fn from(data: UseGlobData) -> Import {\n+impl Into<Import> for UseGlobData {\n+    fn into(self) -> Import {\n         Import {\n             kind: ImportKind::GlobUse,\n             ref_id: None,\n-            span: data.span,\n+            span: self.span,\n             name: \"*\".to_owned(),\n-            value: data.names.join(\", \"),\n+            value: self.names.join(\", \"),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Def {\n-    kind: DefKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    qualname: String,\n-    value: String,\n-    children: Vec<Id>,\n-    decl_id: Option<Id>,\n-    docs: String,\n-    sig: Option<JsonSignature>,\n-    attributes: Vec<Attribute>,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum DefKind {\n-    // value = variant names\n-    Enum,\n-    // value = enum name + variant name + types\n-    Tuple,\n-    // value = [enum name +] name + fields\n-    Struct,\n-    // value = signature\n-    Trait,\n-    // value = type + generics\n-    Function,\n-    // value = type + generics\n-    Method,\n-    // No id, no value.\n-    Macro,\n-    // value = file_name\n-    Mod,\n-    // value = aliased type\n-    Type,\n-    // value = type and init expression (for all variable kinds).\n-    Local,\n-    Static,\n-    Const,\n-    Field,\n-}\n-\n-impl From<EnumData> for Def {\n-    fn from(data: EnumData) -> Def {\n+impl Into<Def> for EnumData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Enum,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n+            children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n \n-impl From<TupleVariantData> for Def {\n-    fn from(data: TupleVariantData) -> Def {\n+impl Into<Def> for TupleVariantData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Tuple,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<StructVariantData> for Def {\n-    fn from(data: StructVariantData) -> Def {\n+impl Into<Def> for StructVariantData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<StructData> for Def {\n-    fn from(data: StructData) -> Def {\n+impl Into<Def> for StructData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n+            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<TraitData> for Def {\n-    fn from(data: TraitData) -> Def {\n+impl Into<Def> for TraitData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Trait,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n+            children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<FunctionData> for Def {\n-    fn from(data: FunctionData) -> Def {\n+impl Into<Def> for FunctionData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Function,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<MethodData> for Def {\n-    fn from(data: MethodData) -> Def {\n+impl Into<Def> for MethodData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Method,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n-            decl_id: data.decl_id.map(|id| From::from(id)),\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<MacroData> for Def {\n-    fn from(data: MacroData) -> Def {\n+impl Into<Def> for MacroData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Macro,\n-            id: From::from(null_def_id()),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n+            id: id_from_def_id(null_def_id()),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n             value: String::new(),\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n             attributes: vec![],\n         }\n     }\n }\n-impl From<TypeDefData> for Def {\n-    fn from(data: TypeDefData) -> Def {\n+impl Into<Def> for TypeDefData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Type,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n             docs: String::new(),\n-            sig: data.sig.map(|s| From::from(s)),\n-            attributes: data.attributes,\n+            sig: self.sig.map(|s| s.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<VariableData> for Def {\n-    fn from(data: VariableData) -> Def {\n+impl Into<Def> for VariableData {\n+    fn into(self) -> Def {\n         Def {\n-            kind: match data.kind {\n+            kind: match self.kind {\n                 VariableKind::Static => DefKind::Static,\n                 VariableKind::Const => DefKind::Const,\n                 VariableKind::Local => DefKind::Local,\n                 VariableKind::Field => DefKind::Field,\n             },\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.type_value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.type_value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n-            attributes: data.attributes,\n+            attributes: self.attributes,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-enum RefKind {\n-    Function,\n-    Mod,\n-    Type,\n-    Variable,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Ref {\n-    kind: RefKind,\n-    span: SpanData,\n-    ref_id: Id,\n-}\n-\n-impl From<FunctionRefData> for Ref {\n-    fn from(data: FunctionRefData) -> Ref {\n+impl Into<Ref> for FunctionRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Function,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id),\n         }\n     }\n }\n-impl From<FunctionCallData> for Ref {\n-    fn from(data: FunctionCallData) -> Ref {\n+impl Into<Ref> for FunctionCallData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Function,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id),\n         }\n     }\n }\n-impl From<MethodCallData> for Ref {\n-    fn from(data: MethodCallData) -> Ref {\n+impl Into<Ref> for MethodCallData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Function,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id.or(data.decl_id).unwrap_or(null_def_id())),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id.or(self.decl_id).unwrap_or(null_def_id())),\n         }\n     }\n }\n-impl From<ModRefData> for Ref {\n-    fn from(data: ModRefData) -> Ref {\n+impl Into<Ref> for ModRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Mod,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id.unwrap_or(null_def_id())),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id.unwrap_or(null_def_id())),\n         }\n     }\n }\n-impl From<TypeRefData> for Ref {\n-    fn from(data: TypeRefData) -> Ref {\n+impl Into<Ref> for TypeRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Type,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id.unwrap_or(null_def_id())),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id.unwrap_or(null_def_id())),\n         }\n     }\n }\n-impl From<VariableRefData> for Ref {\n-    fn from(data: VariableRefData) -> Ref {\n+impl Into<Ref> for VariableRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Variable,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct MacroRef {\n-    span: SpanData,\n-    qualname: String,\n-    callee_span: SpanData,\n-}\n-\n-impl From<MacroUseData> for MacroRef {\n-    fn from(data: MacroUseData) -> MacroRef {\n+impl Into<MacroRef> for MacroUseData {\n+    fn into(self) -> MacroRef {\n         MacroRef {\n-            span: data.span,\n-            qualname: data.qualname,\n-            callee_span: data.callee_span,\n+            span: self.span,\n+            qualname: self.qualname,\n+            callee_span: self.callee_span.into(),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Relation {\n-    span: SpanData,\n-    kind: RelationKind,\n-    from: Id,\n-    to: Id,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum RelationKind {\n-    Impl,\n-    SuperTrait,\n-}\n-\n-impl From<ImplData> for Relation {\n-    fn from(data: ImplData) -> Relation {\n+impl Into<Relation> for ImplData {\n+    fn into(self) -> Relation {\n         Relation {\n-            span: data.span,\n+            span: self.span,\n             kind: RelationKind::Impl,\n-            from: From::from(data.self_ref.unwrap_or(null_def_id())),\n-            to: From::from(data.trait_ref.unwrap_or(null_def_id())),\n+            from: id_from_def_id(self.self_ref.unwrap_or(null_def_id())),\n+            to: id_from_def_id(self.trait_ref.unwrap_or(null_def_id())),\n         }\n     }\n }\n \n-impl From<InheritanceData> for Relation {\n-    fn from(data: InheritanceData) -> Relation {\n+impl Into<Relation> for InheritanceData {\n+    fn into(self) -> Relation {\n         Relation {\n-            span: data.span,\n+            span: self.span,\n             kind: RelationKind::SuperTrait,\n-            from: From::from(data.base_id),\n-            to: From::from(data.deriv_id),\n+            from: id_from_def_id(self.base_id),\n+            to: id_from_def_id(self.deriv_id),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSignature {\n-    span: SpanData,\n-    text: String,\n-    ident_start: usize,\n-    ident_end: usize,\n-    defs: Vec<JsonSigElement>,\n-    refs: Vec<JsonSigElement>,\n-}\n-\n-impl From<Signature> for JsonSignature {\n-    fn from(data: Signature) -> JsonSignature {\n-        JsonSignature {\n-            span: data.span,\n-            text: data.text,\n-            ident_start: data.ident_start,\n-            ident_end: data.ident_end,\n-            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n-            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n+impl Into<Signature> for external_data::Signature {\n+    fn into(self) -> Signature {\n+        Signature {\n+            span: self.span,\n+            text: self.text,\n+            ident_start: self.ident_start,\n+            ident_end: self.ident_end,\n+            defs: self.defs.into_iter().map(|s| s.into()).collect(),\n+            refs: self.refs.into_iter().map(|s| s.into()).collect(),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSigElement {\n-    id: Id,\n-    start: usize,\n-    end: usize,\n-}\n-\n-impl From<SigElement> for JsonSigElement {\n-    fn from(data: SigElement) -> JsonSigElement {\n-        JsonSigElement {\n-            id: From::from(data.id),\n-            start: data.start,\n-            end: data.end,\n+impl Into<SigElement> for data::SigElement {\n+    fn into(self) -> SigElement {\n+        SigElement {\n+            id: id_from_def_id(self.id),\n+            start: self.start,\n+            end: self.end,\n         }\n     }\n }"}, {"sha": "5e2b1df9d34f89451f28737760f2f4648dc487bc", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dedf9d3593632faea7ccb2f78bd6517ce56bb06d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=dedf9d3593632faea7ccb2f78bd6517ce56bb06d", "patch": "@@ -26,9 +26,12 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-extern crate serialize as rustc_serialize;\n+extern crate rustc_serialize;\n extern crate syntax_pos;\n \n+extern crate rls_data;\n+extern crate rls_span;\n+\n \n mod csv_dumper;\n mod json_api_dumper;"}]}