{"sha": "92612c9de159889f77f05855a77482ee1d895f51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNjEyYzlkZTE1OTg4OWY3N2YwNTg1NWE3NzQ4MmVlMWQ4OTVmNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-18T16:21:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-18T16:21:56Z"}, "message": "Auto merge of #3893 - mati865:rustup, r=oli-obk\n\nRustup\n\nSupersedes https://github.com/rust-lang/rust-clippy/pull/3889\n\nAddresses some review comments from previous PR and rustups to https://github.com/rust-lang/rust/pull/58899", "tree": {"sha": "30468b13265981d464570a127e8474e6065f0fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30468b13265981d464570a127e8474e6065f0fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92612c9de159889f77f05855a77482ee1d895f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92612c9de159889f77f05855a77482ee1d895f51", "html_url": "https://github.com/rust-lang/rust/commit/92612c9de159889f77f05855a77482ee1d895f51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92612c9de159889f77f05855a77482ee1d895f51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54e20519d2e3e2de72f6a58e521f405763bae4a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/54e20519d2e3e2de72f6a58e521f405763bae4a6", "html_url": "https://github.com/rust-lang/rust/commit/54e20519d2e3e2de72f6a58e521f405763bae4a6"}, {"sha": "6cb06056000dcf38cb6c50f7da1dd622c312a1d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb06056000dcf38cb6c50f7da1dd622c312a1d7", "html_url": "https://github.com/rust-lang/rust/commit/6cb06056000dcf38cb6c50f7da1dd622c312a1d7"}], "stats": {"total": 385, "additions": 233, "deletions": 152}, "files": [{"sha": "b4e4d46a33a6f9ab9bed59e6cd8e8a246b9e8ef6", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 83, "deletions": 77, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use semver::Version;\n-use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use syntax::source_map::Span;\n \n declare_clippy_lint! {\n@@ -208,22 +208,24 @@ impl LintPass for AttrPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n-            match &*attr.name().as_str() {\n-                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                    check_clippy_lint_names(cx, items);\n-                },\n-                _ => {},\n-            }\n-            if items.is_empty() || attr.name() != \"deprecated\" {\n-                return;\n-            }\n-            for item in items {\n-                if_chain! {\n-                    if let NestedMetaItemKind::MetaItem(mi) = &item.node;\n-                    if let MetaItemKind::NameValue(lit) = &mi.node;\n-                    if mi.name() == \"since\";\n-                    then {\n-                        check_semver(cx, item.span, lit);\n+            if let Some(ident) = attr.ident_str() {\n+                match ident {\n+                    \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                        check_clippy_lint_names(cx, items);\n+                    },\n+                    _ => {},\n+                }\n+                if items.is_empty() || !attr.check_name(\"deprecated\") {\n+                    return;\n+                }\n+                for item in items {\n+                    if_chain! {\n+                        if let NestedMetaItem::MetaItem(mi) = &item;\n+                        if let MetaItemKind::NameValue(lit) = &mi.node;\n+                        if mi.check_name(\"since\");\n+                        then {\n+                            check_semver(cx, item.span(), lit);\n+                        }\n                     }\n                 }\n             }\n@@ -236,55 +238,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n         }\n         match item.node {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.name() == \"macro_use\");\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(\"macro_use\"));\n \n                 for attr in &item.attrs {\n                     if let Some(lint_list) = &attr.meta_item_list() {\n-                        match &*attr.name().as_str() {\n-                            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                // whitelist `unused_imports` and `deprecated` for `use` items\n-                                // and `unused_imports` for `extern crate` items with `macro_use`\n-                                for lint in lint_list {\n-                                    match item.node {\n-                                        ItemKind::Use(..) => {\n-                                            if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                                return;\n-                                            }\n-                                        },\n-                                        ItemKind::ExternCrate(..) => {\n-                                            if is_word(lint, \"unused_imports\") && skip_unused_imports {\n-                                                return;\n-                                            }\n-                                            if is_word(lint, \"unused_extern_crates\") {\n-                                                return;\n-                                            }\n-                                        },\n-                                        _ => {},\n-                                    }\n-                                }\n-                                let line_span = last_line_of_span(cx, attr.span);\n-\n-                                if let Some(mut sugg) = snippet_opt(cx, line_span) {\n-                                    if sugg.contains(\"#[\") {\n-                                        span_lint_and_then(\n-                                            cx,\n-                                            USELESS_ATTRIBUTE,\n-                                            line_span,\n-                                            \"useless lint attribute\",\n-                                            |db| {\n-                                                sugg = sugg.replacen(\"#[\", \"#![\", 1);\n-                                                db.span_suggestion(\n-                                                    line_span,\n-                                                    \"if you just forgot a `!`, use\",\n-                                                    sugg,\n-                                                    Applicability::MachineApplicable,\n-                                                );\n+                        if let Some(ident) = attr.ident_str() {\n+                            match ident {\n+                                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                                    // whitelist `unused_imports` and `deprecated` for `use` items\n+                                    // and `unused_imports` for `extern crate` items with `macro_use`\n+                                    for lint in lint_list {\n+                                        match item.node {\n+                                            ItemKind::Use(..) => {\n+                                                if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n+                                                    return;\n+                                                }\n+                                            },\n+                                            ItemKind::ExternCrate(..) => {\n+                                                if is_word(lint, \"unused_imports\") && skip_unused_imports {\n+                                                    return;\n+                                                }\n+                                                if is_word(lint, \"unused_extern_crates\") {\n+                                                    return;\n+                                                }\n                                             },\n-                                        );\n+                                            _ => {},\n+                                        }\n                                     }\n-                                }\n-                            },\n-                            _ => {},\n+                                    let line_span = last_line_of_span(cx, attr.span);\n+\n+                                    if let Some(mut sugg) = snippet_opt(cx, line_span) {\n+                                        if sugg.contains(\"#[\") {\n+                                            span_lint_and_then(\n+                                                cx,\n+                                                USELESS_ATTRIBUTE,\n+                                                line_span,\n+                                                \"useless lint attribute\",\n+                                                |db| {\n+                                                    sugg = sugg.replacen(\"#[\", \"#![\", 1);\n+                                                    db.span_suggestion(\n+                                                        line_span,\n+                                                        \"if you just forgot a `!`, use\",\n+                                                        sugg,\n+                                                        Applicability::MachineApplicable,\n+                                                    );\n+                                                },\n+                                            );\n+                                        }\n+                                    }\n+                                },\n+                                _ => {},\n+                            }\n                         }\n                     }\n                 }\n@@ -311,10 +315,11 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n     let lint_store = cx.lints();\n     for lint in items {\n         if_chain! {\n-            if let Some(word) = lint.word();\n-            if let Some(tool_name) = word.is_scoped();\n+            if let Some(meta_item) = lint.meta_item();\n+            if meta_item.path.segments.len() > 1;\n+            if let tool_name = meta_item.path.segments[0].ident;\n             if tool_name.as_str() == \"clippy\";\n-            let name = word.name();\n+            let name = meta_item.path.segments.last().unwrap().ident.name;\n             if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(\n                 &name.as_str(),\n                 Some(tool_name.as_str()),\n@@ -323,7 +328,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n                 span_lint_and_then(\n                     cx,\n                     UNKNOWN_CLIPPY_LINTS,\n-                    lint.span,\n+                    lint.span(),\n                     &format!(\"unknown clippy lint: clippy::{}\", name),\n                     |db| {\n                         if name.as_str().chars().any(char::is_uppercase) {\n@@ -337,7 +342,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n                                 CheckLintNameResult::NoLint(None) => (),\n                                 _ => {\n                                     db.span_suggestion(\n-                                        lint.span,\n+                                        lint.span(),\n                                         \"lowercase the lint name\",\n                                         name_lower,\n                                         Applicability::MaybeIncorrect,\n@@ -352,22 +357,22 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n     }\n }\n \n-fn is_relevant_item(tcx: TyCtxt<'_, '_, '_>, item: &Item) -> bool {\n+fn is_relevant_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &Item) -> bool {\n     if let ItemKind::Fn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl(tcx: TyCtxt<'_, '_, '_>, item: &ImplItem) -> bool {\n+fn is_relevant_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n+fn is_relevant_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -377,7 +382,7 @@ fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n+fn is_relevant_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match &stmt.node {\n             StmtKind::Local(_) => true,\n@@ -389,7 +394,7 @@ fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, blo\n     }\n }\n \n-fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n+fn is_relevant_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n     match &expr.node {\n         ExprKind::Block(block, _) => is_relevant_block(tcx, tables, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(tcx, tables, e),\n@@ -443,7 +448,7 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n         }\n \n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || attr.name() != \"inline\" {\n+            if values.len() != 1 || !attr.check_name(\"inline\") {\n                 continue;\n             }\n             if is_word(&values[0], \"always\") {\n@@ -476,8 +481,8 @@ fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n }\n \n fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n-    if let NestedMetaItemKind::MetaItem(mi) = &nmi.node {\n-        mi.is_word() && mi.name() == expected\n+    if let NestedMetaItem::MetaItem(mi) = &nmi {\n+        mi.is_word() && mi.check_name(expected)\n     } else {\n         false\n     }\n@@ -514,15 +519,16 @@ impl EarlyLintPass for CfgAttrPass {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n         if_chain! {\n             // check cfg_attr\n-            if attr.name() == \"cfg_attr\";\n+            if attr.check_name(\"cfg_attr\");\n             if let Some(items) = attr.meta_item_list();\n             if items.len() == 2;\n             // check for `rustfmt`\n             if let Some(feature_item) = items[0].meta_item();\n-            if feature_item.name() == \"rustfmt\";\n+            if feature_item.check_name(\"rustfmt\");\n             // check for `rustfmt_skip` and `rustfmt::skip`\n             if let Some(skip_item) = &items[1].meta_item();\n-            if skip_item.name() == \"rustfmt_skip\" || skip_item.name() == \"skip\";\n+            if skip_item.check_name(\"rustfmt_skip\") ||\n+                skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == \"skip\";\n             // Only lint outer attributes, because custom inner attributes are unstable\n             // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n             if let AttrStyle::Outer = attr.style;"}, {"sha": "61bfc78b3de8e6f63b55e46f3ce4d24c6c7c6f25", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -117,7 +117,7 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: ty::Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n@@ -268,7 +268,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     #[allow(clippy::cast_possible_wrap)]\n-    fn constant_not(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n+    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Bool(b) => Some(Bool(!b)),\n@@ -284,7 +284,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_negate(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n+    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Int(value) => {"}, {"sha": "413645a091ffc82f046a1aef35bde653b1f4169e", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -152,7 +152,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>,\n                 spans.extend_from_slice(&current_spans);\n                 doc.push_str(&current);\n             }\n-        } else if attr.name() == \"doc\" {\n+        } else if attr.check_name(\"doc\") {\n             // ignore mix of sugared and non-sugared doc\n             return;\n         }"}, {"sha": "425f1e67147725966b0777b4eac80df95bf32525", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -1,7 +1,7 @@\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n@@ -129,54 +129,54 @@ fn get_ufcs_type_name(\n     method_def_id: def_id::DefId,\n     self_arg: &Expr,\n ) -> std::option::Option<String> {\n-    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0].sty;\n-    let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id).sty;\n+    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n+    let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, actual_type_of_self) {\n-            return Some(cx.tcx.item_path_str(trait_id));\n+        if match_borrow_depth(expected_type_of_self, &actual_type_of_self) {\n+            return Some(cx.tcx.def_path_str(trait_id));\n         }\n     }\n \n     cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n         //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, actual_type_of_self) {\n+        if match_types(expected_type_of_self, &actual_type_of_self) {\n             return Some(get_type_name(cx, &actual_type_of_self));\n         }\n         None\n     })\n }\n \n-fn match_borrow_depth(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n-    match (lhs, rhs) {\n-        (ty::Ref(_, t1, _), ty::Ref(_, t2, _)) => match_borrow_depth(&t1.sty, &t2.sty),\n+fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n+    match (&lhs.sty, &rhs.sty) {\n+        (ty::Ref(_, t1, _), ty::Ref(_, t2, _)) => match_borrow_depth(&t1, &t2),\n         (l, r) => match (l, r) {\n             (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n             (_, _) => true,\n         },\n     }\n }\n \n-fn match_types(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n-    match (lhs, rhs) {\n+fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n+    match (&lhs.sty, &rhs.sty) {\n         (ty::Bool, ty::Bool)\n         | (ty::Char, ty::Char)\n         | (ty::Int(_), ty::Int(_))\n         | (ty::Uint(_), ty::Uint(_))\n         | (ty::Str, ty::Str) => true,\n         (ty::Ref(_, t1, _), ty::Ref(_, t2, _))\n         | (ty::Array(t1, _), ty::Array(t2, _))\n-        | (ty::Slice(t1), ty::Slice(t2)) => match_types(&t1.sty, &t2.sty),\n+        | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n         (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n         (_, _) => false,\n     }\n }\n \n-fn get_type_name(cx: &LateContext<'_, '_>, kind: &ty::TyKind<'_>) -> String {\n-    match kind {\n-        ty::Adt(t, _) => cx.tcx.item_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, &r.sty),\n-        _ => kind.to_string(),\n+fn get_type_name(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> String {\n+    match ty.sty {\n+        ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n+        ty::Ref(_, r, _) => get_type_name(cx, &r),\n+        _ => ty.to_string(),\n     }\n }\n "}, {"sha": "bed5964fb32f11171c30afb4a92e14d3162999d9", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -3,7 +3,7 @@ use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use syntax_pos::Span;\n \n@@ -132,7 +132,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type(tcx: ty::TyCtxt<'_, '_, '_>, ty: ty::Ty<'_>, path: &[&str]) -> bool {\n+fn match_type<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(tcx, adt.did, path),\n         _ => false,"}, {"sha": "3e13d0073fe8b631bf99fed3dcec8d433ff2154d", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if attr.name() != \"inline\" {\n+        if !attr.check_name(\"inline\") {\n             continue;\n         }\n "}, {"sha": "bf98aa7e2b580b1e1fdb6ac1b8d13744600ac8b2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -1,10 +1,10 @@\n // error-pattern:cargo-clippy\n \n #![feature(box_syntax)]\n+#![feature(never_type)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n-#![feature(range_contains)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![recursion_limit = \"256\"]\n #![warn(rust_2018_idioms, trivial_casts, trivial_numeric_casts)]"}, {"sha": "22c336b8c47829e90121691655aaa017a43fe634", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -3,7 +3,7 @@ use crate::utils::{in_macro, iter_input_pats, match_type, method_chain_args, sni\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n@@ -87,7 +87,7 @@ impl LintPass for Pass {\n     }\n }\n \n-fn is_unit_type(ty: ty::Ty<'_>) -> bool {\n+fn is_unit_type(ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::Tuple(slice) => slice.is_empty(),\n         ty::Never => true,"}, {"sha": "74a85f1f8174f4644c25c1508e43841b41334194", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -539,7 +539,7 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n                     String::new()\n                 };\n                 // This path assumes that the enum type is imported into scope.\n-                format!(\"{}{}{}\", ident_str, cx.tcx.item_path_str(v.did), suffix)\n+                format!(\"{}{}{}\", ident_str, cx.tcx.def_path_str(v.did), suffix)\n             })\n             .collect();\n "}, {"sha": "3e7403a3fe28491ef62b67779c7f4258e0dcd65b", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -2196,7 +2196,7 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n \n fn ty_has_iter_method(\n     cx: &LateContext<'_, '_>,\n-    self_ref_ty: ty::Ty<'_>,\n+    self_ref_ty: Ty<'_>,\n ) -> Option<(&'static Lint, &'static str, &'static str)> {\n     if let Some(ty_name) = has_iter_method(cx, self_ref_ty) {\n         let lint = match ty_name {\n@@ -2217,7 +2217,7 @@ fn ty_has_iter_method(\n     }\n }\n \n-fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::Ty<'_>, method_span: Span) {\n+fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_>, method_span: Span) {\n     if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n         return;\n     }"}, {"sha": "ed984f16db5c893b8b5664706035bd1c325de271", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -58,7 +58,7 @@ impl MissingDoc {\n             if let Some(meta) = meta;\n             if let MetaItemKind::List(list) = meta.node;\n             if let Some(meta) = list.get(0);\n-            if let Some(name) = meta.name();\n+            if let Some(name) = meta.ident_str();\n             then {\n                 name == \"include\"\n             } else {\n@@ -91,7 +91,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.name() == \"doc\" && (a.is_value_str() || Self::has_include(a.meta())));\n+            .any(|a| a.check_name(\"doc\") && (a.is_value_str() || Self::has_include(a.meta())));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "d6711900093eab3b374833681a87d1b3757d5e29", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -59,7 +59,7 @@ declare_clippy_lint! {\n pub struct MissingInline;\n \n fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs.iter().any(|a| a.name() == \"inline\");\n+    let has_inline = attrs.iter().any(|a| a.check_name(\"inline\"));\n     if !has_inline {\n         span_lint(\n             cx,"}, {"sha": "2300456d4c381778310dc09a436ae698a13f8b80", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -324,7 +324,7 @@ fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n         [\"proc_macro\", \"proc_macro_attribute\", \"proc_macro_derive\"]\n             .iter()\n-            .any(|&allow| attr.name() == allow)\n+            .any(|&allow| attr.check_name(allow))\n     })\n }\n "}, {"sha": "8b7b6b6c42c639a21c274ea200bf596604d3e81a", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n use rustc::ty::adjustment::Adjust;\n-use rustc::ty::{self, TypeFlags};\n+use rustc::ty::{Ty, TypeFlags};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_typeck::hir_ty_to_ty;\n@@ -108,7 +108,7 @@ impl Source {\n     }\n }\n \n-fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, source: Source) {\n+fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, source: Source) {\n     if ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP) || is_copy(cx, ty) {\n         // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n         // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`"}, {"sha": "086c76c20b6340e456f1a59a9e9b7a890b33fe9a", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{\n     visit::{MutatingUseContext, PlaceContext, Visitor},\n     TerminatorKind,\n };\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::convert::TryFrom;\n@@ -225,7 +225,7 @@ fn is_call_with_ref_arg<'tcx>(\n     cx: &LateContext<'_, 'tcx>,\n     mir: &'tcx mir::Mir<'tcx>,\n     kind: &'tcx mir::TerminatorKind<'tcx>,\n-) -> Option<(def_id::DefId, mir::Local, ty::Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n+) -> Option<(def_id::DefId, mir::Local, Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n     if_chain! {\n         if let TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;"}, {"sha": "3995d9f2819c225a54ee839b346240deda6688f6", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -263,7 +263,7 @@ impl EarlyLintPass for ReturnPass {\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.name() == \"cfg\"\n+    attr.meta_item_list().is_some() && attr.check_name(\"cfg\")\n }\n \n // get the def site"}, {"sha": "e4eb1bb0b7406bd739f8b6c9b0fdac5a7b6531a5", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -347,7 +347,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     |db| {\n                                         let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n                                         let arg = if let ty::Int(_) = from_ty.sty {\n-                                            arg.as_ty(ty::Uint(ast::UintTy::U32))\n+                                            arg.as_ty(ast::UintTy::U32)\n                                         } else {\n                                             arg\n                                         };"}, {"sha": "e0f19a146541e5fb545ea8e0fffda1cf72968a1b", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n                     return;\n                 }\n                 for a in attrs {\n-                    if a.meta_item_list().is_some() && a.name() == \"proc_macro_derive\" {\n+                    if a.meta_item_list().is_some() && a.check_name(\"proc_macro_derive\") {\n                         return;\n                     }\n                 }"}, {"sha": "2e50222c8a9f6e3f7b053b2da46064c00d05fb75", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -10,6 +10,7 @@ use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisito\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty::layout::LayoutOf;\n+use rustc::ty::print::Printer;\n use rustc::ty::{self, InferTy, Ty, TyCtxt, TypeckTables};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n@@ -24,7 +25,7 @@ use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n     match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n-    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathBuffer,\n+    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathPrinter,\n };\n \n /// Handles all the linting of funky types\n@@ -1135,15 +1136,14 @@ impl LintPass for CastPass {\n \n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>) -> bool {\n+fn is_c_void<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'_>) -> bool {\n     if let ty::Adt(adt, _) = ty.sty {\n-        let mut apb = AbsolutePathBuffer { names: vec![] };\n-        tcx.push_item_path(&mut apb, adt.did, false);\n+        let names = AbsolutePathPrinter { tcx }.print_def_path(adt.did, &[]).unwrap();\n \n-        if apb.names.is_empty() {\n+        if names.is_empty() {\n             return false;\n         }\n-        if apb.names[0] == \"libc\" || apb.names[0] == \"core\" && *apb.names.last().unwrap() == \"c_void\" {\n+        if names[0] == \"libc\" || names[0] == \"core\" && *names.last().unwrap() == \"c_void\" {\n             return true;\n         }\n     }"}, {"sha": "ac901ab062f326404a9f72f21b6affdceea03346", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Vi\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n+use rustc::ty::DefIdTree;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax_pos::symbol::keywords::SelfUpper;\n@@ -233,7 +234,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n             if self.item_path.def == path.def {\n                 span_use_self_lint(self.cx, path);\n             } else if let Def::StructCtor(ctor_did, CtorKind::Fn) = path.def {\n-                if self.item_path.def.opt_def_id() == self.cx.tcx.parent_def_id(ctor_did) {\n+                if self.item_path.def.opt_def_id() == self.cx.tcx.parent(ctor_did) {\n                     span_use_self_lint(self.cx, path);\n                 }\n             }"}, {"sha": "2c96d9a8b5aa58fc9e6986516268e752070bf4e6", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -11,11 +11,9 @@ use syntax::{ast, source_map};\n use toml;\n \n /// Gets the configuration file from arguments.\n-pub fn file_from_args(\n-    args: &[source_map::Spanned<ast::NestedMetaItemKind>],\n-) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n-    for arg in args.iter().filter_map(syntax::source_map::Spanned::meta_item) {\n-        if arg.name() == \"conf_file\" {\n+pub fn file_from_args(args: &[ast::NestedMetaItem]) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n+    for arg in args.iter().filter_map(syntax::ast::NestedMetaItem::meta_item) {\n+        if arg.check_name(\"conf_file\") {\n             return match arg.node {\n                 ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n                     Err((\"`conf_file` must be a named value\", arg.span))"}, {"sha": "2cf638b939ccc5bc77cc8a913f15dcc690ff3987", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 98, "deletions": 22, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92612c9de159889f77f05855a77482ee1d895f51/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=92612c9de159889f77f05855a77482ee1d895f51", "patch": "@@ -24,8 +24,10 @@ use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n use rustc::hir::def::Def;\n+use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc::hir::map::DisambiguatedDefPathData;\n use rustc::hir::Node;\n use rustc::hir::*;\n use rustc::lint::{LateContext, Level, Lint, LintContext};\n@@ -41,8 +43,7 @@ use rustc_errors::Applicability;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::source_map::{Span, DUMMY_SP};\n-use syntax::symbol;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, LocalInternedString, Symbol};\n \n use crate::reexport::*;\n \n@@ -97,19 +98,96 @@ pub fn in_macro(span: Span) -> bool {\n /// Used to store the absolute path to a type.\n ///\n /// See `match_def_path` for usage.\n-#[derive(Debug)]\n-pub struct AbsolutePathBuffer {\n-    pub names: Vec<symbol::LocalInternedString>,\n+pub struct AbsolutePathPrinter<'a, 'tcx> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n-    fn root_mode(&self) -> &ty::item_path::RootMode {\n-        const ABSOLUTE: &ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n-        ABSOLUTE\n+use rustc::ty::print::Printer;\n+\n+#[allow(clippy::diverging_sub_expression)]\n+impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+    type Error = !;\n+\n+    type Path = Vec<LocalInternedString>;\n+    type Region = ();\n+    type Type = ();\n+    type DynExistential = ();\n+\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n     }\n \n-    fn push(&mut self, text: &str) {\n-        self.names.push(symbol::Symbol::intern(text).as_str());\n+    fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn print_dyn_existential(\n+        self,\n+        _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n+        Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n+    }\n+\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        if trait_ref.is_none() {\n+            if let ty::Adt(def, substs) = self_ty.sty {\n+                return self.print_def_path(def.did, substs);\n+            }\n+        }\n+\n+        // This shouldn't ever be needed, but just in case:\n+        Ok(vec![match trait_ref {\n+            Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n+            None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n+        }])\n+    }\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let mut path = print_prefix(self)?;\n+\n+        // This shouldn't ever be needed, but just in case:\n+        path.push(match trait_ref {\n+            Some(trait_ref) => Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str(),\n+            None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n+        });\n+\n+        Ok(path)\n+    }\n+\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let mut path = print_prefix(self)?;\n+        path.push(disambiguated_data.data.as_interned_str().as_str());\n+        Ok(path)\n+    }\n+\n+    fn path_generic_args(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        print_prefix(self)\n     }\n }\n \n@@ -121,12 +199,10 @@ impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) -> bool {\n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n-\n-    tcx.push_item_path(&mut apb, def_id, false);\n+pub fn match_def_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, path: &[&str]) -> bool {\n+    let names = get_def_path(tcx, def_id);\n \n-    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n+    names.len() == path.len() && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n /// Gets the absolute path of `def_id` as a vector of `&str`.\n@@ -138,12 +214,12 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n ///     // The given `def_id` is that of an `Option` type\n /// };\n /// ```\n-pub fn get_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Vec<&'static str> {\n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n-    tcx.push_item_path(&mut apb, def_id, false);\n-    apb.names\n+pub fn get_def_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Vec<&'static str> {\n+    AbsolutePathPrinter { tcx }\n+        .print_def_path(def_id, &[])\n+        .unwrap()\n         .iter()\n-        .map(syntax_pos::symbol::LocalInternedString::get)\n+        .map(LocalInternedString::get)\n         .collect()\n }\n \n@@ -1010,7 +1086,7 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: HirId)\n }\n \n /// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: ty::Ty<'_>) -> Option<&'static str> {\n+pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method."}]}