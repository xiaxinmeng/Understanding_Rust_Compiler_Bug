{"sha": "fedb775fbb127a5099f46078c85046440479b0ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZGI3NzVmYmIxMjdhNTA5OWY0NjA3OGM4NTA0NjQ0MDQ3OWIwZWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-22T15:12:23Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-22T15:12:23Z"}, "message": "Add hacks to extract and compile tutorial code\n\nNot included in the build by default, since it's fragile and kludgy. Do\nsomething like this to run it:\n\n    cd doc/tutorial\n    RUSTC=../../build/stage2/bin/rustc bash test.sh\n\nCloses #1143", "tree": {"sha": "05f37967a75ab41a7a076ace9b36e79ffb26c6b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05f37967a75ab41a7a076ace9b36e79ffb26c6b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fedb775fbb127a5099f46078c85046440479b0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fedb775fbb127a5099f46078c85046440479b0ef", "html_url": "https://github.com/rust-lang/rust/commit/fedb775fbb127a5099f46078c85046440479b0ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fedb775fbb127a5099f46078c85046440479b0ef/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b8b0b8584a57ff60247cece73e273f94a245928", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8b0b8584a57ff60247cece73e273f94a245928", "html_url": "https://github.com/rust-lang/rust/commit/1b8b0b8584a57ff60247cece73e273f94a245928"}], "stats": {"total": 143, "additions": 119, "deletions": 24}, "files": [{"sha": "1797f5a23f592d9ecdff58bb6294f671285b45f9", "filename": "doc/tutorial/args.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fargs.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fargs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fargs.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -22,6 +22,8 @@ other tasks, and that most data is immutable.\n \n Take the following program:\n \n+    # fn get_really_big_record() -> int { 1 }\n+    # fn myfunc(a: int) {}\n     let x = get_really_big_record();\n     myfunc(x);\n \n@@ -32,6 +34,9 @@ existing value as the argument, without copying.\n \n There are more involved cases. The call could look like this:\n \n+    # fn myfunc(a: int, b: block()) {}\n+    # fn get_another_record() -> int { 1 }\n+    # let x = 1;\n     myfunc(x, {|| x = get_another_record(); });\n \n Now, if `myfunc` first calls its second argument and then accesses its"}, {"sha": "fb5f297c81e3b5a49879ce8d28793423252b6b2a", "filename": "doc/tutorial/build.js", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fbuild.js", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fbuild.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fbuild.js?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -4,7 +4,15 @@ require(\"./lib/codemirror-rust\");\n \n md.Markdown.dialects.Maruku.block.code = function code(block, next) {\n   if (block.match(/^    /)) {\n-    var text = block.replace(/(^|\\n)    /g, \"$1\"), accum = [], curstr = \"\", curstyle = null;\n+    var text = String(block);\n+    while (next.length && next[0].match(/^    /)) text += \"\\n\" + String(next.shift());\n+    var leaveAlone, accum = [], curstr = \"\", curstyle = null;\n+    text = text.split(\"\\n\").map(function(line) {\n+      line = line.slice(4);\n+      if (line == \"## notrust\") leaveAlone = true;\n+      return line;\n+    }).filter(function(x) { return !/^##? /.test(x); }).join(\"\\n\");\n+    if (leaveAlone) return [[\"pre\", {}, text]];\n     function add(str, style) {\n       if (style != curstyle) {\n         if (curstyle) accum.push([\"span\", {\"class\": \"cm-\" + curstyle}, curstr]);"}, {"sha": "966aeb2df523c91456c25ea8e9916c865a8c3141", "filename": "doc/tutorial/control.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fcontrol.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fcontrol.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fcontrol.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -38,6 +38,7 @@ Rust's `alt` construct is a generalized, cleaned-up version of C's\n each labelled with a pattern, and it will execute the arm that matches\n the value.\n \n+    # let my_number = 1;\n     alt my_number {\n       0       { std::io::println(\"zero\"); }\n       1 | 2   { std::io::println(\"one or two\"); }\n@@ -89,6 +90,7 @@ To a limited extent, it is possible to use destructuring patterns when\n declaring a variable with `let`. For example, you can say this to\n extract the fields from a tuple:\n \n+    # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n     let (a, b) = get_tuple_of_two_ints();\n \n This will introduce two new variables, `a` and `b`, bound to the\n@@ -118,6 +120,8 @@ it finds one that can be divided by five.\n There's also `while`'s ugly cousin, `do`/`while`, which does not check\n its condition on the first iteration, using traditional syntax:\n \n+    # fn eat_cake() {}\n+    # fn any_cake_left() -> bool { false }\n     do {\n         eat_cake();\n     } while any_cake_left();"}, {"sha": "661fb2f0c6dd71514933e9162ba590e13c641d03", "filename": "doc/tutorial/data.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fdata.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -56,6 +56,7 @@ Records can be destructured on in `alt` patterns. The basic syntax is\n omitted as a shorthand for simply binding the variable with the same\n name as the field.\n \n+    # let mypoint = {x: 0f, y: 0f};\n     alt mypoint {\n         {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n         {x, y}             { /* Simply bind the fields */ }\n@@ -71,6 +72,7 @@ the fields of a record, a record pattern may end with `, _` (as in\n Tags [FIXME terminology] are datatypes that have several different\n representations. For example, the type shown earlier:\n \n+    # type point = {x: float, y: float};\n     tag shape {\n         circle(point, float);\n         rectangle(point, point);\n@@ -96,7 +98,7 @@ equivalent to an `enum` in C:\n         east;\n         south;\n         west;\n-    };\n+    }\n \n This will define `north`, `east`, `south`, and `west` as constants,\n all of which have type `direction`.\n@@ -116,6 +118,7 @@ That is a shorthand for this:\n Tag types like this can have their content extracted with the\n dereference (`*`) unary operator:\n \n+    # tag gizmo_id = int;\n     let my_gizmo_id = gizmo_id(10);\n     let id_int: int = *my_gizmo_id;\n \n@@ -125,6 +128,8 @@ For tag types with multiple variants, destructuring is the only way to\n get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n \n+    # type point = {x: float, y: float};\n+    # tag shape { circle(point, float); rectangle(point, point); }\n     fn area(sh: shape) -> float {\n         alt sh {\n             circle(_, size) { std::math::pi * size * size }\n@@ -136,6 +141,8 @@ For variants without arguments, you have to write `variantname.` (with\n a dot at the end) to match them in a pattern. This to prevent\n ambiguity between matching a variant name and binding a new variable.\n \n+    # type point = {x: float, y: float};\n+    # tag direction { north; east; south; west; }\n     fn point_from_direction(dir: direction) -> point {\n         alt dir {\n             north. { {x:  0f, y:  1f} }\n@@ -295,6 +302,7 @@ strings. They are always immutable.\n \n Resources are data types that have a destructor associated with them.\n \n+    # fn close_file_desc(x: int) {}\n     resource file_desc(fd: int) {\n         close_file_desc(fd);\n     }"}, {"sha": "e84619675455e396cfbe5b77d26ca4076165c01f", "filename": "doc/tutorial/extract.js", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fextract.js", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fextract.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fextract.js?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -0,0 +1,42 @@\n+var fs = require(\"fs\"), md = require(\"./lib/markdown\");\n+\n+// Runs markdown.js over the tutorial, to find the code blocks in it.\n+// Uses the #-markers in those code blocks, along with some vague\n+// heuristics, to turn them into compilable files. Outputs these files\n+// to fragments/.\n+//\n+// '##ignore' means don't test this block\n+// '##notrust' means the block isn't rust code\n+//     (used by build.js to not highlight it)\n+// '# code' means insert the given code to complete the fragment\n+//     (build.js strips out such lines)\n+\n+var curFile, curFrag;\n+md.Markdown.dialects.Maruku.block.code = function code(block, next) {\n+  if (block.match(/^    /)) {\n+    var ignore, text = String(block);\n+    while (next.length && next[0].match(/^    /)) text += \"\\n\" + String(next.shift());\n+    text = text.split(\"\\n\").map(function(line) {\n+      line = line.slice(4);\n+      if (line == \"## ignore\" || line == \"## notrust\") { ignore = true; line = \"\"; }\n+      if (/^# /.test(line)) line = line.slice(2);\n+      return line;\n+    }).join(\"\\n\");\n+    if (ignore) return;\n+    if (!/\\bfn main\\b/.test(text)) {\n+      if (/(^|\\n) *(native|use|mod|import|export)\\b/.test(text))\n+        text += \"\\nfn main() {}\\n\";\n+      else text = \"fn main() {\\n\" + text + \"\\n}\\n\";\n+    }\n+    if (!/\\buse std\\b/.test(text)) text = \"use std;\\n\" + text;\n+    fs.writeFileSync(\"fragments/\" + curFile + \"_\" + (++curFrag) + \".rs\", text);\n+  }\n+};\n+\n+fs.readFileSync(\"order\", \"utf8\").split(\"\\n\").filter(id).forEach(handle);\n+\n+function id(x) { return x; }\n+function handle(file) {\n+  curFile = file; curFrag = 0;\n+  md.parse(fs.readFileSync(file + \".md\", \"utf8\"), \"Maruku\");\n+}"}, {"sha": "7b90f64a6ba563ba3dac087a8ad7ebff71511dc3", "filename": "doc/tutorial/ffi.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fffi.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -67,6 +67,7 @@ most notably the Windows API, use other calling conventions, so Rust\n provides a way to to hint to the compiler which is expected by using\n the `\"abi\"` attribute:\n \n+    #[cfg(target_os = \"win32\")]\n     #[abi = \"stdcall\"]\n     native mod kernel32 {\n         fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n@@ -81,7 +82,9 @@ or `\"stdcall\"`. Other conventions may be defined in the future.\n The native `SHA1` function is declared to take three arguments, and\n return a pointer.\n \n+    # native mod crypto {\n     fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+    # }\n \n When declaring the argument types to a foreign function, the Rust\n compiler has no way to check whether your declaration is correct, so\n@@ -106,6 +109,9 @@ null pointers.\n \n The `sha1` function is the most obscure part of the program.\n \n+    # import std::{str, vec};\n+    # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n+    # fn as_hex(data: [u8]) -> str { \"hi\" }\n     fn sha1(data: str) -> str unsafe {\n         let bytes = str::bytes(data);\n         let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n@@ -141,10 +147,15 @@ Rust's safety mechanisms.\n \n Let's look at our `sha1` function again.\n \n+    # import std::{str, vec};\n+    # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n+    # fn as_hex(data: [u8]) -> str { \"hi\" }\n+    # fn x(data: str) -> str unsafe {\n     let bytes = str::bytes(data);\n     let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n                             vec::len(bytes), std::ptr::null());\n     ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+    # }\n \n The `str::bytes` function is perfectly safe, it converts a string to\n an `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which"}, {"sha": "15811da04b313487742772d7cc5bbe6963b84ca3", "filename": "doc/tutorial/func.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Ffunc.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Ffunc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ffunc.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -19,6 +19,10 @@ This helps the compiler avoid spurious error messages. For example,\n the following code would be a type error if `dead_end` would be\n expected to return.\n \n+    # fn can_go_left() -> bool { true }\n+    # fn can_go_right() -> bool { true }\n+    # tag dir { left; right; }\n+    # fn dead_end() -> ! { fail; }\n     let dir = if can_go_left() { left }\n               else if can_go_right() { right }\n               else { dead_end(); };\n@@ -96,12 +100,14 @@ of integers backwards:\n \n To run such an iteration, you could do this:\n \n+    # fn for_rev(v: [int], act: block(int)) {}\n     for_rev([1, 2, 3], {|n| log n; });\n \n But Rust allows a more pleasant syntax for this situation, with the\n loop block moved out of the parenthesis and the final semicolon\n omitted:\n \n+    # fn for_rev(v: [int], act: block(int)) {}\n     for_rev([1, 2, 3]) {|n|\n         log n;\n     }"}, {"sha": "02d37fd0e9b4eb5fa01617cf2b16d2627386c13c", "filename": "doc/tutorial/generic.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fgeneric.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fgeneric.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fgeneric.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -55,16 +55,17 @@ dereferences become impossible.\n Rust's type inferrer works very well with generics, but there are\n programs that just can't be typed.\n \n-    let n = none;\n+    let n = std::option::none;\n+    # n = std::option::some(1);\n \n If you never do anything else with `n`, the compiler will not be able\n to assign a type to it. (The same goes for `[]`, in fact.) If you\n really want to have such a statement, you'll have to write it like\n this:\n \n-    let n2: option::t<int> = none;\n+    let n2: std::option::t<int> = std::option::none;\n     // or\n-    let n = none::<int>;\n+    let n = std::option::none::<int>;\n \n Note that, in a value expression, `<` already has a meaning as a\n comparison operator, so you'll have to write `::<T>` to explicitly\n@@ -120,6 +121,7 @@ take sendable types.\n \n If you try this program:\n \n+    # fn map(f: block(int) -> int, v: [int]) {}\n     fn plus1(x: int) -> int { x + 1 }\n     map(plus1, [1, 2, 3]);\n \n@@ -131,6 +133,7 @@ way to pass integers, which is by value. To get around this issue, you\n have to explicitly mark the arguments to a function that you want to\n pass to a generic higher-order function as being passed by pointer:\n \n+    # fn map<T, U>(f: block(T) -> U, v: [T]) {}\n     fn plus1(&&x: int) -> int { x + 1 }\n     map(plus1, [1, 2, 3]);\n "}, {"sha": "86151a9b9d5c60e39f3a9c4f48e0c1c13a6c2d4a", "filename": "doc/tutorial/mod.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fmod.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fmod.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fmod.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -35,6 +35,7 @@ It is also possible to include multiple files in a crate. For this\n purpose, you create a `.rc` crate file, which references any number of\n `.rs` code files. A crate file could look like this:\n \n+    ## ignore\n     #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n     mod cow;\n     mod chicken;\n@@ -52,6 +53,7 @@ in a moment.\n To have a nested directory structure for your source files, you can\n nest mods in your `.rc` file:\n \n+    ## ignore\n     mod poultry {\n         mod chicken;\n         mod turkey;\n@@ -79,6 +81,7 @@ OS X.\n It is possible to provide more specific information when using an\n external crate.\n \n+    ## ignore\n     use myfarm (name = \"farm\", vers = \"2.7\");\n \n When a comma-separated list of name/value pairs is given after `use`,\n@@ -90,6 +93,7 @@ local name `myfarm`.\n \n Our example crate declared this set of `link` attributes:\n \n+    ## ignore\n     #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n \n The version does not match the one provided in the `use` directive, so\n@@ -105,12 +109,14 @@ these two files:\n     #[link(name = \"mylib\", vers = \"1.0\")];\n     fn world() -> str { \"world\" }\n \n+    ## ignore\n     // main.rs\n     use mylib;\n     fn main() { log_err \"hello \" + mylib::world(); }\n \n Now compile and run like this (adjust to your platform if necessary):\n \n+    ## notrust\n     > rustc --lib mylib.rs\n     > rustc main.rs -L .\n     > ./main\n@@ -147,8 +153,8 @@ restricted with `export` directives at the top of the module or file.\n     mod enc {\n         export encrypt, decrypt;\n         const super_secret_number: int = 10;\n-        fn encrypt(n: int) { n + super_secret_number }\n-        fn decrypt(n: int) { n - super_secret_number }\n+        fn encrypt(n: int) -> int { n + super_secret_number }\n+        fn decrypt(n: int) -> int { n - super_secret_number }\n     }\n \n This defines a rock-solid encryption algorithm. Code outside of the"}, {"sha": "1ec77b5630e863ebed91e9cebfa9ef7e9542c6a9", "filename": "doc/tutorial/setup.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fsetup.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fsetup.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsetup.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -21,6 +21,7 @@ If you modify the program to make it invalid (for example, remove the\n `use std` line), and then compile it, you'll see an error message like\n this:\n \n+    ## notrust\n     hello.rs:2:4: 2:20 error: unresolved modulename: std\n     hello.rs:2     std::io::println(\"hello world!\");\n                    ^~~~~~~~~~~~~~~~"}, {"sha": "d7be8df79dc487d7ec200a6ff40a73f233e0520a", "filename": "doc/tutorial/syntax.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -21,6 +21,7 @@ statements and expressions is C-like. Function calls are written\n precedence that they have in C, comments look the same, and constructs\n like `if` and `while` are available:\n \n+    # fn call_a_function(_a: int) {}\n     fn main() {\n         if 1 < 2 {\n             while false { call_a_function(10 * 4); }\n@@ -39,10 +40,13 @@ of languages. A lot of thing that are statements in C are expressions\n in Rust. This allows for useless things like this (which passes\n nil\u2014the void type\u2014to a function):\n \n+    # fn a_function(_a: ()) {}\n     a_function(while false {});\n \n But also useful things like this:\n \n+    # fn the_stars_align() -> bool { false }\n+    # fn something_else() -> bool { true }\n     let x = if the_stars_align() { 4 }\n             else if something_else() { 3 }\n             else { 0 };\n@@ -125,6 +129,7 @@ annotation:\n \n     // The type of this vector will be inferred based on its use.\n     let x = [];\n+    # x = [3];\n     // Explicitly say this is a vector of integers.\n     let y: [int] = [];\n \n@@ -272,6 +277,7 @@ The comparison operators are the traditional `==`, `!=`, `<`, `>`,\n \n Rust has a ternary conditional operator `?:`, as in:\n \n+    let badness = 12;\n     let message = badness < 10 ? \"error\" : \"FATAL ERROR\";\n \n For type casting, Rust uses the binary `as` operator, which has a\n@@ -311,19 +317,14 @@ followed by a comma-separated list of nested attributes, as in the\n `cfg` example above, or in this [crate](mod.html) metadata\n declaration:\n \n+    ## ignore\n     #[link(name = \"std\",\n            vers = \"0.1\",\n            url = \"http://rust-lang.org/src/std\")];\n \n An attribute without a semicolon following it applies to the\n definition that follows it. When terminated with a semicolon, it\n-applies to the current context. The above example could also be\n-written like this:\n-\n-    fn register_win_service() {\n-        #[cfg(target_os = \"win32\")];\n-        /* ... */\n-    }\n+applies to the module or crate.\n \n ## Syntax extensions\n "}, {"sha": "b60250217e8f2c3f9fa6dfb953b355215da566e1", "filename": "doc/tutorial/test.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Ftest.md", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Ftest.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftest.md?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -21,6 +21,7 @@ When you compile the program normally, the `test_twice` function will\n not be used. To actually run the tests, compile with the `--test`\n flag:\n \n+    ## notrust\n     > rustc --lib twice.rs\n     > ./twice\n     running 1 tests\n@@ -30,6 +31,7 @@ flag:\n Or, if we change the file to fail, for example by replacing `x + x`\n with `x + 1`:\n \n+    ## notrust\n     running 1 tests\n     test test_twice ... FAILED\n     failures:"}, {"sha": "9cdb1aa9f8e899e0ee6111ba94a2b58a190bb148", "filename": "doc/tutorial/test.sh", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/doc%2Ftutorial%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftest.sh?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -0,0 +1,8 @@\n+#!/bin/bash\n+rm -f fragments/*.rs\n+mkdir -p fragments\n+node extract.js\n+for F in `ls fragments/*.rs`; do\n+  $RUSTC $F > /dev/null\n+  if [[ $? != 0 ]] ; then echo $F; fi\n+done"}, {"sha": "e33572d4575fb14e7a56a5854d47863b1266a0e3", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fedb775fbb127a5099f46078c85046440479b0ef/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fedb775fbb127a5099f46078c85046440479b0ef/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=fedb775fbb127a5099f46078c85046440479b0ef", "patch": "@@ -2485,22 +2485,12 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n               _ { none }\n             };\n         alt p.peek() {\n-\n-\n-\n-\n-\n           // mod x = \"foo.rs\";\n           token::SEMI. {\n             let hi = p.get_hi_pos();\n             p.bump();\n             ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt, outer_attrs));\n           }\n-\n-\n-\n-\n-\n           // mod x = \"foo_dir\" { ...directives... }\n           token::LBRACE. {\n             p.bump();"}]}