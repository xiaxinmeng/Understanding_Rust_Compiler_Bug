{"sha": "a4196cd490deba9f5d885f6c9f335c05f1048c24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTk2Y2Q0OTBkZWJhOWY1ZDg4NWY2YzlmMzM1YzA1ZjEwNDhjMjQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-09T23:19:53Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-14T04:56:21Z"}, "message": "resolve: Use `vis: ty::Visibility` instead of `is_public: bool`", "tree": {"sha": "d5cc3f487fa5d65306418e88ae3cf27cd3e4aa95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5cc3f487fa5d65306418e88ae3cf27cd3e4aa95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4196cd490deba9f5d885f6c9f335c05f1048c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4196cd490deba9f5d885f6c9f335c05f1048c24", "html_url": "https://github.com/rust-lang/rust/commit/a4196cd490deba9f5d885f6c9f335c05f1048c24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4196cd490deba9f5d885f6c9f335c05f1048c24/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf9fc0c2a532c32704dd710c8dd40cf9c296205", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf9fc0c2a532c32704dd710c8dd40cf9c296205", "html_url": "https://github.com/rust-lang/rust/commit/3bf9fc0c2a532c32704dd710c8dd40cf9c296205"}], "stats": {"total": 232, "additions": 127, "deletions": 105}, "files": [{"sha": "842bf20672a2219586d650815978b239f56c2414", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 52, "deletions": 63, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a4196cd490deba9f5d885f6c9f335c05f1048c24/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4196cd490deba9f5d885f6c9f335c05f1048c24/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a4196cd490deba9f5d885f6c9f335c05f1048c24", "patch": "@@ -53,10 +53,10 @@ impl<'a> ToNameBinding<'a> for (Module<'a>, Span) {\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers) {\n+impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n         let kind = NameBindingKind::Def(self.0);\n-        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1) }\n+        NameBinding { modifiers: self.2, kind: kind, span: Some(self.1), vis: self.3 }\n     }\n }\n \n@@ -105,12 +105,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         let parent = *parent_ref;\n         let name = item.name;\n         let sp = item.span;\n-        let is_public = item.vis == hir::Public;\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n+        let modifiers = DefModifiers::IMPORTABLE;\n+        self.current_module = parent;\n+        let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n             ItemUse(ref view_path) => {\n@@ -172,7 +169,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                                     subclass,\n                                                     view_path.span,\n                                                     item.id,\n-                                                    is_public,\n+                                                    vis,\n                                                     is_prelude);\n                     }\n                     ViewPathList(_, ref source_items) => {\n@@ -223,7 +220,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                                         subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n-                                                        is_public,\n+                                                        vis,\n                                                         is_prelude);\n                         }\n                     }\n@@ -233,7 +230,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                                     GlobImport,\n                                                     view_path.span,\n                                                     item.id,\n-                                                    is_public,\n+                                                    vis,\n                                                     is_prelude);\n                     }\n                 }\n@@ -249,7 +246,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                     };\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let module = self.new_extern_crate_module(parent_link, def, is_public, item.id);\n+                    let module = self.new_extern_crate_module(parent_link, def, vis, item.id);\n                     self.define(parent, name, TypeNS, (module, sp));\n \n                     self.build_reduced_graph_for_external_crate(module);\n@@ -259,7 +256,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemMod(..) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n                 parent.module_children.borrow_mut().insert(item.id, module);\n                 *parent_ref = module;\n@@ -271,33 +268,32 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStatic(_, m, _) => {\n                 let mutbl = m == hir::MutMutable;\n                 let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n             }\n             ItemConst(_, _) => {\n                 let def = Def::Const(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let def = Def::Fn(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n             }\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers));\n+                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.ast_map.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module, sp));\n \n-                let variant_modifiers = if is_public {\n-                    DefModifiers::empty()\n-                } else {\n-                    DefModifiers::PRIVATE_VARIANT\n+                let variant_modifiers = match vis {\n+                    ty::Visibility::Public => DefModifiers::empty(),\n+                    _ => DefModifiers::PRIVATE_VARIANT,\n                 };\n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n@@ -310,20 +306,20 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             ItemStruct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.ast_map.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, modifiers));\n+                self.define(parent, name, TypeNS, (def, sp, modifiers, vis));\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if !struct_def.is_struct() {\n                     let def = Def::Struct(self.ast_map.local_def_id(struct_def.id()));\n-                    self.define(parent, name, ValueNS, (def, sp, modifiers));\n+                    self.define(parent, name, ValueNS, (def, sp, modifiers, vis));\n                 }\n \n                 // Record the def ID and fields of this struct.\n-                let field_names = struct_def.fields()\n-                                            .iter()\n-                                            .map(|f| f.name)\n-                                            .collect();\n+                let field_names = struct_def.fields().iter().map(|field| {\n+                    self.resolve_visibility(&field.vis);\n+                    field.name\n+                }).collect();\n                 let item_def_id = self.ast_map.local_def_id(item.id);\n                 self.structs.insert(item_def_id, field_names);\n             }\n@@ -336,7 +332,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Trait(def_id);\n-                let module_parent = self.new_module(parent_link, Some(def), false, is_public);\n+                let module_parent = self.new_module(parent_link, Some(def), false, vis);\n                 self.define(parent, name, TypeNS, (module_parent, sp));\n \n                 // Add the names of all the items to the trait info.\n@@ -348,8 +344,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         hir::TypeTraitItem(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n                     };\n \n-                    let modifiers = DefModifiers::PUBLIC; // NB: not DefModifiers::IMPORTABLE\n-                    self.define(module_parent, item.name, ns, (def, item.span, modifiers));\n+                    let modifiers = DefModifiers::empty(); // NB: not DefModifiers::IMPORTABLE\n+                    self.define(module_parent, item.name, ns, (def, item.span, modifiers, vis));\n \n                     self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }\n@@ -373,24 +369,20 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers;\n+        let modifiers = DefModifiers::IMPORTABLE | variant_modifiers;\n         let def = Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id()));\n+        let vis = ty::Visibility::Public;\n \n-        self.define(parent, name, ValueNS, (def, variant.span, modifiers));\n-        self.define(parent, name, TypeNS, (def, variant.span, modifiers));\n+        self.define(parent, name, ValueNS, (def, variant.span, modifiers, vis));\n+        self.define(parent, name, TypeNS, (def, variant.span, modifiers, vis));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: Module<'b>) {\n         let name = foreign_item.name;\n-        let is_public = foreign_item.vis == hir::Public;\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n+        let modifiers = DefModifiers::IMPORTABLE;\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n@@ -400,7 +392,9 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 Def::Static(self.ast_map.local_def_id(foreign_item.id), m)\n             }\n         };\n-        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers));\n+        self.current_module = parent;\n+        let vis = self.resolve_visibility(&foreign_item.vis);\n+        self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers, vis));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &mut Module<'b>) {\n@@ -412,7 +406,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                    block_id);\n \n             let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, false, false);\n+            let new_module = self.new_module(parent_link, None, false, parent.vis);\n             parent.module_children.borrow_mut().insert(block_id, new_module);\n             *parent = new_module;\n         }\n@@ -434,32 +428,27 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n \n         let name = xcdef.name;\n-        let is_public = xcdef.vis == ty::Visibility::Public || parent.is_trait();\n-\n-        let mut modifiers = DefModifiers::empty();\n-        if is_public {\n-            modifiers = modifiers | DefModifiers::PUBLIC;\n-        }\n-        if parent.is_normal() {\n-            modifiers = modifiers | DefModifiers::IMPORTABLE;\n-        }\n+        let vis = if parent.is_trait() { ty::Visibility::Public } else { xcdef.vis };\n+        let modifiers = match parent.is_normal() {\n+            true => DefModifiers::IMPORTABLE,\n+            false => DefModifiers::empty(),\n+        };\n \n         match def {\n             Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n-                debug!(\"(building reduced graph for external crate) building module {} {}\",\n-                       name,\n-                       is_public);\n+                debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n+                       name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true, is_public);\n+                let module = self.new_module(parent_link, Some(def), true, vis);\n                 self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n             }\n             Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n-                let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                let modifiers = DefModifiers::IMPORTABLE;\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -472,7 +461,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        name);\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n@@ -493,21 +482,21 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 }\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), true, is_public);\n+                let module = self.new_module(parent_link, Some(def), true, vis);\n                 self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers, vis));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers, vis));\n                 }\n \n                 // Record the def ID and fields of this struct."}, {"sha": "c1d2b0c4b4341b25623ec5c4eb099b394cf4147f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a4196cd490deba9f5d885f6c9f335c05f1048c24/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4196cd490deba9f5d885f6c9f335c05f1048c24/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a4196cd490deba9f5d885f6c9f335c05f1048c24", "patch": "@@ -55,6 +55,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::pat_bindings;\n+use rustc::ty;\n use rustc::ty::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::hir::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n@@ -820,7 +821,7 @@ enum ParentLink<'a> {\n pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Option<Def>,\n-    is_public: bool,\n+    vis: ty::Visibility,\n \n     // If the module is an extern crate, `def` is root of the external crate and `extern_crate_id`\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n@@ -864,12 +865,12 @@ impl<'a> ModuleS<'a> {\n     fn new(parent_link: ParentLink<'a>,\n            def: Option<Def>,\n            external: bool,\n-           is_public: bool,\n+           vis: ty::Visibility,\n            arenas: &'a ResolverArenas<'a>) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n-            is_public: is_public,\n+            vis: vis,\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n@@ -892,9 +893,10 @@ impl<'a> ModuleS<'a> {\n         self.def.as_ref().map(Def::def_id)\n     }\n \n+    // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n         match self.def {\n-            Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n+            Some(Def::Mod(_)) => true,\n             _ => false,\n         }\n     }\n@@ -918,23 +920,13 @@ impl<'a> ModuleS<'a> {\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f,\n-               \"{:?}, {}\",\n-               self.def,\n-               if self.is_public {\n-                   \"public\"\n-               } else {\n-                   \"private\"\n-               })\n+        write!(f, \"{:?}, {:?}\", self.def, self.vis)\n     }\n }\n \n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n-        // Enum variants are always considered `PUBLIC`, this is needed for `use Enum::Variant`\n-        // or `use Enum::*` to work on private enums.\n-        const PUBLIC     = 1 << 0,\n         const IMPORTABLE = 1 << 1,\n         // Variants are considered `PUBLIC`, but some of them live in private enums.\n         // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n@@ -949,6 +941,9 @@ pub struct NameBinding<'a> {\n     modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n+    // Enum variants are always considered `PUBLIC`, this is needed for `use Enum::Variant`\n+    // or `use Enum::*` to work on private enums.\n+    vis: ty::Visibility,\n }\n \n #[derive(Clone, Debug)]\n@@ -968,13 +963,12 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n \n impl<'a> NameBinding<'a> {\n     fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n-        let modifiers = if module.is_public {\n-            DefModifiers::PUBLIC\n-        } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n-\n-        NameBinding { modifiers: modifiers, kind: NameBindingKind::Module(module), span: span }\n+        NameBinding {\n+            modifiers: DefModifiers::IMPORTABLE,\n+            kind: NameBindingKind::Module(module),\n+            span: span,\n+            vis: module.vis,\n+        }\n     }\n \n     fn module(&self) -> Option<Module<'a>> {\n@@ -998,7 +992,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn is_public(&self) -> bool {\n-        self.defined_with(DefModifiers::PUBLIC)\n+        self.vis == ty::Visibility::Public\n     }\n \n     fn is_extern_crate(&self) -> bool {\n@@ -1148,8 +1142,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n+        let vis = ty::Visibility::Public;\n         let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true, arenas);\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, vis, arenas);\n         let graph_root = arenas.alloc_module(graph_root);\n \n         Resolver {\n@@ -1209,17 +1204,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                   parent_link: ParentLink<'a>,\n                   def: Option<Def>,\n                   external: bool,\n-                  is_public: bool) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, is_public, self.arenas))\n+                  vis: ty::Visibility) -> Module<'a> {\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, vis, self.arenas))\n     }\n \n     fn new_extern_crate_module(&self,\n                                parent_link: ParentLink<'a>,\n                                def: Def,\n-                               is_public: bool,\n+                               vis: ty::Visibility,\n                                local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, is_public, self.arenas);\n+        let mut module = ModuleS::new(parent_link, Some(def), false, vis, self.arenas);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1617,7 +1612,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_crate(&mut self, krate: &hir::Crate) {\n         debug!(\"(resolving crate) starting\");\n-\n+        self.current_module = self.graph_root;\n         intravisit::walk_crate(self, krate);\n     }\n \n@@ -1980,6 +1975,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 this.with_self_rib(Def::SelfTy(trait_id, Some((item_id, self_type.id))), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n+                            this.resolve_visibility(&impl_item.vis);\n                             match impl_item.node {\n                                 hir::ImplItemKind::Const(..) => {\n                                     // If this is a trait impl, ensure the const\n@@ -3379,6 +3375,43 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n+    fn resolve_visibility(&mut self, vis: &hir::Visibility) -> ty::Visibility {\n+        let (path, id) = match *vis {\n+            hir::Public => return ty::Visibility::Public,\n+            hir::Visibility::Crate => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n+            hir::Visibility::Restricted { ref path, id } => (path, id),\n+            hir::Inherited => {\n+                let current_module =\n+                    self.get_nearest_normal_module_parent_or_self(self.current_module);\n+                let id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+                return ty::Visibility::Restricted(id);\n+            }\n+        };\n+\n+        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n+        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, path.span) {\n+            Success(module) => {\n+                let def = module.def.unwrap();\n+                let path_resolution = PathResolution { base_def: def, depth: 0 };\n+                self.def_map.borrow_mut().insert(id, path_resolution);\n+                ty::Visibility::Restricted(self.ast_map.as_local_node_id(def.def_id()).unwrap())\n+            }\n+            Failed(Some((span, msg))) => {\n+                self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n+                ty::Visibility::Public\n+            }\n+            _ => {\n+                self.session.span_err(path.span, \"unresolved module path\");\n+                ty::Visibility::Public\n+            }\n+        };\n+        if !self.is_accessible(vis) {\n+            let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n+            self.session.span_err(path.span, &msg);\n+        }\n+        vis\n+    }\n+\n     fn is_visible(&self, binding: &'a NameBinding<'a>, parent: Module<'a>) -> bool {\n         binding.is_public() || parent.is_ancestor_of(self.current_module)\n     }"}, {"sha": "c22004910c6ccdd1f6fcbb649ed7b05be308a5b1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a4196cd490deba9f5d885f6c9f335c05f1048c24/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4196cd490deba9f5d885f6c9f335c05f1048c24/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a4196cd490deba9f5d885f6c9f335c05f1048c24", "patch": "@@ -21,6 +21,7 @@ use UseLexicalScopeFlag::DontUseLexicalScope;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n+use rustc::ty;\n use rustc::lint;\n use rustc::hir::def::*;\n \n@@ -63,7 +64,7 @@ pub struct ImportDirective<'a> {\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n-    is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n+    vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n     is_prelude: bool,\n }\n \n@@ -72,10 +73,7 @@ impl<'a> ImportDirective<'a> {\n     // this returns the binding for the name this directive defines in that namespace.\n     fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n               -> NameBinding<'a> {\n-        let mut modifiers = match self.is_public {\n-            true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n-            false => DefModifiers::empty(),\n-        };\n+        let mut modifiers = DefModifiers::IMPORTABLE;\n         if let GlobImport = self.subclass {\n             modifiers = modifiers | DefModifiers::GLOB_IMPORTED;\n         }\n@@ -88,6 +86,7 @@ impl<'a> ImportDirective<'a> {\n             },\n             span: Some(self.span),\n             modifiers: modifiers,\n+            vis: self.vis,\n         }\n     }\n }\n@@ -184,7 +183,7 @@ impl<'a> NameResolution<'a> {\n                 // If (1) we don't allow private imports, (2) no public single import can define\n                 // the name, and (3) no public glob has defined the name, the resolution depends\n                 // on whether more globs can define the name.\n-                if !allow_private_imports && !directive.is_public &&\n+                if !allow_private_imports && directive.vis != ty::Visibility::Public &&\n                    !self.binding.map(NameBinding::is_public).unwrap_or(false) {\n                     return None;\n                 }\n@@ -250,7 +249,7 @@ impl<'a> ::ModuleS<'a> {\n \n         // Check if the globs are determined\n         for directive in self.globs.borrow().iter() {\n-            if !allow_private_imports && !directive.is_public { continue }\n+            if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n             match directive.target_module.get() {\n                 None => return Indeterminate,\n                 Some(target_module) => match target_module.resolve_name(name, ns, false) {\n@@ -285,15 +284,15 @@ impl<'a> ::ModuleS<'a> {\n                                 subclass: ImportDirectiveSubclass,\n                                 span: Span,\n                                 id: NodeId,\n-                                is_public: bool,\n+                                vis: ty::Visibility,\n                                 is_prelude: bool) {\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             module_path: module_path,\n             target_module: Cell::new(None),\n             subclass: subclass,\n             span: span,\n             id: id,\n-            is_public: is_public,\n+            vis: vis,\n             is_prelude: is_prelude,\n         });\n \n@@ -337,7 +336,7 @@ impl<'a> ::ModuleS<'a> {\n     }\n \n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.defined_with(DefModifiers::PUBLIC | DefModifiers::IMPORTABLE) { return }\n+        if !binding.defined_with(DefModifiers::IMPORTABLE) || !binding.is_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n             let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n         }\n@@ -413,6 +412,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 modifiers: DefModifiers::GLOB_IMPORTED,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n+                vis: ty::Visibility::Public,\n             });\n             let dummy_binding = e.import_directive.import(dummy_binding, None);\n \n@@ -569,7 +569,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         match (&value_result, &type_result) {\n             (&Success(name_binding), _) if !name_binding.is_import() &&\n-                                           directive.is_public &&\n+                                           directive.vis == ty::Visibility::Public &&\n                                            !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n@@ -580,7 +580,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             }\n \n             (_, &Success(name_binding)) if !name_binding.is_import() &&\n-                                           directive.is_public &&\n+                                           directive.vis == ty::Visibility::Public &&\n                                            !name_binding.is_public() => {\n                 if name_binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n@@ -662,7 +662,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n-            if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n+            if binding.defined_with(DefModifiers::IMPORTABLE) && binding.is_public() {\n                 let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n             }\n         }"}]}