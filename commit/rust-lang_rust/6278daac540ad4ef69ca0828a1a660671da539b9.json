{"sha": "6278daac540ad4ef69ca0828a1a660671da539b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNzhkYWFjNTQwYWQ0ZWY2OWNhMDgyOGExYTY2MDY3MWRhNTM5Yjk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-18T15:27:16Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-24T19:10:18Z"}, "message": "Track `ParamEnv`s properly\n\nThis uses the same `with_param_env` pattern that late lints use.\nThanks to all the doctree refactors, this was very easy to add.", "tree": {"sha": "1d8e3bafc6392f8a4040e0a7150015101d4467d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d8e3bafc6392f8a4040e0a7150015101d4467d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6278daac540ad4ef69ca0828a1a660671da539b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6278daac540ad4ef69ca0828a1a660671da539b9", "html_url": "https://github.com/rust-lang/rust/commit/6278daac540ad4ef69ca0828a1a660671da539b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6278daac540ad4ef69ca0828a1a660671da539b9/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a192e5d9c2e90798ffcd0bc79527cdc4ad52d949", "url": "https://api.github.com/repos/rust-lang/rust/commits/a192e5d9c2e90798ffcd0bc79527cdc4ad52d949", "html_url": "https://github.com/rust-lang/rust/commit/a192e5d9c2e90798ffcd0bc79527cdc4ad52d949"}], "stats": {"total": 341, "additions": 186, "deletions": 155}, "files": [{"sha": "250922e5aa907c1356336c4ba83e9861a86961af", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 166, "deletions": 152, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/6278daac540ad4ef69ca0828a1a660671da539b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6278daac540ad4ef69ca0828a1a660671da539b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6278daac540ad4ef69ca0828a1a660671da539b9", "patch": "@@ -1067,63 +1067,68 @@ impl Clean<TypeKind> for hir::def::DefKind {\n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        let inner = match self.kind {\n-            hir::TraitItemKind::Const(ref ty, default) => {\n-                AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n-            }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                let mut m = (sig, &self.generics, body).clean(cx);\n-                if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                {\n-                    m.header.constness = hir::Constness::NotConst;\n+        cx.with_param_env(local_did, || {\n+            let inner = match self.kind {\n+                hir::TraitItemKind::Const(ref ty, default) => {\n+                    AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n                 }\n-                MethodItem(m, None)\n-            }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n-                let (generics, decl) = enter_impl_trait(cx, || {\n-                    (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n-                });\n-                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                let mut t = Function { header: sig.header, decl, generics, all_types, ret_types };\n-                if t.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                {\n-                    t.header.constness = hir::Constness::NotConst;\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n+                    let mut m = (sig, &self.generics, body).clean(cx);\n+                    if m.header.constness == hir::Constness::Const\n+                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n+                    {\n+                        m.header.constness = hir::Constness::NotConst;\n+                    }\n+                    MethodItem(m, None)\n                 }\n-                TyMethodItem(t)\n-            }\n-            hir::TraitItemKind::Type(ref bounds, ref default) => {\n-                AssocTypeItem(bounds.clean(cx), default.clean(cx))\n-            }\n-        };\n-        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n+                    let (generics, decl) = enter_impl_trait(cx, || {\n+                        (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n+                    });\n+                    let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n+                    let mut t =\n+                        Function { header: sig.header, decl, generics, all_types, ret_types };\n+                    if t.header.constness == hir::Constness::Const\n+                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n+                    {\n+                        t.header.constness = hir::Constness::NotConst;\n+                    }\n+                    TyMethodItem(t)\n+                }\n+                hir::TraitItemKind::Type(ref bounds, ref default) => {\n+                    AssocTypeItem(bounds.clean(cx), default.clean(cx))\n+                }\n+            };\n+            Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+        })\n     }\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        let inner = match self.kind {\n-            hir::ImplItemKind::Const(ref ty, expr) => {\n-                AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n-            }\n-            hir::ImplItemKind::Fn(ref sig, body) => {\n-                let mut m = (sig, &self.generics, body).clean(cx);\n-                if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                {\n-                    m.header.constness = hir::Constness::NotConst;\n+        cx.with_param_env(local_did, || {\n+            let inner = match self.kind {\n+                hir::ImplItemKind::Const(ref ty, expr) => {\n+                    AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n                 }\n-                MethodItem(m, Some(self.defaultness))\n-            }\n-            hir::ImplItemKind::TyAlias(ref ty) => {\n-                let type_ = ty.clean(cx);\n-                let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n-                TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n-            }\n-        };\n-        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+                hir::ImplItemKind::Fn(ref sig, body) => {\n+                    let mut m = (sig, &self.generics, body).clean(cx);\n+                    if m.header.constness == hir::Constness::Const\n+                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n+                    {\n+                        m.header.constness = hir::Constness::NotConst;\n+                    }\n+                    MethodItem(m, Some(self.defaultness))\n+                }\n+                hir::ImplItemKind::TyAlias(ref ty) => {\n+                    let type_ = ty.clean(cx);\n+                    let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n+                    TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n+                }\n+            };\n+            Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n+        })\n     }\n }\n \n@@ -1396,7 +1401,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n         hir::QPath::Resolved(Some(ref qself), ref p) => {\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            if let Some(normalized_value) = normalize(cx.tcx, ty) {\n+            if let Some(normalized_value) = normalize(cx, ty) {\n                 return normalized_value.clean(cx);\n             }\n \n@@ -1498,21 +1503,16 @@ impl Clean<Type> for hir::Ty<'_> {\n }\n \n /// Returns `None` if the type could not be normalized\n-fn normalize(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+fn normalize(cx: &DocContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     use crate::rustc_trait_selection::infer::TyCtxtInferExt;\n     use crate::rustc_trait_selection::traits::query::normalize::AtExt;\n     use rustc_middle::traits::ObligationCause;\n-    use rustc_middle::ty::ParamEnv;\n \n     // Try to normalize `<X as Y>::T` to a type\n-    // FIXME: rustdoc won't be able to perform 'partial' normalization\n-    // until this param env is actually correct\n-    // 'partial': `<Vec<T> as IntoIterator>::IntoIter>` -> `vec::IntoIter<T>`\n-    let param_env = ParamEnv::empty();\n-    let lifted = ty.lift_to_tcx(tcx).unwrap();\n-    let normalized = tcx.infer_ctxt().enter(|infcx| {\n+    let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n+    let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n         infcx\n-            .at(&ObligationCause::dummy(), param_env)\n+            .at(&ObligationCause::dummy(), cx.param_env.get())\n             .normalize(lifted)\n             .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n     });\n@@ -1531,7 +1531,7 @@ fn normalize(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n-        let ty = normalize(cx.tcx, self.lift_to_tcx(cx.tcx).unwrap()).unwrap_or(self);\n+        let ty = normalize(cx, self.lift_to_tcx(cx.tcx).unwrap()).unwrap_or(self);\n         match *ty.kind() {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n@@ -1984,77 +1984,81 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n             Some(ident) => ident.name,\n             None => cx.tcx.hir().name(item.hir_id),\n         };\n-        let kind = match item.kind {\n-            ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n-                type_: ty.clean(cx),\n-                mutability,\n-                expr: print_const_expr(cx, body_id),\n-            }),\n-            ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n-                type_: ty.clean(cx),\n-                expr: print_const_expr(cx, body_id),\n-                value: print_evaluated_const(cx, def_id),\n-                is_literal: is_literal_expr(cx, body_id.hir_id),\n-            }),\n-            ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n-                bounds: ty.bounds.clean(cx),\n-                generics: ty.generics.clean(cx),\n-            }),\n-            ItemKind::TyAlias(ty, ref generics) => {\n-                let rustdoc_ty = ty.clean(cx);\n-                let item_type = rustdoc_ty.def_id().and_then(|did| inline::build_ty(cx, did));\n-                TypedefItem(\n-                    Typedef { type_: rustdoc_ty, generics: generics.clean(cx), item_type },\n-                    false,\n-                )\n-            }\n-            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n-                variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: generics.clean(cx),\n-                variants_stripped: false,\n-            }),\n-            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n-                generics: generics.clean(cx),\n-                bounds: bounds.clean(cx),\n-            }),\n-            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n-                struct_type: doctree::struct_type_from_def(&variant_data),\n-                generics: generics.clean(cx),\n-                fields: variant_data.fields().clean(cx),\n-                fields_stripped: false,\n-            }),\n-            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n-                struct_type: doctree::struct_type_from_def(&variant_data),\n-                generics: generics.clean(cx),\n-                fields: variant_data.fields().clean(cx),\n-                fields_stripped: false,\n-            }),\n-            ItemKind::Impl { .. } => return clean_impl(item, cx),\n-            // proc macros can have a name set by attributes\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-            }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n-                let items =\n-                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n-                let attrs = item.attrs.clean(cx);\n-                let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n-                TraitItem(Trait {\n-                    unsafety,\n-                    items,\n+        cx.with_param_env(def_id, || {\n+            let kind = match item.kind {\n+                ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n+                    type_: ty.clean(cx),\n+                    mutability,\n+                    expr: print_const_expr(cx, body_id),\n+                }),\n+                ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                    type_: ty.clean(cx),\n+                    expr: print_const_expr(cx, body_id),\n+                    value: print_evaluated_const(cx, def_id),\n+                    is_literal: is_literal_expr(cx, body_id.hir_id),\n+                }),\n+                ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n+                    bounds: ty.bounds.clean(cx),\n+                    generics: ty.generics.clean(cx),\n+                }),\n+                ItemKind::TyAlias(ty, ref generics) => {\n+                    let rustdoc_ty = ty.clean(cx);\n+                    let item_type = rustdoc_ty.def_id().and_then(|did| inline::build_ty(cx, did));\n+                    TypedefItem(\n+                        Typedef { type_: rustdoc_ty, generics: generics.clean(cx), item_type },\n+                        false,\n+                    )\n+                }\n+                ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+                    variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n+                    generics: generics.clean(cx),\n+                    variants_stripped: false,\n+                }),\n+                ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n                     generics: generics.clean(cx),\n                     bounds: bounds.clean(cx),\n-                    is_spotlight,\n-                    is_auto: is_auto.clean(cx),\n-                })\n-            }\n-            ItemKind::ExternCrate(orig_name) => {\n-                return clean_extern_crate(item, name, orig_name, cx);\n-            }\n-            _ => unreachable!(\"not yet converted\"),\n-        };\n+                }),\n+                ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+                    struct_type: doctree::struct_type_from_def(&variant_data),\n+                    generics: generics.clean(cx),\n+                    fields: variant_data.fields().clean(cx),\n+                    fields_stripped: false,\n+                }),\n+                ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+                    struct_type: doctree::struct_type_from_def(&variant_data),\n+                    generics: generics.clean(cx),\n+                    fields: variant_data.fields().clean(cx),\n+                    fields_stripped: false,\n+                }),\n+                ItemKind::Impl { .. } => return clean_impl(item, cx),\n+                // proc macros can have a name set by attributes\n+                ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                    clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+                }\n+                hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                    let items = item_ids\n+                        .iter()\n+                        .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n+                        .collect();\n+                    let attrs = item.attrs.clean(cx);\n+                    let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n+                    TraitItem(Trait {\n+                        unsafety,\n+                        items,\n+                        generics: generics.clean(cx),\n+                        bounds: bounds.clean(cx),\n+                        is_spotlight,\n+                        is_auto: is_auto.clean(cx),\n+                    })\n+                }\n+                ItemKind::ExternCrate(orig_name) => {\n+                    return clean_extern_crate(item, name, orig_name, cx);\n+                }\n+                _ => unreachable!(\"not yet converted\"),\n+            };\n \n-        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+        })\n     }\n }\n \n@@ -2272,32 +2276,42 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Ident>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n-        let kind = match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n-                let abi = cx.tcx.hir().get_foreign_abi(item.hir_id);\n-                let (generics, decl) =\n-                    enter_impl_trait(cx, || (generics.clean(cx), (&**decl, &names[..]).clean(cx)));\n-                let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                ForeignFunctionItem(Function {\n-                    decl,\n-                    generics,\n-                    header: hir::FnHeader {\n-                        unsafety: hir::Unsafety::Unsafe,\n-                        abi,\n-                        constness: hir::Constness::NotConst,\n-                        asyncness: hir::IsAsync::NotAsync,\n-                    },\n-                    all_types,\n-                    ret_types,\n-                })\n-            }\n-            hir::ForeignItemKind::Static(ref ty, mutability) => {\n-                ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: String::new() })\n-            }\n-            hir::ForeignItemKind::Type => ForeignTypeItem,\n-        };\n+        cx.with_param_env(cx.tcx.hir().local_def_id(item.hir_id).to_def_id(), || {\n+            let kind = match item.kind {\n+                hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n+                    let abi = cx.tcx.hir().get_foreign_abi(item.hir_id);\n+                    let (generics, decl) = enter_impl_trait(cx, || {\n+                        (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n+                    });\n+                    let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n+                    ForeignFunctionItem(Function {\n+                        decl,\n+                        generics,\n+                        header: hir::FnHeader {\n+                            unsafety: hir::Unsafety::Unsafe,\n+                            abi,\n+                            constness: hir::Constness::NotConst,\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        },\n+                        all_types,\n+                        ret_types,\n+                    })\n+                }\n+                hir::ForeignItemKind::Static(ref ty, mutability) => ForeignStaticItem(Static {\n+                    type_: ty.clean(cx),\n+                    mutability,\n+                    expr: String::new(),\n+                }),\n+                hir::ForeignItemKind::Type => ForeignTypeItem,\n+            };\n \n-        Item::from_hir_id_and_parts(item.hir_id, Some(renamed.unwrap_or(item.ident).name), kind, cx)\n+            Item::from_hir_id_and_parts(\n+                item.hir_id,\n+                Some(renamed.unwrap_or(item.ident).name),\n+                kind,\n+                cx,\n+            )\n+        })\n     }\n }\n "}, {"sha": "b63acdc114e89cec6299b8bcb35c1f1ba56ae958", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6278daac540ad4ef69ca0828a1a660671da539b9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6278daac540ad4ef69ca0828a1a660671da539b9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6278daac540ad4ef69ca0828a1a660671da539b9", "patch": "@@ -15,7 +15,7 @@ use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_resolve as resolve;\n use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n@@ -25,7 +25,7 @@ use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::mem;\n use std::rc::Rc;\n \n@@ -42,6 +42,10 @@ crate type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n crate struct DocContext<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    /// Used for normalization.\n+    ///\n+    /// Most of this logic is copied from rustc_lint::late.\n+    crate param_env: Cell<ParamEnv<'tcx>>,\n     /// Later on moved into `CACHE_KEY`\n     crate renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `CACHE_KEY`\n@@ -79,6 +83,13 @@ impl<'tcx> DocContext<'tcx> {\n         &self.tcx.sess\n     }\n \n+    crate fn with_param_env<T, F: FnOnce() -> T>(&self, def_id: DefId, f: F) -> T {\n+        let old_param_env = self.param_env.replace(self.tcx.param_env(def_id));\n+        let ret = f();\n+        self.param_env.set(old_param_env);\n+        ret\n+    }\n+\n     crate fn enter_resolver<F, R>(&self, f: F) -> R\n     where\n         F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n@@ -524,6 +535,7 @@ fn run_global_ctxt(\n     let mut ctxt = DocContext {\n         tcx,\n         resolver,\n+        param_env: Cell::new(ParamEnv::empty()),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n         renderinfo: RefCell::new(renderinfo),"}, {"sha": "137fd354a8743a61dceec4ab94702644e036e30e", "filename": "src/test/rustdoc/normalize-assoc-item.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6278daac540ad4ef69ca0828a1a660671da539b9/src%2Ftest%2Frustdoc%2Fnormalize-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6278daac540ad4ef69ca0828a1a660671da539b9/src%2Ftest%2Frustdoc%2Fnormalize-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fnormalize-assoc-item.rs?ref=6278daac540ad4ef69ca0828a1a660671da539b9", "patch": "@@ -16,7 +16,7 @@ pub fn f() -> <usize as Trait>::X {\n }\n \n pub struct S {\n-    // @has 'normalize_assoc_item/struct.S.html' '//span[@id=\"structfield.box_me_up\"]' 'box_me_up: Box<S>'\n+    // @has 'normalize_assoc_item/struct.S.html' '//span[@id=\"structfield.box_me_up\"]' 'box_me_up: Box<S, Global>'\n     pub box_me_up: <S as Trait>::X,\n     // @has 'normalize_assoc_item/struct.S.html' '//span[@id=\"structfield.generic\"]' 'generic: (usize, isize)'\n     pub generic: <Generic<usize> as Trait>::X,\n@@ -61,3 +61,8 @@ pub const A: <usize as Lifetimes<'static>>::Y = &0;\n extern crate inner;\n // @has 'normalize_assoc_item/fn.foo.html' '//pre[@class=\"rust fn\"]' \"pub fn foo() -> i32\"\n pub use inner::foo;\n+\n+// @has 'normalize_assoc_item/fn.h.html' '//pre[@class=\"rust fn\"]' \"pub fn h<T>() -> IntoIter<T, Global>\"\n+pub fn h<T>() -> <Vec<T> as IntoIterator>::IntoIter {\n+    vec![].into_iter()\n+}"}]}