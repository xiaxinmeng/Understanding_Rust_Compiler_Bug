{"sha": "dbcb54f4dc44957c9505958655a16e678ee4396b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiY2I1NGY0ZGM0NDk1N2M5NTA1OTU4NjU1YTE2ZTY3OGVlNDM5NmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-08T05:19:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-11T04:48:28Z"}, "message": "create serializer project which autogenerates serialization code", "tree": {"sha": "7052f0ffb3d41900c455b720995ff1a6ec973f6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7052f0ffb3d41900c455b720995ff1a6ec973f6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbcb54f4dc44957c9505958655a16e678ee4396b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcb54f4dc44957c9505958655a16e678ee4396b", "html_url": "https://github.com/rust-lang/rust/commit/dbcb54f4dc44957c9505958655a16e678ee4396b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbcb54f4dc44957c9505958655a16e678ee4396b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d57fa3403ab627e9507a9f0768e742ebc17bc11", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d57fa3403ab627e9507a9f0768e742ebc17bc11", "html_url": "https://github.com/rust-lang/rust/commit/5d57fa3403ab627e9507a9f0768e742ebc17bc11"}], "stats": {"total": 1011, "additions": 1010, "deletions": 1}, "files": [{"sha": "002296a656dfe554059da9370ce7ec178dc24a9d", "filename": "src/comp/metadata/astencode.rs", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/rust-lang/rust/blob/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fcomp%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fcomp%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode.rs?ref=dbcb54f4dc44957c9505958655a16e678ee4396b", "patch": "@@ -0,0 +1,653 @@\n+// Encoding of ASTs and the associated side tables.\n+\n+import middle::base::trans::common::crate_ctxt;\n+import syntax::ast;\n+import syntax::codemap::{span, filename};\n+import std::ebml::writer;\n+import metadata::common::*;\n+\n+enum ast_tag {\n+    at_span,\n+    at_id,\n+\n+    at_span_expninfo_callie_name,\n+    at_span_expninfo_callie_span,\n+\n+    at_blk,\n+    at_blk_stmts,\n+    at_blk_expr,\n+    at_blk_rules,\n+\n+    at_stmt,\n+    at_stmt_node_decl,\n+    at_stmt_node_expr,\n+\n+    at_expr,\n+    at_expr_node_vec,\n+    at_expr_node_rec,\n+    at_expr_node_call,\n+    at_expr_node_tup,\n+    at_expr_node_bind,\n+    at_expr_node_bind_args,\n+    at_expr_node_binary,\n+    at_expr_node_unary,\n+    at_expr_node_lit,\n+    at_expr_node_cast,\n+    at_expr_node_if,\n+    at_expr_node_while,\n+\n+    at_none,\n+    at_some,\n+}\n+\n+type ast_ctxt = {\n+    embl_w: ebml::writer,\n+    ccx: crate_ctxt,\n+};\n+\n+impl ast_output for ast_ctxt {\n+    fn tag(tag: ast_tag, blk: fn()) {\n+        self.embl_w.wr_tag(tag as uint, blk)\n+    }\n+\n+    fn uint(v: uint) {\n+        self.embl_w.wr_uint(v)\n+    }\n+\n+    fn opt<T>(x: option<T>, blk: fn(T)) {\n+        alt x {\n+          none { self.tag(at_none) {||} }\n+          some(v) { self.tag(at_some) {|| blk(v) } }\n+        }\n+    }\n+\n+    fn str(tag: ast_tag, v: str) {\n+        self.tag(tag) {|| self.embl_w.wr_str(v) };\n+    }\n+\n+    fn vec<T>(tag: ast_tag, v: [T], blk: fn(T)) {\n+        self.tag(tag) {||\n+            self.uint(vec::len(v));\n+            vec::iter(v) {|e| blk(e) };\n+        }\n+    }\n+\n+    fn span(sp: span) {\n+        self.tag(at_span) {||\n+            self.uint(sp.lo);\n+            self.uint(sp.hi);\n+            self.opt(sp.expn_info) {|ei|\n+                self.span(ei.call_site);\n+                self.str(at_span_expninfo_callie_name, ei.callie.name);\n+                self.opt(ei.callie.span) {|v| self.span(v) };\n+            }\n+        }\n+    }\n+\n+    fn id(id: uint) {\n+        self.tag(at_id) {|| self.uint(id); }\n+    }\n+\n+    fn blk(blk: ast::blk) {\n+        self.tag(at_blk) {||\n+            self.id(blk.node.id);\n+            self.span(blk.span);\n+            self.vec(at_blk_stmts, blk.node.stmts) {|stmt|\n+                self.stmt(stmt)\n+            }\n+            self.tag(at_blk_expr) {||\n+                self.opt(blk.node.expr) {|e| self.expr(e) }\n+            }\n+            self.tag(at_blk_rules) {||\n+                self.uint(blk.node.rules as uint);\n+            }\n+        }\n+    }\n+\n+    fn decl(decl: ast::decl) {\n+        self.span(decl.span);\n+        alt decl.node {\n+          ast::decl_local(lcls) {\n+            self.vec(at_decl_local, lcls) {|lcl|\n+                self.local(lcl)\n+            }\n+          }\n+\n+          ast::decl_item(item) {\n+            self.tag(at_decl_item) {||\n+                self.item(item);\n+            }\n+          }\n+        }\n+    }\n+\n+    fn local(lcl: ast::local) {\n+        self.span(lcl.span);\n+        self.ty(lcl.ty);\n+        self.pat(lcl.pat);\n+        self.opt(lcl.init) {|i| self.initializer(i) };\n+        self.uint(lcl.id);\n+    }\n+\n+    fn pat(pat: ast::pat) {\n+        self.uint(pat.id);\n+        self.span(pat.span);\n+        alt pat_util::normalize_pat(pat.node) {\n+          pat_wild {\n+            self.tag(at_pat_wild) {||\n+            }\n+          }\n+          pat_ident(path, o_pat) {\n+            self.tag(at_pat_ident) {||\n+                self.path(path);\n+                self.opt(o_pat) {|p|\n+                    self.pat(p)\n+                }\n+            }\n+          }\n+          pat_enum(path, pats) {\n+            self.tag(at_pat_enum) {||\n+                self.path(path);\n+                self.vec(at_pat_enum_pats, pats) {|p| self.pat(p) };\n+            }\n+          }\n+          pat_rec(field_pats, b) {\n+            self.tag(at_pat_rec) {||\n+                self.vec(at_pat_rec_fields, field_pats) {|p|\n+                    self.field_pat(p)\n+                }\n+            }\n+          }\n+          pat_tup(pats) {\n+            self.vec(at_pat_tup, pats) {|p| self.pat(p); }\n+          }\n+          pat_box(pat) {\n+            self.tag(at_pat_box) {|| self.pat(pat) }\n+          }\n+          pat_lit(expr) {\n+            self.tag(at_pat_lit) {|| self.expr(expr) }\n+          }\n+          pat_range(l, h) {\n+            self.tag(at_pat_range) {||\n+                self.expr(l);\n+                self.expr(h);\n+            }\n+          }\n+        }\n+    }\n+\n+    fn stmt(stmt: ast::stmt) {\n+        self.tag(at_stmt) {||\n+            self.span(stmt.span);\n+            alt stmt.node {\n+              ast::stmt_decl(d, nid) {\n+                self.id(nid);\n+                self.tag(at_stmt_node_decl) {|| self.decl(d) };\n+              }\n+              ast::stmt_expr(e, nid) | ast::stmt_semi(e, nid) {\n+                self.id(nid);\n+                self.tag(at_stmt_node_expr) {|| self.expr(e) };\n+              }\n+            }\n+        }\n+    }\n+\n+    fn exprs(exprs: [ast::expr]) {\n+        self.vec(at_exprs, exprs) {|e| self.expr(e) };\n+    }\n+\n+    fn expr(expr: ast:expr) {\n+        self.id(expr.id);\n+        self.span(expr.span);\n+        alt expr.node {\n+          ast::expr_vec(subexprs, mutbl) {\n+            self.tag(at_expr_node_vec) {||\n+                self.exprs(subexprs);\n+                self.mutbl(mutbl);\n+            }\n+          }\n+\n+          ast::expr_rec(fields, opt_expr) {\n+            self.tag(at_expr_node_rec) {||\n+                self.fields(fields);\n+                self.opt(opt_expr) {|e| self.expr(e) };\n+            }\n+          }\n+\n+          ast::expr_call(func, args, _) {\n+            self.tag(at_expr_node_call) {||\n+                self.expr(func);\n+                self.exprs(args);\n+            }\n+          }\n+\n+          ast::expr_tup(exprs) {\n+            self.tag(at_expr_node_tup) {||\n+                self.exprs(exprs);\n+            }\n+          }\n+\n+          ast::expr_bind(f, args) {\n+            self.tag(at_expr_node_bind) {||\n+                self.expr(f);\n+                self.vec(at_expr_node_bind_args, args) {|opt_e|\n+                    self.opt(opt_e) {|e| self.expr(e)};\n+                }\n+            }\n+          }\n+\n+          ast::expr_binary(binop, l, r) {\n+            self.tag(at_expr_node_binary) {||\n+                self.uint(binop as uint);\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_unary(unop, l, r) {\n+            self.tag(at_expr_node_unary) {||\n+                self.uint(unop as uint);\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_lit(lit) {\n+            self.tag(at_expr_node_lit) {|| self.lit(lit) }\n+          }\n+\n+          ast::expr_cast(expr, ty) {\n+            self.tag(at_expr_node_cast) {||\n+                self.expr(expr);\n+                self.ty(ty);\n+            }\n+          }\n+\n+          ast::expr_if(cond, blk_then, o_blk_else) {\n+            self.tag(at_expr_node_if) {||\n+                self.expr(cond);\n+                self.blk(blk_then);\n+                self.opt(o_blk_else) {|b| self.blk(b)};\n+            }\n+          }\n+\n+          ast::expr_while(cond, blk) {\n+            self.tag(at_expr_node_while) {||\n+                self.expr(cond);\n+                self.blk(blk);\n+            }\n+          }\n+\n+          ast::expr_for(lcl, expr, blk) {\n+            self.tag(at_expr_node_for) {||\n+                self.local(lcl);\n+                self.expr(expr);\n+                self.blk(blk);\n+            }\n+          }\n+\n+          ast::expr_do_while(blk, cond) {\n+            self.tag(at_expr_node_do_while) {||\n+                self.blk(blk);\n+                self.expr(cond);\n+            }\n+          }\n+\n+          ast::expr_alt(cond, arms) {\n+            self.tag(at_expr_node_alt) {||\n+                self.blk(blk);\n+                self.expr(cond);\n+            }\n+          }\n+\n+          ast::expr_block(blk) {\n+            self.tag(at_expr_node_blk) {||\n+                self.blk(blk);\n+            }\n+          }\n+\n+          ast::expr_copy(expr) {\n+            self.tag(at_expr_node_copy) {||\n+                self.expr(expr);\n+            }\n+          }\n+\n+          ast::expr_move(l, r) {\n+            self.tag(at_expr_node_move) {||\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_assign(l, r) {\n+            self.tag(at_expr_node_assign) {||\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_swap(l, r) {\n+            self.tag(at_expr_node_swap) {||\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_assign_of(binop, l, r) {\n+            self.tag(at_expr_node_assign_op) {||\n+                self.uint(binop as uint);\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_field(base, f, tys) {\n+            self.tag(at_expr_node_field) {||\n+                self.expr(base);\n+                self.str(at_ident, f);\n+                self.vec(at_tys) {|v| self.ty(v) }\n+            }\n+          }\n+\n+          ast::expr_index(l, r) {\n+            self.tag(at_expr_node_index) {||\n+                self.expr(l);\n+                self.expr(r);\n+            }\n+          }\n+\n+          ast::expr_path(pth) {\n+            self.tag(at_expr_node_path) {||\n+            }\n+          }\n+\n+          ast::expr_fail(o_expr) {\n+            self.tag(at_expr_node_fail) {||\n+                self.opt(o_expr) {|e| self.expr(e) }\n+            }\n+          }\n+\n+          ast::expr_break {\n+            self.tag(at_expr_node_break) {||}\n+          }\n+\n+          ast::expr_cont {\n+            self.tag(at_expr_node_cont) {||}\n+          }\n+\n+          ast::expr_ret(o_expr) {\n+            self.tag(at_expr_node_ret) {||\n+                self.opt(o_expr) {|e| self.expr(e) }\n+            }\n+          }\n+\n+          ast::expr_be(expr) {\n+            self.tag(at_expr_node_be) {||\n+                self.expr(expr)\n+            }\n+          }\n+\n+          ast::expr_log(i, e1, e2) {\n+            self.tag(at_expr_node_log) {||\n+                self.uint(i);\n+                self.expr(e1);\n+                self.expr(e2);\n+            }\n+          }\n+\n+          ast::expr_assert(e) {\n+            self.tag(at_expr_node_assert) {||\n+                self.expr(e);\n+            }\n+          }\n+\n+          ast::expr_check(mode, e) {\n+            self.tag(at_expr_node_check) {||\n+                self.uint(mode as uint);\n+                self.expr(e);\n+            }\n+          }\n+\n+          ast::expr_if_check(cond, b, e) {\n+            self.tag(at_expr_node_if_check) {||\n+                self.expr(cond);\n+                self.blk(b);\n+                self.opt(e) {|e| self.blk(e)};\n+            }\n+          }\n+\n+          ast::expr_mac(m) {\n+            self.tag(at_expr_node_mac) {||\n+                /* todo */\n+            }\n+          }\n+        }\n+    }\n+\n+    fn lit(l: ast::lit) {\n+        alt l {\n+          lit_str(s) {\n+            self.str(at_lit_str, s);\n+          }\n+          lit_int(i, t) {\n+            self.tag(at_lit_int) {||\n+                self.i64(i);\n+                self.int_ty(t);\n+            }\n+          }\n+          lit_uint(i, t) {\n+            self.tag(at_lit_uint) {||\n+                self.u64(i);\n+                self.uint_ty(t);\n+            }\n+          }\n+          lit_float(s, f) {\n+            self.tag(at_lit_float) {||\n+                self.str(at_value, s);\n+                self.float_ty(f);\n+            }\n+          }\n+          lit_nil {\n+            self.tag(at_lit_nil) {||}\n+          }\n+          lit_bool(true) {\n+            self.tag(at_lit_true) {||}\n+          }\n+          lit_bool(false) {\n+            self.tag(at_lit_false) {||}\n+          }\n+        }\n+    }\n+\n+    fn int_ty(t: ast::int_ty) {\n+        self.uint(t as uint);\n+    }\n+\n+    fn uint_ty(t: ast::uint_ty) {\n+        self.uint(t as uint);\n+    }\n+\n+    fn float_ty(t: ast::float_ty) {\n+        self.uint(t as uint);\n+    }\n+\n+    fn ty(ty: ast::ty) {\n+        self.tag(at_ty) {||\n+            self.span(ty.span);\n+            alt ty.node {\n+              ty_nil {\n+                self.tag(at_ty_nil) {||}\n+              }\n+\n+              ty_bot {\n+                self.tag(at_ty_bot) {||}\n+              }\n+\n+              ty_box({ty: ty, mut: m}) {\n+                self.tag(at_ty_box) {||\n+                    self.ty(ty);\n+                    self.mutbl(m);\n+                }\n+              }\n+\n+              ty_uniq({ty: ty, mut: m}) {\n+                self.tag(at_ty_uniq) {||\n+                    self.ty(ty);\n+                    self.mutbl(m);\n+                }\n+              }\n+\n+              ty_vec({ty: ty, mut: m}) {\n+                self.tag(at_ty_vec) {||\n+                    self.ty(ty);\n+                    self.mutbl(m);\n+                }\n+              }\n+\n+              ty_ptr({ty: ty, mut: m}) {\n+                self.tag(at_ty_ptr) {||\n+                    self.ty(ty);\n+                    self.mutbl(m);\n+                }\n+              }\n+\n+              ty_rec(fields) {\n+                self.vec(at_ty_rec) {|f|\n+                    self.field(f)\n+                }\n+              }\n+\n+              ty_fn(proto, fd) {\n+                self.tag(at_ty_fn) {||\n+                    self.uint(proto as uint);\n+                    self.fn_decl(fd)\n+                }\n+              }\n+\n+              ty_tup(tys) {\n+                self.vec(at_ty_tups) {|ty| self.ty(ty)}\n+              }\n+\n+              ty_path(p, id) {\n+                self.tag(at_ty_path) {||\n+                    self.path(p);\n+                    self.uint(id);\n+                }\n+              }\n+\n+              ty_constr(t, tcs) {\n+                self.tag(at_ty_constr) {||\n+                    self.ty(t);\n+                    // ... constrs ... who cares ...\n+                }\n+              }\n+\n+              ty_mac(m) {\n+                self.tag(at_ty_mac) {||\n+                    self.mac(m);\n+                };\n+              }\n+\n+              ty_infer {\n+                self.tag(at_ty_infer) {||\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n+    fn item(item: @ast::item) {\n+        self.tag(at_item) {||\n+            self.str(at_item_ident, item);\n+            self.vec(at_item_attrs, item.attrs) {|a| self.attr(a)}\n+            self.uint(item.id);\n+            self.span(item.span);\n+\n+            alt item.node {\n+              item_const(t, e) {\n+                self.tag(at_item_const) {||\n+                    self.ty(t);\n+                    self.expr(e);\n+                }\n+              }\n+              item_fn(d, tps, blk) {\n+                self.tag(at_item_fn) {||\n+                    self.fn_decl(d);\n+                    self.ty_params(tps);\n+                }\n+              }\n+              item_mod(m) {\n+                self.tag(at_item_mod) {||\n+                    self.mod_(m)\n+                }\n+              }\n+              item_native_mod(nm) {\n+                self.tag(at_item_native_mod) {||\n+                    self.mod_(nm)\n+                }\n+              }\n+              item_ty(ty, tps) {\n+                self.tag(at_item_ty) {||\n+                    self.ty(ty);\n+                    self.ty_params(tps);\n+                }\n+              }\n+              item_enum(variants, tps) {\n+                self.tag(at_item_enum) {||\n+                    self.ty(ty);\n+                    self.ty_params(tps);\n+                }\n+              }\n+              item_res(fd, tps, blk, node_id, node_id) {\n+                self.tag(at_item_res) {||\n+                    self.fn_decl(fd);\n+                    self.ty_params(tps);\n+                }\n+              }\n+              item_class(tps, citems, fn_decl, blk) {\n+                self.tag(at_item_class) {||\n+                    self.ty_params(tps);\n+                    self.class_items(citems);\n+                    self.fn_decl(fn_decl);\n+                    self.blk(blk);\n+                }\n+              }\n+              item_iface(tps, tms) {\n+                self.tag(at_item_iface) {||\n+                    self.ty_params(tps);\n+                    self.ty_methods(tms);\n+                }\n+              }\n+              item_impl(tps, iface_ty, self_ty, mthds) {\n+                self.tag(at_item_impl) {||\n+                    self.ty_params(tps);\n+                    self.opt(iface_ty) {|t| self.ty(t) };\n+                    self.ty(self_ty);\n+                    self.methods(mthds);\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n+    fn ty_params(tps: [ast::ty_param]) {\n+        self.vec(at_item_tps, tps) {|t| self.ty_param(t) }\n+    }\n+\n+    fn ty_param(tp: ast::ty_param) {\n+        self.str(at_ty_param_ident, tp.ident);\n+        self.uint(at_ty_param_id, tp.id);\n+        self.vec(at_param_bounds, *tp.bounds) {|b| self.ty_param_bound(b) };\n+    }\n+\n+    fn ty_param_bound(b: ast::ty_param_bound) {\n+        alt b {\n+          bound_copy { self.tag(at_ty_param_bound_copy) {||} }\n+          bound_send { self.tag(at_ty_param_bound_send) {||} }\n+          bound_iface(t) {\n+            self.tag(at_ty_param_bound_iface) {|| self.ty(t) }\n+          }\n+        }\n+    }\n+}\n+"}, {"sha": "5c6e956508fc654776661fde6db24422893689f3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=dbcb54f4dc44957c9505958655a16e678ee4396b", "patch": "@@ -53,7 +53,7 @@ export sty;\n export substitute_type_params;\n export t;\n export new_ty_hash;\n-export enum_variants;\n+export enum_variants, substd_enum_variants;\n export iface_methods, store_iface_methods, impl_iface;\n export enum_variant_with_id;\n export ty_param_bounds_and_ty;\n@@ -2357,6 +2357,20 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n type variant_info = @{args: [t], ctor_ty: t, name: str,\n                       id: ast::def_id, disr_val: int};\n \n+fn substd_enum_variants(cx: ctxt, id: ast::def_id, tps: [ty::t])\n+    -> [variant_info] {\n+    vec::map(*enum_variants(cx, id)) { |variant_info|\n+        let substd_args = vec::map(variant_info.args) {|aty|\n+            substitute_type_params(cx, tps, aty)\n+        };\n+\n+        let substd_ctor_ty =\n+            substitute_type_params(cx, tps, variant_info.ctor_ty);\n+\n+        @{args: substd_args, ctor_ty: substd_ctor_ty with *variant_info}\n+    }\n+}\n+\n fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n     alt cx.enum_var_cache.find(id) {\n       some(variants) { ret variants; }"}, {"sha": "ba3a8467b9da07257d15c1393c6c5ede54ba1688", "filename": "src/serializer/serializer.rc", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fserializer%2Fserializer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fserializer%2Fserializer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rc?ref=dbcb54f4dc44957c9505958655a16e678ee4396b", "patch": "@@ -0,0 +1,17 @@\n+// -*- rust -*-\n+\n+// serializer --- Rust metadata encoder/decoder generator.\n+//\n+// This tool is not intended to generate usable modules (just yet),\n+// though perhaps it will be beefed up.  But it can do a lot of the\n+// grunt work for you.\n+\n+#[link(name = \"serializer\",\n+       vers = \"0.1\",\n+       uuid = \"9ff87a04-8fed-4295-9ff8-f99bb802650b\",\n+       url = \"http://rust-lang.org/doc/serializer\")];\n+\n+#[crate_type = \"bin\"];\n+\n+use std;\n+use rustc;"}, {"sha": "f8c4349a7ce6540352fc482aa6dbee25be22ceeb", "filename": "src/serializer/serializer.rs", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=dbcb54f4dc44957c9505958655a16e678ee4396b", "patch": "@@ -0,0 +1,294 @@\n+import rustc::driver::{driver,session};\n+import rustc::syntax::{ast, codemap};\n+import rustc::syntax::parse::parser;\n+import rustc::driver::diagnostic;\n+import rustc::syntax::print::pprust;\n+import rustc::syntax::codemap::span;\n+import rustc::middle::ty;\n+import rustc::middle::ast_map;\n+import rustc::util::ppaux;\n+import std::map::{hashmap, map, new_int_hash};\n+import std::getopts;\n+import std::io;\n+import std::io::writer_util;\n+import driver::build_session_options;\n+import driver::build_session;\n+import driver::build_configuration;\n+\n+type parse_result = {\n+    crate: @ast::crate,\n+    tcx: ty::ctxt,\n+    roots: [str]\n+};\n+\n+fn parse(argv: [str]) -> parse_result {\n+    let argv = argv;\n+    let argv0 = vec::shift(argv);\n+    let match = result::get(getopts::getopts(argv, driver::opts()));\n+    let sessopts = build_session_options(match, diagnostic::emit);\n+    let sess = build_session(sessopts, \"\", diagnostic::emit);\n+    let (ifile, roots) = {\n+        let free = match.free;\n+        if check vec::is_not_empty(free) {\n+            let t = vec::tail(free);\n+            (free[0], t)\n+        } else {\n+            fail \"No input filename given.\";\n+        }\n+    };\n+    let cfg = build_configuration(sess, argv0, ifile);\n+    alt driver::compile_upto(sess, cfg, ifile, driver::cu_typeck, none) {\n+      {crate, tcx: some(tcx)} { {crate:crate, tcx:tcx, roots:roots} }\n+      _ { fail \"no type context\"; }\n+    }\n+}\n+\n+type ast_expr = str;\n+type ast_stmt = str;\n+type ast_blk = str;\n+type ast_pat = str;\n+type ast_ty = str;\n+type ast_item = str;\n+\n+type tp_map = map<ast::node_id, ty::t>;\n+\n+type serialize_ctx = {\n+    crate: @ast::crate,\n+    tcx: ty::ctxt,\n+\n+    tyfns: hashmap<ty::t, str>,\n+    mutable item_fns: [ast_item],\n+    mutable constants: [str]\n+\n+    // needed for #ast:\n+    // opts: @{cfg: ast::crate_cfg},\n+    // psess: parser::parse_sess\n+};\n+\n+fn item_has_name(&&item: @ast::item, &&name: str) -> bool {\n+    item.ident == name\n+}\n+\n+fn lookup(_mod: ast::_mod, idx: uint, names: [str]) -> @ast::item {\n+    let name = names[idx];\n+    alt vec::find(_mod.items, bind item_has_name(_, name)) {\n+      none { fail #fmt[\"cannot resolve name %s at index %u\", name, idx]; }\n+      some(item) if idx == vec::len(names) - 1u { item }\n+      some(item) {\n+        alt item.node {\n+          ast::item_mod(_m) { lookup(_m, idx + 1u, names) }\n+          _ { fail #fmt[\"name %s at index %u not a module\", name, idx]; }\n+        }\n+      }\n+    }\n+}\n+\n+impl serialize_ctx for serialize_ctx {\n+    // fn session() -> parser::parse_sess { self.psess }\n+\n+    fn add_item(item: ast_item) {\n+        self.item_fns += [item];\n+    }\n+\n+    fn mk_serialize_named_item_fn(name: str) -> str {\n+        let names = str::split_str(name, \"::\");\n+        let item = lookup(self.crate.node.module, 0u, names);\n+        let def_id = {crate: ast::local_crate, node: item.id};\n+        self.mk_serialize_item_fn(def_id, [])\n+    }\n+\n+    fn tp_map(ty_params: [ast::ty_param], tps: [ty::t]) -> tp_map {\n+        assert vec::len(tps) == vec::len(ty_params);\n+        let tps_map = new_int_hash();\n+        vec::iter2(ty_params, tps) {|tp_def,tp_val|\n+            tps_map.insert(tp_def.id, tp_val);\n+        }\n+        ret tps_map;\n+    }\n+\n+    fn path(mod_: [str], id: str) -> str {\n+        str::connect(mod_ + [id], \"::\")\n+    }\n+\n+    fn ident(mod_: [str], id: str) -> str {\n+        str::connect(mod_ + [id], \"_\")\n+    }\n+\n+    fn instantiate(id: ast::def_id, args: [ty::t]) -> ty::t {\n+        let {bounds, ty} = ty::lookup_item_type(self.tcx, id);\n+\n+        // typeck should guarantee this\n+        assert vec::len(*bounds) == vec::len(args);\n+\n+        ret if vec::len(args) == 0u {\n+            ty\n+        } else {\n+            ty::substitute_type_params(self.tcx, args, ty)\n+        };\n+    }\n+\n+    fn mk_serialize_item_fn(id: ast::def_id,\n+                            tps: [ty::t]) -> str {\n+        let item_ty = self.instantiate(id, tps);\n+        self.mk_serialize_ty_fn(item_ty)\n+    }\n+\n+    fn blk(stmts: [ast_stmt]) -> ast_blk {\n+        \"{\" + str::connect(stmts, \";\") + \"}\"\n+    }\n+\n+    fn blk_expr(stmts: [ast_stmt]) -> ast_expr {\n+        self.blk(stmts)\n+    }\n+\n+    // Generates a function to serialize the given type.\n+    // Returns an AST fragment that names this function.\n+    fn serialize_ty(ty0: ty::t, v: ast_expr) -> ast_expr {\n+        let fname = self.mk_serialize_ty_fn(ty0);\n+        #fmt[\"%s(cx, %s)\", fname, v]\n+    }\n+\n+    fn mk_serialize_ty_fn(ty0: ty::t) -> str {\n+        // check for existing function\n+        alt self.tyfns.find(ty0) {\n+          some(name) { ret name; }\n+          none { /* fallthrough */ }\n+        }\n+\n+        // define the name and insert into the hashtable\n+        // in case of recursive calls:\n+        let id = self.tyfns.size();\n+        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n+        let name = #fmt[\"serialize_%u /*%s*/\", id, ty0_str];\n+        self.tyfns.insert(ty0, name);\n+        let v = \"v\";\n+\n+        let body_node = alt ty::get(ty0).struct {\n+          ty::ty_nil | ty::ty_bot { \"()\" }\n+          ty::ty_int(_) { #fmt[\"serialize_i64(cx, %s as i64)\", v] }\n+          ty::ty_uint(_) { #fmt[\"serialize_u64(cx, %s as u64)\", v] }\n+          ty::ty_float(_) { #fmt[\"serialize_float(cx, %s as float)\", v] }\n+          ty::ty_bool { #fmt[\"serialize_bool(cx, %s)\", v] }\n+          ty::ty_str { #fmt[\"serialize_str(cx, %s)\", v] }\n+          ty::ty_enum(def_id, tps) { self.serialize_enum(v, def_id, tps) }\n+          ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_ptr(mt) {\n+            self.serialize_ty(mt.ty, #fmt[\"*%s\", v])\n+          }\n+          ty::ty_vec(mt) {\n+            let selem = self.serialize_ty(mt.ty, \"i\");\n+            #fmt[\"start_vec(cx); \\\n+                  vec::iter(v) {|i| \\\n+                  start_vec_item(cx); \\\n+                  %s; \\\n+                  end_vec_item(cx); \\\n+                  } \\\n+                  end_vec(cx);\", selem]\n+          }\n+          ty::ty_rec(fields) {\n+            let stmts = vec::map(fields) {|field|\n+                let f_name = field.ident;\n+                let f_ty = field.mt.ty;\n+                self.serialize_ty(f_ty, #fmt[\"%s.%s\", v, f_name])\n+            };\n+            self.blk_expr(stmts)\n+          }\n+          ty::ty_tup(tys) {\n+            let (pat, stmts) = self.serialize_arm(\"\", tys);\n+            #fmt[\"alt %s { \\\n+                    %s %s \\\n+                  }\", v, pat, self.blk_expr(stmts)]\n+          }\n+          ty::ty_constr(t, _) {\n+            self.serialize_ty(t, v)\n+          }\n+          ty::ty_fn(_) |\n+          ty::ty_iface(_, _) |\n+          ty::ty_res(_, _, _) |\n+          ty::ty_var(_) | ty::ty_param(_, _) |\n+          ty::ty_self(_) | ty::ty_type | ty::ty_send_type |\n+          ty::ty_opaque_closure_ptr(_) | ty::ty_opaque_box {\n+            fail #fmt[\"Unhandled type %s\", ty0_str]\n+          }\n+        };\n+\n+        let item = #fmt[\"fn %s(cx: ctxt, v: %s) {\\\n+                             %s;\\\n+                         }\", name, ty0_str, body_node];\n+        self.add_item(item);\n+        ret name;\n+    }\n+\n+    fn serialize_enum(v: ast_expr,\n+                      id: ast::def_id,\n+                      tps: [ty::t]) -> ast_expr {\n+        let path = [];\n+        let variants = ty::substd_enum_variants(self.tcx, id, tps);\n+\n+        let arms = vec::map(variants) {|variant|\n+            let v_path = self.path(path, variant.name);\n+            let n_args = vec::len(variant.args);\n+            let (v_pat, stmts) = {\n+                if n_args == 0u {\n+                    (v_path, [])\n+                } else {\n+                    self.serialize_arm(v_path, variant.args)\n+                }\n+            };\n+\n+            let v_const = #fmt[\"at_%s\", self.ident(path, variant.name)];\n+\n+            #fmt[\"%s { \\\n+                    start_variant(cx, %s); \\\n+                    %s \\\n+                    end_variant(cx, %s); \\\n+                  }\", v_pat, v_const, self.blk(stmts), v_const]\n+        };\n+\n+        #fmt[\"alt %s { \\\n+                %s \\\n+              }\", v, str::connect(arms, \"\\n\")]\n+    }\n+\n+    fn serialize_arm(v_path: str, args: [ty::t]) -> (ast_pat, [ast_stmt]) {\n+        let n_args = vec::len(args);\n+        let arg_nms = vec::init_fn(n_args) {|i| #fmt[\"v%u\", i] };\n+        let v_pat =\n+            #fmt[\"%s(%s)\", v_path, str::connect(arg_nms, \", \")];\n+        let stmts = vec::init_fn(n_args) {|i|\n+            let arg_ty = args[i];\n+            let serialize_expr =\n+                self.serialize_ty(arg_ty, arg_nms[i]);\n+            #fmt[\"%s;\", serialize_expr]\n+        };\n+        (v_pat, stmts)\n+    }\n+}\n+\n+fn main(argv: [str]) {\n+    let {crate, tcx, roots} = parse(argv);\n+    let sctx: serialize_ctx = {\n+        // let cm = codemap::new_codemap();\n+        // let handler = diagnostic::mk_handler(option::none);\n+        // let psess: parser::parse_sess = @{\n+        //     cm: cm,\n+        //     mutable next_id: 1,\n+        //     span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n+        //     mutable chpos: 0u,\n+        //     mutable byte_pos: 0u\n+        // };\n+        {crate: crate,\n+         tcx: tcx,\n+         tyfns: ty::new_ty_hash::<str>(),\n+         mutable item_fns: [],\n+         mutable constants: []}\n+    };\n+\n+    vec::iter(roots) {|root|\n+        sctx.mk_serialize_named_item_fn(root);\n+    }\n+\n+    let stdout = io::stdout();\n+    vec::iter(copy sctx.item_fns) {|item|\n+        stdout.write_str(#fmt[\"%s\\n\", item])\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c7161e07a27565e8770005c7e039e69b856d44f2", "filename": "src/serializer/stest.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fserializer%2Fstest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcb54f4dc44957c9505958655a16e678ee4396b/src%2Fserializer%2Fstest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fstest.rs?ref=dbcb54f4dc44957c9505958655a16e678ee4396b", "patch": "@@ -0,0 +1,31 @@\n+// Testing types for the serializer.  This should be made more formal.\n+\n+enum test1 {\n+    t1_a(int), t1_b(str)\n+}\n+\n+type test2 = {\n+    f: int, g: str\n+};\n+\n+enum test3 {\n+    t3_a, t3_b\n+}\n+\n+enum test4 {\n+    t4_a(test1), t4_b(test2), t4_c(@test2), t4_d(@test4)\n+}\n+\n+type spanned<A> = {\n+    node: A,\n+    span: { lo: uint, hi: uint }\n+};\n+\n+type test5 = {\n+    s1: spanned<test4>,\n+    s2: spanned<uint>\n+};\n+\n+type test6 = option<int>;\n+\n+fn main() {}\n\\ No newline at end of file"}]}