{"sha": "b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "node_id": "C_kwDOAAsO6NoAKGIwY2YwZThjMDY1M2FhYjJjODlkZTdiNWUxZWYzNGEyNGJmOGVhODA", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-11-20T15:36:15Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-01-02T19:57:38Z"}, "message": "WIP", "tree": {"sha": "6b3dc5c5c837fb703060e595e36d1eb5da66c259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b3dc5c5c837fb703060e595e36d1eb5da66c259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "html_url": "https://github.com/rust-lang/rust/commit/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/889a33a500982cfc2c79ceff1b2caf86c0adbeaa", "html_url": "https://github.com/rust-lang/rust/commit/889a33a500982cfc2c79ceff1b2caf86c0adbeaa"}], "stats": {"total": 39, "additions": 19, "deletions": 20}, "files": [{"sha": "082b7be8c4e30dd296c7e90f1956879b5b268531", "filename": "src/builder.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "patch": "@@ -467,7 +467,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n         try_block.end_with_jump(None, then);\n \n-        self.block.add_try_catch(None, try_block, catch);\n+        if self.cleanup_blocks.borrow().contains(&catch) {\n+            self.block.add_try_finally(None, try_block, catch);\n+        }\n+        else {\n+            // FIXME: FIXME: FIXME: Seems like bad (_URC_NO_REASON) return code, perhaps because the cleanup pad was created properly.\n+            // FIXME: Wrong personality function: __gcc_personality_v0\n+            println!(\"Try/catch in {:?}\", self.current_func());\n+            self.block.add_try_catch(None, try_block, catch);\n+        }\n \n         self.block.end_with_jump(None, then);\n \n@@ -1202,12 +1210,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n         self.set_personality_fn(pers_fn);\n \n+        self.cleanup_blocks.borrow_mut().insert(self.block);\n+\n         // FIXME: we're probably not creating a real cleanup pad here.\n-        // FIXME: FIXME: FIXME: It seems to be the actual problem:\n+        // FIXME: It seems to be the actual problem:\n         // libunwind finds a catch, so returns _URC_HANDLER_FOUND instead of _URC_CONTINUE_UNWIND.\n         // TODO: can we generate a goto from the finally to the cleanup landing pad?\n-        // TODO: TODO: TODO: add this block to a cleanup_blocks variable and generate a try/finally instead if\n+        // TODO: add this block to a cleanup_blocks variable and generate a try/finally instead if\n         // the catch block for it is a cleanup block.\n+        // => NO, a cleanup is only called during unwinding.\n         //\n         // TODO: look at TRY_CATCH_IS_CLEANUP, CLEANUP_POINT_EXPR, WITH_CLEANUP_EXPR, CLEANUP_EH_ONLY.\n         let eh_pointer_builtin = self.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n@@ -1223,13 +1234,14 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.add_assignment(None, value.access_field(None, field1), ptr);\n         self.block.add_assignment(None, value.access_field(None, field2), zero); // TODO: set the proper value here (the type of exception?).\n \n+        /*\n         // Resume.\n         let param = self.context.new_parameter(None, ptr.get_type(), \"exn\");\n         // TODO: should we call __builtin_unwind_resume instead?\n         // FIXME: should probably not called resume because it could be executed (I believe) in\n         // normal (no exception) cases\n         let unwind_resume = self.context.new_function(None, FunctionType::Extern, self.type_void(), &[param], \"_Unwind_Resume\", false);\n-        self.block.add_eval(None, self.context.new_call(None, unwind_resume, &[ptr]));\n+        self.block.add_eval(None, self.context.new_call(None, unwind_resume, &[ptr]));*/\n \n         value.to_rvalue()\n     }"}, {"sha": "496b8578bc3dbfb1dca7189a1e6ce35de258f928", "filename": "src/callee.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "patch": "@@ -25,16 +25,9 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>,\n     let sym = tcx.symbol_name(instance).name;\n \n     if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n-        if sym == \"rust_eh_personality\" {\n-            println!(\"Cached\");\n-        }\n         return func;\n     }\n \n-    if sym == \"rust_eh_personality\" {\n-        println!(\"Not cached\");\n-    }\n-\n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n@@ -179,9 +172,6 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>,\n         };\n \n     //if !dont_cache {\n-    if sym == \"rust_eh_personality\" {\n-        println!(\"Caching here\");\n-    }\n         cx.function_instances.borrow_mut().insert(instance, func);\n     //}\n "}, {"sha": "62e30679efa5fe741a713dcfa3bed575ef924b40", "filename": "src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "patch": "@@ -120,6 +120,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// they can be dereferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n+\n+    pub cleanup_blocks: RefCell<FxHashSet<Block<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -250,6 +252,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             rust_try_fn: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n+            cleanup_blocks: Default::default(),\n         }\n     }\n "}, {"sha": "3b7f9a0b6bc2fb8ebc207e145150bfd1a2eb8519", "filename": "src/mono_item.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=b0cf0e8c0653aab2c89de7b5e1ef34a24bf8ea80", "patch": "@@ -35,9 +35,6 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        if symbol_name == \"rust_eh_personality\" {\n-            println!(\"********************* Generating real rust_eh_personality: {:?}\", base::linkage_to_gcc(linkage));\n-        }\n         let decl = self.declare_fn(symbol_name, &fn_abi, false);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n@@ -64,9 +61,6 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo): use inline attribute from there in linkage.set() above.\n \n         self.functions.borrow_mut().insert(symbol_name.to_string(), decl);\n-        if symbol_name == \"rust_eh_personality\" {\n-            println!(\"Caching here 2\");\n-        }\n         self.function_instances.borrow_mut().insert(instance, unsafe { std::mem::transmute(decl) });\n     }\n }"}]}