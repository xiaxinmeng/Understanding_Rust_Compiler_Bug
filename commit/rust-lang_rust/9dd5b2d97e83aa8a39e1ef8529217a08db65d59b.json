{"sha": "9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZDViMmQ5N2U4M2FhOGEzOWUxZWY4NTI5MjE3YTA4ZGI2NWQ1OWI=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-11T18:23:47Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-11T18:23:47Z"}, "message": "Merge commit '43a1777b89cf6791f9e20878b4e5e3ae907867a5' into clippyup", "tree": {"sha": "8c106d8fe62fa3963f221f66e5c6f93b6fc6842a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c106d8fe62fa3963f221f66e5c6f93b6fc6842a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl65mDYACgkQaTCGhp1Q\nZjdIqw//dxAR3ix7Q4uyAvKWlXKX40aXtg/2EIPEUqwoZlySd7hWnmi5/Ux7HZa9\na2VFiZoSAHxm+r4JLfecSJXRohJYeYEUc3QjiJsAo+B78gX9FtUvde5qrM+BKcgM\nadd7jUSghcSa9nvovpb5NjFsTIDLgZBbNPb6hSlRPuh7Ucj5eW6E2/qeH87VjJB0\n8nV+hPo5hf2u3jnPY2SY9wslC0nAykBoxc0JBtrSY7WSnRr7r5fk0p8JYjOtgvzI\nqTYmKQbqYC+cSdKGtEkamT/6Jpdqr4xBNpnGOfx82uLwjwsqH3kMZaMCSkM8EWXv\n74cPn2IMouX+DTO4cmnSYWxc2Cj22i8JdzeDqrsusQOXB9nbNKoTYnYJUeQaKnan\nS2nCrgpCtKVW6reBoV4iDpN3g5RW6JCr8SkTcvhIHb/0P2JlWTP3bwo9BmZP6vi2\nLRiEi7TRfHtPSZjbPTMK95Xa21U9o8mInrCsUdM+GUq9xRRbIflPlgCiIHd/tIUO\nI5Jn0hlCl48NgY3F0DDrON0aKIznq/J+Fzw12Ue+eN3AOyT5kN8Q/vGas9fMd+gG\nzLtSlDkAqF23dOT8LhUgvf2dg3NhcdoDpWvwZrdLEOfbRMwhm4TjEi0f7fmgfJQS\n+AHUaK/l8tZxdNyhjF3jXFnSMxzlb+HgXO2s8rH78m29bpTu/wU=\n=ZjDs\n-----END PGP SIGNATURE-----", "payload": "tree 8c106d8fe62fa3963f221f66e5c6f93b6fc6842a\nparent 3fe4dd2dda2826643c4ce4ee7307707a90e08d25\nparent 43a1777b89cf6791f9e20878b4e5e3ae907867a5\nauthor flip1995 <hello@philkrones.com> 1589221427 +0200\ncommitter flip1995 <hello@philkrones.com> 1589221427 +0200\n\nMerge commit '43a1777b89cf6791f9e20878b4e5e3ae907867a5' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "html_url": "https://github.com/rust-lang/rust/commit/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fe4dd2dda2826643c4ce4ee7307707a90e08d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe4dd2dda2826643c4ce4ee7307707a90e08d25", "html_url": "https://github.com/rust-lang/rust/commit/3fe4dd2dda2826643c4ce4ee7307707a90e08d25"}, {"sha": "43a1777b89cf6791f9e20878b4e5e3ae907867a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/43a1777b89cf6791f9e20878b4e5e3ae907867a5", "html_url": "https://github.com/rust-lang/rust/commit/43a1777b89cf6791f9e20878b4e5e3ae907867a5"}], "stats": {"total": 1831, "additions": 1574, "deletions": 257}, "files": [{"sha": "8457d6ad05cf9d876fe7739d364189234bb9980d", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1422,7 +1422,9 @@ Released 2018-09-13\n [`lossy_float_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#lossy_float_literal\n [`macro_use_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#macro_use_imports\n [`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n+[`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n+[`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names"}, {"sha": "6999b6bd74040746afb6ac394a436d65ac05d4e3", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -31,7 +31,6 @@ path = \"src/driver.rs\"\n # begin automatic update\n clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n # end automatic update\n-regex = \"1\"\n semver = \"0.9\"\n rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n tempfile = { version = \"3.1.0\", optional = true }"}, {"sha": "51b5401da7d00e65ce96ccac97d70d34ebcd5f69", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -247,6 +247,8 @@ mod literal_representation;\n mod loops;\n mod macro_use;\n mod main_recursion;\n+mod manual_async_fn;\n+mod manual_non_exhaustive;\n mod map_clone;\n mod map_unit_fn;\n mod match_on_vec_items;\n@@ -628,6 +630,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::WHILE_LET_ON_ITERATOR,\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n+        &manual_async_fn::MANUAL_ASYNC_FN,\n+        &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -1054,7 +1058,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let max_struct_bools = conf.max_struct_bools;\n     store.register_early_pass(move || box excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools));\n     store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n-    store.register_late_pass(|| box wildcard_imports::WildcardImports);\n+    let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n+    store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n     store.register_early_pass(|| box macro_use::MacroUseImports);\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n@@ -1064,6 +1069,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n+    store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n+    store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1138,6 +1145,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_INTO_ITER_LOOP),\n         LintId::of(&loops::EXPLICIT_ITER_LOOP),\n         LintId::of(&macro_use::MACRO_USE_IMPORTS),\n+        LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::SINGLE_MATCH_ELSE),\n         LintId::of(&methods::FILTER_MAP),\n@@ -1280,10 +1288,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n-        LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_AS_REF),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n@@ -1474,6 +1483,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n@@ -1647,7 +1658,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEVER_LOOP),\n         LintId::of(&loops::REVERSE_RANGE_LOOP),\n         LintId::of(&loops::WHILE_IMMUTABLE_CONDITION),\n-        LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_UNINIT),\n         LintId::of(&methods::CLONE_DOUBLE_REF),"}, {"sha": "2bbf4dba614b41970f846d8175d995a06fca8ba6", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 176, "deletions": 185, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -10,7 +10,6 @@ use crate::utils::{\n };\n use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sext, sugg};\n use if_chain::if_chain;\n-use itertools::Itertools;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n@@ -772,40 +771,48 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n-        if let ExprKind::Path(ref qpath) = expr.kind;\n-        if let QPath::Resolved(None, ref path) = *qpath;\n+        if let ExprKind::Path(qpath) = &expr.kind;\n+        if let QPath::Resolved(None, path) = qpath;\n         if path.segments.len() == 1;\n         if let Res::Local(local_id) = qpath_res(cx, qpath, expr.hir_id);\n-        // our variable!\n-        if local_id == var;\n         then {\n-            return true;\n+            // our variable!\n+            local_id == var\n+        } else {\n+            false\n         }\n     }\n+}\n \n-    false\n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n }\n \n struct Offset {\n     value: String,\n-    negate: bool,\n+    sign: OffsetSign,\n }\n \n impl Offset {\n-    fn negative(s: String) -> Self {\n-        Self { value: s, negate: true }\n+    fn negative(value: String) -> Self {\n+        Self {\n+            value,\n+            sign: OffsetSign::Negative,\n+        }\n     }\n \n-    fn positive(s: String) -> Self {\n+    fn positive(value: String) -> Self {\n         Self {\n-            value: s,\n-            negate: false,\n+            value,\n+            sign: OffsetSign::Positive,\n         }\n     }\n }\n \n-struct FixedOffsetVar {\n-    var_name: String,\n+struct FixedOffsetVar<'hir> {\n+    var: &'hir Expr<'hir>,\n     offset: Offset,\n }\n \n@@ -819,10 +826,20 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     is_slice || is_type_diagnostic_item(cx, ty, sym!(vec_type)) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n }\n \n-fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> Option<FixedOffsetVar> {\n+fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method, _, args) = expr.kind;\n+        if method.ident.name == sym!(clone);\n+        if args.len() == 1;\n+        if let Some(arg) = args.get(0);\n+        then { arg } else { expr }\n+    }\n+}\n+\n+fn get_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n-        match e.kind {\n-            ExprKind::Lit(ref l) => match l.node {\n+        match &e.kind {\n+            ExprKind::Lit(l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n@@ -831,115 +848,139 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, v\n         }\n     }\n \n-    if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind {\n-        let ty = cx.tables.expr_ty(seqexpr);\n-        if !is_slice_like(cx, ty) {\n-            return None;\n-        }\n-\n-        let offset = match idx.kind {\n-            ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n-                BinOpKind::Add => {\n-                    let offset_opt = if same_var(cx, lhs, var) {\n-                        extract_offset(cx, rhs, var)\n-                    } else if same_var(cx, rhs, var) {\n-                        extract_offset(cx, lhs, var)\n-                    } else {\n-                        None\n-                    };\n-\n-                    offset_opt.map(Offset::positive)\n-                },\n-                BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n-                _ => None,\n-            },\n-            ExprKind::Path(..) => {\n-                if same_var(cx, idx, var) {\n-                    Some(Offset::positive(\"0\".into()))\n+    match idx.kind {\n+        ExprKind::Binary(op, lhs, rhs) => match op.node {\n+            BinOpKind::Add => {\n+                let offset_opt = if same_var(cx, lhs, var) {\n+                    extract_offset(cx, rhs, var)\n+                } else if same_var(cx, rhs, var) {\n+                    extract_offset(cx, lhs, var)\n                 } else {\n                     None\n-                }\n+                };\n+\n+                offset_opt.map(Offset::positive)\n             },\n+            BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n             _ => None,\n-        };\n-\n-        offset.map(|o| FixedOffsetVar {\n-            var_name: snippet_opt(cx, seqexpr.span).unwrap_or_else(|| \"???\".into()),\n-            offset: o,\n-        })\n-    } else {\n-        None\n-    }\n-}\n-\n-fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &Expr<'_>,\n-    var: HirId,\n-) -> Option<FixedOffsetVar> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n-        if method.ident.name == sym!(clone);\n-        if args.len() == 1;\n-        if let Some(arg) = args.get(0);\n-        then {\n-            return get_fixed_offset_var(cx, arg, var);\n-        }\n+        },\n+        ExprKind::Path(..) if same_var(cx, idx, var) => Some(Offset::positive(\"0\".into())),\n+        _ => None,\n     }\n-\n-    get_fixed_offset_var(cx, expr, var)\n }\n \n-fn get_indexed_assignments<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    body: &Expr<'_>,\n-    var: HirId,\n-) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n-    fn get_assignment<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n-        e: &Expr<'_>,\n-        var: HirId,\n-    ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let ExprKind::Assign(ref lhs, ref rhs, _) = e.kind {\n-            match (\n-                get_fixed_offset_var(cx, lhs, var),\n-                fetch_cloned_fixed_offset_var(cx, rhs, var),\n-            ) {\n-                (Some(offset_left), Some(offset_right)) => {\n-                    // Source and destination must be different\n-                    if offset_left.var_name == offset_right.var_name {\n-                        None\n-                    } else {\n-                        Some((offset_left, offset_right))\n-                    }\n-                },\n-                _ => None,\n-            }\n+fn get_assignments<'tcx>(body: &'tcx Expr<'tcx>) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> {\n+    fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+        if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+            Some((lhs, rhs))\n         } else {\n             None\n         }\n     }\n \n-    if let ExprKind::Block(ref b, _) = body.kind {\n-        let Block {\n-            ref stmts, ref expr, ..\n-        } = **b;\n+    // This is one of few ways to return different iterators\n+    // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+    let mut iter_a = None;\n+    let mut iter_b = None;\n+\n+    if let ExprKind::Block(b, _) = body.kind {\n+        let Block { stmts, expr, .. } = *b;\n \n-        stmts\n+        iter_a = stmts\n             .iter()\n-            .map(|stmt| match stmt.kind {\n+            .filter_map(|stmt| match stmt.kind {\n                 StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => Some(get_assignment(cx, e, var)),\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n             })\n-            .chain(expr.as_ref().into_iter().map(|e| Some(get_assignment(cx, &*e, var))))\n-            .filter_map(|op| op)\n-            .collect::<Option<Vec<_>>>()\n-            .unwrap_or_default()\n+            .chain(expr.into_iter())\n+            .map(get_assignment)\n+            .into()\n     } else {\n-        get_assignment(cx, body, var).into_iter().collect()\n+        iter_b = Some(get_assignment(body))\n     }\n+\n+    iter_a.into_iter().flatten().chain(iter_b.into_iter())\n }\n \n+fn build_manual_memcpy_suggestion<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    start: &Expr<'_>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    dst_var: FixedOffsetVar<'_>,\n+    src_var: FixedOffsetVar<'_>,\n+) -> String {\n+    fn print_sum(arg1: &str, arg2: &Offset) -> String {\n+        match (arg1, &arg2.value[..], arg2.sign) {\n+            (\"0\", \"0\", _) => \"0\".into(),\n+            (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n+            (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n+            (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n+            (x, y, OffsetSign::Negative) => {\n+                if x == y {\n+                    \"0\".into()\n+                } else {\n+                    format!(\"({} - {})\", x, y)\n+                }\n+            },\n+        }\n+    }\n+\n+    fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n+        let offset = print_sum(start_str, inline_offset);\n+        if offset.as_str() == \"0\" {\n+            \"\".into()\n+        } else {\n+            offset\n+        }\n+    }\n+\n+    let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n+        if_chain! {\n+            if let ExprKind::MethodCall(method, _, len_args) = end.kind;\n+            if method.ident.name == sym!(len);\n+            if len_args.len() == 1;\n+            if let Some(arg) = len_args.get(0);\n+            if var_def_id(cx, arg) == var_def_id(cx, var);\n+            then {\n+                match offset.sign {\n+                    OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n+                    OffsetSign::Positive => \"\".into(),\n+                }\n+            } else {\n+                let end_str = match limits {\n+                    ast::RangeLimits::Closed => {\n+                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                        format!(\"{}\", end + sugg::ONE)\n+                    },\n+                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n+                };\n+\n+                print_sum(&end_str, &offset)\n+            }\n+        }\n+    };\n+\n+    let start_str = snippet(cx, start.span, \"\").to_string();\n+    let dst_offset = print_offset(&start_str, &dst_var.offset);\n+    let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n+    let src_offset = print_offset(&start_str, &src_var.offset);\n+    let src_limit = print_limit(end, src_var.offset, src_var.var);\n+\n+    let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n+    let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n+\n+    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+        dst_var_name\n+    } else {\n+        format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n+    };\n+\n+    format!(\n+        \"{}.clone_from_slice(&{}[{}..{}])\",\n+        dst, src_var_name, src_offset, src_limit\n+    )\n+}\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'a, 'tcx>(\n@@ -951,93 +992,43 @@ fn detect_manual_memcpy<'a, 'tcx>(\n ) {\n     if let Some(higher::Range {\n         start: Some(start),\n-        ref end,\n+        end: Some(end),\n         limits,\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n-            let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n-                match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n-                    (\"0\", _, \"0\", _) => \"\".into(),\n-                    (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n-                    (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n-                    (x, false, y, false) => format!(\"({} + {})\", x, y),\n-                    (x, false, y, true) => {\n-                        if x == y {\n-                            \"0\".into()\n-                        } else {\n-                            format!(\"({} - {})\", x, y)\n-                        }\n-                    },\n-                    (x, true, y, false) => {\n-                        if x == y {\n-                            \"0\".into()\n-                        } else {\n-                            format!(\"({} - {})\", y, x)\n-                        }\n-                    },\n-                    (x, true, y, true) => format!(\"-({} + {})\", x, y),\n-                }\n-            };\n-\n-            let print_limit = |end: &Option<&Expr<'_>>, offset: Offset, var_name: &str| {\n-                if let Some(end) = *end {\n-                    if_chain! {\n-                        if let ExprKind::MethodCall(ref method, _, ref len_args) = end.kind;\n-                        if method.ident.name == sym!(len);\n-                        if len_args.len() == 1;\n-                        if let Some(arg) = len_args.get(0);\n-                        if snippet(cx, arg.span, \"??\") == var_name;\n-                        then {\n-                            return if offset.negate {\n-                                format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n-                            } else {\n-                                String::new()\n-                            };\n-                        }\n-                    }\n-\n-                    let end_str = match limits {\n-                        ast::RangeLimits::Closed => {\n-                            let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                            format!(\"{}\", end + sugg::ONE)\n-                        },\n-                        ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                    };\n-\n-                    print_sum(&Offset::positive(end_str), &offset)\n-                } else {\n-                    \"..\".into()\n-                }\n-            };\n-\n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n-            let manual_copies = get_indexed_assignments(cx, body, canonical_id);\n-\n-            let big_sugg = manual_copies\n-                .into_iter()\n-                .map(|(dst_var, src_var)| {\n-                    let start_str = Offset::positive(snippet(cx, start.span, \"\").to_string());\n-                    let dst_offset = print_sum(&start_str, &dst_var.offset);\n-                    let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n-                    let src_offset = print_sum(&start_str, &src_var.offset);\n-                    let src_limit = print_limit(end, src_var.offset, &src_var.var_name);\n-                    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-                        dst_var.var_name\n-                    } else {\n-                        format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n-                    };\n-\n-                    format!(\n-                        \"{}.clone_from_slice(&{}[{}..{}])\",\n-                        dst, src_var.var_name, src_offset, src_limit\n-                    )\n+            let big_sugg = get_assignments(body)\n+                .map(|o| {\n+                    o.and_then(|(lhs, rhs)| {\n+                        let rhs = fetch_cloned_expr(rhs);\n+                        if_chain! {\n+                            if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.tables.expr_ty(seqexpr_left))\n+                                && is_slice_like(cx, cx.tables.expr_ty(seqexpr_right));\n+                            if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n+                            if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n+\n+                            // Source and destination must be different\n+                            if var_def_id(cx, seqexpr_left) != var_def_id(cx, seqexpr_right);\n+                            then {\n+                                Some((FixedOffsetVar { var: seqexpr_left, offset: offset_left },\n+                                    FixedOffsetVar { var: seqexpr_right, offset: offset_right }))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    })\n                 })\n-                .join(\"\\n    \");\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, dst, src)))\n+                .collect::<Option<Vec<_>>>()\n+                .filter(|v| !v.is_empty())\n+                .map(|v| v.join(\"\\n    \"));\n \n-            if !big_sugg.is_empty() {\n+            if let Some(big_sugg) = big_sugg {\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,"}, {"sha": "cb72a24058234dcafce74496cc8431f2391f67db", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,159 @@\n+use crate::utils::paths::FUTURE_FROM_GENERATOR;\n+use crate::utils::{match_function_call, snippet_block, snippet_opt, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{\n+    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericBound, HirId, IsAsync,\n+    ItemKind, TraitRef, Ty, TyKind, TypeBindingKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** It checks for manual implementations of `async` functions.\n+    ///\n+    /// **Why is this bad?** It's more idiomatic to use the dedicated syntax.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::future::Future;\n+    ///\n+    /// fn foo() -> impl Future<Output = i32> { async { 42 } }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::future::Future;\n+    ///\n+    /// async fn foo() -> i32 { 42 }\n+    /// ```\n+    pub MANUAL_ASYNC_FN,\n+    style,\n+    \"manual implementations of `async` functions can be simplified using the dedicated syntax\"\n+}\n+\n+declare_lint_pass!(ManualAsyncFn => [MANUAL_ASYNC_FN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ManualAsyncFn {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        span: Span,\n+        _: HirId,\n+    ) {\n+        if_chain! {\n+            if let Some(header) = kind.header();\n+            if let IsAsync::NotAsync = header.asyncness;\n+            // Check that this function returns `impl Future`\n+            if let FnRetTy::Return(ret_ty) = decl.output;\n+            if let Some(trait_ref) = future_trait_ref(cx, ret_ty);\n+            if let Some(output) = future_output_ty(trait_ref);\n+            // Check that the body of the function consists of one async block\n+            if let ExprKind::Block(block, _) = body.value.kind;\n+            if block.stmts.is_empty();\n+            if let Some(closure_body) = desugared_async_block(cx, block);\n+            then {\n+                let header_span = span.with_hi(ret_ty.span.hi());\n+\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_ASYNC_FN,\n+                    header_span,\n+                    \"this function can be simplified using the `async fn` syntax\",\n+                    |diag| {\n+                        if_chain! {\n+                            if let Some(header_snip) = snippet_opt(cx, header_span);\n+                            if let Some(ret_pos) = header_snip.rfind(\"->\");\n+                            if let Some((ret_sugg, ret_snip)) = suggested_ret(cx, output);\n+                            then {\n+                                let help = format!(\"make the function `async` and {}\", ret_sugg);\n+                                diag.span_suggestion(\n+                                    header_span,\n+                                    &help,\n+                                    format!(\"async {}{}\", &header_snip[..ret_pos], ret_snip),\n+                                    Applicability::MachineApplicable\n+                                );\n+\n+                                let body_snip = snippet_block(cx, closure_body.value.span, \"..\", Some(block.span));\n+                                diag.span_suggestion(\n+                                    block.span,\n+                                    \"move the body of the async block to the enclosing function\",\n+                                    body_snip.to_string(),\n+                                    Applicability::MachineApplicable\n+                                );\n+                            }\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn future_trait_ref<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n+    if_chain! {\n+        if let TyKind::Def(item_id, _) = ty.kind;\n+        let item = cx.tcx.hir().item(item_id.id);\n+        if let ItemKind::OpaqueTy(opaque) = &item.kind;\n+        if opaque.bounds.len() == 1;\n+        if let GenericBound::Trait(poly, _) = &opaque.bounds[0];\n+        if poly.trait_ref.trait_def_id() == cx.tcx.lang_items().future_trait();\n+        then {\n+            return Some(&poly.trait_ref);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'tcx>> {\n+    if_chain! {\n+        if let Some(segment) = trait_ref.path.segments.last();\n+        if let Some(args) = segment.args;\n+        if args.bindings.len() == 1;\n+        let binding = &args.bindings[0];\n+        if binding.ident.as_str() == \"Output\";\n+        if let TypeBindingKind::Equality{ty: output} = binding.kind;\n+        then {\n+            return Some(output)\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn desugared_async_block<'tcx>(cx: &LateContext<'_, 'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n+    if_chain! {\n+        if let Some(block_expr) = block.expr;\n+        if let Some(args) = match_function_call(cx, block_expr, &FUTURE_FROM_GENERATOR);\n+        if args.len() == 1;\n+        if let Expr{kind: ExprKind::Closure(_, _, body_id, ..), ..} = args[0];\n+        let closure_body = cx.tcx.hir().body(body_id);\n+        if let Some(GeneratorKind::Async(AsyncGeneratorKind::Block)) = closure_body.generator_kind;\n+        then {\n+            return Some(closure_body);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn suggested_ret(cx: &LateContext<'_, '_>, output: &Ty<'_>) -> Option<(&'static str, String)> {\n+    match output.kind {\n+        TyKind::Tup(tys) if tys.is_empty() => {\n+            let sugg = \"remove the return type\";\n+            Some((sugg, \"\".into()))\n+        },\n+        _ => {\n+            let sugg = \"return the output of the future directly\";\n+            snippet_opt(cx, output.span).map(|snip| (sugg, format!(\"-> {}\", snip)))\n+        },\n+    }\n+}"}, {"sha": "f3b8902e26f672f4df92b63f07da040c67734b44", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::{snippet_opt, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{Attribute, Item, ItemKind, StructField, Variant, VariantData, VisibilityKind};\n+use rustc_attr as attr;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n+    ///\n+    /// **Why is this bad?** Using the #[non_exhaustive] attribute expresses better the intent\n+    /// and allows possible optimizations when applied to enums.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct S {\n+    ///     pub a: i32,\n+    ///     pub b: i32,\n+    ///     _c: (),\n+    /// }\n+    ///\n+    /// enum E {\n+    ///     A,\n+    ///     B,\n+    ///     #[doc(hidden)]\n+    ///     _C,\n+    /// }\n+    ///\n+    /// struct T(pub i32, pub i32, ());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[non_exhaustive]\n+    /// struct S {\n+    ///     pub a: i32,\n+    ///     pub b: i32,\n+    /// }\n+    ///\n+    /// #[non_exhaustive]\n+    /// enum E {\n+    ///     A,\n+    ///     B,\n+    /// }\n+    ///\n+    /// #[non_exhaustive]\n+    /// struct T(pub i32, pub i32);\n+    /// ```\n+    pub MANUAL_NON_EXHAUSTIVE,\n+    style,\n+    \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n+}\n+\n+declare_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+\n+impl EarlyLintPass for ManualNonExhaustive {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        match &item.kind {\n+            ItemKind::Enum(def, _) => {\n+                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n+            },\n+            ItemKind::Struct(variant_data, _) => {\n+                if let VariantData::Unit(..) = variant_data {\n+                    return;\n+                }\n+\n+                check_manual_non_exhaustive_struct(cx, item, variant_data);\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n+    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n+        matches!(variant.data, VariantData::Unit(_))\n+            && variant.ident.as_str().starts_with('_')\n+            && variant.attrs.iter().any(|a| is_doc_hidden(a))\n+    }\n+\n+    fn is_doc_hidden(attr: &Attribute) -> bool {\n+        attr.check_name(sym!(doc))\n+            && match attr.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym!(hidden)),\n+                None => false,\n+            }\n+    }\n+\n+    if_chain! {\n+        let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n+        if let Some(marker) = markers.next();\n+        if markers.count() == 0 && variants.len() > 1;\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_NON_EXHAUSTIVE,\n+                item.span,\n+                \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                |diag| {\n+                    if_chain! {\n+                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n+                        if let Some(snippet) = snippet_opt(cx, header_span);\n+                        then {\n+                            diag.span_suggestion(\n+                                header_span,\n+                                \"add the attribute\",\n+                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                    diag.span_help(marker.span, \"remove this variant\");\n+                });\n+        }\n+    }\n+}\n+\n+fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n+    fn is_private(field: &StructField) -> bool {\n+        matches!(field.vis.node, VisibilityKind::Inherited)\n+    }\n+\n+    fn is_non_exhaustive_marker(field: &StructField) -> bool {\n+        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+    }\n+\n+    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n+        let delimiter = match data {\n+            VariantData::Struct(..) => '{',\n+            VariantData::Tuple(..) => '(',\n+            VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n+        };\n+\n+        cx.sess.source_map().span_until_char(item.span, delimiter)\n+    }\n+\n+    let fields = data.fields();\n+    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n+    let public_fields = fields.iter().filter(|f| f.vis.node.is_pub()).count();\n+\n+    if_chain! {\n+        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n+        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_NON_EXHAUSTIVE,\n+                item.span,\n+                \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                |diag| {\n+                    if_chain! {\n+                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        let header_span = find_header_span(cx, item, data);\n+                        if let Some(snippet) = snippet_opt(cx, header_span);\n+                        then {\n+                            diag.span_suggestion(\n+                                header_span,\n+                                \"add the attribute\",\n+                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                    diag.span_help(marker.span, \"remove this field\");\n+                });\n+        }\n+    }\n+}"}, {"sha": "ee69628e9f05224953a8e9d3680f83c263efe6ef", "filename": "src/tools/clippy/clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{self, is_type_diagnostic_item, match_type, snippet, span_lint_and_sugg, walk_ptrs_ty};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, MatchSource};\n@@ -38,7 +38,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub MATCH_ON_VEC_ITEMS,\n-    correctness,\n+    pedantic,\n     \"matching on vector elements can panic\"\n }\n \n@@ -75,10 +75,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchOnVecItems {\n \n fn is_vec_indexing<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::Index(ref array, _) = expr.kind;\n-        let ty = cx.tables.expr_ty(array);\n-        let ty = walk_ptrs_ty(ty);\n-        if is_type_diagnostic_item(cx, ty, sym!(vec_type));\n+        if let ExprKind::Index(ref array, ref index) = expr.kind;\n+        if is_vector(cx, array);\n+        if !is_full_range(cx, index);\n \n         then {\n             return Some(expr);\n@@ -87,3 +86,15 @@ fn is_vec_indexing<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>)\n \n     None\n }\n+\n+fn is_vector(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.tables.expr_ty(expr);\n+    let ty = walk_ptrs_ty(ty);\n+    is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+}\n+\n+fn is_full_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.tables.expr_ty(expr);\n+    let ty = walk_ptrs_ty(ty);\n+    match_type(cx, ty, &utils::paths::RANGE_FULL)\n+}"}, {"sha": "62ee051624b488afe3411b463204516acf408169", "filename": "src/tools/clippy/clippy_lints/src/misc_early.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -24,8 +24,25 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ```ignore\n-    /// let { a: _, b: ref b, c: _ } = ..\n+    /// ```rust\n+    /// # struct Foo {\n+    /// #     a: i32,\n+    /// #     b: i32,\n+    /// #     c: i32,\n+    /// # }\n+    /// let f = Foo { a: 0, b: 0, c: 0 };\n+    ///\n+    /// // Bad\n+    /// match f {\n+    ///     Foo { a: _, b: 0, .. } => {},\n+    ///     Foo { a: _, b: _, c: _ } => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match f {\n+    ///     Foo { b: 0, .. } => {},\n+    ///     Foo { .. } => {},\n+    /// }\n     /// ```\n     pub UNNEEDED_FIELD_PATTERN,\n     restriction,"}, {"sha": "f3844c7d3b68f4f7e37449a3640c879a2691990e", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1,4 +1,7 @@\n-use crate::utils::{higher::if_block, is_type_diagnostic_item, span_lint_and_then, usage::is_potentially_mutated};\n+use crate::utils::{\n+    differing_macro_contexts, higher::if_block, is_type_diagnostic_item, span_lint_and_then,\n+    usage::is_potentially_mutated,\n+};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, Path, QPath, UnOp};\n@@ -73,6 +76,8 @@ struct UnwrapInfo<'tcx> {\n     ident: &'tcx Path<'tcx>,\n     /// The check, like `x.is_ok()`\n     check: &'tcx Expr<'tcx>,\n+    /// The branch where the check takes place, like `if x.is_ok() { .. }`\n+    branch: &'tcx Expr<'tcx>,\n     /// Whether `is_some()` or `is_ok()` was called (as opposed to `is_err()` or `is_none()`).\n     safe_to_unwrap: bool,\n }\n@@ -82,19 +87,20 @@ struct UnwrapInfo<'tcx> {\n fn collect_unwrap_info<'a, 'tcx>(\n     cx: &'a LateContext<'a, 'tcx>,\n     expr: &'tcx Expr<'_>,\n+    branch: &'tcx Expr<'_>,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n         match (invert, op.node) {\n             (false, BinOpKind::And) | (false, BinOpKind::BitAnd) | (true, BinOpKind::Or) | (true, BinOpKind::BitOr) => {\n-                let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n-                unwrap_info.append(&mut collect_unwrap_info(cx, right, invert));\n+                let mut unwrap_info = collect_unwrap_info(cx, left, branch, invert);\n+                unwrap_info.append(&mut collect_unwrap_info(cx, right, branch, invert));\n                 return unwrap_info;\n             },\n             _ => (),\n         }\n     } else if let ExprKind::Unary(UnOp::UnNot, expr) = &expr.kind {\n-        return collect_unwrap_info(cx, expr, !invert);\n+        return collect_unwrap_info(cx, expr, branch, !invert);\n     } else {\n         if_chain! {\n             if let ExprKind::MethodCall(method_name, _, args) = &expr.kind;\n@@ -111,7 +117,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n                     _ => unreachable!(),\n                 };\n                 let safe_to_unwrap = unwrappable != invert;\n-                return vec![UnwrapInfo { ident: path, check: expr, safe_to_unwrap }];\n+                return vec![UnwrapInfo { ident: path, check: expr, branch, safe_to_unwrap }];\n             }\n         }\n     }\n@@ -121,7 +127,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n impl<'a, 'tcx> UnwrappableVariablesVisitor<'a, 'tcx> {\n     fn visit_branch(&mut self, cond: &'tcx Expr<'_>, branch: &'tcx Expr<'_>, else_branch: bool) {\n         let prev_len = self.unwrappables.len();\n-        for unwrap_info in collect_unwrap_info(self.cx, cond, else_branch) {\n+        for unwrap_info in collect_unwrap_info(self.cx, cond, branch, else_branch) {\n             if is_potentially_mutated(unwrap_info.ident, cond, self.cx)\n                 || is_potentially_mutated(unwrap_info.ident, branch, self.cx)\n             {\n@@ -158,6 +164,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                 let call_to_unwrap = method_name.ident.name == sym!(unwrap);\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.ident.res == path.res);\n+                // Span contexts should not differ with the conditional branch\n+                if !differing_macro_contexts(unwrappable.branch.span, expr.span);\n+                if !differing_macro_contexts(unwrappable.branch.span, unwrappable.check.span);\n                 then {\n                     if call_to_unwrap == unwrappable.safe_to_unwrap {\n                         span_lint_and_then("}, {"sha": "57b9eafd14dbd4a8760998f0a1662a486765b2b7", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -158,6 +158,8 @@ define_Conf! {\n     (max_struct_bools, \"max_struct_bools\": u64, 3),\n     /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bools function parameters can have\n     (max_fn_params_bools, \"max_fn_params_bools\": u64, 3),\n+    /// Lint: WILDCARD_IMPORTS. Whether to allow certain wildcard imports (prelude, super in tests).\n+    (warn_on_all_wildcard_imports, \"warn_on_all_wildcard_imports\": bool, false),\n }\n \n impl Default for Conf {"}, {"sha": "3b8ef18bfab8672a3dd4405655956d5002779ee8", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -933,6 +933,7 @@ pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Exp\n }\n \n /// Returns `true` if a pattern is refutable.\n+// TODO: should be implemented using rustc/mir_build/hair machinery\n pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, id: HirId) -> bool {\n         matches!(\n@@ -946,27 +947,34 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n     }\n \n     match pat.kind {\n-        PatKind::Binding(..) | PatKind::Wild => false,\n+        PatKind::Wild => false,\n+        PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n         PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n-        PatKind::Or(ref pats) | PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Or(ref pats) => {\n+            // TODO: should be the honest check, that pats is exhaustive set\n+            are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        },\n+        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n         PatKind::Struct(ref qpath, ref fields, _) => {\n-            if is_enum_variant(cx, qpath, pat.hir_id) {\n-                true\n-            } else {\n-                are_refutable(cx, fields.iter().map(|field| &*field.pat))\n-            }\n+            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n         },\n         PatKind::TupleStruct(ref qpath, ref pats, _) => {\n-            if is_enum_variant(cx, qpath, pat.hir_id) {\n-                true\n-            } else {\n-                are_refutable(cx, pats.iter().map(|pat| &**pat))\n-            }\n+            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n+            match &cx.tables.node_type(pat.hir_id).kind {\n+                ty::Slice(..) => {\n+                    // [..] is the only irrefutable slice pattern.\n+                    !head.is_empty() || middle.is_none() || !tail.is_empty()\n+                },\n+                ty::Array(..) => are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat)),\n+                _ => {\n+                    // unreachable!()\n+                    true\n+                },\n+            }\n         },\n     }\n }"}, {"sha": "b3ad2ad9d9987e73205b42299003e146a7c80bd6", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -42,6 +42,7 @@ pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n+pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n@@ -85,7 +86,7 @@ pub const RANGE: [&str; 3] = [\"core\", \"ops\", \"Range\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RANGE_FROM: [&str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n pub const RANGE_FROM_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n-pub const RANGE_FULL: [&str; 3] = [\"core\", \"ops\", \"RangeFull\"];\n+pub const RANGE_FULL: [&str; 4] = [\"core\", \"ops\", \"range\", \"RangeFull\"];\n pub const RANGE_FULL_STD: [&str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n pub const RANGE_INCLUSIVE_NEW: [&str; 4] = [\"core\", \"ops\", \"RangeInclusive\", \"new\"];\n pub const RANGE_INCLUSIVE_STD_NEW: [&str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"new\"];"}, {"sha": "32d9a45c37d78fea94190d3273cbf3844cab6b73", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 63, "deletions": 11, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -3,10 +3,10 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     def::{DefKind, Res},\n-    Item, ItemKind, UseKind,\n+    Item, ItemKind, PathSegment, UseKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::BytePos;\n \n declare_clippy_lint! {\n@@ -43,9 +43,14 @@ declare_clippy_lint! {\n     ///\n     /// This can lead to confusing error messages at best and to unexpected behavior at worst.\n     ///\n-    /// Note that this will not warn about wildcard imports from modules named `prelude`; many\n-    /// crates (including the standard library) provide modules named \"prelude\" specifically\n-    /// designed for wildcard import.\n+    /// **Exceptions:**\n+    ///\n+    /// Wildcard imports are allowed from modules named `prelude`. Many crates (including the standard library)\n+    /// provide modules named \"prelude\" specifically designed for wildcard import.\n+    ///\n+    /// `use super::*` is allowed in test modules. This is defined as any module with \"test\" in the name.\n+    ///\n+    /// These exceptions can be disabled using the `warn-on-all-wildcard-imports` configuration flag.\n     ///\n     /// **Known problems:** If macros are imported through the wildcard, this macro is not included\n     /// by the suggestion and has to be added by hand.\n@@ -73,18 +78,34 @@ declare_clippy_lint! {\n     \"lint `use _::*` statements\"\n }\n \n-declare_lint_pass!(WildcardImports => [ENUM_GLOB_USE, WILDCARD_IMPORTS]);\n+#[derive(Default)]\n+pub struct WildcardImports {\n+    warn_on_all: bool,\n+    test_modules_deep: u32,\n+}\n+\n+impl WildcardImports {\n+    pub fn new(warn_on_all: bool) -> Self {\n+        Self {\n+            warn_on_all,\n+            test_modules_deep: 0,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(WildcardImports => [ENUM_GLOB_USE, WILDCARD_IMPORTS]);\n \n impl LateLintPass<'_, '_> for WildcardImports {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item<'_>) {\n+        if is_test_module_or_function(item) {\n+            self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n+        }\n         if item.vis.node.is_pub() || item.vis.node.is_pub_restricted() {\n             return;\n         }\n         if_chain! {\n-            if !in_macro(item.span);\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n-            // don't lint prelude glob imports\n-            if !use_path.segments.iter().last().map_or(false, |ps| ps.ident.as_str() == \"prelude\");\n+            if self.warn_on_all || !self.check_exceptions(item, use_path.segments);\n             let used_imports = cx.tcx.names_imported_by_glob_use(item.hir_id.owner);\n             if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n@@ -109,8 +130,7 @@ impl LateLintPass<'_, '_> for WildcardImports {\n                         span = use_path.span.with_hi(item.span.hi() - BytePos(1));\n                     }\n                     (\n-                        span,\n-                        false,\n+                        span, false,\n                     )\n                 };\n \n@@ -153,4 +173,36 @@ impl LateLintPass<'_, '_> for WildcardImports {\n             }\n         }\n     }\n+\n+    fn check_item_post(&mut self, _: &LateContext<'_, '_>, item: &Item<'_>) {\n+        if is_test_module_or_function(item) {\n+            self.test_modules_deep = self.test_modules_deep.saturating_sub(1);\n+        }\n+    }\n+}\n+\n+impl WildcardImports {\n+    fn check_exceptions(&self, item: &Item<'_>, segments: &[PathSegment<'_>]) -> bool {\n+        in_macro(item.span)\n+            || is_prelude_import(segments)\n+            || (is_super_only_import(segments) && self.test_modules_deep > 0)\n+    }\n+}\n+\n+// Allow \"...prelude::*\" imports.\n+// Many crates have a prelude, and it is imported as a glob by design.\n+fn is_prelude_import(segments: &[PathSegment<'_>]) -> bool {\n+    segments\n+        .iter()\n+        .last()\n+        .map_or(false, |ps| ps.ident.as_str() == \"prelude\")\n+}\n+\n+// Allow \"super::*\" imports in tests.\n+fn is_super_only_import(segments: &[PathSegment<'_>]) -> bool {\n+    segments.len() == 1 && segments[0].ident.as_str() == \"super\"\n+}\n+\n+fn is_test_module_or_function(item: &Item<'_>) -> bool {\n+    matches!(item.kind, ItemKind::Mod(..)) && item.ident.name.as_str().contains(\"test\")\n }"}, {"sha": "51d1cb2216a954c55e5907abc8c5885af1ea1a10", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1081,13 +1081,27 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"main_recursion\",\n     },\n+    Lint {\n+        name: \"manual_async_fn\",\n+        group: \"style\",\n+        desc: \"manual implementations of `async` functions can be simplified using the dedicated syntax\",\n+        deprecation: None,\n+        module: \"manual_async_fn\",\n+    },\n     Lint {\n         name: \"manual_memcpy\",\n         group: \"perf\",\n         desc: \"manually copying items between slices\",\n         deprecation: None,\n         module: \"loops\",\n     },\n+    Lint {\n+        name: \"manual_non_exhaustive\",\n+        group: \"style\",\n+        desc: \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\",\n+        deprecation: None,\n+        module: \"manual_non_exhaustive\",\n+    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\",\n@@ -1146,7 +1160,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"match_on_vec_items\",\n-        group: \"correctness\",\n+        group: \"pedantic\",\n         desc: \"matching on vector elements can panic\",\n         deprecation: None,\n         module: \"match_on_vec_items\","}, {"sha": "53970af41079d5a952038fb4911e19bca40c4bc5", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-struct-bools`, `max-fn-params-bools`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "bc785b075e0282641b3f095be8e6c4665398f198", "filename": "src/tools/clippy/tests/ui/builtin-type-shadow.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbuiltin-type-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbuiltin-type-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fbuiltin-type-shadow.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -18,8 +18,6 @@ LL |     42\n    |\n    = note: expected type parameter `u32`\n                         found type `{integer}`\n-   = help: type parameters must be constrained to match other types\n-   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3e7b4b390bad48581244b7f66c666968af5db293", "filename": "src/tools/clippy/tests/ui/checked_unwrap/simple_conditionals.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -9,6 +9,30 @@ macro_rules! m {\n     };\n }\n \n+macro_rules! checks_in_param {\n+    ($a:expr, $b:expr) => {\n+        if $a {\n+            $b;\n+        }\n+    };\n+}\n+\n+macro_rules! checks_unwrap {\n+    ($a:expr, $b:expr) => {\n+        if $a.is_some() {\n+            $b;\n+        }\n+    };\n+}\n+\n+macro_rules! checks_some {\n+    ($a:expr, $b:expr) => {\n+        if $a {\n+            $b.unwrap();\n+        }\n+    };\n+}\n+\n fn main() {\n     let x = Some(());\n     if x.is_some() {\n@@ -22,6 +46,9 @@ fn main() {\n         x.unwrap(); // unnecessary\n     }\n     m!(x);\n+    checks_in_param!(x.is_some(), x.unwrap()); // ok\n+    checks_unwrap!(x, x.unwrap()); // ok\n+    checks_some!(x.is_some(), x); // ok\n     let mut x: Result<(), ()> = Ok(());\n     if x.is_ok() {\n         x.unwrap(); // unnecessary"}, {"sha": "4013d1ed667f16470d8abe497bfeff6562bb9ac2", "filename": "src/tools/clippy/tests/ui/checked_unwrap/simple_conditionals.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1,5 +1,5 @@\n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/simple_conditionals.rs:15:9\n+  --> $DIR/simple_conditionals.rs:39:9\n    |\n LL |     if x.is_some() {\n    |        ----------- the check is happening here\n@@ -13,7 +13,7 @@ LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: This call to `unwrap()` will always panic.\n-  --> $DIR/simple_conditionals.rs:17:9\n+  --> $DIR/simple_conditionals.rs:41:9\n    |\n LL |     if x.is_some() {\n    |        ----------- because of this check\n@@ -28,15 +28,15 @@ LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: This call to `unwrap()` will always panic.\n-  --> $DIR/simple_conditionals.rs:20:9\n+  --> $DIR/simple_conditionals.rs:44:9\n    |\n LL |     if x.is_none() {\n    |        ----------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/simple_conditionals.rs:22:9\n+  --> $DIR/simple_conditionals.rs:46:9\n    |\n LL |     if x.is_none() {\n    |        ----------- the check is happening here\n@@ -58,15 +58,15 @@ LL |     m!(x);\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/simple_conditionals.rs:27:9\n+  --> $DIR/simple_conditionals.rs:54:9\n    |\n LL |     if x.is_ok() {\n    |        --------- the check is happening here\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: This call to `unwrap_err()` will always panic.\n-  --> $DIR/simple_conditionals.rs:28:9\n+  --> $DIR/simple_conditionals.rs:55:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n@@ -75,7 +75,7 @@ LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n error: This call to `unwrap()` will always panic.\n-  --> $DIR/simple_conditionals.rs:30:9\n+  --> $DIR/simple_conditionals.rs:57:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n@@ -84,7 +84,7 @@ LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/simple_conditionals.rs:31:9\n+  --> $DIR/simple_conditionals.rs:58:9\n    |\n LL |     if x.is_ok() {\n    |        --------- the check is happening here\n@@ -93,15 +93,15 @@ LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: This call to `unwrap()` will always panic.\n-  --> $DIR/simple_conditionals.rs:34:9\n+  --> $DIR/simple_conditionals.rs:61:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/simple_conditionals.rs:35:9\n+  --> $DIR/simple_conditionals.rs:62:9\n    |\n LL |     if x.is_err() {\n    |        ---------- the check is happening here\n@@ -110,7 +110,7 @@ LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n-  --> $DIR/simple_conditionals.rs:37:9\n+  --> $DIR/simple_conditionals.rs:64:9\n    |\n LL |     if x.is_err() {\n    |        ---------- the check is happening here\n@@ -119,7 +119,7 @@ LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: This call to `unwrap_err()` will always panic.\n-  --> $DIR/simple_conditionals.rs:38:9\n+  --> $DIR/simple_conditionals.rs:65:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check"}, {"sha": "d3a920de4b6ad8a685f3c04096a3afd414826998", "filename": "src/tools/clippy/tests/ui/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffuture_not_send.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -41,6 +41,7 @@ impl Dummy {\n         self.private_future().await;\n     }\n \n+    #[allow(clippy::manual_async_fn)]\n     pub fn public_send(&self) -> impl std::future::Future<Output = bool> {\n         async { false }\n     }"}, {"sha": "d1863701bfe7c14dd0cd0a161d3b224530b4343e", "filename": "src/tools/clippy/tests/ui/future_not_send.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffuture_not_send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffuture_not_send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffuture_not_send.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -96,13 +96,13 @@ LL |     }\n    = note: `std::rc::Rc<[u8]>` doesn't implement `std::marker::Sync`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/future_not_send.rs:49:37\n+  --> $DIR/future_not_send.rs:50:37\n    |\n LL | async fn generic_future<T>(t: T) -> T\n    |                                     ^ future returned by `generic_future` is not `Send`\n    |\n note: future is not `Send` as this value is used across an await\n-  --> $DIR/future_not_send.rs:54:5\n+  --> $DIR/future_not_send.rs:55:5\n    |\n LL |     let rt = &t;\n    |         -- has type `&T` which is not `Send`\n@@ -114,7 +114,7 @@ LL | }\n    = note: `T` doesn't implement `std::marker::Sync`\n \n error: future cannot be sent between threads safely\n-  --> $DIR/future_not_send.rs:65:34\n+  --> $DIR/future_not_send.rs:66:34\n    |\n LL | async fn unclear_future<T>(t: T) {}\n    |                                  ^"}, {"sha": "6bb1032a17299108a9a2603662e5b25531e7114f", "filename": "src/tools/clippy/tests/ui/manual_async_fn.fixed", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.fixed?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,67 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(clippy::manual_async_fn)]\n+#![allow(unused)]\n+\n+use std::future::Future;\n+\n+async fn fut() -> i32 { 42 }\n+\n+async fn empty_fut()  {}\n+\n+async fn core_fut() -> i32 { 42 }\n+\n+// should be ignored\n+fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+    let _ = 42;\n+    async move { 42 }\n+}\n+\n+// should be ignored\n+fn not_fut() -> i32 {\n+    42\n+}\n+\n+// should be ignored\n+async fn already_async() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+struct S {}\n+impl S {\n+    async fn inh_fut() -> i32 {\n+        // NOTE: this code is here just to check that the identation is correct in the suggested fix\n+        let a = 42;\n+        let b = 21;\n+        if a < b {\n+            let c = 21;\n+            let d = 42;\n+            if c < d {\n+                let _ = 42;\n+            }\n+        }\n+        42\n+    }\n+\n+    async fn meth_fut(&self) -> i32 { 42 }\n+\n+    async fn empty_fut(&self)  {}\n+\n+    // should be ignored\n+    fn not_fut(&self) -> i32 {\n+        42\n+    }\n+\n+    // should be ignored\n+    fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+        let _ = 42;\n+        async move { 42 }\n+    }\n+\n+    // should be ignored\n+    async fn already_async(&self) -> impl Future<Output = i32> {\n+        async { 42 }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d50c919188be13c4ff4111fa17e604771453da13", "filename": "src/tools/clippy/tests/ui/manual_async_fn.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,79 @@\n+// run-rustfix\n+// edition:2018\n+#![warn(clippy::manual_async_fn)]\n+#![allow(unused)]\n+\n+use std::future::Future;\n+\n+fn fut() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+fn empty_fut() -> impl Future<Output = ()> {\n+    async {}\n+}\n+\n+fn core_fut() -> impl core::future::Future<Output = i32> {\n+    async move { 42 }\n+}\n+\n+// should be ignored\n+fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+    let _ = 42;\n+    async move { 42 }\n+}\n+\n+// should be ignored\n+fn not_fut() -> i32 {\n+    42\n+}\n+\n+// should be ignored\n+async fn already_async() -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+struct S {}\n+impl S {\n+    fn inh_fut() -> impl Future<Output = i32> {\n+        async {\n+            // NOTE: this code is here just to check that the identation is correct in the suggested fix\n+            let a = 42;\n+            let b = 21;\n+            if a < b {\n+                let c = 21;\n+                let d = 42;\n+                if c < d {\n+                    let _ = 42;\n+                }\n+            }\n+            42\n+        }\n+    }\n+\n+    fn meth_fut(&self) -> impl Future<Output = i32> {\n+        async { 42 }\n+    }\n+\n+    fn empty_fut(&self) -> impl Future<Output = ()> {\n+        async {}\n+    }\n+\n+    // should be ignored\n+    fn not_fut(&self) -> i32 {\n+        42\n+    }\n+\n+    // should be ignored\n+    fn has_other_stmts() -> impl core::future::Future<Output = i32> {\n+        let _ = 42;\n+        async move { 42 }\n+    }\n+\n+    // should be ignored\n+    async fn already_async(&self) -> impl Future<Output = i32> {\n+        async { 42 }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f278ee41aa335607a9f26dd265ddb16bcc9206d7", "filename": "src/tools/clippy/tests/ui/manual_async_fn.stderr", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_async_fn.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,98 @@\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:8:1\n+   |\n+LL | fn fut() -> impl Future<Output = i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-async-fn` implied by `-D warnings`\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL | async fn fut() -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn fut() -> impl Future<Output = i32> { 42 }\n+   |                                       ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:12:1\n+   |\n+LL | fn empty_fut() -> impl Future<Output = ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and remove the return type\n+   |\n+LL | async fn empty_fut()  {\n+   | ^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn empty_fut() -> impl Future<Output = ()> {}\n+   |                                            ^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:16:1\n+   |\n+LL | fn core_fut() -> impl core::future::Future<Output = i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL | async fn core_fut() -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn core_fut() -> impl core::future::Future<Output = i32> { 42 }\n+   |                                                          ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:38:5\n+   |\n+LL |     fn inh_fut() -> impl Future<Output = i32> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL |     async fn inh_fut() -> i32 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL |     fn inh_fut() -> impl Future<Output = i32> {\n+LL |         // NOTE: this code is here just to check that the identation is correct in the suggested fix\n+LL |         let a = 42;\n+LL |         let b = 21;\n+LL |         if a < b {\n+LL |             let c = 21;\n+ ...\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:54:5\n+   |\n+LL |     fn meth_fut(&self) -> impl Future<Output = i32> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL |     async fn meth_fut(&self) -> i32 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL |     fn meth_fut(&self) -> impl Future<Output = i32> { 42 }\n+   |                                                     ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:58:5\n+   |\n+LL |     fn empty_fut(&self) -> impl Future<Output = ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and remove the return type\n+   |\n+LL |     async fn empty_fut(&self)  {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL |     fn empty_fut(&self) -> impl Future<Output = ()> {}\n+   |                                                     ^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "9c24d6d4db1f257de14382cdd58ad2d58c11ff21", "filename": "src/tools/clippy/tests/ui/manual_memcpy.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -98,6 +98,21 @@ pub fn manual_copy(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n     for i in from..from + 3 {\n         dst[i] = src[i - from];\n     }\n+\n+    #[allow(clippy::identity_op)]\n+    for i in 0..5 {\n+        dst[i - 0] = src[i];\n+    }\n+\n+    #[allow(clippy::reverse_range_loop)]\n+    for i in 0..0 {\n+        dst[i] = src[i];\n+    }\n+\n+    // `RangeTo` `for` loop - don't trigger lint\n+    for i in 0.. {\n+        dst[i] = src[i];\n+    }\n }\n \n #[warn(clippy::needless_range_loop, clippy::manual_memcpy)]"}, {"sha": "bad84a589008180df702444d2e57b4a9042b9d82", "filename": "src/tools/clippy/tests/ui/manual_memcpy.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -58,19 +58,31 @@ error: it looks like you're manually copying between slices\n   --> $DIR/manual_memcpy.rs:94:14\n    |\n LL |     for i in from..from + src.len() {\n-   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[0..(from + src.len() - from)])`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[..(from + src.len() - from)])`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/manual_memcpy.rs:98:14\n    |\n LL |     for i in from..from + 3 {\n-   |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[0..(from + 3 - from)])`\n+   |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[..(from + 3 - from)])`\n \n error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:105:14\n+  --> $DIR/manual_memcpy.rs:103:14\n+   |\n+LL |     for i in 0..5 {\n+   |              ^^^^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5])`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/manual_memcpy.rs:108:14\n+   |\n+LL |     for i in 0..0 {\n+   |              ^^^^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0])`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/manual_memcpy.rs:120:14\n    |\n LL |     for i in 0..src.len() {\n    |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "7a788f4852072022b393541e63edae6bf0d474da", "filename": "src/tools/clippy/tests/ui/manual_non_exhaustive.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,137 @@\n+#![warn(clippy::manual_non_exhaustive)]\n+#![allow(unused)]\n+\n+mod enums {\n+    enum E {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // user forgot to remove the marker\n+    #[non_exhaustive]\n+    enum Ep {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // marker variant does not have doc hidden attribute, should be ignored\n+    enum NoDocHidden {\n+        A,\n+        B,\n+        _C,\n+    }\n+\n+    // name of variant with doc hidden does not start with underscore, should be ignored\n+    enum NoUnderscore {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        C,\n+    }\n+\n+    // variant with doc hidden is not unit, should be ignored\n+    enum NotUnit {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C(bool),\n+    }\n+\n+    // variant with doc hidden is the only one, should be ignored\n+    enum OnlyMarker {\n+        #[doc(hidden)]\n+        _A,\n+    }\n+\n+    // variant with multiple markers, should be ignored\n+    enum MultipleMarkers {\n+        A,\n+        #[doc(hidden)]\n+        _B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // already non_exhaustive and no markers, should be ignored\n+    #[non_exhaustive]\n+    enum NonExhaustive {\n+        A,\n+        B,\n+    }\n+}\n+\n+mod structs {\n+    struct S {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // user forgot to remove the private field\n+    #[non_exhaustive]\n+    struct Sp {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // some other fields are private, should be ignored\n+    struct PrivateFields {\n+        a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // private field name does not start with underscore, should be ignored\n+    struct NoUnderscore {\n+        pub a: i32,\n+        pub b: i32,\n+        c: (),\n+    }\n+\n+    // private field is not unit type, should be ignored\n+    struct NotUnit {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: i32,\n+    }\n+\n+    // private field is the only field, should be ignored\n+    struct OnlyMarker {\n+        _a: (),\n+    }\n+\n+    // already non exhaustive and no private fields, should be ignored\n+    #[non_exhaustive]\n+    struct NonExhaustive {\n+        pub a: i32,\n+        pub b: i32,\n+    }\n+}\n+\n+mod tuple_structs {\n+    struct T(pub i32, pub i32, ());\n+\n+    // user forgot to remove the private field\n+    #[non_exhaustive]\n+    struct Tp(pub i32, pub i32, ());\n+\n+    // some other fields are private, should be ignored\n+    struct PrivateFields(pub i32, i32, ());\n+\n+    // private field is not unit type, should be ignored\n+    struct NotUnit(pub i32, pub i32, i32);\n+\n+    // private field is the only field, should be ignored\n+    struct OnlyMarker(());\n+\n+    // already non exhaustive and no private fields, should be ignored\n+    #[non_exhaustive]\n+    struct NonExhaustive(pub i32, pub i32);\n+}\n+\n+fn main() {}"}, {"sha": "613c5e8ca1d45b38ec58c9dfc403f4b5abd37e04", "filename": "src/tools/clippy/tests/ui/manual_non_exhaustive.stderr", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -0,0 +1,103 @@\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:5:5\n+   |\n+LL |       enum E {\n+   |       ^-----\n+   |       |\n+   |  _____help: add the attribute: `#[non_exhaustive] enum E`\n+   | |\n+LL | |         A,\n+LL | |         B,\n+LL | |         #[doc(hidden)]\n+LL | |         _C,\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive.rs:9:9\n+   |\n+LL |         _C,\n+   |         ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:14:5\n+   |\n+LL | /     enum Ep {\n+LL | |         A,\n+LL | |         B,\n+LL | |         #[doc(hidden)]\n+LL | |         _C,\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive.rs:18:9\n+   |\n+LL |         _C,\n+   |         ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:68:5\n+   |\n+LL |       struct S {\n+   |       ^-------\n+   |       |\n+   |  _____help: add the attribute: `#[non_exhaustive] struct S`\n+   | |\n+LL | |         pub a: i32,\n+LL | |         pub b: i32,\n+LL | |         _c: (),\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:71:9\n+   |\n+LL |         _c: (),\n+   |         ^^^^^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:76:5\n+   |\n+LL | /     struct Sp {\n+LL | |         pub a: i32,\n+LL | |         pub b: i32,\n+LL | |         _c: (),\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:79:9\n+   |\n+LL |         _c: (),\n+   |         ^^^^^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:117:5\n+   |\n+LL |     struct T(pub i32, pub i32, ());\n+   |     --------^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: add the attribute: `#[non_exhaustive] struct T`\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:117:32\n+   |\n+LL |     struct T(pub i32, pub i32, ());\n+   |                                ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:121:5\n+   |\n+LL |     struct Tp(pub i32, pub i32, ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:121:33\n+   |\n+LL |     struct Tp(pub i32, pub i32, ());\n+   |                                 ^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "30415e3b94dc4b1e95458eba5473d2cc8f4f7da1", "filename": "src/tools/clippy/tests/ui/match_on_vec_items.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_on_vec_items.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -120,11 +120,33 @@ fn match_with_array() {\n     }\n }\n \n+fn match_with_endless_range() {\n+    let arr = vec![0, 1, 2, 3];\n+    let range = ..;\n+\n+    // Ok\n+    match arr[range] {\n+        [0, 1] => println!(\"0 1\"),\n+        [1, 2] => println!(\"1 2\"),\n+        [0, 1, 2, 3] => println!(\"0, 1, 2, 3\"),\n+        _ => {},\n+    }\n+\n+    // Ok\n+    match arr[..] {\n+        [0, 1] => println!(\"0 1\"),\n+        [1, 2] => println!(\"1 2\"),\n+        [0, 1, 2, 3] => println!(\"0, 1, 2, 3\"),\n+        _ => {},\n+    }\n+}\n+\n fn main() {\n     match_with_wildcard();\n     match_without_wildcard();\n     match_wildcard_and_action();\n     match_vec_ref();\n     match_with_get();\n     match_with_array();\n+    match_with_endless_range();\n }"}, {"sha": "e99c98ac79f2a7f4fa97bee33bb41ebb7fba7ef9", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -2,6 +2,7 @@\n \n #![warn(clippy::while_let_on_iterator)]\n #![allow(clippy::never_loop, unreachable_code, unused_mut)]\n+#![feature(or_patterns)]\n \n fn base() {\n     let mut iter = 1..20;\n@@ -77,6 +78,62 @@ fn refutable() {\n     // */\n }\n \n+fn refutable2() {\n+    // Issue 3780\n+    {\n+        let v = vec![1, 2, 3];\n+        let mut it = v.windows(2);\n+        while let Some([x, y]) = it.next() {\n+            println!(\"x: {}\", x);\n+            println!(\"y: {}\", y);\n+        }\n+\n+        let mut it = v.windows(2);\n+        while let Some([x, ..]) = it.next() {\n+            println!(\"x: {}\", x);\n+        }\n+\n+        let mut it = v.windows(2);\n+        while let Some([.., y]) = it.next() {\n+            println!(\"y: {}\", y);\n+        }\n+\n+        let mut it = v.windows(2);\n+        for [..] in it {}\n+\n+        let v = vec![[1], [2], [3]];\n+        let mut it = v.iter();\n+        while let Some([1]) = it.next() {}\n+\n+        let mut it = v.iter();\n+        for [_x] in it {}\n+    }\n+\n+    // binding\n+    {\n+        let v = vec![1, 2, 3];\n+        let mut it = v.iter();\n+        while let Some(x @ 1) = it.next() {\n+            println!(\"{}\", x);\n+        }\n+\n+        let v = vec![[1], [2], [3]];\n+        let mut it = v.iter();\n+        for x @ [_] in it {\n+            println!(\"{:?}\", x);\n+        }\n+    }\n+\n+    // false negative\n+    {\n+        let v = vec![1, 2, 3];\n+        let mut it = v.iter().map(Some);\n+        while let Some(Some(_) | None) = it.next() {\n+            println!(\"1\");\n+        }\n+    }\n+}\n+\n fn nested_loops() {\n     let a = [42, 1337];\n     let mut y = a.iter();\n@@ -152,6 +209,7 @@ fn issue1654() {\n fn main() {\n     base();\n     refutable();\n+    refutable2();\n     nested_loops();\n     issue1121();\n     issue2965();"}, {"sha": "ba13172428e136bc47d8ba47f17387e310133729", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -2,6 +2,7 @@\n \n #![warn(clippy::while_let_on_iterator)]\n #![allow(clippy::never_loop, unreachable_code, unused_mut)]\n+#![feature(or_patterns)]\n \n fn base() {\n     let mut iter = 1..20;\n@@ -77,6 +78,62 @@ fn refutable() {\n     // */\n }\n \n+fn refutable2() {\n+    // Issue 3780\n+    {\n+        let v = vec![1, 2, 3];\n+        let mut it = v.windows(2);\n+        while let Some([x, y]) = it.next() {\n+            println!(\"x: {}\", x);\n+            println!(\"y: {}\", y);\n+        }\n+\n+        let mut it = v.windows(2);\n+        while let Some([x, ..]) = it.next() {\n+            println!(\"x: {}\", x);\n+        }\n+\n+        let mut it = v.windows(2);\n+        while let Some([.., y]) = it.next() {\n+            println!(\"y: {}\", y);\n+        }\n+\n+        let mut it = v.windows(2);\n+        while let Some([..]) = it.next() {}\n+\n+        let v = vec![[1], [2], [3]];\n+        let mut it = v.iter();\n+        while let Some([1]) = it.next() {}\n+\n+        let mut it = v.iter();\n+        while let Some([_x]) = it.next() {}\n+    }\n+\n+    // binding\n+    {\n+        let v = vec![1, 2, 3];\n+        let mut it = v.iter();\n+        while let Some(x @ 1) = it.next() {\n+            println!(\"{}\", x);\n+        }\n+\n+        let v = vec![[1], [2], [3]];\n+        let mut it = v.iter();\n+        while let Some(x @ [_]) = it.next() {\n+            println!(\"{:?}\", x);\n+        }\n+    }\n+\n+    // false negative\n+    {\n+        let v = vec![1, 2, 3];\n+        let mut it = v.iter().map(Some);\n+        while let Some(Some(_) | None) = it.next() {\n+            println!(\"1\");\n+        }\n+    }\n+}\n+\n fn nested_loops() {\n     let a = [42, 1337];\n     let mut y = a.iter();\n@@ -152,6 +209,7 @@ fn issue1654() {\n fn main() {\n     base();\n     refutable();\n+    refutable2();\n     nested_loops();\n     issue1121();\n     issue2965();"}, {"sha": "aa980d9965c76b78e0d0f85819d9e5e19a2ac411", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -1,28 +1,46 @@\n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:8:5\n+  --> $DIR/while_let_on_iterator.rs:9:5\n    |\n LL |     while let Option::Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n    |\n    = note: `-D clippy::while-let-on-iterator` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:13:5\n+  --> $DIR/while_let_on_iterator.rs:14:5\n    |\n LL |     while let Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:18:5\n+  --> $DIR/while_let_on_iterator.rs:19:5\n    |\n LL |     while let Some(_) = iter.next() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:97:9\n+  --> $DIR/while_let_on_iterator.rs:102:9\n+   |\n+LL |         while let Some([..]) = it.next() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [..] in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:109:9\n+   |\n+LL |         while let Some([_x]) = it.next() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [_x] in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:122:9\n+   |\n+LL |         while let Some(x @ [_]) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x @ [_] in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:154:9\n    |\n LL |         while let Some(_) = y.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in y`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "67423e6ec1d19bca17b3acd4b55227ab6cfae2b8", "filename": "src/tools/clippy/tests/ui/wildcard_imports.fixed", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.fixed?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -155,3 +155,76 @@ fn test_weird_formatting() {\n     exported();\n     foo();\n }\n+\n+mod super_imports {\n+    fn foofoo() {}\n+\n+    mod should_be_replaced {\n+        use super::foofoo;\n+\n+        fn with_super() {\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod test_should_pass {\n+        use super::*;\n+\n+        fn with_super() {\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod test_should_pass_inside_function {\n+        fn with_super_inside_function() {\n+            use super::*;\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod test_should_pass_further_inside {\n+        fn insidefoo() {}\n+        mod inner {\n+            use super::*;\n+            fn with_super() {\n+                let _ = insidefoo();\n+            }\n+        }\n+    }\n+\n+    mod should_be_replaced_futher_inside {\n+        fn insidefoo() {}\n+        mod inner {\n+            use super::insidefoo;\n+            fn with_super() {\n+                let _ = insidefoo();\n+            }\n+        }\n+    }\n+\n+    mod use_explicit_should_be_replaced {\n+        use super_imports::foofoo;\n+\n+        fn with_explicit() {\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod use_double_super_should_be_replaced {\n+        mod inner {\n+            use super::super::foofoo;\n+\n+            fn with_double_super() {\n+                let _ = foofoo();\n+            }\n+        }\n+    }\n+\n+    mod use_super_explicit_should_be_replaced {\n+        use super::super::super_imports::foofoo;\n+\n+        fn with_super_explicit() {\n+            let _ = foofoo();\n+        }\n+    }\n+}"}, {"sha": "3ad1a29aebad1f985a19e272ac55f071263f511c", "filename": "src/tools/clippy/tests/ui/wildcard_imports.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.rs?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -156,3 +156,76 @@ fn test_weird_formatting() {\n     exported();\n     foo();\n }\n+\n+mod super_imports {\n+    fn foofoo() {}\n+\n+    mod should_be_replaced {\n+        use super::*;\n+\n+        fn with_super() {\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod test_should_pass {\n+        use super::*;\n+\n+        fn with_super() {\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod test_should_pass_inside_function {\n+        fn with_super_inside_function() {\n+            use super::*;\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod test_should_pass_further_inside {\n+        fn insidefoo() {}\n+        mod inner {\n+            use super::*;\n+            fn with_super() {\n+                let _ = insidefoo();\n+            }\n+        }\n+    }\n+\n+    mod should_be_replaced_futher_inside {\n+        fn insidefoo() {}\n+        mod inner {\n+            use super::*;\n+            fn with_super() {\n+                let _ = insidefoo();\n+            }\n+        }\n+    }\n+\n+    mod use_explicit_should_be_replaced {\n+        use super_imports::*;\n+\n+        fn with_explicit() {\n+            let _ = foofoo();\n+        }\n+    }\n+\n+    mod use_double_super_should_be_replaced {\n+        mod inner {\n+            use super::super::*;\n+\n+            fn with_double_super() {\n+                let _ = foofoo();\n+            }\n+        }\n+    }\n+\n+    mod use_super_explicit_should_be_replaced {\n+        use super::super::super_imports::*;\n+\n+        fn with_super_explicit() {\n+            let _ = foofoo();\n+        }\n+    }\n+}"}, {"sha": "fab43b738eb434d1ab6b453dffbc8967bfeeb222", "filename": "src/tools/clippy/tests/ui/wildcard_imports.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9dd5b2d97e83aa8a39e1ef8529217a08db65d59b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_imports.stderr?ref=9dd5b2d97e83aa8a39e1ef8529217a08db65d59b", "patch": "@@ -92,5 +92,35 @@ LL |       use crate:: fn_mod::\n LL | |         *;\n    | |_________^ help: try: `crate:: fn_mod::foo`\n \n-error: aborting due to 15 previous errors\n+error: usage of wildcard import\n+  --> $DIR/wildcard_imports.rs:164:13\n+   |\n+LL |         use super::*;\n+   |             ^^^^^^^^ help: try: `super::foofoo`\n+\n+error: usage of wildcard import\n+  --> $DIR/wildcard_imports.rs:199:17\n+   |\n+LL |             use super::*;\n+   |                 ^^^^^^^^ help: try: `super::insidefoo`\n+\n+error: usage of wildcard import\n+  --> $DIR/wildcard_imports.rs:207:13\n+   |\n+LL |         use super_imports::*;\n+   |             ^^^^^^^^^^^^^^^^ help: try: `super_imports::foofoo`\n+\n+error: usage of wildcard import\n+  --> $DIR/wildcard_imports.rs:216:17\n+   |\n+LL |             use super::super::*;\n+   |                 ^^^^^^^^^^^^^^^ help: try: `super::super::foofoo`\n+\n+error: usage of wildcard import\n+  --> $DIR/wildcard_imports.rs:225:13\n+   |\n+LL |         use super::super::super_imports::*;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `super::super::super_imports::foofoo`\n+\n+error: aborting due to 20 previous errors\n "}]}