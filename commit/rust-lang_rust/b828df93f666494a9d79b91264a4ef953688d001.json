{"sha": "b828df93f666494a9d79b91264a4ef953688d001", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjhkZjkzZjY2NjQ5NGE5ZDc5YjkxMjY0YTRlZjk1MzY4OGQwMDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-03T14:34:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-07T01:36:54Z"}, "message": "miscellaneous pure annotations and other small changes.\n\nit seems that, to be truly useful, pure fns really need the\nability to modify their parameters.  alternatively, we could\nrewrite the functions that modify their arguments to take/return.", "tree": {"sha": "e7848f787cdbcdf3562555605ed1a8d075881f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7848f787cdbcdf3562555605ed1a8d075881f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b828df93f666494a9d79b91264a4ef953688d001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b828df93f666494a9d79b91264a4ef953688d001", "html_url": "https://github.com/rust-lang/rust/commit/b828df93f666494a9d79b91264a4ef953688d001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b828df93f666494a9d79b91264a4ef953688d001/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bc42d5661d7e41885ef192bc2f4a5b8410a79f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc42d5661d7e41885ef192bc2f4a5b8410a79f2", "html_url": "https://github.com/rust-lang/rust/commit/3bc42d5661d7e41885ef192bc2f4a5b8410a79f2"}], "stats": {"total": 223, "additions": 122, "deletions": 101}, "files": [{"sha": "71bd1025d1db50bd918d19e9549ef3def4edce7e", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b828df93f666494a9d79b91264a4ef953688d001/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b828df93f666494a9d79b91264a4ef953688d001/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=b828df93f666494a9d79b91264a4ef953688d001", "patch": "@@ -218,7 +218,7 @@ impl extensions for rng {\n     }\n \n     #[doc = \"Shuffle a mutable vec in place\"]\n-    fn shuffle_mut<T>(&values: [mut T]) {\n+    fn shuffle_mut<T>(&&values: [mut T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place."}, {"sha": "6c24b65698845b65052dc1bad19903d54d7ee626", "filename": "src/libcore/str.rs", "status": "modified", "additions": 118, "deletions": 97, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/b828df93f666494a9d79b91264a4ef953688d001/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b828df93f666494a9d79b91264a4ef953688d001/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b828df93f666494a9d79b91264a4ef953688d001", "patch": "@@ -122,7 +122,7 @@ Convert a vector of bytes to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-fn from_bytes(vv: [u8]) -> str unsafe {\n+pure fn from_bytes(vv: [u8]) -> str unsafe {\n    assert is_utf8(vv);\n    ret unsafe::from_bytes(vv);\n }\n@@ -134,7 +134,7 @@ Convert a byte to a UTF-8 string\n \n Fails if invalid UTF-8\n \"]\n-fn from_byte(b: u8) -> str unsafe {\n+pure fn from_byte(b: u8) -> str unsafe {\n     assert b < 128u8;\n     let mut v = [b, 0u8];\n     let s: str = ::unsafe::reinterpret_cast(v);\n@@ -217,22 +217,24 @@ fn push_char(&s: str, ch: char) unsafe {\n }\n \n #[doc = \"Convert a char to a string\"]\n-fn from_char(ch: char) -> str {\n+pure fn from_char(ch: char) -> str {\n     let mut buf = \"\";\n-    push_char(buf, ch);\n+    unchecked { push_char(buf, ch); }\n     ret buf;\n }\n \n #[doc = \"Convert a vector of chars to a string\"]\n-fn from_chars(chs: [char]) -> str {\n+pure fn from_chars(chs: [char]) -> str {\n     let mut buf = \"\";\n-    reserve(buf, chs.len());\n-    for vec::each(chs) {|ch| push_char(buf, ch); }\n+    unchecked {\n+        reserve(buf, chs.len());\n+        for vec::each(chs) {|ch| push_char(buf, ch); }\n+    }\n     ret buf;\n }\n \n #[doc = \"Concatenate a vector of strings\"]\n-fn concat(v: [str]) -> str {\n+pure fn concat(v: [str]) -> str {\n     let mut s: str = \"\";\n     for vec::each(v) {|ss| s += ss; }\n     ret s;\n@@ -241,7 +243,7 @@ fn concat(v: [str]) -> str {\n #[doc = \"\n Concatenate a vector of strings, placing a given separator between each\n \"]\n-fn connect(v: [str], sep: str) -> str {\n+pure fn connect(v: [str], sep: str) -> str {\n     let mut s = \"\", first = true;\n     for vec::each(v) {|ss|\n         if first { first = false; } else { s += sep; }\n@@ -286,7 +288,7 @@ fn shift_char(&s: str) -> char unsafe {\n fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n #[doc = \"Returns a string with leading whitespace removed\"]\n-fn trim_left(+s: str) -> str {\n+pure fn trim_left(+s: str) -> str {\n     alt find(s, {|c| !char::is_whitespace(c)}) {\n       none { \"\" }\n       some(first) {\n@@ -297,7 +299,7 @@ fn trim_left(+s: str) -> str {\n }\n \n #[doc = \"Returns a string with trailing whitespace removed\"]\n-fn trim_right(+s: str) -> str {\n+pure fn trim_right(+s: str) -> str {\n     alt rfind(s, {|c| !char::is_whitespace(c)}) {\n       none { \"\" }\n       some(last) {\n@@ -309,7 +311,7 @@ fn trim_right(+s: str) -> str {\n }\n \n #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n-fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n+pure fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -320,7 +322,7 @@ Converts a string to a vector of bytes\n \n The result vector is not null-terminated.\n \"]\n-fn bytes(s: str) -> [u8] unsafe {\n+pure fn bytes(s: str) -> [u8] unsafe {\n     let mut s_copy = s;\n     let mut v: [u8] = ::unsafe::reinterpret_cast(s_copy);\n     ::unsafe::forget(s_copy);\n@@ -332,14 +334,14 @@ fn bytes(s: str) -> [u8] unsafe {\n Work with the string as a byte slice, not including trailing null.\n \"]\n #[inline(always)]\n-fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n+pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n     unpack_slice(s) {|p,n|\n         vec::unsafe::form_slice(p, n-1u, f)\n     }\n }\n \n #[doc = \"Convert a string to a vector of characters\"]\n-fn chars(s: str) -> [char] {\n+pure fn chars(s: str) -> [char] {\n     let mut buf = [], i = 0u;\n     let len = len(s);\n     while i < len {\n@@ -356,7 +358,7 @@ Take a substring of another.\n Returns a string containing `n` characters starting at byte offset\n `begin`.\n \"]\n-fn substr(s: str, begin: uint, n: uint) -> str {\n+pure fn substr(s: str, begin: uint, n: uint) -> str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -366,7 +368,7 @@ Returns a slice of the given string from the byte range [`begin`..`end`)\n Fails when `begin` and `end` do not point to valid characters or\n beyond the last character of the string\n \"]\n-fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n+pure fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe::slice_bytes(s, begin, end)\n@@ -375,7 +377,7 @@ fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n #[doc = \"\n Splits a string into substrings at each occurrence of a given character\n \"]\n-fn split_char(s: str, sep: char) -> [str] {\n+pure fn split_char(s: str, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -385,18 +387,18 @@ character up to 'count' times\n \n The byte must be a valid UTF-8/ASCII byte\n \"]\n-fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n+pure fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n     split_char_inner(s, sep, count, true)\n }\n \n #[doc = \"\n Like `split_char`, but omits empty strings from the returned vector\n \"]\n-fn split_char_nonempty(s: str, sep: char) -> [str] {\n+pure fn split_char_nonempty(s: str, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n-fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n+pure fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n     -> [str] unsafe {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n@@ -423,24 +425,24 @@ fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n \n \n #[doc = \"Splits a string into substrings using a character function\"]\n-fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n #[doc = \"\n Splits a string into substrings using a character function, cutting at\n most `count` times.\n \"]\n-fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n+pure fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n     split_inner(s, sepfn, count, true)\n }\n \n #[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n-fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n+pure fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> [str] unsafe {\n     let l = len(s);\n     let mut result = [], i = 0u, start = 0u, done = 0u;\n@@ -462,7 +464,7 @@ fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -489,7 +491,7 @@ fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     }\n }\n \n-fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n     iter_matches(s, sep) {|from, to|\n         f(last_end, from);\n@@ -507,15 +509,15 @@ Splits a string into a vector of the substrings separated by a given string\n assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n ~~~\n \"]\n-fn split_str(s: str, sep: str) -> [str] {\n+pure fn split_str(s: str, sep: str) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n     }\n     result\n }\n \n-fn split_str_nonempty(s: str, sep: str) -> [str] {\n+pure fn split_str_nonempty(s: str, sep: str) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n@@ -528,13 +530,13 @@ fn split_str_nonempty(s: str, sep: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n \"]\n-fn lines(s: str) -> [str] { split_char(s, '\\n') }\n+pure fn lines(s: str) -> [str] { split_char(s, '\\n') }\n \n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n and/or CR LF ('\\\\r\\\\n')\n \"]\n-fn lines_any(s: str) -> [str] {\n+pure fn lines_any(s: str) -> [str] {\n     vec::map(lines(s), {|s|\n         let l = len(s);\n         let mut cp = s;\n@@ -548,18 +550,22 @@ fn lines_any(s: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by whitespace\n \"]\n-fn words(s: str) -> [str] {\n+pure fn words(s: str) -> [str] {\n     split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n #[doc = \"Convert a string to lowercase. ASCII only\"]\n-fn to_lower(s: str) -> str {\n-    map(s, {|c| (libc::tolower(c as libc::c_char)) as char})\n+pure fn to_lower(s: str) -> str {\n+    map(s, {|c|\n+        unchecked{(libc::tolower(c as libc::c_char)) as char}\n+    })\n }\n \n #[doc = \"Convert a string to uppercase. ASCII only\"]\n-fn to_upper(s: str) -> str {\n-    map(s, {|c| (libc::toupper(c as libc::c_char)) as char})\n+pure fn to_upper(s: str) -> str {\n+    map(s, {|c|\n+        unchecked{(libc::toupper(c as libc::c_char)) as char}\n+    })\n }\n \n #[doc = \"\n@@ -575,7 +581,7 @@ Replace all occurances of one string with another\n \n The original string with all occurances of `from` replaced with `to`\n \"]\n-fn replace(s: str, from: str, to: str) -> str unsafe {\n+pure fn replace(s: str, from: str, to: str) -> str unsafe {\n     let mut result = \"\", first = true;\n     iter_between_matches(s, from) {|start, end|\n         if first { first = false; } else { result += to; }\n@@ -595,7 +601,7 @@ pure fn eq(&&a: str, &&b: str) -> bool { a == b }\n pure fn le(&&a: str, &&b: str) -> bool { a <= b }\n \n #[doc = \"String hash function\"]\n-fn hash(&&s: str) -> uint {\n+pure fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur. (see #859 and #1616)\n     let mut u: uint = 5381u;\n@@ -611,28 +617,32 @@ Section: Iterating through strings\n Return true if a predicate matches all characters or if the string\n contains no characters\n \"]\n-fn all(s: str, it: fn(char) -> bool) -> bool {\n+pure fn all(s: str, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n #[doc = \"\n Return true if a predicate matches any character (and false if it\n matches none or there are no characters)\n \"]\n-fn any(ss: str, pred: fn(char) -> bool) -> bool {\n+pure fn any(ss: str, pred: fn(char) -> bool) -> bool {\n     !all(ss, {|cc| !pred(cc)})\n }\n \n #[doc = \"Apply a function to each character\"]\n-fn map(ss: str, ff: fn(char) -> char) -> str {\n+pure fn map(ss: str, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n-    reserve(result, len(ss));\n-    chars_iter(ss) {|cc| str::push_char(result, ff(cc));}\n+    unchecked {\n+        reserve(result, len(ss));\n+        chars_iter(ss) {|cc|\n+            str::push_char(result, ff(cc));\n+        }\n+    }\n     result\n }\n \n #[doc = \"Iterate over the bytes in a string\"]\n-fn bytes_iter(ss: str, it: fn(u8)) {\n+pure fn bytes_iter(ss: str, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -644,7 +654,7 @@ fn bytes_iter(ss: str, it: fn(u8)) {\n \n #[doc = \"Iterate over the bytes in a string\"]\n #[inline(always)]\n-fn each(s: str, it: fn(u8) -> bool) {\n+pure fn each(s: str, it: fn(u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(s[i]) { break; }\n@@ -654,7 +664,7 @@ fn each(s: str, it: fn(u8) -> bool) {\n \n #[doc = \"Iterates over the chars in a string\"]\n #[inline(always)]\n-fn each_char(s: str, it: fn(char) -> bool) {\n+pure fn each_char(s: str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -665,7 +675,7 @@ fn each_char(s: str, it: fn(char) -> bool) {\n }\n \n #[doc = \"Iterate over the characters in a string\"]\n-fn chars_iter(s: str, it: fn(char)) {\n+pure fn chars_iter(s: str, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -678,25 +688,26 @@ fn chars_iter(s: str, it: fn(char)) {\n #[doc = \"\n Apply a function to each substring after splitting by character\n \"]\n-fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n+pure fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n #[doc = \"\n Apply a function to each substring after splitting by character, up to\n `count` times\n \"]\n-fn splitn_char_iter(ss: str, sep: char, count: uint, ff: fn(&&str)) unsafe {\n+pure fn splitn_char_iter(ss: str, sep: char, count: uint,\n+                         ff: fn(&&str)) unsafe {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n #[doc = \"Apply a function to each word\"]\n-fn words_iter(ss: str, ff: fn(&&str)) {\n+pure fn words_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n #[doc = \"Apply a function to each line (by '\\\\n')\"]\n-fn lines_iter(ss: str, ff: fn(&&str)) {\n+pure fn lines_iter(ss: str, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n \n@@ -717,7 +728,7 @@ Returns the byte index of the first matching character\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-fn find_char(s: str, c: char) -> option<uint> {\n+pure fn find_char(s: str, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -741,7 +752,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -766,7 +777,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-fn find_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn find_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -796,7 +807,7 @@ Returns the byte index of the last matching character\n An `option` containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-fn rfind_char(s: str, c: char) -> option<uint> {\n+pure fn rfind_char(s: str, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -820,7 +831,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be\n the index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -845,7 +856,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -876,7 +887,7 @@ the given predicate\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -900,7 +911,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n@@ -926,7 +937,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`.\n \"]\n-fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -954,7 +965,7 @@ the given predicate\n An option containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -978,7 +989,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)', `start` must be the\n index of a character boundary, as defined by `is_char_boundary`\n \"]\n-fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1004,7 +1015,7 @@ or `none` if there is no match\n than or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`\n \"]\n-fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1019,7 +1030,7 @@ fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n }\n \n // Utility used by various searching functions\n-fn match_at(haystack: str, needle: str, at: uint) -> bool {\n+pure fn match_at(haystack: str, needle: str, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) {|c| if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n@@ -1038,7 +1049,7 @@ Returns the byte index of the first matching substring\n An `option` containing the byte index of the first matching substring\n or `none` if there is no match\n \"]\n-fn find_str(haystack: str, needle: str) -> option<uint> {\n+pure fn find_str(haystack: str, needle: str) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1061,7 +1072,7 @@ or `none` if there is no match\n \n `start` must be less than or equal to `len(s)`\n \"]\n-fn find_str_from(haystack: str, needle: str, start: uint)\n+pure fn find_str_from(haystack: str, needle: str, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1086,7 +1097,7 @@ or `none` if there is no match\n `start` must be less than or equal to `end` and `end` must be less than\n or equal to `len(s)`.\n \"]\n-fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n+pure fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n   -> option<uint> {\n     // See Issue #1932 for why this is a naive search\n     assert end <= len(haystack);\n@@ -1111,7 +1122,7 @@ Returns true if one string contains another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-fn contains(haystack: str, needle: str) -> bool {\n+pure fn contains(haystack: str, needle: str) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n@@ -1123,7 +1134,7 @@ Returns true if one string starts with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-fn starts_with(haystack: str, needle: str) -> bool unsafe {\n+pure fn starts_with(haystack: str, needle: str) -> bool unsafe {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1138,7 +1149,7 @@ Returns true if one string ends with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-fn ends_with(haystack: str, needle: str) -> bool {\n+pure fn ends_with(haystack: str, needle: str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1150,7 +1161,7 @@ Section: String properties\n */\n \n #[doc = \"Determines if a string contains only ASCII characters\"]\n-fn is_ascii(s: str) -> bool {\n+pure fn is_ascii(s: str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n@@ -1167,7 +1178,7 @@ Returns true if the string contains only whitespace\n \n Whitespace characters are determined by `char::is_whitespace`\n \"]\n-fn is_whitespace(s: str) -> bool {\n+pure fn is_whitespace(s: str) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n@@ -1189,14 +1200,14 @@ pure fn len(s: str) -> uint unsafe {\n }\n \n #[doc = \"Returns the number of characters that a string holds\"]\n-fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n+pure fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n #[doc = \"Determines if a vector of bytes contains valid UTF-8\"]\n-fn is_utf8(v: [const u8]) -> bool {\n+pure fn is_utf8(v: [const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1214,7 +1225,7 @@ fn is_utf8(v: [const u8]) -> bool {\n }\n \n #[doc = \"Determines if a vector of `u16` contains valid UTF-16\"]\n-fn is_utf16(v: [const u16]) -> bool {\n+pure fn is_utf16(v: [const u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1235,7 +1246,7 @@ fn is_utf16(v: [const u16]) -> bool {\n }\n \n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n-fn to_utf16(s: str) -> [u16] {\n+pure fn to_utf16(s: str) -> [u16] {\n     let mut u = [];\n     chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1257,7 +1268,7 @@ fn to_utf16(s: str) -> [u16] {\n     ret u;\n }\n \n-fn utf16_chars(v: [const u16], f: fn(char)) {\n+pure fn utf16_chars(v: [const u16], f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1282,10 +1293,12 @@ fn utf16_chars(v: [const u16], f: fn(char)) {\n }\n \n \n-fn from_utf16(v: [const u16]) -> str {\n+pure fn from_utf16(v: [const u16]) -> str {\n     let mut buf = \"\";\n-    reserve(buf, vec::len(v));\n-    utf16_chars(v) {|ch| push_char(buf, ch); }\n+    unchecked {\n+        reserve(buf, vec::len(v));\n+        utf16_chars(v) {|ch| push_char(buf, ch); }\n+    }\n     ret buf;\n }\n \n@@ -1303,7 +1316,7 @@ As char_len but for a slice of a string\n \n The number of Unicode characters in `s` between the given indices.\n \"]\n-fn count_chars(s: str, start: uint, end: uint) -> uint {\n+pure fn count_chars(s: str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1318,7 +1331,7 @@ fn count_chars(s: str, start: uint, end: uint) -> uint {\n #[doc = \"\n Counts the number of bytes taken by the `n` in `s` starting from `start`.\n \"]\n-fn count_bytes(s: str, start: uint, n: uint) -> uint {\n+pure fn count_bytes(s: str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1403,7 +1416,7 @@ index of the next unicode character.\n If `i` is greater than or equal to the length of the string.\n If `i` is not the index of the beginning of a valid UTF-8 character.\n \"]\n-fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n+pure fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1426,14 +1439,16 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n }\n \n #[doc = \"Pluck a character out of a string\"]\n-fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+pure fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n #[doc = \"\n Given a byte position and a str, return the previous char and its position\n \n This function can be used to iterate over a unicode string in reverse.\n \"]\n-fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n+pure fn char_range_at_reverse(ss: str, start: uint)\n+    -> {ch: char, prev: uint} {\n+\n     let mut prev = start;\n \n     // while there is a previous byte == 10......\n@@ -1470,7 +1485,8 @@ Loop through a substring, char by char\n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n \"]\n-fn all_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n+pure fn all_between(s: str, start: uint, end: uint,\n+                    it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n     while i < end {\n@@ -1502,7 +1518,8 @@ Loop through a substring, char by char\n \n `true` if `it` returns `true` for any character\n \"]\n-fn any_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n+pure fn any_between(s: str, start: uint, end: uint,\n+                    it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, {|c| !it(c)})\n }\n \n@@ -1533,7 +1550,7 @@ interop.\n let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n ~~~\n \"]\n-fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n+pure fn as_bytes<T>(s: str, f: fn([u8]) -> T) -> T unsafe {\n     let v: *[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     f(*v)\n }\n@@ -1544,7 +1561,7 @@ Work with the byte buffer of a string.\n Allows for unsafe manipulation of strings, which is useful for native\n interop.\n \"]\n-fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n+pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n     as_bytes(s) { |v| vec::as_buf(v, f) }\n }\n \n@@ -1560,7 +1577,7 @@ interop, without copying the original string.\n let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ~~~\n \"]\n-fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T unsafe {\n+pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T unsafe {\n     as_buf(s) {|buf| f(buf as *libc::c_char) }\n }\n \n@@ -1574,7 +1591,7 @@ indexable area for a null byte, as is the case in slices pointing\n to full strings, or suffixes of them.\n \"]\n #[inline(always)]\n-fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n+pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T unsafe {\n     let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n     f(buf, len)\n@@ -1639,18 +1656,22 @@ pure fn capacity(&&s: str) -> uint unsafe {\n }\n \n #[doc = \"Escape each char in `s` with char::escape_default.\"]\n-fn escape_default(s: str) -> str {\n+pure fn escape_default(s: str) -> str {\n     let mut out: str = \"\";\n-    reserve_at_least(out, str::len(s));\n-    chars_iter(s) {|c| out += char::escape_default(c); }\n+    unchecked {\n+        reserve_at_least(out, str::len(s));\n+        chars_iter(s) {|c| out += char::escape_default(c); }\n+    }\n     ret out;\n }\n \n #[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n-fn escape_unicode(s: str) -> str {\n+pure fn escape_unicode(s: str) -> str {\n     let mut out: str = \"\";\n-    reserve_at_least(out, str::len(s));\n-    chars_iter(s) {|c| out += char::escape_unicode(c); }\n+    unchecked {\n+        reserve_at_least(out, str::len(s));\n+        chars_iter(s) {|c| out += char::escape_unicode(c); }\n+    }\n     ret out;\n }\n "}, {"sha": "8247ad5b262ada597c08119d67d8749a469137fc", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b828df93f666494a9d79b91264a4ef953688d001/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b828df93f666494a9d79b91264a4ef953688d001/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b828df93f666494a9d79b91264a4ef953688d001", "patch": "@@ -798,7 +798,7 @@ Swaps two elements in a vector\n * a - The index of the first element\n * b - The index of the second element\n \"]\n-fn swap<T>(v: [mut T], a: uint, b: uint) {\n+fn swap<T>(&&v: [mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n@@ -1221,12 +1221,12 @@ mod unsafe {\n     #[doc = \"\n     Sets the length of a vector\n \n-    This well explicitly set the size of the vector, without actually\n+    This will explicitly set the size of the vector, without actually\n     modifing its buffers, so it is up to the caller to ensure that\n     the vector is actually the specified size.\n     \"]\n     #[inline(always)]\n-    unsafe fn set_len<T>(&v: [const T], new_len: uint) {\n+    unsafe fn set_len<T>(&&v: [const T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }"}]}