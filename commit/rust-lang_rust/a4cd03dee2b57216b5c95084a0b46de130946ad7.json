{"sha": "a4cd03dee2b57216b5c95084a0b46de130946ad7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0Y2QwM2RlZTJiNTcyMTZiNWM5NTA4NGEwYjQ2ZGUxMzA5NDZhZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-23T21:49:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-23T21:49:44Z"}, "message": "Auto merge of #66296 - Centril:bindings_after_at-init, r=pnkfelix\n\nInitial implementation of `#![feature(bindings_after_at)]`\n\nFollowing up on #16053, under the gate `#![feature(bindings_after_at)]`, `x @ Some(y)` is allowed subject to restrictions necessary for soundness.\n\nThe implementation and test suite should be fairly complete now.\n\nOne aspect that is not covered is the interaction with nested `#![feature(or_patterns)]`.\nThis is not possible to test at the moment in a good way because that feature has not progressed sufficiently and has fatal errors in MIR building. We should make sure to add such tests before we stabilize both features (but shipping one of them is fine).\n\nr? @pnkfelix\ncc @nikomatsakis @matthewjasper @pcwalton\ncc https://github.com/rust-lang/rust/issues/65490", "tree": {"sha": "f7b088dc1993e10a614283fbecc7a7bef4d6e552", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7b088dc1993e10a614283fbecc7a7bef4d6e552"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4cd03dee2b57216b5c95084a0b46de130946ad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cd03dee2b57216b5c95084a0b46de130946ad7", "html_url": "https://github.com/rust-lang/rust/commit/a4cd03dee2b57216b5c95084a0b46de130946ad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4cd03dee2b57216b5c95084a0b46de130946ad7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ae6cedb8d1e37469be1434642a3e403fce50a03", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae6cedb8d1e37469be1434642a3e403fce50a03", "html_url": "https://github.com/rust-lang/rust/commit/9ae6cedb8d1e37469be1434642a3e403fce50a03"}, {"sha": "acfe58272cb188e2da69d2bf1285bf2d954de9a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/acfe58272cb188e2da69d2bf1285bf2d954de9a2", "html_url": "https://github.com/rust-lang/rust/commit/acfe58272cb188e2da69d2bf1285bf2d954de9a2"}], "stats": {"total": 2599, "additions": 2412, "deletions": 187}, "files": [{"sha": "e955b7058e355c232b34eb19f00a3f3e758057c3", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -921,6 +921,16 @@ impl Pat {\n     pub fn walk(&self, mut it: impl FnMut(&Pat) -> bool) {\n         self.walk_(&mut it)\n     }\n+\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If you always want to recurse, prefer this method over `walk`.\n+    pub fn walk_always(&self, mut it: impl FnMut(&Pat)) {\n+        self.walk(|p| {\n+            it(p);\n+            true\n+        })\n+    }\n }\n \n /// A single field in a struct pattern."}, {"sha": "8d3b464a8ffa1e6d67d71559dfabe53eaa83f58b", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -79,11 +79,10 @@ impl hir::Pat {\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n-        self.walk(|p| {\n+        self.walk_always(|p| {\n             if let PatKind::Binding(binding_mode, _, ident, _) = p.kind {\n                 f(binding_mode, p.hir_id, p.span, ident);\n             }\n-            true\n         });\n     }\n "}, {"sha": "e36b11ae0050c0074d007c835b352726182aa542", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -648,6 +648,13 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n+        self.pat_binding_modes().get(id).copied().or_else(|| {\n+            s.delay_span_bug(sp, \"missing binding mode\");\n+            None\n+        })\n+    }\n+\n     pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,"}, {"sha": "700a66438e060269f0200aea39313a72a977c5cc", "filename": "src/librustc_error_codes/error_codes/E0303.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -1,10 +1,18 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Sub-bindings, e.g. `ref x @ Some(ref y)` are now allowed under\n+`#![feature(bindings_after_at)]` and checked to make sure that\n+memory safety is upheld.\n+\n+--------------\n+\n In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n Before:\n \n-```compile_fail,E0303\n+```compile_fail\n match Some(\"hi\".to_string()) {\n     ref op_string_ref @ Some(s) => {},\n     None => {},"}, {"sha": "36664af8782f4eb9b6fb29e8057f67c3c9babfd7", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -539,6 +539,10 @@ declare_features! (\n     /// Allows the use of `loop` and `while` in constants.\n     (active, const_loop, \"1.41.0\", Some(52000), None),\n \n+    /// Allows bindings in the subpattern of a binding pattern.\n+    /// For example, you can write `x @ Some(y)`.\n+    (active, bindings_after_at, \"1.41.0\", Some(65490), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "3a2a2dc412e72c7a39a936309ae3b29da4581387", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -816,15 +816,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                     if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                         name = ident.name;\n-\n-                        if let Some(&bm) = hir_tables.pat_binding_modes().get(pat.hir_id) {\n-                            if bm == ty::BindByValue(hir::Mutability::Mut) {\n+                        match hir_tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n+                            Some(ty::BindByValue(hir::Mutability::Mut)) => {\n                                 mutability = Mutability::Mut;\n-                            } else {\n-                                mutability = Mutability::Not;\n                             }\n-                        } else {\n-                            tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+                            Some(_) => mutability = Mutability::Not,\n+                            _ => {}\n                         }\n                     }\n                 }"}, {"sha": "67c89c7293c43d1698ea9982a2a672476b0d9478", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 151, "deletions": 81, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -4,23 +4,23 @@ use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack}\n \n use super::{PatCtxt, PatKind, PatternError};\n \n-use rustc::lint;\n-use rustc::session::Session;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::HirId;\n use rustc::hir::{self, Pat};\n-\n-use std::slice;\n-\n+use rustc::lint;\n+use rustc::session::Session;\n+use rustc::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_error_codes::*;\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use syntax::ast::Mutability;\n+use syntax::feature_gate::feature_err;\n+use syntax_pos::symbol::sym;\n use syntax_pos::{MultiSpan, Span};\n \n-use rustc_error_codes::*;\n+use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -123,7 +123,10 @@ impl PatCtxt<'_, '_> {\n impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n         check_legality_of_move_bindings(self, has_guard, pat);\n-        check_legality_of_bindings_in_at_patterns(self, pat);\n+        check_borrow_conflicts_in_at_patterns(self, pat);\n+        if !self.tcx.features().bindings_after_at {\n+            check_legality_of_bindings_in_at_patterns(self, pat);\n+        }\n     }\n \n     fn check_match(&mut self, scrut: &hir::Expr, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n@@ -266,20 +269,19 @@ fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, pa\n }\n \n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n-    pat.walk(|p| {\n+    pat.walk_always(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if bm != ty::BindByValue(hir::Mutability::Not) {\n-                    // Nothing to check.\n-                    return true;\n-                }\n+            if let Some(ty::BindByValue(hir::Mutability::Not)) =\n+                cx.tables.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n+            {\n                 let pat_ty = cx.tables.pat_ty(p);\n                 if let ty::Adt(edef, _) = pat_ty.kind {\n                     if edef.is_enum()\n                         && edef.variants.iter().any(|variant| {\n                             variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                         })\n                     {\n+                        // FIXME(Centril): Should be a lint?\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n                         let mut err = struct_span_warn!(\n                             cx.tcx.sess,\n@@ -299,11 +301,8 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                         err.emit();\n                     }\n                 }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(p.span, \"missing binding mode\");\n             }\n         }\n-        true\n     });\n }\n \n@@ -318,7 +317,7 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n     }\n }\n \n-// Check for unreachable patterns\n+/// Check for unreachable patterns.\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     arms: &[(&'p super::Pat<'tcx>, &hir::Pat, bool)],\n@@ -575,105 +574,176 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n     covered\n }\n \n-// Check the legality of legality of by-move bindings.\n+/// Check the legality of legality of by-move bindings.\n fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n-    let mut by_ref_span = None;\n+    let sess = cx.tcx.sess;\n+    let tables = cx.tables;\n+\n+    // Find all by-ref spans.\n+    let mut by_ref_spans = Vec::new();\n     pat.each_binding(|_, hir_id, span, _| {\n-        if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n-            if let ty::BindByReference(..) = bm {\n-                by_ref_span = Some(span);\n-            }\n-        } else {\n-            cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+        if let Some(ty::BindByReference(_)) = tables.extract_binding_mode(sess, hir_id, span) {\n+            by_ref_spans.push(span);\n         }\n     });\n \n-    let span_vec = &mut Vec::new();\n+    // Find bad by-move spans:\n+    let by_move_spans = &mut Vec::new();\n     let mut check_move = |p: &Pat, sub: Option<&Pat>| {\n         // Check legality of moving out of the enum.\n         //\n         // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n         if sub.map_or(false, |p| p.contains_bindings()) {\n-            struct_span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n+            struct_span_err!(sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n-        } else if !has_guard && by_ref_span.is_some() {\n-            span_vec.push(p.span);\n+        } else if !has_guard && !by_ref_spans.is_empty() {\n+            by_move_spans.push(p.span);\n         }\n     };\n-\n-    pat.walk(|p| {\n+    pat.walk_always(|p| {\n         if let hir::PatKind::Binding(.., sub) = &p.kind {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if let ty::BindByValue(..) = bm {\n-                    let pat_ty = cx.tables.node_type(p.hir_id);\n-                    if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n-                        check_move(p, sub.as_deref());\n-                    }\n+            if let Some(ty::BindByValue(_)) = tables.extract_binding_mode(sess, p.hir_id, p.span) {\n+                let pat_ty = tables.node_type(p.hir_id);\n+                if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                    check_move(p, sub.as_deref());\n                 }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n         }\n-        true\n     });\n \n-    if !span_vec.is_empty() {\n+    // Found some bad by-move spans, error!\n+    if !by_move_spans.is_empty() {\n         let mut err = struct_span_err!(\n-            cx.tcx.sess,\n-            MultiSpan::from_spans(span_vec.clone()),\n+            sess,\n+            MultiSpan::from_spans(by_move_spans.clone()),\n             E0009,\n             \"cannot bind by-move and by-ref in the same pattern\",\n         );\n-        if let Some(by_ref_span) = by_ref_span {\n-            err.span_label(by_ref_span, \"both by-ref and by-move used\");\n+        for span in by_ref_spans.iter() {\n+            err.span_label(*span, \"by-ref pattern here\");\n         }\n-        for span in span_vec.iter() {\n+        for span in by_move_spans.iter() {\n             err.span_label(*span, \"by-move pattern here\");\n         }\n         err.emit();\n     }\n }\n \n-/// Forbids bindings in `@` patterns. This is necessary for memory safety,\n-/// because of the way rvalues are handled in the borrow check. (See issue\n-/// #14587.)\n-fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n-    AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n-}\n+/// Check that there are no borrow conflicts in `binding @ subpat` patterns.\n+///\n+/// For example, this would reject:\n+/// - `ref x @ Some(ref mut y)`,\n+/// - `ref mut x @ Some(ref y)`\n+/// - `ref mut x @ Some(ref mut y)`.\n+///\n+/// This analysis is *not* subsumed by NLL.\n+fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+    let tab = cx.tables;\n+    let sess = cx.tcx.sess;\n+    // Get the mutability of `p` if it's by-ref.\n+    let extract_binding_mut = |hir_id, span| match tab.extract_binding_mode(sess, hir_id, span)? {\n+        ty::BindByValue(_) => None,\n+        ty::BindByReference(m) => Some(m),\n+    };\n+    pat.walk_always(|pat| {\n+        // Extract `sub` in `binding @ sub`.\n+        let (name, sub) = match &pat.kind {\n+            hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n+            _ => return,\n+        };\n+\n+        // Extract the mutability.\n+        let mut_outer = match extract_binding_mut(pat.hir_id, pat.span) {\n+            None => return,\n+            Some(m) => m,\n+        };\n+\n+        // We now have `ref $mut_outer binding @ sub` (semantically).\n+        // Recurse into each binding in `sub` and find mutability conflicts.\n+        let mut conflicts_mut_mut = Vec::new();\n+        let mut conflicts_mut_ref = Vec::new();\n+        sub.each_binding(|_, hir_id, span, _| {\n+            if let Some(mut_inner) = extract_binding_mut(hir_id, span) {\n+                match (mut_outer, mut_inner) {\n+                    (Mutability::Not, Mutability::Not) => {}\n+                    (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push(span),\n+                    _ => conflicts_mut_ref.push(span),\n+                }\n+            }\n+        });\n \n-struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n-    cx: &'a MatchVisitor<'b, 'tcx>,\n-    bindings_allowed: bool,\n+        // Report errors if any.\n+        let binding_span = pat.span.with_hi(name.span.hi());\n+        if !conflicts_mut_mut.is_empty() {\n+            // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n+            let msg = &format!(\"cannot borrow `{}` as mutable more than once at a time\", name);\n+            let mut err = sess.struct_span_err(pat.span, msg);\n+            err.span_label(binding_span, \"first mutable borrow occurs here\");\n+            for sp in conflicts_mut_mut {\n+                err.span_label(sp, \"another mutable borrow occurs here\");\n+            }\n+            for sp in conflicts_mut_ref {\n+                err.span_label(sp, \"also borrowed as immutable here\");\n+            }\n+            err.emit();\n+        } else if !conflicts_mut_ref.is_empty() {\n+            // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n+            let (primary, also) = match mut_outer {\n+                Mutability::Mut => (\"mutable\", \"immutable\"),\n+                Mutability::Not => (\"immutable\", \"mutable\"),\n+            };\n+            let msg = &format!(\n+                \"cannot borrow `{}` as {} because it is also borrowed as {}\",\n+                name, also, primary,\n+            );\n+            let mut err = sess.struct_span_err(pat.span, msg);\n+            err.span_label(binding_span, &format!(\"{} borrow occurs here\", primary));\n+            for sp in conflicts_mut_ref {\n+                err.span_label(sp, &format!(\"{} borrow occurs here\", also));\n+            }\n+            err.emit();\n+        }\n+    });\n }\n \n-impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n-        NestedVisitorMap::None\n+/// Forbids bindings in `@` patterns. This used to be is necessary for memory safety,\n+/// because of the way rvalues were handled in the borrow check. (See issue #14587.)\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+    AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n+\n+    struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+        cx: &'a MatchVisitor<'b, 'tcx>,\n+        bindings_allowed: bool,\n     }\n \n-    fn visit_pat(&mut self, pat: &Pat) {\n-        match pat.kind {\n-            hir::PatKind::Binding(.., ref subpat) => {\n-                if !self.bindings_allowed {\n-                    struct_span_err!(\n-                        self.cx.tcx.sess,\n-                        pat.span,\n-                        E0303,\n-                        \"pattern bindings are not allowed after an `@`\"\n-                    )\n-                    .span_label(pat.span, \"not allowed after `@`\")\n-                    .emit();\n-                }\n+    impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n \n-                if subpat.is_some() {\n-                    let bindings_were_allowed = self.bindings_allowed;\n-                    self.bindings_allowed = false;\n-                    intravisit::walk_pat(self, pat);\n-                    self.bindings_allowed = bindings_were_allowed;\n+        fn visit_pat(&mut self, pat: &Pat) {\n+            match pat.kind {\n+                hir::PatKind::Binding(.., ref subpat) => {\n+                    if !self.bindings_allowed {\n+                        feature_err(\n+                            &self.cx.tcx.sess.parse_sess,\n+                            sym::bindings_after_at,\n+                            pat.span,\n+                            \"pattern bindings after an `@` are unstable\",\n+                        )\n+                        .emit();\n+                    }\n+\n+                    if subpat.is_some() {\n+                        let bindings_were_allowed = self.bindings_allowed;\n+                        self.bindings_allowed = false;\n+                        intravisit::walk_pat(self, pat);\n+                        self.bindings_allowed = bindings_were_allowed;\n+                    }\n                 }\n+                _ => intravisit::walk_pat(self, pat),\n             }\n-            _ => intravisit::walk_pat(self, pat),\n         }\n     }\n }"}, {"sha": "1540e6d7c053f63e86cd4217362b039bc9404006", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -406,6 +406,7 @@ impl<'a> Parser<'a> {\n         if let PatKind::Ident(_, _, ref mut sub @ None) = rhs.kind {\n             // The user inverted the order, so help them fix that.\n             let mut applicability = Applicability::MachineApplicable;\n+            // FIXME(bindings_after_at): Remove this code when stabilizing the feature.\n             lhs.walk(&mut |p| match p.kind {\n                 // `check_match` is unhappy if the subpattern has a binding anywhere.\n                 PatKind::Ident(..) => {"}, {"sha": "149f27ed305fb825d43f0e7a72001141bd9d3779", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -1007,20 +1007,13 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n-            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n+            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n                 // `ref x` pattern\n-                if let PatKind::Binding(..) = sub_pat.kind {\n-                    if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n-                        if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(\n-                                sub_pat.span,\n-                                sub_pat.hir_id,\n-                                mutbl,\n-                                &sub_cmt,\n-                            );\n-                        }\n-                    } else {\n-                        self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n+                if let PatKind::Binding(..) = kind {\n+                    if let Some(ty::BindByReference(mutbl)) =\n+                        mc.tables.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n+                    {\n+                        self.link_region_from_node_type(*span, *hir_id, mutbl, &sub_cmt);\n                     }\n                 }\n             })"}, {"sha": "5ef5f4c648e8ce73ef7263944198d1065cc4e4fc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -284,10 +284,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         match p.kind {\n             hir::PatKind::Binding(..) => {\n-                if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n+                let tables = self.fcx.tables.borrow();\n+                if let Some(bm) = tables.extract_binding_mode(self.tcx().sess, p.hir_id, p.span) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n-                } else {\n-                    self.tcx().sess.delay_span_bug(p.span, \"missing binding mode\");\n                 }\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {"}, {"sha": "f3f5e54edd1954bb8dae0f8b6530ec909c1bb7f9", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -534,7 +534,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n-                if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n+                if let Some(bm) = mc.tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n                     debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n \n                     // pat_ty: the type of the binding being produced.\n@@ -560,8 +560,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             delegate.consume(place, mode);\n                         }\n                     }\n-                } else {\n-                    tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n         }));"}, {"sha": "8fdc199d9ed7ce2cdb8bea2578c02d0e824d3e44", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -165,6 +165,7 @@ symbols! {\n         bench,\n         bin,\n         bind_by_move_pattern_guards,\n+        bindings_after_at,\n         block,\n         bool,\n         borrowck_graphviz_postflow,"}, {"sha": "ff00aa8caa8d3bcfa7692c899b6e32d43c829eb0", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-2.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -4,7 +4,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n LL |         Some((ref _y, _z)) => { },\n    |               ------  ^^ by-move pattern here\n    |               |\n-   |               both by-ref and by-move used\n+   |               by-ref pattern here\n \n error: aborting due to previous error\n "}, {"sha": "3e8358da3507da058d783590bd2a91a44639a37c", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-3.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -4,7 +4,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n LL |         DoubleOption::Some2(ref _y, _z) => { },\n    |                             ------  ^^ by-move pattern here\n    |                             |\n-   |                             both by-ref and by-move used\n+   |                             by-ref pattern here\n \n error: aborting due to previous error\n "}, {"sha": "00e0c70d6494b6d658ba149f64337498cd950aa1", "filename": "src/test/ui/bind-by-move/bind-by-move-neither-can-live-while-the-other-survives-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbind-by-move%2Fbind-by-move-neither-can-live-while-the-other-survives-4.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -2,7 +2,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-4.rs:12:15\n    |\n LL |         Some((_y, ref _z)) => { },\n-   |               ^^  ------ both by-ref and by-move used\n+   |               ^^  ------ by-ref pattern here\n    |               |\n    |               by-move pattern here\n "}, {"sha": "022ac5fc113ddbf6a631ed1529ea1b4543a53924", "filename": "src/test/ui/error-codes/E0007.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Ferror-codes%2FE0007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Ferror-codes%2FE0007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0007.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -1,9 +1,10 @@\n+#![feature(bindings_after_at)]\n+\n fn main() {\n     let x = Some(\"s\".to_string());\n     match x {\n         op_string @ Some(s) => {},\n         //~^ ERROR E0007\n-        //~| ERROR E0303\n         //~| ERROR E0382\n         None => {},\n     }"}, {"sha": "31af9171725bb5983a6190709d67e1924d7f4d68", "filename": "src/test/ui/error-codes/E0007.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Ferror-codes%2FE0007.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Ferror-codes%2FE0007.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0007.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -1,17 +1,11 @@\n error[E0007]: cannot bind by-move with sub-bindings\n-  --> $DIR/E0007.rs:4:9\n+  --> $DIR/E0007.rs:6:9\n    |\n LL |         op_string @ Some(s) => {},\n    |         ^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n \n-error[E0303]: pattern bindings are not allowed after an `@`\n-  --> $DIR/E0007.rs:4:26\n-   |\n-LL |         op_string @ Some(s) => {},\n-   |                          ^ not allowed after `@`\n-\n error[E0382]: use of moved value\n-  --> $DIR/E0007.rs:4:26\n+  --> $DIR/E0007.rs:6:26\n    |\n LL |     let x = Some(\"s\".to_string());\n    |         - move occurs because `x` has type `std::option::Option<std::string::String>`, which does not implement the `Copy` trait\n@@ -22,7 +16,7 @@ LL |         op_string @ Some(s) => {},\n    |         |                value used here after move\n    |         value moved here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0007, E0303, E0382.\n+Some errors have detailed explanations: E0007, E0382.\n For more information about an error, try `rustc --explain E0007`."}, {"sha": "446a436d6477952c8b15cd7e1029fb14e653abe8", "filename": "src/test/ui/error-codes/E0009.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Ferror-codes%2FE0009.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Ferror-codes%2FE0009.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0009.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -2,7 +2,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n   --> $DIR/E0009.rs:5:15\n    |\n LL |         Some((y, ref z)) => {},\n-   |               ^  ----- both by-ref and by-move used\n+   |               ^  ----- by-ref pattern here\n    |               |\n    |               by-move pattern here\n "}, {"sha": "af537ce5625ca8a9a572b8bfc92ca43cc90c3191", "filename": "src/test/ui/error-codes/E0303.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ferror-codes%2FE0303.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Ferror-codes%2FE0303.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0303.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,19 +0,0 @@\n-error[E0009]: cannot bind by-move and by-ref in the same pattern\n-  --> $DIR/E0303.rs:3:34\n-   |\n-LL |         ref op_string_ref @ Some(s) => {},\n-   |         -------------------------^-\n-   |         |                        |\n-   |         |                        by-move pattern here\n-   |         both by-ref and by-move used\n-\n-error[E0303]: pattern bindings are not allowed after an `@`\n-  --> $DIR/E0303.rs:3:34\n-   |\n-LL |         ref op_string_ref @ Some(s) => {},\n-   |                                  ^ not allowed after `@`\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0009, E0303.\n-For more information about an error, try `rustc --explain E0009`."}, {"sha": "9cb034e7592daa90ce5697d09d001ba869f1b1d8", "filename": "src/test/ui/issues/issue-53840.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fissues%2Fissue-53840.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fissues%2Fissue-53840.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-53840.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -2,7 +2,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n   --> $DIR/issue-53840.rs:13:16\n    |\n LL |         E::Foo(a, b, ref c) => {}\n-   |                ^  ^  ----- both by-ref and by-move used\n+   |                ^  ^  ----- by-ref pattern here\n    |                |  |\n    |                |  by-move pattern here\n    |                by-move pattern here\n@@ -11,7 +11,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n   --> $DIR/issue-53840.rs:17:14\n    |\n LL |         Bar {a, ref b} => {}\n-   |              ^  ----- both by-ref and by-move used\n+   |              ^  ----- by-ref pattern here\n    |              |\n    |              by-move pattern here\n "}, {"sha": "75d7af58e706db60c96578aa07edd27cb9a09dd4", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,35 @@\n+// This test is taken directly from #16053.\n+// It checks that you cannot use an AND-pattern (`binding @ pat`)\n+// where one side is by-ref and the other is by-move.\n+\n+#![feature(bindings_after_at)]\n+\n+struct X { x: () }\n+\n+fn main() {\n+    let x = Some(X { x: () });\n+    match x {\n+        Some(ref _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+        None => panic!()\n+    }\n+\n+    let x = Some(X { x: () });\n+    match x {\n+        Some(_z @ ref _y) => { }, //~ ERROR cannot bind by-move with sub-bindings\n+        //~^ ERROR borrow of moved value\n+        None => panic!()\n+    }\n+\n+    let mut x = Some(X { x: () });\n+    match x {\n+        Some(ref mut _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n+        None => panic!()\n+    }\n+\n+    let mut x = Some(X { x: () });\n+    match x {\n+        Some(_z @ ref mut _y) => { }, //~ ERROR cannot bind by-move with sub-bindings\n+        //~^ ERROR borrow of moved value\n+        None => panic!()\n+    }\n+}"}, {"sha": "22d62ff4f003f1bdbf311413b208151dc3f00387", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,56 @@\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:12:23\n+   |\n+LL |         Some(ref _y @ _z) => { },\n+   |              ---------^^\n+   |              |        |\n+   |              |        by-move pattern here\n+   |              by-ref pattern here\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:18:14\n+   |\n+LL |         Some(_z @ ref _y) => { },\n+   |              ^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:25:27\n+   |\n+LL |         Some(ref mut _y @ _z) => { },\n+   |              -------------^^\n+   |              |            |\n+   |              |            by-move pattern here\n+   |              by-ref pattern here\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:31:14\n+   |\n+LL |         Some(_z @ ref mut _y) => { },\n+   |              ^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:18:19\n+   |\n+LL |         Some(_z @ ref _y) => { },\n+   |              -----^^^^^^\n+   |              |    |\n+   |              |    value borrowed here after move\n+   |              value moved here\n+   |\n+   = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:31:19\n+   |\n+LL |         Some(_z @ ref mut _y) => { },\n+   |              -----^^^^^^^^^^\n+   |              |    |\n+   |              |    value borrowed here after move\n+   |              value moved here\n+   |\n+   = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0007, E0009, E0382.\n+For more information about an error, try `rustc --explain E0007`."}, {"sha": "86fb04e2edf5bb4d19a07ad90f6be2cf47b3b225", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,14 @@\n+// See issue #12534.\n+\n+#![feature(bindings_after_at)]\n+\n+fn main() {}\n+\n+struct A(Box<u8>);\n+\n+fn f(a @ A(u): A) -> Box<u8> {\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+    drop(a);\n+    u\n+}"}, {"sha": "b039708fd3e0a4c85be7c583ef15feff261bbf30", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,20 @@\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:9:6\n+   |\n+LL | fn f(a @ A(u): A) -> Box<u8> {\n+   |      ^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0382]: use of moved value\n+  --> $DIR/bind-by-move-no-subbindings-fun-param.rs:9:12\n+   |\n+LL | fn f(a @ A(u): A) -> Box<u8> {\n+   |      ------^-\n+   |      |     |\n+   |      |     value used here after move\n+   |      value moved here\n+   |      move occurs because value has type `A`, which does not implement the `Copy` trait\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0007, E0382.\n+For more information about an error, try `rustc --explain E0007`."}, {"sha": "1d9f341c5146ae1e1cf3ca4c94ed4bb6c5ac8b6b", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,47 @@\n+// Test that moving on both sides of an `@` pattern is not allowed.\n+\n+#![feature(bindings_after_at)]\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    struct U; // Not copy!\n+\n+    // Prevent promotion:\n+    fn u() -> U { U }\n+\n+    let a @ b = U;\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    let a @ (b, c) = (U, U);\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    let a @ (b, c) = (u(), u());\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    match Ok(U) {\n+        a @ Ok(b) | a @ Err(b) => {}\n+        //~^ ERROR cannot bind by-move with sub-bindings\n+        //~| ERROR use of moved value\n+        //~| ERROR cannot bind by-move with sub-bindings\n+        //~| ERROR use of moved value\n+    }\n+\n+    fn fun(a @ b: U) {}\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    match [u(), u(), u(), u()] {\n+        xs @ [a, .., b] => {}\n+        //~^ ERROR cannot bind by-move with sub-bindings\n+        //~| ERROR use of moved value\n+    }\n+\n+    match [u(), u(), u(), u()] {\n+        xs @ [_, ys @ .., _] => {}\n+        //~^ ERROR cannot bind by-move with sub-bindings\n+        //~| ERROR use of moved value\n+    }\n+}"}, {"sha": "f3f8fd655ce0cad831414c69a7f4b5276162c0fb", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.stderr", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,133 @@\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:12:9\n+   |\n+LL |     let a @ b = U;\n+   |         ^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:16:9\n+   |\n+LL |     let a @ (b, c) = (U, U);\n+   |         ^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:20:9\n+   |\n+LL |     let a @ (b, c) = (u(), u());\n+   |         ^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:25:9\n+   |\n+LL |         a @ Ok(b) | a @ Err(b) => {}\n+   |         ^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:25:21\n+   |\n+LL |         a @ Ok(b) | a @ Err(b) => {}\n+   |                     ^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:37:9\n+   |\n+LL |         xs @ [a, .., b] => {}\n+   |         ^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:43:9\n+   |\n+LL |         xs @ [_, ys @ .., _] => {}\n+   |         ^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-move-and-move.rs:32:12\n+   |\n+LL |     fn fun(a @ b: U) {}\n+   |            ^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:12:13\n+   |\n+LL |     let a @ b = U;\n+   |         ----^   - move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+   |         |   |\n+   |         |   value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:16:17\n+   |\n+LL |     let a @ (b, c) = (U, U);\n+   |         --------^-   ------ move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n+   |         |       |\n+   |         |       value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:20:17\n+   |\n+LL |     let a @ (b, c) = (u(), u());\n+   |         --------^-   ---------- move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n+   |         |       |\n+   |         |       value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:25:16\n+   |\n+LL |     match Ok(U) {\n+   |           ----- move occurs because value has type `std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n+LL |         a @ Ok(b) | a @ Err(b) => {}\n+   |         -------^-\n+   |         |      |\n+   |         |      value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:25:29\n+   |\n+LL |     match Ok(U) {\n+   |           ----- move occurs because value has type `std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n+LL |         a @ Ok(b) | a @ Err(b) => {}\n+   |                     --------^-\n+   |                     |       |\n+   |                     |       value used here after move\n+   |                     value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:37:22\n+   |\n+LL |     match [u(), u(), u(), u()] {\n+   |           -------------------- move occurs because value has type `[main::U; 4]`, which does not implement the `Copy` trait\n+LL |         xs @ [a, .., b] => {}\n+   |         -------------^-\n+   |         |            |\n+   |         |            value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:43:18\n+   |\n+LL |     match [u(), u(), u(), u()] {\n+   |           -------------------- move occurs because value has type `[main::U; 4]`, which does not implement the `Copy` trait\n+LL |         xs @ [_, ys @ .., _] => {}\n+   |         ---------^^^^^^^----\n+   |         |        |\n+   |         |        value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-move-and-move.rs:32:16\n+   |\n+LL |     fn fun(a @ b: U) {}\n+   |            ----^\n+   |            |   |\n+   |            |   value used here after move\n+   |            value moved here\n+   |            move occurs because value has type `main::U`, which does not implement the `Copy` trait\n+\n+error: aborting due to 16 previous errors\n+\n+Some errors have detailed explanations: E0007, E0382.\n+For more information about an error, try `rustc --explain E0007`."}, {"sha": "afac8d990b4744f8178d2de4a1a2200d02b88bb7", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box-pass.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box-pass.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,76 @@\n+// check-pass\n+\n+// Test `@` patterns combined with `box` patterns.\n+\n+#![feature(bindings_after_at)]\n+#![feature(box_patterns)]\n+#![feature(slice_patterns)]\n+\n+#[derive(Copy, Clone)]\n+struct C;\n+\n+fn c() -> C { C }\n+\n+struct NC;\n+\n+fn nc() -> NC { NC }\n+\n+fn main() {\n+    let ref a @ box b = Box::new(C); // OK; the type is `Copy`.\n+    drop(b);\n+    drop(b);\n+    drop(a);\n+\n+    let ref a @ box b = Box::new(c()); // OK; the type is `Copy`.\n+    drop(b);\n+    drop(b);\n+    drop(a);\n+\n+    fn f3(ref a @ box b: Box<C>) { // OK; the type is `Copy`.\n+        drop(b);\n+        drop(b);\n+        drop(a);\n+    }\n+    match Box::new(c()) {\n+        ref a @ box b => { // OK; the type is `Copy`.\n+            drop(b);\n+            drop(b);\n+            drop(a);\n+        }\n+    }\n+\n+    let ref a @ box ref b = Box::new(NC); // OK.\n+    drop(a);\n+    drop(b);\n+\n+    fn f4(ref a @ box ref b: Box<NC>) { // OK.\n+        drop(a);\n+        drop(b)\n+    }\n+\n+    match Box::new(nc()) {\n+        ref a @ box ref b => { // OK.\n+            drop(a);\n+            drop(b);\n+        }\n+    }\n+\n+    match Box::new([Ok(c()), Err(nc()), Ok(c())]) {\n+        box [Ok(a), ref xs @ .., Err(ref b)] => {\n+            let _: C = a;\n+            let _: &[Result<C, NC>; 1] = xs;\n+            let _: &NC = b;\n+        }\n+        _ => {}\n+    }\n+\n+    match [Ok(Box::new(c())), Err(Box::new(nc())), Ok(Box::new(c())), Ok(Box::new(c()))] {\n+        [Ok(box a), ref xs @ .., Err(box ref b), Err(box ref c)] => {\n+            let _: C = a;\n+            let _: &[Result<Box<C>, Box<NC>>; 1] = xs;\n+            let _: &NC = b;\n+            let _: &NC = c;\n+        }\n+        _ => {}\n+    }\n+}"}, {"sha": "fce31409e16c434cc508e5b841a0d9e53d973cce", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,85 @@\n+// Test `@` patterns combined with `box` patterns.\n+\n+#![feature(bindings_after_at)]\n+#![feature(box_patterns)]\n+#![feature(slice_patterns)]\n+\n+#[derive(Copy, Clone)]\n+struct C;\n+\n+fn c() -> C { C }\n+\n+struct NC;\n+\n+fn nc() -> NC { NC }\n+\n+fn main() {\n+    let a @ box &b = Box::new(&C);\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    let a @ box b = Box::new(C);\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    fn f1(a @ box &b: Box<&C>) {}\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    fn f2(a @ box b: Box<C>) {}\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    match Box::new(C) { a @ box b => {} }\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    let ref a @ box b = Box::new(NC); //~ ERROR cannot bind by-move and by-ref in the same pattern\n+\n+    let ref a @ box ref mut b = Box::new(nc());\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    let ref a @ box ref mut b = Box::new(NC);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    let ref a @ box ref mut b = Box::new(NC);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    *b = NC;\n+    let ref a @ box ref mut b = Box::new(NC);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    *b = NC;\n+    drop(a);\n+\n+    let ref mut a @ box ref b = Box::new(NC);\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+    *a = Box::new(NC);\n+    drop(b);\n+\n+    fn f5(ref mut a @ box ref b: Box<NC>) {\n+        //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+        *a = Box::new(NC);\n+        drop(b);\n+    }\n+\n+    match Box::new(nc()) {\n+        ref mut a @ box ref b => {\n+            //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+            //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+            *a = Box::new(NC);\n+            drop(b);\n+        }\n+    }\n+\n+    match Box::new([Ok(c()), Err(nc()), Ok(c())]) {\n+        box [Ok(a), ref xs @ .., Err(b)] => {}\n+        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n+        _ => {}\n+    }\n+\n+    match [Ok(Box::new(c())), Err(Box::new(nc())), Ok(Box::new(c())), Ok(Box::new(c()))] {\n+        [Ok(box ref a), ref xs @ .., Err(box b), Err(box ref mut c)] => {}\n+        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n+        _ => {}\n+    }\n+}"}, {"sha": "5772fadd1e7418687116fc16f40a23352822630c", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,220 @@\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-at-and-box.rs:17:9\n+   |\n+LL |     let a @ box &b = Box::new(&C);\n+   |         ^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-at-and-box.rs:21:9\n+   |\n+LL |     let a @ box b = Box::new(C);\n+   |         ^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-at-and-box.rs:33:25\n+   |\n+LL |     match Box::new(C) { a @ box b => {} }\n+   |                         ^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/borrowck-pat-at-and-box.rs:37:21\n+   |\n+LL |     let ref a @ box b = Box::new(NC);\n+   |         ------------^\n+   |         |           |\n+   |         |           by-move pattern here\n+   |         by-ref pattern here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:39:9\n+   |\n+LL |     let ref a @ box ref mut b = Box::new(nc());\n+   |         -----^^^^^^^---------\n+   |         |           |\n+   |         |           mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:41:9\n+   |\n+LL |     let ref a @ box ref mut b = Box::new(NC);\n+   |         -----^^^^^^^---------\n+   |         |           |\n+   |         |           mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:43:9\n+   |\n+LL |     let ref a @ box ref mut b = Box::new(NC);\n+   |         -----^^^^^^^---------\n+   |         |           |\n+   |         |           mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:46:9\n+   |\n+LL |     let ref a @ box ref mut b = Box::new(NC);\n+   |         -----^^^^^^^---------\n+   |         |           |\n+   |         |           mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:52:9\n+   |\n+LL |     let ref mut a @ box ref b = Box::new(NC);\n+   |         ---------^^^^^^^-----\n+   |         |               |\n+   |         |               immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:66:9\n+   |\n+LL |         ref mut a @ box ref b => {\n+   |         ---------^^^^^^^-----\n+   |         |               |\n+   |         |               immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/borrowck-pat-at-and-box.rs:75:38\n+   |\n+LL |         box [Ok(a), ref xs @ .., Err(b)] => {}\n+   |                     -----------      ^ by-move pattern here\n+   |                     |\n+   |                     by-ref pattern here\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/borrowck-pat-at-and-box.rs:81:46\n+   |\n+LL |         [Ok(box ref a), ref xs @ .., Err(box b), Err(box ref mut c)] => {}\n+   |                 -----   -----------          ^           --------- by-ref pattern here\n+   |                 |       |                    |\n+   |                 |       |                    by-move pattern here\n+   |                 |       by-ref pattern here\n+   |                 by-ref pattern here\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-at-and-box.rs:25:11\n+   |\n+LL |     fn f1(a @ box &b: Box<&C>) {}\n+   |           ^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-at-and-box.rs:29:11\n+   |\n+LL |     fn f2(a @ box b: Box<C>) {}\n+   |           ^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:58:11\n+   |\n+LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n+   |           ---------^^^^^^^-----\n+   |           |               |\n+   |           |               immutable borrow occurs here\n+   |           mutable borrow occurs here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-at-and-box.rs:17:18\n+   |\n+LL |     let a @ box &b = Box::new(&C);\n+   |         ---------^   ------------ move occurs because value has type `std::boxed::Box<&C>`, which does not implement the `Copy` trait\n+   |         |        |\n+   |         |        value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-at-and-box.rs:21:17\n+   |\n+LL |     let a @ box b = Box::new(C);\n+   |         --------^   ----------- move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n+   |         |       |\n+   |         |       value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-at-and-box.rs:33:33\n+   |\n+LL |     match Box::new(C) { a @ box b => {} }\n+   |           -----------   --------^\n+   |           |             |       |\n+   |           |             |       value used here after move\n+   |           |             value moved here\n+   |           move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:46:21\n+   |\n+LL |     let ref a @ box ref mut b = Box::new(NC);\n+   |         ------------^^^^^^^^^\n+   |         |           |\n+   |         |           mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:52:25\n+   |\n+LL |     let ref mut a @ box ref b = Box::new(NC);\n+   |         ----------------^^^^^\n+   |         |               |\n+   |         |               immutable borrow occurs here\n+   |         mutable borrow occurs here\n+...\n+LL |     *a = Box::new(NC);\n+   |     -- mutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:66:25\n+   |\n+LL |         ref mut a @ box ref b => {\n+   |         ----------------^^^^^\n+   |         |               |\n+   |         |               immutable borrow occurs here\n+   |         mutable borrow occurs here\n+...\n+LL |             *a = Box::new(NC);\n+   |             -- mutable borrow later used here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-at-and-box.rs:25:20\n+   |\n+LL |     fn f1(a @ box &b: Box<&C>) {}\n+   |           ---------^\n+   |           |        |\n+   |           |        value used here after move\n+   |           value moved here\n+   |           move occurs because value has type `std::boxed::Box<&C>`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value\n+  --> $DIR/borrowck-pat-at-and-box.rs:29:19\n+   |\n+LL |     fn f2(a @ box b: Box<C>) {}\n+   |           --------^\n+   |           |       |\n+   |           |       value used here after move\n+   |           value moved here\n+   |           move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n+\n+error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-at-and-box.rs:58:27\n+   |\n+LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n+   |           ----------------^^^^^\n+   |           |               |\n+   |           |               immutable borrow occurs here\n+   |           mutable borrow occurs here\n+...\n+LL |         *a = Box::new(NC);\n+   |         -- mutable borrow later used here\n+\n+error: aborting due to 24 previous errors\n+\n+Some errors have detailed explanations: E0007, E0009, E0382, E0502.\n+For more information about an error, try `rustc --explain E0007`."}, {"sha": "be19e5f2a85cabad53abed7a6b2af4b0dfe4c05d", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-copy-bindings-in-at.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-copy-bindings-in-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-copy-bindings-in-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-copy-bindings-in-at.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,52 @@\n+// check-pass\n+\n+// Test `Copy` bindings in the rhs of `@` patterns.\n+\n+#![feature(slice_patterns)]\n+#![feature(bindings_after_at)]\n+\n+#[derive(Copy, Clone)]\n+struct C;\n+\n+fn mk_c() -> C { C }\n+\n+#[derive(Copy, Clone)]\n+struct P<A, B>(A, B);\n+\n+enum E<A, B> { L(A), R(B) }\n+\n+fn main() {\n+    let a @ b @ c @ d = C;\n+    let a @ (b, c) = (C, mk_c());\n+    let a @ P(b, P(c, d)) = P(mk_c(), P(C, C));\n+    let a @ [b, c] = [C, C];\n+    let a @ [b, .., c] = [C, mk_c(), C];\n+    let a @ [b, mid @ .., c] = [C, mk_c(), C];\n+    let a @ &(b, c) = &(C, C);\n+    let a @ &(b, &P(c, d)) = &(mk_c(), &P(C, C));\n+\n+    fn foo(a @ [b, mid @ .., c]: [C; 3]) {}\n+\n+    use self::E::*;\n+    match L(C) {\n+        L(a) | R(a) => {\n+            let a: C = a;\n+            drop(a);\n+            drop(a);\n+        }\n+    }\n+    match R(&L(&mk_c())) {\n+        L(L(&a)) | L(R(&a)) | R(L(&a)) | R(R(&a)) => {\n+            let a: C = a;\n+            drop(a);\n+            drop(a);\n+        }\n+    }\n+\n+    match Ok(mk_c()) {\n+        Ok(ref a @ b) | Err(b @ ref a) => {\n+            let _: &C = a;\n+            let _: C = b;\n+        }\n+    }\n+}"}, {"sha": "abe5ed81b71a240b8088ad1e44d03d8f51ec9a4d", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -1,8 +1,9 @@\n+#![feature(bindings_after_at)]\n+\n fn main() {\n     match Some(\"hi\".to_string()) {\n         ref op_string_ref @ Some(s) => {},\n-        //~^ ERROR pattern bindings are not allowed after an `@` [E0303]\n-        //~| ERROR E0009\n+        //~^ ERROR cannot bind by-move and by-ref in the same pattern [E0009]\n         None => {},\n     }\n }", "previous_filename": "src/test/ui/error-codes/E0303.rs"}, {"sha": "1f70a6c437e92e61aa2357490ebf85e9e39328ba", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,12 @@\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/borrowck-pat-by-move-and-ref.rs:5:34\n+   |\n+LL |         ref op_string_ref @ Some(s) => {},\n+   |         -------------------------^-\n+   |         |                        |\n+   |         |                        by-move pattern here\n+   |         by-ref pattern here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0009`."}, {"sha": "edf9fb31458909b6d228d56a79980aa9a439fb7f", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-both-sides.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-both-sides.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-both-sides.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-both-sides.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,48 @@\n+// check-pass\n+\n+// Test that `ref` patterns may be used on both sides\n+// of an `@` pattern according to NLL borrowck.\n+\n+#![feature(bindings_after_at)]\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    struct U; // Not copy!\n+\n+    // Promotion:\n+    let ref a @ ref b = U;\n+    let _: &U = a;\n+    let _: &U = b;\n+\n+    // Prevent promotion:\n+    fn u() -> U { U }\n+\n+    let ref a @ ref b = u();\n+    let _: &U = a;\n+    let _: &U = b;\n+\n+    let ref a @ (ref b, [ref c, ref d]) = (u(), [u(), u()]);\n+    let _: &(U, [U; 2]) = a;\n+    let _: &U = b;\n+    let _: &U = c;\n+    let _: &U = d;\n+\n+    fn f1(ref a @ (ref b, [ref c, ref mid @ .., ref d]): (U, [U; 4])) {}\n+\n+    let a @ (b, [c, d]) = &(u(), [u(), u()]);\n+    let _: &(U, [U; 2]) = a;\n+    let _: &U = b;\n+    let _: &U = c;\n+    let _: &U = d;\n+\n+    let ref a @ &ref b = &u();\n+    let _: &&U = a;\n+    let _: &U = b;\n+\n+    match Ok(u()) {\n+        ref a @ Ok(ref b) | ref a @ Err(ref b) => {\n+            let _: &Result<U, U> = a;\n+            let _: &U = b;\n+        }\n+    }\n+}"}, {"sha": "88eda9afec7eb853bc9f9e1301e63b8a56b3b145", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,133 @@\n+#![feature(bindings_after_at)]\n+#![feature(slice_patterns)]\n+\n+enum Option<T> {\n+    None,\n+    Some(T),\n+}\n+\n+fn main() {\n+    match &mut Some(1) {\n+        ref mut z @ &mut Some(ref a) => {\n+        //~^ ERROR cannot borrow `z` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+            **z = None;\n+            println!(\"{}\", *a);\n+        }\n+        _ => ()\n+    }\n+\n+    struct U;\n+\n+    // Prevent promotion:\n+    fn u() -> U { U }\n+\n+    fn f1(ref a @ ref mut b: U) {}\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    fn f2(ref mut a @ ref b: U) {}\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+\n+    let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~| ERROR cannot borrow `b` as mutable because it is also borrowed as immutable\n+\n+    let ref a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    let ref mut a @ ref b = U;\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    let ref a @ (ref mut b, ref mut c) = (U, U);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    let ref mut a @ (ref b, ref c) = (U, U);\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+\n+    let ref mut a @ ref b = u();\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+    *a = u();\n+    drop(b);\n+    let ref a @ ref mut b = u();\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    *b = u();\n+    drop(a);\n+\n+    let ref mut a @ ref b = U;\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+    *a = U;\n+    drop(b);\n+    let ref a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    *b = U;\n+    drop(a);\n+\n+    match Ok(U) {\n+        ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n+            //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+            //~| ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+            *a = Err(U);\n+            drop(b);\n+        }\n+    }\n+\n+    match Ok(U) {\n+        ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n+            //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+            *b = U;\n+            drop(a);\n+        }\n+    }\n+\n+    match Ok(U) {\n+        ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n+        //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+        //~| ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+        //~| ERROR cannot assign to `*b`, as it is immutable for the pattern guard\n+        _ => {}\n+    }\n+    match Ok(U) {\n+        ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n+        //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot assign to `*a`, as it is immutable for the pattern guard\n+        _ => {}\n+    }\n+    match Ok(U) {\n+        ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n+        //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+        //~| ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+        //~| ERROR cannot move out of `b` in pattern guard\n+        _ => {}\n+    }\n+    match Ok(U) {\n+        ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n+        //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot move out of `a` in pattern guard\n+        _ => {}\n+    }\n+\n+    let ref a @ (ref mut b, ref mut c) = (U, U);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    *b = U;\n+    *c = U;\n+\n+    let ref a @ (ref mut b, ref mut c) = (U, U);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    *b = U;\n+    drop(a);\n+\n+    let ref a @ (ref mut b, ref mut c) = (U, U);\n+    //~^ ERROR cannot borrow `a` as mutable because it is also borrowed as immutable\n+    *b = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    *c = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    drop(a);\n+    let ref mut a @ (ref b, ref c) = (U, U);\n+    //~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable\n+}"}, {"sha": "b068a6125b670fded33ac94cb5520095c7d5d0d9", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,421 @@\n+error: cannot borrow `z` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:9\n+   |\n+LL |         ref mut z @ &mut Some(ref a) => {\n+   |         ---------^^^^^^^^^^^^^-----^\n+   |         |                     |\n+   |         |                     immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:32:9\n+   |\n+LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n+   |         ---------^^^^-----------------^\n+   |         |            |       |\n+   |         |            |       another mutable borrow occurs here\n+   |         |            also borrowed as immutable here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `b` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:32:22\n+   |\n+LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n+   |                      -----^^^---------\n+   |                      |       |\n+   |                      |       mutable borrow occurs here\n+   |                      immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:36:9\n+   |\n+LL |     let ref a @ ref mut b = U;\n+   |         -----^^^---------\n+   |         |       |\n+   |         |       mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:38:9\n+   |\n+LL |     let ref mut a @ ref b = U;\n+   |         ---------^^^-----\n+   |         |           |\n+   |         |           immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:40:9\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         -----^^^^---------^^---------^\n+   |         |        |          |\n+   |         |        |          mutable borrow occurs here\n+   |         |        mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:42:9\n+   |\n+LL |     let ref mut a @ (ref b, ref c) = (U, U);\n+   |         ---------^^^^-----^^-----^\n+   |         |            |      |\n+   |         |            |      immutable borrow occurs here\n+   |         |            immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:45:9\n+   |\n+LL |     let ref mut a @ ref b = u();\n+   |         ---------^^^-----\n+   |         |           |\n+   |         |           immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:50:9\n+   |\n+LL |     let ref a @ ref mut b = u();\n+   |         -----^^^---------\n+   |         |       |\n+   |         |       mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:56:9\n+   |\n+LL |     let ref mut a @ ref b = U;\n+   |         ---------^^^-----\n+   |         |           |\n+   |         |           immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:60:9\n+   |\n+LL |     let ref a @ ref mut b = U;\n+   |         -----^^^---------\n+   |         |       |\n+   |         |       mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:66:9\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n+   |         ---------^^^^^^-----^\n+   |         |              |\n+   |         |              immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:66:33\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n+   |                                 ---------^^^^^^^-----^\n+   |                                 |               |\n+   |                                 |               immutable borrow occurs here\n+   |                                 mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:75:9\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n+   |         -----^^^^^^---------^\n+   |         |          |\n+   |         |          mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:75:33\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n+   |                                 -----^^^^^^^---------^\n+   |                                 |           |\n+   |                                 |           mutable borrow occurs here\n+   |                                 immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:86:9\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n+   |         -----^^^^^^---------^\n+   |         |          |\n+   |         |          mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:86:33\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n+   |                                 -----^^^^^^^---------^\n+   |                                 |           |\n+   |                                 |           mutable borrow occurs here\n+   |                                 immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:93:9\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n+   |         ---------^^^^^^-----^\n+   |         |              |\n+   |         |              immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:93:33\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n+   |                                 ---------^^^^^^^-----^\n+   |                                 |               |\n+   |                                 |               immutable borrow occurs here\n+   |                                 mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:100:9\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n+   |         -----^^^^^^---------^\n+   |         |          |\n+   |         |          mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:100:33\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n+   |                                 -----^^^^^^^---------^\n+   |                                 |           |\n+   |                                 |           mutable borrow occurs here\n+   |                                 immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:9\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n+   |         ---------^^^^^^-----^\n+   |         |              |\n+   |         |              immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:33\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n+   |                                 ---------^^^^^^^-----^\n+   |                                 |               |\n+   |                                 |               immutable borrow occurs here\n+   |                                 mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:114:9\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         -----^^^^---------^^---------^\n+   |         |        |          |\n+   |         |        |          mutable borrow occurs here\n+   |         |        mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:119:9\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         -----^^^^---------^^---------^\n+   |         |        |          |\n+   |         |        |          mutable borrow occurs here\n+   |         |        mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:126:9\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         -----^^^^---------^^---------^\n+   |         |        |          |\n+   |         |        |          mutable borrow occurs here\n+   |         |        mutable borrow occurs here\n+   |         immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:9\n+   |\n+LL |     let ref mut a @ (ref b, ref c) = (U, U);\n+   |         ---------^^^^-----^^-----^\n+   |         |            |      |\n+   |         |            |      immutable borrow occurs here\n+   |         |            immutable borrow occurs here\n+   |         mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:25:11\n+   |\n+LL |     fn f1(ref a @ ref mut b: U) {}\n+   |           -----^^^---------\n+   |           |       |\n+   |           |       mutable borrow occurs here\n+   |           immutable borrow occurs here\n+\n+error: cannot borrow `a` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:27:11\n+   |\n+LL |     fn f2(ref mut a @ ref b: U) {}\n+   |           ---------^^^-----\n+   |           |           |\n+   |           |           immutable borrow occurs here\n+   |           mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:29:11\n+   |\n+LL |     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n+   |           -----^^^^^^^^^^^----------------^^^^^^^^\n+   |           |               |\n+   |           |               mutable borrow occurs here\n+   |           immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:31\n+   |\n+LL |         ref mut z @ &mut Some(ref a) => {\n+   |         ----------------------^^^^^-\n+   |         |                     |\n+   |         |                     immutable borrow occurs here\n+   |         mutable borrow occurs here\n+...\n+LL |             **z = None;\n+   |             ---------- mutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:45:21\n+   |\n+LL |     let ref mut a @ ref b = u();\n+   |         ------------^^^^^\n+   |         |           |\n+   |         |           immutable borrow occurs here\n+   |         mutable borrow occurs here\n+...\n+LL |     *a = u();\n+   |     -------- mutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:50:17\n+   |\n+LL |     let ref a @ ref mut b = u();\n+   |         --------^^^^^^^^^\n+   |         |       |\n+   |         |       mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:75:20\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n+   |         -----------^^^^^^^^^-\n+   |         |          |\n+   |         |          mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |             drop(a);\n+   |                  - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:75:45\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n+   |                                 ------------^^^^^^^^^-\n+   |                                 |           |\n+   |                                 |           mutable borrow occurs here\n+   |                                 immutable borrow occurs here\n+...\n+LL |             drop(a);\n+   |                  - immutable borrow later used here\n+\n+error[E0594]: cannot assign to `*b`, as it is immutable for the pattern guard\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:86:61\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n+   |                                                             ^^^^^^ cannot assign\n+   |\n+   = note: variables bound in patterns are immutable until the end of the pattern guard\n+\n+error[E0594]: cannot assign to `*a`, as it is immutable for the pattern guard\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:93:61\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n+   |                                                             ^^^^^^^^^^^ cannot assign\n+   |\n+   = note: variables bound in patterns are immutable until the end of the pattern guard\n+\n+error[E0507]: cannot move out of `b` in pattern guard\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:100:66\n+   |\n+LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n+   |                                                                  ^ move occurs because `b` has type `&mut main::U`, which does not implement the `Copy` trait\n+   |\n+   = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n+\n+error[E0507]: cannot move out of `a` in pattern guard\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:107:66\n+   |\n+LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n+   |                                                                  ^ move occurs because `a` has type `&mut std::result::Result<main::U, main::U>`, which does not implement the `Copy` trait\n+   |\n+   = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:119:18\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         ---------^^^^^^^^^------------\n+   |         |        |\n+   |         |        mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:119:29\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         --------------------^^^^^^^^^-\n+   |         |                   |\n+   |         |                   mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:126:18\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         ---------^^^^^^^^^------------\n+   |         |        |\n+   |         |        mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - immutable borrow later used here\n+\n+error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-pat-ref-mut-and-ref.rs:126:29\n+   |\n+LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n+   |         --------------------^^^^^^^^^-\n+   |         |                   |\n+   |         |                   mutable borrow occurs here\n+   |         immutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - immutable borrow later used here\n+\n+error: aborting due to 43 previous errors\n+\n+Some errors have detailed explanations: E0502, E0507, E0594.\n+For more information about an error, try `rustc --explain E0502`."}, {"sha": "6b8b7545e687db53fca858ba389a269c188b7d29", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,112 @@\n+// Test that `ref mut x @ ref mut y` and varieties of that are not allowed.\n+\n+#![feature(bindings_after_at)]\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    struct U;\n+\n+    fn u() -> U { U }\n+\n+    fn f1(ref mut a @ ref mut b: U) {}\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    fn f2(ref mut a @ ref mut b: U) {}\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    fn f3(\n+        ref mut a @ [\n+        //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+            [ref b @ .., _],\n+            [_, ref mut mid @ ..],\n+            ..,\n+            [..],\n+        ] : [[U; 4]; 5]\n+    ) {}\n+\n+    let ref mut a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~| ERROR cannot borrow `_` as mutable more than once at a time\n+    drop(a);\n+    let ref mut a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    drop(b);\n+    let ref mut a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+\n+    let ref mut a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    //~| ERROR cannot borrow `_` as mutable more than once at a time\n+    *a = U;\n+    let ref mut a @ ref mut b = U;\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+    *b = U;\n+\n+    let ref mut a @ (\n+    //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+        ref mut b,\n+        [\n+            ref mut c,\n+            ref mut d,\n+            ref e,\n+        ]\n+    ) = (U, [U, U, U]);\n+\n+    let ref mut a @ (\n+        //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+            ref mut b,\n+            [\n+                ref mut c,\n+                ref mut d,\n+                ref e,\n+            ]\n+        ) = (u(), [u(), u(), u()]);\n+\n+    let a @ (ref mut b, ref mut c) = (U, U);\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR borrow of moved value\n+    let mut val = (U, [U, U]);\n+    let a @ (b, [c, d]) = &mut val; // Same as ^--\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR borrow of moved value\n+\n+    let a @ &mut ref mut b = &mut U;\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR borrow of moved value\n+    let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR borrow of moved value\n+\n+    match Ok(U) {\n+        ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+        }\n+    }\n+    match Ok(U) {\n+        ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            *b = U;\n+        }\n+    }\n+    match Ok(U) {\n+        ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            *a = Err(U);\n+\n+            // FIXME: The binding name `_` used above makes for problematic diagnostics.\n+            // Resolve that somehow...\n+        }\n+    }\n+    match Ok(U) {\n+        ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+            //~^ ERROR cannot borrow `a` as mutable more than once at a time\n+            //~| ERROR cannot borrow `a` as mutable more than once at a time\n+            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            drop(a);\n+        }\n+    }\n+}"}, {"sha": "1b5e6c7411703f8c5b60bcee2f3b66805396c50d", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,333 @@\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:25:9\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ---------^^^---------\n+   |         |           |\n+   |         |           another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:29:9\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ---------^^^---------\n+   |         |           |\n+   |         |           another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:32:9\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ---------^^^---------\n+   |         |           |\n+   |         |           another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:35:9\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ---------^^^---------\n+   |         |           |\n+   |         |           another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:39:9\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ---------^^^---------\n+   |         |           |\n+   |         |           another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:43:9\n+   |\n+LL |       let ref mut a @ (\n+   |           ^--------\n+   |           |\n+   |  _________first mutable borrow occurs here\n+   | |\n+LL | |\n+LL | |         ref mut b,\n+   | |         --------- another mutable borrow occurs here\n+LL | |         [\n+LL | |             ref mut c,\n+   | |             --------- another mutable borrow occurs here\n+LL | |             ref mut d,\n+   | |             --------- another mutable borrow occurs here\n+LL | |             ref e,\n+   | |             ----- also borrowed as immutable here\n+LL | |         ]\n+LL | |     ) = (U, [U, U, U]);\n+   | |_____^\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:53:9\n+   |\n+LL |       let ref mut a @ (\n+   |           ^--------\n+   |           |\n+   |  _________first mutable borrow occurs here\n+   | |\n+LL | |\n+LL | |             ref mut b,\n+   | |             --------- another mutable borrow occurs here\n+LL | |             [\n+LL | |                 ref mut c,\n+   | |                 --------- another mutable borrow occurs here\n+LL | |                 ref mut d,\n+   | |                 --------- another mutable borrow occurs here\n+LL | |                 ref e,\n+   | |                 ----- also borrowed as immutable here\n+LL | |             ]\n+LL | |         ) = (u(), [u(), u(), u()]);\n+   | |_________^\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:63:9\n+   |\n+LL |     let a @ (ref mut b, ref mut c) = (U, U);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:67:9\n+   |\n+LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n+   |         ^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:71:9\n+   |\n+LL |     let a @ &mut ref mut b = &mut U;\n+   |         ^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:74:9\n+   |\n+LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:79:9\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |         ---------^^^^^^---------^\n+   |         |              |\n+   |         |              another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:79:37\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |                                     ---------^^^^^^^---------^\n+   |                                     |               |\n+   |                                     |               another mutable borrow occurs here\n+   |                                     first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:85:9\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |         ---------^^^^^^---------^\n+   |         |              |\n+   |         |              another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:85:37\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |                                     ---------^^^^^^^---------^\n+   |                                     |               |\n+   |                                     |               another mutable borrow occurs here\n+   |                                     first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:92:9\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |         ---------^^^^^^---------^\n+   |         |              |\n+   |         |              another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:92:37\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |                                     ---------^^^^^^^---------^\n+   |                                     |               |\n+   |                                     |               another mutable borrow occurs here\n+   |                                     first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:104:9\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |         ---------^^^^^^---------^\n+   |         |              |\n+   |         |              another mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:104:37\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |                                     ---------^^^^^^^---------^\n+   |                                     |               |\n+   |                                     |               another mutable borrow occurs here\n+   |                                     first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:11:11\n+   |\n+LL |     fn f1(ref mut a @ ref mut b: U) {}\n+   |           ---------^^^---------\n+   |           |           |\n+   |           |           another mutable borrow occurs here\n+   |           first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:13:11\n+   |\n+LL |     fn f2(ref mut a @ ref mut b: U) {}\n+   |           ---------^^^---------\n+   |           |           |\n+   |           |           another mutable borrow occurs here\n+   |           first mutable borrow occurs here\n+\n+error: cannot borrow `a` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:16:9\n+   |\n+LL |           ref mut a @ [\n+   |           ^--------\n+   |           |\n+   |  _________first mutable borrow occurs here\n+   | |\n+LL | |\n+LL | |             [ref b @ .., _],\n+   | |              ---------- also borrowed as immutable here\n+LL | |             [_, ref mut mid @ ..],\n+   | |                 ---------------- another mutable borrow occurs here\n+LL | |             ..,\n+LL | |             [..],\n+LL | |         ] : [[U; 4]; 5]\n+   | |_________^\n+\n+error[E0499]: cannot borrow `_` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:25:21\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ------------^^^^^^^^^\n+   |         |           |\n+   |         |           second mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+...\n+LL |     drop(a);\n+   |          - first borrow later used here\n+\n+error[E0499]: cannot borrow `_` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:35:21\n+   |\n+LL |     let ref mut a @ ref mut b = U;\n+   |         ------------^^^^^^^^^\n+   |         |           |\n+   |         |           second mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+...\n+LL |     *a = U;\n+   |     ------ first borrow later used here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:63:25\n+   |\n+LL |     let a @ (ref mut b, ref mut c) = (U, U);\n+   |         ----------------^^^^^^^^^-   ------ move occurs because value has type `(main::U, main::U)`, which does not implement the `Copy` trait\n+   |         |               |\n+   |         |               value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:67:21\n+   |\n+LL |     let a @ (b, [c, d]) = &mut val; // Same as ^--\n+   |         ------------^--   -------- move occurs because value has type `&mut (main::U, [main::U; 2])`, which does not implement the `Copy` trait\n+   |         |           |\n+   |         |           value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:71:18\n+   |\n+LL |     let a @ &mut ref mut b = &mut U;\n+   |         ---------^^^^^^^^^   ------ move occurs because value has type `&mut main::U`, which does not implement the `Copy` trait\n+   |         |        |\n+   |         |        value borrowed here after move\n+   |         value moved here\n+\n+error[E0382]: borrow of moved value\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:74:30\n+   |\n+LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n+   |         ---------------------^^^^^^^^^-   ----------- move occurs because value has type `&mut (main::U, main::U)`, which does not implement the `Copy` trait\n+   |         |                    |\n+   |         |                    value borrowed here after move\n+   |         value moved here\n+\n+error[E0499]: cannot borrow `_` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:92:24\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |         ---------------^^^^^^^^^-\n+   |         |              |\n+   |         |              second mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+...\n+LL |             *a = Err(U);\n+   |             ----------- first borrow later used here\n+\n+error[E0499]: cannot borrow `_` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:92:53\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |                                     ----------------^^^^^^^^^-\n+   |                                     |               |\n+   |                                     |               second mutable borrow occurs here\n+   |                                     first mutable borrow occurs here\n+...\n+LL |             *a = Err(U);\n+   |             ----------- first borrow later used here\n+\n+error[E0499]: cannot borrow `_` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:104:24\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |         ---------------^^^^^^^^^-\n+   |         |              |\n+   |         |              second mutable borrow occurs here\n+   |         first mutable borrow occurs here\n+...\n+LL |             drop(a);\n+   |                  - first borrow later used here\n+\n+error[E0499]: cannot borrow `_` as mutable more than once at a time\n+  --> $DIR/borrowck-pat-ref-mut-twice.rs:104:53\n+   |\n+LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n+   |                                     ----------------^^^^^^^^^-\n+   |                                     |               |\n+   |                                     |               second mutable borrow occurs here\n+   |                                     first mutable borrow occurs here\n+...\n+LL |             drop(a);\n+   |                  - first borrow later used here\n+\n+error: aborting due to 32 previous errors\n+\n+Some errors have detailed explanations: E0007, E0382, E0499.\n+For more information about an error, try `rustc --explain E0007`."}, {"sha": "db5aabc7a145309da7fd2099fd70c6561faeef0d", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,20 @@\n+// Test that mixing `Copy` and non-`Copy` types in `@` patterns is forbidden.\n+\n+#![feature(bindings_after_at)]\n+\n+#[derive(Copy, Clone)]\n+struct C;\n+\n+struct NC<A, B>(A, B);\n+\n+fn main() {\n+    let a @ NC(b, c) = NC(C, C);\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+\n+    let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n+    //~^ ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+    //~| ERROR cannot bind by-move with sub-bindings\n+    //~| ERROR use of moved value\n+}"}, {"sha": "cfc35d6c32a7274d77b191028da22f47dfb50915", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,51 @@\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/copy-and-move-mixed.rs:11:9\n+   |\n+LL |     let a @ NC(b, c) = NC(C, C);\n+   |         ^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/copy-and-move-mixed.rs:15:9\n+   |\n+LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0007]: cannot bind by-move with sub-bindings\n+  --> $DIR/copy-and-move-mixed.rs:15:19\n+   |\n+LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n+   |                   ^^^^^^^^^^^^ binds an already bound by-move value by moving it\n+\n+error[E0382]: use of moved value\n+  --> $DIR/copy-and-move-mixed.rs:11:19\n+   |\n+LL |     let a @ NC(b, c) = NC(C, C);\n+   |         ----------^-   -------- move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait\n+   |         |         |\n+   |         |         value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/copy-and-move-mixed.rs:15:19\n+   |\n+LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n+   |         ----------^^^^^^^^^^^^-   --------------- move occurs because value has type `NC<C, NC<C, C>>`, which does not implement the `Copy` trait\n+   |         |         |\n+   |         |         value used here after move\n+   |         value moved here\n+\n+error[E0382]: use of moved value\n+  --> $DIR/copy-and-move-mixed.rs:15:29\n+   |\n+LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n+   |                   ----------^-\n+   |                   |         |\n+   |                   |         value used here after move\n+   |                   value moved here\n+   |\n+   = note: move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0007, E0382.\n+For more information about an error, try `rustc --explain E0007`."}, {"sha": "1127d114145cd2d8b7dc0a6382d8e30e3885adfc", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,37 @@\n+// Ensures the independence of each side in `binding @ subpat`\n+// determine their binding modes independently of each other.\n+//\n+// That is, `binding` does not influence `subpat`.\n+// This is important because we might want to allow `p1 @ p2`,\n+// where both `p1` and `p2` are syntactically unrestricted patterns.\n+// If `binding` is allowed to influence `subpat`,\n+// this would create problems for the generalization aforementioned.\n+\n+#![feature(bindings_after_at)]\n+\n+fn main() {\n+    struct NotCopy;\n+\n+    fn f1(a @ b: &NotCopy) { // OK\n+        let _: &NotCopy = a;\n+    }\n+    fn f2(ref a @ b: &NotCopy) {\n+        let _: &&NotCopy = a; // Ok\n+    }\n+\n+    let a @ b = &NotCopy; // OK\n+    let _: &NotCopy = a;\n+    let ref a @ b = &NotCopy; // OK\n+    let _: &&NotCopy = a;\n+\n+    let ref a @ b = NotCopy; //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    let ref mut a @ b = NotCopy; //~ ERROR cannot bind by-move and by-ref in the same pattern\n+    match Ok(NotCopy) {\n+        Ok(ref a @ b) | Err(ref a @ b) => {}\n+        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n+    }\n+    match NotCopy {\n+        ref a @ b => {}\n+        //~^ ERROR cannot bind by-move and by-ref in the same pattern\n+    }\n+}"}, {"sha": "b6709a8a40e2317b443aea2efd1353ce5cd5b1a5", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,41 @@\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:27:17\n+   |\n+LL |     let ref a @ b = NotCopy;\n+   |         --------^\n+   |         |       |\n+   |         |       by-move pattern here\n+   |         by-ref pattern here\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:28:21\n+   |\n+LL |     let ref mut a @ b = NotCopy;\n+   |         ------------^\n+   |         |           |\n+   |         |           by-move pattern here\n+   |         by-ref pattern here\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:30:20\n+   |\n+LL |         Ok(ref a @ b) | Err(ref a @ b) => {}\n+   |            --------^        --------^\n+   |            |       |        |       |\n+   |            |       |        |       by-move pattern here\n+   |            |       |        by-ref pattern here\n+   |            |       by-move pattern here\n+   |            by-ref pattern here\n+\n+error[E0009]: cannot bind by-move and by-ref in the same pattern\n+  --> $DIR/default-binding-modes-both-sides-independent.rs:34:17\n+   |\n+LL |         ref a @ b => {}\n+   |         --------^\n+   |         |       |\n+   |         |       by-move pattern here\n+   |         by-ref pattern here\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0009`."}, {"sha": "d655f15af1ebab8300b94d8197dc707df7d05dbf", "filename": "src/test/ui/pattern/bindings-after-at/feature-gate-bindings_after_at.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Ffeature-gate-bindings_after_at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Ffeature-gate-bindings_after_at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Ffeature-gate-bindings_after_at.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let x @ y = 0; //~ ERROR pattern bindings after an `@` are unstable\n+}"}, {"sha": "5408f6b5fb56d9a72cd9395597f97d096766f0ac", "filename": "src/test/ui/pattern/bindings-after-at/feature-gate-bindings_after_at.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Ffeature-gate-bindings_after_at.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Ffeature-gate-bindings_after_at.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Ffeature-gate-bindings_after_at.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: pattern bindings after an `@` are unstable\n+  --> $DIR/feature-gate-bindings_after_at.rs:2:13\n+   |\n+LL |     let x @ y = 0;\n+   |             ^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/65490\n+   = help: add `#![feature(bindings_after_at)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "6296652c112124e99980f1c5bb623ef95af68508", "filename": "src/test/ui/pattern/bindings-after-at/nested-patterns.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-patterns.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(bindings_after_at)]\n+\n+struct A { a: u8, b: u8 }\n+\n+pub fn main() {\n+    match (A { a: 10, b: 20 }) {\n+        ref x @ A { ref a, b: 20 } => {\n+            assert_eq!(x.a, 10);\n+            assert_eq!(*a, 10);\n+        }\n+        A { b: ref _b, .. } => panic!(),\n+    }\n+}"}, {"sha": "dbec2f135fbbe2967560750b2fabb5c10d131460", "filename": "src/test/ui/pattern/bindings-after-at/nested-type-ascription-syntactically-invalid.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,34 @@\n+// Here we check that type ascription is syntactically invalid when\n+// not in the top position of a ascribing a let binding or function parameter.\n+\n+#![feature(bindings_after_at)]\n+\n+// This has no effect.\n+// We include it to demonstrate that this is the case:\n+#![feature(type_ascription)]\n+\n+fn main() {}\n+\n+fn _ok() {\n+    let _a @ _b: u8 = 0; // OK.\n+    fn _f(_a @ _b: u8) {} // OK.\n+}\n+\n+#[cfg(FALSE)]\n+fn case_1() {\n+    let a: u8 @ b = 0;\n+    //~^ ERROR expected one of `!`\n+}\n+\n+#[cfg(FALSE)]\n+fn case_2() {\n+    let a @ (b: u8);\n+    //~^ ERROR expected one of `!`\n+    //~| ERROR expected one of `)`\n+}\n+\n+#[cfg(FALSE)]\n+fn case_3() {\n+    let a: T1 @ Outer(b: T2);\n+    //~^ ERROR expected one of `!`\n+}"}, {"sha": "1e957ed06892c01bdc4cfd54fcaffef856a50947", "filename": "src/test/ui/pattern/bindings-after-at/nested-type-ascription-syntactically-invalid.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,26 @@\n+error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `@`\n+  --> $DIR/nested-type-ascription-syntactically-invalid.rs:19:15\n+   |\n+LL |     let a: u8 @ b = 0;\n+   |               ^ expected one of 7 possible tokens\n+\n+error: expected one of `)`, `,`, `@`, or `|`, found `:`\n+  --> $DIR/nested-type-ascription-syntactically-invalid.rs:25:15\n+   |\n+LL |     let a @ (b: u8);\n+   |               ^ expected one of `)`, `,`, `@`, or `|`\n+\n+error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `)`\n+  --> $DIR/nested-type-ascription-syntactically-invalid.rs:25:19\n+   |\n+LL |     let a @ (b: u8);\n+   |                   ^ expected one of 7 possible tokens\n+\n+error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `@`\n+  --> $DIR/nested-type-ascription-syntactically-invalid.rs:32:15\n+   |\n+LL |     let a: T1 @ Outer(b: T2);\n+   |               ^ expected one of 7 possible tokens\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "89ea2d5181945dbe7d1545d886e515b75c3e65b3", "filename": "src/test/ui/pattern/bindings-after-at/pat-at-same-name-both.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,32 @@\n+// Test that `binding @ subpat` acts as a product context with respect to duplicate binding names.\n+// The code that is tested here lives in resolve (see `resolve_pattern_inner`).\n+\n+#![feature(bindings_after_at)]\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete and may cause the compiler to crash\n+\n+fn main() {\n+    fn f(a @ a @ a: ()) {}\n+    //~^ ERROR identifier `a` is bound more than once in this parameter list\n+    //~| ERROR identifier `a` is bound more than once in this parameter list\n+\n+    match Ok(0) {\n+        Ok(a @ b @ a)\n+        //~^ ERROR identifier `a` is bound more than once in the same pattern\n+        | Err(a @ b @ a)\n+        //~^ ERROR identifier `a` is bound more than once in the same pattern\n+        => {}\n+    }\n+\n+    let a @ a @ a = ();\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+    let ref a @ ref a = ();\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    let ref mut a @ ref mut a = ();\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let a @ (Ok(a) | Err(a)) = Ok(());\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+}"}, {"sha": "c568d2a3aa2b810139673bfb75ea4ce2655bd01d", "filename": "src/test/ui/pattern/bindings-after-at/pat-at-same-name-both.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fpat-at-same-name-both.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,72 @@\n+error[E0415]: identifier `a` is bound more than once in this parameter list\n+  --> $DIR/pat-at-same-name-both.rs:9:14\n+   |\n+LL |     fn f(a @ a @ a: ()) {}\n+   |              ^ used as parameter more than once\n+\n+error[E0415]: identifier `a` is bound more than once in this parameter list\n+  --> $DIR/pat-at-same-name-both.rs:9:18\n+   |\n+LL |     fn f(a @ a @ a: ()) {}\n+   |                  ^ used as parameter more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:14:20\n+   |\n+LL |         Ok(a @ b @ a)\n+   |                    ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:16:23\n+   |\n+LL |         | Err(a @ b @ a)\n+   |                       ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:21:13\n+   |\n+LL |     let a @ a @ a = ();\n+   |             ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:21:17\n+   |\n+LL |     let a @ a @ a = ();\n+   |                 ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:24:21\n+   |\n+LL |     let ref a @ ref a = ();\n+   |                     ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:26:29\n+   |\n+LL |     let ref mut a @ ref mut a = ();\n+   |                             ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:29:17\n+   |\n+LL |     let a @ (Ok(a) | Err(a)) = Ok(());\n+   |                 ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/pat-at-same-name-both.rs:29:26\n+   |\n+LL |     let a @ (Ok(a) | Err(a)) = Ok(());\n+   |                          ^ used in a pattern more than once\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/pat-at-same-name-both.rs:5:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to 10 previous errors\n+\n+Some errors have detailed explanations: E0415, E0416.\n+For more information about an error, try `rustc --explain E0415`."}, {"sha": "50ac0ef27834e3c30f088a7a431a50000cf2827b", "filename": "src/test/ui/pattern/bindings-after-at/wild-before-at-syntactically-rejected.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fwild-before-at-syntactically-rejected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fwild-before-at-syntactically-rejected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fwild-before-at-syntactically-rejected.rs?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,16 @@\n+// Here we check that `_ @ sub` is syntactically invalid\n+// and comes with a nice actionable suggestion.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn wild_before_at_is_bad_syntax() {\n+    let _ @ a = 0;\n+    //~^ ERROR pattern on wrong side of `@`\n+    let _ @ ref a = 0;\n+    //~^ ERROR pattern on wrong side of `@`\n+    let _ @ ref mut a = 0;\n+    //~^ ERROR pattern on wrong side of `@`\n+    let _ @ (a, .., b) = (0, 1, 2, 3);\n+    //~^ ERROR left-hand side of `@` must be a binding\n+}"}, {"sha": "2f45415844d8670830f8ff66806d637e6d4ff1cb", "filename": "src/test/ui/pattern/bindings-after-at/wild-before-at-syntactically-rejected.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fwild-before-at-syntactically-rejected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fwild-before-at-syntactically-rejected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fwild-before-at-syntactically-rejected.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -0,0 +1,43 @@\n+error: pattern on wrong side of `@`\n+  --> $DIR/wild-before-at-syntactically-rejected.rs:8:9\n+   |\n+LL |     let _ @ a = 0;\n+   |         -^^^-\n+   |         |   |\n+   |         |   binding on the right, should be on the left\n+   |         pattern on the left, should be on the right\n+   |         help: switch the order: `a @ _`\n+\n+error: pattern on wrong side of `@`\n+  --> $DIR/wild-before-at-syntactically-rejected.rs:10:9\n+   |\n+LL |     let _ @ ref a = 0;\n+   |         -^^^-----\n+   |         |   |\n+   |         |   binding on the right, should be on the left\n+   |         pattern on the left, should be on the right\n+   |         help: switch the order: `ref a @ _`\n+\n+error: pattern on wrong side of `@`\n+  --> $DIR/wild-before-at-syntactically-rejected.rs:12:9\n+   |\n+LL |     let _ @ ref mut a = 0;\n+   |         -^^^---------\n+   |         |   |\n+   |         |   binding on the right, should be on the left\n+   |         pattern on the left, should be on the right\n+   |         help: switch the order: `ref mut a @ _`\n+\n+error: left-hand side of `@` must be a binding\n+  --> $DIR/wild-before-at-syntactically-rejected.rs:14:9\n+   |\n+LL |     let _ @ (a, .., b) = (0, 1, 2, 3);\n+   |         -^^^----------\n+   |         |   |\n+   |         |   also a pattern\n+   |         interpreted as a pattern, not a binding\n+   |\n+   = note: bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "aff7264752de268b7204e288e083b9edc56e9252", "filename": "src/test/ui/pattern/pattern-bindings-after-at.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.rs?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,16 +0,0 @@\n-enum Option<T> {\n-    None,\n-    Some(T),\n-}\n-\n-fn main() {\n-    match &mut Some(1) {\n-        ref mut z @ &mut Some(ref a) => {\n-        //~^ ERROR pattern bindings are not allowed after an `@`\n-        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n-            **z = None;\n-            println!(\"{}\", *a);\n-        }\n-        _ => ()\n-    }\n-}"}, {"sha": "35ee7877f2f7836e52af2c853c35e9e26ca5f69f", "filename": "src/test/ui/pattern/pattern-bindings-after-at.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ae6cedb8d1e37469be1434642a3e403fce50a03/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-bindings-after-at.stderr?ref=9ae6cedb8d1e37469be1434642a3e403fce50a03", "patch": "@@ -1,22 +0,0 @@\n-error[E0303]: pattern bindings are not allowed after an `@`\n-  --> $DIR/pattern-bindings-after-at.rs:8:31\n-   |\n-LL |         ref mut z @ &mut Some(ref a) => {\n-   |                               ^^^^^ not allowed after `@`\n-\n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n-  --> $DIR/pattern-bindings-after-at.rs:8:31\n-   |\n-LL |         ref mut z @ &mut Some(ref a) => {\n-   |         ----------------------^^^^^-\n-   |         |                     |\n-   |         |                     immutable borrow occurs here\n-   |         mutable borrow occurs here\n-...\n-LL |             **z = None;\n-   |             ---------- mutable borrow later used here\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0303, E0502.\n-For more information about an error, try `rustc --explain E0303`."}, {"sha": "ebc6ff5d8c3fe5e63dbb9832447bad3cbb0e1a5b", "filename": "src/test/ui/rfc-2005-default-binding-mode/for.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a4cd03dee2b57216b5c95084a0b46de130946ad7/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Ffor.stderr?ref=a4cd03dee2b57216b5c95084a0b46de130946ad7", "patch": "@@ -4,7 +4,7 @@ error[E0009]: cannot bind by-move and by-ref in the same pattern\n LL |     for (n, mut m) in &tups {\n    |          -  ^^^^^ by-move pattern here\n    |          |\n-   |          both by-ref and by-move used\n+   |          by-ref pattern here\n \n error[E0507]: cannot move out of a shared reference\n   --> $DIR/for.rs:6:23"}]}