{"sha": "0b3ef97066814a5d7b852f32650bed67b691b7f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2VmOTcwNjY4MTRhNWQ3Yjg1MmYzMjY1MGJlZDY3YjY5MWI3ZjM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-31T18:25:17Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-06T10:56:52Z"}, "message": "Reuse MIR visitors for EraseRegions pass", "tree": {"sha": "ecf3eaa2f24644d1ac78cd550130703b04d7a8d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecf3eaa2f24644d1ac78cd550130703b04d7a8d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3ef97066814a5d7b852f32650bed67b691b7f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3ef97066814a5d7b852f32650bed67b691b7f3", "html_url": "https://github.com/rust-lang/rust/commit/0b3ef97066814a5d7b852f32650bed67b691b7f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3ef97066814a5d7b852f32650bed67b691b7f3/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "html_url": "https://github.com/rust-lang/rust/commit/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f"}], "stats": {"total": 226, "additions": 68, "deletions": 158}, "files": [{"sha": "7d4b0288a038f501d0927620cf9e564d756cff30", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3ef97066814a5d7b852f32650bed67b691b7f3/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3ef97066814a5d7b852f32650bed67b691b7f3/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=0b3ef97066814a5d7b852f32650bed67b691b7f3", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_front;\n use build;\n use graphviz;\n use pretty;\n-use transform::*;\n+use transform::{simplify_cfg, MirPass};\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;"}, {"sha": "d851daffe89dd11f41dbc17ddac78c4d498d1ea9", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 67, "deletions": 157, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/0b3ef97066814a5d7b852f32650bed67b691b7f3/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3ef97066814a5d7b852f32650bed67b691b7f3/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=0b3ef97066814a5d7b852f32650bed67b691b7f3", "patch": "@@ -14,8 +14,9 @@\n \n use rustc::middle::ty;\n use rustc::mir::repr::*;\n-use transform::MirPass;\n+use rustc::mir::visit::MutVisitor;\n use mir_map::MirMap;\n+use transform::MirPass;\n \n pub fn erase_regions<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &mut MirMap<'tcx>) {\n     let mut eraser = EraseRegions::new(tcx);\n@@ -29,196 +30,105 @@ pub struct EraseRegions<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'a, 'tcx> MirPass<'tcx> for EraseRegions<'a, 'tcx> {\n-\n-    fn run_on_mir(&mut self, mir: &mut Mir<'tcx>) {\n-\n-        for basic_block in &mut mir.basic_blocks {\n-            self.erase_regions_basic_block(basic_block);\n-        }\n-\n-        self.erase_regions_return_ty(&mut mir.return_ty);\n-\n-        self.erase_regions_tys(mir.var_decls.iter_mut().map(|d| &mut d.ty));\n-        self.erase_regions_tys(mir.arg_decls.iter_mut().map(|d| &mut d.ty));\n-        self.erase_regions_tys(mir.temp_decls.iter_mut().map(|d| &mut d.ty));\n-    }\n-}\n-\n impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n-\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> EraseRegions<'a, 'tcx> {\n         EraseRegions {\n             tcx: tcx\n         }\n     }\n \n-    fn erase_regions_basic_block(&mut self,\n-                                 basic_block: &mut BasicBlockData<'tcx>) {\n-        for statement in &mut basic_block.statements {\n-            self.erase_regions_statement(statement);\n+    fn erase_regions_return_ty(&mut self, fn_output: &mut ty::FnOutput<'tcx>) {\n+        match *fn_output {\n+            ty::FnConverging(ref mut ty) => {\n+                *ty = self.tcx.erase_regions(ty);\n+            },\n+            ty::FnDiverging => {}\n         }\n-\n-        self.erase_regions_terminator(basic_block.terminator_mut());\n     }\n \n-    fn erase_regions_statement(&mut self,\n-                               statement: &mut Statement<'tcx>) {\n-        match statement.kind {\n-            StatementKind::Assign(ref mut lvalue, ref mut rvalue) => {\n-                self.erase_regions_lvalue(lvalue);\n-                self.erase_regions_rvalue(rvalue);\n-            }\n+    fn erase_regions_tys<'b, T>(&mut self, tys: T)\n+        where T: Iterator<Item = &'b mut ty::Ty<'tcx>>,\n+              'tcx: 'b\n+    {\n+        for ty in tys {\n+            *ty = self.tcx.erase_regions(ty);\n         }\n     }\n+}\n+\n+impl<'a, 'tcx> MirPass<'tcx> for EraseRegions<'a, 'tcx> {\n+    fn run_on_mir(&mut self, mir: &mut Mir<'tcx>) {\n+        self.visit_mir(mir);\n+    }\n+}\n \n-    fn erase_regions_terminator(&mut self,\n-                                terminator: &mut Terminator<'tcx>) {\n+impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegions<'a, 'tcx> {\n+    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n+        self.erase_regions_return_ty(&mut mir.return_ty);\n+        self.erase_regions_tys(mir.var_decls.iter_mut().map(|d| &mut d.ty));\n+        self.erase_regions_tys(mir.arg_decls.iter_mut().map(|d| &mut d.ty));\n+        self.erase_regions_tys(mir.temp_decls.iter_mut().map(|d| &mut d.ty));\n+        self.super_mir(mir);\n+    }\n+\n+    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &mut Terminator<'tcx>) {\n         match *terminator {\n             Terminator::Goto { .. } |\n             Terminator::Resume |\n-            Terminator::Return => {\n+            Terminator::Return |\n+            Terminator::If { .. } |\n+            Terminator::Switch { .. } |\n+            Terminator::Drop { .. } |\n+            Terminator::Call { .. } => {\n                 /* nothing to do */\n-            }\n-            Terminator::If { ref mut cond, .. } => {\n-                self.erase_regions_operand(cond);\n-            }\n-            Terminator::Switch { ref mut discr, .. } => {\n-                self.erase_regions_lvalue(discr);\n-            }\n-            Terminator::SwitchInt { ref mut discr, ref mut switch_ty, .. } => {\n-                self.erase_regions_lvalue(discr);\n+            },\n+            Terminator::SwitchInt { ref mut switch_ty, .. } => {\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n-            Terminator::Drop { ref mut value, .. } => {\n-                self.erase_regions_lvalue(value);\n-            }\n-            Terminator::Call { ref mut func, ref mut args, ref mut destination, .. } => {\n-                if let Some((ref mut destination, _)) = *destination {\n-                    self.erase_regions_lvalue(destination);\n-                }\n-                self.erase_regions_operand(func);\n-                for arg in &mut *args {\n-                    self.erase_regions_operand(arg);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn erase_regions_operand(&mut self, operand: &mut Operand<'tcx>) {\n-        match *operand {\n-            Operand::Consume(ref mut lvalue) => {\n-                self.erase_regions_lvalue(lvalue);\n-            }\n-            Operand::Constant(ref mut constant) => {\n-                self.erase_regions_constant(constant);\n-            }\n-        }\n-    }\n-\n-    fn erase_regions_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>) {\n-        match *lvalue {\n-            Lvalue::Var(_)        |\n-            Lvalue::Temp(_)       |\n-            Lvalue::Arg(_)        |\n-            Lvalue::Static(_)     |\n-            Lvalue::ReturnPointer => {}\n-            Lvalue::Projection(ref mut lvalue_projection) => {\n-                self.erase_regions_lvalue(&mut lvalue_projection.base);\n-                match lvalue_projection.elem {\n-                    ProjectionElem::Deref              |\n-                    ProjectionElem::Field(_)           |\n-                    ProjectionElem::Downcast(..)       |\n-                    ProjectionElem::ConstantIndex {..} => { /* nothing to do */ }\n-                    ProjectionElem::Index(ref mut index) => {\n-                        self.erase_regions_operand(index);\n-                    }\n-                }\n-            }\n         }\n+        self.super_terminator(bb, terminator);\n     }\n \n-    fn erase_regions_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n         match *rvalue {\n-            Rvalue::Use(ref mut operand) => {\n-                self.erase_regions_operand(operand)\n-            }\n-            Rvalue::Repeat(ref mut operand, ref mut value) => {\n-                self.erase_regions_operand(operand);\n-                value.ty = self.tcx.erase_regions(&value.ty);\n-            }\n-            Rvalue::Ref(ref mut region, _, ref mut lvalue) => {\n-                *region = ty::ReStatic;\n-                self.erase_regions_lvalue(lvalue);\n-            }\n-            Rvalue::Len(ref mut lvalue) => self.erase_regions_lvalue(lvalue),\n-            Rvalue::Cast(_, ref mut operand, ref mut ty) => {\n-                self.erase_regions_operand(operand);\n-                *ty = self.tcx.erase_regions(ty);\n-            }\n-            Rvalue::BinaryOp(_, ref mut operand1, ref mut operand2) => {\n-                self.erase_regions_operand(operand1);\n-                self.erase_regions_operand(operand2);\n-            }\n-            Rvalue::UnaryOp(_, ref mut operand) => {\n-                self.erase_regions_operand(operand);\n-            }\n+            Rvalue::Use(_) |\n+            Rvalue::Len(_) |\n+            Rvalue::BinaryOp(_, _, _) |\n+            Rvalue::UnaryOp(_, _) |\n+            Rvalue::Slice { input: _, from_start: _, from_end: _ } |\n+            Rvalue::InlineAsm(_) => {},\n+\n+            Rvalue::Repeat(_, ref mut value) => value.ty = self.tcx.erase_regions(&value.ty),\n+            Rvalue::Ref(ref mut region, _, _) => *region = ty::ReStatic,\n+            Rvalue::Cast(_, _, ref mut ty) => *ty = self.tcx.erase_regions(ty),\n             Rvalue::Box(ref mut ty) => *ty = self.tcx.erase_regions(ty),\n-            Rvalue::Aggregate(ref mut aggregate_kind, ref mut operands) => {\n-                match *aggregate_kind {\n-                    AggregateKind::Vec   |\n-                    AggregateKind::Tuple => {},\n-                    AggregateKind::Adt(_, _, ref mut substs) => {\n-                        let erased = self.tcx.erase_regions(*substs);\n-                        *substs = self.tcx.mk_substs(erased);\n-                    }\n-                    AggregateKind::Closure(def_id, ref mut closure_substs) => {\n-                        let cloned = Box::new(closure_substs.clone());\n-                        let ty = self.tcx.mk_closure_from_closure_substs(def_id,\n-                                                                         cloned);\n-                        let erased = self.tcx.erase_regions(&ty);\n-                        *closure_substs = match erased.sty {\n-                            ty::TyClosure(_, ref closure_substs) => &*closure_substs,\n-                            _ => unreachable!()\n-                        };\n-                    }\n-                }\n-                for operand in &mut *operands {\n-                    self.erase_regions_operand(operand);\n-                }\n-            }\n-            Rvalue::Slice { ref mut input, .. } => {\n-                self.erase_regions_lvalue(input);\n+\n+\n+            Rvalue::Aggregate(AggregateKind::Vec, _) |\n+            Rvalue::Aggregate(AggregateKind::Tuple, _) => {},\n+            Rvalue::Aggregate(AggregateKind::Adt(_, _, ref mut substs), _) =>\n+                *substs = self.tcx.mk_substs(self.tcx.erase_regions(*substs)),\n+            Rvalue::Aggregate(AggregateKind::Closure(def_id, ref mut closure_substs), _) => {\n+                let cloned = Box::new(closure_substs.clone());\n+                let ty = self.tcx.mk_closure_from_closure_substs(def_id, cloned);\n+                let erased = self.tcx.erase_regions(&ty);\n+                *closure_substs = match erased.sty {\n+                    ty::TyClosure(_, ref closure_substs) => &*closure_substs,\n+                    _ => unreachable!()\n+                };\n             }\n-            Rvalue::InlineAsm(_) => {},\n         }\n+        self.super_rvalue(rvalue);\n     }\n \n-    fn erase_regions_constant(&mut self, constant: &mut Constant<'tcx>) {\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>) {\n         constant.ty = self.tcx.erase_regions(&constant.ty);\n         match constant.literal {\n             Literal::Item { ref mut substs, .. } => {\n                 *substs = self.tcx.mk_substs(self.tcx.erase_regions(substs));\n             }\n             Literal::Value { .. } => { /* nothing to do */ }\n         }\n-    }\n-\n-    fn erase_regions_return_ty(&mut self, fn_output: &mut ty::FnOutput<'tcx>) {\n-        match *fn_output {\n-            ty::FnConverging(ref mut ty) => {\n-                *ty = self.tcx.erase_regions(ty);\n-            },\n-            ty::FnDiverging => {}\n-        }\n-    }\n-\n-    fn erase_regions_tys<'b, T>(&mut self, tys: T)\n-        where T: Iterator<Item = &'b mut ty::Ty<'tcx>>,\n-              'tcx: 'b\n-    {\n-        for ty in tys {\n-            *ty = self.tcx.erase_regions(ty);\n-        }\n+        self.super_constant(constant);\n     }\n }"}]}