{"sha": "fad267c3b32895999f464c640d603f923fa0eeba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDI2N2MzYjMyODk1OTk5ZjQ2NGM2NDBkNjAzZjkyM2ZhMGVlYmE=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-11-20T09:33:40Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-11-27T14:29:14Z"}, "message": "Introduce snippet_with_applicability and hir_with_applicability functions", "tree": {"sha": "604ea12971577e290ad9b5db1dcb2d237b72633d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/604ea12971577e290ad9b5db1dcb2d237b72633d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad267c3b32895999f464c640d603f923fa0eeba", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE46kBTF5vnyuSPg0W6OiXpYcOQcIFAlv9VMMACgkQ6OiXpYcO\nQcLXSRAAiGp4hjv1nQO2SJzyMefelIAJGdzNZdWoLF5g/neKguY4CDpQwC1skeZu\nXU1CNlF1pg7O8IOIzQZHvNhuywjBLBw10ccL9t3Zj3a509ecMNB7oVTdnCK3YSGG\n83BYgIf8Nowj5Va8m0kiRUi84xzfOFW3P6W1cZp5GxrgMdphQUAlFhFhOYYt7OpZ\nxxXTzbOx98hy9lPuopGtKzdtPuXqTDcG5SGa7zRGklSYRyEtRzG/CI/9GFD5j8PK\nfYCNooZfxbPcaJfYk9HM8Ij6UF+TyZF+eWMMhhRJdAP34vbVGyHce6fjzFrljart\nqE4wShNLGFTETaJUOVkwvV3xMSg7Ng4IzskASd6UNr5EIu5Cz2PfEFreIpqufqIV\nDvSX/upZEuJRSbt7l705w3KJVzzmuix+MVUnI7UWXOMAFVqaTJJ2hN5czgpqSo7p\noa41zglaY6lPYPysDijuhIl5zsAmzYul2dSH62buwVg4vdNNiT/xzKppWxJvR6Gv\n+4YD1ar2Xs93SL+/8Zyko77eiuHgwpXPNbpXx8xMQfvTi5RC5d8qSGrnRdHpkG3U\nXF+tvLqvsp7nyuuqATGDtc691tPqsWIfOSOhtgSZoKkFF5tknoCEUpkawNPoCu+u\nLgCH4mKUe5riYtvLGjIV2nEKVGFB5Zw4c9U8e2M4uaRcsaT/XCY=\n=g8/0\n-----END PGP SIGNATURE-----", "payload": "tree 604ea12971577e290ad9b5db1dcb2d237b72633d\nparent dec389a5eea427c4faf20327baa7f34096a4e41f\nauthor flip1995 <hello@philkrones.com> 1542706420 +0100\ncommitter flip1995 <hello@philkrones.com> 1543328954 +0100\n\nIntroduce snippet_with_applicability and hir_with_applicability functions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad267c3b32895999f464c640d603f923fa0eeba", "html_url": "https://github.com/rust-lang/rust/commit/fad267c3b32895999f464c640d603f923fa0eeba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad267c3b32895999f464c640d603f923fa0eeba/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec389a5eea427c4faf20327baa7f34096a4e41f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec389a5eea427c4faf20327baa7f34096a4e41f", "html_url": "https://github.com/rust-lang/rust/commit/dec389a5eea427c4faf20327baa7f34096a4e41f"}], "stats": {"total": 267, "additions": 151, "deletions": 116}, "files": [{"sha": "43af5e393c8a3063943142b95519b58f224e39b8", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 142, "deletions": 116, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/fad267c3b32895999f464c640d603f923fa0eeba/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad267c3b32895999f464c640d603f923fa0eeba/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=fad267c3b32895999f464c640d603f923fa0eeba", "patch": "@@ -7,44 +7,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::reexport::*;\n-use matches::matches;\n-use if_chain::if_chain;\n use crate::rustc::hir;\n-use crate::rustc::hir::*;\n-use crate::rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use crate::rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use crate::rustc::hir::Node;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, Level, Lint, LintContext};\n use crate::rustc::session::Session;\n use crate::rustc::traits;\n-use crate::rustc::ty::{self, Binder, Ty, TyCtxt, layout::{self, IntegerExt}, subst::Kind};\n+use crate::rustc::ty::{\n+    self,\n+    layout::{self, IntegerExt},\n+    subst::Kind,\n+    Binder, Ty, TyCtxt,\n+};\n use crate::rustc_errors::{Applicability, CodeSuggestion, Substitution, SubstitutionPart};\n-use std::borrow::Cow;\n-use std::env;\n-use std::mem;\n-use std::str::FromStr;\n-use std::rc::Rc;\n use crate::syntax::ast::{self, LitKind};\n use crate::syntax::attr;\n-use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::errors::DiagnosticBuilder;\n+use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::symbol::{keywords, Symbol};\n+use if_chain::if_chain;\n+use matches::matches;\n+use std::borrow::Cow;\n+use std::env;\n+use std::mem;\n+use std::rc::Rc;\n+use std::str::FromStr;\n \n pub mod camel_case;\n \n+pub mod author;\n pub mod comparisons;\n pub mod conf;\n pub mod constants;\n mod hir_utils;\n-pub mod paths;\n-pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n-pub mod author;\n+pub mod paths;\n pub mod ptr;\n+pub mod sugg;\n pub mod usage;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n@@ -101,11 +105,7 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n \n     tcx.push_item_path(&mut apb, def_id, false);\n \n-    apb.names.len() == path.len()\n-        && apb.names\n-            .into_iter()\n-            .zip(path.iter())\n-            .all(|(a, &b)| *a == *b)\n+    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -137,12 +137,9 @@ pub fn match_var(expr: &Expr, var: Name) -> bool {\n     false\n }\n \n-\n pub fn last_path_segment(path: &QPath) -> &PathSegment {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments\n-            .last()\n-            .expect(\"A path must have at least one segment\"),\n+        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n         QPath::TypeRelative(_, ref seg) => seg,\n     }\n }\n@@ -166,7 +163,8 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             TyKind::Path(ref inner_path) => {\n-                !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n+                !segments.is_empty()\n+                    && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n                     && segment.ident.name == segments[segments.len() - 1]\n             },\n             _ => false,\n@@ -199,9 +197,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n /// Get the definition associated to a path.\n pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n-    let krate = crates\n-        .iter()\n-        .find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n+    let krate = crates.iter().find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n     if let Some(krate) = krate {\n         let krate = DefId {\n             krate: *krate,\n@@ -254,10 +250,17 @@ pub fn implements_trait<'a, 'tcx>(\n     ty_params: &[Kind<'tcx>],\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let obligation =\n-        cx.tcx\n-            .predicate_for_trait_def(cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-    cx.tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold(&obligation))\n+    let obligation = cx.tcx.predicate_for_trait_def(\n+        cx.param_env,\n+        traits::ObligationCause::dummy(),\n+        trait_id,\n+        0,\n+        ty,\n+        ty_params,\n+    );\n+    cx.tcx\n+        .infer_ctxt()\n+        .enter(|infcx| infcx.predicate_must_hold(&obligation))\n }\n \n /// Check whether this type implements Drop.\n@@ -326,14 +329,14 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     Some(matched)\n }\n \n-\n /// Get the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir.get_parent(expr.id);\n     match cx.tcx.hir.find(parent_id) {\n         Some(Node::Item(&Item { ref name, .. })) => Some(*name),\n-        Some(Node::TraitItem(&TraitItem { ident, .. })) |\n-        Some(Node::ImplItem(&ImplItem { ident, .. })) => Some(ident.name),\n+        Some(Node::TraitItem(&TraitItem { ident, .. })) | Some(Node::ImplItem(&ImplItem { ident, .. })) => {\n+            Some(ident.name)\n+        },\n         _ => None,\n     }\n }\n@@ -366,15 +369,11 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n \n /// check if an `Expr` contains a certain name\n pub fn contains_name(name: Name, expr: &Expr) -> bool {\n-    let mut cn = ContainsName {\n-        name,\n-        result: false,\n-    };\n+    let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n }\n \n-\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example\n@@ -385,6 +384,31 @@ pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str)\n     snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n }\n \n+pub fn snippet_with_applicability<'a, 'b, T: LintContext<'b>>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    snippet_opt(cx, span).map_or_else(\n+        || {\n+            // If the applicability is already `HasPlaceholders` or `MaybeIncorrect` don't change it.\n+            // Also `Unspecified` shouldn't be changed\n+            // Only if the applicability level is originally `MachineApplicable` and the default value\n+            // has to be used change it to `HasPlaceholders`\n+            if *applicability == Applicability::MachineApplicable {\n+                if in_macro(span) {\n+                    *applicability = Applicability::MaybeIncorrect;\n+                } else {\n+                    *applicability = Applicability::HasPlaceholders;\n+                }\n+            }\n+            Cow::Borrowed(default)\n+        },\n+        From::from,\n+    )\n+}\n+\n /// Same as `snippet`, but should only be used when it's clear that the input span is\n /// not a macro argument.\n pub fn snippet_with_macro_callsite<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n@@ -431,8 +455,7 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     let string = option.unwrap_or_default();\n     if in_macro(expr.span) {\n         Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n-    }\n-    else if let ExprKind::Block(_, _) = expr.node {\n+    } else if let ExprKind::Block(_, _) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n@@ -450,19 +473,15 @@ pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n }\n \n fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n-    let x = s.lines()\n+    let x = s\n+        .lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n             if l.is_empty() {\n                 None\n             } else {\n                 // ignore empty lines\n-                Some(\n-                    l.char_indices()\n-                        .find(|&(_, x)| x != ch)\n-                        .unwrap_or((l.len(), ch))\n-                        .0,\n-                )\n+                Some(l.char_indices().find(|&(_, x)| x != ch).unwrap_or((l.len(), ch)).0)\n             }\n         })\n         .min()\n@@ -505,15 +524,17 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c\n \n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.hir;\n-    let enclosing_node = map.get_enclosing_scope(node)\n+    let enclosing_node = map\n+        .get_enclosing_scope(node)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::Block(block) => Some(block),\n             Node::Item(&Item {\n                 node: ItemKind::Fn(_, _, _, eid),\n                 ..\n-            }) | Node::ImplItem(&ImplItem {\n+            })\n+            | Node::ImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n                 ..\n             }) => match cx.tcx.hir.body(eid).value.node {\n@@ -617,7 +638,8 @@ pub fn span_lint_node_and_then(\n /// Add a span lint with a suggestion on how to fix it.\n ///\n /// These suggestions can be parsed by rustfix to allow it to automatically fix your code.\n-/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x > 2)\"`.\n+/// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x >\n+/// 2)\"`.\n ///\n /// ```ignore\n /// error: This `.fold` can be more succinctly expressed as `.any`\n@@ -652,18 +674,12 @@ where\n     I: IntoIterator<Item = (Span, String)>,\n {\n     let sugg = CodeSuggestion {\n-        substitutions: vec![\n-            Substitution {\n-                parts: sugg.into_iter()\n-                    .map(|(span, snippet)| {\n-                        SubstitutionPart {\n-                            snippet,\n-                            span,\n-                        }\n-                    })\n-                    .collect(),\n-            }\n-        ],\n+        substitutions: vec![Substitution {\n+            parts: sugg\n+                .into_iter()\n+                .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                .collect(),\n+        }],\n         msg: help_msg,\n         show_code_when_inline: true,\n         applicability: Applicability::Unspecified,\n@@ -729,9 +745,7 @@ impl LimitStack {\n         Self { stack: vec![limit] }\n     }\n     pub fn limit(&self) -> u64 {\n-        *self.stack\n-            .last()\n-            .expect(\"there should always be a value in the stack\")\n+        *self.stack.last().expect(\"there should always be a value in the stack\")\n     }\n     pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n         let stack = &mut self.stack;\n@@ -744,10 +758,11 @@ impl LimitStack {\n }\n \n pub fn get_attr<'a>(attrs: &'a [ast::Attribute], name: &'static str) -> impl Iterator<Item = &'a ast::Attribute> {\n-    attrs.iter().filter(move |attr|\n-        attr.path.segments.len() == 2 &&\n-        attr.path.segments[0].ident.to_string() == \"clippy\" &&\n-        attr.path.segments[1].ident.to_string() == name)\n+    attrs.iter().filter(move |attr| {\n+        attr.path.segments.len() == 2\n+            && attr.path.segments[0].ident.to_string() == \"clippy\"\n+            && attr.path.segments[1].ident.to_string() == name\n+    })\n }\n \n fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n@@ -769,7 +784,8 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = span.ctxt()\n+        let span_name_span = span\n+            .ctxt()\n             .outer()\n             .expn_info()\n             .map(|ei| (ei.format.name(), ei.call_site));\n@@ -792,7 +808,8 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n /// `bar!` by\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    let span_name_span = span.ctxt()\n+    let span_name_span = span\n+        .ctxt()\n         .outer()\n         .expn_info()\n         .map(|ei| (ei.format.name(), ei.call_site));\n@@ -855,23 +872,23 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => if is_enum_variant(cx, qpath, pat.hir_id) {\n-            true\n-        } else {\n-            are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            if is_enum_variant(cx, qpath, pat.hir_id) {\n+                true\n+            } else {\n+                are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n+            }\n         },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => if is_enum_variant(cx, qpath, pat.hir_id) {\n-            true\n-        } else {\n-            are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            if is_enum_variant(cx, qpath, pat.hir_id) {\n+                true\n+            } else {\n+                are_refutable(cx, pats.iter().map(|pat| &**pat))\n+            }\n+        },\n+        PatKind::Slice(ref head, ref middle, ref tail) => {\n+            are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n         },\n-        PatKind::Slice(ref head, ref middle, ref tail) => are_refutable(\n-            cx,\n-            head.iter()\n-                .chain(middle)\n-                .chain(tail.iter())\n-                .map(|pat| &**pat),\n-        ),\n     }\n }\n \n@@ -903,32 +920,37 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n \n pub fn opt_def_id(def: Def) -> Option<DefId> {\n     match def {\n-        Def::Fn(id) |\n-        Def::Mod(id) |\n-        Def::Static(id, _) |\n-        Def::Variant(id) |\n-        Def::VariantCtor(id, ..) |\n-        Def::Enum(id) |\n-        Def::TyAlias(id) |\n-        Def::AssociatedTy(id) |\n-        Def::TyParam(id) |\n-        Def::ForeignTy(id) |\n-        Def::Struct(id) |\n-        Def::StructCtor(id, ..) |\n-        Def::Union(id) |\n-        Def::Trait(id) |\n-        Def::TraitAlias(id) |\n-        Def::Method(id) |\n-        Def::Const(id) |\n-        Def::AssociatedConst(id) |\n-        Def::Macro(id, ..) |\n-        Def::Existential(id) |\n-        Def::AssociatedExistential(id) |\n-        Def::SelfCtor(id)\n-        => Some(id),\n-\n-        Def::Upvar(..) | Def::Local(_) | Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) |\n-        Def::ToolMod | Def::NonMacroAttr{..} | Def::Err => None,\n+        Def::Fn(id)\n+        | Def::Mod(id)\n+        | Def::Static(id, _)\n+        | Def::Variant(id)\n+        | Def::VariantCtor(id, ..)\n+        | Def::Enum(id)\n+        | Def::TyAlias(id)\n+        | Def::AssociatedTy(id)\n+        | Def::TyParam(id)\n+        | Def::ForeignTy(id)\n+        | Def::Struct(id)\n+        | Def::StructCtor(id, ..)\n+        | Def::Union(id)\n+        | Def::Trait(id)\n+        | Def::TraitAlias(id)\n+        | Def::Method(id)\n+        | Def::Const(id)\n+        | Def::AssociatedConst(id)\n+        | Def::Macro(id, ..)\n+        | Def::Existential(id)\n+        | Def::AssociatedExistential(id)\n+        | Def::SelfCtor(id) => Some(id),\n+\n+        Def::Upvar(..)\n+        | Def::Local(_)\n+        | Def::Label(..)\n+        | Def::PrimTy(..)\n+        | Def::SelfTy(..)\n+        | Def::ToolMod\n+        | Def::NonMacroAttr { .. }\n+        | Def::Err => None,\n     }\n }\n \n@@ -1019,7 +1041,9 @@ pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n }\n \n pub fn int_bits(tcx: TyCtxt<'_, '_, '_>, ity: ast::IntTy) -> u64 {\n-    layout::Integer::from_attr(&tcx, attr::IntType::SignedInt(ity)).size().bits()\n+    layout::Integer::from_attr(&tcx, attr::IntType::SignedInt(ity))\n+        .size()\n+        .bits()\n }\n \n #[allow(clippy::cast_possible_wrap)]\n@@ -1038,7 +1062,9 @@ pub fn unsext(tcx: TyCtxt<'_, '_, '_>, u: i128, ity: ast::IntTy) -> u128 {\n \n /// clip unused bytes\n pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n-    let bits = layout::Integer::from_attr(&tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n+    let bits = layout::Integer::from_attr(&tcx, attr::IntType::UnsignedInt(ity))\n+        .size()\n+        .bits();\n     let amt = 128 - bits;\n     (u << amt) >> amt\n }"}, {"sha": "5bb35474403abbcec61156781ec0087d8565a37d", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fad267c3b32895999f464c640d603f923fa0eeba/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad267c3b32895999f464c640d603f923fa0eeba/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=fad267c3b32895999f464c640d603f923fa0eeba", "patch": "@@ -96,6 +96,15 @@ impl<'a> Sugg<'a> {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n+    pub fn hir_with_applicability(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str, applicability: &mut Applicability) -> Self {\n+        Self::hir_opt(cx, expr).unwrap_or_else(|| {\n+            if *applicability == Applicability::MachineApplicable {\n+                *applicability = Applicability::HasPlaceholders;\n+            }\n+            Sugg::NonParen(Cow::Borrowed(default))\n+        })\n+    }\n+\n     /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use crate::syntax::ast::RangeLimits;"}]}