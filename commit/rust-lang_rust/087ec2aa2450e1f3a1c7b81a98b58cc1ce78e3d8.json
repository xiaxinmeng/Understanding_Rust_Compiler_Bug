{"sha": "087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4N2VjMmFhMjQ1MGUxZjNhMWM3YjgxYTk4YjU4Y2MxY2U3OGUzZDg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-22T23:11:39Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-22T23:11:39Z"}, "message": "Implement cross-crate support for autoderef.\nCloses #13044.", "tree": {"sha": "328770f6431a56ad06c7543aae36cef6baf8b070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/328770f6431a56ad06c7543aae36cef6baf8b070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "html_url": "https://github.com/rust-lang/rust/commit/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75d7d5210a9f86110ee30ab40ff6515c7e422b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/75d7d5210a9f86110ee30ab40ff6515c7e422b91", "html_url": "https://github.com/rust-lang/rust/commit/75d7d5210a9f86110ee30ab40ff6515c7e422b91"}], "stats": {"total": 167, "additions": 147, "deletions": 20}, "files": [{"sha": "94947b95cd38f9833e280b4e5d07a1d91e2dfc94", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 92, "deletions": 20, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "patch": "@@ -581,41 +581,48 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of MethodCallee\n \n trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> MethodCallee;\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee);\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n+                        autoderef: u32,\n                         method: &MethodCallee) {\n-    ebml_w.emit_struct(\"MethodCallee\", 3, |ebml_w| {\n-        ebml_w.emit_struct_field(\"origin\", 0u, |ebml_w| {\n+    ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n+        ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n+            autoderef.encode(ebml_w);\n+        });\n+        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             method.origin.encode(ebml_w);\n         });\n-        ebml_w.emit_struct_field(\"ty\", 1u, |ebml_w| {\n+        ebml_w.emit_struct_field(\"ty\", 2u, |ebml_w| {\n             ebml_w.emit_ty(ecx, method.ty);\n         });\n-        ebml_w.emit_struct_field(\"substs\", 2u, |ebml_w| {\n+        ebml_w.emit_struct_field(\"substs\", 3u, |ebml_w| {\n             ebml_w.emit_substs(ecx, &method.substs);\n         });\n     })\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> MethodCallee {\n-        self.read_struct(\"MethodCallee\", 3, |this| {\n-            MethodCallee {\n-                origin: this.read_struct_field(\"origin\", 0, |this| {\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee) {\n+        self.read_struct(\"MethodCallee\", 4, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+                Decodable::decode(this)\n+            });\n+            (autoderef, MethodCallee {\n+                origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n                         Decodable::decode(this);\n                     method_origin.tr(xcx)\n                 }),\n-                ty: this.read_struct_field(\"ty\", 1, |this| {\n+                ty: this.read_struct_field(\"ty\", 2, |this| {\n                     this.read_ty(xcx)\n                 }),\n-                substs: this.read_struct_field(\"substs\", 2, |this| {\n+                substs: this.read_struct_field(\"substs\", 3, |this| {\n                     this.read_substs(xcx)\n                 })\n-            }\n+            })\n         })\n     }\n }\n@@ -647,6 +654,20 @@ impl tr for MethodOrigin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n+fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n+                              ebml_w: &mut writer::Encoder,\n+                              autoderef: u32,\n+                              dr: typeck::vtable_res) {\n+    ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n+        ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n+            autoderef.encode(ebml_w);\n+        });\n+        ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n+            encode_vtable_res(ecx, ebml_w, dr);\n+        });\n+    })\n+}\n+\n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n@@ -701,6 +722,10 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n }\n \n pub trait vtable_decoder_helpers {\n+    fn read_vtable_res_with_key(&mut self,\n+                                tcx: &ty::ctxt,\n+                                cdata: @cstore::crate_metadata)\n+                                -> (u32, typeck::vtable_res);\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res;\n@@ -713,6 +738,20 @@ pub trait vtable_decoder_helpers {\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n+    fn read_vtable_res_with_key(&mut self,\n+                                tcx: &ty::ctxt,\n+                                cdata: @cstore::crate_metadata)\n+                                -> (u32, typeck::vtable_res) {\n+        self.read_struct(\"VtableWithKey\", 2, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+                Decodable::decode(this)\n+            });\n+            (autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n+                this.read_vtable_res(tcx, cdata)\n+            }))\n+        })\n+    }\n+\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n@@ -1018,7 +1057,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_method_callee(ecx, ebml_w, method)\n+                encode_method_callee(ecx, ebml_w, method_call.autoderef, method)\n             })\n         })\n     }\n@@ -1027,12 +1066,39 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res(ecx, ebml_w, *dr);\n+                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, *dr);\n             })\n         })\n     }\n \n     for adj in tcx.adjustments.borrow().find(&id).iter() {\n+        match ***adj {\n+            ty::AutoDerefRef(adj) => {\n+                for autoderef in range(0, adj.autoderefs) {\n+                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                    for &method in maps.method_map.borrow().find(&method_call).iter() {\n+                        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n+                            ebml_w.id(id);\n+                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                                encode_method_callee(ecx, ebml_w, method_call.autoderef, method)\n+                            })\n+                        })\n+                    }\n+\n+                    for &dr in maps.vtable_map.borrow().find(&method_call).iter() {\n+                        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n+                            ebml_w.id(id);\n+                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                                encode_vtable_res_with_key(ecx, ebml_w,\n+                                                           method_call.autoderef, *dr);\n+                            })\n+                        })\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1336,15 +1402,21 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let method = val_dsr.read_method_callee(xcx);\n-                        let method_call = MethodCall::expr(id);\n+                        let (autoderef, method) = val_dsr.read_method_callee(xcx);\n+                        let method_call = MethodCall {\n+                            expr_id: id,\n+                            autoderef: autoderef\n+                        };\n                         dcx.maps.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n-                        let vtable_res =\n-                            val_dsr.read_vtable_res(xcx.dcx.tcx,\n-                                                    xcx.dcx.cdata);\n-                        let vtable_key = MethodCall::expr(id);\n+                        let (autoderef, vtable_res) =\n+                            val_dsr.read_vtable_res_with_key(xcx.dcx.tcx,\n+                                                             xcx.dcx.cdata);\n+                        let vtable_key = MethodCall {\n+                            expr_id: id,\n+                            autoderef: autoderef\n+                        };\n                         dcx.maps.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n                     }\n                     c::tag_table_adjustments => {"}, {"sha": "65a404d1ff36209b16d57b36f351233569022168", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+struct DerefWithHelper<H, T> {\n+    helper: H\n+}\n+\n+trait Helper<T> {\n+    fn helper_borrow<'a>(&'a self) -> &'a T;\n+}\n+\n+impl<T> Helper<T> for Option<T> {\n+    fn helper_borrow<'a>(&'a self) -> &'a T {\n+        self.as_ref().unwrap()\n+    }\n+}\n+\n+impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        self.helper.helper_borrow()\n+    }\n+}\n+\n+// Test cross-crate autoderef + vtable.\n+pub fn check<T: Eq>(x: T, y: T) -> bool {\n+    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x) };\n+    d.eq(&y)\n+}"}, {"sha": "fc969093d23a913f25fbecb2dc3d3b12104e028b", "filename": "src/test/run-pass/overloaded-autoderef-xcrate.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs?ref=087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+// aux-build:overloaded_autoderef_xc.rs\n+\n+extern crate overloaded_autoderef_xc;\n+\n+fn main() {\n+    assert!(overloaded_autoderef_xc::check(5, 5));\n+}"}]}