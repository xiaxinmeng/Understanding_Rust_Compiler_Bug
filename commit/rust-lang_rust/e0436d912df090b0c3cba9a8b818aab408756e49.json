{"sha": "e0436d912df090b0c3cba9a8b818aab408756e49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNDM2ZDkxMmRmMDkwYjBjM2NiYTlhOGI4MThhYWI0MDg3NTZlNDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-30T09:52:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-30T09:52:29Z"}, "message": "Auto merge of #64600 - scottmcm:no-slice-tryfold-unroll, r=bluss\n\nRemove manual unrolling from slice::Iter(Mut)::try_fold\n\nWhile this definitely helps sometimes (particularly for trivial closures), it's also a pessimization sometimes, so it's better to leave this to (hypothetical) future LLVM improvements instead of forcing this on everyone.\n\nI think it's better for the advice to be that sometimes you need to unroll manually than you sometimes need to not-unroll manually (like #64545).\n\n---\n\nFor context see https://github.com/rust-lang/rust/pull/64572#issuecomment-532961046", "tree": {"sha": "48d50edb6ab8a2c03fe86b4f2c76e676d2cf4e61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d50edb6ab8a2c03fe86b4f2c76e676d2cf4e61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0436d912df090b0c3cba9a8b818aab408756e49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0436d912df090b0c3cba9a8b818aab408756e49", "html_url": "https://github.com/rust-lang/rust/commit/e0436d912df090b0c3cba9a8b818aab408756e49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0436d912df090b0c3cba9a8b818aab408756e49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf8491e72ef0d5ea0ef683e9d149408a717545e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8491e72ef0d5ea0ef683e9d149408a717545e4", "html_url": "https://github.com/rust-lang/rust/commit/bf8491e72ef0d5ea0ef683e9d149408a717545e4"}, {"sha": "6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "html_url": "https://github.com/rust-lang/rust/commit/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16"}], "stats": {"total": 69, "additions": 1, "deletions": 68}, "files": [{"sha": "b5462d988378be5c6f099456ffae8ccfa44d7036", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e0436d912df090b0c3cba9a8b818aab408756e49/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0436d912df090b0c3cba9a8b818aab408756e49/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e0436d912df090b0c3cba9a8b818aab408756e49", "patch": "@@ -28,7 +28,7 @@ use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub, is_aligned_and_not_null};\n use crate::isize;\n use crate::iter::*;\n-use crate::ops::{FnMut, Try, self};\n+use crate::ops::{FnMut, self};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::result::Result;\n@@ -3180,39 +3180,6 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n-            #[inline]\n-            fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-            {\n-                // manual unrolling is needed when there are conditional exits from the loop\n-                let mut accum = init;\n-                unsafe {\n-                    while len!(self) >= 4 {\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                        accum = f(accum, next_unchecked!(self))?;\n-                    }\n-                    while !is_empty!(self) {\n-                        accum = f(accum, next_unchecked!(self))?;\n-                    }\n-                }\n-                Try::from_ok(accum)\n-            }\n-\n-            #[inline]\n-            fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                // Let LLVM unroll this, rather than using the default\n-                // impl that would force the manual unrolling above\n-                let mut accum = init;\n-                while let Some(x) = self.next() {\n-                    accum = f(accum, x);\n-                }\n-                accum\n-            }\n-\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -3283,40 +3250,6 @@ macro_rules! iterator {\n                     Some(next_back_unchecked!(self))\n                 }\n             }\n-\n-            #[inline]\n-            fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-            {\n-                // manual unrolling is needed when there are conditional exits from the loop\n-                let mut accum = init;\n-                unsafe {\n-                    while len!(self) >= 4 {\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                    }\n-                    // inlining is_empty everywhere makes a huge performance difference\n-                    while !is_empty!(self) {\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                    }\n-                }\n-                Try::from_ok(accum)\n-            }\n-\n-            #[inline]\n-            fn rfold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                // Let LLVM unroll this, rather than using the default\n-                // impl that would force the manual unrolling above\n-                let mut accum = init;\n-                while let Some(x) = self.next_back() {\n-                    accum = f(accum, x);\n-                }\n-                accum\n-            }\n         }\n \n         #[stable(feature = \"fused\", since = \"1.26.0\")]"}]}