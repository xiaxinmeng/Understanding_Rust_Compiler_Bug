{"sha": "eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViOTI2ZGQ0YjczZmNmZDY2ZmQzMTYxODcwY2VlNTEyMmNhNTdiNGY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T15:33:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T14:45:29Z"}, "message": "typeck: Unify if-else blocks, match arms and array elements by coercing where possible.", "tree": {"sha": "cb32bb1648633e3e581311c61246f76c399e4f8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb32bb1648633e3e581311c61246f76c399e4f8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "html_url": "https://github.com/rust-lang/rust/commit/eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2c6bef493a86d83e8df726a8210e09187384cd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2c6bef493a86d83e8df726a8210e09187384cd9", "html_url": "https://github.com/rust-lang/rust/commit/d2c6bef493a86d83e8df726a8210e09187384cd9"}], "stats": {"total": 593, "additions": 422, "deletions": 171}, "files": [{"sha": "6da65c85f91dbbc485bdf233c5ad95cad02197f0", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -139,11 +139,11 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n     relate_substs(relation, opt_variances, a_subst, b_subst)\n }\n \n-fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                               variances: Option<&ty::ItemVariances>,\n-                               a_subst: &Substs<'tcx>,\n-                               b_subst: &Substs<'tcx>)\n-                               -> RelateResult<'tcx, Substs<'tcx>>\n+pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n+                                   variances: Option<&ty::ItemVariances>,\n+                                   a_subst: &Substs<'tcx>,\n+                                   b_subst: &Substs<'tcx>)\n+                                   -> RelateResult<'tcx, Substs<'tcx>>\n     where R: TypeRelation<'a,'tcx>\n {\n     let mut substs = Substs::empty();"}, {"sha": "305970db9e72e0fa43d340ab4c01f34f472c9a18", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -15,9 +15,10 @@ use middle::pat_util::pat_is_resolved_const;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n-use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n+use check::{demand, FnCtxt, Expectation};\n use check::{check_expr_with_lvalue_pref};\n use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n+use check::coercion;\n use lint;\n use require_same_types;\n use util::nodemap::FnvHashMap;\n@@ -492,54 +493,67 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // of execution reach it, we will panic, so bottom is an appropriate\n     // type in that case)\n     let expected = expected.adjust_for_branches(fcx);\n-    let result_ty = arms.iter().fold(fcx.infcx().next_diverging_ty_var(), |result_ty, arm| {\n-        let bty = match expected {\n-            // We don't coerce to `()` so that if the match expression is a\n-            // statement it's branches can have any consistent type. That allows\n-            // us to give better error messages (pointing to a usually better\n-            // arm for inconsistent arms or to the whole match when a `()` type\n-            // is required).\n-            Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n-                check_expr_coercable_to_type(fcx, &arm.body, ety);\n-                ety\n-            }\n-            _ => {\n-                check_expr_with_expectation(fcx, &arm.body, expected);\n-                fcx.node_ty(arm.body.id)\n+    let mut result_ty = fcx.infcx().next_diverging_ty_var();\n+    let coerce_first = match expected {\n+        // We don't coerce to `()` so that if the match expression is a\n+        // statement it's branches can have any consistent type. That allows\n+        // us to give better error messages (pointing to a usually better\n+        // arm for inconsistent arms or to the whole match when a `()` type\n+        // is required).\n+        Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n+            ety\n+        }\n+        _ => result_ty\n+    };\n+    for (i, arm) in arms.iter().enumerate() {\n+        if let Some(ref e) = arm.guard {\n+            check_expr_has_type(fcx, e, tcx.types.bool);\n+        }\n+        check_expr_with_expectation(fcx, &arm.body, expected);\n+        let arm_ty = fcx.expr_ty(&arm.body);\n+\n+        if result_ty.references_error() || arm_ty.references_error() {\n+            result_ty = tcx.types.err;\n+            continue;\n+        }\n+\n+        // Handle the fallback arm of a desugared if-let like a missing else.\n+        let is_if_let_fallback = match match_src {\n+            hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n+                i == arms.len() - 1 && arm_ty.is_nil()\n             }\n+            _ => false\n         };\n \n-        if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, &e, tcx.types.bool);\n-        }\n+        let origin = if is_if_let_fallback {\n+            TypeOrigin::IfExpressionWithNoElse(expr.span)\n+        } else {\n+            TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src)\n+        };\n \n-        if result_ty.references_error() || bty.references_error() {\n-            tcx.types.err\n+        let result = if is_if_let_fallback {\n+            fcx.infcx().eq_types(true, origin, arm_ty, result_ty).map(|_| arm_ty)\n+        } else if i == 0 {\n+            // Special-case the first arm, as it has no \"previous expressions\".\n+            coercion::try(fcx, &arm.body, coerce_first)\n         } else {\n-            let (origin, expected, found) = match match_src {\n-                /* if-let construct without an else block */\n-                hir::MatchSource::IfLetDesugar { contains_else_clause }\n-                if !contains_else_clause => (\n-                    TypeOrigin::IfExpressionWithNoElse(expr.span),\n-                    bty,\n-                    result_ty,\n-                ),\n-                _ => (\n-                    TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src),\n-                    result_ty,\n-                    bty,\n-                ),\n-            };\n+            let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n+            coercion::try_find_lub(fcx, origin, prev_arms, result_ty, &arm.body)\n+        };\n \n-            infer::common_supertype(\n-                fcx.infcx(),\n-                origin,\n-                true,\n-                expected,\n-                found,\n-            )\n-        }\n-    });\n+        result_ty = match result {\n+            Ok(ty) => ty,\n+            Err(e) => {\n+                let (expected, found) = if is_if_let_fallback {\n+                    (arm_ty, result_ty)\n+                } else {\n+                    (result_ty, arm_ty)\n+                };\n+                fcx.infcx().report_mismatched_types(origin, expected, found, e);\n+                fcx.tcx().types.err\n+            }\n+        };\n+    }\n \n     fcx.write_ty(expr.id, result_ty);\n }"}, {"sha": "b5cd5d7f8e5a38d391ab2f056ff70de16cc60d56", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -240,7 +240,7 @@ impl<'tcx> CastCheck<'tcx> {\n                 if let ty::TyFnDef(_, _, f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n                     let res = coercion::try(fcx, self.expr,\n-                        self.expr_ty, fcx.tcx().mk_ty(ty::TyFnPtr(f)));\n+                                            fcx.tcx().mk_ty(ty::TyFnPtr(f)));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -390,7 +390,7 @@ impl<'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n-        coercion::try(fcx, self.expr, self.expr_ty, self.cast_ty).is_ok()\n+        coercion::try(fcx, self.expr, self.cast_ty).is_ok()\n     }\n \n }"}, {"sha": "aa359c95e2d1409c37c42f4de5de2cdc5f663b86", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 204, "deletions": 63, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -62,7 +62,7 @@\n \n use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n \n-use middle::infer::{self, Coercion, TypeOrigin};\n+use middle::infer::{Coercion, TypeOrigin, TypeTrace};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n@@ -71,7 +71,7 @@ use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n use middle::ty::fold::TypeFoldable;\n use middle::ty::error::TypeError;\n-use middle::ty::relate::RelateResult;\n+use middle::ty::relate::{relate_substs, RelateResult, TypeRelation};\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -80,17 +80,30 @@ use rustc_front::hir;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    origin: infer::TypeOrigin,\n+    origin: TypeOrigin,\n+    use_lub: bool,\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, Option<AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, AutoAdjustment<'tcx>)>;\n+\n+fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n+                       to_mutbl: hir::Mutability)\n+                       -> RelateResult<'tcx, ()> {\n+    match (from_mutbl, to_mutbl) {\n+        (hir::MutMutable, hir::MutMutable) |\n+        (hir::MutImmutable, hir::MutImmutable) |\n+        (hir::MutMutable, hir::MutImmutable) => Ok(()),\n+        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability)\n+    }\n+}\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'tcx>, origin: TypeOrigin) -> Self {\n+    fn new(fcx: &'f FnCtxt<'f, 'tcx>, origin: TypeOrigin) -> Self {\n         Coerce {\n             fcx: fcx,\n             origin: origin,\n+            use_lub: false,\n             unsizing_obligations: RefCell::new(vec![])\n         }\n     }\n@@ -99,9 +112,26 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        try!(self.fcx.infcx().sub_types(false, self.origin.clone(), a, b));\n-        Ok(None) // No coercion required.\n+    /// Unify two types (using sub or lub) and produce a noop coercion.\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        let infcx = self.fcx.infcx();\n+        infcx.commit_if_ok(|_| {\n+            let trace = TypeTrace::types(self.origin, false, a, b);\n+            if self.use_lub {\n+                infcx.lub(false, trace).relate(&a, &b)\n+            } else {\n+                infcx.sub(false, trace).relate(&a, &b)\n+            }\n+        }).and_then(|ty| self.identity(ty))\n+    }\n+\n+    /// Synthesize an identity adjustment.\n+    fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        Ok((ty, AdjustDerefRef(AutoDerefRef {\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: None\n+        })))\n     }\n \n     fn coerce<'a, E, I>(&self,\n@@ -118,7 +148,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return Ok(None);\n+            return self.identity(b);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -137,7 +167,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n \n             ty::TyRef(_, mt_b) => {\n-                return self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl);\n+                return self.coerce_borrowed_pointer(exprs, a, b, mt_b.mutbl);\n             }\n \n             _ => {}\n@@ -156,8 +186,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n             _ => {\n-                // Otherwise, just use subtyping rules.\n-                self.subtype(a, b)\n+                // Otherwise, just use unification rules.\n+                self.unify(a, b)\n             }\n         }\n     }\n@@ -166,7 +196,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n     fn coerce_borrowed_pointer<'a, E, I>(&self,\n-                                         span: Span,\n                                          exprs: &E,\n                                          a: Ty<'tcx>,\n                                          b: Ty<'tcx>,\n@@ -188,7 +217,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::TyRef(_, mt_a) => {\n                 try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n             }\n-            _ => return self.subtype(a, b)\n+            _ => return self.unify(a, b)\n         }\n \n         let span = self.origin.span();\n@@ -210,19 +239,20 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             let ty = self.tcx().mk_ref(r_borrow,\n                                         TypeAndMut {ty: inner_ty, mutbl: mutbl_b});\n-            if let Err(err) = self.subtype(ty, b) {\n-                if first_error.is_none() {\n-                    first_error = Some(err);\n+            match self.unify(ty, b) {\n+                Err(err) => {\n+                    if first_error.is_none() {\n+                        first_error = Some(err);\n+                    }\n+                    None\n                 }\n-                None\n-            } else {\n-                Some(())\n+                Ok((ty, _)) => Some(ty)\n             }\n         });\n \n         match success {\n-            Some(_) => {\n-                Ok(Some(AdjustDerefRef(AutoDerefRef {\n+            Some(ty) => {\n+                Ok((ty, AdjustDerefRef(AutoDerefRef {\n                     autoderefs: autoderefs,\n                     autoref: autoref,\n                     unsize: None\n@@ -341,7 +371,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             unsize: Some(target)\n         };\n         debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok(Some(AdjustDerefRef(adjustment)))\n+        Ok((target, AdjustDerefRef(adjustment)))\n     }\n \n     fn coerce_from_fn_pointer(&self,\n@@ -362,13 +392,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n-                    try!(self.subtype(unsafe_a, b));\n-                    return Ok(Some(AdjustUnsafeFnPointer));\n+                    return self.unify(unsafe_a, b).map(|(ty, _)| {\n+                        (ty, AdjustUnsafeFnPointer)\n+                    });\n                 }\n                 _ => {}\n             }\n         }\n-        self.subtype(a, b)\n+        self.unify(a, b)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -387,10 +418,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx().mk_ty(ty::TyFnPtr(fn_ty_a));\n-                try!(self.subtype(a_fn_pointer, b));\n-                Ok(Some(AdjustReifyFnPointer))\n+                self.unify(a_fn_pointer, b).map(|(ty, _)| {\n+                    (ty, AdjustReifyFnPointer)\n+                })\n             }\n-            _ => self.subtype(a, b)\n+            _ => self.unify(a, b)\n         }\n     }\n \n@@ -407,37 +439,37 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.subtype(a, b);\n+                return self.unify(a, b);\n             }\n         };\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx().mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n-        try!(self.subtype(a_unsafe, b));\n+        let (ty, noop) = try!(self.unify(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        if is_ref {\n-            Ok(Some(AdjustDerefRef(AutoDerefRef {\n+        Ok((ty, if is_ref {\n+            AdjustDerefRef(AutoDerefRef {\n                 autoderefs: 1,\n                 autoref: Some(AutoUnsafe(mutbl_b)),\n                 unsize: None\n-            })))\n+            })\n         } else if mt_a.mutbl != mutbl_b {\n-            Ok(Some(AdjustMutToConstPointer))\n+            AdjustMutToConstPointer\n         } else {\n-            Ok(None)\n-        }\n+            noop\n+        }))\n     }\n }\n \n fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n                              exprs: &E,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n-                             -> RelateResult<'tcx, Ty<'tcx>>\n+                             -> CoerceResult<'tcx>\n     where E: Fn() -> I,\n           I: IntoIterator<Item=&'b hir::Expr> {\n \n@@ -446,44 +478,153 @@ fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n     let fcx = coerce.fcx;\n     if let AdjustDerefRef(auto) = adjustment {\n         if auto.unsize.is_some() {\n-            for obligation in coerce.unsizing_obligations.borrow_mut().drain() {\n+            let mut obligations = coerce.unsizing_obligations.borrow_mut();\n+            for obligation in obligations.drain(..) {\n                 fcx.register_predicate(obligation);\n             }\n         }\n     }\n \n-    if !adjustment.is_identity() {\n-        debug!(\"Success, coerced with {:?}\", adjustment);\n-        for expr in exprs() {\n-            assert!(!fcx.inh.tables.borrow().adjustments.contains(&expr.id));\n-            fcx.write_adjustment(expr.id, adjustment);\n-        }\n-    }\n-    Ok(ty)\n+    Ok((ty, adjustment))\n }\n \n-/// Attempt to coerce an expression from a type (a) to another type (b).\n-/// Adjustments are only recorded if the coercion was successful.\n+/// Attempt to coerce an expression to a type, and return the\n+/// adjusted type of the expression, if successful.\n+/// Adjustments are only recorded if the coercion succeeded.\n /// The expressions *must not* have any pre-existing adjustments.\n pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                      expr: &hir::Expr,\n-                     a: Ty<'tcx>,\n-                     b: Ty<'tcx>)\n-                     -> RelateResult<'tcx, ()> {\n-    debug!(\"coercion::try({:?} -> {:?})\", a, b);\n+                     target: Ty<'tcx>)\n+                     -> RelateResult<'tcx, Ty<'tcx>> {\n+    let source = fcx.resolve_type_vars_if_possible(fcx.expr_ty(expr));\n+    debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n+\n     let mut coerce = Coerce::new(fcx, TypeOrigin::ExprAssignable(expr.span));\n     fcx.infcx().commit_if_ok(|_| {\n-        apply(&mut coerce, &|| Some(expr), a, b)\n-    }).map(|_| ())\n+        let (ty, adjustment) =\n+            try!(apply(&mut coerce, &|| Some(expr), source, target));\n+        if !adjustment.is_identity() {\n+            debug!(\"Success, coerced with {:?}\", adjustment);\n+            assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+            fcx.write_adjustment(expr.id, adjustment);\n+        }\n+        Ok(ty)\n+    })\n }\n \n-fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n-                       to_mutbl: hir::Mutability)\n-                       -> CoerceResult<'tcx> {\n-    match (from_mutbl, to_mutbl) {\n-        (hir::MutMutable, hir::MutMutable) |\n-        (hir::MutImmutable, hir::MutImmutable) |\n-        (hir::MutMutable, hir::MutImmutable) => Ok(None),\n-        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability)\n+/// Given some expressions, their known unified type and another expression,\n+/// tries to unify the types, potentially inserting coercions on any of the\n+/// provided expressions and returns their LUB (aka \"common supertype\").\n+pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        origin: TypeOrigin,\n+                                        exprs: E,\n+                                        prev_ty: Ty<'tcx>,\n+                                        new: &'b hir::Expr)\n+                                        -> RelateResult<'tcx, Ty<'tcx>>\n+    // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+    where E: Fn() -> I,\n+          I: IntoIterator<Item=&'b hir::Expr> {\n+\n+    let prev_ty = fcx.resolve_type_vars_if_possible(prev_ty);\n+    let new_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(new));\n+    debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n+\n+    let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n+    let mut lub = fcx.infcx().lub(true, trace);\n+\n+    // Special-case that coercion alone cannot handle:\n+    // Two function item types of differing IDs or Substs.\n+    match (&prev_ty.sty, &new_ty.sty) {\n+        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n+         &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n+            // The signature must always match.\n+            let fty = try!(lub.relate(a_fty, b_fty));\n+\n+            if a_def_id == b_def_id {\n+                // Same function, maybe the parameters match.\n+                let substs = fcx.infcx().commit_if_ok(|_| {\n+                    relate_substs(&mut lub, None, a_substs, b_substs)\n+                }).map(|s| fcx.tcx().mk_substs(s));\n+\n+                if let Ok(substs) = substs {\n+                    // We have a LUB of prev_ty and new_ty, just return it.\n+                    return Ok(fcx.tcx().mk_fn_def(a_def_id, substs, fty));\n+                }\n+            }\n+\n+            // Reify both sides and return the reified fn pointer type.\n+            for expr in exprs().into_iter().chain(Some(new)) {\n+                // No adjustments can produce a fn item, so this should never trip.\n+                assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+                fcx.write_adjustment(expr.id, AdjustReifyFnPointer);\n+            }\n+            return Ok(fcx.tcx().mk_fn_ptr(fty));\n+        }\n+        _ => {}\n+    }\n+\n+    let mut coerce = Coerce::new(fcx, origin);\n+    coerce.use_lub = true;\n+\n+    // First try to coerce the new expression to the type of the previous ones,\n+    // but only if the new expression has no coercion already applied to it.\n+    let mut first_error = None;\n+    if !fcx.inh.tables.borrow().adjustments.contains_key(&new.id) {\n+        let result = fcx.infcx().commit_if_ok(|_| {\n+            apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n+        });\n+        match result {\n+            Ok((ty, adjustment)) => {\n+                if !adjustment.is_identity() {\n+                    fcx.write_adjustment(new.id, adjustment);\n+                }\n+                return Ok(ty);\n+            }\n+            Err(e) => first_error = Some(e)\n+        }\n+    }\n+\n+    // Then try to coerce the previous expressions to the type of the new one.\n+    // This requires ensuring there are no coercions applied to *any* of the\n+    // previous expressions, other than noop reborrows (ignoring lifetimes).\n+    for expr in exprs() {\n+        let noop = match fcx.inh.tables.borrow().adjustments.get(&expr.id) {\n+            Some(&AdjustDerefRef(AutoDerefRef {\n+                autoderefs: 1,\n+                autoref: Some(AutoPtr(_, mutbl_adj)),\n+                unsize: None\n+            })) => match fcx.expr_ty(expr).sty {\n+                ty::TyRef(_, mt_orig) => {\n+                    // Reborrow that we can safely ignore.\n+                    mutbl_adj == mt_orig.mutbl\n+                }\n+                _ => false\n+            },\n+            Some(_) => false,\n+            None => true\n+        };\n+\n+        if !noop {\n+            return fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty));\n+        }\n+    }\n+\n+    match fcx.infcx().commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+        Err(_) => {\n+            // Avoid giving strange errors on failed attempts.\n+            if let Some(e) = first_error {\n+                Err(e)\n+            } else {\n+                fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty))\n+            }\n+        }\n+        Ok((ty, adjustment)) => {\n+            if !adjustment.is_identity() {\n+                for expr in exprs() {\n+                    fcx.write_adjustment(expr.id, adjustment);\n+                }\n+            }\n+            Ok(ty)\n+        }\n     }\n }"}, {"sha": "1f61198bef92134ffc9e39ef793dde2c2b647676", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -39,14 +39,10 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         sp: Span,\n                         expected: Ty<'tcx>,\n                         expr: &hir::Expr) {\n-    let expr_ty = fcx.expr_ty(expr);\n-    debug!(\"demand::coerce(expected = {:?}, expr_ty = {:?})\",\n-           expected,\n-           expr_ty);\n-    let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n-    let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = coercion::try(fcx, expr, expr_ty, expected) {\n+    if let Err(e) = coercion::try(fcx, expr, expected) {\n+        let origin = TypeOrigin::Misc(sp);\n+        let expr_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(expr));\n         fcx.infcx().report_mismatched_types(origin, expected, expr_ty, e);\n     }\n }"}, {"sha": "0743c0b9e187b560da663928c4c773b9a7234e7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 40, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -89,7 +89,7 @@ use middle::cstore::LOCAL_CRATE;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::infer;\n-use middle::infer::{TypeOrigin, type_variable};\n+use middle::infer::{TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n@@ -101,6 +101,7 @@ use middle::ty::{MethodCall, MethodCallee};\n use middle::ty::adjustment;\n use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::relate::TypeRelation;\n use middle::ty::util::Representability;\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n@@ -2080,7 +2081,7 @@ pub fn autoderef<'a, 'b, 'tcx, E, I, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // (i.e. it is an inference variable) because `Ty::builtin_deref`\n                 // and `try_overloaded_deref` both simply return `None`\n                 // in such a case without producing spurious errors.\n-                fcx.resolve_type_vars_if_possible(t)\n+                fcx.infcx().resolve_type_vars_if_possible(&t)\n             }\n         };\n         if resolved_t.references_error() {\n@@ -2164,7 +2165,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait returns a type of `&T`, but the\n /// actual type we assign to the *expression* is `T`. So this function just peels off the return\n /// type by one layer to yield `T`.\n-fn make_overloaded_lvalue_return_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+fn make_overloaded_lvalue_return_type<'tcx>(tcx: &TyCtxt<'tcx>,\n                                             method: MethodCallee<'tcx>)\n                                             -> ty::TypeAndMut<'tcx>\n {\n@@ -2834,30 +2835,52 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         check_block_with_expected(fcx, then_blk, expected);\n         let then_ty = fcx.node_ty(then_blk.id);\n \n-        let branches_ty = match opt_else_expr {\n-            Some(ref else_expr) => {\n-                check_expr_with_expectation(fcx, &else_expr, expected);\n-                let else_ty = fcx.expr_ty(&else_expr);\n-                infer::common_supertype(fcx.infcx(),\n-                                        TypeOrigin::IfExpression(sp),\n-                                        true,\n-                                        then_ty,\n-                                        else_ty)\n-            }\n-            None => {\n-                infer::common_supertype(fcx.infcx(),\n-                                        TypeOrigin::IfExpressionWithNoElse(sp),\n-                                        false,\n-                                        then_ty,\n-                                        fcx.tcx().mk_nil())\n-            }\n-        };\n+        let unit = fcx.tcx().mk_nil();\n+        let (origin, expected, found, result) =\n+        if let Some(else_expr) = opt_else_expr {\n+            check_expr_with_expectation(fcx, else_expr, expected);\n+            let else_ty = fcx.expr_ty(else_expr);\n+            let origin = TypeOrigin::IfExpression(sp);\n+\n+            // Only try to coerce-unify if we have a then expression\n+            // to assign coercions to, otherwise it's () or diverging.\n+            let result = if let Some(ref then) = then_blk.expr {\n+                let res = coercion::try_find_lub(fcx, origin, || Some(&**then),\n+                                                 then_ty, else_expr);\n+\n+                // In case we did perform an adjustment, we have to update\n+                // the type of the block, because old trans still uses it.\n+                let adj = fcx.inh.tables.borrow().adjustments.get(&then.id).cloned();\n+                if res.is_ok() && adj.is_some() {\n+                    fcx.write_ty(then_blk.id, fcx.adjust_expr_ty(then, adj.as_ref()));\n+                }\n \n-        let cond_ty = fcx.expr_ty(cond_expr);\n-        let if_ty = if cond_ty.references_error() {\n-            fcx.tcx().types.err\n+                res\n+            } else {\n+                fcx.infcx().commit_if_ok(|_| {\n+                    let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n+                    fcx.infcx().lub(true, trace).relate(&then_ty, &else_ty)\n+                })\n+            };\n+            (origin, then_ty, else_ty, result)\n         } else {\n-            branches_ty\n+            let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n+            (origin, unit, then_ty,\n+             fcx.infcx().eq_types(true, origin, unit, then_ty).map(|_| unit))\n+        };\n+\n+        let if_ty = match result {\n+            Ok(ty) => {\n+                if fcx.expr_ty(cond_expr).references_error() {\n+                    fcx.tcx().types.err\n+                } else {\n+                    ty\n+                }\n+            }\n+            Err(e) => {\n+                fcx.infcx().report_mismatched_types(origin, expected, found, e);\n+                fcx.tcx().types.err\n+            }\n         };\n \n         fcx.write_ty(id, if_ty);\n@@ -3497,23 +3520,30 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         });\n \n-        let typ = match uty {\n-            Some(uty) => {\n-                for e in args {\n-                    check_expr_coercable_to_type(fcx, &e, uty);\n-                }\n-                uty\n-            }\n-            None => {\n-                let t: Ty = fcx.infcx().next_ty_var();\n-                for e in args {\n-                    check_expr_has_type(fcx, &e, t);\n+        let mut unified = fcx.infcx().next_ty_var();\n+        let coerce_to = uty.unwrap_or(unified);\n+\n+        for (i, e) in args.iter().enumerate() {\n+            check_expr_with_hint(fcx, e, coerce_to);\n+            let e_ty = fcx.expr_ty(e);\n+            let origin = TypeOrigin::Misc(e.span);\n+\n+            // Special-case the first element, as it has no \"previous expressions\".\n+            let result = if i == 0 {\n+                coercion::try(fcx, e, coerce_to)\n+            } else {\n+                let prev_elems = || args[..i].iter().map(|e| &**e);\n+                coercion::try_find_lub(fcx, origin, prev_elems, unified, e)\n+            };\n+\n+            match result {\n+                Ok(ty) => unified = ty,\n+                Err(e) => {\n+                    fcx.infcx().report_mismatched_types(origin, unified, e_ty, e);\n                 }\n-                t\n             }\n-        };\n-        let typ = tcx.mk_array(typ, args.len());\n-        fcx.write_ty(id, typ);\n+        }\n+        fcx.write_ty(id, tcx.mk_array(unified, args.len()));\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &count_expr, tcx.types.usize);"}, {"sha": "2fbd1ddb1e6b962f3ca6f79d3712d3a7e1ec557e", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -20,13 +20,6 @@ trait Foo { fn foo() { /* this is a default fn */ } }\n impl<T> Foo for T { /* `foo` is still default here */ }\n \n fn main() {\n-    let f = if true { foo::<u8> } else { bar::<u8> };\n-    //~^ ERROR if and else have incompatible types\n-    //~| expected `fn(isize) -> isize {foo::<u8>}`\n-    //~| found `fn(isize) -> isize {bar::<u8>}`\n-    //~| expected fn item,\n-    //~| found a different fn item\n-\n     eq(foo::<u8>, bar::<u8>);\n     //~^ ERROR mismatched types\n     //~|  expected `fn(isize) -> isize {foo::<u8>}`"}, {"sha": "e1fe2d06993d5ba4a21f4cddd18a3bf9713bccfa", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     let y = match x {\n         [] => None,\n //~^ ERROR mismatched types\n-//~| expected `[_#0i; 2]`\n+//~| expected `[_#1i; 2]`\n //~| found `[_#7t; 0]`\n //~| expected an array with a fixed size of 2 elements\n //~| found one with 0 elements"}, {"sha": "787eb7a3b8878e362e49b12123d590a8fc03f608", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -107,7 +107,7 @@ impl Debug for Player {\n }\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n-    match to_parse {\n+    match to_parse { //~ ERROR match arms have incompatible types\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -116,7 +116,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"out\" => RoomDirection::Out,\n         \"up\" => RoomDirection::Up,\n         \"down\" => RoomDirection::Down,\n-        _ => None //~ ERROR mismatched types\n+        _ => None //~ NOTE match arm with an incompatible type\n     }\n }\n "}, {"sha": "9143a226a248355a8a932e859dea6b5e8809717b", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -21,5 +21,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR no method named `bind` found for type `[&str; 1]` in the current scope\n+    //~^ ERROR no method named `bind` found for type `[&'static str; 1]` in the current scope\n }"}, {"sha": "3d690146931d9cb8b461164ee3453222215e4b69", "filename": "src/test/run-pass/coerce-unify.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Frun-pass%2Fcoerce-unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb926dd4b73fcfd66fd3161870cee5122ca57b4f/src%2Ftest%2Frun-pass%2Fcoerce-unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-unify.rs?ref=eb926dd4b73fcfd66fd3161870cee5122ca57b4f", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that coercions can unify if-else, match arms and array elements.\n+\n+// Try to construct if-else chains, matches and arrays out of given expressions.\n+macro_rules! check {\n+    ($last:expr $(, $rest:expr)+) => {\n+        // Last expression comes first because of whacky ifs and matches.\n+        let _ = $(if false { $rest })else+ else { $last };\n+\n+        let _ = match 0 { $(_ if false => $rest,)+ _ => $last };\n+\n+        let _ = [$($rest,)+ $last];\n+    }\n+}\n+\n+// Check all non-uniform cases of 2 and 3 expressions of 2 types.\n+macro_rules! check2 {\n+    ($a:expr, $b:expr) => {\n+        check!($a, $b);\n+        check!($b, $a);\n+\n+        check!($a, $a, $b);\n+        check!($a, $b, $a);\n+        check!($a, $b, $b);\n+\n+        check!($b, $a, $a);\n+        check!($b, $a, $b);\n+        check!($b, $b, $a);\n+    }\n+}\n+\n+// Check all non-uniform cases of 2 and 3 expressions of 3 types.\n+macro_rules! check3 {\n+    ($a:expr, $b:expr, $c:expr) => {\n+        // Delegate to check2 for cases where a type repeats.\n+        check2!($a, $b);\n+        check2!($b, $c);\n+        check2!($a, $c);\n+\n+        // Check the remaining cases, i.e. permutations of ($a, $b, $c).\n+        check!($a, $b, $c);\n+        check!($a, $c, $b);\n+        check!($b, $a, $c);\n+        check!($b, $c, $a);\n+        check!($c, $a, $b);\n+        check!($c, $b, $a);\n+    }\n+}\n+\n+use std::mem::size_of;\n+\n+fn foo() {}\n+fn bar() {}\n+\n+pub fn main() {\n+    check3!(foo, bar, foo as fn());\n+    check3!(size_of::<u8>, size_of::<u16>, size_of::<usize> as fn() -> usize);\n+\n+    let s = String::from(\"bar\");\n+    check2!(\"foo\", &s);\n+\n+    let a = [1, 2, 3];\n+    let v = vec![1, 2, 3];\n+    check2!(&a[..], &v);\n+\n+    // Make sure in-array coercion still works.\n+    let _ = [(\"a\", Default::default()), (Default::default(), \"b\"), (&s, &s)];\n+}"}]}