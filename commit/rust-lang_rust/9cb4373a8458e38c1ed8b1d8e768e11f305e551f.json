{"sha": "9cb4373a8458e38c1ed8b1d8e768e11f305e551f", "node_id": "C_kwDOAAsO6NoAKDljYjQzNzNhODQ1OGUzOGMxZWQ4YjFkOGU3NjhlMTFmMzA1ZTU1MWY", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-03-10T11:32:02Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-03T07:30:28Z"}, "message": "move cfg handling into its own module", "tree": {"sha": "2423c1ebe6328e88c938ef956f777beb4cf082aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2423c1ebe6328e88c938ef956f777beb4cf082aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cb4373a8458e38c1ed8b1d8e768e11f305e551f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQqgJQACgkQzXazX3c0\ndp5n8g/9ExGYqAxjH5PK4ID1TYW+4W0CFtYBeotEIcHBzzK6v2VkH4TZcPfJBadt\nddhvWiDflVSUb36lFGF4sVbMZRIy9haP5hD79JqnEx9VeSpRoP+2dm7mt49SHLoL\nqf1V6spYcgRIp2hoYQBUeGQ5ipY93/Uhwcd3pexsFtnnKOdev+fLDs/m9eo/cJ9B\nrU4ZmNuRLtJzQJU56C2vF7ii57f26iqL9G5ILfYH8Th6RE+yx7LBVMTW8TQeo8C8\n8XelWKx9znzgTlGJ7rlC1hvF9/YtdkO3S6dhXUEgSscR1ARW1+NIY7w8HrEAOpuj\nAfC1DlvM4wfakCmEqf/4jRiNgmJbRp+RbKm80VAdbnQ8Y9CHi16ktvximHS81pAT\nASrtrsvDc1/VmhtmzG0TDQv/MmoD0yGa0q8DXnfcuvf3uKDwDT9onJe9SczTQZE1\nQgNLcle4XXxRuIqoX5whP6GJ+CgnahlSMRe/WDnR6Qis/Lv03I6AdNn9K0ft/EG7\nxsoUNmy16VqNMZaCSuuscz0Kiyh3f1IQVlu6qy6P+614zyxxXxUk1B+bKhCE8nNn\nxsFFjqvGhF6voB10U3JYv0yfTlvyhW3SXX8vMsTF6AP3GT/SyreZPT6UDvq45ruQ\nJEh0TeaE9GV8SEYqGUOvRzITIwpw4vMKf2rBcOIMkYYQ8HoPVl8=\n=kItg\n-----END PGP SIGNATURE-----", "payload": "tree 2423c1ebe6328e88c938ef956f777beb4cf082aa\nparent 8eb3def446b7026b2ff2a981791e5fc6fe031944\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1678447922 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1680507028 +0200\n\nmove cfg handling into its own module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb4373a8458e38c1ed8b1d8e768e11f305e551f", "html_url": "https://github.com/rust-lang/rust/commit/9cb4373a8458e38c1ed8b1d8e768e11f305e551f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cb4373a8458e38c1ed8b1d8e768e11f305e551f/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb3def446b7026b2ff2a981791e5fc6fe031944", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb3def446b7026b2ff2a981791e5fc6fe031944", "html_url": "https://github.com/rust-lang/rust/commit/8eb3def446b7026b2ff2a981791e5fc6fe031944"}], "stats": {"total": 470, "additions": 239, "deletions": 231}, "files": [{"sha": "50b99b805729301c9b27c72b55e4b9234691a460", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 6, "deletions": 231, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/9cb4373a8458e38c1ed8b1d8e768e11f305e551f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb4373a8458e38c1ed8b1d8e768e11f305e551f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=9cb4373a8458e38c1ed8b1d8e768e11f305e551f", "patch": "@@ -8,41 +8,16 @@ use std::process::Command;\n \n use tracing::*;\n \n-use crate::common::CompareMode;\n use crate::common::{Config, Debugger, FailMode, Mode, PassMode};\n+use crate::header::cfg::parse_cfg_name_directive;\n+use crate::header::cfg::MatchOutcome;\n use crate::util;\n use crate::{extract_cdb_version, extract_gdb_version};\n \n+mod cfg;\n #[cfg(test)]\n mod tests;\n \n-/// The result of parse_cfg_name_directive.\n-#[derive(Clone, PartialEq, Debug)]\n-struct ParsedNameDirective<'a> {\n-    name: Option<&'a str>,\n-    pretty_reason: Option<String>,\n-    comment: Option<&'a str>,\n-    outcome: MatchOutcome,\n-}\n-\n-impl ParsedNameDirective<'_> {\n-    fn invalid() -> Self {\n-        Self { name: None, pretty_reason: None, comment: None, outcome: MatchOutcome::NoMatch }\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-enum MatchOutcome {\n-    /// No match.\n-    NoMatch,\n-    /// Match.\n-    Match,\n-    /// The directive was invalid.\n-    Invalid,\n-    /// The directive is handled by other parts of our tooling.\n-    External,\n-}\n-\n /// Properties which must be known very early, before actually running\n /// the test.\n #[derive(Default)]\n@@ -666,7 +641,7 @@ impl Config {\n     }\n \n     fn parse_custom_normalization(&self, mut line: &str, prefix: &str) -> Option<(String, String)> {\n-        if self.parse_cfg_name_directive(line, prefix).outcome == MatchOutcome::Match {\n+        if parse_cfg_name_directive(self, line, prefix).outcome == MatchOutcome::Match {\n             let from = parse_normalization_string(&mut line)?;\n             let to = parse_normalization_string(&mut line)?;\n             Some((from, to))\n@@ -683,206 +658,6 @@ impl Config {\n         self.parse_name_directive(line, \"needs-profiler-support\")\n     }\n \n-    /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n-    /// or `normalize-stderr-32bit`.\n-    fn parse_cfg_name_directive<'a>(&self, line: &'a str, prefix: &str) -> ParsedNameDirective<'a> {\n-        if !line.as_bytes().starts_with(prefix.as_bytes()) {\n-            return ParsedNameDirective::invalid();\n-        }\n-        if line.as_bytes().get(prefix.len()) != Some(&b'-') {\n-            return ParsedNameDirective::invalid();\n-        }\n-        let line = &line[prefix.len() + 1..];\n-\n-        let (name, comment) =\n-            line.split_once(&[':', ' ']).map(|(l, c)| (l, Some(c))).unwrap_or((line, None));\n-\n-        // Some of the matchers might be \"\" depending on what the target information is. To avoid\n-        // problems we outright reject empty directives.\n-        if name == \"\" {\n-            return ParsedNameDirective::invalid();\n-        }\n-\n-        let mut outcome = MatchOutcome::Invalid;\n-        let mut message = None;\n-\n-        macro_rules! maybe_condition {\n-            (\n-                name: $name:expr,\n-                $(allowed_names: $allowed_names:expr,)?\n-                $(condition: $condition:expr,)?\n-                message: $($message:tt)*\n-            ) => {{\n-                // This is not inlined to avoid problems with macro repetitions.\n-                let format_message = || format!($($message)*);\n-\n-                if outcome != MatchOutcome::Invalid {\n-                    // Ignore all other matches if we already found one\n-                } else if $name.as_ref().map(|n| n == &name).unwrap_or(false) {\n-                    message = Some(format_message());\n-                    if true $(&& $condition)? {\n-                        outcome = MatchOutcome::Match;\n-                    } else {\n-                        outcome = MatchOutcome::NoMatch;\n-                    }\n-                }\n-                $(else if $allowed_names.contains(name) {\n-                    message = Some(format_message());\n-                    outcome = MatchOutcome::NoMatch;\n-                })?\n-            }};\n-        }\n-        macro_rules! condition {\n-            (\n-                name: $name:expr,\n-                $(allowed_names: $allowed_names:expr,)?\n-                $(condition: $condition:expr,)?\n-                message: $($message:tt)*\n-            ) => {\n-                maybe_condition! {\n-                    name: Some($name),\n-                    $(allowed_names: $allowed_names,)*\n-                    $(condition: $condition,)*\n-                    message: $($message)*\n-                }\n-            };\n-        }\n-        macro_rules! hashset {\n-            ($($value:expr),* $(,)?) => {{\n-                let mut set = HashSet::new();\n-                $(set.insert($value);)*\n-                set\n-            }}\n-        }\n-\n-        let target_cfgs = self.target_cfgs();\n-        let target_cfg = self.target_cfg();\n-\n-        condition! {\n-            name: \"test\",\n-            message: \"always\"\n-        }\n-        condition! {\n-            name: &self.target,\n-            allowed_names: &target_cfgs.all_targets,\n-            message: \"when the target is {name}\"\n-        }\n-        condition! {\n-            name: &target_cfg.os,\n-            allowed_names: &target_cfgs.all_oses,\n-            message: \"when the operative system is {name}\"\n-        }\n-        condition! {\n-            name: &target_cfg.env,\n-            allowed_names: &target_cfgs.all_envs,\n-            message: \"when the target environment is {name}\"\n-        }\n-        condition! {\n-            name: &target_cfg.abi,\n-            allowed_names: &target_cfgs.all_abis,\n-            message: \"when the ABI is {name}\"\n-        }\n-        condition! {\n-            name: &target_cfg.arch,\n-            allowed_names: &target_cfgs.all_archs,\n-            message: \"when the architecture is {name}\"\n-        }\n-        condition! {\n-            name: format!(\"{}bit\", target_cfg.pointer_width),\n-            allowed_names: &target_cfgs.all_pointer_widths,\n-            message: \"when the pointer width is {name}\"\n-        }\n-        for family in &target_cfg.families {\n-            condition! {\n-                name: family,\n-                allowed_names: &target_cfgs.all_families,\n-                message: \"when the target family is {name}\"\n-            }\n-        }\n-\n-        // If something is ignored for emscripten, it likely also needs to be\n-        // ignored for wasm32-unknown-unknown.\n-        // `wasm32-bare` is an alias to refer to just wasm32-unknown-unknown\n-        // (in contrast to `wasm32` which also matches non-bare targets like\n-        // asmjs-unknown-emscripten).\n-        condition! {\n-            name: \"emscripten\",\n-            condition: self.target == \"wasm32-unknown-unknown\",\n-            message: \"when the target is WASM\",\n-        }\n-        condition! {\n-            name: \"wasm32-bare\",\n-            condition: self.target == \"wasm32-unknown-unknown\",\n-            message: \"when the target is WASM\"\n-        }\n-\n-        condition! {\n-            name: &self.channel,\n-            allowed_names: hashset![\"stable\", \"beta\", \"nightly\"],\n-            message: \"when the release channel is {name}\",\n-        }\n-        condition! {\n-            name: \"cross-compile\",\n-            condition: self.target != self.host,\n-            message: \"when cross-compiling\"\n-        }\n-        condition! {\n-            name: \"endian-big\",\n-            condition: self.is_big_endian(),\n-            message: \"on big-endian targets\",\n-        }\n-        condition! {\n-            name: self.stage_id.split('-').next().unwrap(),\n-            allowed_names: hashset![\"stable\", \"beta\", \"nightly\"],\n-            message: \"when the bootstrapping stage is {name}\",\n-        }\n-        condition! {\n-            name: \"remote\",\n-            condition: self.remote_test_client.is_some(),\n-            message: \"when running tests remotely\",\n-        }\n-        condition! {\n-            name: \"debug\",\n-            condition: cfg!(debug_assertions),\n-            message: \"when building with debug assertions\",\n-        }\n-        maybe_condition! {\n-            name: self.debugger.as_ref().map(|d| d.to_str()),\n-            allowed_names: Debugger::VARIANTS\n-                .iter()\n-                .map(|v| v.to_str())\n-                .collect::<HashSet<_>>(),\n-            message: \"when the debugger is {name}\",\n-        }\n-        maybe_condition! {\n-            name: self.compare_mode\n-                .as_ref()\n-                .map(|d| format!(\"compare-mode-{}\", d.to_str())),\n-            allowed_names: CompareMode::VARIANTS\n-                .iter()\n-                .map(|cm| format!(\"compare-mode-{}\", cm.to_str()))\n-                .collect::<HashSet<_>>(),\n-            message: \"when comparing with {name}\",\n-        }\n-\n-        // Don't error out for ignore-tidy-* diretives, as those are not handled by compiletest.\n-        if prefix == \"ignore\" && name.starts_with(\"tidy-\") && outcome == MatchOutcome::Invalid {\n-            outcome = MatchOutcome::External;\n-        }\n-\n-        // Don't error out for ignore-pass, as that is handled elsewhere.\n-        if prefix == \"ignore\" && name == \"pass\" && outcome == MatchOutcome::Invalid {\n-            outcome = MatchOutcome::External;\n-        }\n-\n-        ParsedNameDirective {\n-            name: Some(name),\n-            comment: comment.map(|c| c.trim().trim_start_matches('-').trim()),\n-            outcome,\n-            pretty_reason: message,\n-        }\n-    }\n-\n     fn has_cfg_prefix(&self, line: &str, prefix: &str) -> bool {\n         // returns whether this line contains this prefix or not. For prefix\n         // \"ignore\", returns true if line says \"ignore-x86_64\", \"ignore-arch\",\n@@ -1151,7 +926,7 @@ pub fn make_test_description<R: Read>(\n         }\n \n         {\n-            let parsed = config.parse_cfg_name_directive(ln, \"ignore\");\n+            let parsed = parse_cfg_name_directive(config, ln, \"ignore\");\n             ignore = match parsed.outcome {\n                 MatchOutcome::Match => {\n                     let reason = parsed.pretty_reason.unwrap();\n@@ -1171,7 +946,7 @@ pub fn make_test_description<R: Read>(\n         }\n \n         if config.has_cfg_prefix(ln, \"only\") {\n-            let parsed = config.parse_cfg_name_directive(ln, \"only\");\n+            let parsed = parse_cfg_name_directive(config, ln, \"only\");\n             ignore = match parsed.outcome {\n                 MatchOutcome::Match => ignore,\n                 MatchOutcome::NoMatch => {"}, {"sha": "a6812792c277ddd9796aa0c809e3862c166d697b", "filename": "src/tools/compiletest/src/header/cfg.rs", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/9cb4373a8458e38c1ed8b1d8e768e11f305e551f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb4373a8458e38c1ed8b1d8e768e11f305e551f/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs?ref=9cb4373a8458e38c1ed8b1d8e768e11f305e551f", "patch": "@@ -0,0 +1,233 @@\n+use crate::common::{Config, CompareMode, Debugger};\n+use std::collections::HashSet;\n+\n+/// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n+/// or `normalize-stderr-32bit`.\n+pub(super) fn parse_cfg_name_directive<'a>(\n+    config: &Config,\n+    line: &'a str,\n+    prefix: &str,\n+) -> ParsedNameDirective<'a> {\n+    if !line.as_bytes().starts_with(prefix.as_bytes()) {\n+        return ParsedNameDirective::invalid();\n+    }\n+    if line.as_bytes().get(prefix.len()) != Some(&b'-') {\n+        return ParsedNameDirective::invalid();\n+    }\n+    let line = &line[prefix.len() + 1..];\n+\n+    let (name, comment) =\n+        line.split_once(&[':', ' ']).map(|(l, c)| (l, Some(c))).unwrap_or((line, None));\n+\n+    // Some of the matchers might be \"\" depending on what the target information is. To avoid\n+    // problems we outright reject empty directives.\n+    if name == \"\" {\n+        return ParsedNameDirective::invalid();\n+    }\n+\n+    let mut outcome = MatchOutcome::Invalid;\n+    let mut message = None;\n+\n+    macro_rules! maybe_condition {\n+        (\n+            name: $name:expr,\n+            $(allowed_names: $allowed_names:expr,)?\n+            $(condition: $condition:expr,)?\n+            message: $($message:tt)*\n+        ) => {{\n+            // This is not inlined to avoid problems with macro repetitions.\n+            let format_message = || format!($($message)*);\n+\n+            if outcome != MatchOutcome::Invalid {\n+                // Ignore all other matches if we already found one\n+            } else if $name.as_ref().map(|n| n == &name).unwrap_or(false) {\n+                message = Some(format_message());\n+                if true $(&& $condition)? {\n+                    outcome = MatchOutcome::Match;\n+                } else {\n+                    outcome = MatchOutcome::NoMatch;\n+                }\n+            }\n+            $(else if $allowed_names.contains(name) {\n+                message = Some(format_message());\n+                outcome = MatchOutcome::NoMatch;\n+            })?\n+        }};\n+    }\n+    macro_rules! condition {\n+        (\n+            name: $name:expr,\n+            $(allowed_names: $allowed_names:expr,)?\n+            $(condition: $condition:expr,)?\n+            message: $($message:tt)*\n+        ) => {\n+            maybe_condition! {\n+                name: Some($name),\n+                $(allowed_names: $allowed_names,)*\n+                $(condition: $condition,)*\n+                message: $($message)*\n+            }\n+        };\n+    }\n+    macro_rules! hashset {\n+        ($($value:expr),* $(,)?) => {{\n+            let mut set = HashSet::new();\n+            $(set.insert($value);)*\n+            set\n+        }}\n+    }\n+\n+    let target_cfgs = config.target_cfgs();\n+    let target_cfg = config.target_cfg();\n+\n+    condition! {\n+        name: \"test\",\n+        message: \"always\"\n+    }\n+    condition! {\n+        name: &config.target,\n+        allowed_names: &target_cfgs.all_targets,\n+        message: \"when the target is {name}\"\n+    }\n+    condition! {\n+        name: &target_cfg.os,\n+        allowed_names: &target_cfgs.all_oses,\n+        message: \"when the operative system is {name}\"\n+    }\n+    condition! {\n+        name: &target_cfg.env,\n+        allowed_names: &target_cfgs.all_envs,\n+        message: \"when the target environment is {name}\"\n+    }\n+    condition! {\n+        name: &target_cfg.abi,\n+        allowed_names: &target_cfgs.all_abis,\n+        message: \"when the ABI is {name}\"\n+    }\n+    condition! {\n+        name: &target_cfg.arch,\n+        allowed_names: &target_cfgs.all_archs,\n+        message: \"when the architecture is {name}\"\n+    }\n+    condition! {\n+        name: format!(\"{}bit\", target_cfg.pointer_width),\n+        allowed_names: &target_cfgs.all_pointer_widths,\n+        message: \"when the pointer width is {name}\"\n+    }\n+    for family in &target_cfg.families {\n+        condition! {\n+            name: family,\n+            allowed_names: &target_cfgs.all_families,\n+            message: \"when the target family is {name}\"\n+        }\n+    }\n+\n+    // If something is ignored for emscripten, it likely also needs to be\n+    // ignored for wasm32-unknown-unknown.\n+    // `wasm32-bare` is an alias to refer to just wasm32-unknown-unknown\n+    // (in contrast to `wasm32` which also matches non-bare targets like\n+    // asmjs-unknown-emscripten).\n+    condition! {\n+        name: \"emscripten\",\n+        condition: config.target == \"wasm32-unknown-unknown\",\n+        message: \"when the target is WASM\",\n+    }\n+    condition! {\n+        name: \"wasm32-bare\",\n+        condition: config.target == \"wasm32-unknown-unknown\",\n+        message: \"when the target is WASM\"\n+    }\n+\n+    condition! {\n+        name: &config.channel,\n+        allowed_names: hashset![\"stable\", \"beta\", \"nightly\"],\n+        message: \"when the release channel is {name}\",\n+    }\n+    condition! {\n+        name: \"cross-compile\",\n+        condition: config.target != config.host,\n+        message: \"when cross-compiling\"\n+    }\n+    condition! {\n+        name: \"endian-big\",\n+        condition: config.is_big_endian(),\n+        message: \"on big-endian targets\",\n+    }\n+    condition! {\n+        name: config.stage_id.split('-').next().unwrap(),\n+        allowed_names: hashset![\"stable\", \"beta\", \"nightly\"],\n+        message: \"when the bootstrapping stage is {name}\",\n+    }\n+    condition! {\n+        name: \"remote\",\n+        condition: config.remote_test_client.is_some(),\n+        message: \"when running tests remotely\",\n+    }\n+    condition! {\n+        name: \"debug\",\n+        condition: cfg!(debug_assertions),\n+        message: \"when building with debug assertions\",\n+    }\n+    maybe_condition! {\n+        name: config.debugger.as_ref().map(|d| d.to_str()),\n+        allowed_names: Debugger::VARIANTS\n+            .iter()\n+            .map(|v| v.to_str())\n+            .collect::<HashSet<_>>(),\n+        message: \"when the debugger is {name}\",\n+    }\n+    maybe_condition! {\n+        name: config.compare_mode\n+            .as_ref()\n+            .map(|d| format!(\"compare-mode-{}\", d.to_str())),\n+        allowed_names: CompareMode::VARIANTS\n+            .iter()\n+            .map(|cm| format!(\"compare-mode-{}\", cm.to_str()))\n+            .collect::<HashSet<_>>(),\n+        message: \"when comparing with {name}\",\n+    }\n+\n+    // Don't error out for ignore-tidy-* diretives, as those are not handled by compiletest.\n+    if prefix == \"ignore\" && name.starts_with(\"tidy-\") && outcome == MatchOutcome::Invalid {\n+        outcome = MatchOutcome::External;\n+    }\n+\n+    // Don't error out for ignore-pass, as that is handled elsewhere.\n+    if prefix == \"ignore\" && name == \"pass\" && outcome == MatchOutcome::Invalid {\n+        outcome = MatchOutcome::External;\n+    }\n+\n+    ParsedNameDirective {\n+        name: Some(name),\n+        comment: comment.map(|c| c.trim().trim_start_matches('-').trim()),\n+        outcome,\n+        pretty_reason: message,\n+    }\n+}\n+\n+/// The result of parse_cfg_name_directive.\n+#[derive(Clone, PartialEq, Debug)]\n+pub(super) struct ParsedNameDirective<'a> {\n+    pub(super) name: Option<&'a str>,\n+    pub(super) pretty_reason: Option<String>,\n+    pub(super) comment: Option<&'a str>,\n+    pub(super) outcome: MatchOutcome,\n+}\n+\n+impl ParsedNameDirective<'_> {\n+    fn invalid() -> Self {\n+        Self { name: None, pretty_reason: None, comment: None, outcome: MatchOutcome::NoMatch }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub(super) enum MatchOutcome {\n+    /// No match.\n+    NoMatch,\n+    /// Match.\n+    Match,\n+    /// The directive was invalid.\n+    Invalid,\n+    /// The directive is handled by other parts of our tooling.\n+    External,\n+}"}]}