{"sha": "a4ba11189db2773072fbe9e241669a3e9f4b4429", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YmExMTE4OWRiMjc3MzA3MmZiZTllMjQxNjY5YTNlOWY0YjQ0Mjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-25T18:03:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:00:41Z"}, "message": "Extend region guarantor logic to handle autoref, which will\nbe necessary for reborrowing.\n\nr=catamorphism", "tree": {"sha": "5ef73011a690abc0962ea44e78215f5aa1d6eb4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ef73011a690abc0962ea44e78215f5aa1d6eb4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4ba11189db2773072fbe9e241669a3e9f4b4429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ba11189db2773072fbe9e241669a3e9f4b4429", "html_url": "https://github.com/rust-lang/rust/commit/a4ba11189db2773072fbe9e241669a3e9f4b4429", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4ba11189db2773072fbe9e241669a3e9f4b4429/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f14d43206fe63752407820ccc85eebc423c69ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f14d43206fe63752407820ccc85eebc423c69ad", "html_url": "https://github.com/rust-lang/rust/commit/8f14d43206fe63752407820ccc85eebc423c69ad"}], "stats": {"total": 208, "additions": 125, "deletions": 83}, "files": [{"sha": "fe2fd4a6a22a1da9e455178eb4e0afa0458642c3", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 125, "deletions": 83, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a4ba11189db2773072fbe9e241669a3e9f4b4429/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4ba11189db2773072fbe9e241669a3e9f4b4429/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a4ba11189db2773072fbe9e241669a3e9f4b4429", "patch": "@@ -73,10 +73,10 @@ fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n }\n \n impl @rcx {\n-    fn resolve_type(unresolved_ty: ty::t) -> Option<ty::t> {\n+    fn resolve_type(unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n-         * None if an error results.  Note that we never care\n+         * t_err if an error results.  Note that we never care\n          * about the details of the error, the same error will be\n          * detected and reported in the writeback phase.\n          *\n@@ -104,13 +104,13 @@ impl @rcx {\n          */\n         match resolve_type(self.fcx.infcx(), unresolved_ty,\n                            resolve_and_force_all_but_regions) {\n-            Ok(t) => Some(t),\n-            Err(_) => None\n+            Ok(t) => t,\n+            Err(_) => ty::mk_err(self.fcx.tcx())\n         }\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(id: ast::node_id) -> Option<ty::t> {\n+    fn resolve_node_type(id: ast::node_id) -> ty::t {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n }\n@@ -181,6 +181,12 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n+    for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n+        for adjustment.autoref.each |autoref| {\n+            guarantor::for_autoref(rcx, expr, *adjustment, autoref);\n+        }\n+    }\n+\n     match /*bad*/copy expr.node {\n         ast::expr_path(*) => {\n             // Avoid checking the use of local variables, as we\n@@ -250,15 +256,14 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n             // particular case.  There is an extensive comment on the\n             // function check_cast_for_escaping_regions() in kind.rs\n             // explaining how it goes about doing that.\n-            for rcx.resolve_node_type(expr.id).each |target_ty| {\n-                match ty::get(*target_ty).sty {\n-                    ty::ty_trait(_, _, vstore_slice(trait_region)) => {\n-                        let source_ty = rcx.fcx.expr_ty(source);\n-                        constrain_regions_in_type(rcx, trait_region,\n-                                                  expr.span, source_ty);\n-                    }\n-                    _ => ()\n+            let target_ty = rcx.resolve_node_type(expr.id);\n+            match ty::get(target_ty).sty {\n+                ty::ty_trait(_, _, vstore_slice(trait_region)) => {\n+                    let source_ty = rcx.fcx.expr_ty(source);\n+                    constrain_regions_in_type(rcx, trait_region,\n+                                              expr.span, source_ty);\n                 }\n+                _ => ()\n             }\n         }\n \n@@ -271,16 +276,15 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n         }\n \n         ast::expr_fn(*) | ast::expr_fn_block(*) => {\n-            for rcx.resolve_node_type(expr.id).each |function_type| {\n-                match ty::get(*function_type).sty {\n-                    ty::ty_fn(ref fn_ty) => {\n-                        if fn_ty.meta.proto == ast::ProtoBorrowed {\n-                            constrain_free_variables(\n-                                rcx, fn_ty.meta.region, expr);\n-                        }\n+            let function_type = rcx.resolve_node_type(expr.id);\n+            match ty::get(function_type).sty {\n+                ty::ty_fn(ref fn_ty) => {\n+                    if fn_ty.meta.proto == ast::ProtoBorrowed {\n+                        constrain_free_variables(\n+                            rcx, fn_ty.meta.region, expr);\n                     }\n-                    _ => ()\n                 }\n+                _ => ()\n             }\n         }\n \n@@ -409,15 +413,10 @@ fn constrain_regions_in_type_of_node(\n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    let ty = match rcx.resolve_node_type(id) {\n-        None => { return true; }\n-        Some(ty) => { ty }\n-    };\n-\n+    let ty = rcx.resolve_node_type(id);\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty=%s, id=%d, encl_region=%?)\",\n            ty_to_str(tcx, ty), id, encl_region);\n-\n     constrain_regions_in_type(rcx, encl_region, span, ty)\n }\n \n@@ -567,6 +566,30 @@ mod guarantor {\n         }\n     }\n \n+    pub fn for_autoref(rcx: @rcx,\n+                       expr: @ast::expr,\n+                       adjustment: &ty::AutoAdjustment,\n+                       autoref: &ty::AutoRef)\n+    {\n+        /*!\n+         *\n+         * Computes the guarantor for an expression that has an\n+         * autoref adjustment and links it to the lifetime of the\n+         * autoref.  This is only important when auto re-borrowing\n+         * region pointers.\n+         */\n+\n+        debug!(\"guarantor::for_autoref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        let _i = ::util::common::indenter();\n+\n+        let mut expr_ct = categorize_unadjusted(rcx, expr);\n+        expr_ct = apply_autoderefs(\n+            rcx, expr, adjustment.autoderefs, expr_ct);\n+        for expr_ct.cat.guarantor.each |g| {\n+            infallibly_mk_subr(rcx, true, expr.span, autoref.region, *g);\n+        }\n+    }\n+\n     fn link(\n         rcx: @rcx,\n         span: span,\n@@ -589,9 +612,10 @@ mod guarantor {\n         // this routine is used for the result of ref bindings and &\n         // expressions, both of which always yield a region variable, so\n         // mk_subr should never fail.\n-        for rcx.resolve_node_type(id).each |rptr_ty| {\n-            debug!(\"rptr_ty=%s\", ty_to_str(rcx.fcx.ccx.tcx, *rptr_ty));\n-            let r = ty::ty_region(*rptr_ty);\n+        let rptr_ty = rcx.resolve_node_type(id);\n+        if !ty::type_contains_err(rptr_ty) {\n+            debug!(\"rptr_ty=%s\", ty_to_str(rcx.fcx.ccx.tcx, rptr_ty));\n+            let r = ty::ty_region(rptr_ty);\n             infallibly_mk_subr(rcx, true, span, r, bound);\n         }\n     }\n@@ -608,6 +632,11 @@ mod guarantor {\n         pointer: PointerCat\n     }\n \n+    struct ExprCategorizationType {\n+        cat: ExprCategorization,\n+        ty: ty::t\n+    }\n+\n     fn guarantor(rcx: @rcx, expr: @ast::expr) -> Option<ty::Region> {\n         debug!(\"guarantor(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         match expr.node {\n@@ -683,52 +712,76 @@ mod guarantor {\n         debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         let _i = ::util::common::indenter();\n \n-        let tcx = rcx.fcx.ccx.tcx;\n-        if rcx.fcx.ccx.method_map.contains_key(expr.id) {\n-            debug!(\"method call\");\n-            return id_categorization(rcx, None, expr.id);\n-        }\n-\n-        let expr_ty = match rcx.resolve_node_type(expr.id) {\n-            None => { return id_categorization(rcx, None, expr.id); }\n-            Some(t) => { t }\n-        };\n-        let mut cat = ExprCategorization {\n-            guarantor: guarantor(rcx, expr),\n-            pointer: pointer_categorize(expr_ty)\n-        };\n-\n-        debug!(\"before adjustments, cat=%?\", cat);\n+        let mut expr_ct = categorize_unadjusted(rcx, expr);\n+        debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n \n         for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n             debug!(\"adjustment=%?\", adjustment);\n-            for uint::range(0, adjustment.autoderefs) |_| {\n-                cat.guarantor = guarantor_of_deref(&cat);\n \n-                match ty::deref(tcx, expr_ty, true) {\n-                    Some(t) => {\n-                        cat.pointer = pointer_categorize(t.ty);\n-                    }\n-                    None => {\n-                        tcx.sess.span_bug(\n-                            expr.span,\n-                            fmt!(\"Autoderef but type not derefable: %s\",\n-                                 ty_to_str(tcx, expr_ty)));\n-                    }\n-                }\n+            expr_ct = apply_autoderefs(\n+                rcx, expr, adjustment.autoderefs, expr_ct);\n \n-                debug!(\"autoderef, cat=%?\", cat);\n+            for adjustment.autoref.each |autoref| {\n+                expr_ct.cat.guarantor = None;\n+                expr_ct.cat.pointer = BorrowedPointer(autoref.region);\n+                debug!(\"autoref, cat=%?\", expr_ct.cat);\n             }\n+        }\n \n-            for adjustment.autoref.each |autoref| {\n-                cat.guarantor = None;\n-                cat.pointer = BorrowedPointer(autoref.region);\n-                debug!(\"autoref, cat=%?\", cat);\n+        debug!(\"result=%?\", expr_ct.cat);\n+        return expr_ct.cat;\n+    }\n+\n+    fn categorize_unadjusted(rcx: @rcx,\n+                             expr: @ast::expr) -> ExprCategorizationType {\n+        debug!(\"categorize_unadjusted(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        let _i = ::util::common::indenter();\n+\n+        let guarantor = {\n+            if rcx.fcx.ccx.method_map.contains_key(expr.id) {\n+                None\n+            } else {\n+                guarantor(rcx, expr)\n             }\n+        };\n+\n+        let expr_ty = rcx.resolve_node_type(expr.id);\n+        ExprCategorizationType {\n+            cat: ExprCategorization {\n+                guarantor: guarantor,\n+                pointer: pointer_categorize(expr_ty)\n+            },\n+            ty: expr_ty\n         }\n+    }\n \n-        debug!(\"result=%?\", cat);\n-        return cat;\n+    fn apply_autoderefs(\n+        +rcx: @rcx,\n+        +expr: @ast::expr,\n+        +autoderefs: uint,\n+        +ct: ExprCategorizationType) -> ExprCategorizationType\n+    {\n+        let mut ct = ct;\n+        let tcx = rcx.fcx.ccx.tcx;\n+        for uint::range(0, autoderefs) |_| {\n+            ct.cat.guarantor = guarantor_of_deref(&ct.cat);\n+\n+            match ty::deref(tcx, ct.ty, true) {\n+                Some(mt) => {\n+                    ct.ty = mt.ty;\n+                    ct.cat.pointer = pointer_categorize(ct.ty);\n+                }\n+                None => {\n+                    tcx.sess.span_bug(\n+                        expr.span,\n+                        fmt!(\"Autoderef but type not derefable: %s\",\n+                             ty_to_str(tcx, ct.ty)));\n+                }\n+            }\n+\n+            debug!(\"autoderef, cat=%?\", ct.cat);\n+        }\n+        return ct;\n     }\n \n     fn pointer_categorize(ty: ty::t) -> PointerCat {\n@@ -752,19 +805,6 @@ mod guarantor {\n         }\n     }\n \n-    fn id_categorization(rcx: @rcx,\n-                         guarantor: Option<ty::Region>,\n-                         id: ast::node_id) -> ExprCategorization\n-    {\n-        let pointer = match rcx.resolve_node_type(id) {\n-            None => NotPointer,\n-            Some(t) => pointer_categorize(t)\n-        };\n-\n-        ExprCategorization {guarantor: guarantor,\n-                            pointer: pointer}\n-    }\n-\n     fn guarantor_of_deref(cat: &ExprCategorization) -> Option<ty::Region> {\n         match cat.pointer {\n             NotPointer => cat.guarantor,\n@@ -824,16 +864,18 @@ mod guarantor {\n                 link_ref_bindings_in_pat(rcx, p, guarantor)\n             }\n             ast::pat_region(p) => {\n-                for rcx.resolve_node_type(pat.id).each |rptr_ty| {\n-                    let r = ty::ty_region(*rptr_ty);\n+                let rptr_ty = rcx.resolve_node_type(pat.id);\n+                if !ty::type_contains_err(rptr_ty) {\n+                    let r = ty::ty_region(rptr_ty);\n                     link_ref_bindings_in_pat(rcx, p, Some(r));\n                 }\n             }\n             ast::pat_lit(*) => {}\n             ast::pat_range(*) => {}\n             ast::pat_vec(ref ps, ref opt_tail_pat) => {\n-                for rcx.resolve_node_type(pat.id).each |vec_ty| {\n-                    let vstore = ty::ty_vstore(*vec_ty);\n+                let vec_ty = rcx.resolve_node_type(pat.id);\n+                if !ty::type_contains_err(vec_ty) {\n+                    let vstore = ty::ty_vstore(vec_ty);\n                     let guarantor1 = match vstore {\n                         ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n                         ty::vstore_slice(r) => Some(r),"}]}