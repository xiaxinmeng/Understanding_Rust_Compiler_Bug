{"sha": "711f531b655941b163303062562047767967ea84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMWY1MzFiNjU1OTQxYjE2MzMwMzA2MjU2MjA0Nzc2Nzk2N2VhODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-22T03:33:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-22T22:14:23Z"}, "message": "doc: Touch up the unsafe guide\n\n* Change ~ references to Box\n* Rewrite examples so they can be compiled an run\n* Mention libcore\n* Update wording about compiler-required functions", "tree": {"sha": "2d743bafb6ea81f9ebfba50ffe41cd4bcbeb17a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d743bafb6ea81f9ebfba50ffe41cd4bcbeb17a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/711f531b655941b163303062562047767967ea84", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/711f531b655941b163303062562047767967ea84", "html_url": "https://github.com/rust-lang/rust/commit/711f531b655941b163303062562047767967ea84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/711f531b655941b163303062562047767967ea84/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ccc51ce3b746ee702ef875a90b53b1b06fd2bf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ccc51ce3b746ee702ef875a90b53b1b06fd2bf8", "html_url": "https://github.com/rust-lang/rust/commit/1ccc51ce3b746ee702ef875a90b53b1b06fd2bf8"}], "stats": {"total": 196, "additions": 144, "deletions": 52}, "files": [{"sha": "717902e01d5d59ca3198e99a00076a507ee2c8d4", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 144, "deletions": 52, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/711f531b655941b163303062562047767967ea84/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/711f531b655941b163303062562047767967ea84/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=711f531b655941b163303062562047767967ea84", "patch": "@@ -89,11 +89,11 @@ Raw pointers have much fewer guarantees than other pointer types\n offered by the Rust language and libraries. For example, they\n \n - are not guaranteed to point to valid memory and are not even\n-  guaranteed to be non-null (unlike both `~` and `&`);\n-- do not have any automatic clean-up, unlike `~`, and so require\n+  guaranteed to be non-null (unlike both `Box` and `&`);\n+- do not have any automatic clean-up, unlike `Box`, and so require\n   manual resource management;\n - are plain-old-data, that is, they don't move ownership, again unlike\n-  `~`, hence the Rust compiler cannot protect against bugs like\n+  `Box`, hence the Rust compiler cannot protect against bugs like\n   use-after-free;\n - are considered sendable (if their contents is considered sendable),\n   so the compiler offers no assistance with ensuring their use is\n@@ -189,7 +189,7 @@ code:\n \n As an example, we give a reimplementation of owned boxes by wrapping\n `malloc` and `free`. Rust's move semantics and lifetimes mean this\n-reimplementation is as safe as the built-in `~` type.\n+reimplementation is as safe as the `Box` type.\n \n ```\n extern crate libc;\n@@ -198,13 +198,14 @@ use std::mem;\n use std::ptr;\n \n // Define a wrapper around the handle returned by the foreign code.\n-// Unique<T> has the same semantics as ~T\n+// Unique<T> has the same semantics as Box<T>\n pub struct Unique<T> {\n     // It contains a single raw, mutable pointer to the object in question.\n     ptr: *mut T\n }\n \n // Implement methods for creating and using the values in the box.\n+\n // NB: For simplicity and correctness, we require that T has kind Send\n // (owned boxes relax this restriction, and can contain managed (GC) boxes).\n // This is because, as implemented, the garbage collector would not know\n@@ -215,23 +216,26 @@ impl<T: Send> Unique<T> {\n             let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n             // we *need* valid pointer.\n             assert!(!ptr.is_null());\n-            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n-            // `overwrite` moves a value into this memory without\n-            // attempting to drop the original value.\n+            // `*ptr` is uninitialized, and `*ptr = value` would\n+            // attempt to destroy it `overwrite` moves a value into\n+            // this memory without attempting to drop the original\n+            // value.\n             mem::overwrite(&mut *ptr, value);\n             Unique{ptr: ptr}\n         }\n     }\n \n-    // the 'r lifetime results in the same semantics as `&*x` with ~T\n+    // the 'r lifetime results in the same semantics as `&*x` with\n+    // Box<T>\n     pub fn borrow<'r>(&'r self) -> &'r T {\n         // By construction, self.ptr is valid\n         unsafe { &*self.ptr }\n     }\n \n-    // the 'r lifetime results in the same semantics as `&mut *x` with ~T\n+    // the 'r lifetime results in the same semantics as `&mut *x` with\n+    // Box<T>\n     pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n-        unsafe { &mut*self.ptr }\n+        unsafe { &mut *self.ptr }\n     }\n }\n \n@@ -246,7 +250,6 @@ impl<T: Send> Unique<T> {\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {\n         unsafe {\n-\n             // Copy the object out from the pointer onto the stack,\n             // where it is covered by normal Rust destructor semantics\n             // and cleans itself up, if necessary\n@@ -428,11 +431,9 @@ this is undesirable, and can be avoided with the `#![no_std]`\n attribute attached to the crate.\n \n ```ignore\n-# // FIXME #12903: linking failures due to no_std\n-// the minimal library\n+// a minimal library\n #![crate_type=\"lib\"]\n #![no_std]\n-\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -444,20 +445,23 @@ default shim for the C `main` function with your own.\n The function marked `#[start]` is passed the command line parameters\n in the same format as a C:\n \n-```ignore\n-# // FIXME #12903: linking failures due to no_std\n+```\n #![no_std]\n \n-extern \"rust-intrinsic\" { fn abort() -> !; }\n-#[no_mangle] pub extern fn rust_stack_exhausted() {\n-    unsafe { abort() }\n-}\n+// Pull in the system libc library for what crt0.o likely requires\n+extern crate libc;\n \n+// Entry point for this program\n #[start]\n fn start(_argc: int, _argv: **u8) -> int {\n     0\n }\n \n+// These functions are invoked by the compiler, but not\n+// for a bare-bones hello world. These are normally\n+// provided by libstd.\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -467,29 +471,115 @@ correct ABI and the correct name, which requires overriding the\n compiler's name mangling too:\n \n ```ignore\n-# // FIXME #12903: linking failures due to no_std\n #![no_std]\n #![no_main]\n \n-extern \"rust-intrinsic\" { fn abort() -> !; }\n-#[no_mangle] pub extern fn rust_stack_exhausted() {\n-    unsafe { abort() }\n-}\n+extern crate libc;\n \n #[no_mangle] // ensure that this symbol is called `main` in the output\n-extern \"C\" fn main(_argc: int, _argv: **u8) -> int {\n+pub extern fn main(argc: int, argv: **u8) -> int {\n     0\n }\n \n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n # // fn main() {} tricked you, rustdoc!\n ```\n \n \n-Unfortunately the Rust compiler assumes that symbols with certain\n-names exist; and these have to be defined (or linked in). This is the\n-purpose of the `rust_stack_exhausted`: it is called when a function\n-detects that it will overflow its stack. The example above uses the\n-`abort` intrinsic which ensures that execution halts.\n+The compiler currently makes a few assumptions about symbols which are available\n+in the executable to call. Normally these functions are provided by the standard\n+library, but without it you must define your own.\n+\n+The first of these two functions, `stack_exhausted`, is invoked whenever stack\n+overflow is detected.  This function has a number of restrictions about how it\n+can be called and what it must do, but if the stack limit register is not being\n+maintained then a task always has an \"infinite stack\" and this function\n+shouldn't get triggered.\n+\n+The second of these two functions, `eh_personality`, is used by the failure\n+mechanisms of the compiler. This is often mapped to GCC's personality function\n+(see the [libstd implementation](../std/rt/unwind/) for more information), but\n+crates which do not trigger failure can be assured that this function is never\n+called.\n+\n+## Using libcore\n+\n+> **Note**: the core library's structure is unstable, and it is recommended to\n+> use the standard library instead wherever possible.\n+\n+With the above techniques, we've got a bare-metal executable running some Rust\n+code. There is a good deal of functionality provided by the standard library,\n+however, that is necessary to be productive in Rust. If the standard library is\n+not sufficient, then [libcore](../core/) is designed to be used instead.\n+\n+The core library has very few dependencies and is much more portable than the\n+standard library itself. Additionally, the core library has most of the\n+necessary functionality for writing idiomatic and effective Rust code.\n+\n+As an example, here is a program that will calculate the dot product of two\n+vectors provided from C, using idiomatic Rust practices.\n+\n+```\n+#![no_std]\n+\n+# extern crate libc;\n+extern crate core;\n+\n+use core::prelude::*;\n+\n+use core::mem;\n+use core::raw::Slice;\n+\n+#[no_mangle]\n+pub extern fn dot_product(a: *u32, a_len: u32,\n+                          b: *u32, b_len: u32) -> u32 {\n+    // Convert the provided arrays into Rust slices.\n+    // The core::raw module guarantees that the Slice\n+    // structure has the same memory layout as a &[T]\n+    // slice.\n+    //\n+    // This is an unsafe operation because the compiler\n+    // cannot tell the pointers are valid.\n+    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n+        mem::transmute((\n+            Slice { data: a, len: a_len as uint },\n+            Slice { data: b, len: b_len as uint },\n+        ))\n+    };\n+\n+    // Iterate over the slices, collecting the result\n+    let mut ret = 0;\n+    for (i, j) in a_slice.iter().zip(b_slice.iter()) {\n+        ret += (*i) * (*j);\n+    }\n+    return ret;\n+}\n+\n+#[lang = \"begin_unwind\"]\n+extern fn begin_unwind(args: &core::fmt::Arguments,\n+                       file: &str,\n+                       line: uint) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n+# #[start] fn start(argc: int, argv: **u8) -> int { 0 }\n+# fn main() {}\n+```\n+\n+Note that there is one extra lang item here which differs from the examples\n+above, `begin_unwind`. This must be defined by consumers of libcore because the\n+core library declares failure, but it does not define it. The `begin_unwind`\n+lang item is this crate's definition of failure, and it must be guaranteed to\n+never return.\n+\n+As can be seen in this example, the core library is intended to provide the\n+power of Rust in all circumstances, regardless of platform requirements. Further\n+libraries, such as liballoc, add functionality to libcore which make other\n+platform-specific assumptions, but continue to be more portable than the\n+standard library itself.\n \n # Interacting with the compiler internals\n \n@@ -512,6 +602,10 @@ libraries to interact directly with the compiler and vice versa:\n \n ## Intrinsics\n \n+> **Note**: intrinsics will forever have an unstable interface, it is\n+> recommended to use the stable interfaces of libcore rather than intrinsics\n+> directly.\n+\n These are imported as if they were FFI functions, with the special\n `rust-intrinsic` ABI. For example, if one was in a freestanding\n context, but wished to be able to `transmute` between types, and\n@@ -530,36 +624,33 @@ As with any other FFI functions, these are always `unsafe` to call.\n \n ## Lang items\n \n+> **Note**: lang items are often provided by crates in the Rust distribution,\n+> and lang items themselves have an unstable interface. It is recommended to use\n+> officially distributed crates instead of defining your own lang items.\n+\n The `rustc` compiler has certain pluggable operations, that is,\n functionality that isn't hard-coded into the language, but is\n implemented in libraries, with a special marker to tell the compiler\n it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n various different values of `...`, i.e. various different \"lang\n items\".\n \n-For example, `~` pointers require two lang items, one for allocation\n-and one for deallocation. A freestanding program that uses the `~`\n+For example, `Box` pointers require two lang items, one for allocation\n+and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n-```ignore\n-# // FIXME #12903: linking failures due to no_std\n+```\n #![no_std]\n \n-#[allow(ctypes)] // `uint` == `size_t` on Rust's platforms\n-extern {\n-    fn malloc(size: uint) -> *mut u8;\n-    fn free(ptr: *mut u8);\n+extern crate libc;\n \n+extern {\n     fn abort() -> !;\n }\n \n-#[no_mangle] pub extern fn rust_stack_exhausted() {\n-    unsafe { abort() }\n-}\n-\n #[lang=\"exchange_malloc\"]\n-unsafe fn allocate(size: uint) -> *mut u8 {\n-    let p = malloc(size);\n+unsafe fn allocate(size: uint, _align: uint) -> *mut u8 {\n+    let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n     // malloc failed\n     if p as uint == 0 {\n@@ -569,18 +660,19 @@ unsafe fn allocate(size: uint) -> *mut u8 {\n     p\n }\n #[lang=\"exchange_free\"]\n-unsafe fn deallocate(ptr: *mut u8) {\n-    free(ptr)\n+unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+    libc::free(ptr as *mut libc::c_void)\n }\n \n #[start]\n-fn main(_argc: int, _argv: **u8) -> int {\n-    let _x = ~1;\n+fn main(argc: int, argv: **u8) -> int {\n+    let x = box 1;\n \n     0\n }\n \n-# // fn main() {} tricked you, rustdoc!\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n ```\n \n Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n@@ -602,6 +694,6 @@ Other features provided by lang items include:\n   `contravariant_lifetime`, `no_share_bound`, etc.\n \n Lang items are loaded lazily by the compiler; e.g. if one never uses\n-`~` then there is no need to define functions for `exchange_malloc`\n+`Box` then there is no need to define functions for `exchange_malloc`\n and `exchange_free`. `rustc` will emit an error when an item is needed\n but not found in the current crate or any that it depends on."}]}