{"sha": "e4a7b44e554e183fc66474bcbd8f7ace541c5536", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YTdiNDRlNTU0ZTE4M2ZjNjY0NzRiY2JkOGY3YWNlNTQxYzU1MzY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-16T12:10:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-16T12:10:18Z"}, "message": "internal: use mutable trees when filling match arms", "tree": {"sha": "e606c6fe7990c468ce58049b3074aa70542ce906", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e606c6fe7990c468ce58049b3074aa70542ce906"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4a7b44e554e183fc66474bcbd8f7ace541c5536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a7b44e554e183fc66474bcbd8f7ace541c5536", "html_url": "https://github.com/rust-lang/rust/commit/e4a7b44e554e183fc66474bcbd8f7ace541c5536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4a7b44e554e183fc66474bcbd8f7ace541c5536/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e142757e167ac16ce65ba1c743e131aba83cdc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e142757e167ac16ce65ba1c743e131aba83cdc4", "html_url": "https://github.com/rust-lang/rust/commit/4e142757e167ac16ce65ba1c743e131aba83cdc4"}], "stats": {"total": 223, "additions": 89, "deletions": 134}, "files": [{"sha": "f66a9b54bc7f55e77a52cd19f99e6dbc0d77fe23", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4a7b44e554e183fc66474bcbd8f7ace541c5536/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a7b44e554e183fc66474bcbd8f7ace541c5536/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=e4a7b44e554e183fc66474bcbd8f7ace541c5536", "patch": "@@ -71,6 +71,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             .filter_map(|variant| build_pat(ctx.db(), module, variant))\n             .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n+            .map(|it| it.clone_for_update())\n             .collect::<Vec<_>>();\n         if Some(enum_def)\n             == FamousDefs(&ctx.sema, Some(module.krate()))\n@@ -99,6 +100,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             })\n             .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n+            .map(|it| it.clone_for_update())\n             .collect()\n     } else {\n         return None;\n@@ -114,10 +116,20 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         \"Fill match arms\",\n         target,\n         |builder| {\n-            let new_arm_list = match_arm_list.remove_placeholder();\n-            let n_old_arms = new_arm_list.arms().count();\n-            let new_arm_list = new_arm_list.append_arms(missing_arms);\n-            let first_new_arm = new_arm_list.arms().nth(n_old_arms);\n+            let new_match_arm_list = match_arm_list.clone_for_update();\n+\n+            let catch_all_arm = new_match_arm_list\n+                .arms()\n+                .find(|arm| matches!(arm.pat(), Some(ast::Pat::WildcardPat(_))));\n+            if let Some(arm) = catch_all_arm {\n+                arm.remove()\n+            }\n+            let mut first_new_arm = None;\n+            for arm in missing_arms {\n+                first_new_arm.get_or_insert_with(|| arm.clone());\n+                new_match_arm_list.add_arm(arm);\n+            }\n+\n             let old_range = ctx.sema.original_range(match_arm_list.syntax()).range;\n             match (first_new_arm, ctx.config.snippet_cap) {\n                 (Some(first_new_arm), Some(cap)) => {\n@@ -131,10 +143,10 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n                             }\n                             None => Cursor::Before(first_new_arm.syntax()),\n                         };\n-                    let snippet = render_snippet(cap, new_arm_list.syntax(), cursor);\n+                    let snippet = render_snippet(cap, new_match_arm_list.syntax(), cursor);\n                     builder.replace_snippet(cap, old_range, snippet);\n                 }\n-                _ => builder.replace(old_range, new_arm_list.to_string()),\n+                _ => builder.replace(old_range, new_match_arm_list.to_string()),\n             }\n         },\n     )\n@@ -919,8 +931,8 @@ fn main() {\n                 match a {\n                     // foo bar baz\n                     A::One => {}\n-                    // This is where the rest should be\n                     $0A::Two => {}\n+                    // This is where the rest should be\n                 }\n             }\n             \"#,\n@@ -943,9 +955,9 @@ fn main() {\n             enum A { One, Two }\n             fn foo(a: A) {\n                 match a {\n-                    // foo bar baz\n                     $0A::One => {}\n                     A::Two => {}\n+                    // foo bar baz\n                 }\n             }\n             \"#,"}, {"sha": "5e6c1d44e8c7e9b969adae71340248050895d16c", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e4a7b44e554e183fc66474bcbd8f7ace541c5536/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a7b44e554e183fc66474bcbd8f7ace541c5536/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=e4a7b44e554e183fc66474bcbd8f7ace541c5536", "patch": "@@ -29,38 +29,6 @@ impl ast::BinExpr {\n     }\n }\n \n-fn make_multiline<N>(node: N) -> N\n-where\n-    N: AstNode + Clone,\n-{\n-    let l_curly = match node.syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n-        Some(it) => it,\n-        None => return node,\n-    };\n-    let sibling = match l_curly.next_sibling_or_token() {\n-        Some(it) => it,\n-        None => return node,\n-    };\n-    let existing_ws = match sibling.as_token() {\n-        None => None,\n-        Some(tok) if tok.kind() != WHITESPACE => None,\n-        Some(ws) => {\n-            if ws.text().contains('\\n') {\n-                return node;\n-            }\n-            Some(ws.clone())\n-        }\n-    };\n-\n-    let indent = leading_indent(node.syntax()).unwrap_or_default();\n-    let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-    let to_insert = iter::once(ws.ws().into());\n-    match existing_ws {\n-        None => node.insert_children(InsertPosition::After(l_curly), to_insert),\n-        Some(ws) => node.replace_children(single_node(ws), to_insert),\n-    }\n-}\n-\n impl ast::RecordExprFieldList {\n     #[must_use]\n     pub fn append_field(&self, field: &ast::RecordExprField) -> ast::RecordExprFieldList {\n@@ -214,79 +182,6 @@ impl ast::UseTree {\n     }\n }\n \n-impl ast::MatchArmList {\n-    #[must_use]\n-    pub fn append_arms(&self, items: impl IntoIterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-        let mut res = self.clone();\n-        res = res.strip_if_only_whitespace();\n-        if !res.syntax().text().contains_char('\\n') {\n-            res = make_multiline(res);\n-        }\n-        items.into_iter().for_each(|it| res = res.append_arm(it));\n-        res\n-    }\n-\n-    fn strip_if_only_whitespace(&self) -> ast::MatchArmList {\n-        let mut iter = self.syntax().children_with_tokens().skip_while(|it| it.kind() != T!['{']);\n-        iter.next(); // Eat the curly\n-        let mut inner = iter.take_while(|it| it.kind() != T!['}']);\n-        if !inner.clone().all(|it| it.kind() == WHITESPACE) {\n-            return self.clone();\n-        }\n-        let start = match inner.next() {\n-            Some(s) => s,\n-            None => return self.clone(),\n-        };\n-        let end = match inner.last() {\n-            Some(s) => s,\n-            None => start.clone(),\n-        };\n-        self.replace_children(start..=end, &mut iter::empty())\n-    }\n-\n-    #[must_use]\n-    pub fn remove_placeholder(&self) -> ast::MatchArmList {\n-        let placeholder =\n-            self.arms().find(|arm| matches!(arm.pat(), Some(ast::Pat::WildcardPat(_))));\n-        if let Some(placeholder) = placeholder {\n-            self.remove_arm(&placeholder)\n-        } else {\n-            self.clone()\n-        }\n-    }\n-\n-    #[must_use]\n-    fn remove_arm(&self, arm: &ast::MatchArm) -> ast::MatchArmList {\n-        let start = arm.syntax().clone();\n-        let end = if let Some(comma) = start\n-            .siblings_with_tokens(Direction::Next)\n-            .skip(1)\n-            .find(|it| !it.kind().is_trivia())\n-            .filter(|it| it.kind() == T![,])\n-        {\n-            comma\n-        } else {\n-            start.clone().into()\n-        };\n-        self.replace_children(start.into()..=end, None)\n-    }\n-\n-    #[must_use]\n-    pub fn append_arm(&self, item: ast::MatchArm) -> ast::MatchArmList {\n-        let r_curly = match self.syntax().children_with_tokens().find(|it| it.kind() == T!['}']) {\n-            Some(t) => t,\n-            None => return self.clone(),\n-        };\n-        let position = InsertPosition::Before(r_curly);\n-        let arm_ws = tokens::WsBuilder::new(\"    \");\n-        let match_indent = &leading_indent(self.syntax()).unwrap_or_default();\n-        let match_ws = tokens::WsBuilder::new(&format!(\"\\n{}\", match_indent));\n-        let to_insert: ArrayVec<SyntaxElement, 3> =\n-            [arm_ws.ws().into(), item.syntax().clone().into(), match_ws.ws().into()].into();\n-        self.insert_children(position, to_insert)\n-    }\n-}\n-\n #[must_use]\n pub fn remove_attrs_and_docs<N: ast::AttrsOwner>(node: &N) -> N {\n     N::cast(remove_attrs_and_docs_inner(node.syntax().clone())).unwrap()"}, {"sha": "abab0269a027531f1dc58159b41c1c8cd08c6a7c", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e4a7b44e554e183fc66474bcbd8f7ace541c5536/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a7b44e554e183fc66474bcbd8f7ace541c5536/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=e4a7b44e554e183fc66474bcbd8f7ace541c5536", "patch": "@@ -13,7 +13,7 @@ use crate::{\n         make, GenericParamsOwner,\n     },\n     ted::{self, Position},\n-    AstNode, AstToken, Direction,\n+    AstNode, AstToken, Direction, SyntaxNode,\n };\n \n use super::NameOwner;\n@@ -297,7 +297,7 @@ impl ast::AssocItemList {\n             ),\n             None => match self.l_curly_token() {\n                 Some(l_curly) => {\n-                    self.normalize_ws_between_braces();\n+                    normalize_ws_between_braces(self.syntax());\n                     (IndentLevel::from_token(&l_curly) + 1, Position::after(&l_curly), \"\\n\")\n                 }\n                 None => (IndentLevel::single(), Position::last_child_of(self.syntax()), \"\\n\"),\n@@ -309,25 +309,6 @@ impl ast::AssocItemList {\n         ];\n         ted::insert_all(position, elements);\n     }\n-\n-    fn normalize_ws_between_braces(&self) -> Option<()> {\n-        let l = self.l_curly_token()?;\n-        let r = self.r_curly_token()?;\n-        let indent = IndentLevel::from_node(self.syntax());\n-\n-        match l.next_sibling_or_token() {\n-            Some(ws) if ws.kind() == SyntaxKind::WHITESPACE => {\n-                if ws.next_sibling_or_token()?.into_token()? == r {\n-                    ted::replace(ws, make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n-                }\n-            }\n-            Some(ws) if ws.kind() == T!['}'] => {\n-                ted::insert(Position::after(l), make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n-            }\n-            _ => (),\n-        }\n-        Some(())\n-    }\n }\n \n impl ast::Fn {\n@@ -346,6 +327,73 @@ impl ast::Fn {\n     }\n }\n \n+impl ast::MatchArm {\n+    pub fn remove(&self) {\n+        if let Some(sibling) = self.syntax().prev_sibling_or_token() {\n+            if sibling.kind() == SyntaxKind::WHITESPACE {\n+                ted::remove(sibling);\n+            }\n+        }\n+        if let Some(sibling) = self.syntax().next_sibling_or_token() {\n+            if sibling.kind() == T![,] {\n+                ted::remove(sibling);\n+            }\n+        }\n+        ted::remove(self.syntax());\n+    }\n+}\n+\n+impl ast::MatchArmList {\n+    pub fn add_arm(&self, arm: ast::MatchArm) {\n+        normalize_ws_between_braces(self.syntax());\n+        let position = match self.arms().last() {\n+            Some(last_arm) => {\n+                let curly = last_arm\n+                    .syntax()\n+                    .siblings_with_tokens(Direction::Next)\n+                    .find(|it| it.kind() == T![,]);\n+                Position::after(curly.unwrap_or_else(|| last_arm.syntax().clone().into()))\n+            }\n+            None => match self.l_curly_token() {\n+                Some(it) => Position::after(it),\n+                None => Position::last_child_of(self.syntax()),\n+            },\n+        };\n+        let indent = IndentLevel::from_node(self.syntax()) + 1;\n+        let elements = vec![\n+            make::tokens::whitespace(&format!(\"\\n{}\", indent)).into(),\n+            arm.syntax().clone().into(),\n+        ];\n+        ted::insert_all(position, elements);\n+    }\n+}\n+\n+fn normalize_ws_between_braces(node: &SyntaxNode) -> Option<()> {\n+    let l = node\n+        .children_with_tokens()\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == T!['{'])?;\n+    let r = node\n+        .children_with_tokens()\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == T!['}'])?;\n+\n+    let indent = IndentLevel::from_node(node);\n+\n+    match l.next_sibling_or_token() {\n+        Some(ws) if ws.kind() == SyntaxKind::WHITESPACE => {\n+            if ws.next_sibling_or_token()?.into_token()? == r {\n+                ted::replace(ws, make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+            }\n+        }\n+        Some(ws) if ws.kind() == T!['}'] => {\n+            ted::insert(Position::after(l), make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+        }\n+        _ => (),\n+    }\n+    Some(())\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::fmt;"}]}