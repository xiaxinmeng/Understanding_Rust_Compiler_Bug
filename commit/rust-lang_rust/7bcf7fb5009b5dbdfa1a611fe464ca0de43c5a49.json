{"sha": "7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiY2Y3ZmI1MDA5YjVkYmRmYTFhNjExZmU0NjRjYTBkZTQzYzVhNDk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-03-04T10:32:33Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-03-05T11:50:09Z"}, "message": "Use more associated types in core::iter.\n\nThis concretely improves type inference of some cases (see included\ntest). I assume the compiler struggles to reason about multiple layers\nof generic type parameters (even with associated-type equalities) but\n*can* understand pure associated types, since they are always directly\ncomputable from the input types.", "tree": {"sha": "711b07486654bb072babdefa9d093f6a9c6f4bbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/711b07486654bb072babdefa9d093f6a9c6f4bbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49", "html_url": "https://github.com/rust-lang/rust/commit/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fed12499e7d91f9cdfba5833e34d20e8fd19b898", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed12499e7d91f9cdfba5833e34d20e8fd19b898", "html_url": "https://github.com/rust-lang/rust/commit/fed12499e7d91f9cdfba5833e34d20e8fd19b898"}], "stats": {"total": 119, "additions": 73, "deletions": 46}, "files": [{"sha": "07203ad7d194ab09f97b3792d856fc5876cabd4f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49", "patch": "@@ -1279,14 +1279,14 @@ pub struct Cloned<I> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, D, I> Iterator for Cloned<I> where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: Iterator<Item=D>,\n+impl<I> Iterator for Cloned<I> where\n+    I: Iterator,\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Clone\n {\n-    type Item = T;\n+    type Item = <I::Item as Deref>::Target;\n \n-    fn next(&mut self) -> Option<T> {\n+    fn next(&mut self) -> Option<<Self as Iterator>::Item> {\n         self.it.next().cloned()\n     }\n \n@@ -1296,36 +1296,36 @@ impl<T, D, I> Iterator for Cloned<I> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: DoubleEndedIterator<Item=D>,\n+impl<I> DoubleEndedIterator for Cloned<I> where\n+    I: DoubleEndedIterator,\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Clone\n {\n-    fn next_back(&mut self) -> Option<T> {\n+    fn next_back(&mut self) -> Option<<Self as Iterator>::Item> {\n         self.it.next_back().cloned()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, D, I> ExactSizeIterator for Cloned<I> where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: ExactSizeIterator<Item=D>,\n+impl<I> ExactSizeIterator for Cloned<I> where\n+    I: ExactSizeIterator,\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Clone\n {}\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<T, D, I> RandomAccessIterator for Cloned<I> where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: RandomAccessIterator<Item=D>\n+impl<I> RandomAccessIterator for Cloned<I> where\n+    I: RandomAccessIterator,\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Clone\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n         self.it.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: usize) -> Option<T> {\n+    fn idx(&mut self, index: usize) -> Option<<Self as Iterator>::Item> {\n         self.it.idx(index).cloned()\n     }\n }\n@@ -1400,11 +1400,14 @@ pub struct Chain<A, B> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n-    type Item = T;\n+impl<A, B> Iterator for Chain<A, B> where\n+    A: Iterator,\n+    B: Iterator<Item = A::Item>\n+{\n+    type Item = A::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> {\n+    fn next(&mut self) -> Option<A::Item> {\n         if self.flag {\n             self.b.next()\n         } else {\n@@ -1434,12 +1437,12 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n-    A: DoubleEndedIterator<Item=T>,\n-    B: DoubleEndedIterator<Item=T>,\n+impl<A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator,\n+    B: DoubleEndedIterator<Item=A::Item>,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n+    fn next_back(&mut self) -> Option<A::Item> {\n         match self.b.next_back() {\n             Some(x) => Some(x),\n             None => self.a.next_back()\n@@ -1448,9 +1451,9 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n-    A: RandomAccessIterator<Item=T>,\n-    B: RandomAccessIterator<Item=T>,\n+impl<A, B> RandomAccessIterator for Chain<A, B> where\n+    A: RandomAccessIterator,\n+    B: RandomAccessIterator<Item = A::Item>,\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1459,7 +1462,7 @@ impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: usize) -> Option<T> {\n+    fn idx(&mut self, index: usize) -> Option<A::Item> {\n         let len = self.a.indexable();\n         if index < len {\n             self.a.idx(index)\n@@ -1479,14 +1482,12 @@ pub struct Zip<A, B> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, U, A, B> Iterator for Zip<A, B> where\n-    A: Iterator<Item = T>,\n-    B: Iterator<Item = U>,\n+impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n {\n-    type Item = (T, U);\n+    type Item = (A::Item, B::Item);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(T, U)> {\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n         match self.a.next() {\n             None => None,\n             Some(x) => match self.b.next() {\n@@ -1515,12 +1516,12 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: DoubleEndedIterator + ExactSizeIterator<Item=T>,\n-    B: DoubleEndedIterator + ExactSizeIterator<Item=U>,\n+impl<A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: DoubleEndedIterator + ExactSizeIterator,\n+    B: DoubleEndedIterator + ExactSizeIterator,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(T, U)> {\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n         let a_sz = self.a.len();\n         let b_sz = self.b.len();\n         if a_sz != b_sz {\n@@ -1540,17 +1541,17 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n-    A: RandomAccessIterator<Item=T>,\n-    B: RandomAccessIterator<Item=U>,\n+impl<A, B> RandomAccessIterator for Zip<A, B> where\n+    A: RandomAccessIterator,\n+    B: RandomAccessIterator\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n         cmp::min(self.a.indexable(), self.b.indexable())\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: usize) -> Option<(T, U)> {\n+    fn idx(&mut self, index: usize) -> Option<(A::Item, B::Item)> {\n         match self.a.idx(index) {\n             None => None,\n             Some(x) => match self.b.idx(index) {\n@@ -2071,8 +2072,9 @@ pub struct Scan<I, St, F> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I: Iterator<Item=A>, St, F> Iterator for Scan<I, St, F> where\n-    F: FnMut(&mut St, A) -> Option<B>,\n+impl<B, I, St, F> Iterator for Scan<I, St, F> where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n {\n     type Item = B;\n "}, {"sha": "6ce226bbecac294a53f6d980981006f158f2b7f6", "filename": "src/test/run-pass/iter-cloned-type-inference.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49/src%2Ftest%2Frun-pass%2Fiter-cloned-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49/src%2Ftest%2Frun-pass%2Fiter-cloned-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-cloned-type-inference.rs?ref=7bcf7fb5009b5dbdfa1a611fe464ca0de43c5a49", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test to see that the element type of .cloned() can be inferred\n+// properly. Previously this would fail to deduce the type of `sum`.\n+\n+#![feature(core)]\n+\n+use std::iter::AdditiveIterator;\n+\n+fn square_sum(v: &[i64]) -> i64 {\n+    let sum = v.iter().cloned().sum();\n+    sum * sum\n+}\n+\n+fn main() {\n+    assert_eq!(36, square_sum(&[1,2,3]));\n+}"}]}