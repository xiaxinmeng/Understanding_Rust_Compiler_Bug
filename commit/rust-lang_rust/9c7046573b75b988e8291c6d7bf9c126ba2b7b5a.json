{"sha": "9c7046573b75b988e8291c6d7bf9c126ba2b7b5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNzA0NjU3M2I3NWI5ODhlODI5MWM2ZDdiZjljMTI2YmEyYjdiNWE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-05T04:47:40Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:45Z"}, "message": "libcore: use unboxed closures in the fields of `Splits`", "tree": {"sha": "817d182d761c7c4715cee35ac68030d291ea17d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/817d182d761c7c4715cee35ac68030d291ea17d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c7046573b75b988e8291c6d7bf9c126ba2b7b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c7046573b75b988e8291c6d7bf9c126ba2b7b5a", "html_url": "https://github.com/rust-lang/rust/commit/9c7046573b75b988e8291c6d7bf9c126ba2b7b5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c7046573b75b988e8291c6d7bf9c126ba2b7b5a/comments", "author": null, "committer": null, "parents": [{"sha": "30ea64ea77dd33d0af9271b032644120b4f5166a", "url": "https://api.github.com/repos/rust-lang/rust/commits/30ea64ea77dd33d0af9271b032644120b4f5166a", "html_url": "https://github.com/rust-lang/rust/commit/30ea64ea77dd33d0af9271b032644120b4f5166a"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "3dad5458b365b948d36fbdd9db23cb96e296cca1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c7046573b75b988e8291c6d7bf9c126ba2b7b5a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7046573b75b988e8291c6d7bf9c126ba2b7b5a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9c7046573b75b988e8291c6d7bf9c126ba2b7b5a", "patch": "@@ -43,7 +43,7 @@ use default::Default;\n use iter::*;\n use kinds::Copy;\n use num::Int;\n-use ops;\n+use ops::{FnMut, mod};\n use option::Option;\n use option::Option::{None, Some};\n use ptr;\n@@ -105,20 +105,23 @@ pub trait SlicePrelude<T> for Sized? {\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn rsplitn<'a>(&'a self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -470,7 +473,7 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where P: FnMut(&T) -> bool {\n         Splits {\n             v: self,\n             pred: pred,\n@@ -479,7 +482,9 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool,\n+    {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -488,7 +493,9 @@ impl<T> SlicePrelude<T> for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n+        P: FnMut(&T) -> bool,\n+    {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -1271,14 +1278,14 @@ trait SplitsIter<E>: DoubleEndedIterator<E> {\n /// An iterator over subslices separated by elements that match a predicate\n /// function.\n #[experimental = \"needs review\"]\n-pub struct Splits<'a, T:'a> {\n+pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     v: &'a [T],\n-    pred: |t: &T|: 'a -> bool,\n+    pred: P,\n     finished: bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n+impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -1304,7 +1311,7 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n+impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -1320,7 +1327,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     }\n }\n \n-impl<'a, T> SplitsIter<&'a [T]> for Splits<'a, T> {\n+impl<'a, T, P> SplitsIter<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }"}]}