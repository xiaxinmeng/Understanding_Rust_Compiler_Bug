{"sha": "7d39b13996e312a8a738ed0dfccab45978fc42f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMzliMTM5OTZlMzEyYThhNzM4ZWQwZGZjY2FiNDU5NzhmYzQyZjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-06T13:43:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-06T13:43:37Z"}, "message": "Merge #8364\n\n8364: Memory usage improvements r=jonas-schievink a=alexmaco\n\nThese are mostly focused on splitting up enum variants with large size differences between variants by `Box`-ing things up.\r\n\r\nIn my testing this reduces the memory usage somewhere in the low percentages, even though the measurements are quite noisy.\n\nCo-authored-by: Alexandru Macovei <alexnmaco@gmail.com>", "tree": {"sha": "91761b9bf78d9015fbb6083b9245eb9f6133e234", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91761b9bf78d9015fbb6083b9245eb9f6133e234"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d39b13996e312a8a738ed0dfccab45978fc42f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbGWJCRBK7hj4Ov3rIwAAdHIIAJZcnZpgdudZOEO9Hf6Evf7w\n36bhmDdFtlpDfUrPkIIjRJLUAjiryUR4X2GvffCqcmV2UJcMHga4z0Cj3S2GHSGU\nPVYWwL8gFtiNmNlHkp3CuZPidIokm8cCvN8PuMOkwKp4OcAdAlh/ImXRdaBiGyVw\ncBnvZmWUvpFYpCXBCHnk8vezZRl5YnlkhVrSv4c3weI9xWmj3B78KZ5YG1RjV6b7\nK99oRGapppSKzm6vRves10IhZam80Ywy7szrRKxZliKp6lRSoM7GiZtdB3E8/xq3\ndOrWBxsAAsj+Wb58GvaEWjZvcaZXQlEc1tQz6BMBwy3LOIYYfmQQhwvnxVNbx5U=\n=oEAd\n-----END PGP SIGNATURE-----\n", "payload": "tree 91761b9bf78d9015fbb6083b9245eb9f6133e234\nparent 12e86433ab57ee8b1c96b8da0480fd311752487b\nparent 4e2a6ac7eae3ff193962421cc3c86e5d8f9a7e31\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617716617 +0000\ncommitter GitHub <noreply@github.com> 1617716617 +0000\n\nMerge #8364\n\n8364: Memory usage improvements r=jonas-schievink a=alexmaco\n\nThese are mostly focused on splitting up enum variants with large size differences between variants by `Box`-ing things up.\r\n\r\nIn my testing this reduces the memory usage somewhere in the low percentages, even though the measurements are quite noisy.\n\nCo-authored-by: Alexandru Macovei <alexnmaco@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d39b13996e312a8a738ed0dfccab45978fc42f8", "html_url": "https://github.com/rust-lang/rust/commit/7d39b13996e312a8a738ed0dfccab45978fc42f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d39b13996e312a8a738ed0dfccab45978fc42f8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12e86433ab57ee8b1c96b8da0480fd311752487b", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e86433ab57ee8b1c96b8da0480fd311752487b", "html_url": "https://github.com/rust-lang/rust/commit/12e86433ab57ee8b1c96b8da0480fd311752487b"}, {"sha": "4e2a6ac7eae3ff193962421cc3c86e5d8f9a7e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2a6ac7eae3ff193962421cc3c86e5d8f9a7e31", "html_url": "https://github.com/rust-lang/rust/commit/4e2a6ac7eae3ff193962421cc3c86e5d8f9a7e31"}], "stats": {"total": 87, "additions": 54, "deletions": 33}, "files": [{"sha": "ca0311595102cb9fdde3a36974648c73fad2f9b7", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -1867,6 +1867,7 @@ name = \"vfs\"\n version = \"0.0.0\"\n dependencies = [\n  \"fst\",\n+ \"indexmap\",\n  \"paths\",\n  \"rustc-hash\",\n ]"}, {"sha": "1e743e5d5a39434cd23aeb4e147c923d3ce7d677", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -322,8 +322,10 @@ impl ExprCollector<'_> {\n                     Vec::new()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let generic_args =\n-                    e.generic_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n+                let generic_args = e\n+                    .generic_arg_list()\n+                    .and_then(|it| GenericArgs::from_ast(&self.ctx(), it))\n+                    .map(Box::new);\n                 self.alloc_expr(\n                     Expr::MethodCall { receiver, method_name, args, generic_args },\n                     syntax_ptr,\n@@ -385,7 +387,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordExpr(e) => {\n-                let path = e.path().and_then(|path| self.expander.parse_path(path));\n+                let path = e.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n                 let record_lit = if let Some(nfl) = e.record_expr_field_list() {\n                     let fields = nfl\n                         .fields()\n@@ -430,7 +432,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.ty());\n+                let type_ref = Box::new(TypeRef::from_ast_opt(&self.ctx(), e.ty()));\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n@@ -469,8 +471,10 @@ impl ExprCollector<'_> {\n                         arg_types.push(type_ref);\n                     }\n                 }\n-                let ret_type =\n-                    e.ret_type().and_then(|r| r.ty()).map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                let ret_type = e\n+                    .ret_type()\n+                    .and_then(|r| r.ty())\n+                    .map(|it| Box::new(TypeRef::from_ast(&self.ctx(), it)));\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n@@ -755,7 +759,7 @@ impl ExprCollector<'_> {\n                 }\n             }\n             ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(|path| self.expander.parse_path(path));\n+                let path = p.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n                 let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n@@ -765,7 +769,7 @@ impl ExprCollector<'_> {\n                 Pat::Ref { pat, mutability }\n             }\n             ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(|path| self.expander.parse_path(path));\n+                let path = p.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n@@ -779,7 +783,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(|path| self.expander.parse_path(path));\n+                let path = p.path().and_then(|path| self.expander.parse_path(path)).map(Box::new);\n                 let args: Vec<_> = p\n                     .record_pat_field_list()\n                     .expect(\"every struct should have a field list\")"}, {"sha": "62a28bdba7fdf5860570040da011b65611995dff", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -86,7 +86,7 @@ pub enum Expr {\n         receiver: ExprId,\n         method_name: Name,\n         args: Vec<ExprId>,\n-        generic_args: Option<GenericArgs>,\n+        generic_args: Option<Box<GenericArgs>>,\n     },\n     Match {\n         expr: ExprId,\n@@ -106,7 +106,7 @@ pub enum Expr {\n         expr: Option<ExprId>,\n     },\n     RecordLit {\n-        path: Option<Path>,\n+        path: Option<Box<Path>>,\n         fields: Vec<RecordLitField>,\n         spread: Option<ExprId>,\n     },\n@@ -131,7 +131,7 @@ pub enum Expr {\n     },\n     Cast {\n         expr: ExprId,\n-        type_ref: TypeRef,\n+        type_ref: Box<TypeRef>,\n     },\n     Ref {\n         expr: ExprId,\n@@ -162,7 +162,7 @@ pub enum Expr {\n     Lambda {\n         args: Vec<PatId>,\n         arg_types: Vec<Option<TypeRef>>,\n-        ret_type: Option<TypeRef>,\n+        ret_type: Option<Box<TypeRef>>,\n         body: ExprId,\n     },\n     Tuple {\n@@ -412,13 +412,13 @@ pub enum Pat {\n     Wild,\n     Tuple { args: Vec<PatId>, ellipsis: Option<usize> },\n     Or(Vec<PatId>),\n-    Record { path: Option<Path>, args: Vec<RecordFieldPat>, ellipsis: bool },\n+    Record { path: Option<Box<Path>>, args: Vec<RecordFieldPat>, ellipsis: bool },\n     Range { start: ExprId, end: ExprId },\n     Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n-    Path(Path),\n+    Path(Box<Path>),\n     Lit(ExprId),\n     Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n-    TupleStruct { path: Option<Path>, args: Vec<PatId>, ellipsis: Option<usize> },\n+    TupleStruct { path: Option<Box<Path>>, args: Vec<PatId>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n     Box { inner: PatId },\n     ConstBlock(ExprId),"}, {"sha": "b528ff8bad74a62bafeab1b186203b67bbdb3db7", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -289,6 +289,12 @@ impl From<Name> for Path {\n     }\n }\n \n+impl From<Name> for Box<Path> {\n+    fn from(name: Name) -> Box<Path> {\n+        Box::new(Path::from(name))\n+    }\n+}\n+\n impl From<Name> for ModPath {\n     fn from(name: Name) -> ModPath {\n         ModPath::from_segments(PathKind::Plain, iter::once(name))"}, {"sha": "5b3cdab4e6d21c033493255e6244bfe04d654ab0", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -318,7 +318,13 @@ impl<'a> InferenceContext<'a> {\n                 self.normalize_associated_types_in(ret_ty)\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n-                .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n+                .infer_method_call(\n+                    tgt_expr,\n+                    *receiver,\n+                    &args,\n+                    &method_name,\n+                    generic_args.as_deref(),\n+                ),\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n@@ -399,7 +405,7 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Never.intern(&Interner)\n             }\n             Expr::RecordLit { path, fields, spread } => {\n-                let (ty, def_id) = self.resolve_variant(path.as_ref());\n+                let (ty, def_id) = self.resolve_variant(path.as_deref());\n                 if let Some(variant) = def_id {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n                 }"}, {"sha": "12431ae0747c4917beffc457f5e159d73e6c5cf6", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -174,15 +174,15 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Ref(mutability, static_lifetime(), subty).intern(&Interner)\n             }\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n-                p.as_ref(),\n+                p.as_deref(),\n                 subpats,\n                 expected,\n                 default_bm,\n                 pat,\n                 *ellipsis,\n             ),\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {\n-                self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)\n+                self.infer_record_pat(p.as_deref(), fields, expected, default_bm, pat)\n             }\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression"}, {"sha": "894944b18dd6a135dcad7adcc0ccb88ceb9826cb", "filename": "crates/vfs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2FCargo.toml?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -14,3 +14,4 @@ rustc-hash = \"1.0\"\n fst = \"0.4\"\n \n paths = { path = \"../paths\", version = \"0.0.0\" }\n+indexmap = \"1.6.2\""}, {"sha": "6e049f0d40f73bf266c7b0de53d622e268a43288", "filename": "crates/vfs/src/path_interner.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d39b13996e312a8a738ed0dfccab45978fc42f8/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fpath_interner.rs?ref=7d39b13996e312a8a738ed0dfccab45978fc42f8", "patch": "@@ -1,37 +1,40 @@\n //! Maps paths to compact integer ids. We don't care about clearings paths which\n //! no longer exist -- the assumption is total size of paths we ever look at is\n //! not too big.\n-use rustc_hash::FxHashMap;\n+use std::hash::BuildHasherDefault;\n+\n+use indexmap::IndexSet;\n+use rustc_hash::FxHasher;\n \n use crate::{FileId, VfsPath};\n \n /// Structure to map between [`VfsPath`] and [`FileId`].\n-#[derive(Default)]\n pub(crate) struct PathInterner {\n-    map: FxHashMap<VfsPath, FileId>,\n-    vec: Vec<VfsPath>,\n+    map: IndexSet<VfsPath, BuildHasherDefault<FxHasher>>,\n+}\n+\n+impl Default for PathInterner {\n+    fn default() -> Self {\n+        Self { map: IndexSet::default() }\n+    }\n }\n \n impl PathInterner {\n     /// Get the id corresponding to `path`.\n     ///\n     /// If `path` does not exists in `self`, returns [`None`].\n     pub(crate) fn get(&self, path: &VfsPath) -> Option<FileId> {\n-        self.map.get(path).copied()\n+        self.map.get_index_of(path).map(|i| FileId(i as u32))\n     }\n \n     /// Insert `path` in `self`.\n     ///\n     /// - If `path` already exists in `self`, returns its associated id;\n     /// - Else, returns a newly allocated id.\n     pub(crate) fn intern(&mut self, path: VfsPath) -> FileId {\n-        if let Some(id) = self.get(&path) {\n-            return id;\n-        }\n-        let id = FileId(self.vec.len() as u32);\n-        self.map.insert(path.clone(), id);\n-        self.vec.push(path);\n-        id\n+        let (id, _added) = self.map.insert_full(path);\n+        assert!(id < u32::MAX as usize);\n+        FileId(id as u32)\n     }\n \n     /// Returns the path corresponding to `id`.\n@@ -40,6 +43,6 @@ impl PathInterner {\n     ///\n     /// Panics if `id` does not exists in `self`.\n     pub(crate) fn lookup(&self, id: FileId) -> &VfsPath {\n-        &self.vec[id.0 as usize]\n+        self.map.get_index(id.0 as usize).unwrap()\n     }\n }"}]}