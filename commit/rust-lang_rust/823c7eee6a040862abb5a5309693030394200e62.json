{"sha": "823c7eee6a040862abb5a5309693030394200e62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyM2M3ZWVlNmEwNDA4NjJhYmI1YTUzMDk2OTMwMzAzOTQyMDBlNjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-22T06:25:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-23T17:03:43Z"}, "message": "Fix other bugs with new closure borrowing\n\nThis fixes various issues throughout the standard distribution and tests.", "tree": {"sha": "348049a75e563b2fe9e9478dea3927578accbb9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/348049a75e563b2fe9e9478dea3927578accbb9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/823c7eee6a040862abb5a5309693030394200e62", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/823c7eee6a040862abb5a5309693030394200e62", "html_url": "https://github.com/rust-lang/rust/commit/823c7eee6a040862abb5a5309693030394200e62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/823c7eee6a040862abb5a5309693030394200e62/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4ecbe93401a56181baaffc4ff7e275aeecc5182", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ecbe93401a56181baaffc4ff7e275aeecc5182", "html_url": "https://github.com/rust-lang/rust/commit/b4ecbe93401a56181baaffc4ff7e275aeecc5182"}], "stats": {"total": 247, "additions": 147, "deletions": 100}, "files": [{"sha": "77c94d0150862fbe17a4a4e13bf0f2adee9e014d", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -672,7 +672,7 @@ impl ToStrRadix for BigUint {\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n             }\n-            s.as_slice().trim_left_chars(&'0').to_owned()\n+            s.as_slice().trim_left_chars('0').to_owned()\n         }\n     }\n }"}, {"sha": "c975a5a780901390a88f39827fe1102d98d25d5e", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -47,7 +47,7 @@ pub fn strip_items(krate: ast::Crate,\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)\n+fn filter_view_item<'r>(cx: &mut Context, view_item: &'r ast::ViewItem)\n                         -> Option<&'r ast::ViewItem> {\n     if view_item_in_cfg(cx, view_item) {\n         Some(view_item)\n@@ -72,7 +72,7 @@ fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n     }\n }\n \n-fn filter_foreign_item(cx: &Context, item: @ast::ForeignItem)\n+fn filter_foreign_item(cx: &mut Context, item: @ast::ForeignItem)\n                        -> Option<@ast::ForeignItem> {\n     if foreign_item_in_cfg(cx, item) {\n         Some(item)\n@@ -144,7 +144,7 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n+fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> @ast::StructDef {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n         (cx.in_cfg)(m.node.attrs.as_slice())\n     });\n@@ -156,7 +156,7 @@ fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n     }\n }\n \n-fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n+fn retain_stmt(cx: &mut Context, stmt: @ast::Stmt) -> bool {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n@@ -189,23 +189,23 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     })\n }\n \n-fn item_in_cfg(cx: &Context, item: &ast::Item) -> bool {\n+fn item_in_cfg(cx: &mut Context, item: &ast::Item) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn foreign_item_in_cfg(cx: &Context, item: &ast::ForeignItem) -> bool {\n+fn foreign_item_in_cfg(cx: &mut Context, item: &ast::ForeignItem) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg(cx: &Context, item: &ast::ViewItem) -> bool {\n+fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn method_in_cfg(cx: &Context, meth: &ast::Method) -> bool {\n+fn method_in_cfg(cx: &mut Context, meth: &ast::Method) -> bool {\n     return (cx.in_cfg)(meth.attrs.as_slice());\n }\n \n-fn trait_method_in_cfg(cx: &Context, meth: &ast::TraitMethod) -> bool {\n+fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitMethod) -> bool {\n     match *meth {\n         ast::Required(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n         ast::Provided(meth) => (cx.in_cfg)(meth.attrs.as_slice())"}, {"sha": "7875973d4674def86b860c0ea998ebef2a7c78f4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -84,7 +84,7 @@ pub struct EncodeContext<'a> {\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n-    pub encode_inlined_item: EncodeInlinedItem<'a>,\n+    pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n     pub type_abbrevs: tyencode::abbrev_map,\n }\n \n@@ -765,8 +765,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         if num_params > 0u ||\n                 is_default_impl ||\n                 should_inline(ast_method.attrs.as_slice()) {\n-            (ecx.encode_inlined_item)(\n-                ecx, ebml_w, IIMethodRef(local_def(parent_id), false, ast_method));\n+            encode_inlined_item(ecx, ebml_w,\n+                                IIMethodRef(local_def(parent_id), false, ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -775,6 +775,14 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n+fn encode_inlined_item(ecx: &EncodeContext,\n+                       ebml_w: &mut Encoder,\n+                       ii: InlinedItemRef) {\n+    let mut eii = ecx.encode_inlined_item.borrow_mut();\n+    let eii: &mut EncodeInlinedItem = &mut *eii;\n+    (*eii)(ecx, ebml_w, ii)\n+}\n+\n fn style_fn_family(s: FnStyle) -> char {\n     match s {\n         UnsafeFn => 'u',\n@@ -870,7 +878,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n \n         if inlineable {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n         }\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n@@ -886,7 +894,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(ebml_w, path);\n         encode_attributes(ebml_w, item.attrs.as_slice());\n         if tps_len > 0u || should_inline(item.attrs.as_slice()) {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n@@ -944,7 +952,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n         encode_path(ebml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n@@ -992,7 +1000,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         needs to know*/\n         encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n \n-        (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, ebml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1162,8 +1170,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         encode_bounds_and_type(ebml_w, ecx, &tpt);\n                     }\n                     encode_method_sort(ebml_w, 'p');\n-                    (ecx.encode_inlined_item)(\n-                        ecx, ebml_w, IIMethodRef(def_id, true, m));\n+                    encode_inlined_item(ecx, ebml_w,\n+                                        IIMethodRef(def_id, true, m));\n                 }\n             }\n \n@@ -1199,7 +1207,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ebml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, IIForeignRef(nitem));\n+            encode_inlined_item(ecx, ebml_w, IIForeignRef(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n@@ -1531,12 +1539,12 @@ fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     }\n }\n \n-struct MacroDefVisitor<'a, 'b> {\n-    ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut Encoder<'b>\n+struct MacroDefVisitor<'a, 'b, 'c> {\n+    ecx: &'a EncodeContext<'b>,\n+    ebml_w: &'a mut Encoder<'c>\n }\n \n-impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n+impl<'a, 'b, 'c> Visitor<()> for MacroDefVisitor<'a, 'b, 'c> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemMac(..) => {\n@@ -1552,9 +1560,9 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n     }\n }\n \n-fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &Crate,\n-                     ebml_w: &mut Encoder) {\n+fn encode_macro_defs<'a>(ecx: &'a EncodeContext,\n+                         krate: &Crate,\n+                         ebml_w: &'a mut Encoder) {\n     ebml_w.start_tag(tag_exported_macros);\n     {\n         let mut visitor = MacroDefVisitor {\n@@ -1566,12 +1574,12 @@ fn encode_macro_defs(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-struct ImplVisitor<'a,'b> {\n-    ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut Encoder<'b>,\n+struct ImplVisitor<'a,'b,'c> {\n+    ecx: &'a EncodeContext<'b>,\n+    ebml_w: &'a mut Encoder<'c>,\n }\n \n-impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n+impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n@@ -1604,9 +1612,9 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n /// * Destructors (implementations of the Drop trait).\n ///\n /// * Implementations of traits not defined in this crate.\n-fn encode_impls(ecx: &EncodeContext,\n-                krate: &Crate,\n-                ebml_w: &mut Encoder) {\n+fn encode_impls<'a>(ecx: &'a EncodeContext,\n+                    krate: &Crate,\n+                    ebml_w: &'a mut Encoder) {\n     ebml_w.start_tag(tag_impls);\n \n     {\n@@ -1731,7 +1739,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n-        encode_inlined_item: encode_inlined_item,\n+        encode_inlined_item: RefCell::new(encode_inlined_item),\n         type_abbrevs: RefCell::new(HashMap::new()),\n      };\n "}, {"sha": "5e0b249ce3f23606bafd85c2b24d6376106b8193", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -92,9 +92,9 @@ impl<'a> FileSearch<'a> {\n             match fs::readdir(lib_search_path) {\n                 Ok(files) => {\n                     let mut rslt = FileDoesntMatch;\n-                    let is_rlib = |p: & &Path| {\n+                    fn is_rlib(p: & &Path) -> bool {\n                         p.extension_str() == Some(\"rlib\")\n-                    };\n+                    }\n                     // Reading metadata out of rlibs is faster, and if we find both\n                     // an rlib and a dylib we only read one of the files of\n                     // metadata, so in the name of speed, bring all rlib files to"}, {"sha": "05a225d8953fce281575459cf42eb0ea1b48ef17", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -1164,7 +1164,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n     fn is_camel_case(ident: ast::Ident) -> bool {\n         let ident = token::get_ident(ident);\n         assert!(!ident.get().is_empty());\n-        let ident = ident.get().trim_chars(&'_');\n+        let ident = ident.get().trim_chars('_');\n \n         // start with a non-lowercase letter rather than non-uppercase\n         // ones (some scripts don't have a concept of upper/lowercase)"}, {"sha": "599c73d7295a37e2e36cef0c6b42f228b3c9b468", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -1104,34 +1104,34 @@ impl<'a> SanePrivacyVisitor<'a> {\n     /// control over anything so this forbids any mention of any visibility\n     fn check_all_inherited(&self, item: &ast::Item) {\n         let tcx = self.tcx;\n-        let check_inherited = |sp: Span, vis: ast::Visibility| {\n+        fn check_inherited(tcx: &ty::ctxt, sp: Span, vis: ast::Visibility) {\n             if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n-        };\n+        }\n         let check_struct = |def: &@ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n-                    ast::NamedField(_, p) => check_inherited(f.span, p),\n+                    ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n                     ast::UnnamedField(..) => {}\n                 }\n             }\n         };\n-        check_inherited(item.span, item.vis);\n+        check_inherited(tcx, item.span, item.vis);\n         match item.node {\n             ast::ItemImpl(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n-                    check_inherited(m.span, m.vis);\n+                    check_inherited(tcx, m.span, m.vis);\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n                 for i in fm.items.iter() {\n-                    check_inherited(i.span, i.vis);\n+                    check_inherited(tcx, i.span, i.vis);\n                 }\n             }\n             ast::ItemEnum(ref def, _) => {\n                 for v in def.variants.iter() {\n-                    check_inherited(v.span, v.node.vis);\n+                    check_inherited(tcx, v.span, v.node.vis);\n \n                     match v.node.kind {\n                         ast::StructVariantKind(ref s) => check_struct(s),\n@@ -1146,7 +1146,8 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Required(..) => {}\n-                        ast::Provided(ref m) => check_inherited(m.span, m.vis),\n+                        ast::Provided(ref m) => check_inherited(tcx, m.span,\n+                                                                m.vis),\n                     }\n                 }\n             }"}, {"sha": "7621a7ec4cd5efdc948a9d9e20438225a1f7429b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -107,9 +107,9 @@ impl<'a> Parser<'a> {\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &[|&mut Parser| -> Option<T>])\n+    fn read_or<T>(&mut self, parsers: &mut [|&mut Parser| -> Option<T>])\n                -> Option<T> {\n-        for pf in parsers.iter() {\n+        for pf in parsers.mut_iter() {\n             match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n                 Some(r) => return Some(r),\n                 None => {}\n@@ -305,7 +305,7 @@ impl<'a> Parser<'a> {\n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n         let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr();\n         let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr();\n-        self.read_or([ipv4_addr, ipv6_addr])\n+        self.read_or(&mut [ipv4_addr, ipv6_addr])\n     }\n \n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n@@ -318,7 +318,7 @@ impl<'a> Parser<'a> {\n                 p.read_seq_3::<char, IpAddr, char>(open_br, ip_addr, clos_br)\n                         .map(|t| match t { (_, ip, _) => ip })\n             };\n-            p.read_or([ipv4_p, ipv6_p])\n+            p.read_or(&mut [ipv4_p, ipv6_p])\n         };\n         let colon = |p: &mut Parser| p.read_given_char(':');\n         let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);"}, {"sha": "d895331752f882a1422d38368b1e1c29b35c8796", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -1241,7 +1241,7 @@ pub struct Map<'a, A, B, T> {\n \n impl<'a, A, B, T> Map<'a, A, B, T> {\n     #[inline]\n-    fn do_map(&self, elt: Option<A>) -> Option<B> {\n+    fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n         match elt {\n             Some(a) => Some((self.f)(a)),\n             _ => None\n@@ -1824,7 +1824,7 @@ pub struct Inspect<'a, A, T> {\n \n impl<'a, A, T> Inspect<'a, A, T> {\n     #[inline]\n-    fn do_inspect(&self, elt: Option<A>) -> Option<A> {\n+    fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n         match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n@@ -2910,7 +2910,7 @@ mod tests {\n         let xs = [1, 2, 3, 4, 5];\n \n         // test .map and .inspect that don't implement Clone\n-        let it = xs.iter().inspect(|_| {});\n+        let mut it = xs.iter().inspect(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n@@ -2922,7 +2922,7 @@ mod tests {\n     fn test_random_access_map() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        let it = xs.iter().map(|x| *x);\n+        let mut it = xs.iter().map(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(*elt), it.idx(i));"}, {"sha": "efbb1abacfaa9d8e60dde7b32689816a3620d56a", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -873,9 +873,9 @@ mod tests {\n         assert_eq!(v, None);\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Some(()), || None, || fail!()];\n+        let mut functions = [|| Some(()), || None, || fail!()];\n \n-        let v: Option<~[()]> = collect(functions.iter().map(|f| (*f)()));\n+        let v: Option<~[()]> = collect(functions.mut_iter().map(|f| (*f)()));\n \n         assert_eq!(v, None);\n     }"}, {"sha": "058548eb151a26a83093cce67f87ec28983d00e2", "filename": "src/libstd/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -695,9 +695,9 @@ mod tests {\n         assert_eq!(v, Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail!()];\n+        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        let v: Result<~[()], int> = collect(functions.iter().map(|f| (*f)()));\n+        let v: Result<~[()], int> = collect(functions.mut_iter().map(|f| (*f)()));\n         assert_eq!(v, Err(1));\n     }\n \n@@ -715,9 +715,9 @@ mod tests {\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail!()];\n+        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        assert_eq!(fold_(functions.iter()\n+        assert_eq!(fold_(functions.mut_iter()\n                         .map(|f| (*f)())),\n                    Err(1));\n     }"}, {"sha": "f9f919edaaabde6eaf8b346c2bea78d2e9e03cda", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -212,8 +212,7 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n             return Some(self.v);\n         }\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n                 Some(self.v)\n@@ -2132,7 +2131,8 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n-        match self.v.iter().position(|x| (self.pred)(x)) {\n+        let pred = &mut self.pred;\n+        match self.v.iter().position(|x| (*pred)(x)) {\n             None => {\n                 self.finished = true;\n                 let tmp = mem::replace(&mut self.v, &mut []);\n@@ -2167,7 +2167,8 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n             None => {\n                 self.finished = true;\n                 let tmp = mem::replace(&mut self.v, &mut []);\n@@ -3340,7 +3341,7 @@ mod tests {\n         assert_eq!(v.chunks(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n \n         assert_eq!(v.chunks(2).rev().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n-        let it = v.chunks(2);\n+        let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         assert_eq!(it.idx(0).unwrap(), &[1,2]);\n         assert_eq!(it.idx(1).unwrap(), &[3,4]);"}, {"sha": "3d00c0ac74a6cabf340499cd2daf9440505573e2", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -145,7 +145,7 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let closure: || -> int = || 10;\n+    let mut closure: || -> int = || 10;\n     let i = closure.finally(|| { });\n     assert_eq!(i, 10);\n }\n@@ -154,6 +154,6 @@ fn test_retval() {\n fn test_compact() {\n     fn do_some_fallible_work() {}\n     fn but_always_run_this_function() { }\n-    do_some_fallible_work.finally(\n-        but_always_run_this_function);\n+    let mut f = do_some_fallible_work;\n+    f.finally(but_always_run_this_function);\n }"}, {"sha": "e0b493cd8d9c0d4371e84dd50cca9223dfcb8258", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -34,7 +34,9 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_clone(\"Clone\", c, s, sub)\n+                combine_substructure: combine_substructure(|c, s, sub| {\n+                    cs_clone(\"Clone\", c, s, sub)\n+                }),\n             }\n         )\n     };"}, {"sha": "35b7e7c1a666e772cb9f249b107579a8911eabca", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -40,7 +40,9 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: true,\n-                combine_substructure: $f\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    $f(a, b, c)\n+                })\n             }\n         }\n     );"}, {"sha": "afe2d3dae6a71e63a0b4c3cee718e2bec920dea9", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -30,7 +30,9 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |cx, span, substr| cs_op($op, $equal, cx, span, substr)\n+                combine_substructure: combine_substructure(|cx, span, substr| {\n+                    cs_op($op, $equal, cx, span, substr)\n+                })\n             }\n         }\n     );"}, {"sha": "d161f9668505fcccd0d0df6563d91492f06492fa", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -48,7 +48,9 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: true,\n-                combine_substructure: cs_total_eq_assert\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    cs_total_eq_assert(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "69c413890e902fa3cf449ab3132d7d6d024fffeb", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -37,7 +37,9 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: cs_cmp\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    cs_cmp(a, b, c)\n+                }),\n             }\n         )\n     };"}, {"sha": "9dc52442d29450aab56846d500d7b3811d3c04c2", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -51,7 +51,9 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                           vec!(~Self, ~Literal(Path::new_local(\"__E\"))), true)),\n                 inline: false,\n                 const_nonmatching: true,\n-                combine_substructure: decodable_substructure,\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    decodable_substructure(a, b, c)\n+                }),\n             })\n     };\n "}, {"sha": "633674eff5c18438e010c723dca5d10803a1c83a", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -34,7 +34,9 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: default_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    default_substructure(a, b, c)\n+                })\n             })\n     };\n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "0691b39f354ece5caf88a3b7fc63bb47d1d1c34d", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -122,7 +122,9 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                            true)),\n                 inline: false,\n                 const_nonmatching: true,\n-                combine_substructure: encodable_substructure,\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    encodable_substructure(a, b, c)\n+                }),\n             })\n     };\n "}, {"sha": "449525d9032609b0c3fd9d64b19992bab6b31f32", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -177,6 +177,8 @@ StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span\n \n */\n \n+use std::cell::RefCell;\n+\n use ast;\n use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n@@ -234,7 +236,7 @@ pub struct MethodDef<'a> {\n     /// actual enum variants, i.e. can use _ => .. match.\n     pub const_nonmatching: bool,\n \n-    pub combine_substructure: CombineSubstructureFunc<'a>,\n+    pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n /// All the data about the data structure/method being derived upon.\n@@ -317,6 +319,11 @@ pub type EnumNonMatchFunc<'a> =\n            &[@Expr]|: 'a\n            -> @Expr;\n \n+pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n+    -> RefCell<CombineSubstructureFunc<'a>> {\n+    RefCell::new(f)\n+}\n+\n \n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n@@ -505,8 +512,9 @@ impl<'a> MethodDef<'a> {\n             nonself_args: nonself_args,\n             fields: fields\n         };\n-        (self.combine_substructure)(cx, trait_.span,\n-                                    &substructure)\n+        let mut f = self.combine_substructure.borrow_mut();\n+        let f: &mut CombineSubstructureFunc = &mut *f;\n+        (*f)(cx, trait_.span, &substructure)\n     }\n \n     fn get_ret_ty(&self,"}, {"sha": "587c48ef487485908c4c243a4b084125828aab2b", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -48,7 +48,9 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: hash_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    hash_substructure(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "e42a3c67e34ea7201dd86aa0dd917acf80ab49b1", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -41,7 +41,9 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 // liable to cause code-bloat\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_from(\"i64\", c, s, sub),\n+                combine_substructure: combine_substructure(|c, s, sub| {\n+                    cs_from(\"i64\", c, s, sub)\n+                }),\n             },\n             MethodDef {\n                 name: \"from_u64\",\n@@ -56,7 +58,9 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 // liable to cause code-bloat\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_from(\"u64\", c, s, sub),\n+                combine_substructure: combine_substructure(|c, s, sub| {\n+                    cs_from(\"u64\", c, s, sub)\n+                }),\n             })\n     };\n "}, {"sha": "83ceef0a39c81c7da8c6e46f81d8c6f2b968e84a", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -42,7 +42,9 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: false,\n                 const_nonmatching: false,\n-                combine_substructure: rand_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    rand_substructure(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "7098d0dd6efea4218051b6f8e678d938288eb3d9", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -44,7 +44,9 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"fmt\", \"Result\"))),\n                 inline: false,\n                 const_nonmatching: false,\n-                combine_substructure: show_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    show_substructure(a, b, c)\n+                })\n             }\n         )\n     };"}, {"sha": "0aeeabcaeabb0d25a96dd49ecfe2cdd559b0a3b8", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -34,7 +34,9 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 ret_ty: Self,\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: zero_substructure\n+                combine_substructure: combine_substructure(|a, b, c| {\n+                    zero_substructure(a, b, c)\n+                })\n             },\n             MethodDef {\n                 name: \"is_zero\",\n@@ -44,13 +46,13 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 inline: true,\n                 const_nonmatching: false,\n-                combine_substructure: |cx, span, substr| {\n+                combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_and(|cx, span, _, _| cx.span_bug(span,\n                                                         \"Non-matching enum \\\n                                                          variant in \\\n                                                          deriving(Zero)\"),\n                            cx, span, substr)\n-                }\n+                })\n             }\n         )\n     };"}, {"sha": "6556d0a51f84e356f30ad0c5848dcaad72fdd296", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -16,7 +16,7 @@ struct R<'a> {\n     // This struct is needed to create the\n     // otherwise infinite type of a fn that\n     // accepts itself as argument:\n-    c: |&R, bool|: 'a\n+    c: |&mut R, bool|: 'a\n }\n \n fn innocent_looking_victim() {\n@@ -28,6 +28,7 @@ fn innocent_looking_victim() {\n             match x {\n                 Some(ref msg) => {\n                     (f.c)(f, true);\n+                    //~^ ERROR: cannot borrow `*f` as mutable because\n                     println!(\"{:?}\", msg);\n                 },\n                 None => fail!(\"oops\"),\n@@ -36,9 +37,9 @@ fn innocent_looking_victim() {\n     })\n }\n \n-fn conspirator(f: |&R, bool|) {\n-    let r = R {c: f};\n-    f(&r, false) //~ ERROR use of moved value\n+fn conspirator(f: |&mut R, bool|) {\n+    let mut r = R {c: f};\n+    f(&mut r, false) //~ ERROR use of moved value\n }\n \n fn main() { innocent_looking_victim() }"}, {"sha": "202354b1326dd4879983949022a84391496ecefb", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -18,13 +18,13 @@\n fn f() { }\n static bare_fns: &'static [fn()] = &[f, f];\n struct S<'a>(||:'a);\n-static mut closures: &'static [S<'static>] = &[S(f), S(f)];\n+static mut closures: &'static mut [S<'static>] = &mut [S(f), S(f)];\n \n pub fn main() {\n     unsafe {\n         for &bare_fn in bare_fns.iter() { bare_fn() }\n-        for closure in closures.iter() {\n-            let S(ref closure) = *closure;\n+        for closure in closures.mut_iter() {\n+            let S(ref mut closure) = *closure;\n             (*closure)()\n         }\n     }"}, {"sha": "4144c8227dcd76aff637c38dbb8facadb9bec559", "filename": "src/test/run-pass/issue-6157.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/823c7eee6a040862abb5a5309693030394200e62/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c7eee6a040862abb5a5309693030394200e62/src%2Ftest%2Frun-pass%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6157.rs?ref=823c7eee6a040862abb5a5309693030394200e62", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait OpInt<'a> { fn call<'a>(&'a self, int, int) -> int; }\n+pub trait OpInt<'a> { fn call<'a>(&'a mut self, int, int) -> int; }\n \n impl<'a> OpInt<'a> for |int, int|: 'a -> int {\n-    fn call(&self, a:int, b:int) -> int {\n+    fn call(&mut self, a:int, b:int) -> int {\n         (*self)(a, b)\n     }\n }\n \n-fn squarei<'a>(x: int, op: &'a OpInt) -> int { op.call(x, x) }\n+fn squarei<'a>(x: int, op: &'a mut OpInt) -> int { op.call(x, x) }\n \n fn muli(x:int, y:int) -> int { x * y }\n \n pub fn main() {\n-    let f = |x,y| muli(x,y);\n+    let mut f = |x,y| muli(x,y);\n     {\n-        let g = &f;\n-        let h = g as &OpInt;\n+        let g = &mut f;\n+        let h = g as &mut OpInt;\n         squarei(3, h);\n     }\n }"}]}