{"sha": "be72564a643758afcc1de152ead2359d489149c0", "node_id": "C_kwDOAAsO6NoAKGJlNzI1NjRhNjQzNzU4YWZjYzFkZTE1MmVhZDIzNTlkNDg5MTQ5YzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-08T13:57:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-08T13:57:45Z"}, "message": "Auto merge of #2055 - RalfJung:rustup, r=RalfJung\n\nRustup\n\nFixes https://github.com/rust-lang/miri/issues/1717", "tree": {"sha": "71d89d23ad17995bc18d402d57f9eec4a454c83a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71d89d23ad17995bc18d402d57f9eec4a454c83a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be72564a643758afcc1de152ead2359d489149c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be72564a643758afcc1de152ead2359d489149c0", "html_url": "https://github.com/rust-lang/rust/commit/be72564a643758afcc1de152ead2359d489149c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be72564a643758afcc1de152ead2359d489149c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3a98563dfb5ed7978f5426b260365af0e6df169", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a98563dfb5ed7978f5426b260365af0e6df169", "html_url": "https://github.com/rust-lang/rust/commit/f3a98563dfb5ed7978f5426b260365af0e6df169"}, {"sha": "3a59a15af718339675273b397b822ef1e3f4290b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a59a15af718339675273b397b822ef1e3f4290b", "html_url": "https://github.com/rust-lang/rust/commit/3a59a15af718339675273b397b822ef1e3f4290b"}], "stats": {"total": 151, "additions": 101, "deletions": 50}, "files": [{"sha": "1f717dbd6ed54a2ed16f84c7ab868cfa048f3f01", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be72564a643758afcc1de152ead2359d489149c0/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/be72564a643758afcc1de152ead2359d489149c0/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=be72564a643758afcc1de152ead2359d489149c0", "patch": "@@ -1 +1 @@\n-bbe9d27b8ff36da56638aa43d6d0cdfdf89a4e57\n+1a4b9a85634c17a60e8802307510c300a35a4b9b"}, {"sha": "9e0cb69f28d80ef8eaa2b752e18075aecaf1ef22", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be72564a643758afcc1de152ead2359d489149c0/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72564a643758afcc1de152ead2359d489149c0/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=be72564a643758afcc1de152ead2359d489149c0", "patch": "@@ -605,6 +605,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_read(\n+        _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n         alloc_extra: &AllocExtra,\n         tag: Tag,\n@@ -627,6 +628,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_written(\n+        _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         tag: Tag,\n@@ -649,6 +651,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_deallocated(\n+        _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         tag: Tag,"}, {"sha": "ac9e085b5d7c927b9ff34f6ab028054faa86f840", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/be72564a643758afcc1de152ead2359d489149c0/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72564a643758afcc1de152ead2359d489149c0/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=be72564a643758afcc1de152ead2359d489149c0", "patch": "@@ -1,17 +1,24 @@\n use rustc_middle::mir;\n+use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n+use log::trace;\n+\n+use crate::helpers::check_arg_count;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n-pub enum Dlsym {}\n+pub enum Dlsym {\n+    NtWriteFile,\n+}\n \n impl Dlsym {\n     // Returns an error for unsupported symbols, and None if this symbol\n     // should become a NULL pointer (pretend it does not exist).\n     pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n+            \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -23,15 +30,82 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         abi: Abi,\n-        _args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Tag>],\n         ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");\n+        let (dest, ret) = ret.expect(\"we don't support any diverging dlsym\");\n         assert!(this.tcx.sess.target.os == \"windows\");\n \n         this.check_abi(abi, Abi::System { unwind: false })?;\n \n-        match dlsym {}\n+        match dlsym {\n+            Dlsym::NtWriteFile => {\n+                if !this.frame_in_std() {\n+                    throw_unsup_format!(\n+                        \"NtWriteFile support is crude and just enough for stdout to work\"\n+                    );\n+                }\n+\n+                let &[\n+                    ref handle,\n+                    ref _event,\n+                    ref _apc_routine,\n+                    ref _apc_context,\n+                    ref io_status_block,\n+                    ref buf,\n+                    ref n,\n+                    ref byte_offset,\n+                    ref _key,\n+                ] = check_arg_count(args)?;\n+                let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n+                let buf = this.read_pointer(buf)?;\n+                let n = this.read_scalar(n)?.to_u32()?;\n+                let byte_offset = this.read_scalar(byte_offset)?.to_machine_usize(this)?; // is actually a pointer\n+                let io_status_block = this.deref_operand(io_status_block)?;\n+\n+                if byte_offset != 0 {\n+                    throw_unsup_format!(\n+                        \"NtWriteFile ByteOffset paremeter is non-null, which is unsupported\"\n+                    );\n+                }\n+\n+                let written = if handle == -11 || handle == -12 {\n+                    // stdout/stderr\n+                    use std::io::{self, Write};\n+\n+                    let buf_cont = this.read_bytes_ptr(buf, Size::from_bytes(u64::from(n)))?;\n+                    let res = if handle == -11 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    res.ok().map(|n| n as u32)\n+                } else {\n+                    throw_unsup_format!(\n+                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n+                    )\n+                };\n+                // We have to put the result into io_status_block.\n+                if let Some(n) = written {\n+                    let io_status_information =\n+                        this.mplace_field_named(&io_status_block, \"Information\")?;\n+                    this.write_scalar(\n+                        Scalar::from_machine_usize(n.into(), this),\n+                        &io_status_information.into(),\n+                    )?;\n+                }\n+                // Return whether this was a success. >= 0 is success.\n+                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n+                this.write_scalar(\n+                    Scalar::from_i32(if written.is_some() { 0 } else { 0xC0000185u32 as i32 }),\n+                    dest,\n+                )?;\n+            }\n+        }\n+\n+        trace!(\"{:?}\", this.dump_place(**dest));\n+        this.go_to_block(ret);\n+        Ok(())\n     }\n }"}, {"sha": "d72302794318e08e66100c9e0d7a11478be0ce4e", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/be72564a643758afcc1de152ead2359d489149c0/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72564a643758afcc1de152ead2359d489149c0/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=be72564a643758afcc1de152ead2359d489149c0", "patch": "@@ -23,6 +23,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Windows API stubs.\n         // HANDLE = isize\n+        // NTSTATUS = LONH = i32\n         // DWORD = ULONG = u32\n         // BOOL = i32\n         // BOOLEAN = u8\n@@ -64,49 +65,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n-            // File related shims\n-            \"GetStdHandle\" => {\n-                let &[ref which] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                let which = this.read_scalar(which)?.to_i32()?;\n-                // We just make this the identity function, so we know later in `WriteFile`\n-                // which one it is.\n-                this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n-            }\n-            \"WriteFile\" => {\n-                let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n-                let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n-                let buf = this.read_pointer(buf)?;\n-                let n = this.read_scalar(n)?.to_u32()?;\n-                let written_place = this.deref_operand(written_ptr)?;\n-                // Spec says to always write `0` first.\n-                this.write_null(&written_place.into())?;\n-                let written = if handle == -11 || handle == -12 {\n-                    // stdout/stderr\n-                    use std::io::{self, Write};\n-\n-                    let buf_cont = this.read_bytes_ptr(buf, Size::from_bytes(u64::from(n)))?;\n-                    let res = if handle == -11 {\n-                        io::stdout().write(buf_cont)\n-                    } else {\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    res.ok().map(|n| n as u32)\n-                } else {\n-                    throw_unsup_format!(\n-                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n-                    )\n-                };\n-                // If there was no error, write back how much was written.\n-                if let Some(n) = written {\n-                    this.write_scalar(Scalar::from_u32(n), &written_place.into())?;\n-                }\n-                // Return whether this was a success.\n-                this.write_scalar(Scalar::from_i32(if written.is_some() { 1 } else { 0 }), dest)?;\n-            }\n-\n             // Allocation\n             \"HeapAlloc\" => {\n                 let &[ref handle, ref flags, ref size] =\n@@ -333,6 +291,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // value if this call does result in switching to another thread.\n                 this.write_null(dest)?;\n             }\n+            \"GetStdHandle\" => {\n+                let &[ref which] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let which = this.read_scalar(which)?.to_i32()?;\n+                // We just make this the identity function, so we know later in `NtWriteFile` which\n+                // one it is. This is very fake, but libtest needs it so we cannot make it a\n+                // std-only shim.\n+                this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n+            }\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n@@ -350,6 +317,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n+            \"GetModuleHandleA\" if this.frame_in_std() => {\n+                #[allow(non_snake_case)]\n+                let &[_lpModuleName] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                // We need to return something non-null here to make `compat_fn!` work.\n+                this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n+            }\n             \"SetConsoleTextAttribute\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n                 let &[ref _hConsoleOutput, ref _wAttribute] ="}, {"sha": "40d8802472acac16fa4917d9f48594f9c2542d89", "filename": "tests/run-pass/concurrency/simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be72564a643758afcc1de152ead2359d489149c0/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72564a643758afcc1de152ead2359d489149c0/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs?ref=be72564a643758afcc1de152ead2359d489149c0", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n-// compile-flags: -Zmiri-check-number-validity\n+// compile-flags: -Zmiri-strict-provenance\n \n use std::thread;\n "}, {"sha": "fa6707632dc766b5fb363b2296a3e18f82047abf", "filename": "tests/run-pass/vecdeque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be72564a643758afcc1de152ead2359d489149c0/tests%2Frun-pass%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be72564a643758afcc1de152ead2359d489149c0/tests%2Frun-pass%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecdeque.rs?ref=be72564a643758afcc1de152ead2359d489149c0", "patch": "@@ -26,7 +26,7 @@ fn main() {\n       assert_eq!(**a, 2);\n     }\n \n-    // Regression test for Debug and Diaplay impl's\n+    // Regression test for Debug impl's\n     println!(\"{:?} {:?}\", dst, dst.iter());\n     println!(\"{:?}\", VecDeque::<u32>::new().iter());\n "}]}