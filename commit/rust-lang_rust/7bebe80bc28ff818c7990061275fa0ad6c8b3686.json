{"sha": "7bebe80bc28ff818c7990061275fa0ad6c8b3686", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZWJlODBiYzI4ZmY4MThjNzk5MDA2MTI3NWZhMGFkNmM4YjM2ODY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-29T09:12:01Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-06T06:04:15Z"}, "message": "syntax: dismantle ast_util.", "tree": {"sha": "55cbc78dd15233353b37d8242e5ba6434b20be2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55cbc78dd15233353b37d8242e5ba6434b20be2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bebe80bc28ff818c7990061275fa0ad6c8b3686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bebe80bc28ff818c7990061275fa0ad6c8b3686", "html_url": "https://github.com/rust-lang/rust/commit/7bebe80bc28ff818c7990061275fa0ad6c8b3686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bebe80bc28ff818c7990061275fa0ad6c8b3686/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4c7241f82c08848938b8b2dafed01535559ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4c7241f82c08848938b8b2dafed01535559ec0", "html_url": "https://github.com/rust-lang/rust/commit/ef4c7241f82c08848938b8b2dafed01535559ec0"}], "stats": {"total": 606, "additions": 117, "deletions": 489}, "files": [{"sha": "a6ff716488526888a9b60ca08a2ec34a07f4bbce", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -908,14 +908,6 @@ pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n     let Item { id, name, attrs, node, vis, span } = item;\n     let id = folder.new_id(id);\n     let node = folder.fold_item_underscore(node);\n-    // FIXME: we should update the impl_pretty_name, but it uses pretty printing.\n-    // let ident = match node {\n-    //     // The node may have changed, recompute the \"pretty\" impl name.\n-    //     ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n-    //         impl_pretty_name(maybe_trait, Some(&**ty))\n-    //     }\n-    //     _ => ident\n-    // };\n \n     Item {\n         id: id,"}, {"sha": "d34d66918ca9498f1dc0d95699933f99bef57479", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -27,11 +27,13 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n-use syntax::ast_util;\n use syntax::attr::ThinAttributesExt;\n use syntax::codemap::Span;\n use hir::*;\n \n+use std::cmp;\n+use std::u32;\n+\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n@@ -837,6 +839,54 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }\n \n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct IdRange {\n+    pub min: NodeId,\n+    pub max: NodeId,\n+}\n+\n+impl IdRange {\n+    pub fn max() -> IdRange {\n+        IdRange {\n+            min: u32::MAX,\n+            max: u32::MIN,\n+        }\n+    }\n+\n+    pub fn empty(&self) -> bool {\n+        self.min >= self.max\n+    }\n+\n+    pub fn add(&mut self, id: NodeId) {\n+        self.min = cmp::min(self.min, id);\n+        self.max = cmp::max(self.max, id + 1);\n+    }\n+}\n+\n+pub trait IdVisitingOperation {\n+    fn visit_id(&mut self, node_id: NodeId);\n+}\n+\n+pub struct IdRangeComputingVisitor {\n+    pub result: IdRange,\n+}\n+\n+impl IdRangeComputingVisitor {\n+    pub fn new() -> IdRangeComputingVisitor {\n+        IdRangeComputingVisitor { result: IdRange::max() }\n+    }\n+\n+    pub fn result(&self) -> IdRange {\n+        self.result\n+    }\n+}\n+\n+impl IdVisitingOperation for IdRangeComputingVisitor {\n+    fn visit_id(&mut self, id: NodeId) {\n+        self.result.add(id);\n+    }\n+}\n+\n pub struct IdVisitor<'a, O: 'a> {\n     operation: &'a mut O,\n \n@@ -853,7 +903,7 @@ pub struct IdVisitor<'a, O: 'a> {\n     skip_members: bool,\n }\n \n-impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n+impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n     pub fn new(operation: &'a mut O) -> IdVisitor<'a, O> {\n         IdVisitor { operation: operation, skip_members: false }\n     }\n@@ -868,7 +918,7 @@ impl<'a, O: ast_util::IdVisitingOperation> IdVisitor<'a, O> {\n     }\n }\n \n-impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n+impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     fn visit_mod(&mut self, module: &Mod, _: Span, node_id: NodeId) {\n         self.operation.visit_id(node_id);\n         walk_mod(self, module)\n@@ -1012,8 +1062,8 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n                                     body: &Block,\n                                     sp: Span,\n                                     id: NodeId)\n-                                    -> ast_util::IdRange {\n-    let mut visitor = ast_util::IdRangeComputingVisitor { result: ast_util::IdRange::max() };\n+                                    -> IdRange {\n+    let mut visitor = IdRangeComputingVisitor { result: IdRange::max() };\n     let mut id_visitor = IdVisitor::new(&mut visitor);\n     id_visitor.visit_fn(fk, decl, body, sp, id);\n     id_visitor.operation.result"}, {"sha": "fd45f58327ffcecf65ec9d9c43c0dbf38e18f26f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -39,7 +39,6 @@ use std::cell::RefCell;\n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n-use syntax::ast_util::{self, IdVisitingOperation};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n@@ -48,7 +47,7 @@ use syntax::ast;\n use syntax::attr::ThinAttributesExt;\n use hir;\n use hir::intravisit as hir_visit;\n-use hir::intravisit::IdVisitor;\n+use hir::intravisit::{IdVisitor, IdVisitingOperation};\n use syntax::visit as ast_visit;\n \n /// Information about the registered lints.\n@@ -654,16 +653,6 @@ impl<'a> EarlyContext<'a> {\n             level_stack: vec![],\n         }\n     }\n-\n-    fn visit_ids<F>(&mut self, f: F)\n-        where F: FnOnce(&mut ast_util::IdVisitor<EarlyContext>)\n-    {\n-        let mut v = ast_util::IdVisitor {\n-            operation: self,\n-            visited_outermost: false,\n-        };\n-        f(&mut v);\n-    }\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n@@ -928,7 +917,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n-            cx.visit_ids(|v| v.visit_item(it));\n             ast_visit::walk_item(cx, it);\n             run_lints!(cx, check_item_post, early_passes, it);\n         })\n@@ -1042,7 +1030,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, early_passes, trait_item);\n-            cx.visit_ids(|v| v.visit_trait_item(trait_item));\n             ast_visit::walk_trait_item(cx, trait_item);\n             run_lints!(cx, check_trait_item_post, early_passes, trait_item);\n         });\n@@ -1051,7 +1038,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, early_passes, impl_item);\n-            cx.visit_ids(|v| v.visit_impl_item(impl_item));\n             ast_visit::walk_impl_item(cx, impl_item);\n             run_lints!(cx, check_impl_item_post, early_passes, impl_item);\n         });\n@@ -1099,18 +1085,6 @@ impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n         }\n     }\n }\n-impl<'a> IdVisitingOperation for EarlyContext<'a> {\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        match self.sess.lints.borrow_mut().remove(&id) {\n-            None => {}\n-            Some(lints) => {\n-                for (lint_id, span, msg) in lints {\n-                    self.span_lint(lint_id.lint, span, &msg[..])\n-                }\n-            }\n-        }\n-    }\n-}\n \n // This lint pass is defined here because it touches parts of the `LateContext`\n // that we don't want to expose. It records the lint level at certain AST\n@@ -1292,11 +1266,12 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n-        cx.visit_id(ast::CRATE_NODE_ID);\n-        cx.visit_ids(|v| {\n-            v.visited_outermost = true;\n-            ast_visit::walk_crate(v, krate);\n-        });\n+        // Lints may be assigned to the whole crate.\n+        if let Some(lints) = cx.sess.lints.borrow_mut().remove(&ast::CRATE_NODE_ID) {\n+            for (lint_id, span, msg) in lints {\n+                cx.span_lint(lint_id.lint, span, &msg[..])\n+            }\n+        }\n \n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here."}, {"sha": "a7f415ef2a08aa7e369008884ee41bd910897e3e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -38,14 +38,13 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n-use syntax::ast_util::{IdVisitingOperation};\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::{IdVisitor, Visitor};\n+use hir::intravisit::{IdVisitor, IdVisitingOperation, Visitor};\n \n pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};"}, {"sha": "1aaaa4bcd77f6afc0e4ec114c5cd3e16ba979ea6", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -21,12 +21,11 @@ use std::io;\n use std::mem;\n use std::usize;\n use syntax::ast;\n-use syntax::ast_util::IdRange;\n use syntax::print::pp;\n use syntax::print::pprust::PrintState;\n use util::nodemap::NodeMap;\n use hir;\n-use hir::intravisit;\n+use hir::intravisit::{self, IdRange};\n use hir::print as pprust;\n \n "}, {"sha": "80e408e9a6e797ec73889c611238c691e3b69d07", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -28,9 +28,9 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use rustc::hir;\n+use rustc::hir::intravisit::IdRange;\n \n #[path=\"fragments.rs\"]\n pub mod fragments;\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n                tcx: &'a TyCtxt<'tcx>,\n                cfg: &cfg::CFG,\n-               id_range: ast_util::IdRange,\n+               id_range: IdRange,\n                decl: &hir::FnDecl,\n                body: &hir::Block)\n                -> FlowedMoveData<'a, 'tcx> {"}, {"sha": "797580319b2ee16777acc1cdd06296cf427b99fe", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -34,11 +34,10 @@ use std::iter::{FromIterator, IntoIterator, repeat};\n \n use rustc::hir;\n use rustc::hir::{Pat, PatKind};\n-use rustc::hir::intravisit::{self, IdVisitor, Visitor, FnKind};\n+use rustc::hir::intravisit::{self, IdVisitor, IdVisitingOperation, Visitor, FnKind};\n use rustc_back::slice;\n \n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n-use syntax::ast_util;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n@@ -460,7 +459,7 @@ struct RenamingRecorder<'map> {\n     renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n }\n \n-impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n+impl<'map> IdVisitingOperation for RenamingRecorder<'map> {\n     fn visit_id(&mut self, node_id: NodeId) {\n         let key = (node_id, self.origin_span);\n         self.renaming_map.insert(key, self.substituted_node_id);"}, {"sha": "61f35a12df7fb0d711c43ee4634bdcb4413baef4", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -18,6 +18,7 @@ use rustc::session::Session;\n use rustc::hir;\n use rustc::hir::fold;\n use rustc::hir::fold::Folder;\n+use rustc::hir::intravisit::{IdRange, IdRangeComputingVisitor, IdVisitingOperation};\n \n use common as c;\n use cstore;\n@@ -36,7 +37,7 @@ use middle::region;\n use rustc::ty::subst;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use syntax::{ast, ast_util, codemap};\n+use syntax::{ast, codemap};\n use syntax::ast::NodeIdAssigner;\n use syntax::ptr::P;\n \n@@ -61,8 +62,8 @@ use serialize::EncoderHelpers;\n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     cdata: &'b cstore::crate_metadata,\n-    from_id_range: ast_util::IdRange,\n-    to_id_range: ast_util::IdRange,\n+    from_id_range: IdRange,\n+    to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: Cell<usize>,\n }\n@@ -178,13 +179,13 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n // Enumerating the IDs which appear in an AST\n \n fn reserve_id_range(sess: &Session,\n-                    from_id_range: ast_util::IdRange) -> ast_util::IdRange {\n+                    from_id_range: IdRange) -> IdRange {\n     // Handle the case of an empty range:\n     if from_id_range.empty() { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.reserve_node_ids(cnt);\n     let to_id_max = to_id_min + cnt;\n-    ast_util::IdRange { min: to_id_min, max: to_id_max }\n+    IdRange { min: to_id_min, max: to_id_max }\n }\n \n impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n@@ -705,7 +706,7 @@ struct SideTableEncodingIdVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w: &'a mut Encoder<'b>,\n }\n \n-impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n+impl<'a, 'b, 'c, 'tcx> IdVisitingOperation for\n         SideTableEncodingIdVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n         encode_side_tables_for_id(self.ecx, self.rbml_w, id)\n@@ -1261,8 +1262,8 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     }\n }\n \n-fn inlined_item_id_range(v: &InlinedItem) -> ast_util::IdRange {\n-    let mut visitor = ast_util::IdRangeComputingVisitor::new();\n+fn inlined_item_id_range(v: &InlinedItem) -> IdRange {\n+    let mut visitor = IdRangeComputingVisitor::new();\n     v.visit_ids(&mut visitor);\n     visitor.result()\n }"}, {"sha": "a4f9720bbe26b890e7a7dfc1730bfc0b3f355de9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -39,7 +39,6 @@ use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind};\n-use syntax::ast_util;\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n@@ -670,7 +669,7 @@ impl<'v> Visitor<'v> for PathCollector {\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 // collect path for either visit_local or visit_arm\n-                let path = ast_util::ident_to_path(path1.span, path1.node);\n+                let path = ast::Path::from_ident(path1.span, path1.node);\n                 self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n             }\n             _ => {}"}, {"sha": "370dd0dad72db71d27ecd3f1c05b7599c5caa984", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -205,6 +205,23 @@ impl fmt::Display for Path {\n     }\n }\n \n+impl Path {\n+    // convert a span and an identifier to the corresponding\n+    // 1-segment path\n+    pub fn from_ident(s: Span, identifier: Ident) -> Path {\n+        Path {\n+            span: s,\n+            global: false,\n+            segments: vec!(\n+                PathSegment {\n+                    identifier: identifier,\n+                    parameters: PathParameters::none()\n+                }\n+            ),\n+        }\n+    }\n+}\n+\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "852b153044fea95e4649b22d101062cc0d653007", "filename": "src/libsyntax/ast_util.rs", "status": "removed", "additions": 0, "deletions": 398, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4c7241f82c08848938b8b2dafed01535559ec0/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ef4c7241f82c08848938b8b2dafed01535559ec0", "patch": "@@ -1,398 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::*;\n-use ast;\n-use codemap;\n-use codemap::Span;\n-use parse::token;\n-use print::pprust;\n-use ptr::P;\n-use visit::{FnKind, Visitor};\n-use visit;\n-\n-use std::cmp;\n-use std::u32;\n-\n-pub fn path_name_i(idents: &[Ident]) -> String {\n-    // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n-}\n-\n-pub fn is_path(e: P<Expr>) -> bool {\n-    match e.node { ExprKind::Path(..) => true, _ => false }\n-}\n-\n-\n-// convert a span and an identifier to the corresponding\n-// 1-segment path\n-pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n-    ast::Path {\n-        span: s,\n-        global: false,\n-        segments: vec!(\n-            ast::PathSegment {\n-                identifier: identifier,\n-                parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n-                    lifetimes: Vec::new(),\n-                    types: P::empty(),\n-                    bindings: P::empty(),\n-                })\n-            }\n-        ),\n-    }\n-}\n-\n-// If path is a single segment ident path, return that ident. Otherwise, return\n-// None.\n-pub fn path_to_ident(path: &Path) -> Option<Ident> {\n-    if path.segments.len() != 1 {\n-        return None;\n-    }\n-\n-    let segment = &path.segments[0];\n-    if !segment.parameters.is_empty() {\n-        return None;\n-    }\n-\n-    Some(segment.identifier)\n-}\n-\n-pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n-    let spanned = codemap::Spanned{ span: s, node: i };\n-    P(Pat {\n-        id: id,\n-        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), spanned, None),\n-        span: s\n-    })\n-}\n-\n-/// Generate a \"pretty\" name for an `impl` from its type and trait.\n-/// This is designed so that symbols of `impl`'d methods give some\n-/// hint of where they came from, (previously they would all just be\n-/// listed as `__extensions__::method_name::hash`, with no indication\n-/// of the type).\n-pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: Option<&Ty>) -> Ident {\n-    let mut pretty = match ty {\n-        Some(t) => pprust::ty_to_string(t),\n-        None => String::from(\"..\")\n-    };\n-\n-    match *trait_ref {\n-        Some(ref trait_ref) => {\n-            pretty.push('.');\n-            pretty.push_str(&pprust::path_to_string(&trait_ref.path));\n-        }\n-        None => {}\n-    }\n-    token::gensym_ident(&pretty[..])\n-}\n-\n-pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n-    match field.node.kind {\n-        ast::NamedField(_, v) | ast::UnnamedField(v) => v\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Enumerating the IDs which appear in an AST\n-\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct IdRange {\n-    pub min: NodeId,\n-    pub max: NodeId,\n-}\n-\n-impl IdRange {\n-    pub fn max() -> IdRange {\n-        IdRange {\n-            min: u32::MAX,\n-            max: u32::MIN,\n-        }\n-    }\n-\n-    pub fn empty(&self) -> bool {\n-        self.min >= self.max\n-    }\n-\n-    pub fn add(&mut self, id: NodeId) {\n-        self.min = cmp::min(self.min, id);\n-        self.max = cmp::max(self.max, id + 1);\n-    }\n-}\n-\n-pub trait IdVisitingOperation {\n-    fn visit_id(&mut self, node_id: NodeId);\n-}\n-\n-/// A visitor that applies its operation to all of the node IDs\n-/// in a visitable thing.\n-\n-pub struct IdVisitor<'a, O:'a> {\n-    pub operation: &'a mut O,\n-    pub visited_outermost: bool,\n-}\n-\n-impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n-    fn visit_generics_helper(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            self.operation.visit_id(type_parameter.id)\n-        }\n-        for lifetime in &generics.lifetimes {\n-            self.operation.visit_id(lifetime.lifetime.id)\n-        }\n-    }\n-}\n-\n-impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n-    fn visit_mod(&mut self,\n-                 module: &Mod,\n-                 _: Span,\n-                 node_id: NodeId) {\n-        self.operation.visit_id(node_id);\n-        visit::walk_mod(self, module)\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.operation.visit_id(foreign_item.id);\n-        visit::walk_foreign_item(self, foreign_item)\n-    }\n-\n-    fn visit_item(&mut self, item: &Item) {\n-        if self.visited_outermost {\n-            return\n-        } else {\n-            self.visited_outermost = true\n-        }\n-\n-        self.operation.visit_id(item.id);\n-        match item.node {\n-            ItemKind::Use(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathSimple(_, _) |\n-                    ViewPathGlob(_) => {}\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.operation.visit_id(path.node.id())\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        visit::walk_item(self, item);\n-\n-        self.visited_outermost = false\n-    }\n-\n-    fn visit_local(&mut self, local: &Local) {\n-        self.operation.visit_id(local.id);\n-        visit::walk_local(self, local)\n-    }\n-\n-    fn visit_block(&mut self, block: &Block) {\n-        self.operation.visit_id(block.id);\n-        visit::walk_block(self, block)\n-    }\n-\n-    fn visit_stmt(&mut self, statement: &Stmt) {\n-        self.operation\n-            .visit_id(statement.node.id().expect(\"attempted to visit unexpanded stmt\"));\n-        visit::walk_stmt(self, statement)\n-    }\n-\n-    fn visit_pat(&mut self, pattern: &Pat) {\n-        self.operation.visit_id(pattern.id);\n-        visit::walk_pat(self, pattern)\n-    }\n-\n-    fn visit_expr(&mut self, expression: &Expr) {\n-        self.operation.visit_id(expression.id);\n-        visit::walk_expr(self, expression)\n-    }\n-\n-    fn visit_ty(&mut self, typ: &Ty) {\n-        self.operation.visit_id(typ.id);\n-        visit::walk_ty(self, typ)\n-    }\n-\n-    fn visit_generics(&mut self, generics: &Generics) {\n-        self.visit_generics_helper(generics);\n-        visit::walk_generics(self, generics)\n-    }\n-\n-    fn visit_fn(&mut self,\n-                function_kind: visit::FnKind<'v>,\n-                function_declaration: &'v FnDecl,\n-                block: &'v Block,\n-                span: Span,\n-                node_id: NodeId) {\n-        match function_kind {\n-            FnKind::Method(..) if self.visited_outermost => return,\n-            FnKind::Method(..) => self.visited_outermost = true,\n-            _ => {}\n-        }\n-\n-        self.operation.visit_id(node_id);\n-\n-        match function_kind {\n-            FnKind::ItemFn(_, generics, _, _, _, _) => {\n-                self.visit_generics_helper(generics)\n-            }\n-            FnKind::Method(_, ref sig, _) => {\n-                self.visit_generics_helper(&sig.generics)\n-            }\n-            FnKind::Closure => {}\n-        }\n-\n-        for argument in &function_declaration.inputs {\n-            self.operation.visit_id(argument.id)\n-        }\n-\n-        visit::walk_fn(self,\n-                       function_kind,\n-                       function_declaration,\n-                       block,\n-                       span);\n-\n-        if let FnKind::Method(..) = function_kind {\n-            self.visited_outermost = false;\n-        }\n-    }\n-\n-    fn visit_struct_field(&mut self, struct_field: &StructField) {\n-        self.operation.visit_id(struct_field.node.id);\n-        visit::walk_struct_field(self, struct_field)\n-    }\n-\n-    fn visit_variant_data(&mut self,\n-                        struct_def: &VariantData,\n-                        _: ast::Ident,\n-                        _: &ast::Generics,\n-                        _: NodeId,\n-                        _: Span) {\n-        self.operation.visit_id(struct_def.id());\n-        visit::walk_struct_def(self, struct_def);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n-        self.operation.visit_id(ti.id);\n-        visit::walk_trait_item(self, ti);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n-        self.operation.visit_id(ii.id);\n-        visit::walk_impl_item(self, ii);\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n-        self.operation.visit_id(lifetime.id);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-\n-    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n-        self.operation.visit_id(trait_ref.ref_id);\n-        visit::walk_trait_ref(self, trait_ref);\n-    }\n-}\n-\n-pub struct IdRangeComputingVisitor {\n-    pub result: IdRange,\n-}\n-\n-impl IdRangeComputingVisitor {\n-    pub fn new() -> IdRangeComputingVisitor {\n-        IdRangeComputingVisitor { result: IdRange::max() }\n-    }\n-\n-    pub fn result(&self) -> IdRange {\n-        self.result\n-    }\n-}\n-\n-impl IdVisitingOperation for IdRangeComputingVisitor {\n-    fn visit_id(&mut self, id: NodeId) {\n-        self.result.add(id);\n-    }\n-}\n-\n-/// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body(fk: FnKind,\n-                                    decl: &FnDecl,\n-                                    body: &Block,\n-                                    sp: Span,\n-                                    id: NodeId)\n-                                    -> IdRange\n-{\n-    let mut visitor = IdRangeComputingVisitor::new();\n-    let mut id_visitor = IdVisitor {\n-        operation: &mut visitor,\n-        visited_outermost: false,\n-    };\n-    id_visitor.visit_fn(fk, decl, body, sp, id);\n-    id_visitor.operation.result\n-}\n-\n-/// Returns true if the given pattern consists solely of an identifier\n-/// and false otherwise.\n-pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n-    match pat.node {\n-        PatKind::Ident(..) => true,\n-        _ => false,\n-    }\n-}\n-\n-// are two paths equal when compared unhygienically?\n-// since I'm using this to replace ==, it seems appropriate\n-// to compare the span, global, etc. fields as well.\n-pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n-    (a.span.source_equal(&b.span))\n-    && (a.global == b.global)\n-    && (segments_name_eq(&a.segments[..], &b.segments[..]))\n-}\n-\n-// are two arrays of segments equal when compared unhygienically?\n-pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> bool {\n-    a.len() == b.len() &&\n-    a.iter().zip(b).all(|(s, t)| {\n-        s.identifier.name == t.identifier.name &&\n-        // FIXME #7743: ident -> name problems in lifetime comparison?\n-        // can types contain idents?\n-        s.parameters == t.parameters\n-    })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ast::*;\n-    use super::*;\n-\n-    fn ident_to_segment(id: Ident) -> PathSegment {\n-        PathSegment {identifier: id,\n-                     parameters: PathParameters::none()}\n-    }\n-\n-    #[test] fn idents_name_eq_test() {\n-        assert!(segments_name_eq(\n-            &[Ident::new(Name(3),SyntaxContext(4)), Ident::new(Name(78),SyntaxContext(82))]\n-                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n-            &[Ident::new(Name(3),SyntaxContext(104)), Ident::new(Name(78),SyntaxContext(182))]\n-                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n-        assert!(!segments_name_eq(\n-            &[Ident::new(Name(3),SyntaxContext(4)), Ident::new(Name(78),SyntaxContext(82))]\n-                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n-            &[Ident::new(Name(3),SyntaxContext(104)), Ident::new(Name(77),SyntaxContext(182))]\n-                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n-    }\n-}"}, {"sha": "55eec16551752bc5b9fdf153e8716522d894f949", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -21,7 +21,6 @@\n use ast::*;\n use ast;\n use attr::{ThinAttributes, ThinAttributesExt};\n-use ast_util;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n use ptr::P;\n@@ -1073,13 +1072,6 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n                                         folder: &mut T) -> Item {\n     let id = folder.new_id(id);\n     let node = folder.fold_item_kind(node);\n-    let ident = match node {\n-        // The node may have changed, recompute the \"pretty\" impl name.\n-        ItemKind::Impl(_, _, _, ref maybe_trait, ref ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, Some(&ty))\n-        }\n-        _ => ident\n-    };\n \n     Item {\n         id: id,"}, {"sha": "ab14e21e251cb00cfb30172e4e7cdaffb7ed32ea", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -91,7 +91,6 @@ pub mod syntax {\n \n pub mod abi;\n pub mod ast;\n-pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n pub mod config;"}, {"sha": "36f01463205a0190299e64c09683f0b05aa572de", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -44,7 +44,6 @@ use ast::{Visibility, WhereClause};\n use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast::{BinOpKind, UnOp};\n use ast;\n-use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n use errors::{self, DiagnosticBuilder};\n use ext::tt::macro_parser;\n@@ -1577,9 +1576,14 @@ impl<'a> Parser<'a> {\n             pat\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n-            ast_util::ident_to_pat(ast::DUMMY_NODE_ID,\n-                                   self.last_span,\n-                                   special_idents::invalid)\n+            let sp = self.last_span;\n+            let spanned = Spanned { span: sp, node: special_idents::invalid };\n+            P(Pat {\n+                id: ast::DUMMY_NODE_ID,\n+                node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable),\n+                                     spanned, None),\n+                span: sp\n+            })\n         };\n \n         let t = self.parse_ty_sum()?;\n@@ -2223,7 +2227,7 @@ impl<'a> Parser<'a> {\n                             ctxt: _\n                          }, token::Plain) => {\n                 self.bump();\n-                let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n+                let path = ast::Path::from_ident(mk_sp(lo, hi), id);\n                 ex = ExprKind::Path(None, path);\n                 hi = self.last_span.hi;\n             }\n@@ -3679,7 +3683,7 @@ impl<'a> Parser<'a> {\n                         // Parse macro invocation\n                         let ident = self.parse_ident()?;\n                         let ident_span = self.last_span;\n-                        let path = ident_to_path(ident_span, ident);\n+                        let path = ast::Path::from_ident(ident_span, ident);\n                         self.bump();\n                         let delim = self.expect_open_delim()?;\n                         let tts = self.parse_seq_to_end(\n@@ -5116,7 +5120,7 @@ impl<'a> Parser<'a> {\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n             self.expect(&token::CloseDelim(token::Brace))?;\n-            Ok((ast_util::impl_pretty_name(&opt_trait, None),\n+            Ok((special_idents::invalid,\n              ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n@@ -5132,7 +5136,7 @@ impl<'a> Parser<'a> {\n                 impl_items.push(self.parse_impl_item()?);\n             }\n \n-            Ok((ast_util::impl_pretty_name(&opt_trait, Some(&ty)),\n+            Ok((special_idents::invalid,\n              ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }"}, {"sha": "703b1611540c89272bc9c8b82d4aee63f1ef69f3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -18,7 +18,6 @@ use std::iter;\n use std::slice;\n use std::mem;\n use std::vec;\n-use ast_util::*;\n use attr::AttrMetaMethods;\n use attr;\n use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n@@ -35,7 +34,7 @@ use fold;\n use parse::token::{intern, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n-use {ast, ast_util};\n+use ast;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n@@ -120,8 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         if ident.name != token::special_idents::invalid.name {\n             self.cx.path.push(ident);\n         }\n-        debug!(\"current path: {}\",\n-               ast_util::path_name_i(&self.cx.path));\n+        debug!(\"current path: {}\", path_name_i(&self.cx.path));\n \n         let i = if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n             match i.node {\n@@ -349,7 +347,6 @@ enum HasTestSignature {\n     NotEvenAFunction,\n }\n \n-\n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n \n@@ -576,6 +573,11 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n+fn path_name_i(idents: &[ast::Ident]) -> String {\n+    // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n+    idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n+}\n+\n fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n@@ -645,10 +647,10 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // creates $name: $expr\n     let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(&path[..]));\n+    debug!(\"encoding {}\", path_name_i(&path[..]));\n \n     // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = ast_util::path_name_i(&path[..]);\n+    let path_string = path_name_i(&path[..]);\n     let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[..]));\n \n     // self::test::StaticTestName($name_expr)"}, {"sha": "37c77ec5b2fc9897d1c2ecf9c4d167a8300ccb48", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bebe80bc28ff818c7990061275fa0ad6c8b3686/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7bebe80bc28ff818c7990061275fa0ad6c8b3686", "patch": "@@ -194,7 +194,6 @@ use std::vec;\n \n use syntax::abi::Abi;\n use syntax::ast::{self, EnumDef, Expr, Ident, Generics, VariantData, BinOpKind, PatKind};\n-use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n@@ -620,7 +619,6 @@ impl<'a> TraitDef<'a> {\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let ident = ast_util::impl_pretty_name(&opt_trait_ref, Some(&self_type));\n         let unused_qual = cx.attribute(\n             self.span,\n             cx.meta_list(self.span,\n@@ -638,7 +636,7 @@ impl<'a> TraitDef<'a> {\n \n         cx.item(\n             self.span,\n-            ident,\n+            special_idents::invalid,\n             a,\n             ast::ItemKind::Impl(unsafety,\n                                 ast::ImplPolarity::Positive,"}]}