{"sha": "c07103b4a2b8c88a2c405ede6386f821edad41fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNzEwM2I0YTJiOGM4OGEyYzQwNWVkZTYzODZmODIxZWRhZDQxZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-28T23:30:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-28T23:30:56Z"}, "message": "Auto merge of #6993 - Jarcho:expl_impl_clone, r=llogiq\n\nImprove `expl_impl_clone_on_copy`\n\nfixes: #1254\n\nchangelog: Check to see if the generic constraints are the same as if using derive for `expl_impl_clone_on_copy`", "tree": {"sha": "2fc947a3b0e52f3a8e7641086e10a38da1801d76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc947a3b0e52f3a8e7641086e10a38da1801d76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c07103b4a2b8c88a2c405ede6386f821edad41fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c07103b4a2b8c88a2c405ede6386f821edad41fd", "html_url": "https://github.com/rust-lang/rust/commit/c07103b4a2b8c88a2c405ede6386f821edad41fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c07103b4a2b8c88a2c405ede6386f821edad41fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bcc5525879b33e2863593a81c4ab85249e8aafb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcc5525879b33e2863593a81c4ab85249e8aafb", "html_url": "https://github.com/rust-lang/rust/commit/4bcc5525879b33e2863593a81c4ab85249e8aafb"}, {"sha": "879fa5c9721c89c27be6a9db5f51d935a51f549b", "url": "https://api.github.com/repos/rust-lang/rust/commits/879fa5c9721c89c27be6a9db5f51d935a51f549b", "html_url": "https://github.com/rust-lang/rust/commit/879fa5c9721c89c27be6a9db5f51d935a51f549b"}], "stats": {"total": 138, "additions": 89, "deletions": 49}, "files": [{"sha": "9fad85f8ef432ad8c741730c416b418181a9134a", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c07103b4a2b8c88a2c405ede6386f821edad41fd/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07103b4a2b8c88a2c405ede6386f821edad41fd/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=c07103b4a2b8c88a2c405ede6386f821edad41fd", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_then};\n use clippy_utils::paths;\n-use clippy_utils::ty::is_copy;\n+use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{get_trait_def_id, is_allowed, is_automatically_derived, match_def_path};\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n@@ -12,7 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_span::{def_id::LOCAL_CRATE, source_map::Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n@@ -293,48 +293,53 @@ fn check_ord_partial_ord<'tcx>(\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n-    if cx\n-        .tcx\n-        .lang_items()\n-        .clone_trait()\n-        .map_or(false, |id| Some(id) == trait_ref.trait_def_id())\n-    {\n-        if !is_copy(cx, ty) {\n+    let clone_id = match cx.tcx.lang_items().clone_trait() {\n+        Some(id) if trait_ref.trait_def_id() == Some(id) => id,\n+        _ => return,\n+    };\n+    let copy_id = match cx.tcx.lang_items().copy_trait() {\n+        Some(id) => id,\n+        None => return,\n+    };\n+    let (ty_adt, ty_subs) = match *ty.kind() {\n+        // Unions can't derive clone.\n+        ty::Adt(adt, subs) if !adt.is_union() => (adt, subs),\n+        _ => return,\n+    };\n+    // If the current self type doesn't implement Copy (due to generic constraints), search to see if\n+    // there's a Copy impl for any instance of the adt.\n+    if !is_copy(cx, ty) {\n+        if ty_subs.non_erasable_generics().next().is_some() {\n+            let has_copy_impl = cx\n+                .tcx\n+                .all_local_trait_impls(LOCAL_CRATE)\n+                .get(&copy_id)\n+                .map_or(false, |impls| {\n+                    impls\n+                        .iter()\n+                        .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did == adt.did))\n+                });\n+            if !has_copy_impl {\n+                return;\n+            }\n+        } else {\n             return;\n         }\n-\n-        match *ty.kind() {\n-            ty::Adt(def, _) if def.is_union() => return,\n-\n-            // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            ty::Adt(def, substs) => {\n-                for variant in &def.variants {\n-                    for field in &variant.fields {\n-                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind() {\n-                            return;\n-                        }\n-                    }\n-                    for subst in substs {\n-                        if let ty::subst::GenericArgKind::Type(subst) = subst.unpack() {\n-                            if let ty::Param(_) = subst.kind() {\n-                                return;\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-\n-        span_lint_and_note(\n-            cx,\n-            EXPL_IMPL_CLONE_ON_COPY,\n-            item.span,\n-            \"you are implementing `Clone` explicitly on a `Copy` type\",\n-            Some(item.span),\n-            \"consider deriving `Clone` or removing `Copy`\",\n-        );\n     }\n+    // Derive constrains all generic types to requiring Clone. Check if any type is not constrained for\n+    // this impl.\n+    if ty_subs.types().any(|ty| !implements_trait(cx, ty, clone_id, &[])) {\n+        return;\n+    }\n+\n+    span_lint_and_note(\n+        cx,\n+        EXPL_IMPL_CLONE_ON_COPY,\n+        item.span,\n+        \"you are implementing `Clone` explicitly on a `Copy` type\",\n+        Some(item.span),\n+        \"consider deriving `Clone` or removing `Copy`\",\n+    );\n }\n \n /// Implementation of the `UNSAFE_DERIVE_DESERIALIZE` lint."}, {"sha": "4e46bf1399173f40379eed86ad5225192a538b28", "filename": "tests/ui/derive.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c07103b4a2b8c88a2c405ede6386f821edad41fd/tests%2Fui%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07103b4a2b8c88a2c405ede6386f821edad41fd/tests%2Fui%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.rs?ref=c07103b4a2b8c88a2c405ede6386f821edad41fd", "patch": "@@ -35,7 +35,6 @@ impl<'a> Clone for Lt<'a> {\n     }\n }\n \n-// Ok, `Clone` cannot be derived because of the big array\n #[derive(Copy)]\n struct BigArray {\n     a: [u8; 65],\n@@ -47,7 +46,6 @@ impl Clone for BigArray {\n     }\n }\n \n-// Ok, function pointers are not always Clone\n #[derive(Copy)]\n struct FnPtr {\n     a: fn() -> !,\n@@ -59,7 +57,7 @@ impl Clone for FnPtr {\n     }\n }\n \n-// Ok, generics\n+// Ok, Clone trait impl doesn't have constrained generics.\n #[derive(Copy)]\n struct Generic<T> {\n     a: T,\n@@ -71,4 +69,21 @@ impl<T> Clone for Generic<T> {\n     }\n }\n \n+#[derive(Copy)]\n+struct Generic2<T>(T);\n+impl<T: Clone> Clone for Generic2<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+\n+// Ok, Clone trait impl doesn't have constrained generics.\n+#[derive(Copy)]\n+struct GenericRef<'a, T, U>(T, &'a U);\n+impl<T: Clone, U> Clone for GenericRef<'_, T, U> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone(), self.1)\n+    }\n+}\n+\n fn main() {}"}, {"sha": "82a70ceecc368710f3e0e6411aeb08be51316520", "filename": "tests/ui/derive.stderr", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c07103b4a2b8c88a2c405ede6386f821edad41fd/tests%2Fui%2Fderive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c07103b4a2b8c88a2c405ede6386f821edad41fd/tests%2Fui%2Fderive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.stderr?ref=c07103b4a2b8c88a2c405ede6386f821edad41fd", "patch": "@@ -40,7 +40,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:44:1\n+  --> $DIR/derive.rs:43:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -50,7 +50,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:44:1\n+  --> $DIR/derive.rs:43:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -60,7 +60,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:56:1\n+  --> $DIR/derive.rs:54:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -70,7 +70,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:56:1\n+  --> $DIR/derive.rs:54:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -79,5 +79,25 @@ LL | |     }\n LL | | }\n    | |_^\n \n-error: aborting due to 4 previous errors\n+error: you are implementing `Clone` explicitly on a `Copy` type\n+  --> $DIR/derive.rs:74:1\n+   |\n+LL | / impl<T: Clone> Clone for Generic2<T> {\n+LL | |     fn clone(&self) -> Self {\n+LL | |         Self(self.0.clone())\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: consider deriving `Clone` or removing `Copy`\n+  --> $DIR/derive.rs:74:1\n+   |\n+LL | / impl<T: Clone> Clone for Generic2<T> {\n+LL | |     fn clone(&self) -> Self {\n+LL | |         Self(self.0.clone())\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 5 previous errors\n "}]}