{"sha": "a7e674006c7125fb47ce2909616ba5d59dce62aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZTY3NDAwNmM3MTI1ZmI0N2NlMjkwOTYxNmJhNWQ1OWRjZTYyYWE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-26T17:44:19Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-26T18:23:51Z"}, "message": "Store TyLayout inside CValue and CPlace", "tree": {"sha": "7fd393905fed5155698f9f07c8d097cfab5a32d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fd393905fed5155698f9f07c8d097cfab5a32d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7e674006c7125fb47ce2909616ba5d59dce62aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e674006c7125fb47ce2909616ba5d59dce62aa", "html_url": "https://github.com/rust-lang/rust/commit/a7e674006c7125fb47ce2909616ba5d59dce62aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7e674006c7125fb47ce2909616ba5d59dce62aa/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdad2d427d097fd778b41fa8891a561d756ea373", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdad2d427d097fd778b41fa8891a561d756ea373", "html_url": "https://github.com/rust-lang/rust/commit/bdad2d427d097fd778b41fa8891a561d756ea373"}], "stats": {"total": 301, "additions": 170, "deletions": 131}, "files": [{"sha": "6cbc04f60e164899a7d3f020a248507dc54e3642", "filename": "build.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7e674006c7125fb47ce2909616ba5d59dce62aa/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a7e674006c7125fb47ce2909616ba5d59dce62aa/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=a7e674006c7125fb47ce2909616ba5d59dce62aa", "patch": "@@ -1,3 +1,3 @@\n cargo build || exit 1\n \n-rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cretonne.so example.rs --crate-type lib\n+rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cretonne.so example.rs --crate-type lib -Og"}, {"sha": "a1052bbec488fa4ee3526df4a3b7f4150b06673f", "filename": "src/base.rs", "status": "modified", "additions": 63, "deletions": 74, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a7e674006c7125fb47ce2909616ba5d59dce62aa/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e674006c7125fb47ce2909616ba5d59dce62aa/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=a7e674006c7125fb47ce2909616ba5d59dce62aa", "patch": "@@ -156,31 +156,33 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        let ty = fx.cton_type(mir.local_decls[local].ty);\n-        (local, fx.bcx.append_ebb_param(start_ebb, ty.unwrap_or(types::I64)), ty, stack_slot)\n-    }).collect::<Vec<(Local, Value, Option<Type>, StackSlot)>>();\n+        let ty = mir.local_decls[local].ty;\n+        let cton_type = fx.cton_type(ty).unwrap_or(types::I64);\n+        (local, fx.bcx.append_ebb_param(start_ebb, cton_type), ty, stack_slot)\n+    }).collect::<Vec<(Local, Value, Ty, StackSlot)>>();\n \n-    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param));\n+    let ret_layout = fx.layout_of(fx.instance.ty(fx.tcx).fn_sig(fx.tcx).skip_binder().output());\n+    fx.local_map.insert(RETURN_PLACE, CPlace::Addr(ret_param, ret_layout));\n \n     for (local, ebb_param, ty, stack_slot) in func_params {\n-        let place = CPlace::from_stack_slot(fx, stack_slot);\n-        if ty.is_some() {\n-            CPlace::from_stack_slot(fx, stack_slot).write_cvalue(fx, CValue::ByVal(ebb_param), mir.local_decls[local].ty);\n-            //fx.bcx.ins().stack_store(ebb_param, stack_slot, 0);\n+        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n+        if fx.cton_type(ty).is_some() {\n+            place.write_cvalue(fx, CValue::ByVal(ebb_param, place.layout()));\n         } else {\n-            place.write_cvalue(fx, CValue::ByRef(ebb_param), mir.local_decls[local].ty);\n+            place.write_cvalue(fx, CValue::ByRef(ebb_param, place.layout()));\n         }\n         fx.local_map.insert(local, place);\n     }\n \n     for local in mir.vars_and_temps_iter() {\n-        let layout = fx.layout_of(mir.local_decls[local].ty);\n+        let ty = mir.local_decls[local].ty;\n+        let layout = fx.layout_of(ty);\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        let place = CPlace::from_stack_slot(fx, stack_slot);\n+        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n         fx.local_map.insert(local, place);\n     }\n \n@@ -203,8 +205,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n                 fx.bcx.ins().return_(&[]);\n             }\n             TerminatorKind::Assert { cond, expected, msg: _, target, cleanup: _ } => {\n-                let cond_ty = cond.ty(&fx.mir.local_decls, fx.tcx);\n-                let cond = trans_operand(fx, cond).load_value(fx, cond_ty);\n+                let cond = trans_operand(fx, cond).load_value(fx);\n                 let target = fx.get_ebb(*target);\n                 if *expected {\n                     fx.bcx.ins().brz(cond, target, &[]);\n@@ -215,8 +216,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n             }\n \n             TerminatorKind::SwitchInt { discr, switch_ty, values, targets } => {\n-                let discr_ty = discr.ty(&fx.mir.local_decls, fx.tcx);\n-                let discr = trans_operand(fx, discr).load_value(fx, discr_ty);\n+                let discr = trans_operand(fx, discr).load_value(fx);\n                 let mut jt_data = JumpTableData::new();\n                 for (i, value) in values.iter().enumerate() {\n                     let ebb = fx.get_ebb(targets[i]);\n@@ -244,18 +244,18 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n                                 let ty = arg.ty(&fx.mir.local_decls, fx.tcx);\n                                 let arg = trans_operand(fx, arg);\n                                 if let Some(_) = fx.cton_type(ty) {\n-                                    arg.load_value(fx, ty)\n+                                    arg.load_value(fx)\n                                 } else {\n-                                    arg.force_stack(fx, ty)\n+                                    arg.force_stack(fx)\n                                 }\n                             })\n                     ).collect::<Vec<_>>();\n                 match func {\n-                    CValue::Func(func) => {\n+                    CValue::Func(func, _) => {\n                         fx.bcx.ins().call(func, &args);\n                     }\n                     func => {\n-                        let func = func.load_value(fx, func_ty);\n+                        let func = func.load_value(fx);\n                         let sig = match func_ty.sty {\n                             TypeVariants::TyFnDef(def_id, _substs) => fx.tcx.fn_sig(def_id),\n                             TypeVariants::TyFnPtr(fn_sig) => fn_sig,\n@@ -293,9 +293,8 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx>) {\n     match &stmt.kind {\n         StatementKind::SetDiscriminant { place, variant_index } => {\n-            let place_ty = fx.monomorphize(&place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n             let place = trans_place(fx, place);\n-            let layout = fx.layout_of(place_ty);\n+            let layout = place.layout();\n             if layout.for_variant(&*fx, *variant_index).abi == layout::Abi::Uninhabited {\n                 return;\n             }\n@@ -304,12 +303,12 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                     assert_eq!(index, *variant_index);\n                 }\n                 layout::Variants::Tagged { .. } => {\n-                    let ptr = place.place_field(fx, mir::Field::new(0), place_ty);\n+                    let ptr = place.place_field(fx, mir::Field::new(0));\n                     let to = layout.ty.ty_adt_def().unwrap()\n                         .discriminant_for_variant(fx.tcx, *variant_index)\n                         .val;\n-                    let discr = CValue::const_val(fx, ptr.1.ty, to as u64 as i64);\n-                    ptr.0.write_cvalue(fx, discr, ptr.1.ty);\n+                    let discr = CValue::const_val(fx, ptr.layout().ty, to as u64 as i64);\n+                    ptr.write_cvalue(fx, discr);\n                 }\n                 layout::Variants::NicheFilling {\n                     dataful_variant,\n@@ -318,35 +317,34 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                     ..\n                 } => {\n                     if *variant_index != dataful_variant {\n-                        let niche = place.place_field(fx, mir::Field::new(0), place_ty);\n+                        let niche = place.place_field(fx, mir::Field::new(0));\n                         //let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n                         let niche_value = ((variant_index - *niche_variants.start()) as u128)\n                             .wrapping_add(niche_start);\n                         // FIXME(eddyb) Check the actual primitive type here.\n                         let niche_llval = if niche_value == 0 {\n-                            CValue::const_val(fx, niche.1.ty, 0)\n+                            CValue::const_val(fx, niche.layout().ty, 0)\n                         } else {\n-                            CValue::const_val(fx, niche.1.ty, niche_value as u64 as i64)\n+                            CValue::const_val(fx, niche.layout().ty, niche_value as u64 as i64)\n                         };\n-                        niche.0.write_cvalue(fx, niche_llval, niche.1.ty);\n+                        niche.write_cvalue(fx, niche_llval);\n                     }\n                 }\n             }\n         }\n         StatementKind::Assign(to_place, rval) => {\n-            let dest_ty = fx.monomorphize(&to_place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n             let lval = trans_place(fx, to_place);\n+            let dest_layout = lval.layout();\n             match rval {\n                 Rvalue::Use(operand) => {\n                     let val = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, val, &dest_ty);\n+                    lval.write_cvalue(fx, val);\n                 },\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let lhs_ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let lhs = trans_operand(fx, lhs).load_value(fx, lhs_ty);\n-                    let rhs_ty = fx.monomorphize(&rhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let rhs = trans_operand(fx, rhs).load_value(fx, rhs_ty);\n+                    let layout = fx.layout_of(ty);\n+                    let lhs = trans_operand(fx, lhs).load_value(fx);\n+                    let rhs = trans_operand(fx, rhs).load_value(fx);\n \n                     let res = match ty.sty {\n                         TypeVariants::TyUint(_) => {\n@@ -369,16 +367,15 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                         }\n                         _ => unimplemented!(),\n                     };\n-                    lval.write_cvalue(fx, CValue::ByVal(res), ty);\n+                    lval.write_cvalue(fx, CValue::ByVal(res, layout));\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n                     // TODO correctly write output tuple\n \n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let lhs_ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let lhs = trans_operand(fx, lhs).load_value(fx, lhs_ty);\n-                    let rhs_ty = fx.monomorphize(&rhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let rhs = trans_operand(fx, rhs).load_value(fx, rhs_ty);\n+                    let layout = fx.layout_of(ty);\n+                    let lhs = trans_operand(fx, lhs).load_value(fx);\n+                    let rhs = trans_operand(fx, rhs).load_value(fx);\n \n                     let res = match ty.sty {\n                         TypeVariants::TyUint(_) => {\n@@ -401,22 +398,22 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                         }\n                         _ => unimplemented!(),\n                     };\n-                    lval.write_cvalue(fx, CValue::ByVal(res), ty);\n+                    lval.write_cvalue(fx, CValue::ByVal(res, layout));\n                     unimplemented!(\"checked bin op {:?}\", bin_op);\n                 }\n                 Rvalue::Cast(CastKind::ReifyFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, operand, &dest_ty);\n+                    let layout = fx.layout_of(ty);\n+                    lval.write_cvalue(fx, operand.unchecked_cast_to(layout));\n                 }\n                 Rvalue::Cast(CastKind::UnsafeFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, operand, &dest_ty);\n+                    let layout = fx.layout_of(ty);\n+                    lval.write_cvalue(fx, operand.unchecked_cast_to(layout));\n                 }\n                 Rvalue::Discriminant(place) => {\n-                    let dest_cton_ty = fx.cton_type(&dest_ty).unwrap();\n-                    let place_ty = fx.monomorphize(&place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n-                    let cton_place_ty = fx.cton_type(&place_ty);\n-                    let layout = fx.layout_of(place_ty);\n+                    let dest_cton_ty = fx.cton_type(dest_layout.ty).unwrap();\n+                    let layout = lval.layout();\n \n                     if layout.abi == layout::Abi::Uninhabited {\n                         fx.bcx.ins().trap(TrapCode::User(!0));\n@@ -426,28 +423,26 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                             let discr_val = layout.ty.ty_adt_def().map_or(\n                                 index as u128,\n                                 |def| def.discriminant_for_variant(fx.tcx, index).val);\n-                            let val = CValue::const_val(fx, &dest_ty, discr_val as u64 as i64);\n-                            lval.write_cvalue(fx, val, &dest_ty);\n+                            let val = CValue::const_val(fx, dest_layout.ty, discr_val as u64 as i64);\n+                            lval.write_cvalue(fx, val);\n+                            return;\n                         }\n                         layout::Variants::Tagged { .. } |\n                         layout::Variants::NicheFilling { .. } => {},\n                     }\n \n-                    let discr = lval.to_cvalue(fx).value_field(fx, mir::Field::new(0), place_ty);\n-                    let discr_ty = layout.field(layout::LayoutCx {\n-                        tcx: fx.tcx,\n-                        param_env: ParamEnv::reveal_all()\n-                    }, 0).unwrap().ty;\n-                    let lldiscr = discr.load_value(fx, discr_ty);\n+                    let discr = lval.to_cvalue(fx).value_field(fx, mir::Field::new(0));\n+                    let discr_ty = lval.layout().ty;\n+                    let lldiscr = discr.load_value(fx);\n                     match layout.variants {\n                         layout::Variants::Single { .. } => bug!(),\n                         layout::Variants::Tagged { ref tag, .. } => {\n                             let signed = match tag.value {\n                                 layout::Int(_, signed) => signed,\n                                 _ => false\n                             };\n-                            let val = cton_intcast(fx, lldiscr, discr_ty, &dest_ty, signed);\n-                            lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n+                            let val = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, signed);\n+                            lval.write_cvalue(fx, CValue::ByVal(val, dest_layout));\n                         }\n                         layout::Variants::NicheFilling {\n                             dataful_variant,\n@@ -461,18 +456,17 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                                 let if_true = fx.bcx.ins().iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n                                 let if_false = fx.bcx.ins().iconst(dest_cton_ty, dataful_variant as u64 as i64);\n                                 let val = fx.bcx.ins().select(b, if_true, if_false);\n-                                lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n+                                lval.write_cvalue(fx, CValue::ByVal(val, dest_layout));\n                             } else {\n                                 // Rebase from niche values to discriminant values.\n                                 let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n                                 let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n                                 let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n-                                let lldiscr_max = fx.bcx.ins().iconst(niche_llty, *niche_variants.end() as u64 as i64);\n                                 let b = fx.bcx.ins().icmp_imm(IntCC::UnsignedLessThanOrEqual, lldiscr, *niche_variants.end() as u64 as i64);\n-                                let if_true = cton_intcast(fx, lldiscr, discr_ty, &dest_ty, false);\n+                                let if_true = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, false);\n                                 let if_false = fx.bcx.ins().iconst(niche_llty, dataful_variant as u64 as i64);\n                                 let val = fx.bcx.ins().select(b, if_true, if_false);\n-                                lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n+                                lval.write_cvalue(fx, CValue::ByVal(val, dest_layout));\n                             }\n                         }\n                     }\n@@ -485,21 +479,20 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n     }\n }\n \n-fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace {\n+fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace<'tcx> {\n     match place {\n         Place::Local(local) => fx.get_local_place(*local),\n         Place::Projection(projection) => {\n             let base = trans_place(fx, &projection.base);\n-            let base_ty = projection.base.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx);\n             match projection.elem {\n                 ProjectionElem::Deref => {\n-                    CPlace::Addr(base.to_cvalue(fx).load_value(fx, base_ty))\n+                    CPlace::Addr(base.to_cvalue(fx).load_value(fx), fx.layout_of(place.ty(&*fx.mir, fx.tcx).to_ty(fx.tcx)))\n                 }\n                 ProjectionElem::Field(field, ty) => {\n-                    base.place_field(fx, field, ty).0\n+                    base.place_field(fx, field)\n                 }\n-                ProjectionElem::Downcast(_ty, _field) => {\n-                    base\n+                ProjectionElem::Downcast(adt_def, variant) => {\n+                    base.downcast_variant(fx, variant)\n                 }\n                 _ => unimplemented!(\"projection {:?}\", projection),\n             }\n@@ -508,7 +501,7 @@ fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>)\n     }\n }\n \n-fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue {\n+fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx>) -> CValue<'tcx> {\n     match operand {\n         Operand::Move(place) |\n         Operand::Copy(place) => {\n@@ -522,19 +515,15 @@ fn trans_operand<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx>, operand: &Operand<'tcx\n                     match const_.ty.sty {\n                         TypeVariants::TyUint(_) => {\n                             let bits = value.to_scalar().unwrap().to_bits(layout.size).unwrap();\n-                            let cton_ty = fx.cton_type(const_.ty).unwrap();\n-                            let iconst = fx.bcx.ins().iconst(cton_ty, bits as u64 as i64);\n-                            CValue::ByVal(iconst)\n+                            CValue::const_val(fx, const_.ty, bits as u64 as i64)\n                         }\n                         TypeVariants::TyInt(_) => {\n                             let bits = value.to_scalar().unwrap().to_bits(layout.size).unwrap();\n-                            let cton_ty = fx.cton_type(const_.ty).unwrap();\n-                            let iconst = fx.bcx.ins().iconst(cton_ty, bits as i128 as i64);\n-                            CValue::ByVal(iconst)\n+                            CValue::const_val(fx, const_.ty, bits as i128 as i64)\n                         }\n                         TypeVariants::TyFnDef(def_id, substs) => {\n                             let func_ref = fx.get_function_ref(Instance::new(def_id, substs));\n-                            CValue::Func(func_ref)\n+                            CValue::Func(func_ref, fx.layout_of(const_.ty))\n                         }\n                         _ => unimplemented!(\"value {:?} ty {:?}\", value, const_.ty),\n                     }"}, {"sha": "89ee2666f03b332ac995acef24a146fb9430ed84", "filename": "src/common.rs", "status": "modified", "additions": 106, "deletions": 56, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a7e674006c7125fb47ce2909616ba5d59dce62aa/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e674006c7125fb47ce2909616ba5d59dce62aa/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=a7e674006c7125fb47ce2909616ba5d59dce62aa", "patch": "@@ -82,18 +82,25 @@ fn store_workaround(fx: &mut FunctionCx, ty: Type, addr: Value, val: Value, offs\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub enum CValue {\n-    ByRef(Value),\n-    ByVal(Value),\n-    Func(FuncRef),\n+pub enum CValue<'tcx> {\n+    ByRef(Value, TyLayout<'tcx>),\n+    ByVal(Value, TyLayout<'tcx>),\n+    Func(FuncRef, TyLayout<'tcx>),\n }\n \n-impl CValue {\n-    pub fn force_stack<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n+impl<'tcx> CValue<'tcx> {\n+    pub fn layout(&self) -> TyLayout<'tcx> {\n+        match *self {\n+            CValue::ByRef(_, layout) |\n+            CValue::ByVal(_, layout) |\n+            CValue::Func(_, layout) => layout\n+        }\n+    }\n+\n+    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> Value where 'tcx: 'a {\n         match self {\n-            CValue::ByRef(value) => value,\n-            CValue::ByVal(value) => {\n-                let layout = fx.layout_of(ty);\n+            CValue::ByRef(value, _layout) => value,\n+            CValue::ByVal(value, layout) => {\n                 let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                     kind: StackSlotKind::ExplicitSlot,\n                     size: layout.size.bytes() as u32,\n@@ -102,114 +109,157 @@ impl CValue {\n                 fx.bcx.ins().stack_store(value, stack_slot, 0);\n                 fx.bcx.ins().stack_addr(types::I64, stack_slot, 0)\n             }\n-            CValue::Func(func) => {\n+            CValue::Func(func, ty) => {\n                 let func = fx.bcx.ins().func_addr(types::I64, func);\n-                CValue::ByVal(func).force_stack(fx, ty)\n+                CValue::ByVal(func, ty).force_stack(fx)\n             }\n         }\n     }\n \n-    pub fn load_value<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n+    pub fn load_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx>) -> Value where 'tcx: 'a{\n         match self {\n-            CValue::ByRef(value) => {\n-                let cton_ty = fx.cton_type(ty).expect(&format!(\"{:?}\", ty));\n+            CValue::ByRef(value, layout) => {\n+                let cton_ty = fx.cton_type(layout.ty).expect(&format!(\"{:?}\", layout.ty));\n                 load_workaround(fx, cton_ty, value, 0)\n             }\n-            CValue::ByVal(value) => value,\n-            CValue::Func(func) => {\n+            CValue::ByVal(value, _layout) => value,\n+            CValue::Func(func, _layout) => {\n                 fx.bcx.ins().func_addr(types::I64, func)\n             }\n         }\n     }\n \n-    pub fn expect_byref(self) -> Value {\n+    pub fn expect_byref(self) -> (Value, TyLayout<'tcx>) {\n         match self {\n-            CValue::ByRef(value) => value,\n-            CValue::ByVal(_) => bug!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n-            CValue::Func(_) => bug!(\"Expected CValue::ByRef, found CValue::Func\"),\n+            CValue::ByRef(value, layout) => (value, layout),\n+            CValue::ByVal(_, _) => bug!(\"Expected CValue::ByRef, found CValue::ByVal\"),\n+            CValue::Func(_, _) => bug!(\"Expected CValue::ByRef, found CValue::Func\"),\n         }\n     }\n \n-    pub fn value_field<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field, ty: Ty<'tcx>) -> CValue {\n-        let base = match self {\n-            CValue::ByRef(addr) => addr,\n+    pub fn value_field<'a>(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field) -> CValue<'tcx> where 'tcx: 'a {\n+        use rustc::ty::util::IntTypeExt;\n+\n+        let (base, layout) = match self {\n+            CValue::ByRef(addr, layout) => (addr, layout),\n             _ => bug!(\"place_field for {:?}\", self),\n         };\n-        let layout = fx.layout_of(ty);\n         let field_offset = layout.fields.offset(field.index());\n+        let field_layout = if field.index() == 0 {\n+            fx.layout_of(if let ty::TyAdt(adt_def, _) = layout.ty.sty {\n+                adt_def.repr.discr_type().to_ty(fx.tcx)\n+            } else {\n+                // This can only be `0`, for now, so `u8` will suffice.\n+                fx.tcx.types.u8\n+            })\n+        } else {\n+            layout.field(&*fx, field.index())\n+        };\n         if field_offset.bytes() > 0 {\n             let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n-            CValue::ByRef(fx.bcx.ins().iadd(base, field_offset))\n+            CValue::ByRef(fx.bcx.ins().iadd(base, field_offset), field_layout)\n         } else {\n-            CValue::ByRef(base)\n+            CValue::ByRef(base, field_layout)\n         }\n     }\n \n-    pub fn const_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue {\n-        let ty = fx.cton_type(ty).unwrap();\n-        CValue::ByVal(fx.bcx.ins().iconst(ty, const_val))\n+    pub fn const_val<'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue<'tcx> where 'tcx: 'a {\n+        let cton_ty = fx.cton_type(ty).unwrap();\n+        let layout = fx.layout_of(ty);\n+        CValue::ByVal(fx.bcx.ins().iconst(cton_ty, const_val), layout)\n+    }\n+\n+    pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n+        match self {\n+            CValue::ByRef(addr, _) => CValue::ByRef(addr, layout),\n+            CValue::ByVal(val, _) => CValue::ByVal(val, layout),\n+            CValue::Func(fun, _) => CValue::Func(fun, layout),\n+        }\n     }\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub enum CPlace {\n-    Var(Variable),\n-    Addr(Value),\n+pub enum CPlace<'tcx> {\n+    Var(Variable, TyLayout<'tcx>),\n+    Addr(Value, TyLayout<'tcx>),\n }\n \n-impl<'a, 'tcx: 'a> CPlace {\n-    pub fn from_stack_slot(fx: &mut FunctionCx<'a, 'tcx>, stack_slot: StackSlot) -> CPlace {\n-        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0))\n+impl<'a, 'tcx: 'a> CPlace<'tcx> {\n+    pub fn layout(&self) -> TyLayout<'tcx> {\n+        match *self {\n+            CPlace::Var(_, layout) |\n+            CPlace::Addr(_, layout) => layout\n+        }\n+    }\n+\n+    pub fn from_stack_slot(fx: &mut FunctionCx<'a, 'tcx>, stack_slot: StackSlot, ty: Ty<'tcx>) -> CPlace<'tcx> {\n+        let layout = fx.layout_of(ty);\n+        CPlace::Addr(fx.bcx.ins().stack_addr(types::I64, stack_slot, 0), layout)\n     }\n \n-    pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue {\n+    pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>) -> CValue<'tcx> {\n         match self {\n-            CPlace::Var(var) => CValue::ByVal(fx.bcx.use_var(var)),\n-            CPlace::Addr(addr) => CValue::ByRef(addr),\n+            CPlace::Var(var, layout) => CValue::ByVal(fx.bcx.use_var(var), layout),\n+            CPlace::Addr(addr, layout) => CValue::ByRef(addr, layout),\n         }\n     }\n \n     pub fn expect_addr(self) -> Value {\n         match self {\n-            CPlace::Addr(addr) => addr,\n-            CPlace::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+            CPlace::Addr(addr, _layout) => addr,\n+            CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n         }\n     }\n \n-    pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue, ty: Ty<'tcx>) {\n-        let layout = fx.layout_of(ty);\n-        let size = layout.size.bytes() as i32;\n+    pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue<'tcx>) {\n+        assert_eq!(self.layout().ty, from.layout().ty, \"Can't write value of incompatible type to place\");\n+\n         match self {\n-            CPlace::Var(var) => {\n-                let data = from.load_value(fx, ty);\n+            CPlace::Var(var, _) => {\n+                let data = from.load_value(fx);\n                 fx.bcx.def_var(var, data)\n             },\n-            CPlace::Addr(addr) => {\n-                if let Some(cton_ty) = fx.cton_type(ty) {\n-                    let data = from.load_value(fx, ty);\n+            CPlace::Addr(addr, layout) => {\n+                let size = layout.size.bytes() as i32;\n+\n+                if let Some(cton_ty) = fx.cton_type(layout.ty) {\n+                    let data = from.load_value(fx);\n                     store_workaround(fx, cton_ty, addr, data, 0);\n                 } else {\n                     for i in 0..size {\n                         let from = from.expect_byref();\n-                        let byte = load_workaround(fx, types::I8, from, i);\n+                        let byte = load_workaround(fx, types::I8, from.0, i);\n                         store_workaround(fx, types::I8, addr, byte, i);\n                     }\n                 }\n             }\n         }\n     }\n \n-    pub fn place_field(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field, ty: Ty<'tcx>) -> (CPlace, layout::TyLayout<'tcx>) {\n+    pub fn place_field(self, fx: &mut FunctionCx<'a, 'tcx>, field: mir::Field) -> CPlace<'tcx> {\n         let base = self.expect_addr();\n-        let layout = fx.layout_of(ty);\n+        let layout = self.layout();\n         let field_offset = layout.fields.offset(field.index());\n+        let field_ty = layout.field(&*fx, field.index());\n         if field_offset.bytes() > 0 {\n             let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n-            (CPlace::Addr(fx.bcx.ins().iadd(base, field_offset)), layout)\n+            CPlace::Addr(fx.bcx.ins().iadd(base, field_offset), field_ty)\n         } else {\n-            (CPlace::Addr(base), layout)\n+            CPlace::Addr(base, field_ty)\n         }\n     }\n+\n+    pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n+        match self {\n+            CPlace::Var(var, _) => CPlace::Var(var, layout),\n+            CPlace::Addr(addr, _) => CPlace::Addr(addr, layout),\n+        }\n+    }\n+\n+    pub fn downcast_variant(self, fx: &FunctionCx<'a, 'tcx>, variant: usize) -> Self {\n+        let layout = self.layout().for_variant(fx, variant);\n+        self.unchecked_cast_to(layout)\n+    }\n }\n \n pub fn cton_sig_from_fn_sig<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sig: PolyFnSig<'tcx>, substs: &Substs<'tcx>) -> Signature {\n@@ -267,7 +317,7 @@ pub struct FunctionCx<'a, 'tcx: 'a> {\n     pub param_substs: &'tcx Substs<'tcx>,\n     pub bcx: FunctionBuilder<'a, Variable>,\n     pub ebb_map: HashMap<BasicBlock, Ebb>,\n-    pub local_map: HashMap<Local, CPlace>,\n+    pub local_map: HashMap<Local, CPlace<'tcx>>,\n }\n \n impl<'a, 'tcx: 'a> LayoutOf for &'a FunctionCx<'a, 'tcx> {\n@@ -298,7 +348,7 @@ impl<'a, 'tcx> HasTargetSpec for &'a FunctionCx<'a, 'tcx> {\n     }\n }\n \n-impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n+impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -317,7 +367,7 @@ impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n         *self.ebb_map.get(&bb).unwrap()\n     }\n \n-    pub fn get_local_place(&mut self, local: Local) -> CPlace {\n+    pub fn get_local_place(&mut self, local: Local) -> CPlace<'tcx> {\n         *self.local_map.get(&local).unwrap()\n     }\n "}]}