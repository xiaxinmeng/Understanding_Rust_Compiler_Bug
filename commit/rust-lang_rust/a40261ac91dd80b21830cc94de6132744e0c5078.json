{"sha": "a40261ac91dd80b21830cc94de6132744e0c5078", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MDI2MWFjOTFkZDgwYjIxODMwY2M5NGRlNjEzMjc0NGUwYzUwNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-25T03:43:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-25T03:43:31Z"}, "message": "Auto merge of #24798 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #24662, #24722, #24725, #24729, #24736, #24749, #24751, #24766, #24769, #24772, #24775, #24790\n- Failed merges: #24760", "tree": {"sha": "023666901a4f040367389290d46a22c97ae7d8ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/023666901a4f040367389290d46a22c97ae7d8ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a40261ac91dd80b21830cc94de6132744e0c5078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a40261ac91dd80b21830cc94de6132744e0c5078", "html_url": "https://github.com/rust-lang/rust/commit/a40261ac91dd80b21830cc94de6132744e0c5078", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a40261ac91dd80b21830cc94de6132744e0c5078/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e53c7f2c8285f3422ac7ac091349ce572c4baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e53c7f2c8285f3422ac7ac091349ce572c4baa", "html_url": "https://github.com/rust-lang/rust/commit/f9e53c7f2c8285f3422ac7ac091349ce572c4baa"}, {"sha": "23b1d172a8245f810f179d939488325fff005158", "url": "https://api.github.com/repos/rust-lang/rust/commits/23b1d172a8245f810f179d939488325fff005158", "html_url": "https://github.com/rust-lang/rust/commit/23b1d172a8245f810f179d939488325fff005158"}], "stats": {"total": 987, "additions": 596, "deletions": 391}, "files": [{"sha": "542815e7afe3ce8522cf278692e2bacfd0f1c1a0", "filename": "src/doc/grammar.md", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -152,19 +152,19 @@ token : simple_token | ident | literal | symbol | whitespace token ;\n \n <p id=\"keyword-table-marker\"></p>\n \n-|          |          |          |          |        |\n-|----------|----------|----------|----------|--------|\n-| abstract | alignof  | as       | become   | box    |\n-| break    | const    | continue | crate    | do     |\n-| else     | enum     | extern   | false    | final  |\n-| fn       | for      | if       | impl     | in     |\n-| let      | loop     | match    | mod      | move   |\n-| mut      | offsetof | once     | override | priv   |\n-| proc     | pub      | pure     | ref      | return |\n-| sizeof   | static   | self     | struct   | super  |\n-| true     | trait    | type     | typeof   | unsafe |\n-| unsized  | use      | virtual  | where    | while  |\n-| yield    |          |          |          |        |\n+|          |          |          |          |         |\n+|----------|----------|----------|----------|---------|\n+| abstract | alignof  | as       | become   | box     |\n+| break    | const    | continue | crate    | do      |\n+| else     | enum     | extern   | false    | final   |\n+| fn       | for      | if       | impl     | in      |\n+| let      | loop     | macro    | match    | mod     |\n+| move     | mut      | offsetof | override | priv    |\n+| proc     | pub      | pure     | ref      | return  |\n+| Self     | self     | sizeof   | static   | struct  |\n+| super    | trait    | true     | type     | typeof  |\n+| unsafe   | unsized  | use      | virtual  | where   |\n+| while    | yield    |          |          |         |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -524,6 +524,15 @@ array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n idx_expr : expr '[' expr ']' ;\n ```\n \n+### Range expressions\n+\n+```antlr\n+range_expr : expr \"..\" expr |\n+             expr \"..\" |\n+             \"..\" expr |\n+             \"..\" ;\n+```\n+\n ### Unary operator expressions\n \n **FIXME:** grammar?\n@@ -610,7 +619,7 @@ lambda_expr : '|' ident_list '|' expr ;\n ### While loops\n \n ```antlr\n-while_expr : \"while\" no_struct_literal_expr '{' block '}' ;\n+while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### Infinite loops\n@@ -634,7 +643,7 @@ continue_expr : \"continue\" [ lifetime ];\n ### For expressions\n \n ```antlr\n-for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n+for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### If expressions"}, {"sha": "059da89192576868422e6ab42e53231870d5ce9c", "filename": "src/doc/reference.md", "status": "modified", "additions": 15, "deletions": 340, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -29,41 +29,6 @@ You may also be interested in the [grammar].\n \n # Notation\n \n-Rust's grammar is defined over Unicode code points, each conventionally denoted\n-`U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n-confined to the ASCII range of Unicode, and is described in this document by a\n-dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n-supported by common automated LL(k) parsing tools such as `llgen`, rather than\n-the dialect given in ISO 14977. The dialect can be defined self-referentially\n-as follows:\n-\n-```{.ebnf .notation}\n-grammar : rule + ;\n-rule    : nonterminal ':' productionrule ';' ;\n-productionrule : production [ '|' production ] * ;\n-production : term * ;\n-term : element repeats ;\n-element : LITERAL | IDENTIFIER | '[' productionrule ']' ;\n-repeats : [ '*' | '+' ] NUMBER ? | NUMBER ? | '?' ;\n-```\n-\n-Where:\n-\n-- Whitespace in the grammar is ignored.\n-- Square brackets are used to group rules.\n-- `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n-  ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n-  Unicode code point `U+00QQ`.\n-- `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n-- The `repeat` forms apply to the adjacent `element`, and are as follows:\n-  - `?` means zero or one repetition\n-  - `*` means zero or more repetitions\n-  - `+` means one or more repetitions\n-  - NUMBER trailing a repeat symbol gives a maximum repetition count\n-  - NUMBER on its own gives an exact repetition count\n-\n-This EBNF dialect should hopefully be familiar to many readers.\n-\n ## Unicode productions\n \n A few productions in Rust's grammar permit Unicode code points outside the ASCII\n@@ -132,13 +97,6 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n ## Comments\n \n-```{.ebnf .gram}\n-comment : block_comment | line_comment ;\n-block_comment : \"/*\" block_comment_body * \"*/\" ;\n-block_comment_body : [block_comment | character] * ;\n-line_comment : \"//\" non_eol * ;\n-```\n-\n Comments in Rust code follow the general C++ style of line and block-comment\n forms. Nested block comments are supported.\n \n@@ -159,11 +117,6 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-```{.ebnf .gram}\n-whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n-whitespace : [ whitespace_char | comment ] + ;\n-```\n-\n The `whitespace_char` production is any nonempty Unicode string consisting of\n any of the following Unicode characters: `U+0020` (space, `' '`), `U+0009`\n (tab, `'\\t'`), `U+000A` (LF, `'\\n'`), `U+000D` (CR, `'\\r'`).\n@@ -176,53 +129,18 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-```{.ebnf .gram}\n-simple_token : keyword | unop | binop ;\n-token : simple_token | ident | literal | symbol | whitespace token ;\n-```\n-\n Tokens are primitive productions in the grammar defined by regular\n (non-recursive) languages. \"Simple\" tokens are given in [string table\n production](#string-table-productions) form, and occur in the rest of the\n grammar as double-quoted strings. Other tokens have exact rules given.\n \n-### Keywords\n-\n-<p id=\"keyword-table-marker\"></p>\n-\n-|          |          |          |          |         |\n-|----------|----------|----------|----------|---------|\n-| abstract | alignof  | as       | become   | box     |\n-| break    | const    | continue | crate    | do      |\n-| else     | enum     | extern   | false    | final   |\n-| fn       | for      | if       | impl     | in      |\n-| let      | loop     | macro    | match    | mod     |\n-| move     | mut      | offsetof | override | priv    |\n-| proc     | pub      | pure     | ref      | return  |\n-| Self     | self     | sizeof   | static   | struct  |\n-| super    | trait    | true     | type     | typeof  |\n-| unsafe   | unsized  | use      | virtual  | where   |\n-| while    | yield    |          |          |         |\n-\n-\n-Each of these keywords has special meaning in its grammar, and all of them are\n-excluded from the `ident` rule.\n-\n-Note that some of these keywords are reserved, and do not currently do\n-anything.\n-\n ### Literals\n \n A literal is an expression consisting of a single token, rather than a sequence\n of tokens, that immediately and directly denotes the value it evaluates to,\n rather than referring to it by name or some other evaluation rule. A literal is\n a form of constant expression, so is evaluated (primarily) at compile time.\n \n-```{.ebnf .gram}\n-lit_suffix : ident;\n-literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit ] lit_suffix ?;\n-```\n-\n The optional suffix is only used for certain numeric literals, but is\n reserved for future extension, that is, the above gives the lexical\n grammar, but a Rust parser will reject everything but the 12 special\n@@ -275,32 +193,6 @@ cases mentioned in [Number literals](#number-literals) below.\n \n #### Character and string literals\n \n-```{.ebnf .gram}\n-char_lit : '\\x27' char_body '\\x27' ;\n-string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n-\n-char_body : non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape | unicode_escape ] ;\n-\n-string_body : non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape | unicode_escape ] ;\n-raw_string : '\"' raw_string_body '\"' | '#' raw_string '#' ;\n-\n-common_escape : '\\x5c'\n-              | 'n' | 'r' | 't' | '0'\n-              | 'x' hex_digit 2\n-\n-unicode_escape : 'u' '{' hex_digit+ 6 '}';\n-\n-hex_digit : 'a' | 'b' | 'c' | 'd' | 'e' | 'f'\n-          | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'\n-          | dec_digit ;\n-oct_digit : '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;\n-dec_digit : '0' | nonzero_dec ;\n-nonzero_dec: '1' | '2' | '3' | '4'\n-           | '5' | '6' | '7' | '8' | '9' ;\n-```\n-\n ##### Character literals\n \n A _character literal_ is a single Unicode character enclosed within two\n@@ -349,11 +241,10 @@ following forms:\n \n Raw string literals do not process any escapes. They start with the character\n `U+0072` (`r`), followed by zero or more of the character `U+0023` (`#`) and a\n-`U+0022` (double-quote) character. The _raw string body_ is not defined in the\n-EBNF grammar above: it can contain any sequence of Unicode characters and is\n-terminated only by another `U+0022` (double-quote) character, followed by the\n-same number of `U+0023` (`#`) characters that preceded the opening `U+0022`\n-(double-quote) character.\n+`U+0022` (double-quote) character. The _raw string body_ can contain any sequence\n+of Unicode characters and is terminated only by another `U+0022` (double-quote)\n+character, followed by the same number of `U+0023` (`#`) characters that preceded\n+the opening `U+0022` (double-quote) character.\n \n All Unicode characters contained in the raw string body represent themselves,\n the characters `U+0022` (double-quote) (except when followed by at least as\n@@ -375,19 +266,6 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n #### Byte and byte string literals\n \n-```{.ebnf .gram}\n-byte_lit : \"b\\x27\" byte_body '\\x27' ;\n-byte_string_lit : \"b\\x22\" string_body * '\\x22' | \"br\" raw_byte_string ;\n-\n-byte_body : ascii_non_single_quote\n-          | '\\x5c' [ '\\x27' | common_escape ] ;\n-\n-byte_string_body : ascii_non_double_quote\n-            | '\\x5c' [ '\\x22' | common_escape ] ;\n-raw_byte_string : '\"' raw_byte_string_body '\"' | '#' raw_byte_string '#' ;\n-\n-```\n-\n ##### Byte literals\n \n A _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`\n@@ -403,7 +281,7 @@ preceded by the characters `U+0062` (`b`) and `U+0022` (double-quote), and\n followed by the character `U+0022`. If the character `U+0022` is present within\n the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) character.\n Alternatively, a byte string literal can be a _raw byte string literal_, defined\n-below. A byte string literal is equivalent to a `&'static [u8]` borrowed array\n+below. A byte string literal of length `n` is equivalent to a `&'static [u8; n]` borrowed fixed-sized array\n of unsigned 8-bit integers.\n \n Some additional _escapes_ are available in either byte or non-raw byte string\n@@ -424,11 +302,10 @@ following forms:\n Raw byte string literals do not process any escapes. They start with the\n character `U+0062` (`b`), followed by `U+0072` (`r`), followed by zero or more\n of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The\n-_raw string body_ is not defined in the EBNF grammar above: it can contain any\n-sequence of ASCII characters and is terminated only by another `U+0022`\n-(double-quote) character, followed by the same number of `U+0023` (`#`)\n-characters that preceded the opening `U+0022` (double-quote) character. A raw\n-byte string literal can not contain any non-ASCII byte.\n+_raw string body_ can contain any sequence of ASCII characters and is terminated\n+only by another `U+0022` (double-quote) character, followed by the same number of\n+`U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote)\n+character. A raw byte string literal can not contain any non-ASCII byte.\n \n All characters contained in the raw string body represent their ASCII encoding,\n the characters `U+0022` (double-quote) (except when followed by at least as\n@@ -450,19 +327,6 @@ b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n \n #### Number literals\n \n-```{.ebnf .gram}\n-num_lit : nonzero_dec [ dec_digit | '_' ] * float_suffix ?\n-        | '0' [       [ dec_digit | '_' ] * float_suffix ?\n-              | 'b'   [ '1' | '0' | '_' ] +\n-              | 'o'   [ oct_digit | '_' ] +\n-              | 'x'   [ hex_digit | '_' ] +  ] ;\n-\n-float_suffix : [ exponent | '.' dec_lit exponent ? ] ? ;\n-\n-exponent : ['E' | 'e'] ['-' | '+' ] ? dec_lit ;\n-dec_lit : [ dec_digit | '_' ] + ;\n-```\n-\n A _number literal_ is either an _integer literal_ or a _floating-point\n literal_. The grammar for recognizing the two kinds of literals is mixed.\n \n@@ -540,12 +404,6 @@ The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-```{.ebnf .gram}\n-symbol : \"::\" | \"->\"\n-       | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n-       | ',' | ';' ;\n-```\n-\n Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n completeness as the set of remaining miscellaneous printable tokens that do not\n@@ -555,16 +413,6 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-```{.ebnf .gram}\n-expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n-expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | expr_path ;\n-\n-type_path : ident [ type_path_tail ] + ;\n-type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n-               | \"::\" type_path ;\n-```\n-\n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n refer to either an [item](#items) or a [variable](#variables) in a local control\n@@ -660,19 +508,6 @@ Users of `rustc` can define new syntax extensions in two ways:\n \n ## Macros\n \n-```{.ebnf .gram}\n-expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ;\n-macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n-matcher : '(' matcher * ')' | '[' matcher * ']'\n-        | '{' matcher * '}' | '$' ident ':' ident\n-        | '$' '(' matcher * ')' sep_token? [ '*' | '+' ]\n-        | non_special_token ;\n-transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n-            | '{' transcriber * '}' | '$' ident\n-            | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n-            | non_special_token ;\n-```\n-\n `macro_rules` allows users to define syntax extension in a declarative way.  We\n call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n from the \"procedural macros\" defined in [compiler plugins][plugin].\n@@ -811,12 +646,6 @@ Crates contain [items](#items), each of which may have some number of\n \n ## Items\n \n-```{.ebnf .gram}\n-item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n-     | struct_item | enum_item | static_item | trait_item | impl_item\n-     | extern_block ;\n-```\n-\n An _item_ is a component of a crate. Items are organized within a crate by a\n nested set of [modules](#modules). Every crate has a single \"outermost\"\n anonymous module; all further items within the crate have [paths](#paths)\n@@ -863,11 +692,6 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n \n-```{.ebnf .gram}\n-mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : item * ;\n-```\n-\n A module is a container for zero or more [items](#items).\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n@@ -928,11 +752,6 @@ mod thread {\n \n ##### Extern crate declarations\n \n-```{.ebnf .gram}\n-extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( string_lit \"as\" ident )\n-```\n-\n An _`extern crate` declaration_ specifies a dependency on an external crate.\n The external crate is then bound into the declaring scope as the `ident`\n provided in the `extern_crate_decl`.\n@@ -958,17 +777,6 @@ extern crate std as ruststd; // linking to 'std' under another name\n \n ##### Use declarations\n \n-```{.ebnf .gram}\n-use_decl : \"pub\" ? \"use\" [ path \"as\" ident\n-                          | path_glob ] ;\n-\n-path_glob : ident [ \"::\" [ path_glob\n-                          | '*' ] ] ?\n-          | '{' path_item [ ',' path_item ] * '}' ;\n-\n-path_item : ident | \"self\" ;\n-```\n-\n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths). Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear at the\n@@ -1413,10 +1221,6 @@ it were `Bar(i32)`, this is disallowed.\n \n ### Constant items\n \n-```{.ebnf .gram}\n-const_item : \"const\" ident ':' type '=' expr ';' ;\n-```\n-\n A *constant item* is a named _constant value_ which is not associated with a\n specific memory location in the program. Constants are essentially inlined\n wherever they are used, meaning that they are copied directly into the relevant\n@@ -1453,10 +1257,6 @@ const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n \n ### Static items\n \n-```{.ebnf .gram}\n-static_item : \"static\" ident ':' type '=' expr ';' ;\n-```\n-\n A *static item* is similar to a *constant*, except that it represents a precise\n memory location in the program. A static is never \"inlined\" at the usage site,\n and all references to it refer to the same memory location. Static items have\n@@ -1711,11 +1511,6 @@ impl Seq<bool> for u32 {\n \n ### External blocks\n \n-```{.ebnf .gram}\n-extern_block_item : \"extern\" '{' extern_block '}' ;\n-extern_block : [ foreign_fn ] * ;\n-```\n-\n External blocks form the basis for Rust's foreign function interface.\n Declarations in an external block describe symbols in external, non-Rust\n libraries.\n@@ -1915,13 +1710,6 @@ the namespace hierarchy as it normally would.\n \n ## Attributes\n \n-```{.ebnf .gram}\n-attribute : '#' '!' ? '[' meta_item ']' ;\n-meta_item : ident [ '=' literal\n-                  | '(' meta_seq ')' ] ? ;\n-meta_seq : meta_item [ ',' meta_seq ] ? ;\n-```\n-\n Any item declaration may have an _attribute_ applied to it. Attributes in Rust\n are modeled on Attributes in ECMA-335, with the syntax coming from ECMA-334\n (C#). An attribute is a general, free-form metadatum that is interpreted\n@@ -2503,7 +2291,7 @@ The currently implemented features of the reference compiler are:\n                               terms of encapsulation).\n \n If a feature is promoted to a language feature, then all existing programs will\n-start to receive compilation warnings about #[feature] directives which enabled\n+start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a\n feature is decided to be removed from the language, errors will be issued (if\n there isn't a parser error first). The directive in this case is no longer\n@@ -2554,11 +2342,6 @@ in meaning to declaring the item outside the statement block.\n \n #### Variable declarations\n \n-```{.ebnf .gram}\n-let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n-init : [ '=' ] expr ;\n-```\n-\n A _variable declaration_ introduces a new set of variable, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n@@ -2649,7 +2432,7 @@ parentheses. They are used to create [tuple-typed](#tuple-types) values.\n ```{.tuple}\n (0,);\n (0.0, 4.5);\n-(\"a\", 4us, true);\n+(\"a\", 4usize, true);\n ```\n \n ### Unit expressions\n@@ -2659,15 +2442,6 @@ the same name.\n \n ### Structure expressions\n \n-```{.ebnf .gram}\n-struct_expr : expr_path '{' ident ':' expr\n-                      [ ',' ident ':' expr ] *\n-                      [ \"..\" expr ] '}' |\n-              expr_path '(' expr\n-                      [ ',' expr ] * ')' |\n-              expr_path ;\n-```\n-\n There are several forms of structure expressions. A _structure expression_\n consists of the [path](#paths) of a [structure item](#structures), followed by\n a brace-enclosed list of one or more comma-separated name-value pairs,\n@@ -2718,11 +2492,6 @@ Point3d {y: 0, z: 10, .. base};\n \n ### Block expressions\n \n-```{.ebnf .gram}\n-block_expr : '{' [ stmt ';' | item ] *\n-                 [ expr ] '}' ;\n-```\n-\n A _block expression_ is similar to a module in terms of the declarations that\n are possible. Each block conceptually introduces a new namespace scope. Use\n items can bring new names into scopes and declared items are in scope for only\n@@ -2745,10 +2514,6 @@ assert_eq!(5, x);\n \n ### Method-call expressions\n \n-```{.ebnf .gram}\n-method_call_expr : expr '.' ident paren_expr_list ;\n-```\n-\n A _method call_ consists of an expression followed by a single dot, an\n identifier, and a parenthesized expression-list. Method calls are resolved to\n methods on specific traits, either statically dispatching to a method if the\n@@ -2757,10 +2522,6 @@ the left-hand-side expression is an indirect [trait object](#trait-objects).\n \n ### Field expressions\n \n-```{.ebnf .gram}\n-field_expr : expr '.' ident ;\n-```\n-\n A _field expression_ consists of an expression followed by a single dot and an\n identifier, when not immediately followed by a parenthesized expression-list\n (the latter is a [method call expression](#method-call-expressions)). A field\n@@ -2781,12 +2542,6 @@ automatically dereferenced to make the field access possible.\n \n ### Array expressions\n \n-```{.ebnf .gram}\n-array_expr : '[' \"mut\" ? array_elems? ']' ;\n-\n-array_elems : [expr [',' expr]*] | [expr ';' expr] ;\n-```\n-\n An [array](#array,-and-slice-types) _expression_ is written by enclosing zero\n or more comma-separated expressions of uniform type in square brackets.\n \n@@ -2803,10 +2558,6 @@ constant expression that can be evaluated at compile time, such as a\n \n ### Index expressions\n \n-```{.ebnf .gram}\n-idx_expr : expr '[' expr ']' ;\n-```\n-\n [Array](#array,-and-slice-types)-typed expressions can be indexed by\n writing a square-bracket-enclosed expression (the index) after them. When the\n array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can\n@@ -2823,13 +2574,6 @@ _panicked state_.\n \n ### Range expressions\n \n-```{.ebnf .gram}\n-range_expr : expr \"..\" expr |\n-             expr \"..\" |\n-             \"..\" expr |\n-             \"..\" ;\n-```\n-\n The `..` operator will construct an object of one of the `std::ops::Range` variants.\n \n ```\n@@ -2872,10 +2616,6 @@ before the expression they apply to.\n \n ### Binary operator expressions\n \n-```{.ebnf .gram}\n-binop_expr : expr binop expr ;\n-```\n-\n Binary operators expressions are given in terms of [operator\n precedence](#operator-precedence).\n \n@@ -3036,10 +2776,6 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression. Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-```{.ebnf .gram}\n-paren_expr : '(' expr ')' ;\n-```\n-\n An example of a parenthesized expression:\n \n ```\n@@ -3049,12 +2785,6 @@ let x: i32 = (2 + 3) * 4;\n \n ### Call expressions\n \n-```{.ebnf .gram}\n-expr_list : [ expr [ ',' expr ]* ] ? ;\n-paren_expr_list : '(' expr_list ')' ;\n-call_expr : expr paren_expr_list ;\n-```\n-\n A _call expression_ invokes a function, providing zero or more input variables\n and an optional location to move the function's output into. If the function\n eventually returns, then the expression completes.\n@@ -3070,11 +2800,6 @@ let pi: Result<f32, _> = \"3.14\".parse();\n \n ### Lambda expressions\n \n-```{.ebnf .gram}\n-ident_list : [ ident [ ',' ident ]* ] ? ;\n-lambda_expr : '|' ident_list '|' expr ;\n-```\n-\n A _lambda expression_ (sometimes called an \"anonymous function expression\")\n defines a function and denotes it as a value, in a single expression. A lambda\n expression is a pipe-symbol-delimited (`|`) list of identifiers followed by an\n@@ -3118,10 +2843,6 @@ ten_times(|j| println!(\"hello, {}\", j));\n \n A `loop` expression denotes an infinite loop.\n \n-```{.ebnf .gram}\n-loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n-```\n-\n A `loop` expression may optionally have a _label_. The label is written as\n a lifetime preceding the loop expression, as in `'foo: loop{ }`. If a\n label is present, then labeled `break` and `continue` expressions nested\n@@ -3131,10 +2852,6 @@ expressions](#continue-expressions).\n \n ### Break expressions\n \n-```{.ebnf .gram}\n-break_expr : \"break\" [ lifetime ];\n-```\n-\n A `break` expression has an optional _label_. If the label is absent, then\n executing a `break` expression immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop. If the label is\n@@ -3143,10 +2860,6 @@ be the innermost label enclosing the `break` expression, but must enclose it.\n \n ### Continue expressions\n \n-```{.ebnf .gram}\n-continue_expr : \"continue\" [ lifetime ];\n-```\n-\n A `continue` expression has an optional _label_. If the label is absent, then\n executing a `continue` expression immediately terminates the current iteration\n of the innermost loop enclosing it, returning control to the loop *head*. In\n@@ -3160,10 +2873,6 @@ A `continue` expression is only permitted in the body of a loop.\n \n ### While loops\n \n-```{.ebnf .gram}\n-while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n A `while` loop begins by evaluating the boolean loop conditional expression.\n If the loop conditional expression evaluates to `true`, the loop body block\n executes and control returns to the loop conditional expression. If the loop\n@@ -3187,26 +2896,22 @@ loops](#infinite-loops), [break expressions](#break-expressions), and\n \n ### For expressions\n \n-```{.ebnf .gram}\n-for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n A `for` expression is a syntactic construct for looping over elements provided\n-by an implementation of `std::iter::Iterator`.\n+by an implementation of `std::iter::IntoIterator`.\n \n An example of a for loop over the contents of an array:\n \n ```\n # type Foo = i32;\n-# fn bar(f: Foo) { }\n+# fn bar(f: &Foo) { }\n # let a = 0;\n # let b = 0;\n # let c = 0;\n \n let v: &[Foo] = &[a, b, c];\n \n-for e in v.iter() {\n-    bar(*e);\n+for e in v {\n+    bar(e);\n }\n ```\n \n@@ -3226,14 +2931,6 @@ loops](#infinite-loops), [break expressions](#break-expressions), and\n \n ### If expressions\n \n-```{.ebnf .gram}\n-if_expr : \"if\" no_struct_literal_expr '{' block '}'\n-          else_tail ? ;\n-\n-else_tail : \"else\" [ if_expr | if_let_expr\n-                   | '{' block '}' ] ;\n-```\n-\n An `if` expression is a conditional branch in program control. The form of an\n `if` expression is a condition expression, followed by a consequent block, any\n number of `else if` conditions and blocks, and an optional trailing `else`\n@@ -3246,14 +2943,6 @@ if` condition is evaluated. If all `if` and `else if` conditions evaluate to\n \n ### Match expressions\n \n-```{.ebnf .gram}\n-match_expr : \"match\" no_struct_literal_expr '{' match_arm * '}' ;\n-\n-match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n-\n-match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n-```\n-\n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n literals, destructured arrays or enum constructors, structures and tuples,\n@@ -3370,23 +3059,13 @@ let message = match maybe_digit {\n \n ### If let expressions\n \n-```{.ebnf .gram}\n-if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n-               else_tail ? ;\n-else_tail : \"else\" [ if_expr | if_let_expr | '{' block '}' ] ;\n-```\n-\n An `if let` expression is semantically identical to an `if` expression but in place\n of a condition expression it expects a refutable let statement. If the value of the\n expression on the right hand side of the let statement matches the pattern, the corresponding\n block will execute, otherwise flow proceeds to the first `else` block that follows.\n \n ### While let loops\n \n-```{.ebnf .gram}\n-while_let_expr : \"while\" \"let\" pat '=' expr '{' block '}' ;\n-```\n-\n A `while let` loop is semantically identical to a `while` loop but in place of a\n condition expression it expects a refutable let statement. If the value of the\n expression on the right hand side of the let statement matches the pattern, the\n@@ -3395,10 +3074,6 @@ Otherwise, the while expression completes.\n \n ### Return expressions\n \n-```{.ebnf .gram}\n-return_expr : \"return\" expr ? ;\n-```\n-\n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n expression moves its argument into the designated output location for the\n current function call, destroys the current function activation frame, and"}, {"sha": "695dc42cb6418a7d9694fe07f48235009bcf8c5d", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -36,7 +36,6 @@\n     * [Strings](strings.md)\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n-    * [Operators and Overloading](operators-and-overloading.md)\n     * [Drop](drop.md)\n     * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n@@ -50,6 +49,7 @@\n     * [Casting between types](casting-between-types.md)\n     * [Associated Types](associated-types.md)\n     * [Unsized Types](unsized-types.md)\n+    * [Operators and Overloading](operators-and-overloading.md)\n     * [Deref coercions](deref-coercions.md)\n     * [Macros](macros.md)\n     * [Raw Pointers](raw-pointers.md)"}, {"sha": "b7011100971a88a8a4b96bad37bf7934a9714080", "filename": "src/doc/trpl/deref-coercions.md", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fderef-coercions.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -1,3 +1,119 @@\n % `Deref` coercions\n \n-Coming soon!\n+The standard library provides a special trait, [`Deref`][deref]. It\u2019s normally\n+used to overload `*`, the dereference operator:\n+\n+```rust\n+use std::ops::Deref;\n+\n+struct DerefExample<T> {\n+    value: T,\n+}\n+\n+impl<T> Deref for DerefExample<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+fn main() {\n+    let x = DerefExample { value: 'a' };\n+    assert_eq!('a', *x);\n+}\n+```\n+\n+[deref]: ../std/ops/trait.Deref.html\n+\n+This is useful for writing custom pointer types. However, there\u2019s a language\n+feature related to `Deref`: \u2018deref coercions\u2019. Here\u2019s the rule: If you have a\n+type `U`, and it implements `Deref<Target=T>`, values of `&U` will\n+automatically coerce to a `&T`. Here\u2019s an example:\n+\n+```rust\n+fn foo(s: &str) {\n+    // borrow a string for a second\n+}\n+\n+// String implements Deref<Target=str>\n+let owned = \"Hello\".to_string();\n+\n+// therefore, this works:\n+foo(&owned);\n+```\n+\n+Using an ampersand in front of a value takes a reference to it. So `owned` is a\n+`String`, `&owned` is an `&String`, and since `impl Deref<Target=str> for\n+String`, `&String` will deref to `&str`, which `foo()` takes.\n+\n+That\u2019s it. This rule is one of the only places in which Rust does an automatic\n+conversion for you, but it adds a lot of flexibility. For example, the `Rc<T>`\n+type implements `Deref<Target=T>`, so this works:\n+\n+```rust\n+use std::rc::Rc;\n+\n+fn foo(s: &str) {\n+    // borrow a string for a second\n+}\n+\n+// String implements Deref<Target=str>\n+let owned = \"Hello\".to_string();\n+let counted = Rc::new(owned);\n+\n+// therefore, this works:\n+foo(&counted);\n+```\n+\n+All we\u2019ve done is wrap our `String` in an `Rc<T>`. But we can now pass the\n+`Rc<String>` around anywhere we\u2019d have a `String`. The signature of `foo`\n+didn\u2019t change, but works just as well with either type. This example has two\n+conversions: `Rc<String>` to `String` and then `String` to `&str`. Rust will do\n+this as many times as possible until the types match.\n+\n+Another very common implementation provided by the standard library is:\n+\n+```rust\n+fn foo(s: &[i32]) {\n+    // borrow a slice for a second\n+}\n+\n+// Vec<T> implements Deref<Target=[T]>\n+let owned = vec![1, 2, 3];\n+\n+foo(&owned);\n+```\n+\n+Vectors can `Deref` to a slice.\n+\n+## Deref and method calls\n+\n+`Deref` will also kick in when calling a method. In other words, these are\n+the same two things in Rust:\n+\n+```rust\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) { println!(\"Foo\"); }\n+}\n+\n+let f = Foo;\n+\n+f.foo();\n+```\n+\n+Even though `f` isn\u2019t a reference, and `foo` takes `&self`, this works.\n+That\u2019s because these things are the same:\n+\n+```rust,ignore\n+f.foo();\n+(&f).foo();\n+(&&f).foo();\n+(&&&&&&&&f).foo();\n+```\n+\n+A value of type `&&&&&&&&&&&&&&&&Foo` can still have methods defined on `Foo`\n+called, because the compiler will insert as many * operations as necessary to\n+get it right. And since it\u2019s inserting `*`s, that uses `Deref`."}, {"sha": "1445d39fe873876f48632571c306282c8f1eb155", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -18,7 +18,7 @@ foo.bar().baz();\n Luckily, as you may have guessed with the leading question, you can! Rust provides\n the ability to use this \u2018method call syntax\u2019 via the `impl` keyword.\n \n-## Method calls\n+# Method calls\n \n Here\u2019s how it works:\n \n@@ -83,7 +83,7 @@ impl Circle {\n }\n ```\n \n-## Chaining method calls\n+# Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n@@ -127,7 +127,7 @@ fn grow(&self) -> Circle {\n We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n-## Static methods\n+# Static methods\n \n You can also define methods that do not take a `self` parameter. Here\u2019s a\n pattern that\u2019s very common in Rust code:\n@@ -158,7 +158,7 @@ This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n-## Builder Pattern\n+# Builder Pattern\n \n Let\u2019s say that we want our users to be able to create Circles, but we will\n allow them to only set the properties they care about. Otherwise, the `x`"}, {"sha": "e7506dfe4fd7dc5c850c59c1c5f07843f800b1e3", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -1,3 +1,179 @@\n % Mutability\n \n-Coming Soon\n+Mutability, the ability to change something, works a bit differently in Rust\n+than in other languages. The first aspect of mutability is its non-default\n+status:\n+\n+```rust,ignore\n+let x = 5;\n+x = 6; // error!\n+```\n+\n+We can introduce mutability with the `mut` keyword:\n+\n+```rust\n+let mut x = 5;\n+\n+x = 6; // no problem!\n+```\n+\n+This is a mutable [variable binding][vb]. When a binding is mutable, it means\n+you\u2019re allowed to change what the binding points to. So in the above example,\n+it\u2019s not so much that the value at `x` is changing, but that the binding\n+changed from one `i32` to another.\n+\n+[vb]: variable-bindings.html\n+\n+If you want to change what the binding points to, you\u2019ll need a [mutable reference][mr]:\n+\n+```rust\n+let mut x = 5;\n+let y = &mut x;\n+```\n+\n+[mr]: references-and-borrowing.html\n+\n+`y` is an immutable binding to a mutable reference, which means that you can\u2019t\n+bind `y` to something else (`y = &mut z`), but you can mutate the thing that\u2019s\n+bound to `y`. (`*y = 5`) A subtle distinction.\n+\n+Of course, if you need both:\n+\n+```rust\n+let mut x = 5;\n+let mut y = &mut x;\n+```\n+\n+Now `y` can be bound to another value, and the value it\u2019s referencing can be\n+changed.\n+\n+It\u2019s important to note that `mut` is part of a [pattern][pattern], so you\n+can do things like this:\n+\n+```rust\n+let (mut x, y) = (5, 6);\n+\n+fn foo(mut x: i32) {\n+# }\n+```\n+\n+[pattern]: patterns.html\n+\n+# Interior vs. Exterior Mutability\n+\n+However, when we say something is \u2018immutable\u2019 in Rust, that doesn\u2019t mean that\n+it\u2019s not able to be changed: We mean something has \u2018exterior mutability\u2019. Consider,\n+for example, [`Arc<T>`][arc]:\n+\n+```rust\n+use std::sync::Arc;\n+\n+let x = Arc::new(5);\n+let y = x.clone();\n+```\n+\n+[arc]: ../std/sync/struct.Arc.html\n+\n+When we call `clone()`, the `Arc<T>` needs to update the reference count. Yet\n+we\u2019ve not used any `mut`s here, `x` is an immutable binding, and we didn\u2019t take\n+`&mut 5` or anything. So what gives?\n+\n+To this, we have to go back to the core of Rust\u2019s guiding philosophy, memory\n+safety, and the mechanism by which Rust guarantees it, the\n+[ownership][ownership] system, and more specifically, [borrowing][borrowing]:\n+\n+> You may have one or the other of these two kinds of borrows, but not both at\n+> the same time:\n+> \n+> * 0 to N references (`&T`) to a resource.\n+> * exactly one mutable reference (`&mut T`)\n+\n+[ownership]: ownership.html\n+[borrowing]: borrowing.html#The-Rules\n+\n+So, that\u2019s the real definition of \u2018immutability\u2019: is this safe to have two\n+pointers to? In `Arc<T>`\u2019s case, yes: the mutation is entirely contained inside\n+the structure itself. It\u2019s not user facing. For this reason, it hands out `&T`\n+with `clone()`. If it handed out `&mut T`s, though, that would be a problem.\n+\n+Other types, like the ones in the [`std::cell`][stdcell] module, have the\n+opposite: interior mutability. For example:\n+\n+```rust\n+use std::cell::RefCell;\n+\n+let x = RefCell::new(42);\n+\n+let y = x.borrow_mut();\n+```\n+\n+[stdcell]: ../std/cell/index.html\n+\n+RefCell hands out `&mut` references to what\u2019s inside of it with the\n+`borrow_mut()` method. Isn\u2019t that dangerous? What if we do:\n+\n+```rust,ignore\n+use std::cell::RefCell;\n+\n+let x = RefCell::new(42);\n+\n+let y = x.borrow_mut();\n+let z = x.borrow_mut();\n+# (y, z);\n+```\n+\n+This will in fact panic, at runtime. This is what `RefCell` does: it enforces\n+Rust\u2019s borrowing rules at runtime, and `panic!`s if they\u2019re violated. This\n+allows us to get around another aspect of Rust\u2019s mutability rules. Let\u2019s talk\n+about it first.\n+\n+## Field-level mutability\n+\n+Mutabilty is a property of either a borrow (`&mut`) or a binding (`let mut`).\n+This means that, for example, you cannot have a [`struct`][struct] with\n+some fields mutable and some immutable:\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    mut y: i32, // nope\n+}\n+```\n+\n+The mutability of a struct is in its binding:\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+let mut a = Point { x: 5, y: 6 };\n+\n+a.x = 10;\n+\n+let b = Point { x: 5, y: 6};\n+\n+b.x = 10; // error: cannot assign to immutable field `b.x`\n+```\n+\n+[struct]: structs.html\n+\n+However, by using `Cell<T>`, you can emulate field-level mutability:\n+\n+```\n+use std::cell::Cell;\n+\n+struct Point {\n+    x: i32,\n+    y: Cell<i32>,\n+}\n+\n+let mut point = Point { x: 5, y: Cell::new(6) };\n+\n+point.y.set(7);\n+\n+println!(\"y: {:?}\", point.y);\n+```\n+\n+This will print `y: Cell { value: 7 }`. We\u2019ve successfully updated `y`."}, {"sha": "6a594659c37d27617cc7899c542de54977c21f9a", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -1,3 +1,83 @@\n % Operators and Overloading\n \n-Coming soon!\n+Rust allows for a limited form of operator overloading. There are certain\n+operators that are able to be overloaded. To support a particular operator\n+between types, there\u2019s a specific trait that you can implement, which then\n+overloads the operator.\n+\n+For example, the `+` operator can be overloaded with the `Add` trait:\n+\n+```rust\n+use std::ops::Add;\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+impl Add for Point {\n+    type Output = Point;\n+\n+    fn add(self, other: Point) -> Point {\n+        Point { x: self.x + other.x, y: self.y + other.y }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point { x: 1, y: 0 };\n+    let p2 = Point { x: 2, y: 3 };\n+\n+    let p3 = p1 + p2;\n+\n+    println!(\"{:?}\", p3);\n+}\n+```\n+\n+In `main`, we can use `+` on our two `Point`s, since we\u2019ve implemented\n+`Add<Output=Point>` for `Point`.\n+\n+There are a number of operators that can be overloaded this way, and all of\n+their associated traits live in the [`std::ops`][stdops] module. Check out its\n+documentation for the full list.\n+\n+[stdops]: ../std/ops/index.html\n+\n+Implementing these traits follows a pattern. Let\u2019s look at [`Add`][add] in more\n+detail:\n+\n+```rust\n+# mod foo {\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+# }\n+```\n+\n+[add]: ../std/ops/trait.Add.html\n+\n+There\u2019s three types in total involved here: the type you `impl Add` for, `RHS`,\n+which defaults to `Self`, and `Output`. For an expression `let z = x + y`, `x`\n+is the `Self` type, `y` is the RHS, and `z` is the `Self::Output` type.\n+\n+```rust\n+# struct Point;\n+# use std::ops::Add;\n+impl Add<i32> for Point {\n+    type Output = f64;\n+\n+    fn add(self, rhs: i32) -> f64 {\n+        // add an i32 to a Point and get an f64\n+# 1.0\n+    }\n+}\n+```\n+\n+will let you do this:\n+\n+```rust,ignore\n+let p: Point = // ...\n+let x: f64 = p + 2i32;\n+```"}, {"sha": "4480a7d7e0a09fbe2be418082d6a9b9ee8b32f6f", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -394,14 +394,71 @@\n //!\n //! ## Precision\n //!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the\n-//! resulting string is longer than this width, then it is truncated down to\n-//! this many characters and only those are emitted.\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and only those are\n+//! emitted.\n //!\n //! For integral types, this has no meaning currently.\n //!\n-//! For floating-point types, this indicates how many digits after the decimal\n-//! point should be printed.\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//! 1. An integer `.N`,\n+//! 2. an integer followed by dollar sign `.N$`, or\n+//! 3. an asterisk `.*`.\n+//!\n+//! The first specification, `.N`, means the integer `N` itself is the precision.\n+//!\n+//! The second, `.N$`, means use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! Finally,  `.*` means that this `{...}` is associated with *two* format inputs rather than one:\n+//! the first input holds the `usize` precision, and the second holds the value to print.  Note\n+//! that in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part\n+//! refers to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, these:\n+//!\n+//! ```\n+//! // Hello {arg 0 (x)} is {arg 1 (0.01} with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (x)} is {arg 2 (0.01} with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (x)} is {arg 2 (0.01} with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (x)} is {second of next two args (0.01} with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (x)} is {arg 2 (0.01} with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//! ```\n+//!\n+//! All print the same thing:\n+//!\n+//! ```text\n+//! Hello x is 0.01000\n+//! ```\n+//!\n+//! While these:\n+//!\n+//! ```\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n+//!\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! ```\n //!\n //! # Escaping\n //!"}, {"sha": "d9cda58d9ebedd6e364bffe388e4c5979b43c8d6", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -11,7 +11,7 @@\n //! Traits for conversions between types.\n //!\n //! The traits in this module provide a general way to talk about conversions from one type to\n-//! another. They follow the standard Rust conventions of `as`/`to`/`into`/`from`.\n+//! another. They follow the standard Rust conventions of `as`/`into`/`from`.\n //!\n //! Like many traits, these are often used as bounds for generic functions, to support arguments of\n //! multiple types."}, {"sha": "fa95f667c15afc1d1119bf49b1ee19abd7ef8b03", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -394,7 +394,7 @@ impl<'a> Context<'a> {\n                                are reserved for internal compiler diagnostics\");\n         } else if name.starts_with(\"derive_\") {\n             self.gate_feature(\"custom_derive\", attr.span,\n-                              \"attributes of the form `#[derive_*]` are reserved\n+                              \"attributes of the form `#[derive_*]` are reserved \\\n                                for the compiler\");\n         } else {\n             self.gate_feature(\"custom_attribute\", attr.span,\n@@ -620,7 +620,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   pattern.span,\n                                   \"multiple-element slice matches anywhere \\\n                                    but at the end of a slice (e.g. \\\n-                                   `[0, ..xs, 0]` are experimental\")\n+                                   `[0, ..xs, 0]`) are experimental\")\n             }\n             ast::PatVec(..) => {\n                 self.gate_feature(\"slice_patterns\","}, {"sha": "26303d13b6cfcb61542d1d46ff45d29186a405a1", "filename": "src/rustbook/javascript.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Frustbook%2Fjavascript.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Frustbook%2Fjavascript.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fjavascript.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -52,7 +52,7 @@ document.addEventListener(\"DOMContentLoaded\", function(event) {\n   }\n \n   for (var i = 0; i < toc.length; i++) {\n-    if (toc[i].attributes['href'].value === href) {\n+    if (toc[i].attributes['href'].value.split('/').pop() === href) {\n       var nav = document.createElement('p');\n       if (i > 0) {\n         var prevNode = toc[i-1].cloneNode(true);"}, {"sha": "7dc654fe1c8d569f0c5ec3916d13da4da449e80d", "filename": "src/test/compile-fail/feature-gate-negate-unsigned.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that negating unsigned integers is gated by `negate_unsigned` feature\n+// gate\n+\n+const MAX: usize = -1;\n+//~^ ERROR unary negation of unsigned integers may be removed in the future\n+\n+fn main() {}"}, {"sha": "5d32bba6a766cad91161e33872501c1c0da817f6", "filename": "src/test/compile-fail/feature-gate-on-unimplemented.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-on-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-on-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-on-unimplemented.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `#[rustc_on_unimplemented]` is gated by `on_unimplemented` feature\n+// gate.\n+\n+#[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}`\"]\n+//~^ ERROR the `#[rustc_on_unimplemented]` attribute is an experimental feature\n+trait Foo<Bar>\n+{}\n+\n+fn main() {}"}, {"sha": "59d7473a741d6297f1d20c2d4633636a4a4cf1d6", "filename": "src/test/compile-fail/feature-gate-optin-builtin-traits.rs", "status": "renamed", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-optin-builtin-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-optin-builtin-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-optin-builtin-traits.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -8,20 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that the use of smid types in the ffi is gated by `smid_ffi` feature gate.\n+// Test that default and negative trait implementations are gated by\n+// `optin_builtin_traits` feature gate\n \n-#![feature(simd)]\n+struct DummyStruct;\n \n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-#[simd]\n-pub struct f32x4(f32, f32, f32, f32);\n-\n-#[allow(dead_code)]\n-extern {\n-    fn foo(x: f32x4);\n-    //~^ ERROR use of SIMD type `f32x4` in FFI is highly experimental and may result in invalid code\n-    //~| HELP add #![feature(simd_ffi)] to the crate attributes to enable\n+trait DummyTrait {\n+    fn dummy(&self) {}\n }\n \n+impl DummyTrait for .. {}\n+//~^ ERROR default trait implementations are experimental and possibly buggy\n+\n+impl !DummyTrait for DummyStruct {}\n+//~^ ERROR negative trait bounds are not yet fully implemented; use marker types for now\n+\n fn main() {}", "previous_filename": "src/test/compile-fail/gated-simd-ffi.rs"}, {"sha": "3b5d7626ce309aab0247d5b32ce9c5cc4b8256cf", "filename": "src/test/compile-fail/feature-gate-plugin.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-plugin.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `#![plugin(...)]` attribute is gated by `plugin` feature gate\n+\n+#![plugin(foo)]\n+//~^ ERROR compiler plugins are experimental and possibly buggy\n+\n+fn main() {}"}, {"sha": "dab44b655fce82a5e788a818c202c5f8dae7dc20", "filename": "src/test/compile-fail/feature-gate-rustc-attrs.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Test that `#[rustc_*]` attributes are gated by `rustc_attrs` feature gate.\n+\n+#[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is an experimental feature\n+#[rustc_error] //~ ERROR the `#[rustc_error]` attribute is an experimental feature\n+#[rustc_move_fragments] //~ ERROR the `#[rustc_move_fragments]` attribute is an experimental feature\n+#[rustc_foo]\n+//~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n+\n+fn main() {}"}, {"sha": "8286d833e8d22cd2000af6243629feee8c87df95", "filename": "src/test/compile-fail/feature-gate-rustc-diagnostic-macros.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-diagnostic-macros.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that diagnostic macros are gated by `rustc_diagnostic_macros` feature\n+// gate\n+\n+__register_diagnostic!(E0001);\n+//~^ ERROR macro undefined: '__register_diagnostic!'\n+\n+fn main() {\n+    __diagnostic_used!(E0001);\n+    //~^ ERROR macro undefined: '__diagnostic_used!'\n+}\n+\n+__build_diagnostic_array!(DIAGNOSTICS);\n+//~^ ERROR macro undefined: '__build_diagnostic_array!'"}, {"sha": "625cb2d351553709b9c7dac7379c2b4ec7ebdb88", "filename": "src/test/compile-fail/feature-gate-slice-patterns.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40261ac91dd80b21830cc94de6132744e0c5078/src%2Ftest%2Fcompile-fail%2Ffeature-gate-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-slice-patterns.rs?ref=a40261ac91dd80b21830cc94de6132744e0c5078", "patch": "@@ -8,14 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that patterns including the box syntax are gated by `box_patterns` feature gate.\n+// Test that slice pattern syntax is gated by `slice_patterns` feature gate\n \n fn main() {\n-    let x = Box::new(1);\n-\n+    let x = [1, 2, 3, 4, 5];\n     match x {\n-        box 1 => (),\n-        //~^ box pattern syntax is experimental\n-        _     => ()\n-    };\n+        [1, 2, xs..] => {} //~ ERROR slice pattern syntax is experimental\n+    }\n }", "previous_filename": "src/test/compile-fail/gated-box-patterns.rs"}]}