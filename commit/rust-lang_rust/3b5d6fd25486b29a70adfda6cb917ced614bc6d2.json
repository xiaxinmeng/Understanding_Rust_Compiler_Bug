{"sha": "3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNWQ2ZmQyNTQ4NmIyOWE3MGFkZmRhNmNiOTE3Y2VkNjE0YmM2ZDI=", "commit": {"author": {"name": "Thomas Backman", "email": "serenity@exscape.org", "date": "2014-06-03T14:11:47Z"}, "committer": {"name": "Thomas Backman", "email": "serenity@exscape.org", "date": "2014-06-03T14:11:47Z"}, "message": "Add next_permutation and prev_permutation onto MutableOrdVector<T>.\n\nUnlike ImmutableClonableVector::permutations() which returns an iterator,\ncloning the entire array each iteration, these methods mutate the vector in-place.\nFor that reason, these methods are much faster; between 35-55 times faster,\ndepending on the benchmark. They also generate permutations in lexicographical order.", "tree": {"sha": "a0ddcc7a971f62d52d07bad9170eec327714fcb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0ddcc7a971f62d52d07bad9170eec327714fcb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "html_url": "https://github.com/rust-lang/rust/commit/3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b5d6fd25486b29a70adfda6cb917ced614bc6d2/comments", "author": {"login": "exscape", "id": 143653, "node_id": "MDQ6VXNlcjE0MzY1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/143653?v=4", "gravatar_id": "", "url": "https://api.github.com/users/exscape", "html_url": "https://github.com/exscape", "followers_url": "https://api.github.com/users/exscape/followers", "following_url": "https://api.github.com/users/exscape/following{/other_user}", "gists_url": "https://api.github.com/users/exscape/gists{/gist_id}", "starred_url": "https://api.github.com/users/exscape/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/exscape/subscriptions", "organizations_url": "https://api.github.com/users/exscape/orgs", "repos_url": "https://api.github.com/users/exscape/repos", "events_url": "https://api.github.com/users/exscape/events{/privacy}", "received_events_url": "https://api.github.com/users/exscape/received_events", "type": "User", "site_admin": false}, "committer": {"login": "exscape", "id": 143653, "node_id": "MDQ6VXNlcjE0MzY1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/143653?v=4", "gravatar_id": "", "url": "https://api.github.com/users/exscape", "html_url": "https://github.com/exscape", "followers_url": "https://api.github.com/users/exscape/followers", "following_url": "https://api.github.com/users/exscape/following{/other_user}", "gists_url": "https://api.github.com/users/exscape/gists{/gist_id}", "starred_url": "https://api.github.com/users/exscape/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/exscape/subscriptions", "organizations_url": "https://api.github.com/users/exscape/orgs", "repos_url": "https://api.github.com/users/exscape/repos", "events_url": "https://api.github.com/users/exscape/events{/privacy}", "received_events_url": "https://api.github.com/users/exscape/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "918dbfea60e84868537a1951ad38a782502d39c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/918dbfea60e84868537a1951ad38a782502d39c2", "html_url": "https://github.com/rust-lang/rust/commit/918dbfea60e84868537a1951ad38a782502d39c2"}], "stats": {"total": 142, "additions": 142, "deletions": 0}, "files": [{"sha": "8f66279a9a32f8079c5cd304324472862a943b26", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3b5d6fd25486b29a70adfda6cb917ced614bc6d2/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b5d6fd25486b29a70adfda6cb917ced614bc6d2/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "patch": "@@ -712,13 +712,103 @@ pub trait MutableOrdVector<T> {\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     fn sort(self);\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful, `false` if the slice is at the last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v = &mut [0, 1, 2];\n+    /// v.next_permutation();\n+    /// assert_eq!(v, &mut [0, 2, 1]);\n+    /// v.next_permutation();\n+    /// assert_eq!(v, &mut [1, 0, 2]);\n+    /// ```\n+    fn next_permutation(self) -> bool;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful, `false` if the slice is at the first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v = &mut [1, 0, 2];\n+    /// v.prev_permutation();\n+    /// assert_eq!(v, &mut [0, 2, 1]);\n+    /// v.prev_permutation();\n+    /// assert_eq!(v, &mut [0, 1, 2]);\n+    /// ```\n+    fn prev_permutation(self) -> bool;\n }\n \n impl<'a, T: Ord> MutableOrdVector<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n         self.sort_by(|a,b| a.cmp(b))\n     }\n+\n+    fn next_permutation(self) -> bool {\n+        // These cases only have 1 permutation each, so we can't do anything.\n+        if self.len() < 2 { return false; }\n+\n+        // Step 1: Identify the longest, rightmost weakly decreasing part of the vector\n+        let mut i = self.len() - 1;\n+        while i > 0 && self[i-1] >= self[i] {\n+            i -= 1;\n+        }\n+\n+        // If that is the entire vector, this is the last-ordered permutation.\n+        if i == 0 {\n+            return false;\n+        }\n+\n+        // Step 2: Find the rightmost element larger than the pivot (i-1)\n+        let mut j = self.len() - 1;\n+        while j >= i && self[j] <= self[i-1]  {\n+            j -= 1;\n+        }\n+\n+        // Step 3: Swap that element with the pivot\n+        self.swap(j, i-1);\n+\n+        // Step 4: Reverse the (previously) weakly decreasing part\n+        self.mut_slice_from(i).reverse();\n+\n+        true\n+    }\n+\n+    fn prev_permutation(self) -> bool {\n+        // These cases only have 1 permutation each, so we can't do anything.\n+        if self.len() < 2 { return false; }\n+\n+        // Step 1: Identify the longest, rightmost weakly increasing part of the vector\n+        let mut i = self.len() - 1;\n+        while i > 0 && self[i-1] <= self[i] {\n+            i -= 1;\n+        }\n+\n+        // If that is the entire vector, this is the first-ordered permutation.\n+        if i == 0 {\n+            return false;\n+        }\n+\n+        // Step 2: Reverse the weakly increasing part\n+        self.mut_slice_from(i).reverse();\n+\n+        // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n+        let mut j = self.len() - 1;\n+        while j >= i && self[j-1] < self[i-1]  {\n+            j -= 1;\n+        }\n+\n+        // Step 4: Swap that element with the pivot\n+        self.swap(i-1, j);\n+\n+        true\n+    }\n }\n \n /// Unsafe operations\n@@ -1229,6 +1319,58 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_lexicographic_permutations() {\n+        let v : &mut[int] = &mut[1, 2, 3, 4, 5];\n+        assert!(v.prev_permutation() == false);\n+        assert!(v.next_permutation());\n+        assert_eq!(v, &mut[1, 2, 3, 5, 4]);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[1, 2, 3, 4, 5]);\n+        assert!(v.next_permutation());\n+        assert!(v.next_permutation());\n+        assert_eq!(v, &mut[1, 2, 4, 3, 5]);\n+        assert!(v.next_permutation());\n+        assert_eq!(v, &mut[1, 2, 4, 5, 3]);\n+\n+        let v : &mut[int] = &mut[1, 0, 0, 0];\n+        assert!(v.next_permutation() == false);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[0, 1, 0, 0]);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[0, 0, 1, 0]);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[0, 0, 0, 1]);\n+        assert!(v.prev_permutation() == false);\n+    }\n+\n+    #[test]\n+    fn test_lexicographic_permutations_empty_and_short() {\n+        let empty : &mut[int] = &mut[];\n+        assert!(empty.next_permutation() == false);\n+        assert_eq!(empty, &mut[]);\n+        assert!(empty.prev_permutation() == false);\n+        assert_eq!(empty, &mut[]);\n+\n+        let one_elem : &mut[int] = &mut[4];\n+        assert!(one_elem.prev_permutation() == false);\n+        assert_eq!(one_elem, &mut[4]);\n+        assert!(one_elem.next_permutation() == false);\n+        assert_eq!(one_elem, &mut[4]);\n+\n+        let two_elem : &mut[int] = &mut[1, 2];\n+        assert!(two_elem.prev_permutation() == false);\n+        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem.next_permutation());\n+        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem.next_permutation() == false);\n+        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem.prev_permutation());\n+        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem.prev_permutation() == false);\n+        assert_eq!(two_elem, &mut[1, 2]);\n+    }\n+\n     #[test]\n     fn test_position_elem() {\n         assert!([].position_elem(&1).is_none());"}]}