{"sha": "b03502b35d111bef0399a66ab3cc765f0802e8ba", "node_id": "C_kwDOAAsO6NoAKGIwMzUwMmIzNWQxMTFiZWYwMzk5YTY2YWIzY2M3NjVmMDgwMmU4YmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-30T05:22:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-30T05:22:37Z"}, "message": "Auto merge of #103721 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nNoteworthy PRs:\n- https://github.com/rust-lang/miri/pull/2624\n- https://github.com/rust-lang/miri/pull/2626\n- https://github.com/rust-lang/miri/pull/2630\n- https://github.com/rust-lang/miri/pull/2631", "tree": {"sha": "83deb502ebc9f11c502945b0f7ad0e293b128409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83deb502ebc9f11c502945b0f7ad0e293b128409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b03502b35d111bef0399a66ab3cc765f0802e8ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b03502b35d111bef0399a66ab3cc765f0802e8ba", "html_url": "https://github.com/rust-lang/rust/commit/b03502b35d111bef0399a66ab3cc765f0802e8ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b03502b35d111bef0399a66ab3cc765f0802e8ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4827ceecb9ee9bc0508fecf7059bcc134ca187d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4827ceecb9ee9bc0508fecf7059bcc134ca187d0", "html_url": "https://github.com/rust-lang/rust/commit/4827ceecb9ee9bc0508fecf7059bcc134ca187d0"}, {"sha": "e729db172ad15010244780f450639587c6748ee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e729db172ad15010244780f450639587c6748ee1", "html_url": "https://github.com/rust-lang/rust/commit/e729db172ad15010244780f450639587c6748ee1"}], "stats": {"total": 420, "additions": 346, "deletions": 74}, "files": [{"sha": "3efb2d733d426a8627f8b916983e11de2051f29b", "filename": "src/tools/miri/.github/workflows/ci.yml", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2F.github%2Fworkflows%2Fci.yml?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -10,7 +10,7 @@ on:\n     branches:\n       - 'master'\n   schedule:\n-    - cron: '5 15 * * *' # At 15:05 UTC every day.\n+    - cron: '6 6 * * *' # At 6:06 UTC every day.\n \n env:\n   CARGO_UNSTABLE_SPARSE_REGISTRY: 'true'\n@@ -24,16 +24,12 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        build: [linux64, macos, win32]\n         include:\n-          - build: linux64\n-            os: ubuntu-latest\n+          - os: ubuntu-latest\n             host_target: x86_64-unknown-linux-gnu\n-          - build: macos\n-            os: macos-latest\n+          - os: macos-latest\n             host_target: x86_64-apple-darwin\n-          - build: win32\n-            os: windows-latest\n+          - os: windows-latest\n             host_target: i686-pc-windows-msvc\n     steps:\n       - uses: actions/checkout@v3"}, {"sha": "72b7b791a47e09c70eb45f925ac30597ddbc3372", "filename": "src/tools/miri/ci.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -93,6 +93,7 @@ case $HOST_TARGET in\n     ;;\n   i686-pc-windows-msvc)\n     MIRI_TEST_TARGET=x86_64-unknown-linux-gnu run_tests\n+    MIRI_TEST_TARGET=x86_64-pc-windows-gnu run_tests\n     ;;\n   *)\n     echo \"FATAL: unknown OS\""}, {"sha": "f55c0b43e39bc8d05f26592f2b8ef5c312afeceb", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -98,8 +98,8 @@ pub use crate::eval::{\n pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n-    ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n+    PrimitiveLayouts, Provenance, ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;"}, {"sha": "231a99c1d034ed0ef9316dc82271b3c471b1a607", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -276,10 +276,14 @@ pub struct PrimitiveLayouts<'tcx> {\n     pub i8: TyAndLayout<'tcx>,\n     pub i16: TyAndLayout<'tcx>,\n     pub i32: TyAndLayout<'tcx>,\n+    pub i64: TyAndLayout<'tcx>,\n+    pub i128: TyAndLayout<'tcx>,\n     pub isize: TyAndLayout<'tcx>,\n     pub u8: TyAndLayout<'tcx>,\n     pub u16: TyAndLayout<'tcx>,\n     pub u32: TyAndLayout<'tcx>,\n+    pub u64: TyAndLayout<'tcx>,\n+    pub u128: TyAndLayout<'tcx>,\n     pub usize: TyAndLayout<'tcx>,\n     pub bool: TyAndLayout<'tcx>,\n     pub mut_raw_ptr: TyAndLayout<'tcx>,   // *mut ()\n@@ -296,16 +300,42 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n             i8: layout_cx.layout_of(tcx.types.i8)?,\n             i16: layout_cx.layout_of(tcx.types.i16)?,\n             i32: layout_cx.layout_of(tcx.types.i32)?,\n+            i64: layout_cx.layout_of(tcx.types.i64)?,\n+            i128: layout_cx.layout_of(tcx.types.i128)?,\n             isize: layout_cx.layout_of(tcx.types.isize)?,\n             u8: layout_cx.layout_of(tcx.types.u8)?,\n             u16: layout_cx.layout_of(tcx.types.u16)?,\n             u32: layout_cx.layout_of(tcx.types.u32)?,\n+            u64: layout_cx.layout_of(tcx.types.u64)?,\n+            u128: layout_cx.layout_of(tcx.types.u128)?,\n             usize: layout_cx.layout_of(tcx.types.usize)?,\n             bool: layout_cx.layout_of(tcx.types.bool)?,\n             mut_raw_ptr: layout_cx.layout_of(mut_raw_ptr)?,\n             const_raw_ptr: layout_cx.layout_of(const_raw_ptr)?,\n         })\n     }\n+\n+    pub fn uint(&self, size: Size) -> Option<TyAndLayout<'tcx>> {\n+        match size.bits() {\n+            8 => Some(self.u8),\n+            16 => Some(self.u16),\n+            32 => Some(self.u32),\n+            64 => Some(self.u64),\n+            128 => Some(self.u128),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn int(&self, size: Size) -> Option<TyAndLayout<'tcx>> {\n+        match size.bits() {\n+            8 => Some(self.i8),\n+            16 => Some(self.i16),\n+            32 => Some(self.i32),\n+            64 => Some(self.i64),\n+            128 => Some(self.i128),\n+            _ => None,\n+        }\n+    }\n }\n \n /// The machine itself."}, {"sha": "6004e2078ad4fb6edf21e811f8c12daf25a8e1b4", "filename": "src/tools/miri/src/shims/intrinsics/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::{\n     mir,\n     ty::{self, FloatTy, Ty},\n };\n-use rustc_target::abi::Integer;\n+use rustc_target::abi::{Integer, Size};\n \n use crate::*;\n use atomic::EvalContextExt as _;\n@@ -120,6 +120,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.write_bytes_ptr(ptr, iter::repeat(val_byte).take(byte_count.bytes_usize()))?;\n             }\n \n+            \"ptr_mask\" => {\n+                let [ptr, mask] = check_arg_count(args)?;\n+\n+                let ptr = this.read_pointer(ptr)?;\n+                let mask = this.read_scalar(mask)?.to_machine_usize(this)?;\n+\n+                let masked_addr = Size::from_bytes(ptr.addr().bytes() & mask);\n+\n+                this.write_pointer(Pointer::new(ptr.provenance, masked_addr), dest)?;\n+            }\n+\n             // Floating-point operations\n             \"fabsf32\" => {\n                 let [f] = check_arg_count(args)?;"}, {"sha": "292b9d2e7a17626a5641bfbb1d3d5bc7c7d6065d", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,7 +1,7 @@\n+use std::time::SystemTime;\n+\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n-use rustc_target::abi::{Align, Size};\n-use std::time::SystemTime;\n \n /// Implementation of the SYS_futex syscall.\n /// `args` is the arguments *after* the syscall number.\n@@ -28,13 +28,14 @@ pub fn futex<'tcx>(\n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    let addr = this.read_immediate(&args[0])?;\n+    let addr = this.read_pointer(&args[0])?;\n     let op = this.read_scalar(&args[1])?.to_i32()?;\n     let val = this.read_scalar(&args[2])?.to_i32()?;\n \n     let thread = this.get_active_thread();\n-    let addr_scalar = addr.to_scalar();\n-    let addr_usize = addr_scalar.to_machine_usize(this)?;\n+    // This is a vararg function so we have to bring our own type for this pointer.\n+    let addr = MPlaceTy::from_aligned_ptr(addr, this.machine.layouts.i32);\n+    let addr_usize = addr.ptr.addr().bytes();\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n@@ -89,9 +90,11 @@ pub fn futex<'tcx>(\n             let timeout_time = if this.ptr_is_null(timeout.ptr)? {\n                 None\n             } else {\n-                this.check_no_isolation(\n-                    \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout\",\n-                )?;\n+                if op & futex_realtime != 0 {\n+                    this.check_no_isolation(\n+                        \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout with `FUTEX_CLOCK_REALTIME`\",\n+                    )?;\n+                }\n                 let duration = match this.read_timespec(&timeout)? {\n                     Some(duration) => duration,\n                     None => {\n@@ -117,15 +120,6 @@ pub fn futex<'tcx>(\n                     }\n                 })\n             };\n-            // Check the pointer for alignment and validity.\n-            // The API requires `addr` to be a 4-byte aligned pointer, and will\n-            // use the 4 bytes at the given address as an (atomic) i32.\n-            this.check_ptr_access_align(\n-                addr_scalar.to_pointer(this)?,\n-                Size::from_bytes(4),\n-                Align::from_bytes(4).unwrap(),\n-                CheckInAllocMsg::MemoryAccessTest,\n-            )?;\n             // There may be a concurrent thread changing the value of addr\n             // and then invoking the FUTEX_WAKE syscall. It is critical that the\n             // effects of this and the other thread are correctly observed,\n@@ -172,14 +166,7 @@ pub fn futex<'tcx>(\n             this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n-            let futex_val = this\n-                .read_scalar_at_offset_atomic(\n-                    &addr.into(),\n-                    0,\n-                    this.machine.layouts.i32,\n-                    AtomicReadOrd::Relaxed,\n-                )?\n-                .to_i32()?;\n+            let futex_val = this.read_scalar_atomic(&addr, AtomicReadOrd::Relaxed)?.to_i32()?;\n             if val == futex_val {\n                 // The value still matches, so we block the thread make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n@@ -214,11 +201,10 @@ pub fn futex<'tcx>(\n                         }\n                     }\n \n-                    let dest = dest.clone();\n                     this.register_timeout_callback(\n                         thread,\n                         timeout_time,\n-                        Box::new(Callback { thread, addr_usize, dest }),\n+                        Box::new(Callback { thread, addr_usize, dest: dest.clone() }),\n                     );\n                 }\n             } else {"}, {"sha": "221dc39697f9028147057f75318992c044be74a2", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -177,11 +177,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let thread = this.pthread_self()?;\n                 let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\")?.to_machine_usize(this)?;\n-                this.pthread_setname_np(\n+                let res = this.pthread_setname_np(\n                     thread,\n                     this.read_scalar(name)?,\n                     max_len.try_into().unwrap(),\n                 )?;\n+                // Contrary to the manpage, `pthread_setname_np` on macOS still\n+                // returns an integer indicating success.\n+                this.write_scalar(res, dest)?;\n             }\n             \"pthread_getname_np\" => {\n                 let [thread, name, len] ="}, {"sha": "fcb006920794c52da58e605e4a7a7270223d116f", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -743,8 +743,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`pthread_cond_timedwait`\")?;\n-\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n         let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n         let active_thread = this.get_active_thread();\n@@ -761,6 +759,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n+            this.check_no_isolation(\"`pthread_cond_timedwait` with `CLOCK_REALTIME`\")?;\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n             Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())"}, {"sha": "4b2a90723c79c44ff32e3bdcd4918be4053a2f36", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -6,12 +6,15 @@ use log::trace;\n \n use crate::helpers::check_arg_count;\n use crate::shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n+use crate::shims::windows::sync::EvalContextExt as _;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n     NtWriteFile,\n     SetThreadDescription,\n+    WaitOnAddress,\n+    WakeByAddressSingle,\n }\n \n impl Dlsym {\n@@ -22,6 +25,8 @@ impl Dlsym {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n             \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n+            \"WaitOnAddress\" => Some(Dlsym::WaitOnAddress),\n+            \"WakeByAddressSingle\" => Some(Dlsym::WakeByAddressSingle),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -127,6 +132,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 this.write_null(dest)?;\n             }\n+            Dlsym::WaitOnAddress => {\n+                let [ptr_op, compare_op, size_op, timeout_op] = check_arg_count(args)?;\n+\n+                this.WaitOnAddress(ptr_op, compare_op, size_op, timeout_op, dest)?;\n+            }\n+            Dlsym::WakeByAddressSingle => {\n+                let [ptr_op] = check_arg_count(args)?;\n+\n+                this.WakeByAddressSingle(ptr_op)?;\n+            }\n         }\n \n         trace!(\"{:?}\", this.dump_place(**dest));"}, {"sha": "8156ae8af1ef11128bc9d61a81709835d81bae32", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,3 +1,7 @@\n+use std::time::Duration;\n+\n+use rustc_target::abi::Size;\n+\n use crate::concurrency::init_once::InitOnceStatus;\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n@@ -6,7 +10,6 @@ const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-\n #[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n@@ -221,4 +224,105 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.eval_windows(\"c\", \"TRUE\")\n     }\n+\n+    fn WaitOnAddress(\n+        &mut self,\n+        ptr_op: &OpTy<'tcx, Provenance>,\n+        compare_op: &OpTy<'tcx, Provenance>,\n+        size_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+        let compare = this.read_pointer(compare_op)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(this)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+\n+        let thread = this.get_active_thread();\n+        let addr = ptr.addr().bytes();\n+\n+        if size > 8 || !size.is_power_of_two() {\n+            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\")?;\n+            this.set_last_error(invalid_param)?;\n+            this.write_scalar(Scalar::from_i32(0), dest)?;\n+            return Ok(());\n+        };\n+        let size = Size::from_bytes(size);\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap()))\n+        };\n+\n+        // See the Linux futex implementation for why this fence exists.\n+        this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n+\n+        let layout = this.machine.layouts.uint(size).unwrap();\n+        let futex_val = this\n+            .read_scalar_atomic(&MPlaceTy::from_aligned_ptr(ptr, layout), AtomicReadOrd::Relaxed)?;\n+        let compare_val = this.read_scalar(&MPlaceTy::from_aligned_ptr(compare, layout).into())?;\n+\n+        if futex_val == compare_val {\n+            // If the values are the same, we have to block.\n+            this.block_thread(thread);\n+            this.futex_wait(addr, thread, u32::MAX);\n+\n+            if let Some(timeout_time) = timeout_time {\n+                struct Callback<'tcx> {\n+                    thread: ThreadId,\n+                    addr: u64,\n+                    dest: PlaceTy<'tcx, Provenance>,\n+                }\n+\n+                impl<'tcx> VisitTags for Callback<'tcx> {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        let Callback { thread: _, addr: _, dest } = self;\n+                        dest.visit_tags(visit);\n+                    }\n+                }\n+\n+                impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                        this.unblock_thread(self.thread);\n+                        this.futex_remove_waiter(self.addr, self.thread);\n+                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                        this.set_last_error(error_timeout)?;\n+                        this.write_scalar(Scalar::from_i32(0), &self.dest)?;\n+\n+                        Ok(())\n+                    }\n+                }\n+\n+                this.register_timeout_callback(\n+                    thread,\n+                    timeout_time,\n+                    Box::new(Callback { thread, addr, dest: dest.clone() }),\n+                );\n+            }\n+        }\n+\n+        this.write_scalar(Scalar::from_i32(1), dest)?;\n+\n+        Ok(())\n+    }\n+\n+    fn WakeByAddressSingle(&mut self, ptr_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+\n+        // See the Linux futex implementation for why this fence exists.\n+        this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n+\n+        if let Some(thread) = this.futex_wake(ptr.addr().bytes(), u32::MAX) {\n+            this.unblock_thread(thread);\n+            this.unregister_timeout_callback_if_exists(thread);\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "163f46eacc19f52945ba0149e16a00da8e0ae064", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-preemption-rate=0\n use std::thread;\n "}, {"sha": "589f843cf82705ae401bcf591f27e42bbd08ad5f", "filename": "src/tools/miri/tests/fail/panic/no_std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fno_std.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -3,7 +3,7 @@\n // windows tls dtors go through libstd right now, thus this test\n // cannot pass. When windows tls dtors go through the special magic\n // windows linker section, we can run this test on windows again.\n-//@ignore-target-windows\n+//@ignore-target-windows: no-std not supported on Windows\n \n // Plumbing to let us use `writeln!` to host stderr:\n "}, {"sha": "103ce44006d3ad39ca76f8150716c7efcb392828", "filename": "src/tools/miri/tests/pass-dep/concurrency/libc_pthread_cond_isolated.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Flibc_pthread_cond_isolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Flibc_pthread_cond_isolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Flibc_pthread_cond_isolated.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -0,0 +1,82 @@\n+//@ignore-target-windows: No libc on Windows\n+//@ignore-target-apple: pthread_condattr_setclock is not supported on MacOS.\n+\n+/// Test that conditional variable timeouts are working properly\n+/// with monotonic clocks even under isolation.\n+use std::mem::MaybeUninit;\n+use std::time::Instant;\n+\n+fn test_timed_wait_timeout(clock_id: i32) {\n+    unsafe {\n+        let mut attr: MaybeUninit<libc::pthread_condattr_t> = MaybeUninit::uninit();\n+        assert_eq!(libc::pthread_condattr_init(attr.as_mut_ptr()), 0);\n+        assert_eq!(libc::pthread_condattr_setclock(attr.as_mut_ptr(), clock_id), 0);\n+\n+        let mut cond: MaybeUninit<libc::pthread_cond_t> = MaybeUninit::uninit();\n+        assert_eq!(libc::pthread_cond_init(cond.as_mut_ptr(), attr.as_ptr()), 0);\n+        assert_eq!(libc::pthread_condattr_destroy(attr.as_mut_ptr()), 0);\n+\n+        let mut mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n+\n+        let mut now_mu: MaybeUninit<libc::timespec> = MaybeUninit::uninit();\n+        assert_eq!(libc::clock_gettime(clock_id, now_mu.as_mut_ptr()), 0);\n+        let now = now_mu.assume_init();\n+        // Waiting for a second... mostly because waiting less requires mich more tricky arithmetic.\n+        // FIXME: wait less.\n+        let timeout = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: now.tv_nsec };\n+\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        let current_time = Instant::now();\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(cond.as_mut_ptr(), &mut mutex as *mut _, &timeout),\n+            libc::ETIMEDOUT\n+        );\n+        let elapsed_time = current_time.elapsed().as_millis();\n+        assert!(900 <= elapsed_time && elapsed_time <= 1300);\n+\n+        // Test calling `pthread_cond_timedwait` again with an already elapsed timeout.\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(cond.as_mut_ptr(), &mut mutex as *mut _, &timeout),\n+            libc::ETIMEDOUT\n+        );\n+\n+        // Test that invalid nanosecond values (above 10^9 or negative) are rejected with the\n+        // correct error code.\n+        let invalid_timeout_1 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: 1_000_000_000 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                cond.as_mut_ptr(),\n+                &mut mutex as *mut _,\n+                &invalid_timeout_1\n+            ),\n+            libc::EINVAL\n+        );\n+        let invalid_timeout_2 = libc::timespec { tv_sec: now.tv_sec + 1, tv_nsec: -1 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                cond.as_mut_ptr(),\n+                &mut mutex as *mut _,\n+                &invalid_timeout_2\n+            ),\n+            libc::EINVAL\n+        );\n+        // Test that invalid second values (negative) are rejected with the correct error code.\n+        let invalid_timeout_3 = libc::timespec { tv_sec: -1, tv_nsec: 0 };\n+        assert_eq!(\n+            libc::pthread_cond_timedwait(\n+                cond.as_mut_ptr(),\n+                &mut mutex as *mut _,\n+                &invalid_timeout_3\n+            ),\n+            libc::EINVAL\n+        );\n+\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_cond_destroy(cond.as_mut_ptr()), 0);\n+    }\n+}\n+\n+fn main() {\n+    test_timed_wait_timeout(libc::CLOCK_MONOTONIC);\n+}"}, {"sha": "904ae2fb17f9b3080449234ea6c41cc25a6c8aaa", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -87,7 +87,7 @@ fn test_posix_realpath_errors() {\n     assert_eq!(e.kind(), ErrorKind::NotFound);\n }\n \n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_posix_fadvise() {\n     use std::convert::TryInto;\n     use std::io::Write;\n@@ -115,7 +115,7 @@ fn test_posix_fadvise() {\n     assert_eq!(result, 0);\n }\n \n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_sync_file_range() {\n     use std::io::Write;\n \n@@ -181,7 +181,7 @@ fn test_thread_local_errno() {\n }\n \n /// Tests whether clock support exists at all\n-#[cfg(any(target_os = \"linux\"))]\n+#[cfg(target_os = \"linux\")]\n fn test_clocks() {\n     let mut tp = std::mem::MaybeUninit::<libc::timespec>::uninit();\n     let is_error = unsafe { libc::clock_gettime(libc::CLOCK_REALTIME, tp.as_mut_ptr()) };\n@@ -283,23 +283,21 @@ fn test_posix_mkstemp() {\n }\n \n fn main() {\n-    #[cfg(any(target_os = \"linux\"))]\n-    test_posix_fadvise();\n-\n     test_posix_gettimeofday();\n     test_posix_mkstemp();\n \n     test_posix_realpath_alloc();\n     test_posix_realpath_noalloc();\n     test_posix_realpath_errors();\n \n-    #[cfg(any(target_os = \"linux\"))]\n-    test_sync_file_range();\n-\n     test_thread_local_errno();\n \n-    #[cfg(any(target_os = \"linux\"))]\n-    test_clocks();\n-\n     test_isatty();\n+\n+    #[cfg(target_os = \"linux\")]\n+    {\n+        test_posix_fadvise();\n+        test_sync_file_range();\n+        test_clocks();\n+    }\n }"}, {"sha": "09dd92564d39a42de2a79a140ec36b9b738d978e", "filename": "src/tools/miri/tests/pass-dep/shims/pthreads.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,6 +1,6 @@\n //@ignore-target-windows: No libc on Windows\n #![feature(cstr_from_bytes_until_nul)]\n-use std::ffi::CStr;\n+use std::ffi::{CStr, CString};\n use std::thread;\n \n fn main() {\n@@ -10,7 +10,7 @@ fn main() {\n     test_rwlock_libc_static_initializer();\n     test_named_thread_truncation();\n \n-    #[cfg(any(target_os = \"linux\"))]\n+    #[cfg(target_os = \"linux\")]\n     test_mutex_libc_static_initializer_recursive();\n }\n \n@@ -135,18 +135,30 @@ fn test_named_thread_truncation() {\n         .chain(std::iter::repeat(\" yada\").take(100))\n         .collect::<String>();\n \n+    fn set_thread_name(name: &CStr) -> i32 {\n+        #[cfg(target_os = \"linux\")]\n+        return unsafe { libc::pthread_setname_np(libc::pthread_self(), name.as_ptr().cast()) };\n+        #[cfg(target_os = \"macos\")]\n+        return unsafe { libc::pthread_setname_np(name.as_ptr().cast()) };\n+    }\n+\n     let result = thread::Builder::new().name(long_name.clone()).spawn(move || {\n         // Rust remembers the full thread name itself.\n         assert_eq!(thread::current().name(), Some(long_name.as_str()));\n \n         // But the system is limited -- make sure we successfully set a truncation.\n         let mut buf = vec![0u8; long_name.len() + 1];\n         unsafe {\n-            libc::pthread_getname_np(libc::pthread_self(), buf.as_mut_ptr().cast(), buf.len());\n-        }\n+            libc::pthread_getname_np(libc::pthread_self(), buf.as_mut_ptr().cast(), buf.len())\n+        };\n         let cstr = CStr::from_bytes_until_nul(&buf).unwrap();\n         assert!(cstr.to_bytes().len() >= 15); // POSIX seems to promise at least 15 chars\n         assert!(long_name.as_bytes().starts_with(cstr.to_bytes()));\n+\n+        // Also test directly calling pthread_setname to check its return value.\n+        assert_eq!(set_thread_name(&cstr), 0);\n+        // But with a too long name it should fail.\n+        assert_ne!(set_thread_name(&CString::new(long_name).unwrap()), 0);\n     });\n     result.unwrap().join().unwrap();\n }"}, {"sha": "53b57942d76a4d27bb75e19fa4283bdb8bfc213f", "filename": "src/tools/miri/tests/pass/concurrency/channels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::sync::mpsc::{channel, sync_channel};"}, {"sha": "44b16e1ac74d46b5efada9acf830bcbe9eea5738", "filename": "src/tools/miri/tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n // This specifically tests behavior *without* preemption.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "b1518a49fbb1b8b6e158d4a081aedf8722498a26", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance\n \n use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};\n@@ -225,14 +224,26 @@ fn park_unpark() {\n }\n \n fn main() {\n-    check_barriers();\n-    check_conditional_variables_notify_one();\n-    check_conditional_variables_timed_wait_timeout();\n-    check_conditional_variables_timed_wait_notimeout();\n     check_mutex();\n     check_rwlock_write();\n     check_rwlock_read_no_deadlock();\n     check_once();\n     park_timeout();\n     park_unpark();\n+\n+    if !cfg!(windows) {\n+        // ignore-target-windows: Condvars on Windows are not supported yet\n+        check_barriers();\n+        check_conditional_variables_notify_one();\n+        check_conditional_variables_timed_wait_timeout();\n+        check_conditional_variables_timed_wait_notimeout();\n+    } else {\n+        // We need to fake the same output...\n+        for _ in 0..10 {\n+            println!(\"before wait\");\n+        }\n+        for _ in 0..10 {\n+            println!(\"after wait\");\n+        }\n+    }\n }"}, {"sha": "55206f4bfc526f008aebf4383a81224ef40ab422", "filename": "src/tools/miri/tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n "}, {"sha": "bf004012e8489113f1d3d9909c5c1fee1db4b5d7", "filename": "src/tools/miri/tests/pass/concurrency/thread_park_isolated.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_park_isolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_park_isolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_park_isolated.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -0,0 +1,12 @@\n+//@ignore-target-apple: park_timeout on macOS uses the system clock\n+use std::thread;\n+use std::time::{Duration, Instant};\n+\n+fn main() {\n+    let start = Instant::now();\n+\n+    thread::park_timeout(Duration::from_millis(200));\n+\n+    // Thanks to deterministic execution, this will wiat *exactly* 200ms (rounded to 1ms).\n+    assert!((200..201).contains(&start.elapsed().as_millis()));\n+}"}, {"sha": "eb0e860e68ebffb642c09b6d19d7d8e30942b846", "filename": "src/tools/miri/tests/pass/no_std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -3,7 +3,7 @@\n // windows tls dtors go through libstd right now, thus this test\n // cannot pass. When windows tls dtors go through the special magic\n // windows linker section, we can run this test on windows again.\n-//@ignore-target-windows\n+//@ignore-target-windows: no-std not supported on Windows\n \n // Plumbing to let us use `writeln!` to host stdout:\n "}, {"sha": "3f1153d265d7e144cc007ea263f845e3f1d685d2", "filename": "src/tools/miri/tests/pass/shims/env/current_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_exe.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows\n+//@ignore-target-windows: current_exe not supported on Windows\n //@only-on-host: the Linux std implementation opens /proc/self/exe, which doesn't work cross-target\n //@compile-flags: -Zmiri-disable-isolation\n use std::env;"}, {"sha": "fb8bb6b13dbc2cda484c3656493d712afbcba027", "filename": "src/tools/miri/tests/pass/shims/ptr_mask.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fptr_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fptr_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fptr_mask.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -0,0 +1,18 @@\n+#![feature(ptr_mask)]\n+#![feature(strict_provenance)]\n+\n+fn main() {\n+    let v: u32 = 0xABCDABCD;\n+    let ptr: *const u32 = &v;\n+\n+    // u32 is 4 aligned,\n+    // so the lower `log2(4) = 2` bits of the address are always 0\n+    assert_eq!(ptr.addr() & 0b11, 0);\n+\n+    let tagged_ptr = ptr.map_addr(|a| a | 0b11);\n+    let tag = tagged_ptr.addr() & 0b11;\n+    let masked_ptr = tagged_ptr.mask(!0b11);\n+\n+    assert_eq!(tag, 0b11);\n+    assert_eq!(unsafe { *masked_ptr }, 0xABCDABCD);\n+}"}, {"sha": "c94f63a54274a481a51a8fa46ea8f4972b398e61", "filename": "src/tools/miri/tests/pass/shims/sleep_long.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fsleep_long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fsleep_long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fsleep_long.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: no threads nor sleep on Windows\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-disable-isolation\n use std::sync::{Arc, Mutex};\n use std::thread;"}, {"sha": "a5f81573e963d48d50d100a20730470f8cf0d0e0", "filename": "src/tools/miri/tests/pass/threadleak_ignored.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03502b35d111bef0399a66ab3cc765f0802e8ba/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs?ref=b03502b35d111bef0399a66ab3cc765f0802e8ba", "patch": "@@ -1,6 +1,4 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n-// FIXME: disallow preemption to work around https://github.com/rust-lang/rust/issues/55005\n-//@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-ignore-leaks\n \n //! Test that leaking threads works, and that their destructors are not executed.\n "}]}