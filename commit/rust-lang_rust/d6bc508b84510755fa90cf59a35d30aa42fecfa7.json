{"sha": "d6bc508b84510755fa90cf59a35d30aa42fecfa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YmM1MDhiODQ1MTA3NTVmYTkwY2Y1OWEzNWQzMGFhNDJmZWNmYTc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-08T17:21:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-08T17:21:28Z"}, "message": "Merge pull request #122 from oli-obk/master\n\nprevent more deallocations of statics", "tree": {"sha": "3d2f55257cc819884b6ebb5d3cbecd00ef139f5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d2f55257cc819884b6ebb5d3cbecd00ef139f5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6bc508b84510755fa90cf59a35d30aa42fecfa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bc508b84510755fa90cf59a35d30aa42fecfa7", "html_url": "https://github.com/rust-lang/rust/commit/d6bc508b84510755fa90cf59a35d30aa42fecfa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6bc508b84510755fa90cf59a35d30aa42fecfa7/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f3fc85525731af4c8e8f80ed938864fc2d08a82", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3fc85525731af4c8e8f80ed938864fc2d08a82", "html_url": "https://github.com/rust-lang/rust/commit/4f3fc85525731af4c8e8f80ed938864fc2d08a82"}, {"sha": "4beb774caac83e3a80662c7f141b16cce0404cb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4beb774caac83e3a80662c7f141b16cce0404cb1", "html_url": "https://github.com/rust-lang/rust/commit/4beb774caac83e3a80662c7f141b16cce0404cb1"}], "stats": {"total": 102, "additions": 90, "deletions": 12}, "files": [{"sha": "dedb8a53b718bf69722062fd14ea006b0e574030", "filename": "src/eval_context.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=d6bc508b84510755fa90cf59a35d30aa42fecfa7", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n-        self.memory.mark_static(ptr.alloc_id, false)?;\n+        self.memory.mark_static_initalized(ptr.alloc_id, false)?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n \n@@ -194,9 +194,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Str(ref s) => return self.str_to_value(s),\n \n             ByteStr(ref bs) => {\n+                // FIXME: cache these allocs\n                 let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n-                self.memory.mark_static(ptr.alloc_id, false)?;\n+                self.memory.mark_static_initalized(ptr.alloc_id, false)?;\n                 PrimVal::Ptr(ptr)\n             }\n \n@@ -316,19 +317,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let global_value = self.globals.get_mut(&id)\n                     .expect(\"global should have been cached (static)\");\n                 match global_value.value {\n-                    Value::ByRef(ptr) => self.memory.mark_static(ptr.alloc_id, mutable)?,\n+                    Value::ByRef(ptr) => self.memory.mark_static_initalized(ptr.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.mark_static(ptr.alloc_id, mutable)?;\n+                        self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n+                            self.memory.mark_static_initalized(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n+                // see comment on `initialized` field\n+                assert!(!global_value.initialized);\n+                global_value.initialized = true;\n                 assert!(global_value.mutable);\n                 global_value.mutable = mutable;\n             } else {\n@@ -867,8 +871,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n+                        self.memory.mark_static(ptr.alloc_id);\n                         self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n-                        self.memory.mark_static(ptr.alloc_id, global_val.mutable)?;\n+                        // see comment on `initialized` field\n+                        if global_val.initialized {\n+                            self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n+                        }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n                             value: Value::ByRef(ptr),"}, {"sha": "d54c27904763c0442c01735d90daa8537b17b042", "filename": "src/lvalue.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=d6bc508b84510755fa90cf59a35d30aa42fecfa7", "patch": "@@ -57,6 +57,11 @@ pub struct GlobalId<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub struct Global<'tcx> {\n     pub(super) value: Value,\n+    /// Only used in `force_allocation` to ensure we don't mark the memory\n+    /// before the static is initialized. It is possible to convert a\n+    /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n+    /// lifted to an allocation before the static is fully initialized\n+    pub(super) initialized: bool,\n     pub(super) mutable: bool,\n     pub(super) ty: Ty<'tcx>,\n }\n@@ -102,6 +107,7 @@ impl<'tcx> Global<'tcx> {\n             value: Value::ByVal(PrimVal::Undef),\n             mutable: true,\n             ty,\n+            initialized: false,\n         }\n     }\n }"}, {"sha": "cbef71c68f6da6b9f767e056431134e9a72ef427", "filename": "src/memory.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d6bc508b84510755fa90cf59a35d30aa42fecfa7", "patch": "@@ -38,7 +38,7 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n-    /// Use the `mark_static` method of `Memory` to ensure that an error occurs, if the memory of this\n+    /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     pub static_kind: StaticKind,\n }\n@@ -152,6 +152,11 @@ impl<'tcx> Function<'tcx> {\n pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n+    /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from stepping\n+    /// out of its own allocations.\n+    /// This set only contains statics backed by an allocation. If they are ByVal or ByValPair they\n+    /// are not here, but will be inserted once they become ByRef.\n+    static_alloc: HashSet<AllocId>,\n     /// Number of virtual bytes allocated\n     memory_usage: u64,\n     /// Maximum number of virtual bytes that may be allocated\n@@ -189,6 +194,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             memory_size: max_memory,\n             memory_usage: 0,\n             packed: BTreeSet::new(),\n+            static_alloc: HashSet::new(),\n         }\n     }\n \n@@ -624,8 +630,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    /// mark an allocation as static, either mutable or not\n-    pub fn mark_static(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n+    /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n+    pub fn mark_static(&mut self, alloc_id: AllocId) {\n+        if alloc_id != NEVER_ALLOC_ID && alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n+            bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n+        }\n+    }\n+\n+    /// mark an allocation as static and initialized, either mutable or not\n+    pub fn mark_static_initalized(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n@@ -645,7 +658,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_static(alloc, mutable)?;\n+            // relocations into other statics are not \"inner allocations\"\n+            if !self.static_alloc.contains(&alloc) {\n+                self.mark_static_initalized(alloc, mutable)?;\n+            }\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "bfae608ecbc1013054a797253fd3d372b9f0abf0", "filename": "src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc508b84510755fa90cf59a35d30aa42fecfa7/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=d6bc508b84510755fa90cf59a35d30aa42fecfa7", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.mark_static(vtable.alloc_id, false)?;\n+        self.memory.mark_static_initalized(vtable.alloc_id, false)?;\n \n         Ok(vtable)\n     }"}, {"sha": "90160ebcdf94f856fcc7d4027e37b67e3f60f694", "filename": "tests/run-pass/issue-31267-additional.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc508b84510755fa90cf59a35d30aa42fecfa7/tests%2Frun-pass%2Fissue-31267-additional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc508b84510755fa90cf59a35d30aa42fecfa7/tests%2Frun-pass%2Fissue-31267-additional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-31267-additional.rs?ref=d6bc508b84510755fa90cf59a35d30aa42fecfa7", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]\n+\n+#![feature(associated_consts)]\n+\n+#[derive(Clone, Copy, Debug)]\n+struct Bar;\n+\n+const BAZ: Bar = Bar;\n+\n+#[derive(Debug)]\n+struct Foo([Bar; 1]);\n+\n+struct Biz;\n+\n+impl Biz {\n+    const BAZ: Foo = Foo([BAZ; 1]);\n+}\n+\n+fn main() {\n+    let foo = Biz::BAZ;\n+}"}, {"sha": "69b95f2cd7e10a2b9efd34e8823680d4cf9749da", "filename": "tests/run-pass/issue-5917.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6bc508b84510755fa90cf59a35d30aa42fecfa7/tests%2Frun-pass%2Fissue-5917.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bc508b84510755fa90cf59a35d30aa42fecfa7/tests%2Frun-pass%2Fissue-5917.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-5917.rs?ref=d6bc508b84510755fa90cf59a35d30aa42fecfa7", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+struct T (&'static [isize]);\n+static STATIC : T = T (&[5, 4, 3]);\n+pub fn main () {\n+    let T(ref v) = STATIC;\n+    assert_eq!(v[0], 5);\n+}"}]}