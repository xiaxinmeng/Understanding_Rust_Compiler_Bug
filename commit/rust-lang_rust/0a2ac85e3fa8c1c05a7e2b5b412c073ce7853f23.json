{"sha": "0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMmFjODVlM2ZhOGMxYzA1YTdlMmI1YjQxMmMwNzNjZTc4NTNmMjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-13T14:15:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-13T15:22:07Z"}, "message": "move `drain_fulfillment_cx_or_panic` to be private to traits::trans", "tree": {"sha": "371b5d0939788a614f0233dd9c1dc3ef1ff75035", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/371b5d0939788a614f0233dd9c1dc3ef1ff75035"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23", "html_url": "https://github.com/rust-lang/rust/commit/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4728e494e50a3c07ff3a7d3f16369903ac70d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4728e494e50a3c07ff3a7d3f16369903ac70d49", "html_url": "https://github.com/rust-lang/rust/commit/e4728e494e50a3c07ff3a7d3f16369903ac70d49"}], "stats": {"total": 84, "additions": 44, "deletions": 40}, "files": [{"sha": "fe919775da0b412a8e27280ca3b2bfed1d56e43a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23", "patch": "@@ -493,46 +493,6 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Finishes processes any obligations that remain in the\n-    /// fulfillment context, and then returns the result with all type\n-    /// variables removed and regions erased. Because this is intended\n-    /// for use after type-check has completed, if any errors occur,\n-    /// it will panic. It is used during normalization and other cases\n-    /// where processing the obligations in `fulfill_cx` may cause\n-    /// type inference variables that appear in `result` to be\n-    /// unified, and hence we need to process those obligations to get\n-    /// the complete picture of the type.\n-    pub fn drain_fulfillment_cx_or_panic<T>(&self,\n-                                            span: Span,\n-                                            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                            result: &T)\n-                                            -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n-    {\n-        debug!(\"drain_fulfillment_cx_or_panic()\");\n-\n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => { }\n-            Err(errors) => {\n-                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n-                          errors);\n-            }\n-        }\n-\n-        let result = self.resolve_type_vars_if_possible(result);\n-        let result = self.tcx.erase_regions(&result);\n-\n-        match self.tcx.lift_to_global(&result) {\n-            Some(result) => result,\n-            None => {\n-                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n-            }\n-        }\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }"}, {"sha": "86f9d168ad304f24e94fc3efdcc7798aa4a36d7a", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=0a2ac85e3fa8c1c05a7e2b5b412c073ce7853f23", "patch": "@@ -17,6 +17,8 @@ use dep_graph::{DepKind, DepTrackingMapConfig};\n use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n use hir::def_id::DefId;\n+use infer::InferCtxt;\n+use syntax_pos::Span;\n use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n@@ -151,3 +153,45 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n         DepKind::TraitSelect\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// Finishes processes any obligations that remain in the\n+    /// fulfillment context, and then returns the result with all type\n+    /// variables removed and regions erased. Because this is intended\n+    /// for use after type-check has completed, if any errors occur,\n+    /// it will panic. It is used during normalization and other cases\n+    /// where processing the obligations in `fulfill_cx` may cause\n+    /// type inference variables that appear in `result` to be\n+    /// unified, and hence we need to process those obligations to get\n+    /// the complete picture of the type.\n+    fn drain_fulfillment_cx_or_panic<T>(&self,\n+                                        span: Span,\n+                                        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+                                        result: &T)\n+                                        -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    {\n+        debug!(\"drain_fulfillment_cx_or_panic()\");\n+\n+        // In principle, we only need to do this so long as `result`\n+        // contains unbound type parameters. It could be a slight\n+        // optimization to stop iterating early.\n+        match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => { }\n+            Err(errors) => {\n+                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                          errors);\n+            }\n+        }\n+\n+        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.tcx.erase_regions(&result);\n+\n+        match self.tcx.lift_to_global(&result) {\n+            Some(result) => result,\n+            None => {\n+                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n+            }\n+        }\n+    }\n+}"}]}