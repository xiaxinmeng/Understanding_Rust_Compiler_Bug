{"sha": "697b335fdaf8d09d5f74b98641351624cad901a6", "node_id": "C_kwDOAAsO6NoAKDY5N2IzMzVmZGFmOGQwOWQ1Zjc0Yjk4NjQxMzUxNjI0Y2FkOTAxYTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-16T17:40:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-16T17:40:20Z"}, "message": "Auto merge of #14584 - Veykril:macro-def-err, r=Veykril\n\ninternal: Report item-level macro expansion syntax errors", "tree": {"sha": "939f5143304dcdb24923444aa2285894c38fb994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/939f5143304dcdb24923444aa2285894c38fb994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/697b335fdaf8d09d5f74b98641351624cad901a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/697b335fdaf8d09d5f74b98641351624cad901a6", "html_url": "https://github.com/rust-lang/rust/commit/697b335fdaf8d09d5f74b98641351624cad901a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/697b335fdaf8d09d5f74b98641351624cad901a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0a40c3a0e83c6f3fa50ae240577bd9899515bbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0a40c3a0e83c6f3fa50ae240577bd9899515bbc", "html_url": "https://github.com/rust-lang/rust/commit/f0a40c3a0e83c6f3fa50ae240577bd9899515bbc"}, {"sha": "0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4ffaa5afac3d5df27905cbab4630de4d8556ed", "html_url": "https://github.com/rust-lang/rust/commit/0f4ffaa5afac3d5df27905cbab4630de4d8556ed"}], "stats": {"total": 656, "additions": 329, "deletions": 327}, "files": [{"sha": "1d082d555478433a9c6e82eee828b832d68a8aef", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -21,7 +21,7 @@ use limit::Limit;\n use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, Parse, SyntaxNode, SyntaxNodePtr};\n \n use crate::{\n     attr::Attrs,\n@@ -137,7 +137,8 @@ impl Expander {\n         &mut self,\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n-    ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n+    ) -> Result<ExpandResult<Option<(Mark, Parse<T>)>>, UnresolvedMacro> {\n+        // FIXME: within_limit should support this, instead of us having to extract the error\n         let mut unresolved_macro_err = None;\n \n         let result = self.within_limit(db, |this| {\n@@ -146,22 +147,13 @@ impl Expander {\n             let resolver =\n                 |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n \n-            let mut err = None;\n-            let call_id = match macro_call.as_call_id_with_errors(\n-                db,\n-                this.def_map.krate(),\n-                resolver,\n-                &mut |e| {\n-                    err.get_or_insert(e);\n-                },\n-            ) {\n+            match macro_call.as_call_id_with_errors(db, this.def_map.krate(), resolver) {\n                 Ok(call_id) => call_id,\n                 Err(resolve_err) => {\n                     unresolved_macro_err = Some(resolve_err);\n-                    return ExpandResult { value: None, err: None };\n+                    ExpandResult { value: None, err: None }\n                 }\n-            };\n-            ExpandResult { value: call_id.ok(), err }\n+            }\n         });\n \n         if let Some(err) = unresolved_macro_err {\n@@ -175,37 +167,37 @@ impl Expander {\n         &mut self,\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n-    ) -> ExpandResult<Option<(Mark, T)>> {\n+    ) -> ExpandResult<Option<(Mark, Parse<T>)>> {\n         self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n     }\n \n     fn enter_expand_inner(\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n-        mut err: Option<ExpandError>,\n-    ) -> ExpandResult<Option<(HirFileId, SyntaxNode)>> {\n-        if err.is_none() {\n-            err = db.macro_expand_error(call_id);\n-        }\n-\n+        mut error: Option<ExpandError>,\n+    ) -> ExpandResult<Option<InFile<Parse<SyntaxNode>>>> {\n         let file_id = call_id.as_file();\n+        let ExpandResult { value, err } = db.parse_or_expand_with_err(file_id);\n+\n+        if error.is_none() {\n+            error = err;\n+        }\n \n-        let raw_node = match db.parse_or_expand_with_err(file_id) {\n-            // FIXME: report parse errors\n-            Some(it) => it.syntax_node(),\n+        let parse = match value {\n+            Some(it) => it,\n             None => {\n                 // Only `None` if the macro expansion produced no usable AST.\n-                if err.is_none() {\n+                if error.is_none() {\n                     tracing::warn!(\"no error despite `parse_or_expand` failing\");\n                 }\n \n-                return ExpandResult::only_err(err.unwrap_or_else(|| {\n+                return ExpandResult::only_err(error.unwrap_or_else(|| {\n                     ExpandError::Other(\"failed to parse macro invocation\".into())\n                 }));\n             }\n         };\n \n-        ExpandResult { value: Some((file_id, raw_node)), err }\n+        ExpandResult { value: Some(InFile::new(file_id, parse)), err: error }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n@@ -267,7 +259,7 @@ impl Expander {\n         &mut self,\n         db: &dyn DefDatabase,\n         op: F,\n-    ) -> ExpandResult<Option<(Mark, T)>>\n+    ) -> ExpandResult<Option<(Mark, Parse<T>)>>\n     where\n         F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n     {\n@@ -294,15 +286,15 @@ impl Expander {\n         };\n \n         Self::enter_expand_inner(db, call_id, err).map(|value| {\n-            value.and_then(|(new_file_id, node)| {\n-                let node = T::cast(node)?;\n+            value.and_then(|InFile { file_id, value }| {\n+                let parse = value.cast::<T>()?;\n \n                 self.recursion_depth += 1;\n-                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), new_file_id);\n-                let old_file_id = std::mem::replace(&mut self.current_file_id, new_file_id);\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, file_id);\n                 let mark =\n                     Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-                Some((mark, node))\n+                Some((mark, parse))\n             })\n         })\n     }"}, {"sha": "db619b97dbecc2b0efd1dd51c58907012b2df18b", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -824,7 +824,11 @@ impl ExprCollector<'_> {\n                     self.db.ast_id_map(self.expander.current_file_id),\n                 );\n \n-                let id = collector(self, Some(expansion));\n+                if record_diagnostics {\n+                    // FIXME: Report parse errors here\n+                }\n+\n+                let id = collector(self, Some(expansion.tree()));\n                 self.ast_id_map = prev_ast_id_map;\n                 self.expander.exit(self.db, mark);\n                 id"}, {"sha": "668b436e0196579289254e012c921335ff3e6c48", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n use intern::Interned;\n use smallvec::SmallVec;\n-use syntax::ast;\n+use syntax::{ast, Parse};\n \n use crate::{\n     attr::Attrs,\n@@ -604,13 +604,10 @@ impl<'a> AssocItemCollector<'a> {\n                             continue 'attrs;\n                         }\n                     }\n-                    match self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id) {\n-                        ExpandResult { value: Some((mark, _)), .. } => {\n-                            self.collect_macro_items(mark);\n-                            continue 'items;\n-                        }\n-                        ExpandResult { .. } => {}\n-                    }\n+\n+                    let res = self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id);\n+                    self.collect_macro_items(res, &|| loc.kind.clone());\n+                    continue 'items;\n                 }\n             }\n \n@@ -641,30 +638,52 @@ impl<'a> AssocItemCollector<'a> {\n                     self.items.push((item.name.clone(), def.into()));\n                 }\n                 AssocItem::MacroCall(call) => {\n-                    if let Some(root) =\n-                        self.db.parse_or_expand_with_err(self.expander.current_file_id())\n-                    {\n-                        // FIXME: report parse errors\n-                        let root = root.syntax_node();\n-\n+                    let file_id = self.expander.current_file_id();\n+                    let root = self.db.parse_or_expand(file_id);\n+                    if let Some(root) = root {\n                         let call = &item_tree[call];\n \n-                        let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n-                        let call = ast_id_map.get(call.ast_id).to_node(&root);\n-                        let _cx =\n-                            stdx::panic_context::enter(format!(\"collect_items MacroCall: {call}\"));\n-                        let res = self.expander.enter_expand::<ast::MacroItems>(self.db, call);\n-\n-                        if let Ok(ExpandResult { value: Some((mark, _)), .. }) = res {\n-                            self.collect_macro_items(mark);\n+                        let ast_id_map = self.db.ast_id_map(file_id);\n+                        let macro_call = ast_id_map.get(call.ast_id).to_node(&root);\n+                        let _cx = stdx::panic_context::enter(format!(\n+                            \"collect_items MacroCall: {macro_call}\"\n+                        ));\n+                        if let Ok(res) =\n+                            self.expander.enter_expand::<ast::MacroItems>(self.db, macro_call)\n+                        {\n+                            self.collect_macro_items(res, &|| hir_expand::MacroCallKind::FnLike {\n+                                ast_id: InFile::new(file_id, call.ast_id),\n+                                expand_to: hir_expand::ExpandTo::Items,\n+                            });\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn collect_macro_items(&mut self, mark: Mark) {\n+    fn collect_macro_items(\n+        &mut self,\n+        ExpandResult { value, err }: ExpandResult<Option<(Mark, Parse<ast::MacroItems>)>>,\n+        error_call_kind: &dyn Fn() -> hir_expand::MacroCallKind,\n+    ) {\n+        let Some((mark, parse)) = value else { return };\n+\n+        if let Some(err) = err {\n+            self.inactive_diagnostics.push(DefDiagnostic::macro_error(\n+                self.module_id.local_id,\n+                error_call_kind(),\n+                err.to_string(),\n+            ));\n+        }\n+        if let errors @ [_, ..] = parse.errors() {\n+            self.inactive_diagnostics.push(DefDiagnostic::macro_expansion_parse_error(\n+                self.module_id.local_id,\n+                error_call_kind(),\n+                errors.into(),\n+            ));\n+        }\n+\n         let tree_id = item_tree::TreeId::new(self.expander.current_file_id(), None);\n         let item_tree = tree_id.item_tree(self.db);\n         let iter: SmallVec<[_; 2]> ="}, {"sha": "c1e20d657bd720a16dec3608e902c24569232fef", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -350,7 +350,7 @@ impl GenericParams {\n                 match expander.enter_expand::<ast::Type>(db, macro_call) {\n                     Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n                         let ctx = expander.ctx(db);\n-                        let type_ref = TypeRef::from_ast(&ctx, expanded);\n+                        let type_ref = TypeRef::from_ast(&ctx, expanded.tree());\n                         self.fill_implicit_impl_trait_args(db, expander, &type_ref);\n                         expander.exit(db, mark);\n                     }"}, {"sha": "48c1baf3081b306e67962a3699ccf58753254604", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -101,6 +101,7 @@ pub struct ItemTree {\n     top_level: SmallVec<[ModItem; 1]>,\n     attrs: FxHashMap<AttrOwner, RawAttrs>,\n \n+    // FIXME: Remove this indirection, an item tree is almost always non-empty?\n     data: Option<Box<ItemTreeData>>,\n }\n "}, {"sha": "34d704942abcaa10e144ce0f909313528a096203", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -65,11 +65,11 @@ use hir_expand::{\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n-    eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n+    eager::expand_eager_macro,\n     hygiene::Hygiene,\n     proc_macro::ProcMacroExpander,\n-    AstId, ExpandError, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n-    MacroDefKind, UnresolvedMacro,\n+    AstId, ExpandError, ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind,\n+    MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n use item_tree::ExternBlock;\n use la_arena::Idx;\n@@ -795,16 +795,15 @@ pub trait AsMacroCall {\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n-        self.as_call_id_with_errors(db, krate, resolver, &mut |_| ()).ok()?.ok()\n+        self.as_call_id_with_errors(db, krate, resolver).ok()?.value\n     }\n \n     fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        error_sink: &mut dyn FnMut(ExpandError),\n-    ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro>;\n+    ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro>;\n }\n \n impl AsMacroCall for InFile<&ast::MacroCall> {\n@@ -813,30 +812,23 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        mut error_sink: &mut dyn FnMut(ExpandError),\n-    ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+    ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n         let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n         let path =\n             self.value.path().and_then(|path| path::ModPath::from_src(db.upcast(), path, &h));\n \n-        let path = match error_sink\n-            .option(path, || ExpandError::Other(\"malformed macro invocation\".into()))\n-        {\n-            Ok(path) => path,\n-            Err(error) => {\n-                return Ok(Err(error));\n-            }\n+        let Some(path) = path else {\n+            return Ok(ExpandResult::only_err(ExpandError::Other(\"malformed macro invocation\".into())));\n         };\n \n-        macro_call_as_call_id(\n+        macro_call_as_call_id_(\n             db,\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n             expands_to,\n             krate,\n             resolver,\n-            error_sink,\n         )\n     }\n }\n@@ -860,21 +852,33 @@ fn macro_call_as_call_id(\n     expand_to: ExpandTo,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-    error_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<Option<MacroCallId>, UnresolvedMacro> {\n+    macro_call_as_call_id_(db, call, expand_to, krate, resolver).map(|res| res.value)\n+}\n+\n+fn macro_call_as_call_id_(\n+    db: &dyn db::DefDatabase,\n+    call: &AstIdWithPath<ast::MacroCall>,\n+    expand_to: ExpandTo,\n+    krate: CrateId,\n+    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n     let def =\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;\n \n     let res = if let MacroDefKind::BuiltInEager(..) = def.kind {\n         let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db.upcast()));\n \n-        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver, error_sink)?\n+        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver)?\n     } else {\n-        Ok(def.as_lazy_macro(\n-            db.upcast(),\n-            krate,\n-            MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n-        ))\n+        ExpandResult {\n+            value: Some(def.as_lazy_macro(\n+                db.upcast(),\n+                krate,\n+                MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n+            )),\n+            err: None,\n+        }\n     };\n     Ok(res)\n }"}, {"sha": "73a495d89bfde59c6d069d69448c25d667028aaf", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -125,21 +125,15 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n \n     for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         let macro_call = InFile::new(source.file_id, &macro_call);\n-        let mut error = None;\n-        let macro_call_id = macro_call\n-            .as_call_id_with_errors(\n-                &db,\n-                krate,\n-                |path| {\n-                    resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n-                },\n-                &mut |err| error = Some(err),\n-            )\n-            .unwrap()\n+        let res = macro_call\n+            .as_call_id_with_errors(&db, krate, |path| {\n+                resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n+            })\n             .unwrap();\n+        let macro_call_id = res.value.unwrap();\n         let macro_file = MacroFile { macro_call_id };\n         let mut expansion_result = db.parse_macro_expansion(macro_file);\n-        expansion_result.err = expansion_result.err.or(error);\n+        expansion_result.err = expansion_result.err.or(res.err);\n         expansions.push((macro_call.value.clone(), expansion_result, db.macro_arg(macro_call_id)));\n     }\n "}, {"sha": "6592c6b90249d1e353a7235409b813c2e2ae1454", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -16,8 +16,8 @@ use hir_expand::{\n     builtin_fn_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId,\n-    MacroDefKind,\n+    ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc,\n+    MacroDefId, MacroDefKind,\n };\n use itertools::{izip, Itertools};\n use la_arena::Idx;\n@@ -1116,10 +1116,10 @@ impl DefCollector<'_> {\n                         *expand_to,\n                         self.def_map.krate,\n                         resolver_def_id,\n-                        &mut |_err| (),\n                     );\n-                    if let Ok(Ok(call_id)) = call_id {\n+                    if let Ok(Some(call_id)) = call_id {\n                         push_resolved(directive, call_id);\n+\n                         res = ReachedFixedPoint::No;\n                         return false;\n                     }\n@@ -1355,26 +1355,30 @@ impl DefCollector<'_> {\n         let file_id = macro_call_id.as_file();\n \n         // First, fetch the raw expansion result for purposes of error reporting. This goes through\n-        // `macro_expand_error` to avoid depending on the full expansion result (to improve\n+        // `parse_macro_expansion_error` to avoid depending on the full expansion result (to improve\n         // incrementality).\n-        let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n-        let err = self.db.macro_expand_error(macro_call_id);\n+        let ExpandResult { value, err } = self.db.parse_macro_expansion_error(macro_call_id);\n         if let Some(err) = err {\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n             let diag = match err {\n+                // why is this reported here?\n                 hir_expand::ExpandError::UnresolvedProcMacro(krate) => {\n                     always!(krate == loc.def.krate);\n-                    // Missing proc macros are non-fatal, so they are handled specially.\n                     DefDiagnostic::unresolved_proc_macro(module_id, loc.kind.clone(), loc.def.krate)\n                 }\n-                _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n+                _ => DefDiagnostic::macro_error(module_id, loc.kind.clone(), err.to_string()),\n             };\n \n             self.def_map.diagnostics.push(diag);\n         }\n+        if let Some(errors) = value {\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n+            let diag = DefDiagnostic::macro_expansion_parse_error(module_id, loc.kind, &errors);\n+            self.def_map.diagnostics.push(diag);\n+        }\n \n         // Then, fetch and process the item tree. This will reuse the expansion result from above.\n         let item_tree = self.db.file_item_tree(file_id);\n-        // FIXME: report parse errors for the macro expansion here\n \n         let mod_dir = self.mod_dirs[&module_id].clone();\n         ModCollector {\n@@ -1396,6 +1400,7 @@ impl DefCollector<'_> {\n         for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n+                    // FIXME: we shouldn't need to re-resolve the macro here just to get the unresolved error!\n                     let macro_call_as_call_id = macro_call_as_call_id(\n                         self.db,\n                         ast_id,\n@@ -1414,7 +1419,6 @@ impl DefCollector<'_> {\n                                 .take_macros()\n                                 .map(|it| macro_id_to_def_id(self.db, it))\n                         },\n-                        &mut |_| (),\n                     );\n                     if let Err(UnresolvedMacro { path }) = macro_call_as_call_id {\n                         self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n@@ -2112,8 +2116,7 @@ impl ModCollector<'_, '_> {\n         let ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, ModPath::clone(&mac.path));\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n-        let mut error = None;\n-        match macro_call_as_call_id(\n+        if let Ok(res) = macro_call_as_call_id(\n             self.def_collector.db,\n             &ast_id,\n             mac.expand_to,\n@@ -2133,41 +2136,19 @@ impl ModCollector<'_, '_> {\n                     )\n                 })\n             },\n-            &mut |err| {\n-                error.get_or_insert(err);\n-            },\n         ) {\n-            Ok(Ok(macro_call_id)) => {\n-                // Legacy macros need to be expanded immediately, so that any macros they produce\n-                // are in scope.\n+            // Legacy macros need to be expanded immediately, so that any macros they produce\n+            // are in scope.\n+            if let Some(val) = res {\n                 self.def_collector.collect_macro_expansion(\n                     self.module_id,\n-                    macro_call_id,\n+                    val,\n                     self.macro_depth + 1,\n                     container,\n                 );\n-\n-                if let Some(err) = error {\n-                    self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                        self.module_id,\n-                        MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n-                        err.to_string(),\n-                    ));\n-                }\n-\n-                return;\n             }\n-            Ok(Err(_)) => {\n-                // Built-in macro failed eager expansion.\n \n-                self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                    self.module_id,\n-                    MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n-                    error.unwrap().to_string(),\n-                ));\n-                return;\n-            }\n-            Err(UnresolvedMacro { .. }) => (),\n+            return;\n         }\n \n         // Case 2: resolve in module scope, expand during name resolution."}, {"sha": "6b922b5785b7bcb5c46d660001266bf3e586af64", "filename": "crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -4,7 +4,10 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::{attrs::AttrId, MacroCallKind};\n use la_arena::Idx;\n-use syntax::ast::{self, AnyHasAttrs};\n+use syntax::{\n+    ast::{self, AnyHasAttrs},\n+    SyntaxError,\n+};\n \n use crate::{\n     item_tree::{self, ItemTreeId},\n@@ -29,6 +32,8 @@ pub enum DefDiagnosticKind {\n \n     MacroError { ast: MacroCallKind, message: String },\n \n+    MacroExpansionParseError { ast: MacroCallKind, errors: Box<[SyntaxError]> },\n+\n     UnimplementedBuiltinMacro { ast: AstId<ast::Macro> },\n \n     InvalidDeriveTarget { ast: AstId<ast::Item>, id: usize },\n@@ -91,14 +96,28 @@ impl DefDiagnostic {\n         Self { in_module: container, kind: DefDiagnosticKind::UnresolvedProcMacro { ast, krate } }\n     }\n \n-    pub(super) fn macro_error(\n+    pub(crate) fn macro_error(\n         container: LocalModuleId,\n         ast: MacroCallKind,\n         message: String,\n     ) -> Self {\n         Self { in_module: container, kind: DefDiagnosticKind::MacroError { ast, message } }\n     }\n \n+    pub(crate) fn macro_expansion_parse_error(\n+        container: LocalModuleId,\n+        ast: MacroCallKind,\n+        errors: &[SyntaxError],\n+    ) -> Self {\n+        Self {\n+            in_module: container,\n+            kind: DefDiagnosticKind::MacroExpansionParseError {\n+                ast,\n+                errors: errors.to_vec().into_boxed_slice(),\n+            },\n+        }\n+    }\n+\n     pub(super) fn unresolved_macro_call(\n         container: LocalModuleId,\n         ast: MacroCallKind,"}, {"sha": "b07462cde0f19a706e9b6bff3116b4ab0323516b", "filename": "crates/hir-def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -140,7 +140,7 @@ m!(Z);\n         let n_recalculated_item_trees = events.iter().filter(|it| it.contains(\"item_tree\")).count();\n         assert_eq!(n_recalculated_item_trees, 6);\n         let n_reparsed_macros =\n-            events.iter().filter(|it| it.contains(\"parse_macro_expansion\")).count();\n+            events.iter().filter(|it| it.contains(\"parse_macro_expansion(\")).count();\n         assert_eq!(n_reparsed_macros, 3);\n     }\n "}, {"sha": "afc2be07418652bff02a4db58bef4b3a372e7227", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -9,7 +9,7 @@ use mbe::syntax_node_to_token_tree;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, HasAttrs, HasDocComments},\n-    AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, T,\n+    AstNode, GreenNode, Parse, SyntaxError, SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n@@ -100,7 +100,10 @@ pub trait ExpandDatabase: SourceDatabase {\n     #[salsa::transparent]\n     fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n     #[salsa::transparent]\n-    fn parse_or_expand_with_err(&self, file_id: HirFileId) -> Option<Parse<SyntaxNode>>;\n+    fn parse_or_expand_with_err(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> ExpandResult<Option<Parse<SyntaxNode>>>;\n     /// Implementation for the macro case.\n     fn parse_macro_expansion(\n         &self,\n@@ -129,15 +132,18 @@ pub trait ExpandDatabase: SourceDatabase {\n     /// just fetches procedural ones.\n     fn macro_def(&self, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError>;\n \n-    /// Expand macro call to a token tree. This query is LRUed (we keep 128 or so results in memory)\n+    /// Expand macro call to a token tree.\n     fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n     /// Special case of the previous query for procedural macros. We can't LRU\n     /// proc macros, since they are not deterministic in general, and\n     /// non-determinism breaks salsa in a very, very, very bad way. @edwin0cheng\n     /// heroically debugged this once!\n     fn expand_proc_macro(&self, call: MacroCallId) -> ExpandResult<tt::Subtree>;\n-    /// Firewall query that returns the error from the `macro_expand` query.\n-    fn macro_expand_error(&self, macro_call: MacroCallId) -> Option<ExpandError>;\n+    /// Firewall query that returns the errors from the `parse_macro_expansion` query.\n+    fn parse_macro_expansion_error(\n+        &self,\n+        macro_call: MacroCallId,\n+    ) -> ExpandResult<Option<Box<[SyntaxError]>>>;\n \n     fn hygiene_frame(&self, file_id: HirFileId) -> Arc<HygieneFrame>;\n }\n@@ -262,11 +268,11 @@ fn parse_or_expand(db: &dyn ExpandDatabase, file_id: HirFileId) -> Option<Syntax\n fn parse_or_expand_with_err(\n     db: &dyn ExpandDatabase,\n     file_id: HirFileId,\n-) -> Option<Parse<SyntaxNode>> {\n+) -> ExpandResult<Option<Parse<SyntaxNode>>> {\n     match file_id.repr() {\n-        HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).to_syntax()),\n+        HirFileIdRepr::FileId(file_id) => ExpandResult::ok(Some(db.parse(file_id).to_syntax())),\n         HirFileIdRepr::MacroFile(macro_file) => {\n-            db.parse_macro_expansion(macro_file).value.map(|(parse, _)| parse)\n+            db.parse_macro_expansion(macro_file).map(|it| it.map(|(parse, _)| parse))\n         }\n     }\n }\n@@ -279,25 +285,28 @@ fn parse_macro_expansion(\n     let mbe::ValueResult { value, err } = db.macro_expand(macro_file.macro_call_id);\n \n     if let Some(err) = &err {\n-        // Note:\n-        // The final goal we would like to make all parse_macro success,\n-        // such that the following log will not call anyway.\n-        let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-        let node = loc.kind.to_node(db);\n-\n-        // collect parent information for warning log\n-        let parents =\n-            std::iter::successors(loc.kind.file_id().call_node(db), |it| it.file_id.call_node(db))\n-                .map(|n| format!(\"{:#}\", n.value))\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\");\n-\n-        tracing::debug!(\n-            \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n-            err,\n-            node.value,\n-            parents\n-        );\n+        if tracing::enabled!(tracing::Level::DEBUG) {\n+            // Note:\n+            // The final goal we would like to make all parse_macro success,\n+            // such that the following log will not call anyway.\n+            let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+            let node = loc.kind.to_node(db);\n+\n+            // collect parent information for warning log\n+            let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n+                it.file_id.call_node(db)\n+            })\n+            .map(|n| format!(\"{:#}\", n.value))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+\n+            tracing::debug!(\n+                \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n+                err,\n+                node.value,\n+                parents\n+            );\n+        }\n     }\n     let tt = match value {\n         Some(tt) => tt,\n@@ -442,14 +451,14 @@ fn macro_def(\n fn macro_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n+    // FIXME: Remove the OPtion if possible\n ) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     let _p = profile::span(\"macro_expand\");\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     if let Some(eager) = &loc.eager {\n         return ExpandResult {\n             value: Some(eager.arg_or_expansion.clone()),\n-            // FIXME: There could be errors here!\n-            err: None,\n+            err: eager.error.clone(),\n         };\n     }\n \n@@ -466,7 +475,8 @@ fn macro_expand(\n         Ok(it) => it,\n         // FIXME: This is weird -- we effectively report macro *definition*\n         // errors lazily, when we try to expand the macro. Instead, they should\n-        // be reported at the definition site (when we construct a def map).\n+        // be reported at the definition site when we construct a def map.\n+        // (Note we do report them also at the definition site in the late diagnostic pass)\n         Err(err) => {\n             return ExpandResult::only_err(ExpandError::Other(\n                 format!(\"invalid macro definition: {err}\").into(),\n@@ -492,8 +502,12 @@ fn macro_expand(\n     ExpandResult { value: Some(Arc::new(tt)), err }\n }\n \n-fn macro_expand_error(db: &dyn ExpandDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n-    db.macro_expand(macro_call).err\n+fn parse_macro_expansion_error(\n+    db: &dyn ExpandDatabase,\n+    macro_call_id: MacroCallId,\n+) -> ExpandResult<Option<Box<[SyntaxError]>>> {\n+    db.parse_macro_expansion(MacroFile { macro_call_id })\n+        .map(|it| it.map(|(it, _)| it.errors().to_vec().into_boxed_slice()))\n }\n \n fn expand_proc_macro(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {"}, {"sha": "84f391316c664abac3db3235546897c66548f6d2", "filename": "crates/hir-expand/src/eager.rs", "status": "modified", "additions": 69, "deletions": 127, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Feager.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -21,7 +21,7 @@\n use std::sync::Arc;\n \n use base_db::CrateId;\n-use syntax::{ted, SyntaxNode};\n+use syntax::{ted, Parse, SyntaxNode};\n \n use crate::{\n     ast::{self, AstNode},\n@@ -32,77 +32,16 @@ use crate::{\n     MacroCallLoc, MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n \n-#[derive(Debug)]\n-pub struct ErrorEmitted {\n-    _private: (),\n-}\n-\n-pub trait ErrorSink {\n-    fn emit(&mut self, err: ExpandError);\n-\n-    fn option<T>(\n-        &mut self,\n-        opt: Option<T>,\n-        error: impl FnOnce() -> ExpandError,\n-    ) -> Result<T, ErrorEmitted> {\n-        match opt {\n-            Some(it) => Ok(it),\n-            None => {\n-                self.emit(error());\n-                Err(ErrorEmitted { _private: () })\n-            }\n-        }\n-    }\n-\n-    fn option_with<T>(\n-        &mut self,\n-        opt: impl FnOnce() -> Option<T>,\n-        error: impl FnOnce() -> ExpandError,\n-    ) -> Result<T, ErrorEmitted> {\n-        self.option(opt(), error)\n-    }\n-\n-    fn result<T>(&mut self, res: Result<T, ExpandError>) -> Result<T, ErrorEmitted> {\n-        match res {\n-            Ok(it) => Ok(it),\n-            Err(e) => {\n-                self.emit(e);\n-                Err(ErrorEmitted { _private: () })\n-            }\n-        }\n-    }\n-\n-    fn expand_result_option<T>(&mut self, res: ExpandResult<Option<T>>) -> Result<T, ErrorEmitted> {\n-        match (res.value, res.err) {\n-            (None, Some(err)) => {\n-                self.emit(err);\n-                Err(ErrorEmitted { _private: () })\n-            }\n-            (Some(value), opt_err) => {\n-                if let Some(err) = opt_err {\n-                    self.emit(err);\n-                }\n-                Ok(value)\n-            }\n-            (None, None) => unreachable!(\"`ExpandResult` without value or error\"),\n-        }\n-    }\n-}\n-\n-impl ErrorSink for &'_ mut dyn FnMut(ExpandError) {\n-    fn emit(&mut self, err: ExpandError) {\n-        self(err);\n-    }\n-}\n-\n pub fn expand_eager_macro(\n     db: &dyn ExpandDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    diagnostic_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n+    let MacroDefKind::BuiltInEager(eager, _) = def.kind else {\n+        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\")\n+    };\n     let hygiene = Hygiene::new(db, macro_call.file_id);\n     let parsed_args = macro_call\n         .value\n@@ -121,48 +60,44 @@ pub fn expand_eager_macro(\n     let arg_id = db.intern_macro_call(MacroCallLoc {\n         def,\n         krate,\n-        eager: Some(EagerCallInfo {\n+        eager: Some(Box::new(EagerCallInfo {\n             arg_or_expansion: Arc::new(parsed_args.clone()),\n             included_file: None,\n-        }),\n+            error: None,\n+        })),\n         kind: MacroCallKind::FnLike { ast_id: call_id, expand_to: ExpandTo::Expr },\n     });\n \n     let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, mbe::TopEntryPoint::Expr).0;\n-    let result = match eager_macro_recur(\n+    let ExpandResult { value, mut err } = eager_macro_recur(\n         db,\n         &hygiene,\n         InFile::new(arg_id.as_file(), parsed_args.syntax_node()),\n         krate,\n         resolver,\n-        diagnostic_sink,\n-    ) {\n-        Ok(Ok(it)) => it,\n-        Ok(Err(err)) => return Ok(Err(err)),\n-        Err(err) => return Err(err),\n+    )?;\n+    let Some(value ) = value else {\n+        return Ok(ExpandResult { value: None, err })\n     };\n-    let subtree = to_subtree(&result);\n+    let subtree = to_subtree(&value);\n \n-    if let MacroDefKind::BuiltInEager(eager, _) = def.kind {\n-        let res = eager.expand(db, arg_id, &subtree);\n-        if let Some(err) = res.err {\n-            diagnostic_sink(err);\n-        }\n+    let res = eager.expand(db, arg_id, &subtree);\n+    if err.is_none() {\n+        err = res.err;\n+    }\n \n-        let loc = MacroCallLoc {\n-            def,\n-            krate,\n-            eager: Some(EagerCallInfo {\n-                arg_or_expansion: Arc::new(res.value.subtree),\n-                included_file: res.value.included_file,\n-            }),\n-            kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n-        };\n+    let loc = MacroCallLoc {\n+        def,\n+        krate,\n+        eager: Some(Box::new(EagerCallInfo {\n+            arg_or_expansion: Arc::new(res.value.subtree),\n+            included_file: res.value.included_file,\n+            error: err.clone(),\n+        })),\n+        kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n+    };\n \n-        Ok(Ok(db.intern_macro_call(loc)))\n-    } else {\n-        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\");\n-    }\n+    Ok(ExpandResult { value: Some(db.intern_macro_call(loc)), err })\n }\n \n fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n@@ -176,7 +111,7 @@ fn lazy_expand(\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n     krate: CrateId,\n-) -> ExpandResult<Option<InFile<SyntaxNode>>> {\n+) -> ExpandResult<Option<InFile<Parse<SyntaxNode>>>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n     let expand_to = ExpandTo::from_call_site(&macro_call.value);\n@@ -186,13 +121,8 @@ fn lazy_expand(\n         MacroCallKind::FnLike { ast_id: macro_call.with_value(ast_id), expand_to },\n     );\n \n-    let err = db.macro_expand_error(id);\n-    let value =\n-        db.parse_or_expand_with_err(id.as_file()).map(|node| InFile::new(id.as_file(), node));\n-    // FIXME: report parse errors\n-    let value = value.map(|it| it.map(|it| it.syntax_node()));\n-\n-    ExpandResult { value, err }\n+    db.parse_or_expand_with_err(id.as_file())\n+        .map(|parse| parse.map(|parse| InFile::new(id.as_file(), parse)))\n }\n \n fn eager_macro_recur(\n@@ -201,69 +131,81 @@ fn eager_macro_recur(\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n     macro_resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    mut diagnostic_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<SyntaxNode, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<SyntaxNode>>, UnresolvedMacro> {\n     let original = curr.value.clone_for_update();\n \n     let children = original.descendants().filter_map(ast::MacroCall::cast);\n     let mut replacements = Vec::new();\n \n+    // Note: We only report a single error inside of eager expansions\n+    let mut error = None;\n+\n     // Collect replacement\n     for child in children {\n         let def = match child.path().and_then(|path| ModPath::from_src(db, path, hygiene)) {\n             Some(path) => macro_resolver(path.clone()).ok_or(UnresolvedMacro { path })?,\n             None => {\n-                diagnostic_sink(ExpandError::Other(\"malformed macro invocation\".into()));\n+                error = Some(ExpandError::Other(\"malformed macro invocation\".into()));\n                 continue;\n             }\n         };\n-        let insert = match def.kind {\n+        let ExpandResult { value, err } = match def.kind {\n             MacroDefKind::BuiltInEager(..) => {\n                 let id = match expand_eager_macro(\n                     db,\n                     krate,\n                     curr.with_value(child.clone()),\n                     def,\n                     macro_resolver,\n-                    diagnostic_sink,\n                 ) {\n-                    Ok(Ok(it)) => it,\n-                    Ok(Err(err)) => return Ok(Err(err)),\n+                    Ok(it) => it,\n                     Err(err) => return Err(err),\n                 };\n-                db.parse_or_expand(id.as_file())\n-                    .expect(\"successful macro expansion should be parseable\")\n-                    .clone_for_update()\n+                id.map(|call| {\n+                    call.and_then(|call| db.parse_or_expand(call.as_file()))\n+                        .map(|it| it.clone_for_update())\n+                })\n             }\n             MacroDefKind::Declarative(_)\n             | MacroDefKind::BuiltIn(..)\n             | MacroDefKind::BuiltInAttr(..)\n             | MacroDefKind::BuiltInDerive(..)\n             | MacroDefKind::ProcMacro(..) => {\n-                let res = lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n-                let val = match diagnostic_sink.expand_result_option(res) {\n-                    Ok(it) => it,\n-                    Err(err) => return Ok(Err(err)),\n-                };\n-\n-                // replace macro inside\n-                let hygiene = Hygiene::new(db, val.file_id);\n-                match eager_macro_recur(db, &hygiene, val, krate, macro_resolver, diagnostic_sink) {\n-                    Ok(Ok(it)) => it,\n-                    Ok(Err(err)) => return Ok(Err(err)),\n-                    Err(err) => return Err(err),\n+                let ExpandResult { value, err } =\n+                    lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n+\n+                match value {\n+                    Some(val) => {\n+                        // replace macro inside\n+                        let hygiene = Hygiene::new(db, val.file_id);\n+                        let ExpandResult { value, err: error } = eager_macro_recur(\n+                            db,\n+                            &hygiene,\n+                            // FIXME: We discard parse errors here\n+                            val.map(|it| it.syntax_node()),\n+                            krate,\n+                            macro_resolver,\n+                        )?;\n+                        let err = if err.is_none() { error } else { err };\n+                        ExpandResult { value, err }\n+                    }\n+                    None => ExpandResult { value: None, err },\n                 }\n             }\n         };\n-\n+        if err.is_some() {\n+            error = err;\n+        }\n         // check if the whole original syntax is replaced\n         if child.syntax() == &original {\n-            return Ok(Ok(insert));\n+            return Ok(ExpandResult { value, err: error });\n         }\n \n-        replacements.push((child, insert));\n+        if let Some(insert) = value {\n+            replacements.push((child, insert));\n+        }\n     }\n \n     replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));\n-    Ok(Ok(original))\n+    Ok(ExpandResult { value: Some(original), err: error })\n }"}, {"sha": "9685320cf5d5a9351e5ab8873a25de6ffb232b60", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -52,7 +52,7 @@ use crate::{\n \n pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash)]\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n@@ -114,7 +114,7 @@ impl_intern_key!(MacroCallId);\n pub struct MacroCallLoc {\n     pub def: MacroDefId,\n     pub(crate) krate: CrateId,\n-    eager: Option<EagerCallInfo>,\n+    eager: Option<Box<EagerCallInfo>>,\n     pub kind: MacroCallKind,\n }\n \n@@ -141,6 +141,7 @@ struct EagerCallInfo {\n     /// NOTE: This can be *either* the expansion result, *or* the argument to the eager macro!\n     arg_or_expansion: Arc<tt::Subtree>,\n     included_file: Option<(FileId, TokenMap)>,\n+    error: Option<ExpandError>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -206,8 +207,8 @@ impl HirFileId {\n                 HirFileIdRepr::FileId(id) => break id,\n                 HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n                     let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_call_id);\n-                    file_id = match loc.eager {\n-                        Some(EagerCallInfo { included_file: Some((file, _)), .. }) => file.into(),\n+                    file_id = match loc.eager.as_deref() {\n+                        Some(&EagerCallInfo { included_file: Some((file, _)), .. }) => file.into(),\n                         _ => loc.kind.file_id(),\n                     };\n                 }\n@@ -320,7 +321,7 @@ impl HirFileId {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                matches!(loc.eager, Some(EagerCallInfo { included_file: Some(..), .. }))\n+                matches!(loc.eager.as_deref(), Some(EagerCallInfo { included_file: Some(..), .. }))\n             }\n             _ => false,\n         }"}, {"sha": "33dc5e2d69be8162d1b6050e088128adb27862f0", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -381,7 +381,8 @@ impl<'a> TyLoweringContext<'a> {\n                     match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n                             let ctx = expander.ctx(self.db.upcast());\n-                            let type_ref = TypeRef::from_ast(&ctx, expanded);\n+                            // FIXME: Report syntax errors in expansion here\n+                            let type_ref = TypeRef::from_ast(&ctx, expanded.tree());\n \n                             drop(expander);\n                             let ty = self.lower_ty(&type_ref);"}, {"sha": "7ec27af04b9d32a42a9f5627b5fe2c64fb203c18", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -6,8 +6,8 @@\n pub use hir_def::db::*;\n pub use hir_expand::db::{\n     AstIdMapQuery, ExpandDatabase, ExpandDatabaseStorage, ExpandProcMacroQuery, HygieneFrameQuery,\n-    InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandErrorQuery,\n-    MacroExpandQuery, ParseMacroExpansionQuery,\n+    InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandQuery,\n+    ParseMacroExpansionQuery,\n };\n pub use hir_ty::db::*;\n "}, {"sha": "f81f8b0b011e96a50abb4589aa50d75ffaf5b1fe", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -10,7 +10,7 @@ use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n-use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n+use syntax::{ast, AstPtr, SyntaxError, SyntaxNodePtr, TextRange};\n \n use crate::{AssocItem, Field, Local, MacroKind, Type};\n \n@@ -38,8 +38,9 @@ diagnostics![\n     IncorrectCase,\n     InvalidDeriveTarget,\n     IncoherentImpl,\n-    MacroError,\n     MacroDefError,\n+    MacroError,\n+    MacroExpansionParseError,\n     MalformedDerive,\n     MismatchedArgCount,\n     MissingFields,\n@@ -132,6 +133,13 @@ pub struct MacroError {\n     pub message: String,\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroExpansionParseError {\n+    pub node: InFile<SyntaxNodePtr>,\n+    pub precise_location: Option<TextRange>,\n+    pub errors: Box<[SyntaxError]>,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MacroDefError {\n     pub node: InFile<AstPtr<ast::Macro>>,"}, {"sha": "3adb484b12f4126c30da18f4527d5d31cb7ed95f", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -87,12 +87,12 @@ pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n         AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n-        IncorrectCase, InvalidDeriveTarget, MacroDefError, MacroError, MalformedDerive,\n-        MismatchedArgCount, MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField,\n-        PrivateAssocItem, PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n-        UndeclaredLabel, UnimplementedBuiltinMacro, UnreachableLabel, UnresolvedExternCrate,\n-        UnresolvedField, UnresolvedImport, UnresolvedMacroCall, UnresolvedMethodCall,\n-        UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n+        IncorrectCase, InvalidDeriveTarget, MacroDefError, MacroError, MacroExpansionParseError,\n+        MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms, MissingUnsafe,\n+        NeedMut, NoSuchField, PrivateAssocItem, PrivateField, ReplaceFilterMapNextWithFindMap,\n+        TypeMismatch, UndeclaredLabel, UnimplementedBuiltinMacro, UnreachableLabel,\n+        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -753,15 +753,13 @@ fn emit_def_diagnostic_(\n                 .into(),\n             );\n         }\n-\n         DefDiagnosticKind::UnresolvedProcMacro { ast, krate } => {\n             let (node, precise_location, macro_name, kind) = precise_macro_call_location(ast, db);\n             acc.push(\n                 UnresolvedProcMacro { node, precise_location, macro_name, kind, krate: *krate }\n                     .into(),\n             );\n         }\n-\n         DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {\n             let (node, precise_location, _, _) = precise_macro_call_location(ast, db);\n             acc.push(\n@@ -774,12 +772,16 @@ fn emit_def_diagnostic_(\n                 .into(),\n             );\n         }\n-\n         DefDiagnosticKind::MacroError { ast, message } => {\n             let (node, precise_location, _, _) = precise_macro_call_location(ast, db);\n             acc.push(MacroError { node, precise_location, message: message.clone() }.into());\n         }\n-\n+        DefDiagnosticKind::MacroExpansionParseError { ast, errors } => {\n+            let (node, precise_location, _, _) = precise_macro_call_location(ast, db);\n+            acc.push(\n+                MacroExpansionParseError { node, precise_location, errors: errors.clone() }.into(),\n+            );\n+        }\n         DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {\n             let node = ast.to_node(db.upcast());\n             // Must have a name, otherwise we wouldn't emit it."}, {"sha": "8d14371d034a9b9f5b3e616d3cb347c6ae1d35ce", "filename": "crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -80,7 +80,6 @@ impl RootDatabase {\n             hir::db::MacroDefQuery\n             hir::db::MacroExpandQuery\n             hir::db::ExpandProcMacroQuery\n-            hir::db::MacroExpandErrorQuery\n             hir::db::HygieneFrameQuery\n \n             // DefDatabase"}, {"sha": "12b6e3c4bb83484ecd1c48e6ca454efaaeb34ede", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -152,7 +152,6 @@ impl RootDatabase {\n         let lru_capacity = lru_capacity.unwrap_or(base_db::DEFAULT_LRU_CAP);\n         base_db::ParseQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n         hir::db::ParseMacroExpansionQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n-        hir::db::MacroExpandQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n     }\n \n     pub fn update_lru_capacities(&mut self, lru_capacities: &FxHashMap<Box<str>, usize>) {\n@@ -167,12 +166,6 @@ impl RootDatabase {\n                 .copied()\n                 .unwrap_or(base_db::DEFAULT_LRU_CAP),\n         );\n-        hir_db::MacroExpandQuery.in_db_mut(self).set_lru_capacity(\n-            lru_capacities\n-                .get(stringify!(MacroExpandQuery))\n-                .copied()\n-                .unwrap_or(base_db::DEFAULT_LRU_CAP),\n-        );\n \n         macro_rules! update_lru_capacity_per_query {\n             ($( $module:ident :: $query:ident )*) => {$(\n@@ -201,7 +194,6 @@ impl RootDatabase {\n             hir_db::MacroDefQuery\n             // hir_db::MacroExpandQuery\n             hir_db::ExpandProcMacroQuery\n-            hir_db::MacroExpandErrorQuery\n             hir_db::HygieneFrameQuery\n \n             // DefDatabase"}, {"sha": "7547779a95c72da17fc1f07523f53eaefab95949", "filename": "crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -238,6 +238,22 @@ fn f() {\n   //^^^ error: invalid macro definition: expected subtree\n \n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn expansion_syntax_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! foo {\n+    () => { struct; };\n+}\n+\n+fn f() {\n+    foo!();\n+  //^^^ error: Syntax Error in Expansion: expected a name\n+}\n \"#,\n         )\n     }"}, {"sha": "7c8cb7a4476f19a4ccdacc53e83bbd3bde42e8ae", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -265,6 +265,19 @@ pub fn diagnostics(\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n             AnyDiagnostic::MacroDefError(d) => handlers::macro_error::macro_def_error(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n+            AnyDiagnostic::MacroExpansionParseError(d) => {\n+                res.extend(d.errors.iter().take(32).map(|err| {\n+                    {\n+                        Diagnostic::new(\n+                            \"syntax-error\",\n+                            format!(\"Syntax Error in Expansion: {err}\"),\n+                            ctx.resolve_precise_location(&d.node.clone(), d.precise_location),\n+                        )\n+                    }\n+                    .experimental()\n+                }));\n+                continue;\n+            },\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),"}, {"sha": "23ec3235d2d0fbfba08336749d5f56accb05a38b", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697b335fdaf8d09d5f74b98641351624cad901a6/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=697b335fdaf8d09d5f74b98641351624cad901a6", "patch": "@@ -69,7 +69,7 @@ impl fmt::Display for ParseError {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash)]\n pub enum ExpandError {\n     BindingError(Box<Box<str>>),\n     LeftoverTokens,"}]}