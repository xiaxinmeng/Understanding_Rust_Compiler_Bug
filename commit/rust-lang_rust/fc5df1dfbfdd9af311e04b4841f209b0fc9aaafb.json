{"sha": "fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNWRmMWRmYmZkZDlhZjMxMWUwNGI0ODQxZjIwOWIwZmM5YWFhZmI=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-30T10:38:32Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-30T10:38:32Z"}, "message": "renaming err to err_unsup", "tree": {"sha": "be054b5ff9f3d53a71f829cd1f8e958bd8eeec88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be054b5ff9f3d53a71f829cd1f8e958bd8eeec88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "html_url": "https://github.com/rust-lang/rust/commit/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b60a336e86dece15a277139ba76117ed4f17eb3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b60a336e86dece15a277139ba76117ed4f17eb3c", "html_url": "https://github.com/rust-lang/rust/commit/b60a336e86dece15a277139ba76117ed4f17eb3c"}], "stats": {"total": 136, "additions": 73, "deletions": 63}, "files": [{"sha": "b8686754fa764c3adc34ff2d9e78069077356173", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -244,7 +244,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => throw_err!(UnterminatedCString(ptr.erase_tag())),\n+            None => throw_err_unsup!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n \n@@ -446,7 +446,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n-            throw_err!(ReadPointerAsBytes)\n+            throw_err_unsup!(ReadPointerAsBytes)\n         }\n     }\n \n@@ -516,7 +516,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ).or_else(|idx| throw_err!(ReadUndefBytes(idx)))\n+        ).or_else(|idx| throw_err_unsup!(ReadUndefBytes(idx)))\n     }\n \n     pub fn mark_definedness("}, {"sha": "7108f69d39ed47105bffc3fde2c21475f71fdf08", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -184,8 +184,8 @@ pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'\n /// Packages the kind of error we got from the const code interpreter\n /// up with a Rust-level backtrace of where the error occured.\n /// Thsese should always be constructed by calling `.into()` on\n-/// a `InterpError`. In `librustc_mir::interpret`, we have the `throw_err!`\n-/// macro for this.\n+/// a `InterpError`. In `librustc_mir::interpret`, we have `throw_err_*`\n+/// macros for this.\n #[derive(Debug, Clone)]\n pub struct InterpErrorInfo<'tcx> {\n     pub kind: InterpError<'tcx>,"}, {"sha": "bc72050de181b2fab4347c174f45e5105626d3b0", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -1,7 +1,7 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n #[macro_export]\n-macro_rules! throw_err {\n+macro_rules! throw_err_unsup {\n     ($($tt:tt)*) => {\n         Err($crate::mir::interpret::InterpError::Unsupported(\n             $crate::mir::interpret::UnsupportedOpInfo::$($tt)*\n@@ -55,7 +55,7 @@ macro_rules! err_inval {\n }\n \n #[macro_export]\n-macro_rules! err {\n+macro_rules! err_unsup {\n     ($($tt:tt)*) => {\n         $crate::mir::interpret::InterpError::Unsupported(\n             $crate::mir::interpret::UnsupportedOpInfo::$($tt)*"}, {"sha": "17f963609f6d830136a5e3280c5a5895c57e040a", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -196,7 +196,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n-            throw_err!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n+            throw_err_unsup!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n         } else {\n             Ok(())\n         }"}, {"sha": "01db0e48e21e091a0d652482d7e6084488f20ddc", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -360,7 +360,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n-            Scalar::Ptr(_) => throw_err!(ReadPointerAsBytes),\n+            Scalar::Ptr(_) => throw_err_unsup!(ReadPointerAsBytes),\n         }\n     }\n \n@@ -373,8 +373,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Raw { data: 0, .. } => throw_err!(InvalidNullPointerUsage),\n-            Scalar::Raw { .. } => throw_err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => throw_err_unsup!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => throw_err_unsup!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n@@ -406,15 +406,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => throw_err!(InvalidBool),\n+            _ => throw_err_unsup!(InvalidBool),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => throw_err!(InvalidChar(val as u128)),\n+            None => throw_err_unsup!(InvalidChar(val as u128)),\n         }\n     }\n \n@@ -537,7 +537,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_err!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_err_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n "}, {"sha": "423449bc95d4e6d85a61bab0617eb54998519171", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -352,7 +352,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    throw_err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+                    throw_err_unsup!(\n+                        MachineError(format!(\"calling non-const function `{}`\", instance))\n+                    )\n                 };\n             }\n         }\n@@ -412,7 +414,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_err!(ReadForeignStatic)\n+        throw_err_unsup!(ReadForeignStatic)\n     }\n \n     #[inline(always)]"}, {"sha": "94f3148aaaf9e7406adf709d0c1f767fd456c9e7", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -199,7 +199,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => throw_err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n+            _ => throw_err_unsup!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }\n     }\n "}, {"sha": "61ee60fd3d5035c754c1ee52ab6ae6c9462d5561", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -135,7 +135,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => throw_err!(DeadLocal),\n+            LocalValue::Dead => throw_err_unsup!(DeadLocal),\n             LocalValue::Uninitialized =>\n                 bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n@@ -148,7 +148,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => throw_err!(DeadLocal),\n+            LocalValue::Dead => throw_err_unsup!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n             ref mut local @ LocalValue::Uninitialized => {\n@@ -346,7 +346,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                throw_err!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                throw_err_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }"}, {"sha": "4539a1c7e1dddb5712a72eab79d24df36b3dc06c", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -328,7 +328,7 @@ pub fn intern_const_alloc_recursive(\n             }\n         } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            return throw_err!(\n+            return throw_err_unsup!(\n                 ValidationFailure(\"encountered dangling pointer in final constant\".into())\n             )\n         }"}, {"sha": "687265c983f2653c99e039fe85cfaf2cbdc8097e", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -104,7 +104,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        return throw_err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n+                        return throw_err_unsup!(\n+                            Intrinsic(format!(\"{} called on 0\", intrinsic_name))\n+                        );\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -190,7 +192,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    return throw_err!(Intrinsic(\n+                    return throw_err_unsup!(Intrinsic(\n                         format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name),\n                     ));\n                 }"}, {"sha": "3f3d4376d29cddde5585dc58ee4384ae1b387fe4", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -251,6 +251,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        throw_err!(ReadPointerAsBytes)\n+        throw_err_unsup!(ReadPointerAsBytes)\n     }\n }"}, {"sha": "8c43fb3dc40de11bf41a0d0a7ddab1019d3122f5", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -66,7 +66,7 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) => throw_err!(MachineError(format!(\n+            FnVal::Other(_) => throw_err_unsup!(MachineError(format!(\n                 \"Expected instance function pointer, got 'other' pointer\"\n             ))),\n         }\n@@ -202,7 +202,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            return throw_err!(ReallocateNonBasePtr);\n+            return throw_err_unsup!(ReallocateNonBasePtr);\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -243,38 +243,40 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            return throw_err!(DeallocateNonBasePtr);\n+            return throw_err_unsup!(DeallocateNonBasePtr);\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => throw_err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Function(..)) => throw_err_unsup!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n                     Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => throw_err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Memory(..)) => throw_err_unsup!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    None => throw_err!(DoubleFree)\n+                    None => throw_err_unsup!(DoubleFree)\n                 }\n             }\n         };\n \n         if alloc_kind != kind {\n-            return throw_err!(DeallocatedWrongMemoryKind(\n+            return throw_err_unsup!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n                 format!(\"{:?}\", kind),\n             ));\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n-                return throw_err!(IncorrectAllocationInformation(size, bytes, align, alloc.align));\n+                return throw_err_unsup!(\n+                    IncorrectAllocationInformation(size, bytes, align, alloc.align)\n+                );\n             }\n         }\n \n@@ -319,7 +321,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_err!(AlignmentCheckFailed {\n+                throw_err_unsup!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n                 })\n@@ -341,7 +343,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL and aligned.\n                 if bits == 0 {\n-                    return throw_err!(InvalidNullPointerUsage);\n+                    return throw_err_unsup!(InvalidNullPointerUsage);\n                 }\n                 check_offset_align(bits, align)?;\n                 None\n@@ -362,7 +364,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // got picked we might be aligned even if this check fails.\n                     // We instead have to fall back to converting to an integer and checking\n                     // the \"real\" alignment.\n-                    return throw_err!(AlignmentCheckFailed {\n+                    return throw_err_unsup!(AlignmentCheckFailed {\n                         has: alloc_align,\n                         required: align,\n                     });\n@@ -413,9 +415,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(mem)) =>\n                 Cow::Borrowed(mem),\n             Some(GlobalAlloc::Function(..)) =>\n-                return throw_err!(DerefFunctionPointer),\n+                return throw_err_unsup!(DerefFunctionPointer),\n             None =>\n-                return throw_err!(DanglingPointerDeref),\n+                return throw_err_unsup!(DanglingPointerDeref),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n@@ -505,11 +507,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n-                return throw_err!(ModifiedConstantMemory);\n+                return throw_err_unsup!(ModifiedConstantMemory);\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => throw_err!(ModifiedStatic),\n+                None => throw_err_unsup!(ModifiedStatic),\n             }\n         });\n         // Unpack the error type manually because type inference doesn't\n@@ -519,7 +521,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Immutable {\n-                    return throw_err!(ModifiedConstantMemory);\n+                    return throw_err_unsup!(ModifiedConstantMemory);\n                 }\n                 Ok(a)\n             }\n@@ -548,7 +550,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Ok(_) = self.get_fn_alloc(id) {\n             return if let AllocCheck::Dereferencable = liveness {\n                 // The caller requested no function pointers.\n-                throw_err!(DerefFunctionPointer)\n+                throw_err_unsup!(DerefFunctionPointer)\n             } else {\n                 Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             };\n@@ -579,7 +581,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     .expect(\"deallocated pointers should all be recorded in \\\n                             `dead_alloc_map`\"))\n             } else {\n-                throw_err!(DanglingPointerDeref)\n+                throw_err_unsup!(DanglingPointerDeref)\n             },\n         }\n     }\n@@ -591,7 +593,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         } else {\n             match self.tcx.alloc_map.lock().get(id) {\n                 Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n-                _ => throw_err!(ExecuteMemory),\n+                _ => throw_err_unsup!(ExecuteMemory),\n             }\n         }\n     }\n@@ -602,7 +604,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            return throw_err!(InvalidFunctionPointer);\n+            return throw_err_unsup!(InvalidFunctionPointer);\n         }\n         self.get_fn_alloc(ptr.alloc_id)\n     }\n@@ -837,7 +839,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        return throw_err!(Intrinsic(\n+                        return throw_err_unsup!(Intrinsic(\n                             \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n                         ));\n                     }"}, {"sha": "8c443c9579f75b9abd14ee7437e4543cbbd02bc4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -461,7 +461,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n                 PlaceBase::Local(mir::RETURN_PLACE) =>\n-                    return throw_err!(ReadFromReturnPointer),\n+                    return throw_err_unsup!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n@@ -610,7 +610,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n                     Err(_) =>\n-                        return throw_err!(InvalidDiscriminant(raw_discr.erase_tag())),\n+                        return throw_err_unsup!(InvalidDiscriminant(raw_discr.erase_tag())),\n                 };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n@@ -637,7 +637,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .find(|(_, var)| var.val == real_discr),\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }.ok_or_else(\n-                    || err!(InvalidDiscriminant(raw_discr.erase_tag()))\n+                    || err_unsup!(InvalidDiscriminant(raw_discr.erase_tag()))\n                 )?;\n                 (real_discr, index.0)\n             },\n@@ -657,7 +657,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            return throw_err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n+                            return throw_err_unsup!(\n+                                InvalidDiscriminant(raw_discr.erase_tag().into())\n+                            );\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },"}, {"sha": "334cf09ba122b726421f3f21a77d777479999375", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -155,7 +155,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 r,\n                 right_layout.ty\n             );\n-            return throw_err!(Unimplemented(msg));\n+            return throw_err_unsup!(Unimplemented(msg));\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     r,\n                     right_layout.ty,\n                 );\n-                return throw_err!(Unimplemented(msg));\n+                return throw_err_unsup!(Unimplemented(msg));\n             }\n         };\n "}, {"sha": "b385862490a23b33450fcd50416136a0c90856b9", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -622,7 +622,7 @@ where\n                                 .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n-                    None => return throw_err!(InvalidNullPointerUsage),\n+                    None => return throw_err_unsup!(InvalidNullPointerUsage),\n                 },\n                 PlaceBase::Local(local) => PlaceTy {\n                     // This works even for dead/uninitialized locals; we check further when writing"}, {"sha": "de798ecee7348649bc62f12081a9b2caaefdc5d4", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return throw_err!(InlineAsm),\n+            InlineAsm { .. } => return throw_err_unsup!(InlineAsm),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "f1c91058b713de13e80736494a74bbfd17fab17d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -89,7 +89,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        return throw_err!(Unimplemented(msg));\n+                        return throw_err_unsup!(Unimplemented(msg));\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n@@ -220,13 +220,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n         let caller_arg = caller_arg.next()\n-            .ok_or_else(|| err!(FunctionArgCountMismatch)) ?;\n+            .ok_or_else(|| err_unsup!(FunctionArgCountMismatch)) ?;\n         if rust_abi {\n             debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            return throw_err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n+            return throw_err_unsup!(\n+                FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty)\n+            );\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -254,7 +256,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 if caller_abi != Abi::RustIntrinsic {\n-                    return throw_err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                    return throw_err_unsup!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n@@ -295,7 +297,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             abi,\n                     };\n                     if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        return throw_err!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                        return throw_err_unsup!(FunctionAbiMismatch(caller_abi, callee_abi));\n                     }\n                 }\n \n@@ -390,7 +392,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n                         trace!(\"Caller has passed too many args\");\n-                        return throw_err!(FunctionArgCountMismatch);\n+                        return throw_err_unsup!(FunctionArgCountMismatch);\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n@@ -402,15 +404,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             caller_ret.layout,\n                             callee_ret.layout,\n                         ) {\n-                            return throw_err!(\n+                            return throw_err_unsup!(\n                                 FunctionRetMismatch(caller_ret.layout.ty, callee_ret.layout.ty)\n                             );\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n                         let ty = self.frame().body.local_decls[local].ty;\n                         if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            return throw_err!(FunctionRetMismatch(self.tcx.types.never, ty));\n+                            return throw_err_unsup!(FunctionRetMismatch(self.tcx.types.never, ty));\n                         }\n                     }\n                     Ok(())"}, {"sha": "df6fb7a7c63c8a30e14935f35c51dd2746537ddd", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "patch": "@@ -22,7 +22,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        throw_err!(ValidationFailure(format!(\n+        throw_err_unsup!(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n         )))\n@@ -34,7 +34,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        throw_err!(ValidationFailure(format!(\n+        throw_err_unsup!(ValidationFailure(format!(\n             \"encountered {}{}\",\n             $what, where_,\n         )))"}]}