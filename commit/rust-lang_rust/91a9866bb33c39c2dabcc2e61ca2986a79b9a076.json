{"sha": "91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYTk4NjZiYjMzYzM5YzJkYWJjYzJlNjFjYTI5ODZhNzliOWEwNzY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-04-11T12:45:12Z"}, "committer": {"name": "Seiichi Uchida", "email": "topecongiro@localhost.localdomain", "date": "2017-05-01T08:25:07Z"}, "message": "Add an example for 'fence'", "tree": {"sha": "35c49eafba4a5894df275b2431956a09199191ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c49eafba4a5894df275b2431956a09199191ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "html_url": "https://github.com/rust-lang/rust/commit/91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91a9866bb33c39c2dabcc2e61ca2986a79b9a076/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8107c0d7ce4f39364fc96d0eeb6a23673491f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8107c0d7ce4f39364fc96d0eeb6a23673491f81", "html_url": "https://github.com/rust-lang/rust/commit/f8107c0d7ce4f39364fc96d0eeb6a23673491f81"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "53362de0d113c89b211952f9add8ae8878cf3733", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/91a9866bb33c39c2dabcc2e61ca2986a79b9a076/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a9866bb33c39c2dabcc2e61ca2986a79b9a076/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "patch": "@@ -1550,12 +1550,30 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// An atomic fence.\n ///\n-/// A fence 'A' which has [`Release`] ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) [`Acquire`] semantics, if and only if there exists\n-/// atomic operations X and Y, both operating on some atomic object 'M' such\n+/// Depending on the specified order, a fence prevents the compiler and CPU from\n+/// reordering certain types of memory operations around it.\n+/// That creates synchronizes-with relationships between it and atomic operations\n+/// or fences in other threads.\n+///\n+/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n+/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n+/// exist operations X and Y, both operating on some atomic object 'M' such\n /// that A is sequenced before X, Y is synchronized before B and Y observes\n /// the change to M. This provides a happens-before dependence between A and B.\n ///\n+/// ```text\n+///     Thread 1                                          Thread 2\n+///\n+/// fence(Release);      A --------------\n+/// x.store(3, Relaxed); X ---------    |\n+///                                |    |\n+///                                |    |\n+///                                -------------> Y  if x.load(Relaxed) == 3 {\n+///                                     |-------> B      fence(Acquire);\n+///                                                      ...\n+///                                                  }\n+/// ```\n+///\n /// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n /// with a fence.\n ///\n@@ -1569,6 +1587,37 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is [`Relaxed`].\n ///\n+/// # Examples\n+///\n+/// ```\n+/// use std::sync::atomic::AtomicBool;\n+/// use std::sync::atomic::fence;\n+/// use std::sync::atomic::Ordering;\n+///\n+/// // A mutual exclusion primitive based on spinlock.\n+/// pub struct Mutex {\n+///     flag: AtomicBool,\n+/// }\n+///\n+/// impl Mutex {\n+///     pub fn new() -> Mutex {\n+///         Mutex {\n+///             flag: AtomicBool::new(false),\n+///         }\n+///     }\n+///\n+///     pub fn lock(&self) {\n+///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n+///         // This fence syncronizes-with store in `unlock`.\n+///         fence(Ordering::Acquire);\n+///     }\n+///\n+///     pub fn unlock(&self) {\n+///         self.flag.store(false, Ordering::Release);\n+///     }\n+/// }\n+/// ```\n+///\n /// [`Ordering`]: enum.Ordering.html\n /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst"}]}