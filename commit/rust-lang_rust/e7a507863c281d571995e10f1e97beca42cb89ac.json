{"sha": "e7a507863c281d571995e10f1e97beca42cb89ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTUwNzg2M2MyODFkNTcxOTk1ZTEwZjFlOTdiZWNhNDJjYjg5YWM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-08T13:54:13Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-09T10:35:51Z"}, "message": "Implement real saturating behaviour for the saturating_* intrinsics with unsigned ints", "tree": {"sha": "9626c51b72c38684979481182b9ba8a0a9cc6228", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9626c51b72c38684979481182b9ba8a0a9cc6228"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a507863c281d571995e10f1e97beca42cb89ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a507863c281d571995e10f1e97beca42cb89ac", "html_url": "https://github.com/rust-lang/rust/commit/e7a507863c281d571995e10f1e97beca42cb89ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a507863c281d571995e10f1e97beca42cb89ac/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6414f03644931085f1859a0707273b11e26a5d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/6414f03644931085f1859a0707273b11e26a5d18", "html_url": "https://github.com/rust-lang/rust/commit/6414f03644931085f1859a0707273b11e26a5d18"}], "stats": {"total": 154, "additions": 117, "deletions": 37}, "files": [{"sha": "c9c733c3f6f6e1474e6094cbb0da63061f200f8f", "filename": "src/common.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e7a507863c281d571995e10f1e97beca42cb89ac/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a507863c281d571995e10f1e97beca42cb89ac/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=e7a507863c281d571995e10f1e97beca42cb89ac", "patch": "@@ -116,6 +116,74 @@ pub fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n     }\n }\n \n+pub fn type_min_max_value<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (i64, i64) {\n+    use syntax::ast::UintTy::*;\n+    use syntax::ast::IntTy::*;\n+\n+    let uint_usize_cvt = |uint| {\n+        match uint {\n+            UintTy::Usize => match pointer_ty(tcx) {\n+                types::I16 => UintTy::U16,\n+                types::I32 => UintTy::U32,\n+                types::I64 => UintTy::U64,\n+                ty => unreachable!(\"{:?}\", ty),\n+            }\n+            _ => uint,\n+        }\n+    };\n+\n+    let int_isize_cvt = |int| {\n+        match int {\n+            IntTy::Isize => match pointer_ty(tcx) {\n+                types::I16 => IntTy::I16,\n+                types::I32 => IntTy::I32,\n+                types::I64 => IntTy::I64,\n+                ty => unreachable!(\"{:?}\", ty),\n+            }\n+            _ => int,\n+        }\n+    };\n+\n+    let min = match ty.sty {\n+        ty::Uint(uint) => match uint_usize_cvt(uint) {\n+            U8 | U16 | U32 | U64 => 0i64,\n+            U128 => unimplemented!(),\n+            Usize => unreachable!(),\n+        }\n+        ty::Int(int) => match int_isize_cvt(int) {\n+            I8 => i8::min_value() as i64,\n+            I16 => i16::min_value() as i64,\n+            I32 => i32::min_value() as i64,\n+            I64 => i64::min_value(),\n+            I128 => unimplemented!(),\n+            Isize => unreachable!(),\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    let max = match ty.sty {\n+        ty::Uint(uint) => match uint_usize_cvt(uint) {\n+            U8 => u8::max_value() as i64,\n+            U16 => u16::max_value() as i64,\n+            U32 => u32::max_value() as i64,\n+            U64 => u64::max_value() as i64,\n+            U128 => unimplemented!(),\n+            Usize => unreachable!(),\n+        }\n+        ty::Int(int) => match int_isize_cvt(int) {\n+            I8 => i8::max_value() as i64,\n+            I16 => i16::max_value() as i64,\n+            I32 => i32::max_value() as i64,\n+            I64 => i64::max_value(),\n+            I128 => unimplemented!(),\n+            Isize => unreachable!(),\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    (min, max)\n+}\n+\n pub struct FunctionCx<'a, 'tcx: 'a, B: Backend> {\n     // FIXME use a reference to `CodegenCx` instead of `tcx`, `module` and `constants` and `caches`\n     pub tcx: TyCtxt<'tcx>,"}, {"sha": "9c5565fa2b53050da7524c3473fd30e602163f99", "filename": "src/intrinsics.rs", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e7a507863c281d571995e10f1e97beca42cb89ac/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a507863c281d571995e10f1e97beca42cb89ac/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=e7a507863c281d571995e10f1e97beca42cb89ac", "patch": "@@ -470,25 +470,21 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 \"mul_with_overflow\" => BinOp::Mul,\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = match T.sty {\n-                ty::Uint(_) => crate::base::trans_checked_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    false,\n-                ),\n-                ty::Int(_) => crate::base::trans_checked_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    true,\n-                ),\n-                _ => panic!(),\n+\n+            let signed = match T.sty {\n+                ty::Uint(_) => false,\n+                ty::Int(_) => true,\n+                _ => unimplemented!(\"{} for {:?}\", intrinsic, T),\n             };\n+\n+            let res = crate::base::trans_checked_int_binop(\n+                fx,\n+                bin_op,\n+                x,\n+                y,\n+                ret.layout().ty,\n+                signed,\n+            );\n             ret.write_cvalue(fx, res);\n         };\n         _ if intrinsic.starts_with(\"overflowing_\"), <T> (c x, c y) {\n@@ -526,28 +522,44 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             let bin_op = match intrinsic {\n                 \"saturating_add\" => BinOp::Add,\n                 \"saturating_sub\" => BinOp::Sub,\n-                \"saturating_mul\" => BinOp::Mul,\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = match T.sty {\n-                ty::Uint(_) => crate::base::trans_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    false,\n-                ),\n-                ty::Int(_) => crate::base::trans_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    true,\n-                ),\n-                _ => panic!(),\n+\n+            let signed = match T.sty {\n+                ty::Uint(_) => false,\n+                ty::Int(_) => true,\n+                _ => unimplemented!(\"{} for {:?}\", intrinsic, T),\n             };\n+\n+            let checked_res = crate::base::trans_checked_int_binop(\n+                fx,\n+                bin_op,\n+                x,\n+                y,\n+                fx.tcx.mk_tup([T, fx.tcx.types.bool].into_iter()),\n+                signed,\n+            );\n+\n+            let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n+            let clif_ty = fx.clif_type(T).unwrap();\n+\n+            // `select.i8` is not implemented by Cranelift.\n+            let has_overflow = fx.bcx.ins().uextend(types::I32, has_overflow);\n+\n+            let (min, max) = type_min_max_value(fx.tcx, T);\n+            let min = fx.bcx.ins().iconst(clif_ty, min);\n+            let max = fx.bcx.ins().iconst(clif_ty, max);\n+\n+            let val = match (intrinsic, signed) {\n+                (\"saturating_add\", false) => fx.bcx.ins().select(has_overflow, max, val),\n+                (\"saturating_sub\", false) => fx.bcx.ins().select(has_overflow, min, val),\n+                (\"saturating_add\", true) => unimplemented!(),\n+                (\"saturating_sub\", true) => unimplemented!(),\n+                _ => unreachable!(),\n+            };\n+\n+            let res = CValue::by_val(val, fx.layout_of(T));\n+\n             ret.write_cvalue(fx, res);\n         };\n         rotate_left, <T>(v x, v y) {"}]}