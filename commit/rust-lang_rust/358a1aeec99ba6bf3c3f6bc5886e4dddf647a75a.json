{"sha": "358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1OGExYWVlYzk5YmE2YmYzYzNmNmJjNTg4NmU0ZGRkZjY0N2E3NWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T11:25:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T13:40:21Z"}, "message": "Keep resolve data in external hash table, rather than embedded defs\n\nOne step closer to removing fold and having a single, immutable AST.\nResolve still uses fold, because it has to detect and transform\nexpr_field expressions. If we go through on our plan of moving to a\ndifferent syntax for module dereferencing, the parser can spit out\nexpr_field expressions, and resolve can move to walk.\n\n(I am truly sorry for the things I did in typestate_check.rs. I expect\nwe'll want to change that to walk as well in the near future, at which\npoint it should probably pass around a context record, which could\nhold the def_map.)", "tree": {"sha": "314e23b11b7fed0c6f667dfae66192ffd59566a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314e23b11b7fed0c6f667dfae66192ffd59566a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "html_url": "https://github.com/rust-lang/rust/commit/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b36e40c58a4b153da593e4da73ba45647b811de", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b36e40c58a4b153da593e4da73ba45647b811de", "html_url": "https://github.com/rust-lang/rust/commit/2b36e40c58a4b153da593e4da73ba45647b811de"}], "stats": {"total": 997, "additions": 516, "deletions": 481}, "files": [{"sha": "b38b8c9b75c117668deace9a223cb865e7214b5d", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -86,28 +86,30 @@ fn compile_input(session.session sess,\n                  str input, str output) {\n     auto time_passes = sess.get_opts().time_passes;\n     auto def = tup(ast.local_crate, 0);\n-    auto p = parser.new_parser(sess, env, def, input, 0u);\n-    auto crate = time[@ast.crate](time_passes, \"parsing\",\n-                                  bind parse_input(sess, p, input));\n+    auto p = parser.new_parser(sess, env, def, input, 0u, 0u);\n+    auto crate = time(time_passes, \"parsing\",\n+                      bind parse_input(sess, p, input));\n     if (sess.get_opts().output_type == Link.output_type_none) {ret;}\n \n-    crate = time[@ast.crate](time_passes, \"external crate reading\",\n-                             bind creader.read_crates(sess, crate));\n-    crate = time[@ast.crate](time_passes, \"resolution\",\n-                             bind resolve.resolve_crate(sess, crate));\n+    crate = time(time_passes, \"external crate reading\",\n+                 bind creader.read_crates(sess, crate));\n+    auto res = time(time_passes, \"resolution\",\n+                    bind resolve.resolve_crate(sess, crate));\n+    crate = res._0;\n+    auto def_map = res._1;\n     time[()](time_passes, \"capture checking\",\n-             bind capture.check_for_captures(sess, crate));\n+             bind capture.check_for_captures(sess, crate, def_map));\n \n-    auto ty_cx = ty.mk_ctxt(sess);\n+    auto ty_cx = ty.mk_ctxt(sess, def_map);\n     auto typeck_result =\n         time[typeck.typecheck_result](time_passes, \"typechecking\",\n                                       bind typeck.check_crate(ty_cx, crate));\n     crate = typeck_result._0;\n     auto type_cache = typeck_result._1;\n \n     if (sess.get_opts().run_typestate) {\n-        crate = time[@ast.crate](time_passes, \"typestate checking\",\n-            bind typestate_check.check_crate(crate));\n+        crate = time(time_passes, \"typestate checking\",\n+                     bind typestate_check.check_crate(crate, def_map));\n     }\n \n     auto llmod = time[llvm.ModuleRef](time_passes, \"translation\",\n@@ -121,7 +123,7 @@ fn pretty_print_input(session.session sess,\n                              eval.env env,\n                              str input) {\n     auto def = tup(ast.local_crate, 0);\n-    auto p = front.parser.new_parser(sess, env, def, input, 0u);\n+    auto p = front.parser.new_parser(sess, env, def, input, 0u, 0u);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n     pretty.pprust.print_file(sess, crate.node.module, input, std.IO.stdout());\n }"}, {"sha": "84dae306a44e039c9a273c645fcd95e5d3495e0d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -56,6 +56,14 @@ tag def {\n     def_native_fn(def_id);\n }\n \n+fn variant_def_ids(&def d) -> tup(def_id, def_id) {\n+    alt (d) {\n+        case (def_variant(?tag_id, ?var_id)) {\n+            ret tup(tag_id, var_id);\n+        }\n+    }\n+}\n+\n fn def_id_of_def(def d) -> def_id {\n     alt (d) {\n         case (def_fn(?id)) { ret id; }\n@@ -106,14 +114,12 @@ type block_ = rec(vec[@stmt] stmts,\n                   Option.t[@expr] expr,\n                   ann a); /* ann is only meaningful for the ts_ann field */\n \n-type variant_def = tup(def_id /* tag */, def_id /* variant */);\n-\n type pat = spanned[pat_];\n tag pat_ {\n     pat_wild(ann);\n     pat_bind(ident, def_id, ann);\n     pat_lit(@lit, ann);\n-    pat_tag(path, vec[@pat], Option.t[variant_def], ann);\n+    pat_tag(path, vec[@pat], ann);\n }\n \n tag mutability {\n@@ -277,7 +283,7 @@ tag expr_ {\n     expr_recv(@expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n-    expr_path(path, Option.t[def], ann);\n+    expr_path(path, ann);\n     expr_ext(path, vec[@expr], Option.t[str], @expr, ann);\n     expr_fail(ann);\n     expr_break(ann);\n@@ -333,7 +339,7 @@ tag ty_ {\n     ty_rec(vec[ty_field]);\n     ty_fn(proto, vec[ty_arg], @ty);\n     ty_obj(vec[ty_method]);\n-    ty_path(path, Option.t[def]);\n+    ty_path(path, ann);\n     ty_type;\n     ty_constr(@ty, vec[@constr]);\n }\n@@ -463,7 +469,7 @@ fn is_constraint_arg(@expr e) -> bool {\n         case (expr_lit(_,_)) {\n             ret true;\n         }\n-        case (expr_path(_, Option.some[def](def_local(_)), _)) {\n+        case (expr_path(_, _)) {\n             ret true;\n         }\n         case (_) {"}, {"sha": "c03e313d80986ff4808aead62b66565f6630ed42", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -34,7 +34,8 @@ type ctx = @rec(parser p,\n                 eval_mode mode,\n                 mutable vec[str] deps,\n                 session.session sess,\n-                mutable uint chpos);\n+                mutable uint chpos,\n+                mutable uint next_ann);\n \n fn mk_env() -> env {\n     let env e = vec();\n@@ -113,7 +114,7 @@ fn eval_lit(ctx cx, span sp, @ast.lit lit) -> val {\n \n fn eval_expr(ctx cx, env e, @ast.expr x) -> val {\n     alt (x.node) {\n-        case (ast.expr_path(?pth, _, _)) {\n+        case (ast.expr_path(?pth, _)) {\n             if (Vec.len[ident](pth.node.idents) == 1u &&\n                 Vec.len[@ast.ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n@@ -383,12 +384,14 @@ fn eval_crate_directive(ctx cx,\n             }\n \n             auto start_id = cx.p.next_def_id();\n-            auto p0 = new_parser(cx.sess, e, start_id, full_path, cx.chpos);\n+            auto p0 = new_parser(cx.sess, e, start_id, full_path, cx.chpos,\n+                                 cx.next_ann);\n             auto m0 = parse_mod_items(p0, token.EOF);\n             auto next_id = p0.next_def_id();\n             // Thread defids and chpos through the parsers\n             cx.p.set_def(next_id._1);\n             cx.chpos = p0.get_chpos();\n+            cx.next_ann = p0.next_ann_num();\n             auto im = ast.item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n             Vec.push[@ast.item](items, i);"}, {"sha": "ab0800248ff067918f54004f01b0e21b448039df", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -121,7 +121,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast.expr] args)\n         let vec[@ast.ty] types = vec();\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n-        auto pathexpr = ast.expr_path(sp_path, none[ast.def], p.get_ann());\n+        auto pathexpr = ast.expr_path(sp_path, p.get_ann());\n         auto sp_pathexpr = @rec(node=pathexpr, span=sp);\n         ret sp_pathexpr;\n     }"}, {"sha": "fb43188af503ecbbed66da4cd67fcc5b5f2faff0", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -43,12 +43,13 @@ state type parser =\n           fn get_filemap() -> codemap.filemap;\n           fn get_chpos() -> uint;\n           fn get_ann() -> ast.ann;\n+          fn next_ann_num() -> uint;\n     };\n \n fn new_parser(session.session sess,\n                      eval.env env,\n                      ast.def_id initial_def,\n-                     str path, uint pos) -> parser {\n+                     str path, uint pos, uint next_ann) -> parser {\n     state obj stdio_parser(session.session sess,\n                            eval.env env,\n                            file_type ftype,\n@@ -134,6 +135,9 @@ fn new_parser(session.session sess,\n                 next_ann_var += 1u;\n                 ret rv;\n             }\n+            fn next_ann_num() -> uint {\n+                ret next_ann_var;\n+            }\n         }\n     auto ftype = SOURCE_FILE;\n     if (Str.ends_with(path, \".rc\")) {\n@@ -148,7 +152,7 @@ fn new_parser(session.session sess,\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, env, ftype, lexer.next_token(rdr),\n                      npos, npos, initial_def._1, UNRESTRICTED, initial_def._0,\n-                     rdr, prec_table(), 0u);\n+                     rdr, prec_table(), next_ann);\n }\n \n fn unexpected(parser p, token.token t) {\n@@ -474,7 +478,7 @@ fn parse_ty(parser p) -> @ast.ty {\n \n         case (token.IDENT(_)) {\n             auto path = parse_path(p, GREEDY);\n-            t = ast.ty_path(path, none[ast.def]);\n+            t = ast.ty_path(path, p.get_ann());\n             hi = path.span.hi;\n         }\n \n@@ -693,7 +697,7 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.IDENT(_)) {\n             auto pth = parse_path(p, MINIMAL);\n             hi = pth.span.hi;\n-            ex = ast.expr_path(pth, none[ast.def], p.get_ann());\n+            ex = ast.expr_path(pth, p.get_ann());\n         }\n \n         case (token.LPAREN) {\n@@ -985,15 +989,15 @@ fn extend_expr_by_ident(parser p, uint lo, uint hi,\n                                @ast.expr e, ast.ident i) -> @ast.expr {\n     auto e_ = e.node;\n     alt (e.node) {\n-        case (ast.expr_path(?pth, ?def, ?ann)) {\n+        case (ast.expr_path(?pth, ?ann)) {\n             if (Vec.len[@ast.ty](pth.node.types) == 0u) {\n                 auto idents_ = pth.node.idents;\n                 idents_ += vec(i);\n                 auto tys = parse_ty_args(p, hi);\n                 auto pth_ = spanned(pth.span.lo, tys.span.hi,\n                                     rec(idents=idents_,\n                                         types=tys.node));\n-                e_ = ast.expr_path(pth_, def, ann);\n+                e_ = ast.expr_path(pth_, ann);\n                 ret @spanned(pth_.span.lo, pth_.span.hi, e_);\n             } else {\n                 e_ = ast.expr_field(e, i, ann);\n@@ -1525,8 +1529,7 @@ fn parse_pat(parser p) -> @ast.pat {\n                 case (_) { args = vec(); }\n             }\n \n-            pat = ast.pat_tag(tag_path, args, none[ast.variant_def],\n-                              p.get_ann());\n+            pat = ast.pat_tag(tag_path, args, p.get_ann());\n         }\n         case (_) {\n             auto lit = parse_lit(p);\n@@ -1666,7 +1669,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_recv(_,_,_))     { ret true; }\n                 case (ast.expr_field(_,_,_))    { ret true; }\n                 case (ast.expr_index(_,_,_))    { ret true; }\n-                case (ast.expr_path(_,_,_))     { ret true; }\n+                case (ast.expr_path(_,_))       { ret true; }\n                 case (ast.expr_fail(_))         { ret true; }\n                 case (ast.expr_break(_))        { ret true; }\n                 case (ast.expr_cont(_))         { ret true; }\n@@ -2496,7 +2499,8 @@ fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n                    mode=eval.mode_parse,\n                    mutable deps = deps,\n                    sess=p.get_session(),\n-                   mutable chpos=p.get_chpos());\n+                   mutable chpos=p.get_chpos(),\n+                   mutable next_ann=p.next_ann_num());\n     auto m = eval.eval_crate_directives_to_mod(cx, p.get_env(),\n                                                cdirs, prefix);\n     auto hi = p.get_hi_pos();"}, {"sha": "7aa64fdb503c0b7fa434d618e9d525c02acdcebc", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -7,9 +7,11 @@ import std.Option.none;\n import std.Int;\n import std.Vec;\n import util.common;\n+import resolve.def_map;\n \n type fn_id_of_local = std.Map.hashmap[ast.def_id, ast.def_id];\n type env = rec(mutable vec[ast.def_id] current_context, // fn or obj\n+               def_map def_map,\n                fn_id_of_local idmap,\n                session.session sess);\n \n@@ -22,7 +24,7 @@ fn enter_item(@env e, &@ast.item i) {\n         case (ast.item_fn(?name, _, _, ?id, _)) {\n             Vec.push(e.current_context, id);\n         }\n-        case (ast.item_obj(_, _, _, ?ids, _)) {\n+        case (ast.item_obj(?name, _, _, ?ids, _)) {\n             Vec.push(e.current_context, ids.ty);\n         }\n         case (_) {}\n@@ -59,15 +61,14 @@ fn walk_expr(@env e, &@ast.expr x) {\n                 case (_) { }\n             }\n         }\n-        case (ast.expr_path(_, ?def, _)) {\n+        case (ast.expr_path(?pt, ?ann)) {\n             auto local_id;\n-            alt (Option.get(def)) {\n+            alt (e.def_map.get(ast.ann_tag(ann))) {\n                 case (ast.def_local(?id)) { local_id = id; }\n                 case (_) { ret; }\n             }\n-\n-            auto df = ast.def_id_of_def(Option.get(def));\n-            auto def_context = Option.get(e.idmap.find(df));\n+            auto df = ast.def_id_of_def(e.def_map.get(ast.ann_tag(ann)));\n+            auto def_context = e.idmap.get(df);\n \n             if (current_context(*e) != def_context) {\n                 e.sess.span_err(x.span,\n@@ -94,9 +95,10 @@ fn walk_block(@env e, &ast.block b) {\n     }\n }\n \n-fn check_for_captures(session.session sess, @ast.crate crate) {\n+fn check_for_captures(session.session sess, @ast.crate crate, def_map dm) {\n     let vec[ast.def_id] curctx = vec();\n     auto env = @rec(mutable current_context = curctx,\n+                    def_map = dm,\n                     idmap = common.new_def_hash[ast.def_id](),\n                     sess = sess);\n     auto visitor = rec(visit_item_pre = bind enter_item(env, _),"}, {"sha": "d3426684cbf58c7362b3d1420feca5c9eed2ea8e", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -67,7 +67,7 @@ type ast_fold[ENV] =\n          &@ty output) -> @ty)                     fold_ty_fn,\n \n      (fn(&ENV e, &span sp, &ast.path p,\n-         &Option.t[def] d) -> @ty)                fold_ty_path,\n+         &ann a) -> @ty)                          fold_ty_path,\n \n      (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_chan,\n      (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_port,\n@@ -171,7 +171,6 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          &path p,\n-         &Option.t[def] d,\n          &ann a) -> @expr)                        fold_expr_path,\n \n      (fn(&ENV e, &span sp,\n@@ -231,7 +230,6 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          &path p, &vec[@pat] args,\n-         &Option.t[ast.variant_def] d,\n          &ann a) -> @pat)                         fold_pat_tag,\n \n \n@@ -419,9 +417,9 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n             ret fld.fold_ty_obj(env_, t.span, meths_);\n         }\n \n-        case (ast.ty_path(?pth, ?ref_opt)) {\n+        case (ast.ty_path(?pth, ?ann)) {\n             auto pth_ = fold_path(env, fld, pth);\n-            ret fld.fold_ty_path(env_, t.span, pth_, ref_opt);\n+            ret fld.fold_ty_path(env_, t.span, pth_, ann);\n         }\n \n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n@@ -508,15 +506,15 @@ fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast.pat p) -> @ast.pat {\n         case (ast.pat_bind(?id, ?did, ?t)) {\n             ret fld.fold_pat_bind(env_, p.span, id, did, t);\n         }\n-        case (ast.pat_tag(?path, ?pats, ?d, ?t)) {\n+        case (ast.pat_tag(?path, ?pats, ?t)) {\n             auto ppath = fold_path(env, fld, path);\n \n             let vec[@ast.pat] ppats = vec();\n             for (@ast.pat pat in pats) {\n                 ppats += vec(fold_pat(env_, fld, pat));\n             }\n \n-            ret fld.fold_pat_tag(env_, p.span, ppath, ppats, d, t);\n+            ret fld.fold_pat_tag(env_, p.span, ppath, ppats, t);\n         }\n     }\n }\n@@ -742,10 +740,10 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_index(env_, e.span, ee, iix, t2);\n         }\n \n-        case (ast.expr_path(?p, ?r, ?t)) {\n+        case (ast.expr_path(?p, ?t)) {\n             auto p_ = fold_path(env_, fld, p);\n             auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_path(env_, e.span, p_, r, t2);\n+            ret fld.fold_expr_path(env_, e.span, p_, t2);\n         }\n \n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?t)) {\n@@ -1201,8 +1199,8 @@ fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast.path p,\n-                              &Option.t[def] d) -> @ty {\n-    ret @respan(sp, ast.ty_path(p, d));\n+                              &ann a) -> @ty {\n+    ret @respan(sp, ast.ty_path(p, a));\n }\n \n fn identity_fold_ty_chan[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n@@ -1349,9 +1347,8 @@ fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n-                                &path p, &Option.t[def] d,\n-                                &ann a) -> @expr {\n-    ret @respan(sp, ast.expr_path(p, d, a));\n+                                &path p, &ann a) -> @expr {\n+    ret @respan(sp, ast.expr_path(p, a));\n }\n \n fn identity_fold_expr_ext[ENV](&ENV env, &span sp,\n@@ -1443,8 +1440,8 @@ fn identity_fold_pat_bind[ENV](&ENV e, &span sp, &ident i,\n }\n \n fn identity_fold_pat_tag[ENV](&ENV e, &span sp, &path p, &vec[@pat] args,\n-                              &Option.t[ast.variant_def] d, &ann a) -> @pat {\n-    ret @respan(sp, ast.pat_tag(p, args, d, a));\n+                              &ann a) -> @pat {\n+    ret @respan(sp, ast.pat_tag(p, args, a));\n }\n \n \n@@ -1692,7 +1689,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_recv   = bind identity_fold_expr_recv[ENV](_,_,_,_,_),\n          fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),\n          fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n-         fold_expr_path   = bind identity_fold_expr_path[ENV](_,_,_,_,_),\n+         fold_expr_path   = bind identity_fold_expr_path[ENV](_,_,_,_),\n          fold_expr_ext    = bind identity_fold_expr_ext[ENV](_,_,_,_,_,_,_),\n          fold_expr_fail   = bind identity_fold_expr_fail[ENV](_,_,_),\n          fold_expr_break  = bind identity_fold_expr_break[ENV](_,_,_),\n@@ -1715,7 +1712,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_pat_wild    = bind identity_fold_pat_wild[ENV](_,_,_),\n          fold_pat_lit     = bind identity_fold_pat_lit[ENV](_,_,_,_),\n          fold_pat_bind    = bind identity_fold_pat_bind[ENV](_,_,_,_,_),\n-         fold_pat_tag     = bind identity_fold_pat_tag[ENV](_,_,_,_,_,_),\n+         fold_pat_tag     = bind identity_fold_pat_tag[ENV](_,_,_,_,_),\n \n          fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_,_),\n          fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_,_),"}, {"sha": "1305ad5f539a12869e50d3eeb16ed5fb46fa7b37", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -7,6 +7,7 @@ import front.creader;\n import driver.session.session;\n import util.common.new_def_hash;\n import util.common.new_int_hash;\n+import util.common.new_uint_hash;\n import util.common.new_str_hash;\n import util.common.span;\n import util.typestate_ann.ts_ann;\n@@ -74,7 +75,10 @@ tag native_mod_index_entry {\n type nmod_index = hashmap[ident,native_mod_index_entry];\n type indexed_nmod = rec(ast.native_mod m, nmod_index index);\n \n-type env = rec(hashmap[ast.def_num,import_state] imports,\n+type def_map = hashmap[uint,def];\n+\n+type env = rec(def_map def_map,\n+               hashmap[ast.def_num,import_state] imports,\n                hashmap[ast.def_num,@indexed_mod] mod_map,\n                hashmap[ast.def_num,@indexed_nmod] nmod_map,\n                hashmap[def_id,vec[ident]] ext_map,\n@@ -90,16 +94,18 @@ tag namespace {\n     ns_type;\n }\n \n-fn resolve_crate(session sess, @ast.crate crate) -> @ast.crate {\n-    auto e = @rec(imports = new_int_hash[import_state](),\n+fn resolve_crate(session sess, @ast.crate crate)\n+    -> tup(@ast.crate, def_map) {\n+    auto e = @rec(def_map = new_uint_hash[def](),\n+                  imports = new_int_hash[import_state](),\n                   mod_map = new_int_hash[@indexed_mod](),\n                   nmod_map = new_int_hash[@indexed_nmod](),\n                   ext_map = new_def_hash[vec[ident]](),\n                   ext_cache = new_ext_hash(),\n                   sess = sess);\n     map_crate(e, *crate);\n     resolve_imports(*e);\n-    ret resolve_names(e, *crate);\n+    ret tup(resolve_names(e, *crate), e.def_map);\n }\n \n // Locate all modules and imports and index them, so that the next passes can\n@@ -165,8 +171,8 @@ fn resolve_imports(&env e) {\n }\n \n fn resolve_names(&@env e, &ast.crate c) -> @ast.crate {\n-    auto fld = @rec(fold_pat_tag = bind fold_pat_tag(e,_,_,_,_,_,_),\n-                    fold_expr_path = bind fold_expr_path(e,_,_,_,_,_),\n+    auto fld = @rec(fold_pat_tag = bind fold_pat_tag(e,_,_,_,_,_),\n+                    fold_expr_path = bind fold_expr_path(e,_,_,_,_),\n                     fold_ty_path = bind fold_ty_path(e,_,_,_,_),\n                     update_env_for_crate = bind update_env_for_crate(_,_),\n                     update_env_for_item = bind update_env_for_item(_,_),\n@@ -291,8 +297,8 @@ fn resolve_import(&env e, &@ast.view_item it, &list[scope] sc) {\n // and split that off as the 'primary' expr_path, with secondary expr_field\n // expressions tacked on the end.\n \n-fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n-                  &Option.t[def] d, &ann a) -> @ast.expr {\n+fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p, &ann a)\n+    -> @ast.expr {\n     auto idents = p.node.idents;\n     auto n_idents = Vec.len(idents);\n     assert (n_idents != 0u);\n@@ -310,7 +316,10 @@ fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n     }\n \n     p = rec(node=rec(idents=Vec.slice(idents, 0u, i) with p.node) with p);\n-    auto ex = @fold.respan(sp, ast.expr_path(p, some(dcur), a));\n+    auto ex = @fold.respan(sp, ast.expr_path(p, a));\n+    e.def_map.insert(ast.ann_tag(a), dcur);\n+    // FIXME this duplicates the ann. Is that a problem? How will we deal with\n+    // splitting this into path and field exprs when we don't fold?\n     while (i < n_idents) {\n         ex = @fold.respan(sp, ast.expr_field(ex, idents.(i), a));\n         i += 1u;\n@@ -319,33 +328,12 @@ fn fold_expr_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n }\n \n \n-fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n-                      namespace ns) -> def {\n-    auto n_idents = Vec.len(idents);\n-    auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), ns);\n-    auto i = 1u;\n-    while (i < n_idents) {\n-        if (!is_module(dcur)) {\n-            e.sess.span_err(sp, idents.(i-1u) +\n-                            \" can't be dereferenced as a module\");\n-        }\n-        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), ns, outside);\n-        i += 1u;\n-    }\n-    if (is_module(dcur)) {\n-        e.sess.span_err(sp, Str.connect(idents, \".\") +\n-                        \" is a module, not a \" + ns_name(ns));\n-    }\n-    ret dcur;\n-}\n-                      \n fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast.path p,\n-                &vec[@ast.pat] args, &Option.t[ast.variant_def] old_def,\n-                &ann a) -> @ast.pat {\n+                &vec[@ast.pat] args, &ann a) -> @ast.pat {\n     alt (lookup_path_strict(*e, sc, sp, p.node.idents, ns_value)) {\n         case (ast.def_variant(?did, ?vid)) {\n-            auto new_def = some[ast.variant_def](tup(did, vid));\n-            ret @fold.respan[ast.pat_](sp, ast.pat_tag(p, args, new_def, a));\n+            e.def_map.insert(ast.ann_tag(a), ast.def_variant(did, vid));\n+            ret @fold.respan[ast.pat_](sp, ast.pat_tag(p, args, a));\n         }\n         case (_) {\n             e.sess.span_err(sp, \"not a tag variant: \" +\n@@ -356,9 +344,10 @@ fn fold_pat_tag(@env e, &list[scope] sc, &span sp, &ast.path p,\n }\n \n fn fold_ty_path(@env e, &list[scope] sc, &span sp, &ast.path p,\n-                &Option.t[def] d) -> @ast.ty {\n+                &ast.ann a) -> @ast.ty {\n     auto new_def = lookup_path_strict(*e, sc, sp, p.node.idents, ns_type);\n-    ret @fold.respan[ast.ty_](sp, ast.ty_path(p, some(new_def)));\n+    e.def_map.insert(ast.ann_tag(a), new_def);\n+    ret @fold.respan[ast.ty_](sp, ast.ty_path(p, a));\n }\n \n fn is_module(def d) -> bool {\n@@ -380,6 +369,26 @@ fn unresolved(&env e, &span sp, ident id, str kind) {\n     e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n }\n \n+fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n+                      namespace ns) -> def {\n+    auto n_idents = Vec.len(idents);\n+    auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), ns);\n+    auto i = 1u;\n+    while (i < n_idents) {\n+        if (!is_module(dcur)) {\n+            e.sess.span_err(sp, idents.(i-1u) +\n+                            \" can't be dereferenced as a module\");\n+        }\n+        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), ns, outside);\n+        i += 1u;\n+    }\n+    if (is_module(dcur)) {\n+        e.sess.span_err(sp, Str.connect(idents, \".\") +\n+                        \" is a module, not a \" + ns_name(ns));\n+    }\n+    ret dcur;\n+}\n+                      \n fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, ident id,\n                         namespace ns) -> def {\n     alt (lookup_in_scope(e, sc, id, ns)) {\n@@ -497,7 +506,7 @@ fn lookup_in_pat(ident id, &ast.pat pat) -> Option.t[def] {\n         }\n         case (ast.pat_wild(_)) {}\n         case (ast.pat_lit(_, _)) {}\n-        case (ast.pat_tag(_, ?pats, _, _)) {\n+        case (ast.pat_tag(_, ?pats, _)) {\n             for (@ast.pat p in pats) {\n                 auto found = lookup_in_pat(id, *p);\n                 if (found != none[def]) { ret found; }"}, {"sha": "d6e86045c4f41d405ecfeeef5102af8c6abfe003", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 102, "deletions": 104, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -3621,13 +3621,14 @@ fn collect_upvars(&@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n         -> vec[ast.def_id] {\n     type env = @rec(\n         mutable vec[ast.def_id] refs,\n-        hashmap[ast.def_id,()] decls\n+        hashmap[ast.def_id,()] decls,\n+        resolve.def_map def_map\n     );\n \n     fn walk_expr(env e, &@ast.expr expr) {\n         alt (expr.node) {\n-            case (ast.expr_path(?path, ?d, _)) {\n-                alt (Option.get[ast.def](d)) {\n+            case (ast.expr_path(?path, ?ann)) {\n+                alt (e.def_map.get(ast.ann_tag(ann))) {\n                     case (ast.def_arg(?did)) {\n                         Vec.push[ast.def_id](e.refs, did);\n                     }\n@@ -3656,7 +3657,9 @@ fn collect_upvars(&@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n     let vec[ast.def_id] refs = vec();\n     let hashmap[ast.def_id,()] decls = new_def_hash[()]();\n     decls.insert(initial_decl, ());\n-    let env e = @rec(mutable refs=refs, decls=decls);\n+    let env e = @rec(mutable refs=refs,\n+                     decls=decls,\n+                     def_map=cx.fcx.lcx.ccx.tcx.def_map);\n \n     auto visitor = @rec(visit_decl_pre = bind walk_decl(e, _),\n                         visit_expr_pre = bind walk_expr(e, _)\n@@ -3941,24 +3944,24 @@ fn trans_pat_match(&@block_ctxt cx, &@ast.pat pat, ValueRef llval,\n             ret res(matched_cx, llval);\n         }\n \n-        case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n+        case (ast.pat_tag(?id, ?subpats, ?ann)) {\n             auto lltagptr = cx.build.PointerCast(llval,\n                 T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n \n             auto lldiscrimptr = cx.build.GEP(lltagptr,\n                                              vec(C_int(0), C_int(0)));\n             auto lldiscrim = cx.build.Load(lldiscrimptr);\n \n-            auto vdef = Option.get[ast.variant_def](vdef_opt);\n-            auto variant_id = vdef._1;\n+            auto vdef = ast.variant_def_ids\n+                (cx.fcx.lcx.ccx.tcx.def_map.get(ast.ann_tag(ann)));\n             auto variant_tag = 0;\n \n             auto variants = tag_variants(cx.fcx.lcx.ccx, vdef._0);\n             auto i = 0;\n             for (variant_info v in variants) {\n                 auto this_variant_id = v.id;\n-                if (variant_id._0 == this_variant_id._0 &&\n-                    variant_id._1 == this_variant_id._1) {\n+                if (vdef._1._0 == this_variant_id._0 &&\n+                    vdef._1._1 == this_variant_id._1) {\n                     variant_tag = i;\n                 }\n                 i += 1;\n@@ -4021,11 +4024,12 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast.pat pat,\n                 ret copy_ty(bcx, INIT, dst, llval, t);\n             }\n         }\n-        case (ast.pat_tag(_, ?subpats, ?vdef_opt, ?ann)) {\n+        case (ast.pat_tag(_, ?subpats, ?ann)) {\n             if (Vec.len[@ast.pat](subpats) == 0u) { ret res(cx, llval); }\n \n             // Get the appropriate variant for this tag.\n-            auto vdef = Option.get[ast.variant_def](vdef_opt);\n+            auto vdef = ast.variant_def_ids\n+                (cx.fcx.lcx.ccx.tcx.def_map.get(ast.ann_tag(ann)));\n \n             auto lltagptr = cx.build.PointerCast(llval,\n                 T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n@@ -4191,109 +4195,103 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast.def_id tid, &ast.def_id vid)\n     }\n }\n \n-fn trans_path(&@block_ctxt cx, &ast.path p, &Option.t[ast.def] dopt,\n-              &ast.ann ann) -> lval_result {\n-    alt (dopt) {\n-        case (some[ast.def](?def)) {\n-            alt (def) {\n-                case (ast.def_arg(?did)) {\n-                    alt (cx.fcx.llargs.find(did)) {\n-                        case (none[ValueRef]) {\n-                            assert (cx.fcx.llupvars.contains_key(did));\n-                            ret lval_mem(cx, cx.fcx.llupvars.get(did));\n-                        }\n-                        case (some[ValueRef](?llval)) {\n-                            ret lval_mem(cx, llval);\n-                        }\n-                    }\n-                }\n-                case (ast.def_local(?did)) {\n-                    alt (cx.fcx.lllocals.find(did)) {\n-                        case (none[ValueRef]) {\n-                            assert (cx.fcx.llupvars.contains_key(did));\n-                            ret lval_mem(cx, cx.fcx.llupvars.get(did));\n-                        }\n-                        case (some[ValueRef](?llval)) {\n-                            ret lval_mem(cx, llval);\n-                        }\n-                    }\n+fn trans_path(&@block_ctxt cx, &ast.path p, &ast.ann ann) -> lval_result {\n+    alt (cx.fcx.lcx.ccx.tcx.def_map.get(ast.ann_tag(ann))) {\n+        case (ast.def_arg(?did)) {\n+            alt (cx.fcx.llargs.find(did)) {\n+                case (none[ValueRef]) {\n+                    assert (cx.fcx.llupvars.contains_key(did));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                 }\n-                case (ast.def_binding(?did)) {\n-                    assert (cx.fcx.lllocals.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.lllocals.get(did));\n+                case (some[ValueRef](?llval)) {\n+                    ret lval_mem(cx, llval);\n                 }\n-                case (ast.def_obj_field(?did)) {\n-                    assert (cx.fcx.llobjfields.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n+            }\n+        }\n+        case (ast.def_local(?did)) {\n+            alt (cx.fcx.lllocals.find(did)) {\n+                case (none[ValueRef]) {\n+                    assert (cx.fcx.llupvars.contains_key(did));\n+                    ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                 }\n-                case (ast.def_fn(?did)) {\n-                    auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.type_cache, did);\n-                    ret lval_generic_fn(cx, tyt, did, ann);\n+                case (some[ValueRef](?llval)) {\n+                    ret lval_mem(cx, llval);\n                 }\n-                case (ast.def_obj(?did)) {\n-                    auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.type_cache, did);\n-                    ret lval_generic_fn(cx, tyt, did, ann);\n+            }\n+        }\n+        case (ast.def_binding(?did)) {\n+            assert (cx.fcx.lllocals.contains_key(did));\n+            ret lval_mem(cx, cx.fcx.lllocals.get(did));\n+        }\n+        case (ast.def_obj_field(?did)) {\n+            assert (cx.fcx.llobjfields.contains_key(did));\n+            ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n+        }\n+        case (ast.def_fn(?did)) {\n+            auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                                           cx.fcx.lcx.ccx.tcx,\n+                                           cx.fcx.lcx.ccx.type_cache, did);\n+            ret lval_generic_fn(cx, tyt, did, ann);\n+        }\n+        case (ast.def_obj(?did)) {\n+            auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                                           cx.fcx.lcx.ccx.tcx,\n+                                           cx.fcx.lcx.ccx.type_cache, did);\n+            ret lval_generic_fn(cx, tyt, did, ann);\n+        }\n+        case (ast.def_variant(?tid, ?vid)) {\n+            auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                                             cx.fcx.lcx.ccx.tcx,\n+                                             cx.fcx.lcx.ccx.type_cache, vid);\n+            alt (ty.struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n+                case (ty.ty_fn(_, _, _)) {\n+                    // N-ary variant.\n+                    ret lval_generic_fn(cx, v_tyt, vid, ann);\n                 }\n-                case (ast.def_variant(?tid, ?vid)) {\n-                    auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tcx, cx.fcx.lcx.ccx.type_cache, vid);\n-                    alt (ty.struct(cx.fcx.lcx.ccx.tcx, v_tyt._1)) {\n-                        case (ty.ty_fn(_, _, _)) {\n-                            // N-ary variant.\n-                            ret lval_generic_fn(cx, v_tyt, vid, ann);\n-                        }\n-                        case (_) {\n-                            // Nullary variant.\n-                            auto tag_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n-                            auto lldiscrim_gv =\n-                                lookup_discriminant(cx.fcx.lcx, tid, vid);\n-                            auto lldiscrim = cx.build.Load(lldiscrim_gv);\n-\n-                            auto alloc_result = alloc_ty(cx, tag_ty);\n-                            auto lltagblob = alloc_result.val;\n-\n-                            auto lltagty;\n-                            if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx,\n-                                                         tag_ty)) {\n-                                lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n-                            } else {\n-                                lltagty = type_of(cx.fcx.lcx.ccx, tag_ty);\n-                            }\n-                            auto lltagptr = alloc_result.bcx.build.\n-                                PointerCast(lltagblob, T_ptr(lltagty));\n+                case (_) {\n+                    // Nullary variant.\n+                    auto tag_ty = node_ann_type(cx.fcx.lcx.ccx, ann);\n+                    auto lldiscrim_gv =\n+                        lookup_discriminant(cx.fcx.lcx, tid, vid);\n+                    auto lldiscrim = cx.build.Load(lldiscrim_gv);\n+\n+                    auto alloc_result = alloc_ty(cx, tag_ty);\n+                    auto lltagblob = alloc_result.val;\n+\n+                    auto lltagty;\n+                    if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx,\n+                                                 tag_ty)) {\n+                        lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n+                    } else {\n+                        lltagty = type_of(cx.fcx.lcx.ccx, tag_ty);\n+                    }\n+                    auto lltagptr = alloc_result.bcx.build.\n+                        PointerCast(lltagblob, T_ptr(lltagty));\n \n-                            auto lldiscrimptr = alloc_result.bcx.build.GEP(\n-                                lltagptr, vec(C_int(0), C_int(0)));\n-                            alloc_result.bcx.build.Store(lldiscrim,\n-                                                         lldiscrimptr);\n+                    auto lldiscrimptr = alloc_result.bcx.build.GEP\n+                        (lltagptr, vec(C_int(0), C_int(0)));\n+                    alloc_result.bcx.build.Store(lldiscrim,\n+                                                 lldiscrimptr);\n \n-                            ret lval_val(alloc_result.bcx, lltagptr);\n-                        }\n-                    }\n-                }\n-                case (ast.def_const(?did)) {\n-                    // TODO: externals\n-                    assert (cx.fcx.lcx.ccx.consts.contains_key(did));\n-                    ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n-                }\n-                case (ast.def_native_fn(?did)) {\n-                    auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n-                        cx.fcx.lcx.ccx.tcx,\n-                        cx.fcx.lcx.ccx.type_cache, did);\n-                    ret lval_generic_fn(cx, tyt, did, ann);\n-                }\n-                case (_) {\n-                    cx.fcx.lcx.ccx.sess.unimpl(\"def variant in trans\");\n+                    ret lval_val(alloc_result.bcx, lltagptr);\n                 }\n             }\n         }\n-        case (none[ast.def]) {\n-            cx.fcx.lcx.ccx.sess.err(\"unresolved expr_path in trans\");\n+        case (ast.def_const(?did)) {\n+            // TODO: externals\n+            assert (cx.fcx.lcx.ccx.consts.contains_key(did));\n+            ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n+        }\n+        case (ast.def_native_fn(?did)) {\n+            auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                                           cx.fcx.lcx.ccx.tcx,\n+                                           cx.fcx.lcx.ccx.type_cache, did);\n+            ret lval_generic_fn(cx, tyt, did, ann);\n+        }\n+        case (_) {\n+            cx.fcx.lcx.ccx.sess.unimpl(\"def variant in trans\");\n         }\n     }\n-    fail;\n }\n \n fn trans_field(&@block_ctxt cx, &ast.span sp, ValueRef v, &ty.t t0,\n@@ -4402,8 +4400,8 @@ fn trans_index(&@block_ctxt cx, &ast.span sp, &@ast.expr base,\n \n fn trans_lval(&@block_ctxt cx, &@ast.expr e) -> lval_result {\n     alt (e.node) {\n-        case (ast.expr_path(?p, ?dopt, ?ann)) {\n-            ret trans_path(cx, p, dopt, ann);\n+        case (ast.expr_path(?p, ?ann)) {\n+            ret trans_path(cx, p, ann);\n         }\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n             auto r = trans_expr(cx, base);"}, {"sha": "c749b2208c683bb85600bc424534595160665d5e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -55,6 +55,7 @@ type mt = rec(t ty, ast.mutability mut);\n type creader_cache = hashmap[tup(int,uint,uint),ty.t];\n type ctxt = rec(@type_store ts,\n                 session.session sess,\n+                resolve.def_map def_map,\n                 creader_cache rcache,\n                 hashmap[t,str] short_names_cache);\n type ty_ctxt = ctxt;    // Needed for disambiguation from Unify.ctxt.\n@@ -209,9 +210,10 @@ fn mk_rcache() -> creader_cache {\n     ret Map.mk_hashmap[tup(int,uint,uint),t](h, e);\n }\n \n-fn mk_ctxt(session.session s) -> ctxt {\n+fn mk_ctxt(session.session s, resolve.def_map dm) -> ctxt {\n     ret rec(ts = mk_type_store(),\n             sess = s,\n+            def_map = dm,\n             rcache = mk_rcache(),\n             short_names_cache =\n                 Map.mk_hashmap[ty.t,str](ty.hash_ty, ty.eq_ty));\n@@ -1640,7 +1642,7 @@ fn pat_ty(&ctxt cx, &@ast.pat pat) -> t {\n         case (ast.pat_wild(?ann))           { ret ann_to_monotype(cx, ann); }\n         case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(cx, ann); }\n         case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(cx, ann); }\n-        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_monotype(cx, ann); }\n+        case (ast.pat_tag(_, _, ?ann))      { ret ann_to_monotype(cx, ann); }\n     }\n     fail;   // not reached\n }\n@@ -1713,7 +1715,7 @@ fn expr_ann(&@ast.expr e) -> ast.ann {\n         case (ast.expr_index(_,_,?a)) {\n             ret a;\n         }\n-        case (ast.expr_path(_,_,?a)) {\n+        case (ast.expr_path(_,?a)) {\n             ret a;\n         }\n         case (ast.expr_ext(_,_,_,_,?a)) {\n@@ -1816,9 +1818,9 @@ fn replace_expr_type(&@ast.expr expr,\n             ret @fold.respan(expr.span,\n                              ast.expr_field(e, i, mkann(a)));\n         }\n-        case (ast.expr_path(?p, ?dopt, ?a)) {\n+        case (ast.expr_path(?p, ?a)) {\n             ret @fold.respan(expr.span,\n-                             ast.expr_path(p, dopt, mkann(a)));\n+                             ast.expr_path(p, mkann(a)));\n         }\n         case (_) {\n             log_err \"unhandled expr type in replace_expr_type(): \" +\n@@ -1897,7 +1899,7 @@ fn is_lval(&@ast.expr expr) -> bool {\n     alt (expr.node) {\n         case (ast.expr_field(_,_,_))    { ret true;  }\n         case (ast.expr_index(_,_,_))    { ret true;  }\n-        case (ast.expr_path(_,_,_))     { ret true;  }\n+        case (ast.expr_path(_,_))       { ret true;  }\n         case (ast.expr_unary(ast.deref,_,_))  { ret true; }\n         case (_)                        { ret false; }\n     }"}, {"sha": "a8114cd174a5f9ddb0dcf9456d7aa831f5b9d5eb", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -313,9 +313,8 @@ fn ast_ty_to_ty(&ty.ctxt tcx, &ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n             typ = ty.mk_fn(tcx, proto, i, out_ty);\n         }\n \n-        case (ast.ty_path(?path, ?def)) {\n-            assert (def != none[ast.def]);\n-            alt (Option.get[ast.def](def)) {\n+        case (ast.ty_path(?path, ?ann)) {\n+            alt (tcx.def_map.get(ast.ann_tag(ann))) {\n                 case (ast.def_ty(?id)) {\n                     typ = instantiate(tcx, getter, id, path.node.types);\n                 }\n@@ -1137,7 +1136,7 @@ mod Pushdown {\n                                                          none[vec[ty.t]],\n                                                          none[@ts_ann]));\n             }\n-            case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n+            case (ast.pat_tag(?id, ?subpats, ?ann)) {\n                 // Take the variant's type parameters out of the expected\n                 // type.\n                 auto tag_tps;\n@@ -1150,9 +1149,13 @@ mod Pushdown {\n                 }\n \n                 // Get the types of the arguments of the variant.\n-                auto vdef = Option.get[ast.variant_def](vdef_opt);\n-                auto arg_tys = variant_arg_types(fcx.ccx, pat.span, vdef._1,\n-                                                 tag_tps);\n+                auto arg_tys;\n+                alt (fcx.ccx.tcx.def_map.get(ast.ann_tag(ann))) {\n+                    case (ast.def_variant(_, ?vdefid)) {\n+                        arg_tys = variant_arg_types(fcx.ccx, pat.span, vdefid,\n+                                                    tag_tps);\n+                    }\n+                }\n \n                 let vec[@ast.pat] subpats_1 = vec();\n                 auto i = 0u;\n@@ -1162,7 +1165,7 @@ mod Pushdown {\n                 }\n \n                 // TODO: push down type from \"expected\".\n-                p_1 = ast.pat_tag(id, subpats_1, vdef_opt, ann);\n+                p_1 = ast.pat_tag(id, subpats_1, ann);\n             }\n         }\n \n@@ -1387,7 +1390,7 @@ mod Pushdown {\n                                           ann_to_type(ann), adk);\n                 e_1 = ast.expr_index(base, index, triv_ann(ann, t));\n             }\n-            case (ast.expr_path(?pth, ?d, ?ann)) {\n+            case (ast.expr_path(?pth, ?ann)) {\n                 auto tp_substs_0 = ty.ann_to_type_params(ann);\n                 auto t_0 = ann_to_type(ann);\n \n@@ -1416,7 +1419,7 @@ mod Pushdown {\n                     }\n                 }\n \n-                e_1 = ast.expr_path(pth, d,\n+                e_1 = ast.expr_path(pth,\n                                     ast.ann_type(ast.ann_tag(ann), t,\n                                                  ty_params_opt,\n                                                  none[@ts_ann]));\n@@ -1634,8 +1637,9 @@ fn check_pat(&@fn_ctxt fcx, &@ast.pat pat) -> @ast.pat {\n             auto ann = triv_ann(a, next_ty_var(fcx.ccx));\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n-        case (ast.pat_tag(?p, ?subpats, ?vdef_opt, ?old_ann)) {\n-            auto vdef = Option.get[ast.variant_def](vdef_opt);\n+        case (ast.pat_tag(?p, ?subpats, ?old_ann)) {\n+            auto vdef = ast.variant_def_ids\n+                (fcx.ccx.tcx.def_map.get(ast.ann_tag(old_ann)));\n             auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                          fcx.ccx.type_cache, vdef._1)._1;\n             auto len = Vec.len[ast.ident](p.node.idents);\n@@ -1668,7 +1672,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast.pat pat) -> @ast.pat {\n                         new_subpats += vec(check_pat(fcx, subpat));\n                     }\n \n-                    new_pat = ast.pat_tag(p, new_subpats, vdef_opt, ann);\n+                    new_pat = ast.pat_tag(p, new_subpats, ann);\n                 }\n \n                 // Nullary variants have tag types.\n@@ -1686,7 +1690,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast.pat pat) -> @ast.pat {\n                         fail;   // TODO: recover\n                     }\n \n-                    new_pat = ast.pat_tag(p, subpats, vdef_opt, ann);\n+                    new_pat = ast.pat_tag(p, subpats, ann);\n                 }\n             }\n         }\n@@ -1722,7 +1726,11 @@ fn require_pure_call(@crate_ctxt ccx,\n         }\n         case (ast.pure_fn) {\n             alt (callee.node) {\n-                case (ast.expr_path(_, some[ast.def](ast.def_fn(?d_id)), _)) {\n+                case (ast.expr_path(_, ?ann)) {\n+                    auto d_id;\n+                    alt (ccx.tcx.def_map.get(ast.ann_tag(ann))) {\n+                        case (ast.def_fn(?_d_id)) { d_id = _d_id; }\n+                    }\n                     alt (get_function_purity(ccx, d_id)) {\n                             case (ast.pure_fn) {\n                                 ret;\n@@ -1918,18 +1926,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                                         ast.expr_unary(unop, oper_1, ann));\n         }\n \n-        case (ast.expr_path(?pth, ?defopt, ?old_ann)) {\n+        case (ast.expr_path(?pth, ?old_ann)) {\n             auto t = ty.mk_nil(fcx.ccx.tcx);\n-            assert (defopt != none[ast.def]);\n-            auto defn = Option.get[ast.def](defopt);\n+            auto defn = fcx.ccx.tcx.def_map.get(ast.ann_tag(old_ann));\n \n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n \n             if (ty.def_has_ty_params(defn)) {\n                 auto ann = instantiate_path(fcx, pth, tpt, expr.span,\n                                             ast.ann_tag(old_ann));\n                 ret @fold.respan[ast.expr_](expr.span,\n-                                            ast.expr_path(pth, defopt, ann));\n+                                            ast.expr_path(pth, ann));\n             }\n \n             // The definition doesn't take type parameters. If the programmer\n@@ -1940,7 +1947,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 fail;\n             }\n \n-            auto e = ast.expr_path(pth, defopt, triv_ann(old_ann, tpt._1));\n+            auto e = ast.expr_path(pth, triv_ann(old_ann, tpt._1));\n             ret @fold.respan[ast.expr_](expr.span, e);\n         }\n \n@@ -2046,9 +2053,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             alt (e.node) {\n                 case (ast.expr_call(?operator, ?operands, _)) {\n                     alt (operator.node) {\n-                        case (ast.expr_path(?oper_name,\n-                                some[ast.def](ast.def_fn(?d_id)), _)) {\n-\n+                        case (ast.expr_path(?oper_name, ?ann)) {\n+                            auto d_id;\n+                            alt (fcx.ccx.tcx.def_map.get(ast.ann_tag(ann))) {\n+                                case (ast.def_fn(?_d_id)) { d_id = _d_id; }\n+                            }\n                             for (@ast.expr operand in operands) {\n                                 if (! ast.is_constraint_arg(operand)) {\n                                     fcx.ccx.sess.span_err(expr.span,"}, {"sha": "b13364184fe7388ef3e0c486def801562b1fb313", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 255, "deletions": 252, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -189,6 +189,8 @@ import util.typestate_ann.union;\n import util.typestate_ann.pps_len;\n import util.typestate_ann.require_and_preserve;\n \n+import resolve.def_map;\n+\n /**** debugging junk  ****/\n \n fn bitv_to_str(fn_info enclosing, BitV.t v) -> str {\n@@ -711,36 +713,37 @@ fn find_pre_post_state_native_mod(&native_mod m) -> bool {\n     fail;\n }\n  \n-fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n-    fn do_a_method(fn_info_map fm, &@method m) -> () {\n+fn find_pre_post_obj(&def_map dm, &fn_info_map fm, _obj o) -> () {\n+    fn do_a_method(def_map dm, fn_info_map fm, &@method m) -> () {\n         assert (fm.contains_key(m.node.id));\n-        find_pre_post_fn(fm, fm.get(m.node.id), m.node.meth);\n+        find_pre_post_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n     }\n-    auto f = bind do_a_method(fm,_);\n+    auto f = bind do_a_method(dm, fm, _);\n     Vec.map[@method, ()](f, o.methods);\n     Option.map[@method, ()](f, o.dtor);\n }\n \n-fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n-    fn do_a_method(fn_info_map fm, &@method m) -> bool {\n+fn find_pre_post_state_obj(&def_map dm, &fn_info_map fm, _obj o) -> bool {\n+    fn do_a_method(def_map dm, fn_info_map fm, &@method m) -> bool {\n         assert (fm.contains_key(m.node.id));\n-        ret find_pre_post_state_fn(fm, fm.get(m.node.id), m.node.meth);\n+        ret find_pre_post_state_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n     }\n-    auto f = bind do_a_method(fm,_);\n+    auto f = bind do_a_method(dm, fm, _);\n     auto flags = Vec.map[@method, bool](f, o.methods);\n     auto changed = Vec.or(flags);\n     changed = changed || maybe[@method, bool](false, f, o.dtor);\n     ret changed;\n }\n \n-fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n+fn find_pre_post_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n+                      &item i) -> () {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n-        find_pre_post_expr(fm, enclosing, e);\n+        find_pre_post_expr(dm, fm, enclosing, e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n       assert (fm.contains_key(di));\n-      find_pre_post_fn(fm, fm.get(di), f);\n+      find_pre_post_fn(dm, fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n       find_pre_post_mod(m);\n@@ -755,7 +758,7 @@ fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n       ret;\n     }\n     case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n-        find_pre_post_obj(fm, o);\n+        find_pre_post_obj(dm, fm, o);\n     }\n   }\n }\n@@ -764,15 +767,15 @@ fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to \n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_exprs(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                        &vec[@expr] args, ann a) {\n     auto nv = num_locals(enclosing);\n \n-    fn do_one(fn_info_map fm, fn_info enclosing,\n+    fn do_one(def_map dm, fn_info_map fm, fn_info enclosing,\n               &@expr e) -> () {\n-        find_pre_post_expr(fm, enclosing, e);\n+        find_pre_post_expr(dm, fm, enclosing, e);\n     }\n-    auto f = bind do_one(fm, enclosing, _);\n+    auto f = bind do_one(dm, fm, enclosing, _);\n \n     Vec.map[@expr, ()](f, args);\n \n@@ -789,10 +792,10 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n            (nv, (Vec.map[pre_and_post, postcond](h, pps)))));\n }\n \n-fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n-     &@expr index, &block body, &ann a) -> () {\n-    find_pre_post_expr(fm, enclosing, index);\n-    find_pre_post_block(fm, enclosing, body);\n+fn find_pre_post_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n+                      &@decl d, &@expr index, &block body, &ann a) -> () {\n+    find_pre_post_expr(dm, fm, enclosing, index);\n+    find_pre_post_block(dm, fm, enclosing, body);\n     auto loop_precond = declare_var(enclosing, decl_lhs(d),\n            seq_preconds(enclosing, vec(expr_pp(index),\n                                        block_pp(body))));\n@@ -803,48 +806,35 @@ fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n+fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n+                      @expr e) -> () {\n     auto num_local_vars = num_locals(enclosing);\n \n-    fn do_rand_(fn_info_map fm, fn_info enclosing, &@expr e) -> () {\n-        find_pre_post_expr(fm, enclosing, e);\n-    }\n-    fn pp_one(&@expr e) -> pre_and_post {\n-        ret expr_pp(e);\n-    }\n-    \n-        log(\"find_pre_post_expr (num_locals =\" +\n-             uistr(num_local_vars) + \"):\");\n-        log_expr(*e);\n+    log(\"find_pre_post_expr (num_locals =\" +\n+        uistr(num_local_vars) + \"):\");\n+    log_expr(*e);\n     \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n             auto args = Vec.clone[@expr](operands);\n             Vec.push[@expr](args, operator);\n-            find_pre_post_exprs(fm, enclosing, args, a);\n+            find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n             auto args = Vec.clone[@expr](operands);\n             Vec.push[@expr](args, operator);\n-            find_pre_post_exprs(fm, enclosing, args, a);\n+            find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_vec(?args, _, ?a)) {\n-            find_pre_post_exprs(fm, enclosing, args, a);\n+            find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_tup(?elts, ?a)) {\n-            find_pre_post_exprs(fm, enclosing, elt_exprs(elts), a);\n-        }\n-        case (expr_path(?p, ?maybe_def, ?a)) {\n-            auto df;\n-            alt (maybe_def) {\n-                case (none[def])\n-                    { log(\"expr_path should have a def\"); fail; }\n-                case (some[def](?d)) { df = d; }\n-            }\n-\n+            find_pre_post_exprs(dm, fm, enclosing, elt_exprs(elts), a);\n+        }\n+        case (expr_path(?p, ?a)) {\n             auto res = empty_pre_post(num_local_vars);\n \n-            alt (df) {\n+            alt (dm.get(ast.ann_tag(a))) {\n                 case (def_local(?d_id)) {\n                     auto i = bit_num(d_id, enclosing);\n                     require_and_preserve(i, res);\n@@ -861,17 +851,17 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case(expr_log(_, ?arg, ?a)) {\n-            find_pre_post_expr(fm, enclosing, arg);\n+            find_pre_post_expr(dm, fm, enclosing, arg);\n             set_pre_and_post(a, expr_pp(arg));\n         }\n         case (expr_chan(?arg, ?a)) {\n-            find_pre_post_expr(fm, enclosing, arg);\n+            find_pre_post_expr(dm, fm, enclosing, arg);\n             set_pre_and_post(a, expr_pp(arg));\n         }\n         case(expr_put(?opt, ?a)) {\n             alt (opt) {\n                 case (some[@expr](?arg)) {\n-                    find_pre_post_expr(fm, enclosing, arg);\n+                    find_pre_post_expr(dm, fm, enclosing, arg);\n                     set_pre_and_post(a, expr_pp(arg));\n                 }\n                 case (none[@expr]) {\n@@ -880,50 +870,60 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             }\n         }\n         case (expr_block(?b, ?a)) {\n-            find_pre_post_block(fm, enclosing, b);\n+            find_pre_post_block(dm, fm, enclosing, b);\n             set_pre_and_post(a, block_pp(b));\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n             auto es = field_exprs(fields);\n             Vec.plus_option[@expr](es, maybe_base);\n-            find_pre_post_exprs(fm, enclosing, es, a);\n+            find_pre_post_exprs(dm, fm, enclosing, es, a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n-                case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, rhs);\n-                    set_pre_and_post(a, expr_pp(rhs));\n-                    log(\"gen:\");\n-                    log_expr(*e);\n-                    gen(enclosing, a, d_id);\n-                }\n-                case (_) {\n-                    // doesn't check that lhs is an lval, but\n-                    // that's probably ok\n-                    find_pre_post_exprs(fm, enclosing, vec(lhs, rhs), a);\n+                case (expr_path(?p, ?a_lhs)) {\n+                    alt (dm.get(ast.ann_tag(a_lhs))) {\n+                        case (def_local(?d_id)) {\n+                            find_pre_post_expr(dm, fm, enclosing, rhs);\n+                            set_pre_and_post(a, expr_pp(rhs));\n+                            log(\"gen:\");\n+                            log_expr(*e);\n+                            gen(enclosing, a, d_id);\n+                            ret;\n+                        }\n+                        case (_) {}\n+                    }\n                 }\n+                case (_) {}\n             }\n+            // doesn't check that lhs is an lval, but\n+            // that's probably ok\n+            find_pre_post_exprs(dm, fm, enclosing, vec(lhs, rhs), a);\n         }\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n-                case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, rhs);\n-                    set_pre_and_post(a, expr_pp(rhs));\n-                    log(\"gen:\");\n-                    log_expr(*e);\n-                    gen(enclosing, a, d_id);\n-                }\n-                case (_) {\n-                    // doesn't check that lhs is an lval, but\n-                    // that's probably ok\n-                    find_pre_post_exprs(fm, enclosing, vec(lhs, rhs), a);\n+                case (expr_path(?p, ?a_lhs)) {\n+                    alt (dm.get(ast.ann_tag(a_lhs))) {\n+                        case (def_local(?d_id)) {\n+                            find_pre_post_expr(dm, fm, enclosing, rhs);\n+                            set_pre_and_post(a, expr_pp(rhs));\n+                            log(\"gen:\");\n+                            log_expr(*e);\n+                            gen(enclosing, a, d_id);\n+                            ret;\n+                        }\n+                        case (_) {}\n+                    }\n                 }\n+                case (_) {}\n             }\n+            // doesn't check that lhs is an lval, but\n+            // that's probably ok\n+            find_pre_post_exprs(dm, fm, enclosing, vec(lhs, rhs), a);\n         }\n         case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n-            find_pre_post_exprs(fm, enclosing, vec(lhs, rhs), a);\n+            find_pre_post_exprs(dm, fm, enclosing, vec(lhs, rhs), a);\n         }\n         case (expr_lit(_,?a)) {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n@@ -936,7 +936,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                           postcondition=false_postcond(num_local_vars)));\n                 }\n                 case (some[@expr](?ret_val)) {\n-                    find_pre_post_expr(fm, enclosing, ret_val);\n+                    find_pre_post_expr(dm, fm, enclosing, ret_val);\n                     let pre_and_post pp =\n                         rec(precondition=expr_precond(ret_val),\n                             postcondition=false_postcond(num_local_vars));\n@@ -945,13 +945,13 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             }\n         }\n         case (expr_be(?e, ?a)) {\n-            find_pre_post_expr(fm, enclosing, e);\n+            find_pre_post_expr(dm, fm, enclosing, e);\n             set_pre_and_post(a, rec(precondition=expr_prestate(e),\n                           postcondition=false_postcond(num_local_vars)));\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            find_pre_post_expr(fm, enclosing, antec);\n-            find_pre_post_block(fm, enclosing, conseq);\n+            find_pre_post_expr(dm, fm, enclosing, antec);\n+            find_pre_post_block(dm, fm, enclosing, conseq);\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n                     auto precond_res = seq_preconds(enclosing,\n@@ -962,7 +962,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                                             expr_poststate(antec)));\n                 }\n                 case (some[@expr](?altern)) {\n-                    find_pre_post_expr(fm, enclosing, altern);\n+                    find_pre_post_expr(dm, fm, enclosing, altern);\n                     auto precond_true_case =\n                         seq_preconds(enclosing,\n                                      vec(expr_pp(antec), block_pp(conseq)));\n@@ -988,22 +988,22 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n         case (expr_binary(?bop,?l,?r,?a)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n              FIXME */\n-            find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n+            find_pre_post_exprs(dm, fm, enclosing, vec(l, r), a);\n         }\n         case (expr_send(?l, ?r, ?a)) {\n-            find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n+            find_pre_post_exprs(dm, fm, enclosing, vec(l, r), a);\n         }\n         case (expr_unary(_,?operand,?a)) {\n-            find_pre_post_expr(fm, enclosing, operand);\n+            find_pre_post_expr(dm, fm, enclosing, operand);\n             set_pre_and_post(a, expr_pp(operand));\n         }\n         case (expr_cast(?operand, _, ?a)) {\n-            find_pre_post_expr(fm, enclosing, operand);\n+            find_pre_post_expr(dm, fm, enclosing, operand);\n             set_pre_and_post(a, expr_pp(operand));\n         }\n         case (expr_while(?test, ?body, ?a)) {\n-            find_pre_post_expr(fm, enclosing, test);\n-            find_pre_post_block(fm, enclosing, body);\n+            find_pre_post_expr(dm, fm, enclosing, test);\n+            find_pre_post_block(dm, fm, enclosing, body);\n             set_pre_and_post(a,\n               rec(precondition=\n                   seq_preconds(enclosing,\n@@ -1014,8 +1014,8 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                                           block_postcond(body)))));\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n-            find_pre_post_block(fm, enclosing, body);\n-            find_pre_post_expr(fm, enclosing, test);\n+            find_pre_post_block(dm, fm, enclosing, body);\n+            find_pre_post_expr(dm, fm, enclosing, test);\n    \n             auto loop_postcond = union_postconds(num_local_vars,\n                             vec(block_postcond(body), expr_postcond(test)));\n@@ -1032,22 +1032,22 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                    postcondition=loop_postcond));\n         }\n         case (expr_for(?d, ?index, ?body, ?a)) {\n-            find_pre_post_loop(fm, enclosing, d, index, body, a);\n+            find_pre_post_loop(dm, fm, enclosing, d, index, body, a);\n         }\n         case (expr_for_each(?d, ?index, ?body, ?a)) {\n-            find_pre_post_loop(fm, enclosing, d, index, body, a);\n+            find_pre_post_loop(dm, fm, enclosing, d, index, body, a);\n         }\n         case (expr_index(?e, ?sub, ?a)) {\n-            find_pre_post_exprs(fm, enclosing, vec(e, sub), a);\n+            find_pre_post_exprs(dm, fm, enclosing, vec(e, sub), a);\n         }\n         case (expr_alt(?e, ?alts, ?a)) {\n-            find_pre_post_expr(fm, enclosing, e);\n-            fn do_an_alt(fn_info_map fm, fn_info enc, &arm an_alt)\n+            find_pre_post_expr(dm, fm, enclosing, e);\n+            fn do_an_alt(def_map dm, fn_info_map fm, fn_info enc, &arm an_alt)\n                 -> pre_and_post {\n-                find_pre_post_block(fm, enc, an_alt.block);\n+                find_pre_post_block(dm, fm, enc, an_alt.block);\n                 ret block_pp(an_alt.block);\n             }\n-            auto f = bind do_an_alt(fm, enclosing, _);\n+            auto f = bind do_an_alt(dm, fm, enclosing, _);\n             auto alt_pps = Vec.map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n                           fn_info enclosing, &pre_and_post pp,\n@@ -1068,7 +1068,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, alts_overall_pp);\n         }\n         case (expr_field(?operator, _, ?a)) {\n-            find_pre_post_expr(fm, enclosing, operator);\n+            find_pre_post_expr(dm, fm, enclosing, operator);\n             set_pre_and_post(a, expr_pp(operator));\n         }\n         case (expr_fail(?a)) {\n@@ -1079,18 +1079,18 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n                    postcondition=false_postcond(num_local_vars)));\n         }\n         case (expr_assert(?p, ?a)) {\n-            find_pre_post_expr(fm, enclosing, p);\n+            find_pre_post_expr(dm, fm, enclosing, p);\n             set_pre_and_post(a, expr_pp(p));\n         }\n         case (expr_check(?p, ?a)) {\n             /* will need to change when we support arbitrary predicates... */\n-            find_pre_post_expr(fm, enclosing, p);\n+            find_pre_post_expr(dm, fm, enclosing, p);\n             set_pre_and_post(a, expr_pp(p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = Vec.cat_options[@expr](maybe_args);\n             Vec.push[@expr](args, operator); /* ??? order of eval? */\n-            find_pre_post_exprs(fm, enclosing, args, a);\n+            find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_break(?a)) {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n@@ -1102,7 +1102,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case (expr_ext(_, _, _, ?expanded, ?a)) {\n-            find_pre_post_expr(fm, enclosing, expanded);\n+            find_pre_post_expr(dm, fm, enclosing, expanded);\n             set_pre_and_post(a, expr_pp(expanded));\n         }\n     }\n@@ -1130,8 +1130,8 @@ fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n   ret set_in_poststate(i, (ann_to_ts_ann_fail_more(a)).states);\n }\n \n-fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n-    -> () {\n+fn find_pre_post_stmt(&def_map dm, fn_info_map fm, &fn_info enclosing,\n+                      &ast.stmt s) -> () {\n     log(\"stmt =\");\n     log_stmt(s);\n \n@@ -1142,7 +1142,7 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n             case(ast.decl_local(?alocal)) {\n                 alt(alocal.init) {\n                     case(some[ast.initializer](?an_init)) {\n-                        find_pre_post_expr(fm, enclosing, an_init.expr);\n+                        find_pre_post_expr(dm, fm, enclosing, an_init.expr);\n                         auto rhs_pp = expr_pp(an_init.expr);\n                         set_pre_and_post(alocal.ann, rhs_pp);\n \n@@ -1167,19 +1167,19 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n             case(decl_item(?anitem)) {\n                 auto pp = empty_pre_post(num_local_vars);\n                 set_pre_and_post(a, pp);\n-                find_pre_post_item(fm, enclosing, *anitem);\n+                find_pre_post_item(dm, fm, enclosing, *anitem);\n             }\n         }\n     }\n     case(stmt_expr(?e,?a)) {\n-        find_pre_post_expr(fm, enclosing, e);\n+        find_pre_post_expr(dm, fm, enclosing, e);\n         set_pre_and_post(a, expr_pp(e));\n     }    \n   }\n }\n \n-fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n-    -> () {\n+fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n+                       block b) -> () {\n     /* Want to say that if there is a break or cont in this\n      block, then that invalidates the poststate upheld by\n     any of the stmts after it. \n@@ -1198,20 +1198,20 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n      */\n     auto nv = num_locals(enclosing);\n \n-    fn do_one_(fn_info_map fm, fn_info i, &@stmt s) -> () {\n-        find_pre_post_stmt(fm, i, *s);\n+    fn do_one_(def_map dm, fn_info_map fm, fn_info i, &@stmt s) -> () {\n+        find_pre_post_stmt(dm, fm, i, *s);\n         log(\"pre_post for stmt:\");\n         log_stmt(*s);\n         log(\"is:\");\n         log_pp(stmt_pp(*s));\n     }\n-    auto do_one = bind do_one_(fm, enclosing, _);\n+    auto do_one = bind do_one_(dm, fm, enclosing, _);\n     \n     Vec.map[@stmt, ()](do_one, b.node.stmts);\n-    fn do_inner_(fn_info_map fm, fn_info i, &@expr e) -> () {\n-        find_pre_post_expr(fm, i, e);\n+    fn do_inner_(def_map dm, fn_info_map fm, fn_info i, &@expr e) -> () {\n+        find_pre_post_expr(dm, fm, i, e);\n     }\n-    auto do_inner = bind do_inner_(fm, enclosing, _);\n+    auto do_inner = bind do_inner_(dm, fm, enclosing, _);\n     Option.map[@expr, ()](do_inner, b.node.expr);\n \n     let vec[pre_and_post] pps = vec();\n@@ -1244,33 +1244,33 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n                                    postcondition=block_postcond));\n }\n \n-fn find_pre_post_fn(&fn_info_map fm, &fn_info fi, &_fn f) -> () {\n-    find_pre_post_block(fm, fi, f.body);\n+fn find_pre_post_fn(&def_map dm, &fn_info_map fm, &fn_info fi, &_fn f) -> () {\n+    find_pre_post_block(dm, fm, fi, f.body);\n }\n \n-fn check_item_fn(&fn_info_map fm, &span sp, &ident i, &ast._fn f,\n+fn check_item_fn(&def_map dm, &fn_info_map fm, &span sp, &ident i, &ast._fn f,\n                  &vec[ast.ty_param] ty_params,\n                  &def_id id, &ann a) -> @item {\n \n     log(\"check_item_fn:\");\n     log_fn(f, i, ty_params);\n \n   assert (fm.contains_key(id));\n-  find_pre_post_fn(fm, fm.get(id), f);\n+  find_pre_post_fn(dm, fm, fm.get(id), f);\n \n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n-fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n-   -> bool {\n+fn find_pre_post_state_item(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n+                            @item i) -> bool {\n  alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n-        ret find_pre_post_state_expr(fm, enclosing,\n+        ret find_pre_post_state_expr(dm, fm, enclosing,\n               empty_prestate(num_locals(enclosing)), e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n       assert (fm.contains_key(di));\n-      ret find_pre_post_state_fn(fm, fm.get(di), f);\n+      ret find_pre_post_state_fn(dm, fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n       ret find_pre_post_state_mod(m);\n@@ -1285,7 +1285,7 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n       ret false;\n     }\n     case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n-        ret find_pre_post_state_obj(fm, o);\n+        ret find_pre_post_state_obj(dm, fm, o);\n     }\n   }\n }\n@@ -1363,24 +1363,26 @@ fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n     }\n }\n \n-fn seq_states(&fn_info_map fm, &fn_info enclosing,\n+fn seq_states(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     prestate pres, vec[@expr] exprs) -> tup(bool, poststate) {\n   auto changed = false;\n   auto post = pres;\n \n   for (@expr e in exprs) {\n-    changed = find_pre_post_state_expr(fm, enclosing, post, e) || changed;\n+      changed = find_pre_post_state_expr(dm, fm, enclosing, post, e)\n+                || changed;\n     post = expr_poststate(e);\n   }\n \n   ret tup(changed, post);\n }\n \n-fn find_pre_post_state_exprs(&fn_info_map fm,\n+fn find_pre_post_state_exprs(&def_map dm,\n+                             &fn_info_map fm,\n                              &fn_info enclosing,\n                              &prestate pres,\n                              &ann a, &vec[@expr] es) -> bool {\n-  auto res = seq_states(fm, enclosing, pres, es);\n+  auto res = seq_states(dm, fm, enclosing, pres, es);\n   auto changed = res._0;\n   changed = extend_prestate_ann(a, pres) || changed;\n   changed = extend_poststate_ann(a, res._1) || changed;\n@@ -1394,17 +1396,17 @@ fn pure_exp(&ann a, &prestate p) -> bool {\n   ret changed;\n }\n \n-fn find_pre_post_state_loop(fn_info_map fm, fn_info enclosing,\n-   prestate pres, &@decl d, &@expr index, &block body, &ann a) -> bool {\n+fn find_pre_post_state_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n+   &prestate pres, &@decl d, &@expr index, &block body, &ann a) -> bool {\n     auto changed = false;\n \n     /* same issues as while */\n     changed = extend_prestate_ann(a, pres) || changed;\n-    changed = find_pre_post_state_expr(fm, enclosing, pres, index)\n+    changed = find_pre_post_state_expr(dm, fm, enclosing, pres, index)\n         || changed;\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n-    changed = find_pre_post_state_block(fm, enclosing,\n+    changed = find_pre_post_state_block(dm, fm, enclosing,\n                 expr_poststate(index), body) || changed;\n     auto res_p = intersect_postconds(vec(expr_poststate(index),\n                                          block_poststate(body)));\n@@ -1413,59 +1415,60 @@ fn find_pre_post_state_loop(fn_info_map fm, fn_info enclosing,\n     ret changed;\n }\n \n-fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @expr e) -> bool {\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n   /* FIXME could get rid of some of the copy/paste */\n   alt (e.node) {\n     case (expr_vec(?elts, _, ?a)) {\n-      ret find_pre_post_state_exprs(fm, enclosing, pres, a, elts); \n+      ret find_pre_post_state_exprs(dm, fm, enclosing, pres, a, elts); \n     }\n     case (expr_tup(?elts, ?a)) {\n-      ret find_pre_post_state_exprs(fm, enclosing, pres, a, elt_exprs(elts));\n+      ret find_pre_post_state_exprs(dm, fm, enclosing, pres, a,\n+                                    elt_exprs(elts));\n     }\n     case (expr_call(?operator, ?operands, ?a)) {\n       /* do the prestate for the rator */\n-      changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n+      changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operator)\n         || changed;\n       /* rands go left-to-right */\n-      ret(find_pre_post_state_exprs(fm, enclosing,\n+      ret(find_pre_post_state_exprs(dm, fm, enclosing,\n                                     expr_poststate(operator), a, operands)\n           || changed);\n     }\n     case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, operator);\n-        ret(find_pre_post_state_exprs(fm, enclosing,\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operator);\n+        ret(find_pre_post_state_exprs(dm, fm, enclosing,\n                  expr_poststate(operator), a, operands)\n           || changed);\n     }\n     case (expr_bind(?operator, ?maybe_args, ?a)) {\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operator)\n             || changed;\n-        ret (find_pre_post_state_exprs(fm, enclosing,\n+        ret (find_pre_post_state_exprs(dm, fm, enclosing,\n           expr_poststate(operator), a, cat_options[@expr](maybe_args))\n             || changed);\n     }\n-    case (expr_path(_,_,?a)) {\n+    case (expr_path(_,?a)) {\n       ret pure_exp(a, pres);\n     }\n     case (expr_log(_,?e,?a)) {\n         /* factor out the \"one exp\" pattern */\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n         ret changed;\n     }\n     case (expr_chan(?e, ?a)) {\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n         ret changed;\n     }\n     case (expr_ext(_, _, _, ?expanded, ?a)) {\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, expanded);\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, expanded);\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(expanded))\n            || changed;\n@@ -1474,7 +1477,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     case (expr_put(?maybe_e, ?a)) {\n         alt (maybe_e) {\n             case (some[@expr](?arg)) {\n-                changed = find_pre_post_state_expr(fm, enclosing, pres, arg);\n+                changed = find_pre_post_state_expr(dm, fm, enclosing,\n+                                                   pres, arg);\n                 changed = extend_prestate_ann(a, pres) || changed;\n                 changed = extend_poststate_ann(a, expr_poststate(arg))\n                     || changed;\n@@ -1489,20 +1493,20 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         ret pure_exp(a, pres);\n     }\n     case (expr_block(?b,?a)) {\n-        changed = find_pre_post_state_block(fm, enclosing, pres, b)\n+        changed = find_pre_post_state_block(dm, fm, enclosing, pres, b)\n            || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, block_poststate(b)) || changed;\n         ret changed;\n     }\n     case (expr_rec(?fields,?maybe_base,?a)) {\n-        changed = find_pre_post_state_exprs(fm, enclosing, pres, a,\n+        changed = find_pre_post_state_exprs(dm, fm, enclosing, pres, a,\n                                             field_exprs(fields)) || changed;\n         alt (maybe_base) {\n             case (none[@expr]) { /* do nothing */ }\n             case (some[@expr](?base)) {\n-                changed = find_pre_post_state_expr(fm, enclosing, pres, base)\n-                    || changed;\n+                changed = find_pre_post_state_expr\n+                    (dm, fm, enclosing, pres, base) || changed;\n                 changed = extend_poststate_ann(a, expr_poststate(base))\n                     || changed;\n             }\n@@ -1513,51 +1517,56 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         extend_prestate_ann(a, pres);\n \n         alt (lhs.node) {\n-            case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                // assignment to local var\n-                changed = pure_exp(a_lhs, pres) || changed;\n-                changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n-                    || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n-                changed = gen_poststate(enclosing, a, d_id) || changed;\n-            }\n-            case (_) {\n-                // assignment to something that must already have been init'd\n-                changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n-                    || changed;\n-                changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n+            case (expr_path(_, ?a_lhs)) {\n+                alt (dm.get(ast.ann_tag(a_lhs))) {\n+                    case (def_local(?d_id)) {\n+                        // assignment to local var\n+                        changed = pure_exp(a_lhs, pres) || changed;\n+                        changed = find_pre_post_state_expr\n+                            (dm, fm, enclosing, pres, rhs) || changed;\n+                        changed = extend_poststate_ann\n+                            (a, expr_poststate(rhs)) || changed;\n+                        ret gen_poststate(enclosing, a, d_id)\n+                            || changed;\n+                    }\n+                    case (_) {}\n+                }\n             }\n+            case (_) {}\n         }\n-        ret changed;\n+        // assignment to something that must already have been init'd\n+        changed = find_pre_post_state_expr\n+            (dm, fm, enclosing, pres, lhs) || changed;\n+        changed = find_pre_post_state_expr\n+            (dm, fm, enclosing, expr_poststate(lhs), rhs) || changed;\n+        ret extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n     }\n     case (expr_recv(?lhs, ?rhs, ?a)) {\n         extend_prestate_ann(a, pres);\n \n         alt (lhs.node) {\n-            case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                // receive to local var\n-                changed = pure_exp(a_lhs, pres) || changed;\n-                changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n-                    || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n-                changed = gen_poststate(enclosing, a, d_id) || changed;\n-            }\n-            case (_) {\n-                // receive to something that must already have been init'd\n-                changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n-                    || changed;\n-                changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(rhs))\n-                    || changed;\n+            case (expr_path(?p, ?a_lhs)) {\n+                alt (dm.get(ast.ann_tag(a_lhs))) {\n+                    case (def_local(?d_id)) {\n+                        // receive to local var\n+                        changed = pure_exp(a_lhs, pres) || changed;\n+                        changed = find_pre_post_state_expr\n+                            (dm, fm, enclosing, pres, rhs) || changed;\n+                        changed = extend_poststate_ann(a, expr_poststate(rhs))\n+                            || changed;\n+                        ret gen_poststate(enclosing, a, d_id) || changed;\n+                    }\n+                    case (_) {}\n+                }\n             }\n+            case (_) {}\n         }\n-        ret changed;\n+        // receive to something that must already have been init'd\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, lhs)\n+            || changed;\n+        changed = find_pre_post_state_expr\n+            (dm, fm, enclosing, expr_poststate(lhs), rhs) || changed;\n+        ret extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n     }\n \n     case (expr_ret(?maybe_ret_val, ?a)) {\n@@ -1566,7 +1575,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         alt(maybe_ret_val) {\n             case (none[@expr]) { /* do nothing */ }\n             case (some[@expr](?ret_val)) {\n-                changed = find_pre_post_state_expr(fm, enclosing,\n+                changed = find_pre_post_state_expr(dm, fm, enclosing,\n                              pres, ret_val) || changed;\n             }\n         }\n@@ -1575,22 +1584,23 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     case (expr_be(?e, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         set_poststate_ann(a, false_postcond(num_local_vars));\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+        changed = find_pre_post_state_expr\n+            (dm, fm, enclosing, pres, e) || changed;\n         ret changed;\n     }\n     case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, antec)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, antec)\n             || changed;\n-        changed = find_pre_post_state_block(fm, enclosing,\n+        changed = find_pre_post_state_block(dm, fm, enclosing,\n           expr_poststate(antec), conseq) || changed;\n         alt (maybe_alt) {\n             case (none[@expr]) {\n                 changed = extend_poststate_ann(a, expr_poststate(antec))\n                     || changed;\n             }\n             case (some[@expr](?altern)) {\n-                changed = find_pre_post_state_expr(fm, enclosing,\n+                changed = find_pre_post_state_expr(dm, fm, enclosing,\n                    expr_poststate(antec), altern) || changed;\n                 auto poststate_res = intersect_postconds\n                     (vec(block_poststate(conseq), expr_poststate(altern)));\n@@ -1609,28 +1619,28 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     case (expr_binary(?bop, ?l, ?r, ?a)) {\n         /* FIXME: what if bop is lazy? */\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, l)\n                     || changed;\n-        changed = find_pre_post_state_expr(fm,\n+        changed = find_pre_post_state_expr(dm, fm,\n                     enclosing, expr_poststate(l), r) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n         ret changed;\n     }\n     case (expr_send(?l, ?r, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, l)\n                     || changed;\n-        changed = find_pre_post_state_expr(fm,\n+        changed = find_pre_post_state_expr(dm, fm,\n                     enclosing, expr_poststate(l), r) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n         ret changed;\n     }\n     case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n         /* quite similar to binary -- should abstract this */\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, lhs)\n                     || changed;\n-        changed = find_pre_post_state_expr(fm,\n+        changed = find_pre_post_state_expr(dm, fm,\n                     enclosing, expr_poststate(lhs), rhs) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n         ret changed;\n@@ -1645,9 +1655,9 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n            FIXME\n            maybe need a \"don't know\" state in addition to 0 or 1?\n         */\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, test)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, test)\n             || changed;\n-        changed = find_pre_post_state_block(fm, \n+        changed = find_pre_post_state_block(dm, fm, \n                    enclosing, expr_poststate(test), body) || changed; \n         changed = extend_poststate_ann(a,\n                     intersect_postconds(vec(expr_poststate(test),\n@@ -1656,9 +1666,9 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     }\n     case (expr_do_while(?body, ?test, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_block(fm, enclosing, pres, body)\n+        changed = find_pre_post_state_block(dm, fm, enclosing, pres, body)\n             || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing,\n+        changed = find_pre_post_state_expr(dm, fm, enclosing,\n                      block_poststate(body), test) || changed;\n \n         /* conservative approximination: if the body of the loop\n@@ -1676,28 +1686,32 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         ret changed;\n     }\n     case (expr_for(?d, ?index, ?body, ?a)) {\n-        ret find_pre_post_state_loop(fm, enclosing, pres, d, index, body, a);\n+        ret find_pre_post_state_loop(dm, fm, enclosing, pres, d, index,\n+                                     body, a);\n     }\n     case (expr_for_each(?d, ?index, ?body, ?a)) {\n-        ret find_pre_post_state_loop(fm, enclosing, pres, d, index, body, a);\n+        ret find_pre_post_state_loop(dm, fm, enclosing, pres, d, index,\n+                                     body, a);\n     }\n     case (expr_index(?e, ?sub, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed; \n-        changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing,\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e)\n+                  || changed;\n+        changed = find_pre_post_state_expr(dm, fm, enclosing,\n                      expr_poststate(e), sub) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(sub));\n         ret changed;\n     }\n     case (expr_alt(?e, ?alts, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed; \n-        changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e)\n+                  || changed;\n         auto e_post = expr_poststate(e);\n         auto a_post;\n         if (Vec.len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n             for (arm an_alt in alts) {\n-                changed = find_pre_post_state_block(fm, enclosing, e_post,\n+                changed = find_pre_post_state_block(dm, fm, enclosing, e_post,\n                                                     an_alt.block) || changed;\n                 changed = intersect(a_post, block_poststate(an_alt.block))\n                     || changed; \n@@ -1711,21 +1725,21 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         ret changed;\n     }\n     case (expr_field(?e,_,?a)) {\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n         ret changed;\n     }\n     case (expr_unary(_,?operand,?a)) {\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operand)\n           || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(operand))\n           || changed;\n         ret changed;\n     }\n     case (expr_cast(?operand, _, ?a)) {\n-           changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n+          changed = find_pre_post_state_expr(dm, fm, enclosing, pres, operand)\n           || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(operand))\n@@ -1744,7 +1758,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     }\n     case (expr_check(?p, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = find_pre_post_state_expr(fm, enclosing, pres, p) || changed;\n+        changed = find_pre_post_state_expr(dm, fm, enclosing, pres, p)\n+                  || changed;\n         /* FIXME: update the postcondition to reflect that p holds */\n         changed = extend_poststate_ann(a, pres) || changed;\n         ret changed;\n@@ -1764,7 +1779,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n   }\n }\n \n-fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_state_stmt(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @stmt s) -> bool {\n   auto changed = false;\n   auto stmt_ann_ = stmt_to_ann(*s);\n@@ -1788,7 +1803,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                 changed = extend_prestate(stmt_ann.states.prestate, pres)\n                     || changed;\n                 changed = find_pre_post_state_expr\n-                    (fm, enclosing, pres, an_init.expr) || changed;\n+                    (dm, fm, enclosing, pres, an_init.expr) || changed;\n                 changed = extend_poststate(stmt_ann.states.poststate,\n                                            expr_poststate(an_init.expr))\n                     || changed;\n@@ -1819,12 +1834,14 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                || changed;\n             changed = extend_poststate(stmt_ann.states.poststate, pres)\n                || changed;\n-            ret (find_pre_post_state_item(fm, enclosing, an_item) || changed);\n+            ret find_pre_post_state_item(dm, fm, enclosing, an_item)\n+                || changed;\n         }\n       }\n     }\n     case (stmt_expr(?e, _)) {\n-      changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+      changed = find_pre_post_state_expr(dm, fm, enclosing, pres, e)\n+                || changed;\n       changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(e))\n           || changed;\n       changed = extend_poststate(stmt_ann.states.poststate,\n@@ -1849,7 +1866,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n \n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n+fn find_pre_post_state_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                              &prestate pres0, &block b)\n   -> bool {\n     \n@@ -1863,7 +1880,7 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n    consist of improving <pres> with whatever variables this stmt initializes.\n   Then <pres> becomes the new poststate. */ \n   for (@stmt s in b.node.stmts) {\n-    changed = find_pre_post_state_stmt(fm, enclosing, pres, s) || changed;\n+    changed = find_pre_post_state_stmt(dm, fm, enclosing, pres, s) || changed;\n     pres = stmt_poststate(*s, num_local_vars);\n   }\n \n@@ -1872,7 +1889,8 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n   alt (b.node.expr) {\n     case (none[@expr]) {}\n     case (some[@expr](?e)) {\n-      changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+      changed = find_pre_post_state_expr(dm,fm, enclosing, pres, e)\n+                || changed;\n       post = expr_poststate(e);\n     }\n   }\n@@ -1907,30 +1925,15 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n   ret changed;\n }\n \n-fn find_pre_post_state_fn(&fn_info_map f_info, &fn_info fi, &ast._fn f)\n-  -> bool {\n+fn find_pre_post_state_fn(&def_map dm, &fn_info_map f_info, &fn_info fi,\n+                          &ast._fn f) -> bool {\n     /* FIXME: where do we set args as being initialized?\n        What about for methods? */\n     auto num_local_vars = num_locals(fi);\n-    ret find_pre_post_state_block(f_info, fi,\n+    ret find_pre_post_state_block(dm, f_info, fi,\n                                   empty_prestate(num_local_vars), f.body);\n }\n \n-fn fixed_point_states(fn_info_map fm, fn_info f_info,\n-                      fn (&fn_info_map, &fn_info, &ast._fn) -> bool f,\n-                      &ast._fn start) -> () {\n-\n-  auto changed = f(fm, f_info, start);\n-\n-  if (changed) {\n-    ret fixed_point_states(fm, f_info, f, start);\n-  }\n-  else {\n-    // we're done!\n-    ret;\n-  }\n-}\n-\n fn check_states_expr(fn_info enclosing, @expr e) -> () {\n   let precond prec    = expr_precond(e);\n   let prestate pres   = expr_prestate(e);\n@@ -1993,44 +1996,44 @@ fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n   \n }\n \n-fn check_fn_states(&fn_info_map f_info_map, &fn_info f_info, &ast._fn f)\n-    -> () {\n-  /* Compute the pre- and post-states for this function */\n-    auto g = find_pre_post_state_fn;\n-    fixed_point_states(f_info_map, f_info, g, f);\n+fn check_fn_states(&def_map dm, &fn_info_map f_info_map, &fn_info f_info,\n+                   &ast._fn f) -> () {\n+    /* Compute the pre- and post-states for this function */\n+    // (Fixpoint iteration)\n+    while (find_pre_post_state_fn(dm, f_info_map, f_info, f)) {}\n     \n   /* Now compare each expr's pre-state to its precondition\n      and post-state to its postcondition */\n     check_states_against_conditions(f_info, f);\n }\n \n-fn check_item_fn_state(&fn_info_map f_info_map, &span sp, &ident i,\n-                       &ast._fn f, &vec[ast.ty_param] ty_params,\n+fn check_item_fn_state(def_map dm, &fn_info_map f_info_map, &span sp,\n+                       &ident i, &ast._fn f, &vec[ast.ty_param] ty_params,\n                        &def_id id, &ann a) -> @item {\n \n   /* Look up the var-to-bit-num map for this function */\n   assert (f_info_map.contains_key(id));\n   auto f_info = f_info_map.get(id);\n \n-  check_fn_states(f_info_map, f_info, f);\n+  check_fn_states(dm, f_info_map, f_info, f);\n \n   /* Rebuild the same function */\n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n-fn check_method_states(&fn_info_map f_info_map, @method m) -> () {\n+fn check_method_states(&def_map dm, &fn_info_map f_info_map, @method m) {\n     assert (f_info_map.contains_key(m.node.id));\n     auto f_info = f_info_map.get(m.node.id);\n-    check_fn_states(f_info_map, f_info, m.node.meth);\n+    check_fn_states(dm, f_info_map, f_info, m.node.meth);\n }\n \n-fn check_obj_state(&fn_info_map f_info_map, &vec[obj_field] fields,\n-                   &vec[@method] methods,\n+fn check_obj_state(def_map dm, &fn_info_map f_info_map,\n+                   &vec[obj_field] fields, &vec[@method] methods,\n                    &Option.t[@method] dtor) -> ast._obj {\n-    fn one(fn_info_map fm, &@method m) -> () {\n-        ret check_method_states(fm, m);\n+    fn one(def_map dm, fn_info_map fm, &@method m) -> () {\n+        ret check_method_states(dm, fm, m);\n     }\n-    auto f = bind one(f_info_map,_);\n+    auto f = bind one(dm, f_info_map,_);\n     Vec.map[@method, ()](f, methods);\n     Option.map[@method, ()](f, dtor);\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n@@ -2283,7 +2286,7 @@ fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n             e1 = expr_index(annotate_expr(fm, e),\n                             annotate_expr(fm, sub), a);\n         }\n-        case (expr_path(_,_,_)) {\n+        case (expr_path(_,_)) {\n             /* no change */\n         }\n         case (expr_ext(?p, ?es, ?s_opt, ?e, ?a)) {\n@@ -2482,7 +2485,7 @@ fn annotate_crate(&fn_info_map fm, &@ast.crate crate) -> @ast.crate {\n                    with crate.node));\n }\n \n-fn check_crate(@ast.crate crate) -> @ast.crate {\n+fn check_crate(@ast.crate crate, def_map dm) -> @ast.crate {\n   /* Build the global map from function id to var-to-bit-num-map */\n   auto fm = mk_f_to_fn_info(crate);\n \n@@ -2491,14 +2494,14 @@ fn check_crate(@ast.crate crate) -> @ast.crate {\n \n   /* Compute the pre and postcondition for every subexpression */\n   auto fld = fold.new_identity_fold[fn_info_map]();\n-  fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n+  fld = @rec(fold_item_fn = bind check_item_fn(dm,_,_,_,_,_,_,_) with *fld);\n   auto with_pre_postconditions = fold.fold_crate[fn_info_map]\n     (fm, fld, with_anns);\n \n   auto fld1 = fold.new_identity_fold[fn_info_map]();\n \n-  fld1 = @rec(fold_item_fn = bind check_item_fn_state(_,_,_,_,_,_,_),\n-              fold_obj     = bind check_obj_state(_,_,_,_)\n+  fld1 = @rec(fold_item_fn = bind check_item_fn_state(dm,_,_,_,_,_,_,_),\n+              fold_obj     = bind check_obj_state(dm,_,_,_,_)\n               with *fld1);\n \n   ret fold.fold_crate[fn_info_map](fm, fld1,"}, {"sha": "e684924adc77d3f72c92efce36831f0c1af97a0b", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -372,7 +372,7 @@ fn walk_expr(&ast_visitor v, @ast.expr e) {\n             walk_expr(v, a);\n             walk_expr(v, b);\n         }\n-        case (ast.expr_path(_, _, _)) { }\n+        case (ast.expr_path(_, _)) { }\n         case (ast.expr_ext(_, ?args, ?body, ?expansion, _)) {\n             // Only walk expansion, not args/body.\n             walk_expr(v, expansion);"}, {"sha": "d380f0b7eeafb437d39bd6b6a88cd084c1dd7f12", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=358a1aeec99ba6bf3c3f6bc5886e4dddf647a75a", "patch": "@@ -613,7 +613,7 @@ fn print_expr(ps s, &@ast.expr expr) {\n             print_expr(s, index);\n             pclose(s);\n         }\n-        case (ast.expr_path(?path,_,_)) {\n+        case (ast.expr_path(?path,_)) {\n             print_path(s, path);\n         }\n         case (ast.expr_fail(_)) {\n@@ -768,7 +768,7 @@ fn print_pat(ps s, &@ast.pat pat) {\n         case (ast.pat_wild(_)) {wrd(s.s, \"_\");}\n         case (ast.pat_bind(?id,_,_)) {wrd(s.s, \"?\" + id);}\n         case (ast.pat_lit(?lit,_)) {print_literal(s, lit);}\n-        case (ast.pat_tag(?path,?args,_,_)) {\n+        case (ast.pat_tag(?path,?args,_)) {\n             print_path(s, path);\n             if (Vec.len[@ast.pat](args) > 0u) {\n                 popen_h(s);"}]}