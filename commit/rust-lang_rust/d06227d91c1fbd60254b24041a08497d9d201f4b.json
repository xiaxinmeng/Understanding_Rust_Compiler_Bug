{"sha": "d06227d91c1fbd60254b24041a08497d9d201f4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNjIyN2Q5MWMxZmJkNjAyNTRiMjQwNDFhMDg0OTdkOWQyMDFmNGI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-11T00:18:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-11T00:18:13Z"}, "message": "Merge pull request #52 from oli-obk/vtable\n\nVtable", "tree": {"sha": "7c23f9d31a5fd547f505634e5fefc5e82e689395", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c23f9d31a5fd547f505634e5fefc5e82e689395"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d06227d91c1fbd60254b24041a08497d9d201f4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d06227d91c1fbd60254b24041a08497d9d201f4b", "html_url": "https://github.com/rust-lang/rust/commit/d06227d91c1fbd60254b24041a08497d9d201f4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d06227d91c1fbd60254b24041a08497d9d201f4b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "248bfdea8628ee8606d78759397323e139710e42", "url": "https://api.github.com/repos/rust-lang/rust/commits/248bfdea8628ee8606d78759397323e139710e42", "html_url": "https://github.com/rust-lang/rust/commit/248bfdea8628ee8606d78759397323e139710e42"}, {"sha": "3562118948c8414ff50ca717086edc04729749ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/3562118948c8414ff50ca717086edc04729749ab", "html_url": "https://github.com/rust-lang/rust/commit/3562118948c8414ff50ca717086edc04729749ab"}], "stats": {"total": 409, "additions": 362, "deletions": 47}, "files": [{"sha": "7129fa0dfcd82140fc8eccf95df5404febda0f79", "filename": "src/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=d06227d91c1fbd60254b24041a08497d9d201f4b", "patch": "@@ -40,6 +40,8 @@ pub enum EvalError<'tcx> {\n         required: usize,\n         has: usize,\n     },\n+    CalledClosureAsFunction,\n+    VtableForArgumentlessMethod,\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -88,6 +90,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"reached the configured maximum number of stack frames\",\n             EvalError::AlignmentCheckFailed{..} =>\n                 \"tried to execute a misaligned read or write\",\n+            EvalError::CalledClosureAsFunction =>\n+                \"tried to call a closure through a function pointer\",\n+            EvalError::VtableForArgumentlessMethod =>\n+                \"tried to call a vtable function without arguments\",\n         }\n     }\n "}, {"sha": "370b1efc4991470a1143fda9fa809511488194c1", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=d06227d91c1fbd60254b24041a08497d9d201f4b", "patch": "@@ -23,6 +23,7 @@ use std::collections::HashMap;\n mod step;\n mod terminator;\n mod cast;\n+mod vtable;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -108,7 +109,7 @@ struct Lvalue {\n enum LvalueExtra {\n     None,\n     Length(u64),\n-    // TODO(solson): Vtable(memory::AllocId),\n+    Vtable(Pointer),\n     DowncastVariant(usize),\n }\n \n@@ -569,6 +570,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     LvalueExtra::Length(len) => {\n                         self.memory.write_usize(extra, len)?;\n                     }\n+                    LvalueExtra::Vtable(ptr) => {\n+                        self.memory.write_ptr(extra, ptr)?;\n+                    },\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 }\n@@ -587,6 +591,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n+                        let dest_ty = self.monomorphize(dest_ty, self.substs());\n+                        assert!(self.type_is_fat_ptr(dest_ty));\n                         let (ptr, extra) = self.get_fat_ptr(dest);\n                         self.move_(src, ptr, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n@@ -596,8 +602,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                                 self.memory.write_usize(extra, length as u64)?;\n                             }\n-\n-                            _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n+                            (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n+                                // For now, upcasts are limited to changes in marker\n+                                // traits, and hence never actually require an actual\n+                                // change to the vtable.\n+                                let (_, src_extra) = self.get_fat_ptr(src);\n+                                let src_extra = self.memory.read_ptr(src_extra)?;\n+                                self.memory.write_ptr(extra, src_extra)?;\n+                            },\n+                            (_, &ty::TyTrait(ref data)) => {\n+                                let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n+                                let trait_ref = self.tcx.erase_regions(&trait_ref);\n+                                let vtable = self.get_vtable(trait_ref)?;\n+                                self.memory.write_ptr(extra, vtable)?;\n+                            },\n+\n+                            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n                         }\n                     }\n \n@@ -638,8 +658,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TyFnPtr(unsafe_fn_ty) => {\n                             let src = self.eval_operand(operand)?;\n                             let ptr = self.memory.read_ptr(src)?;\n-                            let fn_def = self.memory.get_fn(ptr.alloc_id)?;\n-                            let fn_ptr = self.memory.create_fn_ptr(fn_def.def_id, fn_def.substs, unsafe_fn_ty);\n+                            let (def_id, substs, _) = self.memory.get_fn(ptr.alloc_id)?;\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, unsafe_fn_ty);\n                             self.memory.write_ptr(dest, fn_ptr)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n@@ -827,15 +847,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Deref => {\n                         let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n-                        self.memory.dump(base.ptr.alloc_id);\n                         let ptr = self.memory.read_ptr(base.ptr)?;\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n                                 let (_, extra) = self.get_fat_ptr(base.ptr);\n                                 let len = self.memory.read_usize(extra)?;\n                                 LvalueExtra::Length(len)\n                             }\n-                            ty::TyTrait(_) => unimplemented!(),\n+                            ty::TyTrait(_) => {\n+                                let (_, extra) = self.get_fat_ptr(base.ptr);\n+                                let vtable = self.memory.read_ptr(extra)?;\n+                                LvalueExtra::Vtable(vtable)\n+                            },\n                             _ => LvalueExtra::None,\n                         };\n                         return Ok(Lvalue { ptr: ptr, extra: extra });"}, {"sha": "89a0f820ed6e8444ccc4c8a36b371153a5cffc62", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=d06227d91c1fbd60254b24041a08497d9d201f4b", "patch": "@@ -12,7 +12,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n \n use super::{EvalContext, IntegerExt};\n use error::{EvalError, EvalResult};\n-use memory::{Pointer, FunctionDefinition};\n+use memory::Pointer;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n@@ -90,7 +90,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyFnPtr(bare_fn_ty) => {\n                         let ptr = self.eval_operand(func)?;\n                         let fn_ptr = self.memory.read_ptr(ptr)?;\n-                        let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        let (def_id, substs, fn_ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         if fn_ty != bare_fn_ty {\n                             return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n                         }\n@@ -172,21 +172,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // TODO(solson): Adjust the first argument when calling a Fn or\n                 // FnMut closure via FnOnce::call_once.\n \n-                // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs) =\n-                    if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n-                        self.trait_method(trait_id, def_id, substs)\n-                    } else {\n-                        (def_id, substs)\n-                    };\n-\n                 let mut arg_srcs = Vec::new();\n                 for arg in args {\n                     let src = self.eval_operand(arg)?;\n                     let src_ty = self.operand_ty(arg);\n                     arg_srcs.push((src, src_ty));\n                 }\n \n+                // Only trait methods can have a Self parameter.\n+                let (resolved_def_id, resolved_substs) =\n+                    if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n+                        self.trait_method(trait_id, def_id, substs, arg_srcs.get_mut(0))?\n+                    } else {\n+                        (def_id, substs)\n+                    };\n+\n                 if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n                     arg_srcs.pop();\n                     let last_arg = args.last().unwrap();\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+    pub(super) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl.\n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n@@ -491,8 +491,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self,\n         trait_id: DefId,\n         def_id: DefId,\n-        substs: &'tcx Substs<'tcx>\n-    ) -> (DefId, &'tcx Substs<'tcx>) {\n+        substs: &'tcx Substs<'tcx>,\n+        first_arg: Option<&mut (Pointer, Ty<'tcx>)>,\n+    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n \n@@ -504,11 +505,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // and those from the method:\n                 let mth = get_impl_method(self.tcx, substs, impl_did, vtable_impl.substs, mname);\n \n-                (mth.method.def_id, mth.substs)\n+                Ok((mth.method.def_id, mth.substs))\n             }\n \n             traits::VtableClosure(vtable_closure) =>\n-                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n+                Ok((vtable_closure.closure_def_id, vtable_closure.substs.func_substs)),\n \n             traits::VtableFnPointer(_fn_ty) => {\n                 let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n@@ -524,14 +525,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n \n-            traits::VtableObject(ref _data) => {\n-                unimplemented!()\n-                // Callee {\n-                //     data: Virtual(traits::get_vtable_index_of_object_method(\n-                //                   tcx, data, def_id)),\n-                //                   ty: def_ty(tcx, def_id, substs)\n-                // }\n-            }\n+            traits::VtableObject(ref data) => {\n+                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n+                if let Some(&mut(first_arg, ref mut first_ty)) = first_arg {\n+                    let (_, vtable) = self.get_fat_ptr(first_arg);\n+                    let vtable = self.memory.read_ptr(vtable)?;\n+                    let idx = idx + 3;\n+                    let offset = idx * self.memory.pointer_size();\n+                    let fn_ptr = self.memory.read_ptr(vtable.offset(offset as isize))?;\n+                    let (def_id, substs, ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                    // FIXME: skip_binder is wrong for HKL\n+                    *first_ty = ty.sig.skip_binder().inputs[0];\n+                    Ok((def_id, substs))\n+                } else {\n+                    Err(EvalError::VtableForArgumentlessMethod)\n+                }\n+            },\n             vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n         }\n     }\n@@ -566,14 +575,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n #[derive(Debug)]\n-struct ImplMethod<'tcx> {\n-    method: Rc<ty::Method<'tcx>>,\n-    substs: &'tcx Substs<'tcx>,\n-    is_provided: bool,\n+pub(super) struct ImplMethod<'tcx> {\n+    pub(super) method: Rc<ty::Method<'tcx>>,\n+    pub(super) substs: &'tcx Substs<'tcx>,\n+    pub(super) is_provided: bool,\n }\n \n /// Locates the applicable definition of a method, given its name.\n-fn get_impl_method<'a, 'tcx>(\n+pub(super) fn get_impl_method<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     substs: &'tcx Substs<'tcx>,\n     impl_def_id: DefId,"}, {"sha": "800ded8177cb98ed9d7ade74aee2bebfcbdba451", "filename": "src/interpreter/vtable.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=d06227d91c1fbd60254b24041a08497d9d201f4b", "patch": "@@ -0,0 +1,202 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::traits::{self, Reveal, SelectionContext};\n+use rustc::ty::subst::{Substs, Subst};\n+use rustc::ty;\n+\n+use super::EvalContext;\n+use error::EvalResult;\n+use memory::Pointer;\n+use super::terminator::{get_impl_method, ImplMethod};\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    /// Creates a returns a dynamic vtable for the given type and vtable origin.\n+    /// This is used only for objects.\n+    ///\n+    /// The `trait_ref` encodes the erased self type. Hence if we are\n+    /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n+    /// `trait_ref` would map `T:Trait`.\n+    pub fn get_vtable(&mut self, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n+        let tcx = self.tcx;\n+\n+        debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n+\n+        let methods: Vec<_> = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n+            match self.fulfill_obligation(trait_ref.clone()) {\n+                // Should default trait error here?\n+                traits::VtableDefaultImpl(_) |\n+                traits::VtableBuiltin(_) => {\n+                    Vec::new().into_iter()\n+                }\n+                traits::VtableImpl(\n+                    traits::VtableImplData {\n+                        impl_def_id: id,\n+                        substs,\n+                        nested: _ }) => {\n+                    self.get_vtable_methods(id, substs)\n+                        .into_iter()\n+                        .map(|opt_mth| opt_mth.map(|mth| {\n+                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs, mth.method.fty)\n+                        }))\n+                        .collect::<Vec<_>>()\n+                        .into_iter()\n+                }\n+                traits::VtableClosure(\n+                    traits::VtableClosureData {\n+                        closure_def_id,\n+                        substs,\n+                        nested: _ }) => {\n+                    let closure_type = self.tcx.closure_type(closure_def_id, substs);\n+                    let fn_ty = ty::BareFnTy {\n+                        unsafety: closure_type.unsafety,\n+                        abi: closure_type.abi,\n+                        sig: closure_type.sig,\n+                    };\n+                    let fn_ty = self.tcx.mk_bare_fn(fn_ty);\n+                    unimplemented!()\n+                    //vec![Some(self.memory.create_fn_ptr(closure_def_id, substs.func_substs, fn_ty))].into_iter()\n+                }\n+                traits::VtableFnPointer(\n+                    traits::VtableFnPointerData {\n+                        fn_ty: bare_fn_ty,\n+                        nested: _ }) => {\n+                    let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                    //vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n+                    unimplemented!()\n+                }\n+                traits::VtableObject(ref data) => {\n+                    // this would imply that the Self type being erased is\n+                    // an object type; this cannot happen because we\n+                    // cannot cast an unsized type into a trait object\n+                    bug!(\"cannot get vtable for an object type: {:?}\",\n+                         data);\n+                }\n+                vtable @ traits::VtableParam(..) => {\n+                    bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n+                         trait_ref,\n+                         vtable);\n+                }\n+            }\n+        }).collect();\n+\n+        let size = self.type_size(trait_ref.self_ty());\n+        let align = self.type_align(trait_ref.self_ty());\n+\n+        let ptr_size = self.memory.pointer_size();\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.len()), ptr_size)?;\n+\n+        // FIXME: generate a destructor for the vtable.\n+        // trans does this with glue::get_drop_glue(ccx, trait_ref.self_ty())\n+\n+        self.memory.write_usize(vtable.offset(ptr_size as isize), size as u64)?;\n+        self.memory.write_usize(vtable.offset((ptr_size * 2) as isize), align as u64)?;\n+\n+        for (i, method) in methods.into_iter().enumerate() {\n+            if let Some(method) = method {\n+                self.memory.write_ptr(vtable.offset(ptr_size as isize * (3 + i as isize)), method)?;\n+            }\n+        }\n+\n+        Ok(vtable)\n+    }\n+\n+    fn get_vtable_methods(&mut self, impl_id: DefId, substs: &'tcx Substs<'tcx>) -> Vec<Option<ImplMethod<'tcx>>> {\n+        debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n+\n+        let trait_id = match self.tcx.impl_trait_ref(impl_id) {\n+            Some(t_id) => t_id.def_id,\n+            None       => bug!(\"make_impl_vtable: don't know how to \\\n+                                make a vtable for a type impl!\")\n+        };\n+\n+        self.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n+\n+        let trait_item_def_ids = self.tcx.trait_item_def_ids(trait_id);\n+        trait_item_def_ids\n+            .iter()\n+\n+            // Filter out non-method items.\n+            .filter_map(|item_def_id| {\n+                match *item_def_id {\n+                    ty::MethodTraitItemId(def_id) => Some(def_id),\n+                    _ => None,\n+                }\n+            })\n+\n+            // Now produce pointers for each remaining method. If the\n+            // method could never be called from this object, just supply\n+            // null.\n+            .map(|trait_method_def_id| {\n+                debug!(\"get_vtable_methods: trait_method_def_id={:?}\",\n+                       trait_method_def_id);\n+\n+                let trait_method_type = match self.tcx.impl_or_trait_item(trait_method_def_id) {\n+                    ty::MethodTraitItem(m) => m,\n+                    _ => bug!(\"should be a method, not other assoc item\"),\n+                };\n+                let name = trait_method_type.name;\n+\n+                // Some methods cannot be called on an object; skip those.\n+                if !self.tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n+                    debug!(\"get_vtable_methods: not vtable safe\");\n+                    return None;\n+                }\n+\n+                debug!(\"get_vtable_methods: trait_method_type={:?}\",\n+                       trait_method_type);\n+\n+                // the method may have some early-bound lifetimes, add\n+                // regions for those\n+                let method_substs = Substs::for_item(self.tcx, trait_method_def_id,\n+                                                     |_, _| self.tcx.mk_region(ty::ReErased),\n+                                                     |_, _| self.tcx.types.err);\n+\n+                // The substitutions we have are on the impl, so we grab\n+                // the method type from the impl to substitute into.\n+                let mth = get_impl_method(self.tcx, method_substs, impl_id, substs, name);\n+\n+                debug!(\"get_vtable_methods: mth={:?}\", mth);\n+\n+                // If this is a default method, it's possible that it\n+                // relies on where clauses that do not hold for this\n+                // particular set of type parameters. Note that this\n+                // method could then never be called, so we do not want to\n+                // try and trans it, in that case. Issue #23435.\n+                if mth.is_provided {\n+                    let predicates = mth.method.predicates.predicates.subst(self.tcx, &mth.substs);\n+                    if !self.normalize_and_test_predicates(predicates) {\n+                        debug!(\"get_vtable_methods: predicates do not hold\");\n+                        return None;\n+                    }\n+                }\n+\n+                Some(mth)\n+            })\n+            .collect()\n+    }\n+\n+    /// Normalizes the predicates and checks whether they hold.  If this\n+    /// returns false, then either normalize encountered an error or one\n+    /// of the predicates did not hold. Used when creating vtables to\n+    /// check for unsatisfiable methods.\n+    fn normalize_and_test_predicates(&mut self, predicates: Vec<ty::Predicate<'tcx>>) -> bool {\n+        debug!(\"normalize_and_test_predicates(predicates={:?})\",\n+               predicates);\n+\n+        self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+            let mut selcx = SelectionContext::new(&infcx);\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let cause = traits::ObligationCause::dummy();\n+            let traits::Normalized { value: predicates, obligations } =\n+                traits::normalize(&mut selcx, cause.clone(), &predicates);\n+            for obligation in obligations {\n+                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+            }\n+            for predicate in predicates {\n+                let obligation = traits::Obligation::new(cause.clone(), predicate);\n+                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+            }\n+\n+            fulfill_cx.select_all_or_error(&infcx).is_ok()\n+        })\n+    }\n+}"}, {"sha": "25ae6b3d995ba0452ed304af0d6214a0afd63ead", "filename": "src/memory.rs", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06227d91c1fbd60254b24041a08497d9d201f4b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d06227d91c1fbd60254b24041a08497d9d201f4b", "patch": "@@ -4,7 +4,7 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::BareFnTy;\n+use rustc::ty::{BareFnTy, ClosureTy, ClosureSubsts};\n use rustc::ty::subst::Substs;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n@@ -53,11 +53,22 @@ impl Pointer {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n-pub struct FunctionDefinition<'tcx> {\n+#[derive(Debug, Clone, Hash, Eq, PartialEq)]\n+struct FunctionDefinition<'tcx> {\n     pub def_id: DefId,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub fn_ty: &'tcx BareFnTy<'tcx>,\n+    pub kind: FunctionKind<'tcx>,\n+}\n+\n+#[derive(Debug, Clone, Hash, Eq, PartialEq)]\n+enum FunctionKind<'tcx> {\n+    Closure {\n+        substs: ClosureSubsts<'tcx>,\n+        ty: ClosureTy<'tcx>,\n+    },\n+    Function {\n+        substs: &'tcx Substs<'tcx>,\n+        ty: &'tcx BareFnTy<'tcx>,\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -112,12 +123,27 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n+    pub fn create_closure_ptr(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n+        self.create_fn_alloc(FunctionDefinition {\n+            def_id: def_id,\n+            kind: FunctionKind::Closure {\n+                substs: substs,\n+                ty: fn_ty,\n+            }\n+        })\n+    }\n+\n     pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n-        let def = FunctionDefinition {\n+        self.create_fn_alloc(FunctionDefinition {\n             def_id: def_id,\n-            substs: substs,\n-            fn_ty: fn_ty,\n-        };\n+            kind: FunctionKind::Function {\n+                substs: substs,\n+                ty: fn_ty,\n+            }\n+        })\n+    }\n+\n+    fn create_fn_alloc(&mut self, def: FunctionDefinition<'tcx>) -> Pointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&def) {\n             return Pointer {\n                 alloc_id: alloc_id,\n@@ -127,7 +153,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n-        self.functions.insert(id, def);\n+        self.functions.insert(id, def.clone());\n         self.function_alloc_cache.insert(def, id);\n         Pointer {\n             alloc_id: id,\n@@ -269,10 +295,33 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n+    pub fn get_closure(&self, id: AllocId) -> EvalResult<'tcx, (DefId, ClosureSubsts<'tcx>, ClosureTy<'tcx>)> {\n+        debug!(\"reading closure fn ptr: {}\", id);\n+        match self.functions.get(&id) {\n+            Some(&FunctionDefinition {\n+                def_id,\n+                kind: FunctionKind::Closure { ref substs, ref ty }\n+            }) => Ok((def_id, substs.clone(), ty.clone())),\n+            Some(&FunctionDefinition {\n+                kind: FunctionKind::Function { .. }, ..\n+            }) => Err(EvalError::CalledClosureAsFunction),\n+            None => match self.alloc_map.get(&id) {\n+                Some(_) => Err(EvalError::ExecuteMemory),\n+                None => Err(EvalError::InvalidFunctionPointer),\n+            }\n+        }\n+    }\n+\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, &'tcx BareFnTy<'tcx>)> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n-            Some(&fn_id) => Ok(fn_id),\n+            Some(&FunctionDefinition {\n+                def_id,\n+                kind: FunctionKind::Function { substs, ty }\n+            }) => Ok((def_id, substs, ty)),\n+            Some(&FunctionDefinition {\n+                kind: FunctionKind::Closure { .. }, ..\n+            }) => Err(EvalError::CalledClosureAsFunction),\n             None => match self.alloc_map.get(&id) {\n                 Some(_) => Err(EvalError::ExecuteMemory),\n                 None => Err(EvalError::InvalidFunctionPointer),"}, {"sha": "acef02d2bc8863624c422da621557fd2bb52dd16", "filename": "tests/run-pass/traits.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d06227d91c1fbd60254b24041a08497d9d201f4b/tests%2Frun-pass%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06227d91c1fbd60254b24041a08497d9d201f4b/tests%2Frun-pass%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftraits.rs?ref=d06227d91c1fbd60254b24041a08497d9d201f4b", "patch": "@@ -0,0 +1,26 @@\n+struct Struct(i32);\n+\n+trait Trait {\n+    fn method(&self);\n+}\n+\n+impl Trait for Struct {\n+    fn method(&self) {\n+        assert_eq!(self.0, 42);\n+    }\n+}\n+\n+fn main() {\n+    let y: &Trait = &Struct(42);\n+    y.method();\n+    /*\n+    let x: Box<Fn(i32) -> i32> = Box::new(|x| x * 2);\n+    assert_eq!(x(21), 42);\n+    let mut i = 5;\n+    {\n+        let mut x: Box<FnMut()> = Box::new(|| i *= 2);\n+        x(); x();\n+    }\n+    assert_eq!(i, 20);\n+    */\n+}"}]}