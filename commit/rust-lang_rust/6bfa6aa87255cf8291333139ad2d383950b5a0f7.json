{"sha": "6bfa6aa87255cf8291333139ad2d383950b5a0f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZmE2YWE4NzI1NWNmODI5MTMzMzEzOWFkMmQzODM5NTBiNWEwZjc=", "commit": {"author": {"name": "Diogo Sousa", "email": "diogogsousa@gmail.com", "date": "2018-09-30T01:41:49Z"}, "committer": {"name": "Diogo Sousa", "email": "diogogsousa@gmail.com", "date": "2018-09-30T19:01:35Z"}, "message": "Deduplicate errors in the obligation forest.\n\nFixes #40827.", "tree": {"sha": "69f4fe903cc2ca7110f21748012a08e47596267e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69f4fe903cc2ca7110f21748012a08e47596267e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bfa6aa87255cf8291333139ad2d383950b5a0f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfa6aa87255cf8291333139ad2d383950b5a0f7", "html_url": "https://github.com/rust-lang/rust/commit/6bfa6aa87255cf8291333139ad2d383950b5a0f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bfa6aa87255cf8291333139ad2d383950b5a0f7/comments", "author": {"login": "orium", "id": 4107683, "node_id": "MDQ6VXNlcjQxMDc2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4107683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orium", "html_url": "https://github.com/orium", "followers_url": "https://api.github.com/users/orium/followers", "following_url": "https://api.github.com/users/orium/following{/other_user}", "gists_url": "https://api.github.com/users/orium/gists{/gist_id}", "starred_url": "https://api.github.com/users/orium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orium/subscriptions", "organizations_url": "https://api.github.com/users/orium/orgs", "repos_url": "https://api.github.com/users/orium/repos", "events_url": "https://api.github.com/users/orium/events{/privacy}", "received_events_url": "https://api.github.com/users/orium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "orium", "id": 4107683, "node_id": "MDQ6VXNlcjQxMDc2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4107683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orium", "html_url": "https://github.com/orium", "followers_url": "https://api.github.com/users/orium/followers", "following_url": "https://api.github.com/users/orium/following{/other_user}", "gists_url": "https://api.github.com/users/orium/gists{/gist_id}", "starred_url": "https://api.github.com/users/orium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orium/subscriptions", "organizations_url": "https://api.github.com/users/orium/orgs", "repos_url": "https://api.github.com/users/orium/repos", "events_url": "https://api.github.com/users/orium/events{/privacy}", "received_events_url": "https://api.github.com/users/orium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2ff5d696cfa6003b10a124910259fe5a5885271", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ff5d696cfa6003b10a124910259fe5a5885271", "html_url": "https://github.com/rust-lang/rust/commit/d2ff5d696cfa6003b10a124910259fe5a5885271"}], "stats": {"total": 189, "additions": 162, "deletions": 27}, "files": [{"sha": "f159857e7446711e1d391327990c07618712e08d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 72, "deletions": 19, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=6bfa6aa87255cf8291333139ad2d383950b5a0f7", "patch": "@@ -65,6 +65,12 @@ pub enum ProcessResult<O, E> {\n     Error(E),\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+struct ObligationTreeId(usize);\n+\n+type ObligationTreeIdGenerator =\n+    ::std::iter::Map<::std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n+\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -79,11 +85,25 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n+\n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n+\n     /// An cache of the nodes in `nodes`, indexed by predicate.\n     waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n+\n     scratch: Option<Vec<usize>>,\n+\n+    obligation_tree_id_generator: ObligationTreeIdGenerator,\n+\n+    /// Per tree error cache.  This is used to deduplicate errors,\n+    /// which is necessary to avoid trait resolution overflow in\n+    /// some cases.\n+    ///\n+    /// See [this][details] for details.\n+    ///\n+    /// [details]: https://github.com/rust-lang/rust/pull/53255#issuecomment-421184780\n+    error_cache: FxHashMap<ObligationTreeId, FxHashSet<O::Predicate>>,\n }\n \n #[derive(Debug)]\n@@ -99,6 +119,9 @@ struct Node<O> {\n     /// Obligations that depend on this obligation for their\n     /// completion. They must all be in a non-pending state.\n     dependents: Vec<NodeIndex>,\n+\n+    /// Identifier of the obligation tree to which this node belongs.\n+    obligation_tree_id: ObligationTreeId,\n }\n \n /// The state of one node in some tree within the forest. This\n@@ -165,6 +188,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n             done_cache: FxHashSet(),\n             waiting_cache: FxHashMap(),\n             scratch: Some(vec![]),\n+            obligation_tree_id_generator: (0..).map(|i| ObligationTreeId(i)),\n+            error_cache: FxHashMap(),\n         }\n     }\n \n@@ -214,9 +239,29 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Vacant(v) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - ok, new index is {}\",\n                        obligation, parent, self.nodes.len());\n-                v.insert(NodeIndex::new(self.nodes.len()));\n-                self.nodes.push(Node::new(parent, obligation));\n-                Ok(())\n+\n+                let obligation_tree_id = match parent {\n+                    Some(p) => {\n+                        let parent_node = &self.nodes[p.get()];\n+                        parent_node.obligation_tree_id\n+                    }\n+                    None => self.obligation_tree_id_generator.next().unwrap()\n+                };\n+\n+                let already_failed =\n+                    parent.is_some()\n+                        && self.error_cache\n+                            .get(&obligation_tree_id)\n+                            .map(|errors| errors.contains(obligation.as_predicate()))\n+                            .unwrap_or(false);\n+\n+                if already_failed {\n+                    Err(())\n+                } else {\n+                    v.insert(NodeIndex::new(self.nodes.len()));\n+                    self.nodes.push(Node::new(parent, obligation, obligation_tree_id));\n+                    Ok(())\n+                }\n             }\n         }\n     }\n@@ -251,6 +296,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .collect()\n     }\n \n+    fn insert_into_error_cache(&mut self, node_index: usize) {\n+        let node = &self.nodes[node_index];\n+\n+        self.error_cache\n+            .entry(node.obligation_tree_id)\n+            .or_insert_with(|| FxHashSet())\n+            .insert(node.obligation.as_predicate().clone());\n+    }\n+\n     /// Perform a pass through the obligation list. This must\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n@@ -264,22 +318,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut stalled = true;\n \n         for index in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\",\n-                   index,\n-                   self.nodes[index]);\n+            debug!(\"process_obligations: node {} == {:?}\", index, self.nodes[index]);\n \n             let result = match self.nodes[index] {\n-                Node { ref state, ref mut obligation, .. }\n-                    if state.get() == NodeState::Pending =>\n-                {\n-                    processor.process_obligation(obligation)\n-                }\n+                Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n+                    processor.process_obligation(obligation),\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\",\n-                   index,\n-                   result);\n+            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -420,13 +467,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n \n         while let Some(i) = error_stack.pop() {\n-            let node = &self.nodes[i];\n-\n-            match node.state.get() {\n+            match self.nodes[i].state.get() {\n                 NodeState::Error => continue,\n-                _ => node.state.set(NodeState::Error)\n+                _ => self.nodes[i].state.set(NodeState::Error),\n             }\n \n+            let node = &self.nodes[i];\n+\n             error_stack.extend(\n                 node.parent.iter().chain(node.dependents.iter()).map(|x| x.get())\n             );\n@@ -514,6 +561,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n+                    self.insert_into_error_cache(i);\n                 }\n                 NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n@@ -587,12 +635,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n }\n \n impl<O> Node<O> {\n-    fn new(parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+    fn new(\n+        parent: Option<NodeIndex>,\n+        obligation: O,\n+        obligation_tree_id: ObligationTreeId\n+    ) -> Node<O> {\n         Node {\n             obligation,\n             state: Cell::new(NodeState::Pending),\n             parent,\n             dependents: vec![],\n+            obligation_tree_id,\n         }\n     }\n }"}, {"sha": "4b079ace3ca328258fc5e13cd77c033cfa871a13", "filename": "src/test/ui/issue-40827.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Fissue-40827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Fissue-40827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40827.rs?ref=6bfa6aa87255cf8291333139ad2d383950b5a0f7", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+struct Foo(Arc<Bar>);\n+\n+enum Bar {\n+    A(Rc<Foo>),\n+    B(Option<Foo>),\n+}\n+\n+fn f<T: Send>(_: T) {}\n+\n+fn main() {\n+    f(Foo(Arc::new(Bar::B(None))));\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n+}"}, {"sha": "dd0ebf96d19e4cfd5b23e5fb67de87b8345c7161", "filename": "src/test/ui/issue-40827.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Fissue-40827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Fissue-40827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40827.stderr?ref=6bfa6aa87255cf8291333139ad2d383950b5a0f7", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: `std::rc::Rc<Foo>` cannot be sent between threads safely\n+  --> $DIR/issue-40827.rs:24:5\n+   |\n+LL |     f(Foo(Arc::new(Bar::B(None))));\n+   |     ^ `std::rc::Rc<Foo>` cannot be sent between threads safely\n+   |\n+   = help: within `Bar`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<Foo>`\n+   = note: required because it appears within the type `Bar`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<Bar>`\n+   = note: required because it appears within the type `Foo`\n+note: required by `f`\n+  --> $DIR/issue-40827.rs:21:1\n+   |\n+LL | fn f<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `std::rc::Rc<Foo>` cannot be shared between threads safely\n+  --> $DIR/issue-40827.rs:24:5\n+   |\n+LL |     f(Foo(Arc::new(Bar::B(None))));\n+   |     ^ `std::rc::Rc<Foo>` cannot be shared between threads safely\n+   |\n+   = help: within `Bar`, the trait `std::marker::Sync` is not implemented for `std::rc::Rc<Foo>`\n+   = note: required because it appears within the type `Bar`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc<Bar>`\n+   = note: required because it appears within the type `Foo`\n+note: required by `f`\n+  --> $DIR/issue-40827.rs:21:1\n+   |\n+LL | fn f<T: Send>(_: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "dd6d2f6a2256a0e1512dee2d23d79c5e57164bcf", "filename": "src/test/ui/recursion/recursive-requirements.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.rs?ref=6bfa6aa87255cf8291333139ad2d383950b5a0f7", "patch": "@@ -23,5 +23,7 @@ pub struct Bar {\n }\n \n fn main() {\n-    let _: AssertSync<Foo> = unimplemented!(); //~ ERROR E0275\n+    let _: AssertSync<Foo> = unimplemented!();\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n }"}, {"sha": "8fe282505e9078d1652fd4cb8e864b4d05675121", "filename": "src/test/ui/recursion/recursive-requirements.stderr", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bfa6aa87255cf8291333139ad2d383950b5a0f7/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-requirements.stderr?ref=6bfa6aa87255cf8291333139ad2d383950b5a0f7", "patch": "@@ -1,15 +1,33 @@\n-error[E0275]: overflow evaluating the requirement `Foo: std::marker::Sync`\n+error[E0277]: `*const Bar` cannot be shared between threads safely\n   --> $DIR/recursive-requirements.rs:26:12\n    |\n-LL |     let _: AssertSync<Foo> = unimplemented!(); //~ ERROR E0275\n-   |            ^^^^^^^^^^^^^^^\n+LL |     let _: AssertSync<Foo> = unimplemented!();\n+   |            ^^^^^^^^^^^^^^^ `*const Bar` cannot be shared between threads safely\n    |\n-   = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n-   = note: required because it appears within the type `std::marker::PhantomData<Foo>`\n+   = help: within `Foo`, the trait `std::marker::Sync` is not implemented for `*const Bar`\n+   = note: required because it appears within the type `Foo`\n+note: required by `AssertSync`\n+  --> $DIR/recursive-requirements.rs:13:1\n+   |\n+LL | struct AssertSync<T: Sync>(PhantomData<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `*const Foo` cannot be shared between threads safely\n+  --> $DIR/recursive-requirements.rs:26:12\n+   |\n+LL |     let _: AssertSync<Foo> = unimplemented!();\n+   |            ^^^^^^^^^^^^^^^ `*const Foo` cannot be shared between threads safely\n+   |\n+   = help: within `Foo`, the trait `std::marker::Sync` is not implemented for `*const Foo`\n    = note: required because it appears within the type `Bar`\n    = note: required because it appears within the type `std::marker::PhantomData<Bar>`\n    = note: required because it appears within the type `Foo`\n+note: required by `AssertSync`\n+  --> $DIR/recursive-requirements.rs:13:1\n+   |\n+LL | struct AssertSync<T: Sync>(PhantomData<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0275`.\n+For more information about this error, try `rustc --explain E0277`."}]}