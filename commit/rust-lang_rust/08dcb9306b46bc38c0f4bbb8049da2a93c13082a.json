{"sha": "08dcb9306b46bc38c0f4bbb8049da2a93c13082a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZGNiOTMwNmI0NmJjMzhjMGY0YmJiODA0OWRhMmE5M2MxMzA4MmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-08T17:51:43Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-08T17:52:12Z"}, "message": "rustc: Remove all traces of the unification cache", "tree": {"sha": "3b549c9eae04cf6beb0fbdb1857636ba4078200f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b549c9eae04cf6beb0fbdb1857636ba4078200f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08dcb9306b46bc38c0f4bbb8049da2a93c13082a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08dcb9306b46bc38c0f4bbb8049da2a93c13082a", "html_url": "https://github.com/rust-lang/rust/commit/08dcb9306b46bc38c0f4bbb8049da2a93c13082a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08dcb9306b46bc38c0f4bbb8049da2a93c13082a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d360c481e8bd6079eb92b155a7c5451fc8bd35f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d360c481e8bd6079eb92b155a7c5451fc8bd35f6", "html_url": "https://github.com/rust-lang/rust/commit/d360c481e8bd6079eb92b155a7c5451fc8bd35f6"}], "stats": {"total": 60, "additions": 0, "deletions": 60}, "files": [{"sha": "ee3ca30095b4c7c3c0d0bf579d85123f4edf30c5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/08dcb9306b46bc38c0f4bbb8049da2a93c13082a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08dcb9306b46bc38c0f4bbb8049da2a93c13082a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=08dcb9306b46bc38c0f4bbb8049da2a93c13082a", "patch": "@@ -52,16 +52,10 @@ import middle::tstate::ann::ts_ann;\n type ty_table = hashmap[ast::def_id, ty::t];\n type fn_purity_table = hashmap[ast::def_id, ast::purity];\n \n-type unify_cache_entry = tup(ty::t,ty::t,vec[mutable ty::t]);\n-type unify_cache = hashmap[unify_cache_entry,ty::unify::result];\n-\n type obj_info = rec(vec[ast::obj_field] obj_fields, ast::def_id this_obj);\n \n type crate_ctxt = rec(mutable vec[obj_info] obj_infos,\n                       @fn_purity_table fn_purity_table,\n-                      unify_cache unify_cache,\n-                      mutable uint cache_hits,\n-                      mutable uint cache_misses,\n                       ty::ctxt tcx);\n \n type fn_ctxt = rec(ty::t ret_ty,\n@@ -820,22 +814,9 @@ mod collect {\n mod unify {\n     fn simple(&@fn_ctxt fcx, &ty::t expected, &ty::t actual)\n             -> ty::unify::result {\n-        /*auto cache_key = tup(expected, actual, param_substs);\n-        alt (fcx.ccx.unify_cache.find(cache_key)) {\n-            case (some(?r)) {\n-                fcx.ccx.cache_hits += 1u;\n-                ret r;\n-            }\n-            case (none) {\n-                fcx.ccx.cache_misses += 1u;\n-            }\n-        }*/\n-\n         auto result = ty::unify::unify(expected, actual, fcx.var_bindings,\n                                        fcx.ccx.tcx);\n \n-        //fcx.ccx.unify_cache.insert(cache_key, result);\n-\n         // FIXME: Shouldn't be necessary, but is until we remove pushdown.\n         alt (result) {\n             case (ures_ok(?typ)) {\n@@ -2856,37 +2837,6 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n     }\n }\n \n-// Utilities for the unification cache\n-\n-fn hash_unify_cache_entry(&unify_cache_entry uce) -> uint {\n-    auto h = ty::hash_ty(uce._0);\n-    h += h << 5u + ty::hash_ty(uce._1);\n-\n-    auto i = 0u;\n-    auto tys_len = vec::len(uce._2);\n-    while (i < tys_len) {\n-        h += h << 5u + ty::hash_ty(uce._2.(i));\n-        i += 1u;\n-    }\n-\n-    ret h;\n-}\n-\n-fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n-    if (!ty::eq_ty(a._0, b._0) || !ty::eq_ty(a._1, b._1)) { ret false; }\n-\n-    auto i = 0u;\n-    auto tys_len = vec::len(a._2);\n-    if (vec::len(b._2) != tys_len) { ret false; }\n-\n-    while (i < tys_len) {\n-        if (!ty::eq_ty(a._2.(i), b._2.(i))) { ret false; }\n-        i += 1u;\n-    }\n-\n-    ret true;\n-}\n-\n fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n     auto res = @new_def_hash[ast::purity]();\n \n@@ -2914,26 +2864,16 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) {\n \n     let vec[obj_info] obj_infos = [];\n \n-    auto hasher = hash_unify_cache_entry;\n-    auto eqer = eq_unify_cache_entry;\n-    auto unify_cache =\n-        map::mk_hashmap[unify_cache_entry,ty::unify::result](hasher, eqer);\n     auto fpt = mk_fn_purity_table(crate); // use a variation on collect\n \n     auto ccx = @rec(mutable obj_infos=obj_infos,\n                     fn_purity_table=fpt,\n-                    unify_cache=unify_cache,\n-                    mutable cache_hits=0u,\n-                    mutable cache_misses=0u,\n                     tcx=tcx);\n \n     auto visit = rec(visit_item_pre = bind check_item(ccx, _)\n                      with walk::default_visitor());\n \n     walk::walk_crate(visit, *crate);\n-\n-    log #fmt(\"cache hit rate: %u/%u\", ccx.cache_hits,\n-             ccx.cache_hits + ccx.cache_misses);\n }\n \n //"}]}