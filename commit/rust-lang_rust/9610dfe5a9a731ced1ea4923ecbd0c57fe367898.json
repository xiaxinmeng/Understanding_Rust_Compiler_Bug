{"sha": "9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "node_id": "C_kwDOAAsO6NoAKDk2MTBkZmU1YTlhNzMxY2VkMWVhNDkyM2VjYmQwYzU3ZmUzNjc4OTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T21:26:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T21:26:22Z"}, "message": "Auto merge of #109698 - epage:wtf, r=Amanieu\n\nAllow limited access to `OsStr` bytes\n\n`OsStr` has historically kept its implementation details private out of\nconcern for locking us into a specific encoding on Windows.\n\nThis is an alternative to rust-lang#95290 which proposed specifying the encoding on Windows.  Instead, this\nonly specifies that for cross-platform code, `OsStr`'s encoding is a superset of UTF-8 and defines\nrules for safely interacting with it\n\nAt minimum, this can greatly simplify the `os_str_bytes` crate and every\narg parser that interacts with `OsStr` directly (which is most of those\nthat support invalid UTF-8).\n\nTracking issue: #111544", "tree": {"sha": "9d34e6dd7c85cc272964c3b8232e401cea3bbfea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d34e6dd7c85cc272964c3b8232e401cea3bbfea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "html_url": "https://github.com/rust-lang/rust/commit/9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0411ffcebcd7f75ac02ed45feb53ffd07b75398", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0411ffcebcd7f75ac02ed45feb53ffd07b75398", "html_url": "https://github.com/rust-lang/rust/commit/f0411ffcebcd7f75ac02ed45feb53ffd07b75398"}, {"sha": "e6a35c49533dd734f178b04677404df0da518737", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a35c49533dd734f178b04677404df0da518737", "html_url": "https://github.com/rust-lang/rust/commit/e6a35c49533dd734f178b04677404df0da518737"}], "stats": {"total": 242, "additions": 159, "deletions": 83}, "files": [{"sha": "3ddb8748753e40c5b5ca440c82155c432e0e975c", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -127,6 +127,14 @@\n //! trait, which provides a [`from_wide`] method to convert a native Windows\n //! string (without the terminating nul character) to an [`OsString`].\n //!\n+//! ## On all platforms\n+//!\n+//! On all platforms, [`OsStr`] consists of a sequence of bytes that is encoded as a superset of\n+//! UTF-8; see [`OsString`] for more details on its encoding on different platforms.\n+//!\n+//! For limited, inexpensive conversions from and to bytes, see [`OsStr::as_os_str_bytes`] and\n+//! [`OsStr::from_os_str_bytes_unchecked`].\n+//!\n //! [Unicode scalar value]: https://www.unicode.org/glossary/#unicode_scalar_value\n //! [Unicode code point]: https://www.unicode.org/glossary/#code_point\n //! [`env::set_var()`]: crate::env::set_var \"env::set_var\""}, {"sha": "bb577acf769d4cdacf09688c045f56eb7343059e", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -667,6 +667,51 @@ impl OsStr {\n         s.as_ref()\n     }\n \n+    /// Converts a slice of bytes to an OS string slice without checking that the string contains\n+    /// valid `OsStr`-encoded data.\n+    ///\n+    /// The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n+    /// By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n+    /// ASCII.\n+    ///\n+    /// See the [module's toplevel documentation about conversions][conversions] for safe,\n+    /// cross-platform [conversions] from/to native representations.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As the encoding is unspecified, callers must pass in bytes that originated as a mixture of\n+    /// validated UTF-8 and bytes from [`OsStr::as_os_str_bytes`] from within the same rust version\n+    /// built for the same target platform.  For example, reconstructing an `OsStr` from bytes sent\n+    /// over the network or stored in a file will likely violate these safety rules.\n+    ///\n+    /// Due to the encoding being self-synchronizing, the bytes from [`OsStr::as_os_str_bytes`] can be\n+    /// split either immediately before or immediately after any valid non-empty UTF-8 substring.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(os_str_bytes)]\n+    ///\n+    /// use std::ffi::OsStr;\n+    ///\n+    /// let os_str = OsStr::new(\"Mary had a little lamb\");\n+    /// let bytes = os_str.as_os_str_bytes();\n+    /// let words = bytes.split(|b| *b == b' ');\n+    /// let words: Vec<&OsStr> = words.map(|word| {\n+    ///     // SAFETY:\n+    ///     // - Each `word` only contains content that originated from `OsStr::as_os_str_bytes`\n+    ///     // - Only split with ASCII whitespace which is a non-empty UTF-8 substring\n+    ///     unsafe { OsStr::from_os_str_bytes_unchecked(word) }\n+    /// }).collect();\n+    /// ```\n+    ///\n+    /// [conversions]: super#conversions\n+    #[inline]\n+    #[unstable(feature = \"os_str_bytes\", issue = \"111544\")]\n+    pub unsafe fn from_os_str_bytes_unchecked(bytes: &[u8]) -> &Self {\n+        Self::from_inner(Slice::from_os_str_bytes_unchecked(bytes))\n+    }\n+\n     #[inline]\n     fn from_inner(inner: &Slice) -> &OsStr {\n         // SAFETY: OsStr is just a wrapper of Slice,\n@@ -837,13 +882,24 @@ impl OsStr {\n         OsString { inner: Buf::from_box(boxed) }\n     }\n \n-    /// Gets the underlying byte representation.\n+    /// Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n+    /// string slice, use the [`OsStr::from_os_str_bytes_unchecked`] function.\n+    ///\n+    /// The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n+    /// By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n+    /// ASCII.\n+    ///\n+    /// Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n+    /// be treated as opaque and only comparable within the same rust version built for the same\n+    /// target platform.  For example, sending the slice over the network or storing it in a file\n+    /// will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n+    /// and [`std::ffi`] for platform-specific, specified conversions.\n     ///\n-    /// Note: it is *crucial* that this API is not externally public, to avoid\n-    /// revealing the internal, platform-specific encodings.\n+    /// [`std::ffi`]: crate::ffi\n     #[inline]\n-    pub(crate) fn bytes(&self) -> &[u8] {\n-        unsafe { &*(&self.inner as *const _ as *const [u8]) }\n+    #[unstable(feature = \"os_str_bytes\", issue = \"111544\")]\n+    pub fn as_os_str_bytes(&self) -> &[u8] {\n+        self.inner.as_os_str_bytes()\n     }\n \n     /// Converts this string to its ASCII lower case equivalent in-place.\n@@ -1131,7 +1187,7 @@ impl Default for &OsStr {\n impl PartialEq for OsStr {\n     #[inline]\n     fn eq(&self, other: &OsStr) -> bool {\n-        self.bytes().eq(other.bytes())\n+        self.as_os_str_bytes().eq(other.as_os_str_bytes())\n     }\n }\n \n@@ -1158,23 +1214,23 @@ impl Eq for OsStr {}\n impl PartialOrd for OsStr {\n     #[inline]\n     fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n-        self.bytes().partial_cmp(other.bytes())\n+        self.as_os_str_bytes().partial_cmp(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn lt(&self, other: &OsStr) -> bool {\n-        self.bytes().lt(other.bytes())\n+        self.as_os_str_bytes().lt(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn le(&self, other: &OsStr) -> bool {\n-        self.bytes().le(other.bytes())\n+        self.as_os_str_bytes().le(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn gt(&self, other: &OsStr) -> bool {\n-        self.bytes().gt(other.bytes())\n+        self.as_os_str_bytes().gt(other.as_os_str_bytes())\n     }\n     #[inline]\n     fn ge(&self, other: &OsStr) -> bool {\n-        self.bytes().ge(other.bytes())\n+        self.as_os_str_bytes().ge(other.as_os_str_bytes())\n     }\n }\n \n@@ -1193,7 +1249,7 @@ impl PartialOrd<str> for OsStr {\n impl Ord for OsStr {\n     #[inline]\n     fn cmp(&self, other: &OsStr) -> cmp::Ordering {\n-        self.bytes().cmp(other.bytes())\n+        self.as_os_str_bytes().cmp(other.as_os_str_bytes())\n     }\n }\n \n@@ -1243,7 +1299,7 @@ impl_cmp!(Cow<'a, OsStr>, OsString);\n impl Hash for OsStr {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.bytes().hash(state)\n+        self.as_os_str_bytes().hash(state)\n     }\n }\n "}, {"sha": "28cd3c4e4dbd2d301c5728443571810f39c39015", "filename": "library/std/src/path.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -193,7 +193,7 @@ impl<'a> Prefix<'a> {\n     fn len(&self) -> usize {\n         use self::Prefix::*;\n         fn os_str_len(s: &OsStr) -> usize {\n-            s.bytes().len()\n+            s.as_os_str_bytes().len()\n         }\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n@@ -299,20 +299,6 @@ where\n     }\n }\n \n-unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n-    // SAFETY: See note at the top of this module to understand why this and\n-    // `OsStr::bytes` are used:\n-    //\n-    // This casts are safe as OsStr is internally a wrapper around [u8] on all\n-    // platforms.\n-    //\n-    // Note that currently this relies on the special knowledge that std has;\n-    // these types are single-element structs but are not marked\n-    // repr(transparent) or repr(C) which would make these casts not allowable\n-    // outside std.\n-    unsafe { &*(s as *const [u8] as *const OsStr) }\n-}\n-\n // Detect scheme on Redox\n fn has_redox_scheme(s: &[u8]) -> bool {\n     cfg!(target_os = \"redox\") && s.contains(&b':')\n@@ -330,26 +316,31 @@ fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n \n // basic workhorse for splitting stem and extension\n fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n-    if file.bytes() == b\"..\" {\n+    if file.as_os_str_bytes() == b\"..\" {\n         return (Some(file), None);\n     }\n \n     // The unsafety here stems from converting between &OsStr and &[u8]\n     // and back. This is safe to do because (1) we only look at ASCII\n     // contents of the encoding and (2) new &OsStr values are produced\n     // only from ASCII-bounded slices of existing &OsStr values.\n-    let mut iter = file.bytes().rsplitn(2, |b| *b == b'.');\n+    let mut iter = file.as_os_str_bytes().rsplitn(2, |b| *b == b'.');\n     let after = iter.next();\n     let before = iter.next();\n     if before == Some(b\"\") {\n         (Some(file), None)\n     } else {\n-        unsafe { (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s))) }\n+        unsafe {\n+            (\n+                before.map(|s| OsStr::from_os_str_bytes_unchecked(s)),\n+                after.map(|s| OsStr::from_os_str_bytes_unchecked(s)),\n+            )\n+        }\n     }\n }\n \n fn split_file_at_dot(file: &OsStr) -> (&OsStr, Option<&OsStr>) {\n-    let slice = file.bytes();\n+    let slice = file.as_os_str_bytes();\n     if slice == b\"..\" {\n         return (file, None);\n     }\n@@ -364,7 +355,12 @@ fn split_file_at_dot(file: &OsStr) -> (&OsStr, Option<&OsStr>) {\n     };\n     let before = &slice[..i];\n     let after = &slice[i + 1..];\n-    unsafe { (u8_slice_as_os_str(before), Some(u8_slice_as_os_str(after))) }\n+    unsafe {\n+        (\n+            OsStr::from_os_str_bytes_unchecked(before),\n+            Some(OsStr::from_os_str_bytes_unchecked(after)),\n+        )\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -743,7 +739,7 @@ impl<'a> Components<'a> {\n             // separately via `include_cur_dir`\n             b\"..\" => Some(Component::ParentDir),\n             b\"\" => None,\n-            _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) })),\n+            _ => Some(Component::Normal(unsafe { OsStr::from_os_str_bytes_unchecked(comp) })),\n         }\n     }\n \n@@ -900,7 +896,7 @@ impl<'a> Iterator for Components<'a> {\n                     let raw = &self.path[..self.prefix_len()];\n                     self.path = &self.path[self.prefix_len()..];\n                     return Some(Component::Prefix(PrefixComponent {\n-                        raw: unsafe { u8_slice_as_os_str(raw) },\n+                        raw: unsafe { OsStr::from_os_str_bytes_unchecked(raw) },\n                         parsed: self.prefix.unwrap(),\n                     }));\n                 }\n@@ -972,7 +968,7 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.back = State::Done;\n                     return Some(Component::Prefix(PrefixComponent {\n-                        raw: unsafe { u8_slice_as_os_str(self.path) },\n+                        raw: unsafe { OsStr::from_os_str_bytes_unchecked(self.path) },\n                         parsed: self.prefix.unwrap(),\n                     }));\n                 }\n@@ -1481,17 +1477,17 @@ impl PathBuf {\n     fn _set_extension(&mut self, extension: &OsStr) -> bool {\n         let file_stem = match self.file_stem() {\n             None => return false,\n-            Some(f) => f.bytes(),\n+            Some(f) => f.as_os_str_bytes(),\n         };\n \n         // truncate until right after the file stem\n         let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n-        let start = self.inner.bytes().as_ptr().addr();\n+        let start = self.inner.as_os_str_bytes().as_ptr().addr();\n         let v = self.as_mut_vec();\n         v.truncate(end_file_stem.wrapping_sub(start));\n \n         // add the new extension, if any\n-        let new = extension.bytes();\n+        let new = extension.as_os_str_bytes();\n         if !new.is_empty() {\n             v.reserve_exact(new.len() + 1);\n             v.push(b'.');\n@@ -2011,11 +2007,11 @@ impl Path {\n     // The following (private!) function allows construction of a path from a u8\n     // slice, which is only safe when it is known to follow the OsStr encoding.\n     unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n-        unsafe { Path::new(u8_slice_as_os_str(s)) }\n+        unsafe { Path::new(OsStr::from_os_str_bytes_unchecked(s)) }\n     }\n     // The following (private!) function reveals the byte encoding used for OsStr.\n     fn as_u8_slice(&self) -> &[u8] {\n-        self.inner.bytes()\n+        self.inner.as_os_str_bytes()\n     }\n \n     /// Directly wraps a string slice as a `Path` slice."}, {"sha": "963d17a47e4c022e3681ef96e1d8ab424855951d", "filename": "library/std/src/sys/common/small_c_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fsmall_c_string.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -19,7 +19,7 @@ pub fn run_path_with_cstr<T, F>(path: &Path, f: F) -> io::Result<T>\n where\n     F: FnOnce(&CStr) -> io::Result<T>,\n {\n-    run_with_cstr(path.as_os_str().bytes(), f)\n+    run_with_cstr(path.as_os_str().as_os_str_bytes(), f)\n }\n \n #[inline]"}, {"sha": "0a1cbcbe8ef3789ed3554b7ab5a5832a0bacebaa", "filename": "library/std/src/sys/common/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Ftests.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -8,7 +8,7 @@ use core::iter::repeat;\n fn stack_allocation_works() {\n     let path = Path::new(\"abc\");\n     let result = run_path_with_cstr(path, |p| {\n-        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        assert_eq!(p, &*CString::new(path.as_os_str().as_os_str_bytes()).unwrap());\n         Ok(42)\n     });\n     assert_eq!(result.unwrap(), 42);\n@@ -25,7 +25,7 @@ fn heap_allocation_works() {\n     let path = repeat(\"a\").take(384).collect::<String>();\n     let path = Path::new(&path);\n     let result = run_path_with_cstr(path, |p| {\n-        assert_eq!(p, &*CString::new(path.as_os_str().bytes()).unwrap());\n+        assert_eq!(p, &*CString::new(path.as_os_str().as_os_str_bytes()).unwrap());\n         Ok(42)\n     });\n     assert_eq!(result.unwrap(), 42);"}, {"sha": "142fcb9ed0b739f503781380f4330e82c611579e", "filename": "library/std/src/sys/unix/os_str.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -193,13 +193,18 @@ impl Buf {\n \n impl Slice {\n     #[inline]\n-    fn from_u8_slice(s: &[u8]) -> &Slice {\n+    pub fn as_os_str_bytes(&self) -> &[u8] {\n+        &self.inner\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_os_str_bytes_unchecked(s: &[u8]) -> &Slice {\n         unsafe { mem::transmute(s) }\n     }\n \n     #[inline]\n     pub fn from_str(s: &str) -> &Slice {\n-        Slice::from_u8_slice(s.as_bytes())\n+        unsafe { Slice::from_os_str_bytes_unchecked(s.as_bytes()) }\n     }\n \n     pub fn to_str(&self) -> Option<&str> {"}, {"sha": "91bc0e61a4a5baa41cd3f007e1a969af49efcab2", "filename": "library/std/src/sys/unix/os_str/tests.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos_str%2Ftests.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n #[test]\n fn slice_debug_output() {\n-    let input = Slice::from_u8_slice(b\"\\xF0hello,\\tworld\");\n+    let input = unsafe { Slice::from_os_str_bytes_unchecked(b\"\\xF0hello,\\tworld\") };\n     let expected = r#\"\"\\xF0hello,\\tworld\"\"#;\n     let output = format!(\"{input:?}\");\n \n@@ -11,8 +11,7 @@ fn slice_debug_output() {\n \n #[test]\n fn display() {\n-    assert_eq!(\n-        \"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\",\n-        Slice::from_u8_slice(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string(),\n-    );\n+    assert_eq!(\"Hello\\u{FFFD}\\u{FFFD} There\\u{FFFD} Goodbye\", unsafe {\n+        Slice::from_os_str_bytes_unchecked(b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\").to_string()\n+    },);\n }"}, {"sha": "935245f637b8670b03f42416224899df1f2eb7b3", "filename": "library/std/src/sys/unix/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpath.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n \n     // Get the components, skipping the redundant leading \".\" component if it exists.\n     let mut components = path.strip_prefix(\".\").unwrap_or(path).components();\n-    let path_os = path.as_os_str().bytes();\n+    let path_os = path.as_os_str().as_os_str_bytes();\n \n     let mut normalized = if path.is_absolute() {\n         // \"If a pathname begins with two successive <slash> characters, the"}, {"sha": "640648e870748b4e60dc2100bcb5cfcc3a0ee92c", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -164,9 +164,9 @@ pub enum ProgramKind {\n \n impl ProgramKind {\n     fn new(program: &OsStr) -> Self {\n-        if program.bytes().starts_with(b\"/\") {\n+        if program.as_os_str_bytes().starts_with(b\"/\") {\n             Self::Absolute\n-        } else if program.bytes().contains(&b'/') {\n+        } else if program.as_os_str_bytes().contains(&b'/') {\n             // If the program has more than one component in it, it is a relative path.\n             Self::Relative\n         } else {"}, {"sha": "6b597f499bcdc18a2b74d8b4965c166faddc5e33", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -226,7 +226,7 @@ pub(crate) fn append_arg(cmd: &mut Vec<u16>, arg: &Arg, force_quotes: bool) -> i\n     // that it actually gets passed through on the command line or otherwise\n     // it will be dropped entirely when parsed on the other end.\n     ensure_no_nuls(arg)?;\n-    let arg_bytes = arg.bytes();\n+    let arg_bytes = arg.as_os_str_bytes();\n     let (quote, escape) = match quote {\n         Quote::Always => (true, true),\n         Quote::Auto => {\n@@ -297,7 +297,9 @@ pub(crate) fn make_bat_command_line(\n         // * `|<>` pipe/redirect characters.\n         const SPECIAL: &[u8] = b\"\\t &()[]{}^=;!'+,`~%|<>\";\n         let force_quotes = match arg {\n-            Arg::Regular(arg) if !force_quotes => arg.bytes().iter().any(|c| SPECIAL.contains(c)),\n+            Arg::Regular(arg) if !force_quotes => {\n+                arg.as_os_str_bytes().iter().any(|c| SPECIAL.contains(c))\n+            }\n             _ => force_quotes,\n         };\n         append_arg(&mut cmd, arg, force_quotes)?;"}, {"sha": "611f0d040f0eb74d6eb3f23b8bbda1eae5d80799", "filename": "library/std/src/sys/windows/os_str.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -151,6 +151,16 @@ impl Buf {\n }\n \n impl Slice {\n+    #[inline]\n+    pub fn as_os_str_bytes(&self) -> &[u8] {\n+        self.inner.as_bytes()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_os_str_bytes_unchecked(s: &[u8]) -> &Slice {\n+        mem::transmute(Wtf8::from_bytes_unchecked(s))\n+    }\n+\n     #[inline]\n     pub fn from_str(s: &str) -> &Slice {\n         unsafe { mem::transmute(Wtf8::from_str(s)) }"}, {"sha": "c9c2d10e6c444f42bddaef7294ca96b464ac577e", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -1,7 +1,6 @@\n use super::{c, fill_utf16_buf, to_u16s};\n use crate::ffi::{OsStr, OsString};\n use crate::io;\n-use crate::mem;\n use crate::path::{Path, PathBuf, Prefix};\n use crate::ptr;\n \n@@ -11,16 +10,6 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n-/// # Safety\n-///\n-/// `bytes` must be a valid wtf8 encoded slice\n-#[inline]\n-unsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n-    // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n-    // which is compatible with &[u8].\n-    mem::transmute(bytes)\n-}\n-\n #[inline]\n pub fn is_sep_byte(b: u8) -> bool {\n     b == b'/' || b == b'\\\\'\n@@ -33,12 +22,12 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n \n /// Returns true if `path` looks like a lone filename.\n pub(crate) fn is_file_name(path: &OsStr) -> bool {\n-    !path.bytes().iter().copied().any(is_sep_byte)\n+    !path.as_os_str_bytes().iter().copied().any(is_sep_byte)\n }\n pub(crate) fn has_trailing_slash(path: &OsStr) -> bool {\n-    let is_verbatim = path.bytes().starts_with(br\"\\\\?\\\");\n+    let is_verbatim = path.as_os_str_bytes().starts_with(br\"\\\\?\\\");\n     let is_separator = if is_verbatim { is_verbatim_sep } else { is_sep_byte };\n-    if let Some(&c) = path.bytes().last() { is_separator(c) } else { false }\n+    if let Some(&c) = path.as_os_str_bytes().last() { is_separator(c) } else { false }\n }\n \n /// Appends a suffix to a path.\n@@ -60,7 +49,7 @@ impl<'a, const LEN: usize> PrefixParser<'a, LEN> {\n     fn get_prefix(path: &OsStr) -> [u8; LEN] {\n         let mut prefix = [0; LEN];\n         // SAFETY: Only ASCII characters are modified.\n-        for (i, &ch) in path.bytes().iter().take(LEN).enumerate() {\n+        for (i, &ch) in path.as_os_str_bytes().iter().take(LEN).enumerate() {\n             prefix[i] = if ch == b'/' { b'\\\\' } else { ch };\n         }\n         prefix\n@@ -93,15 +82,15 @@ impl<'a> PrefixParserSlice<'a, '_> {\n     }\n \n     fn prefix_bytes(&self) -> &'a [u8] {\n-        &self.path.bytes()[..self.index]\n+        &self.path.as_os_str_bytes()[..self.index]\n     }\n \n     fn finish(self) -> &'a OsStr {\n         // SAFETY: The unsafety here stems from converting between &OsStr and\n         // &[u8] and back. This is safe to do because (1) we only look at ASCII\n         // contents of the encoding and (2) new &OsStr values are produced only\n         // from ASCII-bounded slices of existing &OsStr values.\n-        unsafe { bytes_as_os_str(&self.path.bytes()[self.index..]) }\n+        unsafe { OsStr::from_os_str_bytes_unchecked(&self.path.as_os_str_bytes()[self.index..]) }\n     }\n }\n \n@@ -173,7 +162,7 @@ fn parse_drive(path: &OsStr) -> Option<u8> {\n         drive.is_ascii_alphabetic()\n     }\n \n-    match path.bytes() {\n+    match path.as_os_str_bytes() {\n         [drive, b':', ..] if is_valid_drive_letter(drive) => Some(drive.to_ascii_uppercase()),\n         _ => None,\n     }\n@@ -182,7 +171,7 @@ fn parse_drive(path: &OsStr) -> Option<u8> {\n // Parses a drive prefix exactly, e.g. \"C:\"\n fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n     // only parse two bytes: the drive letter and the drive separator\n-    if path.bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n+    if path.as_os_str_bytes().get(2).map(|&x| is_sep_byte(x)).unwrap_or(true) {\n         parse_drive(path)\n     } else {\n         None\n@@ -196,21 +185,26 @@ fn parse_drive_exact(path: &OsStr) -> Option<u8> {\n fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n     let separator = if verbatim { is_verbatim_sep } else { is_sep_byte };\n \n-    match path.bytes().iter().position(|&x| separator(x)) {\n+    match path.as_os_str_bytes().iter().position(|&x| separator(x)) {\n         Some(separator_start) => {\n             let separator_end = separator_start + 1;\n \n-            let component = &path.bytes()[..separator_start];\n+            let component = &path.as_os_str_bytes()[..separator_start];\n \n             // Panic safe\n             // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n-            let path = &path.bytes()[separator_end..];\n+            let path = &path.as_os_str_bytes()[separator_end..];\n \n             // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n             // is encoded in a single byte, therefore `bytes[separator_start]` and\n             // `bytes[separator_end]` must be code point boundaries and thus\n             // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices.\n-            unsafe { (bytes_as_os_str(component), bytes_as_os_str(path)) }\n+            unsafe {\n+                (\n+                    OsStr::from_os_str_bytes_unchecked(component),\n+                    OsStr::from_os_str_bytes_unchecked(path),\n+                )\n+            }\n         }\n         None => (path, OsStr::new(\"\")),\n     }\n@@ -329,7 +323,7 @@ pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n     // Verbatim paths should not be modified.\n     if prefix.map(|x| x.is_verbatim()).unwrap_or(false) {\n         // NULs in verbatim paths are rejected for consistency.\n-        if path.bytes().contains(&0) {\n+        if path.as_os_str_bytes().contains(&0) {\n             return Err(io::const_io_error!(\n                 io::ErrorKind::InvalidInput,\n                 \"strings passed to WinAPI cannot contain NULs\","}, {"sha": "a573a05c39cd913c5482068b5686cde87a248aec", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -395,7 +395,7 @@ fn resolve_exe<'a>(\n     // Test if the file name has the `exe` extension.\n     // This does a case-insensitive `ends_with`.\n     let has_exe_suffix = if exe_path.len() >= EXE_SUFFIX.len() {\n-        exe_path.bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n+        exe_path.as_os_str_bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n             .eq_ignore_ascii_case(EXE_SUFFIX.as_bytes())\n     } else {\n         false\n@@ -425,7 +425,7 @@ fn resolve_exe<'a>(\n         // From the `CreateProcessW` docs:\n         // > If the file name does not contain an extension, .exe is appended.\n         // Note that this rule only applies when searching paths.\n-        let has_extension = exe_path.bytes().contains(&b'.');\n+        let has_extension = exe_path.as_os_str_bytes().contains(&b'.');\n \n         // Search the directories given by `search_paths`.\n         let result = search_paths(parent_paths, child_paths, |mut path| {"}, {"sha": "31bb0ad25a656a2b57b9a675607abae02443de37", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9610dfe5a9a731ced1ea4923ecbd0c57fe367898/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "patch": "@@ -570,7 +570,7 @@ impl Wtf8 {\n     /// Since the byte slice is not checked for valid WTF-8, this functions is\n     /// marked unsafe.\n     #[inline]\n-    unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {\n+    pub unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {\n         mem::transmute(value)\n     }\n \n@@ -614,6 +614,12 @@ impl Wtf8 {\n         Wtf8CodePoints { bytes: self.bytes.iter() }\n     }\n \n+    /// Access raw bytes of WTF-8 data\n+    #[inline]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        &self.bytes\n+    }\n+\n     /// Tries to convert the string to UTF-8 and return a `&str` slice.\n     ///\n     /// Returns `None` if the string contains surrogates."}]}