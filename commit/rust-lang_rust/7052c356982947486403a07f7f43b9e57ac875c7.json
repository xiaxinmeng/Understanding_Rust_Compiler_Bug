{"sha": "7052c356982947486403a07f7f43b9e57ac875c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNTJjMzU2OTgyOTQ3NDg2NDAzYTA3ZjdmNDNiOWU1N2FjODc1Yzc=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-08-01T21:41:37Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-08-01T21:41:37Z"}, "message": "Make is_mutable use PlaceRef instead of it's fields", "tree": {"sha": "10dde30fe9cd931fe39fec4cfbedd16d56cd3fc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10dde30fe9cd931fe39fec4cfbedd16d56cd3fc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7052c356982947486403a07f7f43b9e57ac875c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7052c356982947486403a07f7f43b9e57ac875c7", "html_url": "https://github.com/rust-lang/rust/commit/7052c356982947486403a07f7f43b9e57ac875c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7052c356982947486403a07f7f43b9e57ac875c7/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "435236b8877cdb98c82eaebfb7887782277265c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/435236b8877cdb98c82eaebfb7887782277265c5", "html_url": "https://github.com/rust-lang/rust/commit/435236b8877cdb98c82eaebfb7887782277265c5"}], "stats": {"total": 133, "additions": 71, "deletions": 62}, "files": [{"sha": "e53e5734cc5f7683f204dda021d3e45855736e0e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 71, "deletions": 62, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7052c356982947486403a07f7f43b9e57ac875c7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7052c356982947486403a07f7f43b9e57ac875c7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7052c356982947486403a07f7f43b9e57ac875c7", "patch": "@@ -1942,7 +1942,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     BorrowKind::Mut { .. } => is_local_mutation_allowed,\n                     BorrowKind::Shared | BorrowKind::Shallow => unreachable!(),\n                 };\n-                match self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed) {\n+                match self.is_mutable(place.as_ref(), is_local_mutation_allowed) {\n                     Ok(root_place) => {\n                         self.add_used_mut(root_place, flow_state);\n                         return false;\n@@ -1954,7 +1954,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n             Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-                match self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed) {\n+                match self.is_mutable(place.as_ref(), is_local_mutation_allowed) {\n                     Ok(root_place) => {\n                         self.add_used_mut(root_place, flow_state);\n                         return false;\n@@ -1974,8 +1974,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             | Write(wk @ WriteKind::StorageDeadOrDrop)\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n             | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow)) => {\n-                if let (Err(_place_err), true) = (\n-                    self.is_mutable(&place.base, &place.projection, is_local_mutation_allowed),\n+                if let (Err(place_err), true) = (\n+                    self.is_mutable(place.as_ref(), is_local_mutation_allowed),\n                     self.errors_buffer.is_empty()\n                 ) {\n                     if self.infcx.tcx.migrate_borrowck() {\n@@ -1996,10 +1996,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.report_mutability_error(\n                             place,\n                             span,\n-                            PlaceRef {\n-                                base: _place_err.0,\n-                                projection: _place_err.1,\n-                            },\n+                            place_err,\n                             error_access,\n                             location,\n                         );\n@@ -2033,10 +2030,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             self.report_mutability_error(\n                 place,\n                 span,\n-                PlaceRef {\n-                    base: the_place_err.0,\n-                    projection: the_place_err.1,\n-                },\n+                the_place_err,\n                 error_access,\n                 location,\n             );\n@@ -2107,78 +2101,86 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n-        place_base: &'d PlaceBase<'tcx>,\n-        place_projection: &'d Option<Box<Projection<'tcx>>>,\n+        place: PlaceRef<'d, 'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<RootPlace<'d, 'tcx>, (&'d PlaceBase<'tcx>, &'d Option<Box<Projection<'tcx>>>)> {\n-        match (place_base, place_projection) {\n-            (PlaceBase::Local(local), None) => {\n+    ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: None,\n+            } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n-                            place_base,\n-                            place_projection,\n+                            place_base: place.base,\n+                            place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n                         }),\n                         LocalMutationIsAllowed::ExceptUpvars => Ok(RootPlace {\n-                            place_base,\n-                            place_projection,\n+                            place_base: place.base,\n+                            place_projection: place.projection,\n                             is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars,\n                         }),\n-                        LocalMutationIsAllowed::No => Err((place_base, place_projection)),\n+                        LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(RootPlace {\n-                        place_base,\n-                        place_projection,\n+                        place_base: place.base,\n+                        place_projection: place.projection,\n                         is_local_mutation_allowed,\n                     }),\n                 }\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            (PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(_),\n-                ..\n-            }), None) =>\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(_),\n+                    ..\n+                }),\n+                projection: None,\n+            } =>\n                 Ok(RootPlace {\n-                    place_base,\n-                    place_projection,\n+                    place_base: place.base,\n+                    place_projection: place.projection,\n                     is_local_mutation_allowed,\n                 }),\n-            (PlaceBase::Static(box Static {\n-                kind: StaticKind::Static(def_id),\n-                ..\n-            }), None) => {\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Static(def_id),\n+                    ..\n+                }),\n+                projection: None,\n+            } => {\n                 if !self.infcx.tcx.is_mutable_static(*def_id) {\n-                    Err((place_base, place_projection))\n+                    Err(place)\n                 } else {\n                     Ok(RootPlace {\n-                        place_base,\n-                        place_projection,\n+                        place_base: place.base,\n+                        place_projection: place.projection,\n                         is_local_mutation_allowed,\n                     })\n                 }\n             }\n-            (_, Some(ref proj)) => {\n+            PlaceRef {\n+                base: _,\n+                projection: Some(proj),\n+            } => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place_base, &proj.base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, &proj.base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::MutImmutable => Err((place_base, place_projection)),\n+                                    hir::MutImmutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(PlaceRef {\n-                                            base: &place_base,\n-                                            projection: &place_projection,\n-                                        }) {\n+                                        let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n                                             {\n@@ -2187,28 +2189,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             _ => LocalMutationIsAllowed::Yes,\n                                         };\n \n-                                        self.is_mutable(place_base, &proj.base, mode)\n+                                        self.is_mutable(PlaceRef {\n+                                            base: place.base,\n+                                            projection: &proj.base,\n+                                        }, mode)\n                                     }\n                                 }\n                             }\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err((place_base, place_projection)),\n+                                    hir::MutImmutable => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n                                         Ok(RootPlace {\n-                                            place_base,\n-                                            place_projection,\n+                                            place_base: place.base,\n+                                            place_projection: place.projection,\n                                             is_local_mutation_allowed,\n                                         })\n                                     }\n                                 }\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => {\n-                                self.is_mutable(place_base, &proj.base, is_local_mutation_allowed)\n+                                self.is_mutable(PlaceRef {\n+                                    base: place.base,\n+                                    projection: &proj.base,\n+                                }, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n@@ -2221,21 +2229,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = self.is_upvar_field_projection(PlaceRef {\n-                            base: &place_base,\n-                            projection: &place_projection,\n-                        });\n+                        let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n                                 \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                place={:?} {:?}\",\n-                                upvar, is_local_mutation_allowed, place_base, place_projection\n+                                place={:?}\",\n+                                upvar, is_local_mutation_allowed, place\n                             );\n                             match (upvar.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n                                 | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n-                                    Err((place_base, place_projection))\n+                                    Err(place)\n                                 }\n                                 (Mutability::Not, LocalMutationIsAllowed::Yes)\n                                 | (Mutability::Mut, _) => {\n@@ -2265,18 +2270,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     //     });\n                                     // }\n                                     // ```\n-                                    let _ = self.is_mutable(place_base,\n-                                                            &proj.base,\n-                                                            is_local_mutation_allowed)?;\n+                                    let _ = self.is_mutable(PlaceRef {\n+                                        base: place.base,\n+                                        projection: &proj.base,\n+                                    }, is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n-                                        place_base,\n-                                        place_projection,\n+                                        place_base: place.base,\n+                                        place_projection: place.projection,\n                                         is_local_mutation_allowed,\n                                     })\n                                 }\n                             }\n                         } else {\n-                            self.is_mutable(place_base, &proj.base, is_local_mutation_allowed)\n+                            self.is_mutable(PlaceRef {\n+                                base: place.base,\n+                                projection: &proj.base,\n+                            }, is_local_mutation_allowed)\n                         }\n                     }\n                 }"}]}