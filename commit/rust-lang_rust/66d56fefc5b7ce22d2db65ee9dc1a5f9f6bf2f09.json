{"sha": "66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZDU2ZmVmYzViN2NlMjJkMmRiNjVlZTlkYzFhNWY5ZjZiZjJmMDk=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2020-10-27T05:42:13Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2020-10-27T05:42:13Z"}, "message": "Add `invalid_paths` internal lint", "tree": {"sha": "b030677266fb104fce1f9240465000a6a6a75b13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b030677266fb104fce1f9240465000a6a6a75b13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "html_url": "https://github.com/rust-lang/rust/commit/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/comments", "author": null, "committer": null, "parents": [{"sha": "afbac8906e614a63ff5825710c3ebe45a3b5e01a", "url": "https://api.github.com/repos/rust-lang/rust/commits/afbac8906e614a63ff5825710c3ebe45a3b5e01a", "html_url": "https://github.com/rust-lang/rust/commit/afbac8906e614a63ff5825710c3ebe45a3b5e01a"}], "stats": {"total": 146, "additions": 146, "deletions": 0}, "files": [{"sha": "7c8cb90fe1c8e398dd6a9a8be471561411165e34", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "patch": "@@ -892,6 +892,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n         &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n         &utils::internal_lints::DEFAULT_LINT,\n+        &utils::internal_lints::INVALID_PATHS,\n         &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n         &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n@@ -919,6 +920,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n     store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n+    store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n     store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n     store.register_late_pass(|| box utils::author::Author);\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n@@ -1280,6 +1282,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n+        LintId::of(&utils::internal_lints::INVALID_PATHS),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n         LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),"}, {"sha": "6ca72d895c8dab74c2af2b4a89b1151c2e0dc1ae", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "patch": "@@ -1,3 +1,4 @@\n+use crate::consts::{constant_simple, Constant};\n use crate::utils::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, qpath_res, run_lints,\n     snippet, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n@@ -14,9 +15,11 @@ use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{Symbol, SymbolStr};\n+use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n \n@@ -229,6 +232,21 @@ declare_clippy_lint! {\n     \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks the paths module for invalid paths.\n+    ///\n+    /// **Why is this bad?**\n+    /// It indicates a bug in the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** None.\n+    pub INVALID_PATHS,\n+    internal,\n+    \"invalid path\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -761,3 +779,64 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n \n     None\n }\n+\n+// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n+// module.  That's all it does and all it needs to do.\n+pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n+    if path_to_res(cx, path).is_some() {\n+        return true;\n+    }\n+\n+    // Some implementations can't be found by `path_to_res`, particularly inherent\n+    // implementations of native types. Check lang items.\n+    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n+    let lang_items = cx.tcx.lang_items();\n+    for lang_item in lang_items.items() {\n+        if let Some(def_id) = lang_item {\n+            let lang_item_path = cx.get_def_path(*def_id);\n+            if path_syms.starts_with(&lang_item_path) {\n+                if let [item] = &path_syms[lang_item_path.len()..] {\n+                    for child in cx.tcx.item_children(*def_id) {\n+                        if child.ident.name == *item {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let local_def_id = &cx.tcx.parent_module(item.hir_id);\n+        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n+        if_chain! {\n+            if mod_name.as_str() == \"paths\";\n+            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n+            let ty = hir_ty_to_ty(cx.tcx, ty);\n+            if let ty::Array(el_ty, _) = &ty.kind();\n+            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n+            if el_ty.is_str();\n+            let body = cx.tcx.hir().body(body_id);\n+            let typeck_results = cx.tcx.typeck_body(body_id);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, &body.value);\n+            let path: Vec<&str> = path.iter().map(|x| {\n+                    if let Constant::Str(s) = x {\n+                        s.as_str()\n+                    } else {\n+                        // We checked the type of the constant above\n+                        unreachable!()\n+                    }\n+                }).collect();\n+            if !check_path(cx, &path[..]);\n+            then {\n+                span_lint(cx, CLIPPY_LINTS_INTERNAL, item.span, \"invalid path\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "a1ecca0961a8d57060f627d7342a6e3f70cb81e1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "patch": "@@ -268,6 +268,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n             krate: *krate,\n             index: CRATE_DEF_INDEX,\n         };\n+        let mut current_item = None;\n         let mut items = cx.tcx.item_children(krate);\n         let mut path_it = path.iter().skip(1).peekable();\n \n@@ -277,17 +278,41 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n                 None => return None,\n             };\n \n+            // `get_def_path` seems to generate these empty segments for extern blocks.\n+            // We can just ignore them.\n+            if segment.is_empty() {\n+                continue;\n+            }\n+\n             let result = SmallVec::<[_; 8]>::new();\n             for item in mem::replace(&mut items, cx.tcx.arena.alloc_slice(&result)).iter() {\n                 if item.ident.name.as_str() == *segment {\n                     if path_it.peek().is_none() {\n                         return Some(item.res);\n                     }\n \n+                    current_item = Some(item);\n                     items = cx.tcx.item_children(item.res.def_id());\n                     break;\n                 }\n             }\n+\n+            // The segment isn't a child_item.\n+            // Try to find it under an inherent impl.\n+            if_chain! {\n+                if path_it.peek().is_none();\n+                if let Some(current_item) = current_item;\n+                let item_def_id = current_item.res.def_id();\n+                if cx.tcx.def_kind(item_def_id) == DefKind::Struct;\n+                then {\n+                    // Bad `find_map` suggestion. See #4193.\n+                    #[allow(clippy::find_map)]\n+                    return cx.tcx.inherent_impls(item_def_id).iter()\n+                        .flat_map(|&impl_def_id| cx.tcx.item_children(impl_def_id))\n+                        .find(|item| item.ident.name.as_str() == *segment)\n+                        .map(|item| item.res);\n+                }\n+            }\n         }\n     } else {\n         None"}, {"sha": "01e28ae5e9d3581c0995e1b88abb0fd738494052", "filename": "tests/ui/invalid_paths.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/tests%2Fui%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/tests%2Fui%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_paths.rs?ref=66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "patch": "@@ -0,0 +1,23 @@\n+#![warn(clippy::internal)]\n+\n+mod paths {\n+    // Good path\n+    pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n+\n+    // Path to method on inherent impl of a primitive type\n+    pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n+\n+    // Path to method on inherent impl\n+    pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n+\n+    // Path with empty segment\n+    pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+\n+    // Path with bad crate\n+    pub const BAD_CRATE_PATH: [&str; 2] = [\"bad\", \"path\"];\n+\n+    // Path with bad module\n+    pub const BAD_MOD_PATH: [&str; 2] = [\"std\", \"xxx\"];\n+}\n+\n+fn main() {}"}, {"sha": "bd69d661b714fe8bd29e553588d2736e3eb22fc3", "filename": "tests/ui/invalid_paths.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/tests%2Fui%2Finvalid_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09/tests%2Fui%2Finvalid_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_paths.stderr?ref=66d56fefc5b7ce22d2db65ee9dc1a5f9f6bf2f09", "patch": "@@ -0,0 +1,16 @@\n+error: invalid path\n+  --> $DIR/invalid_paths.rs:17:5\n+   |\n+LL |     pub const BAD_CRATE_PATH: [&str; 2] = [\"bad\", \"path\"];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::clippy-lints-internal` implied by `-D warnings`\n+\n+error: invalid path\n+  --> $DIR/invalid_paths.rs:20:5\n+   |\n+LL |     pub const BAD_MOD_PATH: [&str; 2] = [\"std\", \"xxx\"];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}