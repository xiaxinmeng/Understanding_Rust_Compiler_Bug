{"sha": "96041ccd1054aa05c4ce7f6741df278fbf96c06b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MDQxY2NkMTA1NGFhMDVjNGNlN2Y2NzQxZGYyNzhmYmY5NmMwNmI=", "commit": {"author": {"name": "Victor Berger", "email": "victor.berger@m4x.org", "date": "2015-07-31T16:58:59Z"}, "committer": {"name": "Victor Berger", "email": "victor.berger@m4x.org", "date": "2015-07-31T17:10:14Z"}, "message": "More perseverant about indeterminate imports.\n\nMost errors generated by resolve might be caused by\nnot-yet-resolved glob imports. This changes the behavior of the\nresolve imports algorithms to not fail prematurally on first\nerror, but instead buffer intermediate errors and report them\nonly when stuck.\n\nFixes #18083", "tree": {"sha": "40afa5c92c697787e32dba13d629503f9a8bd304", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40afa5c92c697787e32dba13d629503f9a8bd304"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96041ccd1054aa05c4ce7f6741df278fbf96c06b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96041ccd1054aa05c4ce7f6741df278fbf96c06b", "html_url": "https://github.com/rust-lang/rust/commit/96041ccd1054aa05c4ce7f6741df278fbf96c06b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96041ccd1054aa05c4ce7f6741df278fbf96c06b/comments", "author": {"login": "elinorbgr", "id": 3009227, "node_id": "MDQ6VXNlcjMwMDkyMjc=", "avatar_url": "https://avatars.githubusercontent.com/u/3009227?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elinorbgr", "html_url": "https://github.com/elinorbgr", "followers_url": "https://api.github.com/users/elinorbgr/followers", "following_url": "https://api.github.com/users/elinorbgr/following{/other_user}", "gists_url": "https://api.github.com/users/elinorbgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/elinorbgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elinorbgr/subscriptions", "organizations_url": "https://api.github.com/users/elinorbgr/orgs", "repos_url": "https://api.github.com/users/elinorbgr/repos", "events_url": "https://api.github.com/users/elinorbgr/events{/privacy}", "received_events_url": "https://api.github.com/users/elinorbgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "elinorbgr", "id": 3009227, "node_id": "MDQ6VXNlcjMwMDkyMjc=", "avatar_url": "https://avatars.githubusercontent.com/u/3009227?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elinorbgr", "html_url": "https://github.com/elinorbgr", "followers_url": "https://api.github.com/users/elinorbgr/followers", "following_url": "https://api.github.com/users/elinorbgr/following{/other_user}", "gists_url": "https://api.github.com/users/elinorbgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/elinorbgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elinorbgr/subscriptions", "organizations_url": "https://api.github.com/users/elinorbgr/orgs", "repos_url": "https://api.github.com/users/elinorbgr/repos", "events_url": "https://api.github.com/users/elinorbgr/events{/privacy}", "received_events_url": "https://api.github.com/users/elinorbgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88c2914e56fe54f2179c37914a7d61c7fe4a2605", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c2914e56fe54f2179c37914a7d61c7fe4a2605", "html_url": "https://github.com/rust-lang/rust/commit/88c2914e56fe54f2179c37914a7d61c7fe4a2605"}], "stats": {"total": 94, "additions": 63, "deletions": 31}, "files": [{"sha": "45dbf08071d19fbacfb95a96f82a17901e028263", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96041ccd1054aa05c4ce7f6741df278fbf96c06b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96041ccd1054aa05c4ce7f6741df278fbf96c06b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=96041ccd1054aa05c4ce7f6741df278fbf96c06b", "patch": "@@ -20,6 +20,7 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(rc_weak)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -538,8 +539,8 @@ enum ResolveResult<T> {\n }\n \n impl<T> ResolveResult<T> {\n-    fn indeterminate(&self) -> bool {\n-        match *self { Indeterminate => true, _ => false }\n+    fn success(&self) -> bool {\n+        match *self { Success(_) => true, _ => false }\n     }\n }\n \n@@ -731,7 +732,12 @@ impl Module {\n     }\n \n     fn all_imports_resolved(&self) -> bool {\n-        self.imports.borrow().len() == self.resolved_import_count.get()\n+        if self.imports.borrow_state() == ::std::cell::BorrowState::Writing {\n+            // it is currently being resolved ! so nope\n+            false\n+        } else {\n+            self.imports.borrow().len() == self.resolved_import_count.get()\n+        }\n     }\n }\n "}, {"sha": "b368e16d6feac94f28c860eb951bafa7ed84a5fa", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/96041ccd1054aa05c4ce7f6741df278fbf96c06b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96041ccd1054aa05c4ce7f6741df278fbf96c06b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=96041ccd1054aa05c4ce7f6741df278fbf96c06b", "patch": "@@ -208,15 +208,28 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    i, self.resolver.unresolved_imports);\n \n             let module_root = self.resolver.graph_root.get_module();\n-            self.resolve_imports_for_module_subtree(module_root.clone());\n+            let errors = self.resolve_imports_for_module_subtree(module_root.clone());\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n                 break;\n             }\n \n             if self.resolver.unresolved_imports == prev_unresolved_imports {\n-                self.resolver.report_unresolved_imports(module_root);\n+                // resolving failed\n+                if errors.len() > 0 {\n+                    for (span, path, help) in errors {\n+                        resolve_error(self.resolver,\n+                                      span,\n+                                      ResolutionError::UnresolvedImport(Some((&*path, &*help))));\n+                    }\n+                } else {\n+                    // report unresolved imports only if no hard error was already reported\n+                    // to avoid generating multiple errors on the same import\n+                    // imports that are still undeterminate at this point are actually blocked\n+                    // by errored imports, so there is no point reporting them\n+                    self.resolver.report_unresolved_imports(module_root);\n+                }\n                 break;\n             }\n \n@@ -227,11 +240,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n-    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n+    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>)\n+                                          -> Vec<(Span, String, String)> {\n+        let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                module_to_string(&*module_));\n         let orig_module = replace(&mut self.resolver.current_module, module_.clone());\n-        self.resolve_imports_for_module(module_.clone());\n+        errors.extend(self.resolve_imports_for_module(module_.clone()));\n         self.resolver.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n@@ -241,53 +256,65 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     // Nothing to do.\n                 }\n                 Some(child_module) => {\n-                    self.resolve_imports_for_module_subtree(child_module);\n+                    errors.extend(self.resolve_imports_for_module_subtree(child_module));\n                 }\n             }\n         }\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            self.resolve_imports_for_module_subtree(child_module.clone());\n+            errors.extend(self.resolve_imports_for_module_subtree(child_module.clone()));\n         }\n+\n+        errors\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: Rc<Module>) {\n+    fn resolve_imports_for_module(&mut self, module: Rc<Module>) -> Vec<(Span, String, String)> {\n+        let mut errors = Vec::new();\n+\n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    {}\",\n                    module_to_string(&*module));\n-            return;\n+            return errors;\n         }\n \n-        let imports = module.imports.borrow();\n+        let mut imports = module.imports.borrow_mut();\n         let import_count = imports.len();\n-        while module.resolved_import_count.get() < import_count {\n+        let mut indeterminate_imports = Vec::new();\n+        while module.resolved_import_count.get() + indeterminate_imports.len() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = &(*imports)[import_index];\n             match self.resolve_import_for_module(module.clone(),\n-                                                 import_directive) {\n+                                                 &imports[import_index]) {\n                 ResolveResult::Failed(err) => {\n+                    let import_directive = &imports[import_index];\n                     let (span, help) = match err {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    resolve_error(self.resolver,\n-                                    span,\n-                                    ResolutionError::UnresolvedImport(\n-                                                Some((&*import_path_to_string(\n-                                                        &import_directive.module_path,\n-                                                        import_directive.subclass),\n-                                                      &*help)))\n-                                   );\n+                    errors.push((span,\n+                                 import_path_to_string(\n+                                    &import_directive.module_path,\n+                                    import_directive.subclass\n+                                 ),\n+                                 help))\n+                }\n+                ResolveResult::Indeterminate => {}\n+                ResolveResult::Success(()) => {\n+                    // count success\n+                    module.resolved_import_count\n+                          .set(module.resolved_import_count.get() + 1);\n+                    continue;\n                 }\n-                ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n-                ResolveResult::Success(()) => () // Good. Continue.\n             }\n+            // This resolution was not successful, keep it for later\n+            indeterminate_imports.push(imports.swap_remove(import_index));\n \n-            module.resolved_import_count\n-                  .set(module.resolved_import_count.get() + 1);\n         }\n+\n+        imports.extend(indeterminate_imports);\n+\n+        errors\n     }\n \n     /// Attempts to resolve the given import. The return value indicates\n@@ -367,11 +394,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         // Decrement the count of unresolved globs if necessary. But only if\n-        // the resolution result is indeterminate -- otherwise we'll stop\n-        // processing imports here. (See the loop in\n-        // resolve_imports_for_module).\n+        // the resolution result is a success -- other cases will\n+        // be handled by the main loop.\n \n-        if !resolution_result.indeterminate() {\n+        if resolution_result.success() {\n             match import_directive.subclass {\n                 GlobImport => {\n                     assert!(module_.glob_count.get() >= 1);"}]}