{"sha": "19c1a47713bfba32ded7d8c32ceb36423fe44e35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzFhNDc3MTNiZmJhMzJkZWQ3ZDhjMzJjZWIzNjQyM2ZlNDRlMzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-07T18:25:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-15T21:12:41Z"}, "message": "remove TypeOrigin and use ObligationCause instead\n\nIn general having all these different structs for \"origins\" is not\ngreat, since equating types can cause obligations and vice-versa.  I\nthink we should gradually collapse these things. We almost certainly\nalso need to invest a big more energy into the `error_reporting` code to\nrationalize it: this PR does kind of the minimal effort in that\ndirection.", "tree": {"sha": "59f094284f83e7b55e3e968c38b0d3ea3c8ef8bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f094284f83e7b55e3e968c38b0d3ea3c8ef8bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c1a47713bfba32ded7d8c32ceb36423fe44e35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c1a47713bfba32ded7d8c32ceb36423fe44e35", "html_url": "https://github.com/rust-lang/rust/commit/19c1a47713bfba32ded7d8c32ceb36423fe44e35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c1a47713bfba32ded7d8c32ceb36423fe44e35/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43006fcea0066a935b657fff9ccef56983cbf56c", "url": "https://api.github.com/repos/rust-lang/rust/commits/43006fcea0066a935b657fff9ccef56983cbf56c", "html_url": "https://github.com/rust-lang/rust/commit/43006fcea0066a935b657fff9ccef56983cbf56c"}], "stats": {"total": 743, "additions": 389, "deletions": 354}, "files": [{"sha": "5d33d6e6d2e71ee443d443188eea09c08995aa99", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -274,7 +274,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n-            span: self.trace.origin.span(),\n+            span: self.trace.cause.span,\n             for_vid: for_vid,\n             make_region_vars: make_region_vars,\n             cycle_detected: false"}, {"sha": "58caac4034e34a1144e70ec4e06c08e645c5cb75", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -80,8 +80,9 @@ use hir::print as pprust;\n use lint;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use infer::{self, TypeOrigin};\n+use infer;\n use middle::region;\n+use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n@@ -524,10 +525,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn note_error_origin(&self,\n                          err: &mut DiagnosticBuilder<'tcx>,\n-                         origin: &TypeOrigin)\n+                         cause: &ObligationCause<'tcx>)\n     {\n-        match origin {\n-            &TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n+        match cause.code {\n+            ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n                 hir::MatchSource::IfLetDesugar {..} => {\n                     err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n                 }\n@@ -541,7 +542,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn note_type_err(&self,\n                          diag: &mut DiagnosticBuilder<'tcx>,\n-                         origin: TypeOrigin,\n+                         cause: &ObligationCause<'tcx>,\n                          secondary_span: Option<(Span, String)>,\n                          values: Option<ValuePairs<'tcx>>,\n                          terr: &TypeError<'tcx>)\n@@ -558,7 +559,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let span = origin.span();\n+        let span = cause.span;\n \n         if let Some((expected, found)) = expected_found {\n             let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n@@ -588,7 +589,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             diag.span_label(sp, &msg);\n         }\n \n-        self.note_error_origin(diag, &origin);\n+        self.note_error_origin(diag, &cause);\n         self.check_and_note_conflicting_crates(diag, terr, span);\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n     }\n@@ -598,17 +599,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                          terr: &TypeError<'tcx>)\n                                          -> DiagnosticBuilder<'tcx>\n     {\n-        let span = trace.origin.span();\n-        let failure_str = trace.origin.as_failure_str();\n-        let mut diag = match trace.origin {\n-            TypeOrigin::IfExpressionWithNoElse(_) => {\n+        let span = trace.cause.span;\n+        let failure_str = trace.cause.as_failure_str();\n+        let mut diag = match trace.cause.code {\n+            ObligationCauseCode::IfExpressionWithNoElse => {\n                 struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n             },\n             _ => {\n                 struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str)\n             },\n         };\n-        self.note_type_err(&mut diag, trace.origin, None, Some(trace.values), terr);\n+        self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr);\n         diag\n     }\n \n@@ -1695,18 +1696,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n                     // FIXME: do we want a \"the\" here?\n                     err.span_note(\n-                        trace.origin.span(),\n+                        trace.cause.span,\n                         &format!(\"...so that {} (expected {}, found {})\",\n-                                 trace.origin.as_requirement_str(), expected, found));\n+                                 trace.cause.as_requirement_str(), expected, found));\n                 } else {\n                     // FIXME: this really should be handled at some earlier stage. Our\n                     // handling of region checking when type errors are present is\n                     // *terrible*.\n \n                     err.span_note(\n-                        trace.origin.span(),\n+                        trace.cause.span,\n                         &format!(\"...so that {}\",\n-                                 trace.origin.as_requirement_str()));\n+                                 trace.cause.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n@@ -1961,3 +1962,45 @@ fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n                     span: syntax_pos::DUMMY_SP,\n                     name: name }\n }\n+\n+impl<'tcx> ObligationCause<'tcx> {\n+    fn as_failure_str(&self) -> &'static str {\n+        use traits::ObligationCauseCode::*;\n+        match self.code {\n+            CompareImplMethodObligation { .. } => \"method not compatible with trait\",\n+            MatchExpressionArm { source, .. } => match source {\n+                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n+                _ => \"match arms have incompatible types\",\n+            },\n+            IfExpression => \"if and else have incompatible types\",\n+            IfExpressionWithNoElse => \"if may be missing an else clause\",\n+            EquatePredicate => \"equality predicate not satisfied\",\n+            MainFunctionType => \"main function has wrong type\",\n+            StartFunctionType => \"start function has wrong type\",\n+            IntrinsicType => \"intrinsic has wrong type\",\n+            MethodReceiver => \"mismatched method receiver\",\n+            _ => \"mismatched types\",\n+        }\n+    }\n+\n+    fn as_requirement_str(&self) -> &'static str {\n+        use traits::ObligationCauseCode::*;\n+        match self.code {\n+            CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n+            ExprAssignable => \"expression is assignable\",\n+            MatchExpressionArm { source, .. } => match source {\n+                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have compatible types\",\n+                _ => \"match arms have compatible types\",\n+            },\n+            IfExpression => \"if and else have compatible types\",\n+            IfExpressionWithNoElse => \"if missing an else returns ()\",\n+            EquatePredicate => \"equality where clause is satisfied\",\n+            MainFunctionType => \"`main` function has the correct type\",\n+            StartFunctionType => \"`start` function has the correct type\",\n+            IntrinsicType => \"intrinsic has the correct type\",\n+            MethodReceiver => \"method receiver has the correct type\",\n+            _ => \"types are compatible\",\n+        }\n+    }\n+}\n+"}, {"sha": "08e522f5fd6ee4a39599f905b1f2874c74fa6575", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n \n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n@@ -230,7 +230,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n             let (a_with_fresh, a_map) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, a);\n@@ -247,7 +247,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n@@ -325,10 +325,10 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Instantiate each bound region with a fresh region variable.\n             let (a_with_fresh, a_map) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.origin.span(), HigherRankedType, a);\n+                    self.trace.cause.span, HigherRankedType, a);\n             let (b_with_fresh, b_map) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.origin.span(), HigherRankedType, b);\n+                    self.trace.cause.span, HigherRankedType, b);\n             let a_vars = var_ids(self, &a_map);\n             let b_vars = var_ids(self, &b_map);\n \n@@ -341,7 +341,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.origin.span();\n+            let span = self.trace.cause.span;\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n@@ -463,7 +463,7 @@ fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n            ty::ReVar(r) => { r }\n            _ => {\n                span_bug!(\n-                   fields.trace.origin.span(),\n+                   fields.trace.cause.span,\n                    \"found non-region-vid: {:?}\",\n                    r);\n            }"}, {"sha": "6ae104d79122bce0aab12d0a22d68c0917ac56fa", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 149, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -32,7 +32,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::{self, PredicateObligations, Reveal};\n+use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n@@ -173,89 +173,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n /// region that each late-bound region was replaced with.\n pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n-/// Why did we require that the two types be related?\n-///\n-/// See `error_reporting.rs` for more details\n-#[derive(Clone, Copy, Debug)]\n-pub enum TypeOrigin {\n-    // Not yet categorized in a better way\n-    Misc(Span),\n-\n-    // Checking that method of impl is compatible with trait\n-    MethodCompatCheck(Span),\n-\n-    // Checking that this expression can be assigned where it needs to be\n-    ExprAssignable(Span),\n-\n-    // Relating trait type parameters to those found in impl etc\n-    RelateOutputImplTypes(Span),\n-\n-    // Computing common supertype in the arms of a match expression\n-    MatchExpressionArm(Span, Span, hir::MatchSource),\n-\n-    // Computing common supertype in an if expression\n-    IfExpression(Span),\n-\n-    // Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse(Span),\n-\n-    // `where a == b`\n-    EquatePredicate(Span),\n-\n-    // `main` has wrong type\n-    MainFunctionType(Span),\n-\n-    // `start` has wrong type\n-    StartFunctionType(Span),\n-\n-    // intrinsic has wrong type\n-    IntrinsicType(Span),\n-\n-    // method receiver\n-    MethodReceiver(Span),\n-}\n-\n-impl TypeOrigin {\n-    fn as_failure_str(&self) -> &'static str {\n-        match self {\n-            &TypeOrigin::Misc(_) |\n-            &TypeOrigin::RelateOutputImplTypes(_) |\n-            &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n-            &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n-            &TypeOrigin::MatchExpressionArm(.., source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n-                _ => \"match arms have incompatible types\",\n-            },\n-            &TypeOrigin::IfExpression(_) => \"if and else have incompatible types\",\n-            &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n-            &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n-            &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n-            &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n-            &TypeOrigin::IntrinsicType(_) => \"intrinsic has wrong type\",\n-            &TypeOrigin::MethodReceiver(_) => \"mismatched method receiver\",\n-        }\n-    }\n-\n-    fn as_requirement_str(&self) -> &'static str {\n-        match self {\n-            &TypeOrigin::Misc(_) => \"types are compatible\",\n-            &TypeOrigin::MethodCompatCheck(_) => \"method type is compatible with trait\",\n-            &TypeOrigin::ExprAssignable(_) => \"expression is assignable\",\n-            &TypeOrigin::RelateOutputImplTypes(_) => {\n-                \"trait type parameters matches those specified on the impl\"\n-            }\n-            &TypeOrigin::MatchExpressionArm(..) => \"match arms have compatible types\",\n-            &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n-            &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n-            &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n-            &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n-            &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n-            &TypeOrigin::IntrinsicType(_) => \"intrinsic has the correct type\",\n-            &TypeOrigin::MethodReceiver(_) => \"method receiver has the correct type\",\n-        }\n-    }\n-}\n-\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n@@ -270,7 +187,7 @@ pub enum ValuePairs<'tcx> {\n /// See `error_reporting.rs` for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n-    origin: TypeOrigin,\n+    cause: ObligationCause<'tcx>,\n     values: ValuePairs<'tcx>,\n }\n \n@@ -1006,14 +923,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn sub_types(&self,\n                      a_is_expected: bool,\n-                     origin: TypeOrigin,\n+                     cause: &ObligationCause<'tcx>,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n+            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n             self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n@@ -1024,7 +941,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          -> UnitResult<'tcx>\n     {\n         self.probe(|_| {\n-            let origin = TypeOrigin::Misc(syntax_pos::DUMMY_SP);\n+            let origin = &ObligationCause::dummy();\n             let trace = TypeTrace::types(origin, true, a, b);\n             self.sub(true, trace, &a, &b).map(|InferOk { obligations, .. }| {\n                 // FIXME(#32730) propagate obligations\n@@ -1035,28 +952,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n-                    origin: TypeOrigin,\n+                    cause: &ObligationCause<'tcx>,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n+            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n             self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n     pub fn eq_trait_refs(&self,\n                           a_is_expected: bool,\n-                          origin: TypeOrigin,\n+                          cause: &ObligationCause<'tcx>,\n                           a: ty::TraitRef<'tcx>,\n                           b: ty::TraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n-                origin: origin,\n+                cause: cause.clone(),\n                 values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n@@ -1065,30 +982,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn eq_impl_headers(&self,\n                            a_is_expected: bool,\n-                           origin: TypeOrigin,\n+                           cause: &ObligationCause<'tcx>,\n                            a: &ty::ImplHeader<'tcx>,\n                            b: &ty::ImplHeader<'tcx>)\n                            -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n         match (a.trait_ref, b.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, origin, a_ref, b_ref),\n-            (None, None) => self.eq_types(a_is_expected, origin, a.self_ty, b.self_ty),\n+            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, cause, a_ref, b_ref),\n+            (None, None) => self.eq_types(a_is_expected, cause, a.self_ty, b.self_ty),\n             _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n         }\n     }\n \n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n-                               origin: TypeOrigin,\n+                               cause: ObligationCause<'tcx>,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_poly_trait_refs({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n-                origin: origin,\n+                cause: cause,\n                 values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n@@ -1104,16 +1021,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn equality_predicate(&self,\n-                              span: Span,\n+                              cause: &ObligationCause<'tcx>,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = TypeOrigin::EquatePredicate(span);\n-            let eqty_ok = self.eq_types(false, origin, a, b)?;\n-            self.leak_check(false, span, &skol_map, snapshot)?;\n+            let cause_span = cause.span;\n+            let eqty_ok = self.eq_types(false, cause, a, b)?;\n+            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(eqty_ok.unit())\n         })\n@@ -1443,26 +1360,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn report_mismatched_types(&self,\n-                                   origin: TypeOrigin,\n+                                   cause: &ObligationCause<'tcx>,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n                                    err: TypeError<'tcx>) {\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: Types(ExpectedFound {\n-                expected: expected,\n-                found: actual\n-            })\n-        };\n+        let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err).emit();\n     }\n \n     pub fn report_conflicting_default_types(&self,\n                                             span: Span,\n+                                            body_id: ast::NodeId,\n                                             expected: type_variable::Default<'tcx>,\n                                             actual: type_variable::Default<'tcx>) {\n         let trace = TypeTrace {\n-            origin: TypeOrigin::Misc(span),\n+            cause: ObligationCause::misc(span, body_id),\n             values: Types(ExpectedFound {\n                 expected: expected.ty,\n                 found: actual.ty\n@@ -1507,15 +1419,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n     /// details.\n     pub fn match_poly_projection_predicate(&self,\n-                                           origin: TypeOrigin,\n+                                           cause: ObligationCause<'tcx>,\n                                            match_a: ty::PolyProjectionPredicate<'tcx>,\n                                            match_b: ty::TraitRef<'tcx>)\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n     {\n-        let span = origin.span();\n+        let span = cause.span;\n         let match_trait_ref = match_a.skip_binder().projection_ty.trait_ref;\n         let trace = TypeTrace {\n-            origin: origin,\n+            cause: cause,\n             values: TraitRefs(ExpectedFound::new(true, match_trait_ref, match_b))\n         };\n \n@@ -1664,23 +1576,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n-        self.origin.span()\n+        self.cause.span\n     }\n \n-    pub fn types(origin: TypeOrigin,\n+    pub fn types(cause: &ObligationCause<'tcx>,\n                  a_is_expected: bool,\n                  a: Ty<'tcx>,\n                  b: Ty<'tcx>)\n                  -> TypeTrace<'tcx> {\n         TypeTrace {\n-            origin: origin,\n+            cause: cause.clone(),\n             values: Types(ExpectedFound::new(a_is_expected, a, b))\n         }\n     }\n \n     pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n-            origin: TypeOrigin::Misc(syntax_pos::DUMMY_SP),\n+            cause: ObligationCause::dummy(),\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n@@ -1691,26 +1603,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n \n impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeTrace({:?})\", self.origin)\n-    }\n-}\n-\n-impl TypeOrigin {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            TypeOrigin::MethodCompatCheck(span) => span,\n-            TypeOrigin::ExprAssignable(span) => span,\n-            TypeOrigin::Misc(span) => span,\n-            TypeOrigin::RelateOutputImplTypes(span) => span,\n-            TypeOrigin::MatchExpressionArm(match_span, ..) => match_span,\n-            TypeOrigin::IfExpression(span) => span,\n-            TypeOrigin::IfExpressionWithNoElse(span) => span,\n-            TypeOrigin::EquatePredicate(span) => span,\n-            TypeOrigin::MainFunctionType(span) => span,\n-            TypeOrigin::StartFunctionType(span) => span,\n-            TypeOrigin::IntrinsicType(span) => span,\n-            TypeOrigin::MethodReceiver(span) => span,\n-        }\n+        write!(f, \"TypeTrace({:?})\", self.cause)\n     }\n }\n \n@@ -1787,16 +1680,6 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for TypeOrigin {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        self.clone()\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n@@ -1824,12 +1707,12 @@ impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         TypeTrace {\n-            origin: self.origin.fold_with(folder),\n+            cause: self.cause.fold_with(folder),\n             values: self.values.fold_with(folder)\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.origin.visit_with(visitor) || self.values.visit_with(visitor)\n+        self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n     }\n }"}, {"sha": "5664777772f7ee770be044e9ec9bdc26e7f4d7c0", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -111,6 +111,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n                self.tag(), a, b, self.fields.cause);\n+\n         // FIXME -- we have more fine-grained information available\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages."}, {"sha": "2e06e83f8489ca4ded13fd450d139b05dd100ebd", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -14,8 +14,8 @@ use super::{SelectionContext, Obligation, ObligationCause};\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n-use infer::{InferCtxt, InferOk, TypeOrigin};\n-use syntax_pos::DUMMY_SP;\n+\n+use infer::{InferCtxt, InferOk};\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n@@ -55,8 +55,10 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    match selcx.infcx().eq_impl_headers(true, TypeOrigin::Misc(DUMMY_SP), &a_impl_header,\n-                                                                          &b_impl_header) {\n+    match selcx.infcx().eq_impl_headers(true,\n+                                        &ObligationCause::dummy(),\n+                                        &a_impl_header,\n+                                        &b_impl_header) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty());"}, {"sha": "e0a397ad28fbd28f6946efa405907bef712c11df", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -26,7 +26,7 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{self, InferCtxt};\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n@@ -100,7 +100,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.probe(|_| {\n-            let origin = TypeOrigin::Misc(obligation.cause.span);\n             let err_buf;\n             let mut err = &error.err;\n             let mut values = None;\n@@ -121,9 +120,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     obligation.cause.clone(),\n                     0\n                 );\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 if let Err(error) = self.eq_types(\n-                    false, origin,\n+                    false, &obligation.cause,\n                     data.ty, normalized.value\n                 ) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n@@ -136,10 +134,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             let mut diag = struct_span_err!(\n-                self.tcx.sess, origin.span(), E0271,\n+                self.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`\", predicate\n             );\n-            self.note_type_err(&mut diag, origin, None, values, err);\n+            self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n             self.note_obligation_cause(&mut diag, obligation);\n             diag.emit();\n         });\n@@ -529,7 +527,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::Equate(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.equality_predicate(span,\n+                            let err = self.equality_predicate(&obligation.cause,\n                                                               &predicate).err().unwrap();\n                             struct_span_err!(self.tcx.sess, span, E0278,\n                                 \"the requirement `{}` is not satisfied (`{}`)\",\n@@ -851,7 +849,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let tcx = self.tcx;\n         match *cause_code {\n-            ObligationCauseCode::MiscObligation => { }\n+            ObligationCauseCode::ExprAssignable |\n+            ObligationCauseCode::MatchExpressionArm { .. } |\n+            ObligationCauseCode::IfExpression |\n+            ObligationCauseCode::IfExpressionWithNoElse |\n+            ObligationCauseCode::EquatePredicate |\n+            ObligationCauseCode::MainFunctionType |\n+            ObligationCauseCode::StartFunctionType |\n+            ObligationCauseCode::IntrinsicType |\n+            ObligationCauseCode::MethodReceiver |\n+            ObligationCauseCode::MiscObligation => {\n+            }\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "535156e61e94f18e8311aea924af93b70ca5f1d2", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -519,7 +519,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n+            match selcx.infcx().equality_predicate(&obligation.cause, binder) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());"}, {"sha": "a5fdaed9712573d51c48879ceae8b0780864ce05", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -15,6 +15,7 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use hir;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n@@ -148,6 +149,35 @@ pub enum ObligationCauseCode<'tcx> {\n         trait_item_def_id: DefId,\n         lint_id: Option<ast::NodeId>,\n     },\n+\n+    // Checking that this expression can be assigned where it needs to be\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable,\n+\n+    // Computing common supertype in the arms of a match expression\n+    MatchExpressionArm { arm_span: Span,\n+                         source: hir::MatchSource },\n+\n+    // Computing common supertype in an if expression\n+    IfExpression,\n+\n+    // Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse,\n+\n+    // `where a == b`\n+    EquatePredicate,\n+\n+    // `main` has wrong type\n+    MainFunctionType,\n+\n+    // `start` has wrong type\n+    StartFunctionType,\n+\n+    // intrinsic has wrong type\n+    IntrinsicType,\n+\n+    // method receiver\n+    MethodReceiver,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "6ab7a1fbfb8a21a906f5f49271a00744e31a4f79", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -24,7 +24,7 @@ use super::VtableImplData;\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::{InferOk, TypeOrigin};\n+use infer::InferOk;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::parse::token;\n use syntax::ast;\n@@ -209,8 +209,7 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligations);\n \n     let infcx = selcx.infcx();\n-    let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    match infcx.eq_types(true, origin, normalized_ty, obligation.predicate.ty) {\n+    match infcx.eq_types(true, &obligation.cause, normalized_ty, obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, .. }) => {\n             // FIXME(#32730) once obligations are generated in inference, drop this assertion\n             assert!(inferred_obligations.is_empty());\n@@ -840,13 +839,12 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n \n                 let is_match = same_name && infcx.probe(|_| {\n-                    let origin = TypeOrigin::Misc(obligation.cause.span);\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n                     let obligation_poly_trait_ref =\n                         obligation_trait_ref.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n-                                              origin,\n+                                              obligation.cause.clone(),\n                                               data_poly_trait_ref,\n                                               obligation_poly_trait_ref)\n                         // FIXME(#32730) once obligations are propagated from unification in\n@@ -1153,12 +1151,11 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n \n         // select those with a relevant trait-ref\n         let mut env_predicates = env_predicates.filter(|data| {\n-            let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let data_poly_trait_ref = data.to_poly_trait_ref();\n             let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n             selcx.infcx().probe(|_| {\n                 selcx.infcx().sub_poly_trait_refs(false,\n-                                                  origin,\n+                                                  obligation.cause.clone(),\n                                                   data_poly_trait_ref,\n                                                   obligation_poly_trait_ref).is_ok()\n             })\n@@ -1265,9 +1262,9 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     -> Progress<'tcx>\n {\n     let infcx = selcx.infcx();\n-    let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n+    let cause = obligation.cause.clone();\n     let trait_ref = obligation.predicate.trait_ref;\n-    match infcx.match_poly_projection_predicate(origin, poly_projection, trait_ref) {\n+    match infcx.match_poly_projection_predicate(cause, poly_projection, trait_ref) {\n         Ok(InferOk { value: ty_match, obligations }) => {\n             // FIXME(#32730) once obligations are generated in inference, drop this assertion\n             assert!(obligations.is_empty());"}, {"sha": "6c75fb6a246e012cc4c34ff4ec96ebb7c5aaaa7b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -35,7 +35,7 @@ use super::util;\n \n use hir::def_id::DefId;\n use infer;\n-use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeFreshener};\n use ty::subst::{Kind, Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n@@ -521,7 +521,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n-                match self.infcx.equality_predicate(obligation.cause.span, p) {\n+                match self.infcx.equality_predicate(&obligation.cause, p) {\n                     Ok(InferOk { obligations, .. }) => {\n                         self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n@@ -1247,9 +1247,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n+        let cause = obligation.cause.clone();\n         match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n+                                             cause,\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n             Ok(InferOk { obligations, .. }) => {\n@@ -2439,16 +2439,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// selection of the impl. Therefore, if there is a mismatch, we\n     /// report an error to the user.\n     fn confirm_poly_trait_refs(&mut self,\n-                               obligation_cause: ObligationCause,\n+                               obligation_cause: ObligationCause<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation_cause.span);\n-\n         let obligation_trait_ref = obligation_trait_ref.clone();\n         self.infcx.sub_poly_trait_refs(false,\n-                                       origin,\n+                                       obligation_cause.clone(),\n                                        expected_trait_ref.clone(),\n                                        obligation_trait_ref.clone())\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n@@ -2482,9 +2480,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     builtin_bounds: data_b.builtin_bounds,\n                     projection_bounds: data_a.projection_bounds.clone(),\n                 });\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, origin, new_trait, target)\n+                    self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2553,9 +2550,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, origin, a, b)\n+                    self.infcx.sub_types(false, &obligation.cause, a, b)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -2617,9 +2613,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n-                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, origin, new_struct, target)\n+                    self.infcx.sub_types(false, &obligation.cause, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2705,10 +2700,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                impl_trait_ref,\n                skol_obligation_trait_ref);\n \n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         let InferOk { obligations, .. } =\n             self.infcx.eq_trait_refs(false,\n-                                     origin,\n+                                     &obligation.cause,\n                                      impl_trait_ref.value.clone(),\n                                      skol_obligation_trait_ref)\n             .map_err(|e| {\n@@ -2780,9 +2774,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                obligation,\n                poly_trait_ref);\n \n-        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         self.infcx.sub_poly_trait_refs(false,\n-                                       origin,\n+                                       obligation.cause.clone(),\n                                        poly_trait_ref,\n                                        obligation.predicate.to_poly_trait_ref())\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))"}, {"sha": "870494363c85a8371385495c39c34d487fee04ec", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -22,7 +22,7 @@ use super::util::impl_trait_ref_and_oblig;\n \n use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk, TypeOrigin};\n+use infer::{InferCtxt, InferOk};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n@@ -223,8 +223,10 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                                    target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    match infcx.eq_trait_refs(true, TypeOrigin::Misc(DUMMY_SP), source_trait_ref,\n-                                                                target_trait_ref) {\n+    match infcx.eq_trait_refs(true,\n+                              &ObligationCause::dummy(),\n+                              source_trait_ref,\n+                              target_trait_ref) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty())"}, {"sha": "d03ba5b0a31f1314e979b1c824638c9a1430538f", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -213,6 +213,34 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                     lint_id: lint_id,\n                 })\n             }\n+            super::ExprAssignable => {\n+                Some(super::ExprAssignable)\n+            }\n+            super::MatchExpressionArm { arm_span, source } => {\n+                Some(super::MatchExpressionArm { arm_span: arm_span,\n+                                                 source: source })\n+            }\n+            super::IfExpression => {\n+                Some(super::IfExpression)\n+            }\n+            super::IfExpressionWithNoElse => {\n+                Some(super::IfExpressionWithNoElse)\n+            }\n+            super::EquatePredicate => {\n+                Some(super::EquatePredicate)\n+            }\n+            super::MainFunctionType => {\n+                Some(super::MainFunctionType)\n+            }\n+            super::StartFunctionType => {\n+                Some(super::StartFunctionType)\n+            }\n+            super::IntrinsicType => {\n+                Some(super::IntrinsicType)\n+            }\n+            super::MethodReceiver => {\n+                Some(super::MethodReceiver)\n+            }\n         }\n     }\n }\n@@ -461,6 +489,15 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n+            super::ExprAssignable |\n+            super::MatchExpressionArm { arm_span: _, source: _ } |\n+            super::IfExpression |\n+            super::IfExpressionWithNoElse |\n+            super::EquatePredicate |\n+            super::MainFunctionType |\n+            super::StartFunctionType |\n+            super::IntrinsicType |\n+            super::MethodReceiver |\n             super::MiscObligation |\n             super::SliceOrArrayElem |\n             super::TupleElem |\n@@ -497,6 +534,15 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n+            super::ExprAssignable |\n+            super::MatchExpressionArm { arm_span: _, source: _ } |\n+            super::IfExpression |\n+            super::IfExpressionWithNoElse |\n+            super::EquatePredicate |\n+            super::MainFunctionType |\n+            super::StartFunctionType |\n+            super::IntrinsicType |\n+            super::MethodReceiver |\n             super::MiscObligation |\n             super::SliceOrArrayElem |\n             super::TupleElem |"}, {"sha": "782c74c8c78c75b17c294458f33ae2a9caace1e9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -21,9 +21,9 @@ use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n-use rustc::traits::Reveal;\n+use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n+use rustc::infer::{self, InferOk, InferResult};\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n@@ -36,7 +36,6 @@ use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n@@ -245,7 +244,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx.sub_types(true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n+        match self.infcx.sub_types(true, &ObligationCause::dummy(), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }"}, {"sha": "78912f607faa32df71d015985782a742930949a9", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -306,30 +306,36 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n-    last_span: Span\n+    last_span: Span,\n+    body_id: ast::NodeId,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, body_id: ast::NodeId) -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n-            last_span: DUMMY_SP\n+            last_span: DUMMY_SP,\n+            body_id: body_id,\n         }\n     }\n \n+    fn misc(&self, span: Span) -> traits::ObligationCause<'tcx> {\n+        traits::ObligationCause::misc(span, self.body_id)\n+    }\n+\n     fn sub_types(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n                  -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.sub_types(false, infer::TypeOrigin::Misc(span), sup, sub)\n+        self.infcx.sub_types(false, &self.misc(span), sup, sub)\n             // FIXME(#32730) propagate obligations\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn eq_types(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.eq_types(false, infer::TypeOrigin::Misc(span), a, b)\n+        self.infcx.eq_types(false, &self.misc(span), a, b)\n             // FIXME(#32730) propagate obligations\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n@@ -715,7 +721,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n         tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable).enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx);\n+            let mut checker = TypeChecker::new(&infcx, src.item_id());\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);\n                 verifier.visit_mir(mir);"}, {"sha": "d57a27ddc7610de316ea74ca3bfcd06d3b7ea750", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -11,7 +11,8 @@\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk};\n+use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n use util::nodemap::FxHashMap;\n@@ -450,14 +451,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => false\n             };\n \n-            let origin = if is_if_let_fallback {\n-                TypeOrigin::IfExpressionWithNoElse(expr.span)\n+            let cause = if is_if_let_fallback {\n+                self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse)\n             } else {\n-                TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src)\n+                self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                    arm_span: arm.body.span,\n+                    source: match_src\n+                })\n             };\n \n             let result = if is_if_let_fallback {\n-                self.eq_types(true, origin, arm_ty, result_ty)\n+                self.eq_types(true, &cause, arm_ty, result_ty)\n                     .map(|InferOk { obligations, .. }| {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n@@ -468,7 +472,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.try_coerce(&arm.body, arm_ty, coerce_first)\n             } else {\n                 let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body, arm_ty)\n+                self.try_find_coercion_lub(&cause, prev_arms, result_ty, &arm.body, arm_ty)\n             };\n \n             result_ty = match result {\n@@ -479,7 +483,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         (result_ty, arm_ty)\n                     };\n-                    self.report_mismatched_types(origin, expected, found, e);\n+                    self.report_mismatched_types(&cause, expected, found, e);\n                     self.tcx.types.err\n                 }\n             };"}, {"sha": "7a7ea760c03838526a3c0addd87f068bc958d01e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -63,8 +63,8 @@\n use check::FnCtxt;\n \n use rustc::hir;\n-use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n-use rustc::traits::{self, ObligationCause};\n+use rustc::infer::{Coercion, InferOk, TypeTrace};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n@@ -78,7 +78,7 @@ use std::ops::Deref;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    origin: TypeOrigin,\n+    cause: ObligationCause<'tcx>,\n     use_lub: bool,\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n@@ -104,18 +104,18 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n }\n \n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, origin: TypeOrigin) -> Self {\n+    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n         Coerce {\n             fcx: fcx,\n-            origin: origin,\n+            cause: cause,\n             use_lub: false,\n             unsizing_obligations: RefCell::new(vec![]),\n         }\n     }\n \n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(self.origin, false, a, b);\n+            let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n                 self.lub(false, trace, &a, &b)\n                     .map(|InferOk { value, obligations }| {\n@@ -238,7 +238,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             _ => return self.unify_and_identity(a, b),\n         };\n \n-        let span = self.origin.span();\n+        let span = self.cause.span;\n \n         let mut first_error = None;\n         let mut r_borrow_var = None;\n@@ -430,7 +430,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n \n-                let coercion = Coercion(self.origin.span());\n+                let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n                 (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n             }\n@@ -449,7 +449,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let mut leftover_predicates = vec![];\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n-        let cause = ObligationCause::misc(self.origin.span(), self.body_id);\n+        let cause = ObligationCause::misc(self.cause.span, self.body_id);\n         queue.push_back(self.tcx\n             .predicate_for_trait_def(cause, coerce_unsized_did, 0, source, &[target]));\n \n@@ -635,7 +635,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n-        let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n+        let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n+        let mut coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n             let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n@@ -655,7 +656,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\").\n     pub fn try_find_coercion_lub<'b, E, I>(&self,\n-                                           origin: TypeOrigin,\n+                                           cause: &ObligationCause<'tcx>,\n                                            exprs: E,\n                                            prev_ty: Ty<'tcx>,\n                                            new: &'b hir::Expr,\n@@ -669,7 +670,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n-        let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n+        let trace = TypeTrace::types(cause, true, prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n@@ -715,7 +716,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        let mut coerce = Coerce::new(self, origin);\n+        let mut coerce = Coerce::new(self, cause.clone());\n         coerce.use_lub = true;\n \n         // First try to coerce the new expression to the type of the previous ones,"}, {"sha": "075567c794924d3c5b1b393d3a598e01d036d2b6", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n@@ -95,6 +95,17 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n+    let cause = ObligationCause {\n+        span: impl_m_span,\n+        body_id: impl_m_body_id,\n+        code: ObligationCauseCode::CompareImplMethodObligation {\n+            item_name: impl_m.name,\n+            impl_item_def_id: impl_m.def_id,\n+            trait_item_def_id: trait_m.def_id,\n+            lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n+        },\n+    };\n+\n     // This code is best explained by example. Consider a trait:\n     //\n     //     trait Trait<'t,T> {\n@@ -235,20 +246,9 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n-            let cause = traits::ObligationCause {\n-                span: impl_m_span,\n-                body_id: impl_m_body_id,\n-                code: traits::ObligationCauseCode::CompareImplMethodObligation {\n-                    item_name: impl_m.name,\n-                    impl_item_def_id: impl_m.def_id,\n-                    trait_item_def_id: trait_m.def_id,\n-                    lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n-                },\n-            };\n-\n             fulfillment_cx.borrow_mut().register_predicate_obligation(\n                 &infcx,\n-                traits::Obligation::new(cause, predicate));\n+                traits::Obligation::new(cause.clone(), predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -266,7 +266,6 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Compute skolemized form of impl and trait method tys.\n         let tcx = infcx.tcx;\n-        let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n         let m_fty = |method: &ty::AssociatedItem| {\n             match tcx.item_type(method.def_id).sty {\n@@ -315,7 +314,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.sub_types(false, origin, impl_fty, trait_fty)\n+        let sub_result = infcx.sub_types(false, &cause, impl_fty, trait_fty)\n             .map(|InferOk { obligations, .. }| {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n@@ -328,22 +327,25 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             let (impl_err_span, trait_err_span) = extract_spans_for_error_reporting(&infcx,\n                                                                                     &terr,\n-                                                                                    origin,\n+                                                                                    &cause,\n                                                                                     impl_m,\n                                                                                     impl_sig,\n                                                                                     trait_m,\n                                                                                     trait_sig);\n \n-            let origin = TypeOrigin::MethodCompatCheck(impl_err_span);\n+            let cause = ObligationCause {\n+                span: impl_err_span,\n+                ..cause.clone()\n+            };\n \n             let mut diag = struct_span_err!(tcx.sess,\n-                                            origin.span(),\n+                                            cause.span,\n                                             E0053,\n                                             \"method `{}` has an incompatible type for trait\",\n                                             trait_m.name);\n \n             infcx.note_type_err(&mut diag,\n-                                origin,\n+                                &cause,\n                                 trait_err_span.map(|sp| (sp, format!(\"type in trait\"))),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_fty,\n@@ -429,7 +431,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                                      terr: &TypeError,\n-                                                     origin: TypeOrigin,\n+                                                     cause: &ObligationCause<'tcx>,\n                                                      impl_m: &ty::AssociatedItem,\n                                                      impl_sig: ty::FnSig<'tcx>,\n                                                      trait_m: &ty::AssociatedItem,\n@@ -478,9 +480,9 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                                    }\n                                }\n                            })\n-                           .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+                           .unwrap_or((cause.span, tcx.map.span_if_local(trait_m.def_id)))\n             } else {\n-                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                (cause.span, tcx.map.span_if_local(trait_m.def_id))\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n@@ -499,25 +501,25 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n                          .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                             match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n+                             match infcx.sub_types(true, &cause, trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n                              }\n                          })\n                          .next()\n                          .unwrap_or_else(|| {\n-                             if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n+                             if infcx.sub_types(false, &cause, impl_sig.output, trait_sig.output)\n                                      .is_err() {\n                                          (impl_m_output.span(), Some(trait_m_output.span()))\n                                      } else {\n-                                         (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                                         (cause.span, tcx.map.span_if_local(trait_m.def_id))\n                                      }\n                          })\n             } else {\n-                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                (cause.span, tcx.map.span_if_local(trait_m.def_id))\n             }\n         }\n-        _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n+        _ => (cause.span, tcx.map.span_if_local(trait_m.def_id)),\n     }\n }\n \n@@ -787,7 +789,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = tcx.item_type(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n         let trait_ty = tcx.item_type(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n-        let mut origin = TypeOrigin::Misc(impl_c_span);\n+        let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n         let err = infcx.commit_if_ok(|_| {\n             // There is no \"body\" here, so just pass dummy id.\n@@ -807,7 +809,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-            infcx.sub_types(false, origin, impl_ty, trait_ty)\n+            infcx.sub_types(false, &cause, impl_ty, trait_ty)\n                 .map(|InferOk { obligations, .. }| {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty())\n@@ -821,12 +823,12 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             // Locate the Span containing just the type of the offending impl\n             match tcx.map.expect_impl_item(impl_c_node_id).node {\n-                ImplItemKind::Const(ref ty, _) => origin = TypeOrigin::Misc(ty.span),\n+                ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n                 _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n \n             let mut diag = struct_span_err!(tcx.sess,\n-                                            origin.span(),\n+                                            cause.span,\n                                             E0326,\n                                             \"implemented const `{}` has an incompatible type for \\\n                                              trait\",\n@@ -840,7 +842,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             };\n \n             infcx.note_type_err(&mut diag,\n-                                origin,\n+                                &cause,\n                                 Some((trait_c_span, format!(\"type in trait\"))),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_ty,"}, {"sha": "8a0f1478a7364f82953657f6def882c506c41550", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -11,7 +11,8 @@\n \n use check::FnCtxt;\n use rustc::ty::Ty;\n-use rustc::infer::{InferOk, TypeOrigin};\n+use rustc::infer::{InferOk};\n+use rustc::traits::ObligationCause;\n \n use syntax_pos::Span;\n use rustc::hir;\n@@ -20,34 +21,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        let origin = TypeOrigin::Misc(sp);\n-        match self.sub_types(false, origin, actual, expected) {\n+        let cause = self.misc(sp);\n+        match self.sub_types(false, &cause, actual, expected) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n             },\n             Err(e) => {\n-                self.report_mismatched_types(origin, expected, actual, e);\n+                self.report_mismatched_types(&cause, expected, actual, e);\n             }\n         }\n     }\n \n     pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        self.demand_eqtype_with_origin(TypeOrigin::Misc(sp), expected, actual);\n+        self.demand_eqtype_with_origin(&self.misc(sp), expected, actual);\n     }\n \n     pub fn demand_eqtype_with_origin(&self,\n-                                     origin: TypeOrigin,\n+                                     cause: &ObligationCause<'tcx>,\n                                      expected: Ty<'tcx>,\n                                      actual: Ty<'tcx>)\n     {\n-        match self.eq_types(false, origin, actual, expected) {\n+        match self.eq_types(false, cause, actual, expected) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n             },\n             Err(e) => {\n-                self.report_mismatched_types(origin, expected, actual, e);\n+                self.report_mismatched_types(cause, expected, actual, e);\n             }\n         }\n     }\n@@ -56,9 +57,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n-            let origin = TypeOrigin::Misc(expr.span);\n+            let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n-            self.report_mismatched_types(origin, expected, expr_ty, e);\n+            self.report_mismatched_types(&cause, expected, expr_ty, e);\n         }\n     }\n }"}, {"sha": "8868d1e54f4b9661362b845c5d769e4734b8de1e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::{self, InferOk};\n use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, Reveal};\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n@@ -93,8 +93,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n-        match infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n-                             named_type, fresh_impl_self_ty) {\n+        let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n+        match infcx.eq_types(true, cause, named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());"}, {"sha": "77106b8b0c3a14dd26b4da1f19cd81b65597d63e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -12,7 +12,7 @@\n //! intrinsics that the compiler exposes.\n \n use intrinsics;\n-use rustc::infer::TypeOrigin;\n+use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n@@ -63,7 +63,9 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             .emit();\n     } else {\n         require_same_types(ccx,\n-                           TypeOrigin::IntrinsicType(it.span),\n+                           &ObligationCause::new(it.span,\n+                                                 it.id,\n+                                                 ObligationCauseCode::IntrinsicType),\n                            tcx.item_type(def_id),\n                            fty);\n     }"}, {"sha": "f9e1db141c8bdf8f87eca589f87eea35d3e4ed1c", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -17,7 +17,7 @@ use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n use rustc::hir;\n \n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n-        match self.sub_types(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n+        match self.sub_types(false, &self.misc(self.span), self_ty, method_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());"}, {"sha": "71696c0abea92763a22c99caf0563425dbf552f1", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -17,12 +17,12 @@ use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::traits;\n+use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer::{InferOk, TypeOrigin};\n+use rustc::infer::InferOk;\n use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n use rustc::hir;\n use std::mem;\n use std::ops::Deref;\n@@ -1032,7 +1032,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             // First check that the self type can be related.\n             match self.sub_types(false,\n-                                 TypeOrigin::Misc(DUMMY_SP),\n+                                 &ObligationCause::dummy(),\n                                  self_ty,\n                                  probe.xform_self_ty) {\n                 Ok(InferOk { obligations, .. }) => {"}, {"sha": "76cd3c4a1eb7605d6f2d49f3bf69847114880f74", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -87,9 +87,9 @@ use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n-                   TypeOrigin, TypeTrace, type_variable};\n+                   TypeTrace, type_variable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n@@ -1521,6 +1521,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn cause(&self,\n+                 span: Span,\n+                 code: ObligationCauseCode<'tcx>)\n+                 -> ObligationCause<'tcx> {\n+        ObligationCause::new(span, self.body_id, code)\n+    }\n+\n+    pub fn misc(&self, span: Span) -> ObligationCause<'tcx> {\n+        self.cause(span, ObligationCauseCode::MiscObligation)\n+    }\n+\n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_type_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n@@ -2096,8 +2107,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let Some(default) = default_map.get(ty) {\n                                     let default = default.clone();\n                                     match self.eq_types(false,\n-                                            TypeOrigin::Misc(default.origin_span),\n-                                            ty, default.ty) {\n+                                                        &self.misc(default.origin_span),\n+                                                        ty,\n+                                                        default.ty) {\n                                         Ok(InferOk { obligations, .. }) => {\n                                             // FIXME(#32730) propagate obligations\n                                             assert!(obligations.is_empty())\n@@ -2146,6 +2158,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     self.report_conflicting_default_types(\n                         first_default.origin_span,\n+                        self.body_id,\n                         first_default,\n                         second_default)\n                 }\n@@ -2194,8 +2207,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n                             match self.eq_types(false,\n-                                    TypeOrigin::Misc(default.origin_span),\n-                                    ty, default.ty) {\n+                                                &self.misc(default.origin_span),\n+                                                ty,\n+                                                default.ty) {\n                                 // FIXME(#32730) propagate obligations\n                                 Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n                                 Err(_) => {\n@@ -2765,8 +2779,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n-                let origin = TypeOrigin::Misc(call_span);\n-                let ures = self.sub_types(false, origin, formal_ret, ret_ty);\n+                let origin = self.misc(call_span);\n+                let ures = self.sub_types(false, &origin, formal_ret, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n                 match ures {\n@@ -2852,16 +2866,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n \n         let unit = self.tcx.mk_nil();\n-        let (origin, expected, found, result) =\n+        let (cause, expected_ty, found_ty, result);\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n+            cause = self.cause(sp, ObligationCauseCode::IfExpression);\n \n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n-            let origin = TypeOrigin::IfExpression(sp);\n-            let result = if let Some(ref then) = then_blk.expr {\n-                let res = self.try_find_coercion_lub(origin, || Some(&**then),\n+            expected_ty = then_ty;\n+            found_ty = else_ty;\n+            result = if let Some(ref then) = then_blk.expr {\n+                let res = self.try_find_coercion_lub(&cause, || Some(&**then),\n                                                      then_ty, else_expr, else_ty);\n \n                 // In case we did perform an adjustment, we have to update\n@@ -2876,7 +2892,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 res\n             } else {\n                 self.commit_if_ok(|_| {\n-                    let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n+                    let trace = TypeTrace::types(&cause, true, then_ty, else_ty);\n                     self.lub(true, trace, &then_ty, &else_ty)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n@@ -2888,21 +2904,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n-\n-            (origin, then_ty, else_ty, result)\n         } else {\n             // If the condition is false we can't diverge.\n             self.diverges.set(cond_diverges);\n \n-            let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n-            (origin, unit, then_ty,\n-             self.eq_types(true, origin, unit, then_ty)\n-                 .map(|InferOk { obligations, .. }| {\n-                     // FIXME(#32730) propagate obligations\n-                     assert!(obligations.is_empty());\n-                     unit\n-                 }))\n-        };\n+            cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n+            expected_ty = unit;\n+            found_ty = then_ty;\n+            result = self.eq_types(true, &cause, unit, then_ty)\n+                         .map(|InferOk { obligations, .. }| {\n+                             // FIXME(#32730) propagate obligations\n+                             assert!(obligations.is_empty());\n+                             unit\n+                         });\n+        }\n \n         match result {\n             Ok(ty) => {\n@@ -2913,7 +2928,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             Err(e) => {\n-                self.report_mismatched_types(origin, expected, found, e);\n+                self.report_mismatched_types(&cause, expected_ty, found_ty, e);\n                 self.tcx.types.err\n             }\n         }\n@@ -3565,7 +3580,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_expr_coercable_to_type(&e, self.ret_ty);\n             } else {\n                 let eq_result = self.eq_types(false,\n-                                              TypeOrigin::Misc(expr.span),\n+                                              &self.misc(expr.span),\n                                               self.ret_ty,\n                                               tcx.mk_nil())\n                     // FIXME(#32730) propagate obligations\n@@ -3695,20 +3710,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             for (i, e) in args.iter().enumerate() {\n                 let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                let origin = TypeOrigin::Misc(e.span);\n+                let cause = self.misc(e.span);\n \n                 // Special-case the first element, as it has no \"previous expressions\".\n                 let result = if i == 0 {\n                     self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n                     let prev_elems = || args[..i].iter().map(|e| &**e);\n-                    self.try_find_coercion_lub(origin, prev_elems, unified, e, e_ty)\n+                    self.try_find_coercion_lub(&cause, prev_elems, unified, e, e_ty)\n                 };\n \n                 match result {\n                     Ok(ty) => unified = ty,\n                     Err(e) => {\n-                        self.report_mismatched_types(origin, unified, e_ty, e);\n+                        self.report_mismatched_types(&cause, unified, e_ty, e);\n                     }\n                 }\n             }\n@@ -4064,9 +4079,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // We're not diverging and there's an expected type, which,\n                 // in case it's not `()`, could result in an error higher-up.\n                 // We have a chance to error here early and be more helpful.\n-                let origin = TypeOrigin::Misc(blk.span);\n-                let trace = TypeTrace::types(origin, false, ty, ety);\n-                match self.sub_types(false, origin, ty, ety) {\n+                let cause = self.misc(blk.span);\n+                let trace = TypeTrace::types(&cause, false, ty, ety);\n+                match self.sub_types(false, &cause, ty, ety) {\n                     Ok(InferOk { obligations, .. }) => {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n@@ -4367,7 +4382,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ty = self.tcx.item_type(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n-            match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n+            match self.sub_types(false, &self.misc(span), self_ty, impl_ty) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());"}, {"sha": "e41c149b178c182b56f664d8b860c3932b1cbe07", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -91,7 +91,7 @@ use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, InferOk, SubregionOrigin, VerifyBound};\n use hir::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -1762,7 +1762,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                            outlives);\n \n                     // check whether this predicate applies to our current projection\n-                    match self.eq_types(false, TypeOrigin::Misc(span), ty, outlives.0) {\n+                    let cause = self.fcx.misc(span);\n+                    match self.eq_types(false, &cause, ty, outlives.0) {\n                         Ok(InferOk { obligations, .. }) => {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());"}, {"sha": "41bea187416295d68e399a8eda3bb71470d2bc54", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -15,8 +15,7 @@ use CrateCtxt;\n \n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n-use rustc::infer::TypeOrigin;\n-use rustc::traits;\n+use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n@@ -29,15 +28,15 @@ use rustc::hir;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n     ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n-    code: traits::ObligationCauseCode<'tcx>,\n+    code: ObligationCauseCode<'tcx>,\n }\n \n /// Helper type of a temporary returned by .for_item(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n-    code: traits::ObligationCauseCode<'gcx>,\n+    code: ObligationCauseCode<'gcx>,\n     id: ast::NodeId,\n     span: Span\n }\n@@ -67,7 +66,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                -> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         CheckTypeWellFormedVisitor {\n             ccx: ccx,\n-            code: traits::ObligationCauseCode::MiscObligation\n+            code: ObligationCauseCode::MiscObligation\n         }\n     }\n \n@@ -515,8 +514,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n-        let origin = TypeOrigin::MethodReceiver(span);\n-        fcx.demand_eqtype_with_origin(origin, rcvr_ty, self_arg_ty);\n+        let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n+        fcx.demand_eqtype_with_origin(&cause, rcvr_ty, self_arg_ty);\n     }\n \n     fn check_variances_for_type_defn(&self,"}, {"sha": "7c860bc5aecb357c241da1ec4cbcc3c796b9b021", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -19,7 +19,7 @@ use hir::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n@@ -30,7 +30,7 @@ use rustc::ty::{TyProjection, TyAnon};\n use rustc::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use rustc::infer::{self, InferCtxt, TypeOrigin};\n+use rustc::infer::{self, InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n@@ -344,12 +344,12 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                    target);\n \n             tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n-                let origin = TypeOrigin::Misc(span);\n+                let cause = ObligationCause::misc(span, impl_node_id);\n                 let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n                                    mt_b: ty::TypeAndMut<'gcx>,\n                                    mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n                     if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(origin,\n+                        infcx.report_mismatched_types(&cause,\n                                                       mk_ptr(mt_b.ty),\n                                                       target,\n                                                       ty::error::TypeError::Mutability);\n@@ -397,7 +397,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                                 }\n \n                                 // Ignore fields that aren't significantly changed\n-                                if let Ok(ok) = infcx.sub_types(false, origin, b, a) {\n+                                if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n                                     if ok.obligations.is_empty() {\n                                         return None;\n                                     }"}, {"sha": "76f8254cb0fef4ae67fc1b86c72220f124567cea", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c1a47713bfba32ded7d8c32ceb36423fe44e35/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=19c1a47713bfba32ded7d8c32ceb36423fe44e35", "patch": "@@ -106,10 +106,10 @@ pub use rustc::util;\n \n use dep_graph::DepNode;\n use hir::map as hir_map;\n-use rustc::infer::{InferOk, TypeOrigin};\n+use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use session::{config, CompileResult};\n use util::common::time;\n \n@@ -172,19 +172,19 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n }\n \n fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                origin: TypeOrigin,\n+                                cause: &ObligationCause<'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n     ccx.tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n-        match infcx.eq_types(false, origin.clone(), expected, actual) {\n+        match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n                 true\n             }\n             Err(err) => {\n-                infcx.report_mismatched_types(origin, expected, actual, err);\n+                infcx.report_mismatched_types(cause, expected, actual, err);\n                 false\n             }\n         }\n@@ -231,7 +231,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n \n             require_same_types(\n                 ccx,\n-                TypeOrigin::MainFunctionType(main_span),\n+                &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n                 se_ty,\n                 main_t);\n         }\n@@ -286,7 +286,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n             require_same_types(\n                 ccx,\n-                TypeOrigin::StartFunctionType(start_span),\n+                &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n                 se_ty,\n                 start_t);\n         }"}]}