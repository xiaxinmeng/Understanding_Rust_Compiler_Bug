{"sha": "339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOWQ0MDAyNjE3ZDViMzZkNjEyNWQ4YTE3ODFhNmFkYTJlMGEzZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-05T04:06:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-05T04:06:34Z"}, "message": "auto merge of #13284 : pnkfelix/rust/more-fs-info-on-crate-mismatch, r=alexcrichton\n\nFix #13266.\r\n\r\nThere is a little bit of acrobatics in the definition of `crate_paths`\r\nto avoid calling `clone()` on the dylib/rlib unless we actually are\r\ngoing to need them.\r\n\r\nThe other oddity is that I have replaced the `root_ident: Option<&str>`\r\nparameter with a `root: &Option<CratePaths>`, which may surprise one\r\nwho was expecting to see something like: `root: Option<&CratePaths>`.\r\nI went with the approach here because I could not come up with code for\r\nthe alternative that was acceptable to the borrow checker.", "tree": {"sha": "b7d7ca0b968561e2a70fa6bf39fd9ab62ad968b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7d7ca0b968561e2a70fa6bf39fd9ab62ad968b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "html_url": "https://github.com/rust-lang/rust/commit/339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cf8d8ce69c1d1d10e90b04230d4c4e8dbb67bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf8d8ce69c1d1d10e90b04230d4c4e8dbb67bcc", "html_url": "https://github.com/rust-lang/rust/commit/4cf8d8ce69c1d1d10e90b04230d4c4e8dbb67bcc"}, {"sha": "f4cde4eddc04733da478ae1030ebc1ddeec04d80", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cde4eddc04733da478ae1030ebc1ddeec04d80", "html_url": "https://github.com/rust-lang/rust/commit/f4cde4eddc04733da478ae1030ebc1ddeec04d80"}], "stats": {"total": 255, "additions": 219, "deletions": 36}, "files": [{"sha": "c25a2e79824bbf1ee2821e3970a7ced8cf288a2a", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -232,6 +232,9 @@ impl Session {\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_end_note(sp, msg)\n     }\n+    pub fn fileline_note(&self, sp: Span, msg: &str) {\n+        self.diagnostic().fileline_note(sp, msg)\n+    }\n     pub fn note(&self, msg: &str) {\n         self.diagnostic().handler().note(msg)\n     }"}, {"sha": "8ce4a2f8eed860b87535e4b9c5eafb39f33d6e77", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -21,6 +21,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::Os;\n+use metadata::loader::CratePaths;\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -141,7 +142,7 @@ fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n \n     match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, None, info.ident, &info.crate_id, None,\n+            let cnum = resolve_crate(e, &None, info.ident, &info.crate_id, None,\n                                      i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n@@ -278,13 +279,13 @@ fn existing_match(e: &Env, crate_id: &CrateId,\n     None\n }\n \n-fn resolve_crate(e: &mut Env,\n-                 root_ident: Option<&str>,\n-                 ident: &str,\n-                 crate_id: &CrateId,\n-                 hash: Option<&Svh>,\n-                 span: Span)\n-              -> ast::CrateNum {\n+fn resolve_crate<'a>(e: &mut Env,\n+                     root: &Option<CratePaths>,\n+                     ident: &str,\n+                     crate_id: &CrateId,\n+                     hash: Option<&Svh>,\n+                     span: Span)\n+                     -> ast::CrateNum {\n     match existing_match(e, crate_id, hash) {\n         None => {\n             let id_hash = link::crate_id_hash(crate_id);\n@@ -297,11 +298,11 @@ fn resolve_crate(e: &mut Env,\n                 hash: hash.map(|a| &*a),\n                 os: e.os,\n                 intr: e.intr.clone(),\n-                rejected_via_hash: false,\n+                rejected_via_hash: vec!(),\n             };\n             let loader::Library {\n                 dylib, rlib, metadata\n-            } = load_ctxt.load_library_crate(root_ident);\n+            } = load_ctxt.load_library_crate(root);\n \n             let crate_id = decoder::get_crate_id(metadata.as_slice());\n             let hash = decoder::get_crate_hash(metadata.as_slice());\n@@ -316,15 +317,22 @@ fn resolve_crate(e: &mut Env,\n             });\n             e.next_crate_num += 1;\n \n-            // Maintain a reference to the top most crate.\n-            let root_crate = match root_ident {\n-                Some(c) => c,\n-                None => load_ctxt.ident.clone()\n+            // Stash paths for top-most crate locally if necessary.\n+            let crate_paths = if root.is_none() {\n+                Some(CratePaths {\n+                    ident: load_ctxt.ident.to_owned(),\n+                    dylib: dylib.clone(),\n+                    rlib:  rlib.clone(),\n+                })\n+            } else {\n+                None\n             };\n+            // Maintain a reference to the top most crate.\n+            let root = if root.is_some() { root } else { &crate_paths };\n \n             // Now resolve the crates referenced by this crate\n             let cnum_map = resolve_crate_deps(e,\n-            Some(root_crate),\n+            root,\n             metadata.as_slice(),\n             span);\n \n@@ -349,7 +357,7 @@ fn resolve_crate(e: &mut Env,\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: &mut Env,\n-                      root_ident: Option<&str>,\n+                      root: &Option<CratePaths>,\n                       cdata: &[u8], span : Span)\n                    -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n@@ -360,7 +368,7 @@ fn resolve_crate_deps(e: &mut Env,\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n-        let local_cnum = resolve_crate(e, root_ident,\n+        let local_cnum = resolve_crate(e, root,\n                                        dep.crate_id.name.as_slice(),\n                                        &dep.crate_id,\n                                        Some(&dep.hash),\n@@ -393,7 +401,7 @@ impl<'a> Loader<'a> {\n impl<'a> CrateLoader for Loader<'a> {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let cnum = resolve_crate(&mut self.env, None, info.ident,\n+        let cnum = resolve_crate(&mut self.env, &None, info.ident,\n                                  &info.crate_id, None, krate.span);\n         let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n         MacroCrate {"}, {"sha": "4f4ef31e15b374bf6ea30791c3bb5391cd6c8d0c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -46,6 +46,10 @@ pub enum Os {\n     OsFreebsd\n }\n \n+pub struct HashMismatch {\n+    path: Path,\n+}\n+\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n@@ -55,7 +59,7 @@ pub struct Context<'a> {\n     pub hash: Option<&'a Svh>,\n     pub os: Os,\n     pub intr: Rc<IdentInterner>,\n-    pub rejected_via_hash: bool,\n+    pub rejected_via_hash: Vec<HashMismatch>\n }\n \n pub struct Library {\n@@ -70,6 +74,23 @@ pub struct ArchiveMetadata {\n     data: &'static [u8],\n }\n \n+pub struct CratePaths {\n+    pub ident: ~str,\n+    pub dylib: Option<Path>,\n+    pub rlib: Option<Path>\n+}\n+\n+impl CratePaths {\n+    fn paths(&self) -> Vec<Path> {\n+        match (&self.dylib, &self.rlib) {\n+            (&None,    &None)              => vec!(),\n+            (&Some(ref p), &None) |\n+            (&None, &Some(ref p))          => vec!(p.clone()),\n+            (&Some(ref p1), &Some(ref p2)) => vec!(p1.clone(), p2.clone()),\n+        }\n+    }\n+}\n+\n // FIXME(#11857) this should be a \"real\" realpath\n fn realpath(p: &Path) -> Path {\n     use std::os;\n@@ -83,26 +104,43 @@ fn realpath(p: &Path) -> Path {\n }\n \n impl<'a> Context<'a> {\n-    pub fn load_library_crate(&mut self, root_ident: Option<&str>) -> Library {\n+    pub fn load_library_crate(&mut self, root: &Option<CratePaths>) -> Library {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n                 self.sess.abort_if_errors();\n-                let message = if self.rejected_via_hash {\n+                let message = if self.rejected_via_hash.len() > 0 {\n                     format!(\"found possibly newer version of crate `{}`\",\n                             self.ident)\n                 } else {\n                     format!(\"can't find crate for `{}`\", self.ident)\n                 };\n-                let message = match root_ident {\n-                    None => message,\n-                    Some(c) => format!(\"{} which `{}` depends on\", message, c),\n+                let message = match root {\n+                    &None => message,\n+                    &Some(ref r) => format!(\"{} which `{}` depends on\",\n+                                            message, r.ident)\n                 };\n                 self.sess.span_err(self.span, message);\n \n-                if self.rejected_via_hash {\n+                if self.rejected_via_hash.len() > 0 {\n                     self.sess.span_note(self.span, \"perhaps this crate needs \\\n                                                     to be recompiled?\");\n+                    let mismatches = self.rejected_via_hash.iter();\n+                    for (i, &HashMismatch{ ref path }) in mismatches.enumerate() {\n+                        self.sess.fileline_note(self.span,\n+                            format!(\"crate `{}` path \\\\#{}: {}\",\n+                                    self.ident, i+1, path.display()));\n+                    }\n+                    match root {\n+                        &None => {}\n+                        &Some(ref r) => {\n+                            for (i, path) in r.paths().iter().enumerate() {\n+                                self.sess.fileline_note(self.span,\n+                                    format!(\"crate `{}` path \\\\#{}: {}\",\n+                                            r.ident, i+1, path.display()));\n+                            }\n+                        }\n+                    }\n                 }\n                 self.sess.abort_if_errors();\n                 unreachable!()\n@@ -292,7 +330,7 @@ impl<'a> Context<'a> {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.os, &lib) {\n                 Ok(blob) => {\n-                    if self.crate_matches(blob.as_slice()) {\n+                    if self.crate_matches(blob.as_slice(), &lib) {\n                         blob\n                     } else {\n                         info!(\"metadata mismatch\");\n@@ -327,7 +365,7 @@ impl<'a> Context<'a> {\n         return if error > 0 {None} else {ret}\n     }\n \n-    fn crate_matches(&mut self, crate_data: &[u8]) -> bool {\n+    fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n         match decoder::maybe_get_crate_id(crate_data) {\n             Some(ref id) if self.crate_id.matches(id) => {}\n             _ => return false\n@@ -339,7 +377,7 @@ impl<'a> Context<'a> {\n             None => true,\n             Some(myhash) => {\n                 if *myhash != hash {\n-                    self.rejected_via_hash = true;\n+                    self.rejected_via_hash.push(HashMismatch{ path: libpath.clone() });\n                     false\n                 } else {\n                     true"}, {"sha": "e3514b6f3f36a8de8b6bc67e33f7013a22bf9cc7", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -20,11 +20,37 @@ use term;\n // maximum number of lines we will print for each error; arbitrary.\n static MAX_LINES: uint = 6u;\n \n+#[deriving(Clone)]\n+pub enum RenderSpan {\n+    /// A FullSpan renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary of\n+    /// the source code covered by the span.\n+    FullSpan(Span),\n+\n+    /// A FileLine renders with just a line for the message prefixed\n+    /// by file:linenum.\n+    FileLine(Span),\n+}\n+\n+impl RenderSpan {\n+    fn span(self) -> Span {\n+        match self {\n+            FullSpan(s) | FileLine(s) => s\n+        }\n+    }\n+    fn is_full_span(&self) -> bool {\n+        match self {\n+            &FullSpan(..) => true,\n+            &FileLine(..) => false,\n+        }\n+    }\n+}\n+\n pub trait Emitter {\n     fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str, lvl: Level);\n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: Span, msg: &str, lvl: Level);\n+                   sp: RenderSpan, msg: &str, lvl: Level);\n }\n \n /// This structure is used to signify that a task has failed with a fatal error\n@@ -60,7 +86,10 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, sp, msg, Note);\n+        self.handler.custom_emit(&self.cm, FullSpan(sp), msg, Note);\n+    }\n+    pub fn fileline_note(&self, sp: Span, msg: &str) {\n+        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n@@ -132,7 +161,7 @@ impl Handler {\n         self.emit.borrow_mut().emit(cmsp, msg, lvl);\n     }\n     pub fn custom_emit(&self, cm: &codemap::CodeMap,\n-                       sp: Span, msg: &str, lvl: Level) {\n+                       sp: RenderSpan, msg: &str, lvl: Level) {\n         self.emit.borrow_mut().custom_emit(cm, sp, msg, lvl);\n     }\n }\n@@ -258,7 +287,7 @@ impl Emitter for EmitterWriter {\n             msg: &str,\n             lvl: Level) {\n         let error = match cmsp {\n-            Some((cm, sp)) => emit(self, cm, sp, msg, lvl, false),\n+            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, lvl, false),\n             None => print_diagnostic(self, \"\", lvl, msg),\n         };\n \n@@ -269,16 +298,17 @@ impl Emitter for EmitterWriter {\n     }\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: Span, msg: &str, lvl: Level) {\n+                   sp: RenderSpan, msg: &str, lvl: Level) {\n         match emit(self, cm, sp, msg, lvl, true) {\n             Ok(()) => {}\n             Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n }\n \n-fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, sp: Span,\n+fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n+    let sp = rsp.span();\n     let ss = cm.span_to_str(sp);\n     let lines = cm.span_to_lines(sp);\n     if custom {\n@@ -288,10 +318,14 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, sp: Span,\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_str(span_end);\n         try!(print_diagnostic(dst, ses, lvl, msg));\n-        try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n+        if rsp.is_full_span() {\n+            try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n+        }\n     } else {\n         try!(print_diagnostic(dst, ss, lvl, msg));\n-        try!(highlight_lines(dst, cm, sp, lvl, lines));\n+        if rsp.is_full_span() {\n+            try!(highlight_lines(dst, cm, sp, lvl, lines));\n+        }\n     }\n     print_macro_backtrace(dst, cm, sp)\n }"}, {"sha": "4d80c09c26b337572f81066f83e58eb0ab386b4c", "filename": "src/test/run-make/many-crates-but-no-match/Makefile", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -0,0 +1,34 @@\n+-include ../tools.mk\n+\n+# Modelled after compile-fail/changing-crates test, but this one puts\n+# more than one (mismatching) candidate crate into the search path,\n+# which did not appear directly expressible in compile-fail/aux-build\n+# infrastructure.\n+#\n+# Note that we move the built libraries into target direcrtories rather than\n+# use the `--out-dir` option because the `../tools.mk` file already bakes a\n+# use of `--out-dir` into the definition of $(RUSTC).\n+\n+A1=$(TMPDIR)/a1\n+A2=$(TMPDIR)/a2\n+A3=$(TMPDIR)/a3\n+\n+# A hack to match distinct lines of output from a single run.\n+LOG=$(TMPDIR)/log.txt\n+\n+all: \n+\tmkdir -p $(A1) $(A2) $(A3)\n+\t$(RUSTC) --crate-type=rlib crateA1.rs\n+\tmv $(TMPDIR)/$(call RLIB_GLOB,crateA) $(A1)\n+\t$(RUSTC) --crate-type=rlib -L$(A1) crateB.rs\n+\t$(RUSTC) --crate-type=rlib crateA2.rs\n+\tmv $(TMPDIR)/$(call RLIB_GLOB,crateA) $(A2)\n+\t$(RUSTC) --crate-type=rlib crateA3.rs\n+\tmv $(TMPDIR)/$(call RLIB_GLOB,crateA) $(A3)\n+\t# Ensure crateC fails to compile since A1 is \"missing\" and A2/A3 hashes do not match\n+\t$(RUSTC) -L$(A2) -L$(A3) crateC.rs >$(LOG) 2>&1 || true\n+\tgrep \"error: found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n+\tgrep \"note: perhaps this crate needs to be recompiled?\" $(LOG)\n+\tgrep \"note: crate \\`crateA\\` path #1:\" $(LOG)\n+\tgrep \"note: crate \\`crateA\\` path #2:\" $(LOG)\n+\tgrep \"note: crate \\`crateB\\` path #1:\" $(LOG)"}, {"sha": "0c88cf4745a00e87cbdfed4562e03fa4b20725ad", "filename": "src/test/run-make/many-crates-but-no-match/crateA1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_id=\"crateA\"]\n+\n+// Base crate\n+pub fn func<T>() {}"}, {"sha": "e3fb50e13d0eb1d65a07f9cefaa0addbcf801353", "filename": "src/test/run-make/many-crates-but-no-match/crateA2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_id=\"crateA\"]\n+\n+// Base crate\n+pub fn func<T>() { println!(\"hello\"); }"}, {"sha": "ad9d458be242d6fe7bc4873d20f79b74210f4511", "filename": "src/test/run-make/many-crates-but-no-match/crateA3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_id=\"crateA\"]\n+\n+// Base crate\n+pub fn foo<T>() { println!(\"world!\"); }"}, {"sha": "bf55017c6463f7c0d247777c560c1eb423aa8abd", "filename": "src/test/run-make/many-crates-but-no-match/crateB.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateB.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateB.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateB.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate crateA;"}, {"sha": "174d9382b76be37f56b466240ece1e7ea9ab0b7a", "filename": "src/test/run-make/many-crates-but-no-match/crateC.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateC.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339d4002617d5b36d6125d8a1781a6ada2e0a3f8/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateC.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateC.rs?ref=339d4002617d5b36d6125d8a1781a6ada2e0a3f8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate crateB;\n+\n+fn main() {}"}]}