{"sha": "26becc308e4b9a0f5be1c7c2895c7761b778e01f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmVjYzMwOGU0YjlhMGY1YmUxYzdjMjg5NWM3NzYxYjc3OGUwMWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-17T06:12:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-18T00:54:27Z"}, "message": "core: Wire up oneshot pipes to newsched", "tree": {"sha": "73fb276dad954cec037e43a72c2e75b8d7652645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73fb276dad954cec037e43a72c2e75b8d7652645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26becc308e4b9a0f5be1c7c2895c7761b778e01f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26becc308e4b9a0f5be1c7c2895c7761b778e01f", "html_url": "https://github.com/rust-lang/rust/commit/26becc308e4b9a0f5be1c7c2895c7761b778e01f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26becc308e4b9a0f5be1c7c2895c7761b778e01f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5", "html_url": "https://github.com/rust-lang/rust/commit/f5987b03b8d65a2b885519b7b9a0ea33cda33bc5"}], "stats": {"total": 389, "additions": 253, "deletions": 136}, "files": [{"sha": "da3ae0e6c5dfe35e47746ce5f1848c4cd3c126a0", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 226, "deletions": 124, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=26becc308e4b9a0f5be1c7c2895c7761b778e01f", "patch": "@@ -22,6 +22,8 @@ use vec;\n use vec::OwnedVector;\n use util::replace;\n use unstable::sync::{Exclusive, exclusive};\n+use rtcomm = rt::comm;\n+use rt;\n \n use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n \n@@ -335,180 +337,280 @@ impl<T: Owned> ::clone::Clone for SharedChan<T> {\n     }\n }\n \n-/*proto! oneshot (\n-    Oneshot:send<T:Owned> {\n-        send(T) -> !\n+pub struct PortOne<T> {\n+    inner: Either<pipesy::PortOne<T>, rtcomm::PortOne<T>>\n+}\n+\n+pub struct ChanOne<T> {\n+    inner: Either<pipesy::ChanOne<T>, rtcomm::ChanOne<T>>\n+}\n+\n+pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+    let (port, chan) = match rt::context() {\n+        rt::OldTaskContext => match pipesy::oneshot() {\n+            (p, c) => (Left(p), Left(c)),\n+        },\n+        _ => match rtcomm::oneshot() {\n+            (p, c) => (Right(p), Right(c))\n+        }\n+    };\n+    let port = PortOne {\n+        inner: port\n+    };\n+    let chan = ChanOne {\n+        inner: chan\n+    };\n+    return (port, chan);\n+}\n+\n+impl<T: Owned> PortOne<T> {\n+    pub fn recv(self) -> T {\n+        let PortOne { inner } = self;\n+        match inner {\n+            Left(p) => p.recv(),\n+            Right(p) => p.recv()\n+        }\n     }\n-)*/\n \n-#[allow(non_camel_case_types)]\n-pub mod oneshot {\n-    priv use core::kinds::Owned;\n-    use ptr::to_mut_unsafe_ptr;\n+    pub fn try_recv(self) -> Option<T> {\n+        let PortOne { inner } = self;\n+        match inner {\n+            Left(p) => p.try_recv(),\n+            Right(p) => p.try_recv()\n+        }\n+    }\n+}\n \n-    pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n-        pub use core::pipes::HasBuffer;\n+impl<T: Owned> ChanOne<T> {\n+    pub fn send(self, data: T) {\n+        let ChanOne { inner } = self;\n+        match inner {\n+            Left(p) => p.send(data),\n+            Right(p) => p.send(data)\n+        }\n+    }\n \n-        let buffer = ~::core::pipes::Buffer {\n-            header: ::core::pipes::BufferHeader(),\n-            data: __Buffer {\n-                Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n-            },\n-        };\n-        do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n-            data.Oneshot.set_buffer(buffer);\n-            to_mut_unsafe_ptr(&mut data.Oneshot)\n+    pub fn try_send(self, data: T) -> bool {\n+        let ChanOne { inner } = self;\n+        match inner {\n+            Left(p) => p.try_send(data),\n+            Right(p) => p.try_send(data)\n         }\n     }\n-    #[allow(non_camel_case_types)]\n-    pub enum Oneshot<T> { pub send(T), }\n-    #[allow(non_camel_case_types)]\n-    pub struct __Buffer<T> {\n-        Oneshot: ::core::pipes::Packet<Oneshot<T>>,\n+}\n+\n+pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+    let PortOne { inner } = port;\n+    match inner {\n+        Left(p) => pipesy::recv_one(p),\n+        Right(p) => p.recv()\n     }\n+}\n \n-    #[allow(non_camel_case_types)]\n-    pub mod client {\n+pub fn try_recv_one<T: Owned>(port: PortOne<T>) -> Option<T> {\n+    let PortOne { inner } = port;\n+    match inner {\n+        Left(p) => pipesy::try_recv_one(p),\n+        Right(p) => p.try_recv()\n+    }\n+}\n+\n+pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+    let ChanOne { inner } = chan;\n+    match inner {\n+        Left(c) => pipesy::send_one(c, data),\n+        Right(c) => c.send(data)\n+    }\n+}\n+\n+pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+    let ChanOne { inner } = chan;\n+    match inner {\n+        Left(c) => pipesy::try_send_one(c, data),\n+        Right(c) => c.try_send(data)\n+    }\n+}\n \n+mod pipesy {\n+\n+    use kinds::Owned;\n+    use option::{Option, Some, None};\n+    use pipes::{recv, try_recv};\n+\n+    /*proto! oneshot (\n+        Oneshot:send<T:Owned> {\n+            send(T) -> !\n+        }\n+    )*/\n+\n+    #[allow(non_camel_case_types)]\n+    pub mod oneshot {\n         priv use core::kinds::Owned;\n+        use ptr::to_mut_unsafe_ptr;\n \n-        #[allow(non_camel_case_types)]\n-        pub fn try_send<T: Owned>(pipe: Oneshot<T>, x_0: T) ->\n-            ::core::option::Option<()> {\n-            {\n-                use super::send;\n-                let message = send(x_0);\n-                if ::core::pipes::send(pipe, message) {\n-                    ::core::pipes::rt::make_some(())\n-                } else { ::core::pipes::rt::make_none() }\n+        pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n+            pub use core::pipes::HasBuffer;\n+\n+            let buffer = ~::core::pipes::Buffer {\n+                header: ::core::pipes::BufferHeader(),\n+                data: __Buffer {\n+                    Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n+                },\n+            };\n+            do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n+                data.Oneshot.set_buffer(buffer);\n+                to_mut_unsafe_ptr(&mut data.Oneshot)\n             }\n         }\n+        #[allow(non_camel_case_types)]\n+        pub enum Oneshot<T> { pub send(T), }\n+        #[allow(non_camel_case_types)]\n+        pub struct __Buffer<T> {\n+            Oneshot: ::core::pipes::Packet<Oneshot<T>>,\n+        }\n \n         #[allow(non_camel_case_types)]\n-        pub fn send<T: Owned>(pipe: Oneshot<T>, x_0: T) {\n-            {\n-                use super::send;\n-                let message = send(x_0);\n-                ::core::pipes::send(pipe, message);\n+        pub mod client {\n+\n+            priv use core::kinds::Owned;\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn try_send<T: Owned>(pipe: Oneshot<T>, x_0: T) ->\n+                ::core::option::Option<()> {\n+                {\n+                    use super::send;\n+                    let message = send(x_0);\n+                    if ::core::pipes::send(pipe, message) {\n+                        ::core::pipes::rt::make_some(())\n+                    } else { ::core::pipes::rt::make_none() }\n+                }\n             }\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn send<T: Owned>(pipe: Oneshot<T>, x_0: T) {\n+                {\n+                    use super::send;\n+                    let message = send(x_0);\n+                    ::core::pipes::send(pipe, message);\n+                }\n+            }\n+\n+            #[allow(non_camel_case_types)]\n+            pub type Oneshot<T> =\n+                ::core::pipes::SendPacketBuffered<super::Oneshot<T>,\n+            super::__Buffer<T>>;\n         }\n \n         #[allow(non_camel_case_types)]\n-        pub type Oneshot<T> =\n-            ::core::pipes::SendPacketBuffered<super::Oneshot<T>,\n-                                              super::__Buffer<T>>;\n+        pub mod server {\n+            #[allow(non_camel_case_types)]\n+            pub type Oneshot<T> =\n+                ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,\n+            super::__Buffer<T>>;\n+        }\n     }\n \n-    #[allow(non_camel_case_types)]\n-    pub mod server {\n-        #[allow(non_camel_case_types)]\n-        pub type Oneshot<T> =\n-            ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,\n-                                              super::__Buffer<T>>;\n+    /// The send end of a oneshot pipe.\n+    pub struct ChanOne<T> {\n+        contents: oneshot::client::Oneshot<T>\n     }\n-}\n-\n-/// The send end of a oneshot pipe.\n-pub struct ChanOne<T> {\n-    contents: oneshot::client::Oneshot<T>\n-}\n \n-impl<T> ChanOne<T> {\n-    pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n-        ChanOne {\n-            contents: contents\n+    impl<T> ChanOne<T> {\n+        pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n+            ChanOne {\n+                contents: contents\n+            }\n         }\n     }\n-}\n \n-/// The receive end of a oneshot pipe.\n-pub struct PortOne<T> {\n-    contents: oneshot::server::Oneshot<T>\n-}\n+    /// The receive end of a oneshot pipe.\n+    pub struct PortOne<T> {\n+        contents: oneshot::server::Oneshot<T>\n+    }\n \n-impl<T> PortOne<T> {\n-    pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n-        PortOne {\n-            contents: contents\n+    impl<T> PortOne<T> {\n+        pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n+            PortOne {\n+                contents: contents\n+            }\n         }\n     }\n-}\n \n-/// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n-    let (chan, port) = oneshot::init();\n-    (PortOne::new(port), ChanOne::new(chan))\n-}\n+    /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n+    pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+        let (chan, port) = oneshot::init();\n+        (PortOne::new(port), ChanOne::new(chan))\n+    }\n \n-pub impl<T: Owned> PortOne<T> {\n-    fn recv(self) -> T { recv_one(self) }\n-    fn try_recv(self) -> Option<T> { try_recv_one(self) }\n-    fn unwrap(self) -> oneshot::server::Oneshot<T> {\n-        match self {\n-            PortOne { contents: s } => s\n+    pub impl<T: Owned> PortOne<T> {\n+        fn recv(self) -> T { recv_one(self) }\n+        fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+        fn unwrap(self) -> oneshot::server::Oneshot<T> {\n+            match self {\n+                PortOne { contents: s } => s\n+            }\n         }\n     }\n-}\n \n-pub impl<T: Owned> ChanOne<T> {\n-    fn send(self, data: T) { send_one(self, data) }\n-    fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n-    fn unwrap(self) -> oneshot::client::Oneshot<T> {\n-        match self {\n-            ChanOne { contents: s } => s\n+    pub impl<T: Owned> ChanOne<T> {\n+        fn send(self, data: T) { send_one(self, data) }\n+        fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+        fn unwrap(self) -> oneshot::client::Oneshot<T> {\n+            match self {\n+                ChanOne { contents: s } => s\n+            }\n         }\n     }\n-}\n \n-/**\n- * Receive a message from a oneshot pipe, failing if the connection was\n- * closed.\n- */\n-pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n-    match port {\n-        PortOne { contents: port } => {\n-            let oneshot::send(message) = recv(port);\n-            message\n+    /**\n+    * Receive a message from a oneshot pipe, failing if the connection was\n+    * closed.\n+    */\n+    pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+        match port {\n+            PortOne { contents: port } => {\n+                let oneshot::send(message) = recv(port);\n+                message\n+            }\n         }\n     }\n-}\n \n-/// Receive a message from a oneshot pipe unless the connection was closed.\n-pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n-    match port {\n-        PortOne { contents: port } => {\n-            let message = try_recv(port);\n+    /// Receive a message from a oneshot pipe unless the connection was closed.\n+    pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n+        match port {\n+            PortOne { contents: port } => {\n+                let message = try_recv(port);\n \n-            if message.is_none() {\n-                None\n-            } else {\n-                let oneshot::send(message) = message.unwrap();\n-                Some(message)\n+                if message.is_none() {\n+                    None\n+                } else {\n+                    let oneshot::send(message) = message.unwrap();\n+                    Some(message)\n+                }\n             }\n         }\n     }\n-}\n \n-/// Send a message on a oneshot pipe, failing if the connection was closed.\n-pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n-    match chan {\n-        ChanOne { contents: chan } => oneshot::client::send(chan, data),\n+    /// Send a message on a oneshot pipe, failing if the connection was closed.\n+    pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+        match chan {\n+            ChanOne { contents: chan } => oneshot::client::send(chan, data),\n+        }\n     }\n-}\n \n-/**\n- * Send a message on a oneshot pipe, or return false if the connection was\n- * closed.\n- */\n-pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n-    match chan {\n-        ChanOne { contents: chan } => {\n-            oneshot::client::try_send(chan, data).is_some()\n+    /**\n+    * Send a message on a oneshot pipe, or return false if the connection was\n+    * closed.\n+    */\n+    pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+        match chan {\n+            ChanOne { contents: chan } => {\n+                oneshot::client::try_send(chan, data).is_some()\n+            }\n         }\n     }\n-}\n-\n \n+}\n \n /// Returns the index of an endpoint that is ready to receive.\n pub fn selecti<T: Selectable>(endpoints: &mut [T]) -> uint {"}, {"sha": "35c703bb35074848bb92d88d390aee8640b9c42e", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=26becc308e4b9a0f5be1c7c2895c7761b778e01f", "patch": "@@ -244,5 +244,27 @@ mod test {\n             info!(\"here i am. logging in a newsched task\");\n         }\n     }\n+\n+    #[test]\n+    fn comm_oneshot() {\n+        use comm::*;\n+\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot();\n+            send_one(chan, 10);\n+            assert!(recv_one(port) == 10);\n+        }\n+    }\n+\n+    #[test]\n+    fn comm_stream() {\n+        use comm::*;\n+\n+        do run_in_newsched_task() {\n+            let (port, chan) = oneshot();\n+            chan.send(10);\n+            assert!(port.recv() == 10);\n+        }\n+    }\n }\n "}, {"sha": "b8ae03c0f2bfe52f216ba67a12857223acb6d3b9", "filename": "src/libstd/future.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=26becc308e4b9a0f5be1c7c2895c7761b778e01f", "patch": "@@ -23,8 +23,7 @@\n \n use core::cast;\n use core::cell::Cell;\n-use core::comm::{PortOne, oneshot, send_one};\n-use core::pipes::recv;\n+use core::comm::{PortOne, oneshot, send_one, recv_one};\n use core::task;\n use core::util::replace;\n \n@@ -105,11 +104,8 @@ pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n      */\n \n     let port = Cell(port);\n-    do from_fn || {\n-        let port = port.take().unwrap();\n-        match recv(port) {\n-            oneshot::send(data) => data\n-        }\n+    do from_fn {\n+        recv_one(port.take())\n     }\n }\n "}, {"sha": "3889650d012e094592785461bf192f0b07d26b4d", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26becc308e4b9a0f5be1c7c2895c7761b778e01f/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=26becc308e4b9a0f5be1c7c2895c7761b778e01f", "patch": "@@ -15,11 +15,10 @@ use sort;\n \n use core::cell::Cell;\n use core::cmp;\n-use core::comm::{PortOne, oneshot, send_one};\n+use core::comm::{PortOne, oneshot, send_one, recv_one};\n use core::either::{Either, Left, Right};\n use core::hashmap::HashMap;\n use core::io;\n-use core::pipes::recv;\n use core::run;\n use core::to_bytes;\n use core::util::replace;\n@@ -389,9 +388,7 @@ fn unwrap<T:Owned +\n         None => fail!(),\n         Some(Left(v)) => v,\n         Some(Right(port)) => {\n-            let (exe, v) = match recv(port.unwrap()) {\n-                oneshot::send(data) => data\n-            };\n+            let (exe, v) = recv_one(port);\n \n             let s = json_encode(&v);\n "}]}