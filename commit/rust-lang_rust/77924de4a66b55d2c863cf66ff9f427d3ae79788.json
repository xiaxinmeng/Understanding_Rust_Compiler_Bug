{"sha": "77924de4a66b55d2c863cf66ff9f427d3ae79788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3OTI0ZGU0YTY2YjU1ZDJjODYzY2Y2NmZmOWY0MjdkM2FlNzk3ODg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-11-18T20:25:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-02T22:35:06Z"}, "message": "refactor highlighting to take any RegionKind, making it more general", "tree": {"sha": "7de47e7bf459b4342be5fe0eebb279edd3abcdc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7de47e7bf459b4342be5fe0eebb279edd3abcdc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77924de4a66b55d2c863cf66ff9f427d3ae79788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77924de4a66b55d2c863cf66ff9f427d3ae79788", "html_url": "https://github.com/rust-lang/rust/commit/77924de4a66b55d2c863cf66ff9f427d3ae79788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77924de4a66b55d2c863cf66ff9f427d3ae79788/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cbbee1dc7ec5c680bb5c83af0aa1b16b3a03cc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cbbee1dc7ec5c680bb5c83af0aa1b16b3a03cc0", "html_url": "https://github.com/rust-lang/rust/commit/6cbbee1dc7ec5c680bb5c83af0aa1b16b3a03cc0"}], "stats": {"total": 347, "additions": 160, "deletions": 187}, "files": [{"sha": "4fd1a970076823ec2416bc54b3217cdbd1595788", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 76, "deletions": 121, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/77924de4a66b55d2c863cf66ff9f427d3ae79788/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77924de4a66b55d2c863cf66ff9f427d3ae79788/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=77924de4a66b55d2c863cf66ff9f427d3ae79788", "patch": "@@ -24,15 +24,15 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n-                ty::RePlaceholder(sub_placeholder),\n+                sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n-                ty::RePlaceholder(sup_placeholder),\n+                sup_placeholder @ ty::RePlaceholder(_),\n             )) => if expected.def_id == found.def_id {\n                 return Some(self.try_report_placeholders_trait(\n-                    Some(*vid),\n+                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n                     cause,\n-                    Some(*sub_placeholder),\n-                    Some(*sup_placeholder),\n+                    Some(sub_placeholder),\n+                    Some(sup_placeholder),\n                     expected.def_id,\n                     expected.substs,\n                     found.substs,\n@@ -48,14 +48,14 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n-                ty::RePlaceholder(sub_placeholder),\n+                sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 _,\n             )) => if expected.def_id == found.def_id {\n                 return Some(self.try_report_placeholders_trait(\n-                    Some(*vid),\n+                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n                     cause,\n-                    Some(*sub_placeholder),\n+                    Some(sub_placeholder),\n                     None,\n                     expected.def_id,\n                     expected.substs,\n@@ -74,10 +74,10 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n                 }),\n                 _,\n                 _,\n-                ty::RePlaceholder(sup_placeholder),\n+                sup_placeholder @ ty::RePlaceholder(_),\n             )) => if expected.def_id == found.def_id {\n                 return Some(self.try_report_placeholders_trait(\n-                    Some(*vid),\n+                    Some(self.tcx.mk_region(ty::ReVar(*vid))),\n                     cause,\n                     None,\n                     Some(*sup_placeholder),\n@@ -106,10 +106,10 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n     //    = note: However, the type `T` only implements `...` for some specific lifetime `'2`.\n     fn try_report_placeholders_trait(\n         &self,\n-        vid: Option<ty::RegionVid>,\n+        vid: Option<ty::Region<'tcx>>,\n         cause: &ObligationCause<'tcx>,\n-        sub_placeholder: Option<ty::PlaceholderRegion>,\n-        sup_placeholder: Option<ty::PlaceholderRegion>,\n+        sub_placeholder: Option<ty::Region<'tcx>>,\n+        sup_placeholder: Option<ty::Region<'tcx>>,\n         trait_def_id: DefId,\n         expected_substs: &'tcx Substs<'tcx>,\n         actual_substs: &'tcx Substs<'tcx>,\n@@ -152,120 +152,75 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         let mut has_sup = None;\n         let mut has_vid = None;\n \n-        self.tcx\n-            .for_each_free_region(&expected_trait_ref, |r| match r {\n-                ty::RePlaceholder(p) => {\n-                    if Some(*p) == sub_placeholder {\n-                        if has_sub.is_none() {\n-                            has_sub = Some(counter);\n-                            counter += 1;\n-                        }\n-                    } else if Some(*p) == sup_placeholder {\n-                        if has_sup.is_none() {\n-                            has_sup = Some(counter);\n-                            counter += 1;\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            });\n+        self.tcx.for_each_free_region(&expected_trait_ref, |r| {\n+            if Some(r) == sub_placeholder && has_sub.is_none() {\n+                has_sub = Some(counter);\n+                counter += 1;\n+            } else if Some(r) == sup_placeholder && has_sup.is_none() {\n+                has_sup = Some(counter);\n+                counter += 1;\n+            }\n+        });\n \n-        self.tcx\n-            .for_each_free_region(&actual_trait_ref, |r| match r {\n-                ty::ReVar(v) if Some(*v) == vid => {\n-                    if has_vid.is_none() {\n-                        has_vid = Some(counter);\n-                        counter += 1;\n+        self.tcx.for_each_free_region(&actual_trait_ref, |r| {\n+            if Some(r) == vid && has_vid.is_none() {\n+                has_vid = Some(counter);\n+                counter += 1;\n+            }\n+        });\n+\n+        RegionHighlightMode::maybe_highlighting_region(sub_placeholder, has_sub, || {\n+            RegionHighlightMode::maybe_highlighting_region(sup_placeholder, has_sup, || {\n+                match (has_sub, has_sup) {\n+                    (Some(n1), Some(n2)) => {\n+                        err.note(&format!(\n+                            \"`{}` must implement `{}` \\\n+                             for any two lifetimes `'{}` and `'{}`\",\n+                            expected_trait_ref.self_ty(),\n+                            expected_trait_ref,\n+                            std::cmp::min(n1, n2),\n+                            std::cmp::max(n1, n2),\n+                        ));\n+                    }\n+                    (Some(n), _) | (_, Some(n)) => {\n+                        err.note(&format!(\n+                            \"`{}` must implement `{}` \\\n+                             for any lifetime `'{}`\",\n+                            expected_trait_ref.self_ty(),\n+                            expected_trait_ref,\n+                            n,\n+                        ));\n+                    }\n+                    (None, None) => {\n+                        err.note(&format!(\n+                            \"`{}` must implement `{}`\",\n+                            expected_trait_ref.self_ty(),\n+                            expected_trait_ref,\n+                        ));\n                     }\n                 }\n-                _ => {}\n-            });\n-\n-        maybe_highlight(\n-            sub_placeholder,\n-            has_sub,\n-            RegionHighlightMode::highlighting_placeholder,\n-            || {\n-                maybe_highlight(\n-                    sup_placeholder,\n-                    has_sup,\n-                    RegionHighlightMode::highlighting_placeholder,\n-                    || match (has_sub, has_sup) {\n-                        (Some(n1), Some(n2)) => {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}` \\\n-                                 for any two lifetimes `'{}` and `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                std::cmp::min(n1, n2),\n-                                std::cmp::max(n1, n2),\n-                            ));\n-                        }\n-                        (Some(n), _) | (_, Some(n)) => {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}` \\\n-                                 for any lifetime `'{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                                n,\n-                            ));\n-                        }\n-                        (None, None) => {\n-                            err.note(&format!(\n-                                \"`{}` must implement `{}`\",\n-                                expected_trait_ref.self_ty(),\n-                                expected_trait_ref,\n-                            ));\n-                        }\n-                    },\n-                )\n-            },\n-        );\n+            })\n+        });\n \n-        maybe_highlight(\n-            vid,\n-            has_vid,\n-            RegionHighlightMode::highlighting_region_vid,\n-            || match has_vid {\n-                Some(n) => {\n-                    err.note(&format!(\n-                        \"but `{}` only implements `{}` for some lifetime `'{}`\",\n-                        actual_trait_ref.self_ty(),\n-                        actual_trait_ref,\n-                        n\n-                    ));\n-                }\n-                None => {\n-                    err.note(&format!(\n-                        \"but `{}` only implements `{}`\",\n-                        actual_trait_ref.self_ty(),\n-                        actual_trait_ref,\n-                    ));\n-                }\n-            },\n-        );\n+        RegionHighlightMode::maybe_highlighting_region(vid, has_vid, || match has_vid {\n+            Some(n) => {\n+                err.note(&format!(\n+                    \"but `{}` only implements `{}` for some lifetime `'{}`\",\n+                    actual_trait_ref.self_ty(),\n+                    actual_trait_ref,\n+                    n\n+                ));\n+            }\n+            None => {\n+                err.note(&format!(\n+                    \"but `{}` only implements `{}`\",\n+                    actual_trait_ref.self_ty(),\n+                    actual_trait_ref,\n+                ));\n+            }\n+        });\n \n         err.emit();\n         ErrorReported\n     }\n }\n-\n-/// If both `thing` and `counter` are `Some`, invoke\n-/// `highlighting_func` with their contents (and the `op`). Else just\n-/// invoke `op`.\n-fn maybe_highlight<T, F, R>(\n-    thing: Option<T>,\n-    counter: Option<usize>,\n-    highlighting_func: impl FnOnce(T, usize, F) -> R,\n-    op: F,\n-) -> R\n-where\n-    F: FnOnce() -> R,\n-{\n-    if let Some(thing) = thing {\n-        if let Some(n) = counter {\n-            return highlighting_func(thing, n, op);\n-        }\n-    }\n-    op()\n-}"}, {"sha": "0742d0aebe954b2c583ac06d325c42e45519fe73", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 84, "deletions": 66, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/77924de4a66b55d2c863cf66ff9f427d3ae79788/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77924de4a66b55d2c863cf66ff9f427d3ae79788/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=77924de4a66b55d2c863cf66ff9f427d3ae79788", "patch": "@@ -9,7 +9,7 @@ use ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n-use ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n use util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n@@ -30,10 +30,9 @@ use hir;\n /// unaffected.\n #[derive(Copy, Clone, Default)]\n pub struct RegionHighlightMode {\n-    /// If enabled, when we see the selected region inference\n-    /// variable, use `\"'N\"`; otherwise, use an empty string `\"\"`\n-    /// (which is our ordinary behavior).\n-    highlight_region_vid: Option<(RegionVid, usize)>,\n+    /// If enabled, when we see the selected region, use `\"'N\"`\n+    /// instead of the ordinary behavior.\n+    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n \n     /// If enabled, when printing a \"free region\" that originated from\n     /// the given `ty::BoundRegion`, print it as `'1`. Free regions that would ordinarily\n@@ -43,13 +42,6 @@ pub struct RegionHighlightMode {\n     /// y: &'a u32)` and we want to give a name to the region of the\n     /// reference `x`.\n     highlight_bound_region: Option<(ty::BoundRegion, usize)>,\n-\n-    /// If enabled, when printing a \"placeholder\" (what we get when\n-    /// substituting a universally quantified region as in `for<'a> T:\n-    /// Foo<'a>`), print out instead `'N`.\n-    ///\n-    /// (Unlike other modes, we can highlight more than one placeholder at a time.)\n-    highlight_placeholders: [Option<(ty::PlaceholderRegion, usize)>; 2],\n }\n \n thread_local! {\n@@ -79,20 +71,72 @@ impl RegionHighlightMode {\n         })\n     }\n \n+    /// If `region` and `number` are both `Some`, invoke\n+    /// `highlighting_region`. Otherwise, just invoke `op` directly.\n+    pub fn maybe_highlighting_region<R>(\n+        region: Option<ty::Region<'_>>,\n+        number: Option<usize>,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        if let Some(k) = region {\n+            if let Some(n) = number {\n+                return Self::highlighting_region(k, n, op);\n+            }\n+        }\n+\n+        op()\n+    }\n+\n     /// During the execution of `op`, highlight the region inference\n     /// vairable `vid` as `'N`.  We can only highlight one region vid\n     /// at a time.\n-    pub fn highlighting_region_vid<R>(vid: RegionVid, number: usize, op: impl FnOnce() -> R) -> R {\n+    pub fn highlighting_region<R>(region: ty::Region<'_>, number: usize, op: impl FnOnce() -> R) -> R {\n         let old_mode = Self::get();\n-        assert!(old_mode.highlight_region_vid.is_none());\n-        Self::set(\n-            old_mode,\n-            Self {\n-                highlight_region_vid: Some((vid, number)),\n-                ..old_mode\n-            },\n-            op,\n-        )\n+        let mut new_mode = old_mode;\n+        let first_avail_slot = new_mode.highlight_regions.iter_mut()\n+            .filter(|s| s.is_none())\n+            .next()\n+            .unwrap_or_else(|| {\n+                panic!(\n+                    \"can only highlight {} placeholders at a time\",\n+                    old_mode.highlight_regions.len(),\n+                )\n+            });\n+        *first_avail_slot = Some((*region, number));\n+        Self::set(old_mode, new_mode, op)\n+    }\n+\n+    /// Convenience wrapper for `highlighting_region`\n+    pub fn highlighting_region_vid<R>(\n+        vid: ty::RegionVid,\n+        number: usize,\n+        op: impl FnOnce() -> R,\n+    ) -> R {\n+        Self::highlighting_region(&ty::ReVar(vid), number, op)\n+    }\n+\n+    /// Returns true if any placeholders are highlighted.\n+    fn any_region_vids_highlighted(&self) -> bool {\n+        Self::get()\n+            .highlight_regions\n+            .iter()\n+            .any(|h| match h {\n+                Some((ty::ReVar(_), _)) => true,\n+                _ => false,\n+            })\n+    }\n+\n+    /// Returns `Some(n)` with the number to use for the given region,\n+    /// if any.\n+    fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n+        Self::get()\n+            .highlight_regions\n+            .iter()\n+            .filter_map(|h| match h {\n+                Some((r, n)) if r == region => Some(*n),\n+                _ => None,\n+            })\n+            .next()\n     }\n \n     /// During the execution of `op`, highlight the given bound\n@@ -115,50 +159,20 @@ impl RegionHighlightMode {\n         )\n     }\n \n-    /// During the execution of `op`, highlight the given placeholders\n-    /// with the given numbers. Unlike other modes: non-highlighted\n-    /// placeholders are printed as `'_` (where they might normally print\n-    /// differently. This may want to be tweaked; but we do it for two reasons\n-    ///\n-    /// (a) to draw attention to the placeholders we are trying to highlight\n-    /// (b) because placeholder names can come from other scopes than the one\n-    ///     in which the error occurred, so that can be misleading.\n-    ///\n-    /// We can highlight up to two placeholders at a time.\n-    pub fn highlighting_placeholder<R>(\n-        placeholder: ty::PlaceholderRegion,\n-        number: usize,\n-        op: impl FnOnce() -> R,\n-    ) -> R {\n-        let old_mode = Self::get();\n-        let mut new_mode = old_mode;\n-        let first_avail_slot = new_mode.highlight_placeholders.iter_mut()\n-            .filter(|s| s.is_none())\n-            .next()\n-            .unwrap_or_else(|| {\n-                panic!(\n-                    \"can only highlight {} placeholders at a time\",\n-                    old_mode.highlight_placeholders.len(),\n-                )\n-            });\n-        *first_avail_slot = Some((placeholder, number));\n-        Self::set(old_mode, new_mode, op)\n-    }\n-\n     /// Returns true if any placeholders are highlighted.\n     pub fn any_placeholders_highlighted(&self) -> bool {\n-        self.highlight_placeholders.iter().any(|p| p.is_some())\n+        Self::get()\n+            .highlight_regions\n+            .iter()\n+            .any(|h| match h {\n+                Some((ty::RePlaceholder(_), _)) => true,\n+                _ => false,\n+            })\n     }\n \n     /// Returns `Some(N)` if the placeholder `p` is highlighted to print as `'N`.\n     pub fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n-        self.highlight_placeholders\n-            .iter()\n-            .filter_map(|h| match h {\n-                &Some((h, n)) if h == p => Some(n),\n-                _ => None,\n-            })\n-            .next()\n+        self.region_highlighted(&ty::RePlaceholder(p))\n     }\n }\n \n@@ -886,6 +900,11 @@ define_print! {\n                 return self.print_debug(f, cx);\n             }\n \n+            // Watch out for region highlights.\n+            if let Some(n) = RegionHighlightMode::get().region_highlighted(self) {\n+                return write!(f, \"'{:?}\", n);\n+            }\n+\n             // These printouts are concise.  They do not contain all the information\n             // the user might want to diagnose an error, but there is basically no way\n             // to fit that into a short string.  Hence the recommendation to use\n@@ -920,7 +939,7 @@ define_print! {\n                     }\n                 }\n                 ty::ReVar(region_vid) => {\n-                    if RegionHighlightMode::get().highlight_region_vid.is_some() {\n+                    if RegionHighlightMode::get().any_region_vids_highlighted() {\n                         write!(f, \"{:?}\", region_vid)\n                     } else if cx.identify_regions {\n                         write!(f, \"'{}rv\", region_vid.index())\n@@ -1057,12 +1076,11 @@ impl fmt::Debug for ty::FloatVid {\n \n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some((region, counter)) = RegionHighlightMode::get().highlight_region_vid {\n-            debug!(\"RegionVid.fmt: region={:?} self={:?} counter={:?}\", region, self, counter);\n-            return if *self == region {\n-                write!(f, \"'{:?}\", counter)\n+        if RegionHighlightMode::get().any_region_vids_highlighted() {\n+            if let Some(counter) = RegionHighlightMode::get().region_highlighted(&ty::ReVar(*self)) {\n+                return write!(f, \"'{:?}\", counter);\n             } else {\n-                write!(f, \"'_\")\n+                return write!(f, \"'_\");\n             }\n         }\n "}]}