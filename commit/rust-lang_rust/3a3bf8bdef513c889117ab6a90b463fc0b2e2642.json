{"sha": "3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhM2JmOGJkZWY1MTNjODg5MTE3YWI2YTkwYjQ2M2ZjMGIyZTI2NDI=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-05-30T03:22:08Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-30T05:21:55Z"}, "message": "Remove all of the `#[inline(always)]` attributes from bigint", "tree": {"sha": "2a83ec6da49af331790eebc054d68061df1aec06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a83ec6da49af331790eebc054d68061df1aec06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "html_url": "https://github.com/rust-lang/rust/commit/3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a3bf8bdef513c889117ab6a90b463fc0b2e2642/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e67bfabbf7f9ccff329371460ee245161d9ee52b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e67bfabbf7f9ccff329371460ee245161d9ee52b", "html_url": "https://github.com/rust-lang/rust/commit/e67bfabbf7f9ccff329371460ee245161d9ee52b"}], "stats": {"total": 224, "additions": 112, "deletions": 112}, "files": [{"sha": "263618ed56f9b37c5278e72d7d848b35635bf626", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/3a3bf8bdef513c889117ab6a90b463fc0b2e2642/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a3bf8bdef513c889117ab6a90b463fc0b2e2642/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=3a3bf8bdef513c889117ab6a90b463fc0b2e2642", "patch": "@@ -58,19 +58,19 @@ pub mod BigDigit {\n     priv static hi_mask: uint = (-1 as uint) << bits;\n     priv static lo_mask: uint = (-1 as uint) >> bits;\n \n-    #[inline(always)]\n+\n     priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-    #[inline(always)]\n+\n     priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n-    #[inline(always)]\n+\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n-    #[inline(always)]\n+\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n@@ -88,40 +88,40 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n-    #[inline(always)]\n+\n     fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n-    #[inline(always)]\n+\n     fn ne(&self, other: &BigUint) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigUint {\n-    #[inline(always)]\n+\n     fn equals(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigUint {\n-    #[inline(always)]\n+\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-    #[inline(always)]\n+\n     fn le(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn ge(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn gt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigUint {\n-    #[inline(always)]\n+\n     fn cmp(&self, other: &BigUint) -> Ordering {\n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len < o_len { return Less; }\n@@ -139,12 +139,12 @@ impl TotalOrd for BigUint {\n }\n \n impl ToStr for BigUint {\n-    #[inline(always)]\n+\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigUint {\n-    #[inline(always)]\n+\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -153,25 +153,25 @@ impl FromStr for BigUint {\n impl Num for BigUint {}\n \n impl Orderable for BigUint {\n-    #[inline(always)]\n+\n     fn min(&self, other: &BigUint) -> BigUint {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn max(&self, other: &BigUint) -> BigUint {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn clamp(&self, mn: &BigUint, mx: &BigUint) -> BigUint {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -180,7 +180,7 @@ impl Shl<uint, BigUint> for BigUint {\n }\n \n impl Shr<uint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -189,22 +189,22 @@ impl Shr<uint, BigUint> for BigUint {\n }\n \n impl Zero for BigUint {\n-    #[inline(always)]\n+\n     fn zero() -> BigUint { BigUint::new(~[]) }\n \n-    #[inline(always)]\n+\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n-    #[inline(always)]\n+\n     fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -224,7 +224,7 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -280,7 +280,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n-        #[inline(always)]\n+\n         fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n             if n == 1 { return copy *a; }\n@@ -297,15 +297,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod + [carry]);\n         }\n \n-        #[inline(always)]\n+\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n             return (BigUint::from_slice(vec::slice(a.data, mid,\n                                                    a.data.len())),\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n-        #[inline(always)]\n+\n         fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n                 Less    => (Less,    b - a),\n@@ -317,45 +317,45 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Div<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn div(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n-    #[inline(always)]\n+\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n impl Integer for BigUint {\n-    #[inline(always)]\n+\n     fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.div_mod_floor(other)\n     }\n \n-    #[inline(always)]\n+\n     fn div_floor(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-    #[inline(always)]\n+\n     fn mod_floor(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-    #[inline(always)]\n+\n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n@@ -377,7 +377,7 @@ impl Integer for BigUint {\n         let (d, m) = div_mod_floor_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n-        #[inline(always)]\n+\n         fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut m = a;\n             let mut d = Zero::zero::<BigUint>();\n@@ -408,7 +408,7 @@ impl Integer for BigUint {\n             return (d, m);\n         }\n \n-        #[inline(always)]\n+\n         fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n@@ -442,7 +442,7 @@ impl Integer for BigUint {\n      *\n      * The result is always positive\n      */\n-    #[inline(always)]\n+\n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n         let mut m = copy *self, n = copy *other;\n@@ -457,15 +457,15 @@ impl Integer for BigUint {\n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-    #[inline(always)]\n+\n     fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+\n     fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+\n     fn is_even(&self) -> bool {\n         // Considering only the last digit.\n         if self.data.is_empty() {\n@@ -476,24 +476,24 @@ impl Integer for BigUint {\n     }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n impl IntConvertible for BigUint {\n-    #[inline(always)]\n+\n     fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n-    #[inline(always)]\n+\n     fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n impl ToStrRadix for BigUint {\n-    #[inline(always)]\n+\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n@@ -502,7 +502,7 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n-        #[inline(always)]\n+\n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n@@ -518,7 +518,7 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n-        #[inline(always)]\n+\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let s = str::concat(vec::reversed(v).map(|n| {\n@@ -532,7 +532,7 @@ impl ToStrRadix for BigUint {\n \n impl FromStrRadix for BigUint {\n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(str::to_bytes(s), radix)\n@@ -541,7 +541,7 @@ impl FromStrRadix for BigUint {\n \n impl BigUint {\n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n@@ -553,7 +553,7 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n@@ -563,13 +563,13 @@ impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(vec::to_owned(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n-    #[inline(always)]\n+\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -596,7 +596,7 @@ impl BigUint {\n         }\n     }\n \n-    #[inline(always)]\n+\n     pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n@@ -606,14 +606,14 @@ impl BigUint {\n         }\n     }\n \n-    #[inline(always)]\n+\n     priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return copy *self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n-    #[inline(always)]\n+\n     priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n@@ -629,7 +629,7 @@ impl BigUint {\n         return BigUint::new(shifted + [carry]);\n     }\n \n-    #[inline(always)]\n+\n     priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n@@ -638,7 +638,7 @@ impl BigUint {\n         );\n     }\n \n-    #[inline(always)]\n+\n     priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return copy *self; }\n \n@@ -653,7 +653,7 @@ impl BigUint {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-#[inline(always)]\n+\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -679,7 +679,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n-#[inline(always)]\n+\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -707,26 +707,26 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n-    #[inline(always)]\n+\n     fn lt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-    #[inline(always)]\n+\n     fn le(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn ge(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn gt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for Sign {\n-    #[inline(always)]\n+\n     fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n@@ -738,7 +738,7 @@ impl TotalOrd for Sign {\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n-    #[inline(always)]\n+\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n@@ -756,40 +756,40 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-    #[inline(always)]\n+\n     fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n-    #[inline(always)]\n+\n     fn ne(&self, other: &BigInt) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigInt {\n-    #[inline(always)]\n+\n     fn equals(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigInt {\n-    #[inline(always)]\n+\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n-    #[inline(always)]\n+\n     fn le(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn ge(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n-    #[inline(always)]\n+\n     fn gt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigInt {\n-    #[inline(always)]\n+\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);\n         if scmp != Equal { return scmp; }\n@@ -803,12 +803,12 @@ impl TotalOrd for BigInt {\n }\n \n impl ToStr for BigInt {\n-    #[inline(always)]\n+\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl FromStr for BigInt {\n-    #[inline(always)]\n+\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n@@ -817,69 +817,69 @@ impl FromStr for BigInt {\n impl Num for BigInt {}\n \n impl Orderable for BigInt {\n-    #[inline(always)]\n+\n     fn min(&self, other: &BigInt) -> BigInt {\n         if self < other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn max(&self, other: &BigInt) -> BigInt {\n         if self > other { self.clone() } else { other.clone() }\n     }\n \n-    #[inline(always)]\n+\n     fn clamp(&self, mn: &BigInt, mx: &BigInt) -> BigInt {\n         if self > mx { mx.clone() } else\n         if self < mn { mn.clone() } else { self.clone() }\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-    #[inline(always)]\n+\n     fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n-    #[inline(always)]\n+\n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n-    #[inline(always)]\n+\n     fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Signed for BigInt {\n-    #[inline(always)]\n+\n     fn abs(&self) -> BigInt {\n         match self.sign {\n             Plus | Zero => self.clone(),\n             Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn abs_sub(&self, other: &BigInt) -> BigInt {\n         if *self <= *other { Zero::zero() } else { *self - *other }\n     }\n \n-    #[inline(always)]\n+\n     fn signum(&self) -> BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n@@ -888,15 +888,15 @@ impl Signed for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn is_positive(&self) -> bool { self.sign == Plus }\n \n-    #[inline(always)]\n+\n     fn is_negative(&self) -> bool { self.sign == Minus }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => other.clone(),\n@@ -911,7 +911,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -929,7 +929,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -944,30 +944,30 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Div<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn div(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n-    #[inline(always)]\n+\n     fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), self.data.clone())\n     }\n }\n \n impl Integer for BigInt {\n-    #[inline(always)]\n+\n     fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n@@ -982,19 +982,19 @@ impl Integer for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn div_floor(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n-    #[inline(always)]\n+\n     fn mod_floor(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n-    #[inline(always)]\n+\n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.div_rem(&other.data);\n@@ -1022,34 +1022,34 @@ impl Integer for BigInt {\n      *\n      * The result is always positive\n      */\n-    #[inline(always)]\n+\n     fn gcd(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n     }\n \n     /**\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n-    #[inline(always)]\n+\n     fn lcm(&self, other: &BigInt) -> BigInt {\n         BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-    #[inline(always)]\n+\n     fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n \n     /// Returns `true` if the number is divisible by `2`\n-    #[inline(always)]\n+\n     fn is_even(&self) -> bool { self.data.is_even() }\n \n     /// Returns `true` if the number is not divisible by `2`\n-    #[inline(always)]\n+\n     fn is_odd(&self) -> bool { self.data.is_odd() }\n }\n \n impl IntConvertible for BigInt {\n-    #[inline(always)]\n+\n     fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n@@ -1059,7 +1059,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n+\n     fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n@@ -1074,7 +1074,7 @@ impl IntConvertible for BigInt {\n }\n \n impl ToStrRadix for BigInt {\n-    #[inline(always)]\n+\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n@@ -1086,7 +1086,7 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n         BigInt::parse_bytes(str::to_bytes(s), radix)\n@@ -1095,13 +1095,13 @@ impl FromStrRadix for BigInt {\n \n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n@@ -1110,20 +1110,20 @@ pub impl BigInt {\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n-    #[inline(always)]\n+\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -1137,7 +1137,7 @@ pub impl BigInt {\n             .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-    #[inline(always)]\n+\n     fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),"}]}