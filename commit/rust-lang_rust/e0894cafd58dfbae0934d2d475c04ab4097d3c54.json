{"sha": "e0894cafd58dfbae0934d2d475c04ab4097d3c54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwODk0Y2FmZDU4ZGZiYWUwOTM0ZDJkNDc1YzA0YWI0MDk3ZDNjNTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-09T18:51:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-09T18:51:18Z"}, "message": "Rollup merge of #37627 - GuillaumeGomez:missing_urls_bis, r=frewsxcv\n\nAdd missing urls and few local rewrites\n\nr? @steveklabnik", "tree": {"sha": "7f68793fa00943861559dd0d3603e0b6b92852cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f68793fa00943861559dd0d3603e0b6b92852cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0894cafd58dfbae0934d2d475c04ab4097d3c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0894cafd58dfbae0934d2d475c04ab4097d3c54", "html_url": "https://github.com/rust-lang/rust/commit/e0894cafd58dfbae0934d2d475c04ab4097d3c54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0894cafd58dfbae0934d2d475c04ab4097d3c54/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aad4f29f7be65f41a55d89f23b27321431e756b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aad4f29f7be65f41a55d89f23b27321431e756b8", "html_url": "https://github.com/rust-lang/rust/commit/aad4f29f7be65f41a55d89f23b27321431e756b8"}, {"sha": "f2ff9857cd74132486538cc92c491fa2c331c9b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ff9857cd74132486538cc92c491fa2c331c9b4", "html_url": "https://github.com/rust-lang/rust/commit/f2ff9857cd74132486538cc92c491fa2c331c9b4"}], "stats": {"total": 146, "additions": 92, "deletions": 54}, "files": [{"sha": "f6b74a91c193b7110fb8561ae626f327bd960de4", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 92, "deletions": 54, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/e0894cafd58dfbae0934d2d475c04ab4097d3c54/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0894cafd58dfbae0934d2d475c04ab4097d3c54/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=e0894cafd58dfbae0934d2d475c04ab4097d3c54", "patch": "@@ -35,11 +35,14 @@ pub trait Iterator {\n \n     /// Advances the iterator and returns the next value.\n     ///\n-    /// Returns `None` when iteration is finished. Individual iterator\n+    /// Returns [`None`] when iteration is finished. Individual iterator\n     /// implementations may choose to resume iteration, and so calling `next()`\n-    /// again may or may not eventually start returning `Some(Item)` again at some\n+    /// again may or may not eventually start returning [`Some(Item)`] again at some\n     /// point.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(Item)`]: ../../std/option/enum.Option.html#variant.Some\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -69,9 +72,9 @@ pub trait Iterator {\n     /// Specifically, `size_hint()` returns a tuple where the first element\n     /// is the lower bound, and the second element is the upper bound.\n     ///\n-    /// The second half of the tuple that is returned is an `Option<usize>`. A\n-    /// `None` here means that either there is no known upper bound, or the\n-    /// upper bound is larger than `usize`.\n+    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// A [`None`] here means that either there is no known upper bound, or the\n+    /// upper bound is larger than [`usize`].\n     ///\n     /// # Implementation notes\n     ///\n@@ -91,6 +94,10 @@ pub trait Iterator {\n     /// The default implementation returns `(0, None)` which is correct for any\n     /// iterator.\n     ///\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`Option`]: ../../std/option/enum.Option.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -134,23 +141,26 @@ pub trait Iterator {\n     /// Consumes the iterator, counting the number of iterations and returning it.\n     ///\n     /// This method will evaluate the iterator until its [`next()`] returns\n-    /// `None`. Once `None` is encountered, `count()` returns the number of\n+    /// [`None`]. Once [`None`] is encountered, `count()` returns the number of\n     /// times it called [`next()`].\n     ///\n     /// [`next()`]: #tymethod.next\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so counting elements of\n-    /// an iterator with more than `usize::MAX` elements either produces the\n+    /// an iterator with more than [`usize::MAX`] elements either produces the\n     /// wrong result or panics. If debug assertions are enabled, a panic is\n     /// guaranteed.\n     ///\n     /// # Panics\n     ///\n-    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// This function might panic if the iterator has more than [`usize::MAX`]\n     /// elements.\n     ///\n+    /// [`usize::MAX`]: ../../std/isize/constant.MAX.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -172,10 +182,12 @@ pub trait Iterator {\n \n     /// Consumes the iterator, returning the last element.\n     ///\n-    /// This method will evaluate the iterator until it returns `None`. While\n-    /// doing so, it keeps track of the current element. After `None` is\n+    /// This method will evaluate the iterator until it returns [`None`]. While\n+    /// doing so, it keeps track of the current element. After [`None`] is\n     /// returned, `last()` will then return the last element it saw.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -202,9 +214,11 @@ pub trait Iterator {\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on.\n     ///\n-    /// `nth()` will return `None` if `n` is greater than or equal to the length of the\n+    /// `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n     /// iterator.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -306,8 +320,8 @@ pub trait Iterator {\n     ///\n     /// In other words, it zips two iterators together, into a single one.\n     ///\n-    /// When either iterator returns `None`, all further calls to `next()`\n-    /// will return `None`.\n+    /// When either iterator returns [`None`], all further calls to [`next()`]\n+    /// will return [`None`].\n     ///\n     /// # Examples\n     ///\n@@ -346,7 +360,7 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// `zip()` is often used to zip an infinite iterator to a finite one.\n-    /// This works because the finite iterator will eventually return `None`,\n+    /// This works because the finite iterator will eventually return [`None`],\n     /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate()`]:\n     ///\n     /// ```\n@@ -365,6 +379,8 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+    /// [`next()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n@@ -501,23 +517,21 @@ pub trait Iterator {\n     ///\n     /// The closure must return an [`Option<T>`]. `filter_map()` creates an\n     /// iterator which calls this closure on each element. If the closure\n-    /// returns `Some(element)`, then that element is returned. If the\n-    /// closure returns `None`, it will try again, and call the closure on the\n-    /// next element, seeing if it will return `Some`.\n-    ///\n-    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    /// returns [`Some(element)`][`Some`], then that element is returned. If the\n+    /// closure returns [`None`], it will try again, and call the closure on the\n+    /// next element, seeing if it will return [`Some`].\n     ///\n     /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n     /// part:\n     ///\n     /// [`filter()`]: #method.filter\n     /// [`map()`]: #method.map\n     ///\n-    /// > If the closure returns `Some(element)`, then that element is returned.\n+    /// > If the closure returns [`Some(element)`][`Some`], then that element is returned.\n     ///\n     /// In other words, it removes the [`Option<T>`] layer automatically. If your\n     /// mapping is already returning an [`Option<T>`] and you want to skip over\n-    /// `None`s, then `filter_map()` is much, much nicer to use.\n+    /// [`None`]s, then `filter_map()` is much, much nicer to use.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +561,11 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     ///\n-    /// There's an extra layer of `Some` in there.\n+    /// There's an extra layer of [`Some`] in there.\n+    ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n@@ -567,21 +585,20 @@ pub trait Iterator {\n     /// different sized integer, the [`zip()`] function provides similar\n     /// functionality.\n     ///\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    /// [`zip()`]: #method.zip\n-    ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so enumerating more than\n     /// [`usize::MAX`] elements either produces the wrong result or panics. If\n     /// debug assertions are enabled, a panic is guaranteed.\n     ///\n-    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n-    ///\n     /// # Panics\n     ///\n     /// The returned iterator might panic if the to-be-returned index would\n-    /// overflow a `usize`.\n+    /// overflow a [`usize`].\n+    ///\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`zip()`]: #method.zip\n     ///\n     /// # Examples\n     ///\n@@ -607,12 +624,13 @@ pub trait Iterator {\n     /// Adds a [`peek()`] method to an iterator. See its documentation for\n     /// more information.\n     ///\n-    /// Note that the underlying iterator is still advanced when `peek` is\n+    /// Note that the underlying iterator is still advanced when [`peek()`] is\n     /// called for the first time: In order to retrieve the next element,\n-    /// `next` is called on the underlying iterator, hence any side effects of\n-    /// the `next` method will occur.\n+    /// [`next()`] is called on the underlying iterator, hence any side effects of\n+    /// the [`next()`] method will occur.\n     ///\n     /// [`peek()`]: struct.Peekable.html#method.peek\n+    /// [`next()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n     ///\n     /// # Examples\n     ///\n@@ -894,12 +912,12 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n-    /// [`map()`]: #method.map\n-    ///\n     /// Another way of thinking about `flat_map()`: [`map()`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n+    /// [`map()`]: #method.map\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -921,11 +939,14 @@ pub trait Iterator {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n-    /// Creates an iterator which ends after the first `None`.\n+    /// Creates an iterator which ends after the first [`None`].\n     ///\n-    /// After an iterator returns `None`, future calls may or may not yield\n-    /// `Some(T)` again. `fuse()` adapts an iterator, ensuring that after a\n-    /// `None` is given, it will always return `None` forever.\n+    /// After an iterator returns [`None`], future calls may or may not yield\n+    /// [`Some(T)`] again. `fuse()` adapts an iterator, ensuring that after a\n+    /// [`None`] is given, it will always return [`None`] forever.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(T)`]: ../../std/option/enum.Option.html#variant.Some\n     ///\n     /// # Examples\n     ///\n@@ -1082,19 +1103,15 @@ pub trait Iterator {\n     /// library, used in a variety of contexts.\n     ///\n     /// The most basic pattern in which `collect()` is used is to turn one\n-    /// collection into another. You take a collection, call `iter()` on it,\n+    /// collection into another. You take a collection, call [`iter()`] on it,\n     /// do a bunch of transformations, and then `collect()` at the end.\n     ///\n     /// One of the keys to `collect()`'s power is that many things you might\n     /// not think of as 'collections' actually are. For example, a [`String`]\n     /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n-    /// be thought of as single `Result<Collection<T>, E>`. See the examples\n+    /// be thought of as single [`Result`]`<Collection<T>, E>`. See the examples\n     /// below for more.\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// Because `collect()` is so general, it can cause problems with type\n     /// inference. As such, `collect()` is one of the few times you'll see\n     /// the syntax affectionately known as the 'turbofish': `::<>`. This\n@@ -1172,7 +1189,7 @@ pub trait Iterator {\n     /// assert_eq!(\"hello\", hello);\n     /// ```\n     ///\n-    /// If you have a list of [`Result<T, E>`]s, you can use `collect()` to\n+    /// If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n     /// see if any of them failed:\n     ///\n     /// ```\n@@ -1190,6 +1207,11 @@ pub trait Iterator {\n     /// // gives us the list of answers\n     /// assert_eq!(Ok(vec![1, 3]), result);\n     /// ```\n+    ///\n+    /// [`iter()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`Result`]: ../../std/result/enum.Result.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n@@ -1281,6 +1303,8 @@ pub trait Iterator {\n     /// use a `for` loop with a list of things to build up a result. Those\n     /// can be turned into `fold()`s:\n     ///\n+    /// [`for`]: ../../book/loops.html#for\n+    ///\n     /// ```\n     /// let numbers = [1, 2, 3, 4, 5];\n     ///\n@@ -1414,8 +1438,8 @@ pub trait Iterator {\n     ///\n     /// `find()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, and if any of them return\n-    /// `true`, then `find()` returns `Some(element)`. If they all return\n-    /// `false`, it returns `None`.\n+    /// `true`, then `find()` returns [`Some(element)`]. If they all return\n+    /// `false`, it returns [`None`].\n     ///\n     /// `find()` is short-circuiting; in other words, it will stop processing\n     /// as soon as the closure returns `true`.\n@@ -1425,6 +1449,9 @@ pub trait Iterator {\n     /// argument is a double reference. You can see this effect in the\n     /// examples below, with `&&x`.\n     ///\n+    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1465,16 +1492,16 @@ pub trait Iterator {\n     ///\n     /// `position()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, and if one of them\n-    /// returns `true`, then `position()` returns `Some(index)`. If all of\n-    /// them return `false`, it returns `None`.\n+    /// returns `true`, then `position()` returns [`Some(index)`]. If all of\n+    /// them return `false`, it returns [`None`].\n     ///\n     /// `position()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so if there are more\n-    /// than `usize::MAX` non-matching elements, it either produces the wrong\n+    /// than [`usize::MAX`] non-matching elements, it either produces the wrong\n     /// result or panics. If debug assertions are enabled, a panic is\n     /// guaranteed.\n     ///\n@@ -1483,6 +1510,10 @@ pub trait Iterator {\n     /// This function might panic if the iterator has more than `usize::MAX`\n     /// non-matching elements.\n     ///\n+    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1528,11 +1559,14 @@ pub trait Iterator {\n     /// `rposition()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, starting from the end,\n     /// and if one of them returns `true`, then `rposition()` returns\n-    /// `Some(index)`. If all of them return `false`, it returns `None`.\n+    /// [`Some(index)`]. If all of them return `false`, it returns [`None`].\n     ///\n     /// `rposition()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n+    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1798,11 +1832,13 @@ pub trait Iterator {\n         (ts, us)\n     }\n \n-    /// Creates an iterator which `clone()`s all of its elements.\n+    /// Creates an iterator which [`clone()`]s all of its elements.\n     ///\n     /// This is useful when you have an iterator over `&T`, but you need an\n     /// iterator over `T`.\n     ///\n+    /// [`clone()`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1827,10 +1863,12 @@ pub trait Iterator {\n \n     /// Repeats an iterator endlessly.\n     ///\n-    /// Instead of stopping at `None`, the iterator will instead start again,\n+    /// Instead of stopping at [`None`], the iterator will instead start again,\n     /// from the beginning. After iterating again, it will start at the\n     /// beginning again. And again. And again. Forever.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1862,7 +1900,7 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// When calling `sum` and a primitive integer type is being returned, this\n+    /// When calling `sum()` and a primitive integer type is being returned, this\n     /// method will panic if the computation overflows and debug assertions are\n     /// enabled.\n     ///\n@@ -1890,7 +1928,7 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// When calling `product` and a primitive integer type is being returned,\n+    /// When calling `product()` and a primitive integer type is being returned,\n     /// method will panic if the computation overflows and debug assertions are\n     /// enabled.\n     ///"}]}