{"sha": "2153d1e560a2de06ddd60f29df86c342f1f83a90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNTNkMWU1NjBhMmRlMDZkZGQ2MGYyOWRmODZjMzQyZjFmODNhOTA=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2017-10-23T19:20:37Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2017-10-23T21:53:30Z"}, "message": "manual fixups if_let_chain -> if_chain", "tree": {"sha": "1baf0219e4234b2a899cb28883485ffeac898d1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1baf0219e4234b2a899cb28883485ffeac898d1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2153d1e560a2de06ddd60f29df86c342f1f83a90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2153d1e560a2de06ddd60f29df86c342f1f83a90", "html_url": "https://github.com/rust-lang/rust/commit/2153d1e560a2de06ddd60f29df86c342f1f83a90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2153d1e560a2de06ddd60f29df86c342f1f83a90/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41840ae3c41483745ff92f3ba8e99f9ffcb3dff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/41840ae3c41483745ff92f3ba8e99f9ffcb3dff8", "html_url": "https://github.com/rust-lang/rust/commit/41840ae3c41483745ff92f3ba8e99f9ffcb3dff8"}], "stats": {"total": 188, "additions": 96, "deletions": 92}, "files": [{"sha": "ab9ba4a9327b0651f6767b9486e4b5d3377e4a2a", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2153d1e560a2de06ddd60f29df86c342f1f83a90/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2153d1e560a2de06ddd60f29df86c342f1f83a90/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=2153d1e560a2de06ddd60f29df86c342f1f83a90", "patch": "@@ -140,12 +140,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         let parent_fn = cx.tcx.hir.get_parent(e.id);\n                                         let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n                                         // the crate node is the only one that is not in the map\n-                                        if_let_chain!{[\n-                                            parent_impl != ast::CRATE_NODE_ID,\n-                                            let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl),\n-                                            let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node,\n-                                            trait_ref.path.def.def_id() == trait_id\n-                                        ], { return; }}\n+                                        if_chain! {\n+                                            if parent_impl != ast::CRATE_NODE_ID;\n+                                            if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n+                                            if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+                                            if trait_ref.path.def.def_id() == trait_id;\n+                                            then { return; }\n+                                        }\n                                         implements_trait($cx, $ty, trait_id, &[$rty])\n                                     },)*\n                                     _ => false,"}, {"sha": "31a9de871b466fbcf20d33f263cf1ced29974a19", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2153d1e560a2de06ddd60f29df86c342f1f83a90/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2153d1e560a2de06ddd60f29df86c342f1f83a90/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=2153d1e560a2de06ddd60f29df86c342f1f83a90", "patch": "@@ -142,11 +142,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                                                                       span,\n                                                                       \"try this\",\n                                                                       &format!(\n-    \"impl Default for {} {{\n-        fn default() -> Self {{\n-            Self::new()\n-        }}\n-    }}\",\n+\"impl Default for {} {{\n+    fn default() -> Self {{\n+        Self::new()\n+    }}\n+}}\",\n                                                                                self_ty));\n                                             });\n                                         }"}, {"sha": "a4bdcd152904eda1c942a446ac11fdbe77c9ab16", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 69, "deletions": 67, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2153d1e560a2de06ddd60f29df86c342f1f83a90/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2153d1e560a2de06ddd60f29df86c342f1f83a90/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=2153d1e560a2de06ddd60f29df86c342f1f83a90", "patch": "@@ -28,15 +28,16 @@ use std::collections::HashMap;\n /// prints\n ///\n /// ```\n-/// if_let_chain!{[\n-///     let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n-///     let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     let Expr_::ExprPath(ref path) = left.node,\n-///     let Expr_::ExprLit(ref lit) = right.node,\n-///     let LitKind::Int(42, _) = lit.node,\n-/// ], {\n-///     // report your lint here\n-/// }}\n+/// if_chain!{\n+///     if let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n+///     if let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n+///     if let Expr_::ExprPath(ref path) = left.node,\n+///     if let Expr_::ExprLit(ref lit) = right.node,\n+///     if let LitKind::Int(42, _) = lit.node,\n+///     then {\n+///         // report your lint here\n+///     }\n+/// }\n /// ```\n declare_lint! {\n     pub LINT_AUTHOR,\n@@ -53,13 +54,14 @@ impl LintPass for Pass {\n }\n \n fn prelude() {\n-    println!(\"if_let_chain!{{[\");\n+    println!(\"if_chain! {{\");\n }\n \n fn done() {\n-    println!(\"], {{\");\n-    println!(\"    // report your lint here\");\n-    println!(\"}}}}\");\n+    println!(\"    then {{\");\n+    println!(\"        // report your lint here\");\n+    println!(\"    }}\");\n+    println!(\"}}\");\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n@@ -181,36 +183,36 @@ struct PrintVisitor {\n \n impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n-        print!(\"    let Expr_::Expr\");\n+        print!(\"    if let Expr_::Expr\");\n         let current = format!(\"{}.node\", self.current);\n         match expr.node {\n             Expr_::ExprBox(ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n-                println!(\"Box(ref {}) = {},\", inner_pat, current);\n+                println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             Expr_::ExprArray(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n-                println!(\"Array(ref {}) = {},\", elements_pat, current);\n-                println!(\"    {}.len() == {},\", elements_pat, elements.len());\n+                println!(\"Array(ref {}) = {};\", elements_pat, current);\n+                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n                 for (i, element) in elements.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", elements_pat, i);\n                     self.visit_expr(element);\n                 }\n             },\n             Expr_::ExprCall(ref _func, ref _args) => {\n-                println!(\"Call(ref func, ref args) = {},\", current);\n+                println!(\"Call(ref func, ref args) = {};\", current);\n                 println!(\"    // unimplemented: `ExprCall` is not further destructured at the moment\");\n             },\n             Expr_::ExprMethodCall(ref _method_name, ref _generics, ref _args) => {\n-                println!(\"MethodCall(ref method_name, ref generics, ref args) = {},\", current);\n+                println!(\"MethodCall(ref method_name, ref generics, ref args) = {};\", current);\n                 println!(\"    // unimplemented: `ExprMethodCall` is not further destructured at the moment\");\n             },\n             Expr_::ExprTup(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n-                println!(\"Tup(ref {}) = {},\", elements_pat, current);\n-                println!(\"    {}.len() == {},\", elements_pat, elements.len());\n+                println!(\"Tup(ref {}) = {};\", elements_pat, current);\n+                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n                 for (i, element) in elements.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", elements_pat, i);\n                     self.visit_expr(element);\n@@ -220,51 +222,51 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n-                println!(\"Binary(ref {}, ref {}, ref {}) = {},\", op_pat, left_pat, right_pat, current);\n-                println!(\"    BinOp_::{:?} == {}.node,\", op.node, op_pat);\n+                println!(\"Binary(ref {}, ref {}, ref {}) = {};\", op_pat, left_pat, right_pat, current);\n+                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = left_pat;\n                 self.visit_expr(left);\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n             Expr_::ExprUnary(ref op, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n-                println!(\"Unary(UnOp::{:?}, ref {}) = {},\", op, inner_pat, current);\n+                println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             Expr_::ExprLit(ref lit) => {\n                 let lit_pat = self.next(\"lit\");\n-                println!(\"Lit(ref {}) = {},\", lit_pat, current);\n+                println!(\"Lit(ref {}) = {};\", lit_pat, current);\n                 match lit.node {\n-                    LitKind::Bool(val) => println!(\"    let LitKind::Bool({:?}) = {}.node,\", val, lit_pat),\n-                    LitKind::Char(c) => println!(\"    let LitKind::Char({:?}) = {}.node,\", c, lit_pat),\n-                    LitKind::Byte(b) => println!(\"    let LitKind::Byte({}) = {}.node,\", b, lit_pat),\n+                    LitKind::Bool(val) => println!(\"    if let LitKind::Bool({:?}) = {}.node;\", val, lit_pat),\n+                    LitKind::Char(c) => println!(\"    if let LitKind::Char({:?}) = {}.node;\", c, lit_pat),\n+                    LitKind::Byte(b) => println!(\"    if let LitKind::Byte({}) = {}.node;\", b, lit_pat),\n                     // FIXME: also check int type\n-                    LitKind::Int(i, _) => println!(\"    let LitKind::Int({}, _) = {}.node,\", i, lit_pat),\n-                    LitKind::Float(..) => println!(\"    let LitKind::Float(..) = {}.node,\", lit_pat),\n-                    LitKind::FloatUnsuffixed(_) => println!(\"    let LitKind::FloatUnsuffixed(_) = {}.node,\", lit_pat),\n+                    LitKind::Int(i, _) => println!(\"    if let LitKind::Int({}, _) = {}.node;\", i, lit_pat),\n+                    LitKind::Float(..) => println!(\"    if let LitKind::Float(..) = {}.node;\", lit_pat),\n+                    LitKind::FloatUnsuffixed(_) => println!(\"    if let LitKind::FloatUnsuffixed(_) = {}.node;\", lit_pat),\n                     LitKind::ByteStr(ref vec) => {\n                         let vec_pat = self.next(\"vec\");\n-                        println!(\"    let LitKind::ByteStr(ref {}) = {}.node,\", vec_pat, lit_pat);\n-                        println!(\"    let [{:?}] = **{},\", vec, vec_pat);\n+                        println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);\n+                        println!(\"    if let [{:?}] = **{};\", vec, vec_pat);\n                     },\n                     LitKind::Str(ref text, _) => {\n                         let str_pat = self.next(\"s\");\n-                        println!(\"    let LitKind::Str(ref {}) = {}.node,\", str_pat, lit_pat);\n-                        println!(\"    {}.as_str() == {:?}\", str_pat, &*text.as_str())\n+                        println!(\"    if let LitKind::Str(ref {}) = {}.node;\", str_pat, lit_pat);\n+                        println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str())\n                     },\n                 }\n             },\n             Expr_::ExprCast(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n-                println!(\"Cast(ref {}, _) = {},\", cast_pat, current);\n+                println!(\"Cast(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n             Expr_::ExprType(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n-                println!(\"Type(ref {}, _) = {},\", cast_pat, current);\n+                println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n@@ -273,49 +275,49 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let then_pat = self.next(\"then\");\n                 if let Some(ref else_) = *opt_else {\n                     let else_pat = self.next(\"else_\");\n-                    println!(\"If(ref {}, ref {}, Some(ref {})) = {},\", cond_pat, then_pat, else_pat, current);\n+                    println!(\"If(ref {}, ref {}, Some(ref {})) = {};\", cond_pat, then_pat, else_pat, current);\n                     self.current = else_pat;\n                     self.visit_expr(else_);\n                 } else {\n-                    println!(\"If(ref {}, ref {}, None) = {},\", cond_pat, then_pat, current);\n+                    println!(\"If(ref {}, ref {}, None) = {};\", cond_pat, then_pat, current);\n                 }\n                 self.current = cond_pat;\n                 self.visit_expr(cond);\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n             Expr_::ExprWhile(ref _cond, ref _body, ref _opt_label) => {\n-                println!(\"While(ref cond, ref body, ref opt_label) = {},\", current);\n+                println!(\"While(ref cond, ref body, ref opt_label) = {};\", current);\n                 println!(\"    // unimplemented: `ExprWhile` is not further destructured at the moment\");\n             },\n             Expr_::ExprLoop(ref _body, ref _opt_label, ref _desuraging) => {\n-                println!(\"Loop(ref body, ref opt_label, ref desugaring) = {},\", current);\n+                println!(\"Loop(ref body, ref opt_label, ref desugaring) = {};\", current);\n                 println!(\"    // unimplemented: `ExprLoop` is not further destructured at the moment\");\n             },\n             Expr_::ExprMatch(ref _expr, ref _arms, ref _desugaring) => {\n-                println!(\"Match(ref expr, ref arms, ref desugaring) = {},\", current);\n+                println!(\"Match(ref expr, ref arms, ref desugaring) = {};\", current);\n                 println!(\"    // unimplemented: `ExprMatch` is not further destructured at the moment\");\n             },\n             Expr_::ExprClosure(ref _capture_clause, ref _func, _, _, _) => {\n-                println!(\"Closure(ref capture_clause, ref func, _, _, _) = {},\", current);\n+                println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n                 println!(\"    // unimplemented: `ExprClosure` is not further destructured at the moment\");\n             },\n             Expr_::ExprYield(ref sub) => {\n                 let sub_pat = self.next(\"sub\");\n-                println!(\"Yield(ref sub) = {},\", current);\n+                println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n             Expr_::ExprBlock(ref block) => {\n                 let block_pat = self.next(\"block\");\n-                println!(\"Block(ref {}) = {},\", block_pat, current);\n+                println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n             Expr_::ExprAssign(ref target, ref value) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n-                println!(\"Assign(ref {}, ref {}) = {},\", target_pat, value_pat, current);\n+                println!(\"Assign(ref {}, ref {}) = {};\", target_pat, value_pat, current);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n                 self.current = value_pat;\n@@ -325,8 +327,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n-                println!(\"AssignOp(ref {}, ref {}, ref {}) = {},\", op_pat, target_pat, value_pat, current);\n-                println!(\"    BinOp_::{:?} == {}.node,\", op.node, op_pat);\n+                println!(\"AssignOp(ref {}, ref {}, ref {}) = {};\", op_pat, target_pat, value_pat, current);\n+                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n                 self.current = value_pat;\n@@ -335,67 +337,67 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             Expr_::ExprField(ref object, ref field_name) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n-                println!(\"Field(ref {}, ref {}) = {},\", obj_pat, field_name_pat, current);\n-                println!(\"    {}.node.as_str() == {:?}\", field_name_pat, field_name.node.as_str());\n+                println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n+                println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_name.node.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n             Expr_::ExprTupField(ref object, ref field_id) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_id_pat = self.next(\"field_id\");\n-                println!(\"TupField(ref {}, ref {}) = {},\", obj_pat, field_id_pat, current);\n-                println!(\"    {}.node == {}\", field_id_pat, field_id.node);\n+                println!(\"TupField(ref {}, ref {}) = {};\", obj_pat, field_id_pat, current);\n+                println!(\"    if {}.node == {}\", field_id_pat, field_id.node);\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n             Expr_::ExprIndex(ref object, ref index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n-                println!(\"Index(ref {}, ref {}) = {},\", object_pat, index_pat, current);\n+                println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n                 self.current = object_pat;\n                 self.visit_expr(object);\n                 self.current = index_pat;\n                 self.visit_expr(index);\n             },\n             Expr_::ExprPath(ref path) => {\n                 let path_pat = self.next(\"path\");\n-                println!(\"Path(ref {}) = {},\", path_pat, current);\n+                println!(\"Path(ref {}) = {};\", path_pat, current);\n                 self.current = path_pat;\n                 self.visit_qpath(path, expr.id, expr.span);\n             },\n             Expr_::ExprAddrOf(mutability, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n-                println!(\"AddrOf({:?}, ref {}) = {},\", mutability, inner_pat, current);\n+                println!(\"AddrOf({:?}, ref {}) = {};\", mutability, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             Expr_::ExprBreak(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n                 if let Some(ref value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n-                    println!(\"Break(ref {}, Some(ref {})) = {},\", destination_pat, value_pat, current);\n+                    println!(\"Break(ref {}, Some(ref {})) = {};\", destination_pat, value_pat, current);\n                     self.current = value_pat;\n                     self.visit_expr(value);\n                 } else {\n-                    println!(\"Break(ref {}, None) = {},\", destination_pat, current);\n+                    println!(\"Break(ref {}, None) = {};\", destination_pat, current);\n                 }\n                 // FIXME: implement label printing\n             },\n             Expr_::ExprAgain(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n-                println!(\"Again(ref {}) = {},\", destination_pat, current);\n+                println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n             Expr_::ExprRet(ref opt_value) => if let Some(ref value) = *opt_value {\n                 let value_pat = self.next(\"value\");\n-                println!(\"Ret(Some(ref {})) = {},\", value_pat, current);\n+                println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             } else {\n-                println!(\"Ret(None) = {},\", current);\n+                println!(\"Ret(None) = {};\", current);\n             },\n             Expr_::ExprInlineAsm(_, ref _input, ref _output) => {\n-                println!(\"InlineAsm(_, ref input, ref output) = {},\", current);\n+                println!(\"InlineAsm(_, ref input, ref output) = {};\", current);\n                 println!(\"    // unimplemented: `ExprInlineAsm` is not further destructured at the moment\");\n             },\n             Expr_::ExprStruct(ref path, ref fields, ref opt_base) => {\n@@ -404,7 +406,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 if let Some(ref base) = *opt_base {\n                     let base_pat = self.next(\"base\");\n                     println!(\n-                        \"Struct(ref {}, ref {}, Some(ref {})) = {},\",\n+                        \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n                         path_pat,\n                         fields_pat,\n                         base_pat,\n@@ -413,17 +415,17 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.current = base_pat;\n                     self.visit_expr(base);\n                 } else {\n-                    println!(\"Struct(ref {}, ref {}, None) = {},\", path_pat, fields_pat, current);\n+                    println!(\"Struct(ref {}, ref {}, None) = {};\", path_pat, fields_pat, current);\n                 }\n                 self.current = path_pat;\n                 self.visit_qpath(path, expr.id, expr.span);\n-                println!(\"    {}.len() == {},\", fields_pat, fields.len());\n+                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n             // FIXME: compute length (needs type info)\n             Expr_::ExprRepeat(ref value, _) => {\n                 let value_pat = self.next(\"value\");\n-                println!(\"Repeat(ref {}, _) = {},\", value_pat, current);\n+                println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");\n                 self.current = value_pat;\n                 self.visit_expr(value);\n@@ -432,9 +434,9 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n \n     fn visit_qpath(&mut self, path: &QPath, _: NodeId, _: Span) {\n-        print!(\"    match_qpath({}, &[\", self.current);\n+        print!(\"    if match_qpath({}, &[\", self.current);\n         print_path(path, &mut true);\n-        println!(\"]),\");\n+        println!(\"]);\");\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None"}, {"sha": "145c102ed95b1631fd2146cc595e29d2a59d9930", "filename": "tests/ui/trailing_zeros.stdout", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2153d1e560a2de06ddd60f29df86c342f1f83a90/tests%2Fui%2Ftrailing_zeros.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2153d1e560a2de06ddd60f29df86c342f1f83a90/tests%2Fui%2Ftrailing_zeros.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stdout?ref=2153d1e560a2de06ddd60f29df86c342f1f83a90", "patch": "@@ -1,14 +1,15 @@\n-if_let_chain!{[\n-    let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node,\n-    BinOp_::BiEq == op.node,\n-    let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node,\n-    BinOp_::BiBitAnd == op1.node,\n-    let Expr_::ExprPath(ref path) = left1.node,\n-    match_qpath(path, &[\"x\"]),\n-    let Expr_::ExprLit(ref lit) = right1.node,\n-    let LitKind::Int(15, _) = lit.node,\n-    let Expr_::ExprLit(ref lit1) = right.node,\n-    let LitKind::Int(0, _) = lit1.node,\n-], {\n-    // report your lint here\n-}}\n+if_chain! {\n+    if let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node;\n+    if BinOp_::BiEq == op.node;\n+    if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n+    if BinOp_::BiBitAnd == op1.node;\n+    if let Expr_::ExprPath(ref path) = left1.node;\n+    if match_qpath(path, &[\"x\"]);\n+    if let Expr_::ExprLit(ref lit) = right1.node;\n+    if let LitKind::Int(15, _) = lit.node;\n+    if let Expr_::ExprLit(ref lit1) = right.node;\n+    if let LitKind::Int(0, _) = lit1.node;\n+    then {\n+        // report your lint here\n+    }\n+}"}]}