{"sha": "5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54", "node_id": "C_kwDOAAsO6NoAKDVjOTk1MDAyM2JmNmZiZDJmNTVhNGU5ZTVmMWE1NDc5M2JjZmRlNTQ", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2021-08-21T12:39:28Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2021-12-13T20:36:35Z"}, "message": "Suggest remove on const async const instead of const const async", "tree": {"sha": "baef253d7d4a6ad6b85c3f4343b4ed18b376eeda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baef253d7d4a6ad6b85c3f4343b4ed18b376eeda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54", "html_url": "https://github.com/rust-lang/rust/commit/5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bc8577d99d521ea600ede94f2a8ed3bcd6eb4fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc8577d99d521ea600ede94f2a8ed3bcd6eb4fb", "html_url": "https://github.com/rust-lang/rust/commit/7bc8577d99d521ea600ede94f2a8ed3bcd6eb4fb"}], "stats": {"total": 61, "additions": 45, "deletions": 16}, "files": [{"sha": "6ea86fe9f45d76bb72e60e1224efafeef449e372", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=5c9950023bf6fbd2f55a4e9e5f1a54793bcfde54", "patch": "@@ -1938,33 +1938,62 @@ impl<'a> Parser<'a> {\n                 Ok(false) => unreachable!(),\n                 Err(mut err) => {\n                     // Qualifier keywords ordering check\n+                    enum WrongKw {\n+                        Duplicated(Span),\n+                        Misplaced(Span),\n+                    }\n \n-                    // This will allow the machine fix to directly place the keyword in the correct place\n-                    let current_qual_sp = if self.check_keyword(kw::Const) {\n-                        Some(async_start_sp)\n+                    // This will allow the machine fix to directly place the keyword in the correct place or to indicate\n+                    // that the keyword is already present and the second instance should be removed.\n+                    let wrong_kw = if self.check_keyword(kw::Const) {\n+                        match constness {\n+                            Const::Yes(sp) => Some(WrongKw::Duplicated(sp)),\n+                            Const::No => Some(WrongKw::Misplaced(async_start_sp)),\n+                        }\n                     } else if self.check_keyword(kw::Async) {\n-                        Some(unsafe_start_sp)\n+                        match asyncness {\n+                            Async::Yes { span, .. } => Some(WrongKw::Duplicated(span)),\n+                            Async::No => Some(WrongKw::Misplaced(unsafe_start_sp)),\n+                        }\n                     } else if self.check_keyword(kw::Unsafe) {\n-                        Some(ext_start_sp)\n+                        match unsafety {\n+                            Unsafe::Yes(sp) => Some(WrongKw::Duplicated(sp)),\n+                            Unsafe::No => Some(WrongKw::Misplaced(ext_start_sp)),\n+                        }\n                     } else {\n                         None\n                     };\n \n-                    if let Some(current_qual_sp) = current_qual_sp {\n-                        let current_qual_sp = current_qual_sp.to(self.prev_token.span);\n-                        if let Ok(current_qual) = self.span_to_snippet(current_qual_sp) {\n-                            let invalid_qual_sp = self.token.uninterpolated_span();\n-                            let invalid_qual = self.span_to_snippet(invalid_qual_sp).unwrap();\n+                    // The keyword is already present, suggest removal of the second instance\n+                    if let Some(WrongKw::Duplicated(original_sp)) = wrong_kw {\n+                        let original_kw = self\n+                            .span_to_snippet(original_sp)\n+                            .expect(\"Span extracted directly from keyword should always work\");\n+\n+                        err.span_suggestion(\n+                            self.token.uninterpolated_span(),\n+                            &format!(\"`{}` already used earlier, remove this one\", original_kw),\n+                            \"\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .span_note(original_sp, &format!(\"`{}` first seen here\", original_kw));\n+                    }\n+                    // The keyword has not been seen yet, suggest correct placement in the function front matter\n+                    else if let Some(WrongKw::Misplaced(correct_pos_sp)) = wrong_kw {\n+                        let correct_pos_sp = correct_pos_sp.to(self.prev_token.span);\n+                        if let Ok(current_qual) = self.span_to_snippet(correct_pos_sp) {\n+                            let misplaced_qual_sp = self.token.uninterpolated_span();\n+                            let misplaced_qual = self.span_to_snippet(misplaced_qual_sp).unwrap();\n \n                             err.span_suggestion(\n-                                current_qual_sp.to(invalid_qual_sp),\n-                                &format!(\"`{}` must come before `{}`\", invalid_qual, current_qual),\n-                                format!(\"{} {}\", invalid_qual, current_qual),\n-                                Applicability::MachineApplicable,\n-                            ).note(\"keyword order for functions declaration is `default`, `pub`, `const`, `async`, `unsafe`, `extern`\");\n+                                    correct_pos_sp.to(misplaced_qual_sp),\n+                                    &format!(\"`{}` must come before `{}`\", misplaced_qual, current_qual),\n+                                    format!(\"{} {}\", misplaced_qual, current_qual),\n+                                    Applicability::MachineApplicable,\n+                                ).note(\"keyword order for functions declaration is `default`, `pub`, `const`, `async`, `unsafe`, `extern`\");\n                         }\n                     }\n-                    // Recover incorrect visibility order such as `async pub`.\n+                    // Recover incorrect visibility order such as `async pub`\n                     else if self.check_keyword(kw::Pub) {\n                         let orig_vis = vis.unwrap_or(&Visibility {\n                             span: rustc_span::DUMMY_SP,"}]}