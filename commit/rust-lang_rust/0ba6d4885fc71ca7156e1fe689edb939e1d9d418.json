{"sha": "0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYTZkNDg4NWZjNzFjYTcxNTZlMWZlNjg5ZWRiOTM5ZTFkOWQ0MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-16T15:11:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-16T15:11:34Z"}, "message": "auto merge of #12313 : bjz/rust/tuple, r=huonw\n\nThis renames the `n*` and `n*_ref` tuple getters to `val*` and `ref*` respectively, and adds `mut*` getters. It also removes the `CloneableTuple` and `ImmutableTuple` traits.", "tree": {"sha": "157894361cfedb2ef3cd231a6b7b2d144a5db8dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/157894361cfedb2ef3cd231a6b7b2d144a5db8dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "html_url": "https://github.com/rust-lang/rust/commit/0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fe775e2b5eaa77dd49c1d9a234c67d52e5f9087", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe775e2b5eaa77dd49c1d9a234c67d52e5f9087", "html_url": "https://github.com/rust-lang/rust/commit/6fe775e2b5eaa77dd49c1d9a234c67d52e5f9087"}, {"sha": "f450b2b379794ba9f367f9dadbd2d70913da8560", "url": "https://api.github.com/repos/rust-lang/rust/commits/f450b2b379794ba9f367f9dadbd2d70913da8560", "html_url": "https://github.com/rust-lang/rust/commit/f450b2b379794ba9f367f9dadbd2d70913da8560"}], "stats": {"total": 500, "additions": 193, "deletions": 307}, "files": [{"sha": "03c67276049ec32fefa8ac3e633b5109737554c2", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -95,13 +95,9 @@ syn keyword rustTrait Buffer Writer Reader Seek\n syn keyword rustTrait Str StrVector StrSlice OwnedStr IntoMaybeOwned\n syn keyword rustTrait IterBytes\n syn keyword rustTrait ToStr IntoStr\n-syn keyword rustTrait CloneableTuple ImmutableTuple\n syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8\n syn keyword rustTrait Tuple9 Tuple10 Tuple11 Tuple12\n-syn keyword rustTrait ImmutableTuple1 ImmutableTuple2 ImmutableTuple3 ImmutableTuple4\n-syn keyword rustTrait ImmutableTuple5 ImmutableTuple6 ImmutableTuple7 ImmutableTuple8\n-syn keyword rustTrait ImmutableTuple9 ImmutableTuple10 ImmutableTuple11 ImmutableTuple12\n syn keyword rustTrait ImmutableEqVector ImmutableTotalOrdVector ImmutableCloneableVector\n syn keyword rustTrait OwnedVector OwnedCloneableVector OwnedEqVector MutableVector\n syn keyword rustTrait Vector VectorVector CloneableVector ImmutableVector"}, {"sha": "13b39da0756e0db46e42ab9d52e451375d7137e1", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -500,15 +500,15 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                     let new_outcome = self.clone().rightmost_child.insert(k.clone(),\n                                                                        v.clone(),\n                                                                        ub.clone());\n-                    new_branch = new_outcome.clone().n0();\n-                    outcome = new_outcome.n1();\n+                    new_branch = new_outcome.clone().val0();\n+                    outcome = new_outcome.val1();\n                 }\n                 else {\n                     let new_outcome = self.clone().elts[index.unwrap()].left.insert(k.clone(),\n                                                                                  v.clone(),\n                                                                                  ub.clone());\n-                    new_branch = new_outcome.clone().n0();\n-                    outcome = new_outcome.n1();\n+                    new_branch = new_outcome.clone().val0();\n+                    outcome = new_outcome.val1();\n                 }\n                 //Check to see whether a branch or a leaf was returned from the\n                 //tree traversal."}, {"sha": "b796535371f7a0be7c44f16e799a5c118c09d216", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -529,7 +529,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n             let mut tmps = vec::with_capacity(env.len());\n \n             for pair in env.iter() {\n-                let kv = format!(\"{}={}\", pair.first(), pair.second());\n+                let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());\n                 tmps.push(kv.to_c_str());\n             }\n \n@@ -553,7 +553,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n             let mut blk = ~[];\n \n             for pair in env.iter() {\n-                let kv = format!(\"{}={}\", pair.first(), pair.second());\n+                let kv = format!(\"{}={}\", *pair.ref0(), *pair.ref1());\n                 blk.push_all(kv.as_bytes());\n                 blk.push(0);\n             }"}, {"sha": "fc5e48a161f1329653829a7dac036cea136f8089", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -599,7 +599,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess.span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = vec::from_elem(n, const_expr(cx, elem, is_local).first());\n+            let vs = vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(vs, false)\n             } else {"}, {"sha": "0dcbfe491c312e3eb121bc4c0f23bfb660a875ec", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -4604,7 +4604,7 @@ pub fn determine_inherited_purity(parent: (ast::Purity, ast::NodeId),\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n     match child_sigil {\n-        ast::BorrowedSigil if child.first() == ast::ImpureFn => parent,\n+        ast::BorrowedSigil if child.val0() == ast::ImpureFn => parent,\n         _ => child\n     }\n }"}, {"sha": "11f801550856b019ee98b2d7b09b1ae4432726ff", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -1379,11 +1379,11 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n         match c.impls.find(&it.id) {\n             Some(v) => {\n                 let mut non_trait = v.iter().filter(|p| {\n-                    p.n0_ref().trait_.is_none()\n+                    p.ref0().trait_.is_none()\n                 });\n                 let non_trait = non_trait.to_owned_vec();\n                 let mut traits = v.iter().filter(|p| {\n-                    p.n0_ref().trait_.is_some()\n+                    p.ref0().trait_.is_some()\n                 });\n                 let traits = traits.to_owned_vec();\n "}, {"sha": "24c9d81e5308d2bf7ecb5d90941a22ae6155df1c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -262,7 +262,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n-            Some(i) => PASSES[i].n1(),\n+            Some(i) => PASSES[i].val1(),\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);\n                 continue"}, {"sha": "e5a89fc42e1521227a2029373d607ffdcafae7ef", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -2611,7 +2611,7 @@ mod tests {\n         assert_eq!(vi.size_hint(), (10, Some(10)));\n \n         assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n-        assert_eq!(c.skip(5).size_hint().second(), None);\n+        assert_eq!(c.skip(5).size_hint().val1(), None);\n         assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n         assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n         assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));"}, {"sha": "bd21bb4e75444a5b5fd58ea0dfc3f8e51c1113c5", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -67,10 +67,6 @@ pub use io::{Buffer, Writer, Reader, Seek};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, IntoStr};\n-pub use tuple::{CloneableTuple, ImmutableTuple};\n-pub use tuple::{ImmutableTuple1, ImmutableTuple2, ImmutableTuple3, ImmutableTuple4};\n-pub use tuple::{ImmutableTuple5, ImmutableTuple6, ImmutableTuple7, ImmutableTuple8};\n-pub use tuple::{ImmutableTuple9, ImmutableTuple10, ImmutableTuple11, ImmutableTuple12};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};"}, {"sha": "0a7f513581c0db0c31014cae742555b2d040711f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -567,14 +567,14 @@ impl<'a> Iterator<&'a str> for StrSplits<'a> {\n // Helper functions used for Unicode normalization\n fn canonical_sort(comb: &mut [(char, u8)]) {\n     use iter::range;\n-    use tuple::CloneableTuple;\n+    use tuple::Tuple2;\n \n     let len = comb.len();\n     for i in range(0, len) {\n         let mut swapped = false;\n         for j in range(1, len-i) {\n-            let classA = comb[j-1].second();\n-            let classB = comb[j].second();\n+            let classA = *comb[j-1].ref1();\n+            let classB = *comb[j].ref1();\n             if classA != 0 && classB != 0 && classA > classB {\n                 comb.swap(j-1, j);\n                 swapped = true;"}, {"sha": "ab14e9f566778664caad83207aa7744b54dbbf7b", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -40,17 +40,6 @@ impl ToStr for () {\n     fn to_str(&self) -> ~str { ~\"()\" }\n }\n \n-impl<A:ToStr> ToStr for (A,) {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            (ref a,) => {\n-                format!(\"({},)\", (*a).to_str())\n-            }\n-        }\n-    }\n-}\n-\n impl<A:ToStr+Hash+Eq, B:ToStr> ToStr for HashMap<A, B> {\n     #[inline]\n     fn to_str(&self) -> ~str {\n@@ -91,36 +80,6 @@ impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n     }\n }\n \n-impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        // FIXME(#4653): this causes an llvm assertion\n-        //let &(ref a, ref b) = self;\n-        match *self {\n-            (ref a, ref b) => {\n-                format!(\"({}, {})\", (*a).to_str(), (*b).to_str())\n-            }\n-        }\n-    }\n-}\n-\n-impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        // FIXME(#4653): this causes an llvm assertion\n-        //let &(ref a, ref b, ref c) = self;\n-        match *self {\n-            (ref a, ref b, ref c) => {\n-                format!(\"({}, {}, {})\",\n-                    (*a).to_str(),\n-                    (*b).to_str(),\n-                    (*c).to_str()\n-                )\n-            }\n-        }\n-    }\n-}\n-\n impl<'a,A:ToStr> ToStr for &'a [A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n@@ -178,13 +137,6 @@ mod tests {\n         assert_eq!((~\"hi\").to_str(), ~\"hi\");\n     }\n \n-    #[test]\n-    fn test_tuple_types() {\n-        assert_eq!((1, 2).to_str(), ~\"(1, 2)\");\n-        assert_eq!((~\"a\", ~\"b\", false).to_str(), ~\"(a, b, false)\");\n-        assert_eq!(((), ((), 100)).to_str(), ~\"((), ((), 100))\");\n-    }\n-\n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = ~[];"}, {"sha": "7a81e69f30ac8b717c8f68f00593692dd0f31c3b", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 175, "deletions": 233, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -15,157 +15,99 @@\n use clone::Clone;\n #[cfg(not(test))] use cmp::*;\n #[cfg(not(test))] use default::Default;\n-\n-/// Method extensions to pairs where both types satisfy the `Clone` bound\n-pub trait CloneableTuple<T, U> {\n-    /// Return the first element of self\n-    fn first(&self) -> T;\n-    /// Return the second element of self\n-    fn second(&self) -> U;\n-    /// Return the results of swapping the two elements of self\n-    fn swap(&self) -> (U, T);\n-}\n-\n-impl<T:Clone,U:Clone> CloneableTuple<T, U> for (T, U) {\n-    /// Return the first element of self\n-    #[inline]\n-    fn first(&self) -> T {\n-        match *self {\n-            (ref t, _) => (*t).clone(),\n-        }\n-    }\n-\n-    /// Return the second element of self\n-    #[inline]\n-    fn second(&self) -> U {\n-        match *self {\n-            (_, ref u) => (*u).clone(),\n-        }\n-    }\n-\n-    /// Return the results of swapping the two elements of self\n-    #[inline]\n-    fn swap(&self) -> (U, T) {\n-        match (*self).clone() {\n-            (t, u) => (u, t),\n-        }\n-    }\n-}\n-\n-/// Method extensions for pairs where the types don't necessarily satisfy the\n-/// `Clone` bound\n-pub trait ImmutableTuple<T, U> {\n-    /// Return a reference to the first element of self\n-    fn first_ref<'a>(&'a self) -> &'a T;\n-    /// Return a reference to the second element of self\n-    fn second_ref<'a>(&'a self) -> &'a U;\n-}\n-\n-impl<T, U> ImmutableTuple<T, U> for (T, U) {\n-    #[inline]\n-    fn first_ref<'a>(&'a self) -> &'a T {\n-        match *self {\n-            (ref t, _) => t,\n-        }\n-    }\n-    #[inline]\n-    fn second_ref<'a>(&'a self) -> &'a U {\n-        match *self {\n-            (_, ref u) => u,\n-        }\n-    }\n-}\n+use fmt;\n+use result::{Ok, Err};\n+use to_str::ToStr;\n \n // macro for implementing n-ary tuple functions and operations\n-\n macro_rules! tuple_impls {\n     ($(\n-        ($move_trait:ident, $immutable_trait:ident) {\n-            $(($get_fn:ident, $get_ref_fn:ident) -> $T:ident {\n-                $move_pattern:pat, $ref_pattern:pat => $ret:expr\n+        $Tuple:ident {\n+            $(($valN:ident, $refN:ident, $mutN:ident) -> $T:ident {\n+                ($($x:ident),+) => $ret:expr\n             })+\n         }\n     )+) => {\n         $(\n-            pub trait $move_trait<$($T),+> {\n-                $(fn $get_fn(self) -> $T;)+\n+            pub trait $Tuple<$($T),+> {\n+                $(fn $valN(self) -> $T;)+\n+                $(fn $refN<'a>(&'a self) -> &'a $T;)+\n+                $(fn $mutN<'a>(&'a mut self) -> &'a mut $T;)+\n             }\n \n-            impl<$($T),+> $move_trait<$($T),+> for ($($T,)+) {\n+            impl<$($T),+> $Tuple<$($T),+> for ($($T,)+) {\n                 $(\n                     #[inline]\n-                    fn $get_fn(self) -> $T {\n-                        let $move_pattern = self;\n-                        $ret\n+                    #[allow(unused_variable)]\n+                    fn $valN(self) -> $T {\n+                        let ($($x,)+) = self; $ret\n                     }\n-                )+\n-            }\n \n-            pub trait $immutable_trait<$($T),+> {\n-                $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n-            }\n+                    #[inline]\n+                    #[allow(unused_variable)]\n+                    fn $refN<'a>(&'a self) -> &'a $T {\n+                        let ($(ref $x,)+) = *self; $ret\n+                    }\n \n-            impl<$($T),+> $immutable_trait<$($T),+> for ($($T,)+) {\n-                $(\n                     #[inline]\n-                    fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n-                        let $ref_pattern = *self;\n-                        $ret\n+                    #[allow(unused_variable)]\n+                    fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n+                        let ($(ref mut $x,)+) = *self; $ret\n                     }\n                 )+\n             }\n \n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n-                    ($(self.$get_ref_fn().clone(),)+)\n+                    ($(self.$refN().clone(),)+)\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n+                    $(*self.$refN() == *other.$refN())&&+\n                 }\n                 #[inline]\n                 fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$get_ref_fn() != *other.$get_ref_fn())||+\n+                    $(*self.$refN() != *other.$refN())||+\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {\n                 #[inline]\n                 fn equals(&self, other: &($($T,)+)) -> bool {\n-                    $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n+                    $(self.$refN().equals(other.$refN()))&&+\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n                 }\n                 #[inline]\n                 fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(le, $(self.$refN(), other.$refN()),+)\n                 }\n                 #[inline]\n                 fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(ge, $(self.$refN(), other.$refN()),+)\n                 }\n                 #[inline]\n                 fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_ord!(gt, $(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n             #[cfg(not(test))]\n             impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    lexical_cmp!($(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n@@ -176,6 +118,18 @@ macro_rules! tuple_impls {\n                     ($({ let x: $T = Default::default(); x},)+)\n                 }\n             }\n+\n+            impl<$($T: fmt::Show),+> ToStr for ($($T,)+) {\n+                fn to_str(&self) -> ~str {\n+                    format!(\"{}\", *self)\n+                }\n+            }\n+\n+            impl<$($T: fmt::Show),+> fmt::Show for ($($T,)+) {\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    write_tuple!(f.buf, $(self.$refN()),+)\n+                }\n+            }\n         )+\n     }\n }\n@@ -202,120 +156,120 @@ macro_rules! lexical_cmp {\n     ($a:expr, $b:expr) => { ($a).cmp($b) };\n }\n \n+macro_rules! write_tuple {\n+    ($buf:expr, $x:expr) => (\n+        write!($buf, \"({},)\", *$x)\n+    );\n+    ($buf:expr, $hd:expr, $($tl:expr),+) => ({\n+        if_ok!(write!($buf, \"(\"));\n+        if_ok!(write!($buf, \"{}\", *$hd));\n+        $(if_ok!(write!($buf, \", {}\", *$tl));)+\n+        write!($buf, \")\")\n+    });\n+}\n \n tuple_impls! {\n-    (Tuple1, ImmutableTuple1) {\n-        (n0, n0_ref) -> A { (a,), (ref a,) => a }\n+    Tuple1 {\n+        (val0, ref0, mut0) -> A { (a) => a }\n     }\n-\n-    (Tuple2, ImmutableTuple2) {\n-        (n0, n0_ref) -> A { (a,_), (ref a,_) => a }\n-        (n1, n1_ref) -> B { (_,b), (_,ref b) => b }\n+    Tuple2 {\n+        (val0, ref0, mut0) -> A { (a, b) => a }\n+        (val1, ref1, mut1) -> B { (a, b) => b }\n     }\n-\n-    (Tuple3, ImmutableTuple3) {\n-        (n0, n0_ref) -> A { (a,_,_), (ref a,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_), (_,ref b,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c), (_,_,ref c) => c }\n+    Tuple3 {\n+        (val0, ref0, mut0) -> A { (a, b, c) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c) => c }\n     }\n-\n-    (Tuple4, ImmutableTuple4) {\n-        (n0, n0_ref) -> A { (a,_,_,_), (ref a,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_), (_,ref b,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_), (_,_,ref c,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d), (_,_,_,ref d) => d }\n+    Tuple4 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d) => d }\n     }\n-\n-    (Tuple5, ImmutableTuple5) {\n-        (n0, n0_ref) -> A { (a,_,_,_,_), (ref a,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_), (_,ref b,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_), (_,_,ref c,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_), (_,_,_,ref d,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e), (_,_,_,_,ref e) => e }\n+    Tuple5 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e) => e }\n     }\n-\n-    (Tuple6, ImmutableTuple6) {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_), (ref a,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_), (_,ref b,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_), (_,_,ref c,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_), (_,_,_,ref d,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_), (_,_,_,_,ref e,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f), (_,_,_,_,_,ref f) => f }\n+    Tuple6 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f) => f }\n     }\n-\n-    (Tuple7, ImmutableTuple7) {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_), (ref a,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_), (_,ref b,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_), (_,_,ref c,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_), (_,_,_,ref d,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_), (_,_,_,_,ref e,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_), (_,_,_,_,_,ref f,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g), (_,_,_,_,_,_,ref g) => g }\n+    Tuple7 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g) => g }\n     }\n-\n-    (Tuple8, ImmutableTuple8) {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_,_), (_,_,ref c,_,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_,_), (_,_,_,ref d,_,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_,_), (_,_,_,_,ref e,_,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_,_), (_,_,_,_,_,ref f,_,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g,_), (_,_,_,_,_,_,ref g,_) => g }\n-        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,h), (_,_,_,_,_,_,_,ref h) => h }\n+    Tuple8 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h) => g }\n+        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h) => h }\n     }\n-\n-    (Tuple9, ImmutableTuple9) {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_,_,_), (_,_,_,_,ref e,_,_,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_,_,_), (_,_,_,_,_,ref f,_,_,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g,_,_), (_,_,_,_,_,_,ref g,_,_) => g }\n-        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,h,_), (_,_,_,_,_,_,_,ref h,_) => h }\n-        (n8, n8_ref) -> I { (_,_,_,_,_,_,_,_,i), (_,_,_,_,_,_,_,_,ref i) => i }\n+    Tuple9 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i) => g }\n+        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i) => h }\n+        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i) => i }\n     }\n-\n-    (Tuple10, ImmutableTuple10) {\n-        (n0, n0_ref) -> A { (a,_,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_,_) => a }\n-        (n1, n1_ref) -> B { (_,b,_,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_,_) => b }\n-        (n2, n2_ref) -> C { (_,_,c,_,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_,_) => c }\n-        (n3, n3_ref) -> D { (_,_,_,d,_,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_,_) => d }\n-        (n4, n4_ref) -> E { (_,_,_,_,e,_,_,_,_,_), (_,_,_,_,ref e,_,_,_,_,_) => e }\n-        (n5, n5_ref) -> F { (_,_,_,_,_,f,_,_,_,_), (_,_,_,_,_,ref f,_,_,_,_) => f }\n-        (n6, n6_ref) -> G { (_,_,_,_,_,_,g,_,_,_), (_,_,_,_,_,_,ref g,_,_,_) => g }\n-        (n7, n7_ref) -> H { (_,_,_,_,_,_,_,h,_,_), (_,_,_,_,_,_,_,ref h,_,_) => h }\n-        (n8, n8_ref) -> I { (_,_,_,_,_,_,_,_,i,_), (_,_,_,_,_,_,_,_,ref i,_) => i }\n-        (n9, n9_ref) -> J { (_,_,_,_,_,_,_,_,_,j), (_,_,_,_,_,_,_,_,_,ref j) => j }\n+    Tuple10 {\n+        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i, j) => a }\n+        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i, j) => b }\n+        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i, j) => c }\n+        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i, j) => d }\n+        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i, j) => e }\n+        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i, j) => f }\n+        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i, j) => g }\n+        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i, j) => h }\n+        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i, j) => i }\n+        (val9, ref9, mut9) -> J { (a, b, c, d, e, f, g, h, i, j) => j }\n     }\n-\n-    (Tuple11, ImmutableTuple11) {\n-        (n0,  n0_ref)  -> A { (a,_,_,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_,_,_) => a }\n-        (n1,  n1_ref)  -> B { (_,b,_,_,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_,_,_) => b }\n-        (n2,  n2_ref)  -> C { (_,_,c,_,_,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_,_,_) => c }\n-        (n3,  n3_ref)  -> D { (_,_,_,d,_,_,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_,_,_) => d }\n-        (n4,  n4_ref)  -> E { (_,_,_,_,e,_,_,_,_,_,_), (_,_,_,_,ref e,_,_,_,_,_,_) => e }\n-        (n5,  n5_ref)  -> F { (_,_,_,_,_,f,_,_,_,_,_), (_,_,_,_,_,ref f,_,_,_,_,_) => f }\n-        (n6,  n6_ref)  -> G { (_,_,_,_,_,_,g,_,_,_,_), (_,_,_,_,_,_,ref g,_,_,_,_) => g }\n-        (n7,  n7_ref)  -> H { (_,_,_,_,_,_,_,h,_,_,_), (_,_,_,_,_,_,_,ref h,_,_,_) => h }\n-        (n8,  n8_ref)  -> I { (_,_,_,_,_,_,_,_,i,_,_), (_,_,_,_,_,_,_,_,ref i,_,_) => i }\n-        (n9,  n9_ref)  -> J { (_,_,_,_,_,_,_,_,_,j,_), (_,_,_,_,_,_,_,_,_,ref j,_) => j }\n-        (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,k), (_,_,_,_,_,_,_,_,_,_,ref k) => k }\n+    Tuple11 {\n+        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k) => a }\n+        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k) => b }\n+        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k) => c }\n+        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k) => d }\n+        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k) => e }\n+        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k) => f }\n+        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k) => g }\n+        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k) => h }\n+        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k) => i }\n+        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k) => j }\n+        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k) => k }\n     }\n-\n-    (Tuple12, ImmutableTuple12) {\n-        (n0,  n0_ref)  -> A { (a,_,_,_,_,_,_,_,_,_,_,_), (ref a,_,_,_,_,_,_,_,_,_,_,_) => a }\n-        (n1,  n1_ref)  -> B { (_,b,_,_,_,_,_,_,_,_,_,_), (_,ref b,_,_,_,_,_,_,_,_,_,_) => b }\n-        (n2,  n2_ref)  -> C { (_,_,c,_,_,_,_,_,_,_,_,_), (_,_,ref c,_,_,_,_,_,_,_,_,_) => c }\n-        (n3,  n3_ref)  -> D { (_,_,_,d,_,_,_,_,_,_,_,_), (_,_,_,ref d,_,_,_,_,_,_,_,_) => d }\n-        (n4,  n4_ref)  -> E { (_,_,_,_,e,_,_,_,_,_,_,_), (_,_,_,_,ref e,_,_,_,_,_,_,_) => e }\n-        (n5,  n5_ref)  -> F { (_,_,_,_,_,f,_,_,_,_,_,_), (_,_,_,_,_,ref f,_,_,_,_,_,_) => f }\n-        (n6,  n6_ref)  -> G { (_,_,_,_,_,_,g,_,_,_,_,_), (_,_,_,_,_,_,ref g,_,_,_,_,_) => g }\n-        (n7,  n7_ref)  -> H { (_,_,_,_,_,_,_,h,_,_,_,_), (_,_,_,_,_,_,_,ref h,_,_,_,_) => h }\n-        (n8,  n8_ref)  -> I { (_,_,_,_,_,_,_,_,i,_,_,_), (_,_,_,_,_,_,_,_,ref i,_,_,_) => i }\n-        (n9,  n9_ref)  -> J { (_,_,_,_,_,_,_,_,_,j,_,_), (_,_,_,_,_,_,_,_,_,ref j,_,_) => j }\n-        (n10, n10_ref) -> K { (_,_,_,_,_,_,_,_,_,_,k,_), (_,_,_,_,_,_,_,_,_,_,ref k,_) => k }\n-        (n11, n11_ref) -> L { (_,_,_,_,_,_,_,_,_,_,_,l), (_,_,_,_,_,_,_,_,_,_,_,ref l) => l }\n+    Tuple12 {\n+        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k, l) => a }\n+        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k, l) => b }\n+        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k, l) => c }\n+        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k, l) => d }\n+        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k, l) => e }\n+        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k, l) => f }\n+        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k, l) => g }\n+        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k, l) => h }\n+        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k, l) => i }\n+        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k, l) => j }\n+        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k, l) => k }\n+        (val11, ref11, mut11) -> L { (a, b, c, d, e, f, g, h, i, j, k, l) => l }\n     }\n }\n \n@@ -325,56 +279,37 @@ mod tests {\n     use clone::Clone;\n     use cmp::*;\n \n-    #[test]\n-    fn test_tuple_ref() {\n-        let x = (~\"foo\", ~\"bar\");\n-        assert_eq!(x.first_ref(), &~\"foo\");\n-        assert_eq!(x.second_ref(), &~\"bar\");\n-    }\n-\n-    #[test]\n-    fn test_tuple() {\n-        assert_eq!((948, 4039.48).first(), 948);\n-        assert_eq!((34.5, ~\"foo\").second(), ~\"foo\");\n-        assert_eq!(('a', 2).swap(), (2, 'a'));\n-    }\n-\n     #[test]\n     fn test_clone() {\n         let a = (1, ~\"2\");\n         let b = a.clone();\n-        assert_eq!(a.first(), b.first());\n-        assert_eq!(a.second(), b.second());\n+        assert_eq!(a, b);\n     }\n \n     #[test]\n-    fn test_n_tuple() {\n-        let t = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n-        assert_eq!(t.n0(), 0u8);\n-        assert_eq!(t.n1(), 1u16);\n-        assert_eq!(t.n2(), 2u32);\n-        assert_eq!(t.n3(), 3u64);\n-        assert_eq!(t.n4(), 4u);\n-        assert_eq!(t.n5(), 5i8);\n-        assert_eq!(t.n6(), 6i16);\n-        assert_eq!(t.n7(), 7i32);\n-        assert_eq!(t.n8(), 8i64);\n-        assert_eq!(t.n9(), 9i);\n-        assert_eq!(t.n10(), 10f32);\n-        assert_eq!(t.n11(), 11f64);\n-\n-        assert_eq!(t.n0_ref(), &0u8);\n-        assert_eq!(t.n1_ref(), &1u16);\n-        assert_eq!(t.n2_ref(), &2u32);\n-        assert_eq!(t.n3_ref(), &3u64);\n-        assert_eq!(t.n4_ref(), &4u);\n-        assert_eq!(t.n5_ref(), &5i8);\n-        assert_eq!(t.n6_ref(), &6i16);\n-        assert_eq!(t.n7_ref(), &7i32);\n-        assert_eq!(t.n8_ref(), &8i64);\n-        assert_eq!(t.n9_ref(), &9i);\n-        assert_eq!(t.n10_ref(), &10f32);\n-        assert_eq!(t.n11_ref(), &11f64);\n+    fn test_getters() {\n+        macro_rules! test_getter(\n+            ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n+             $init:expr, $incr:expr, $result:expr) => ({\n+                assert_eq!($x.$valN(), $init);\n+                assert_eq!(*$x.$refN(), $init);\n+                *$x.$mutN() += $incr;\n+                assert_eq!(*$x.$refN(), $result);\n+            })\n+        )\n+        let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n+        test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n+        test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n+        test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n+        test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n+        test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n+        test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n+        test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n+        test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n+        test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n+        test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n+        test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n+        test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n     }\n \n     #[test]\n@@ -422,4 +357,11 @@ mod tests {\n         assert_eq!(small.cmp(&big), Less);\n         assert_eq!(big.cmp(&small), Greater);\n     }\n+\n+    #[test]\n+    fn test_show() {\n+        assert_eq!(format!(\"{}\", (1,)), ~\"(1,)\");\n+        assert_eq!(format!(\"{}\", (1, true)), ~\"(1, true)\");\n+        assert_eq!(format!(\"{}\", (1, ~\"hi\", true)), ~\"(1, hi, true)\");\n+    }\n }"}, {"sha": "f0c3517a0b88e79f4a27a81348d94dcdc2b85b32", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -51,7 +51,7 @@ impl<'a> Iterator<u8> for AAGen<'a> {\n     fn next(&mut self) -> Option<u8> {\n         let r = self.rng.gen();\n         self.data.iter()\n-            .skip_while(|pc| pc.n0() < r)\n+            .skip_while(|pc| pc.val0() < r)\n             .map(|&(_, c)| c)\n             .next()\n     }"}, {"sha": "51eb65b1d5c7ed7beed723a61c8946523f002f46", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ba6d4885fc71ca7156e1fe689edb939e1d9d418/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "patch": "@@ -90,8 +90,8 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n             State {\n                 managed: @Cons((), st.managed),\n                 unique: ~Cons((), @*st.unique),\n-                tuple: (@Cons((), st.tuple.first()),\n-                        ~Cons((), @*st.tuple.second())),\n+                tuple: (@Cons((), st.tuple.ref0().clone()),\n+                        ~Cons((), @*st.tuple.ref1().clone())),\n                 vec: st.vec + &[@Cons((), *st.vec.last().unwrap())],\n                 res: r(@Cons((), st.res._l))\n             }"}]}