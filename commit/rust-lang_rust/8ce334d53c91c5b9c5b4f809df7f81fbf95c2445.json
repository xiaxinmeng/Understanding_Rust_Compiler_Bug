{"sha": "8ce334d53c91c5b9c5b4f809df7f81fbf95c2445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZTMzNGQ1M2M5MWM1YjljNWI0ZjgwOWRmN2Y4MWZiZjk1YzI0NDU=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-04-02T02:14:51Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-04-14T01:58:17Z"}, "message": "rustfmt", "tree": {"sha": "72b15f10ee35970860c650e3d636be857bf84811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72b15f10ee35970860c650e3d636be857bf84811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ce334d53c91c5b9c5b4f809df7f81fbf95c2445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ce334d53c91c5b9c5b4f809df7f81fbf95c2445", "html_url": "https://github.com/rust-lang/rust/commit/8ce334d53c91c5b9c5b4f809df7f81fbf95c2445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ce334d53c91c5b9c5b4f809df7f81fbf95c2445/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e340375ef8eb551bae29f36bf562aab1162939db", "url": "https://api.github.com/repos/rust-lang/rust/commits/e340375ef8eb551bae29f36bf562aab1162939db", "html_url": "https://github.com/rust-lang/rust/commit/e340375ef8eb551bae29f36bf562aab1162939db"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "bbe059dda6f24cc0cca971a26ea9df363ca8d017", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8ce334d53c91c5b9c5b4f809df7f81fbf95c2445/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ce334d53c91c5b9c5b4f809df7f81fbf95c2445/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8ce334d53c91c5b9c5b4f809df7f81fbf95c2445", "patch": "@@ -10,7 +10,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{GeneratorKind, AsyncGeneratorKind, Node};\n+use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n     self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n@@ -1204,7 +1204,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let generator_body = self.tcx\n+        let generator_body = self\n+            .tcx\n             .hir()\n             .as_local_hir_id(generator_did)\n             .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n@@ -1246,7 +1247,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             })\n             .map(|cause| {\n                 // Check to see if any awaited expressions have the target type.\n-                let from_awaited_ty = visitor.awaits.into_iter()\n+                let from_awaited_ty = visitor\n+                    .awaits\n+                    .into_iter()\n                     .map(|id| self.tcx.hir().expect_expr(id))\n                     .find(|expr| {\n                         let ty = tables.expr_ty_adjusted(&expr);\n@@ -1335,29 +1338,32 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             err.clear_code();\n             err.set_primary_message(format!(\n                 \"{} cannot be {} between threads safely\",\n-                future_or_generator,\n-                trait_verb\n+                future_or_generator, trait_verb\n             ));\n \n             let original_span = err.span.primary_span().unwrap();\n             let mut span = MultiSpan::from_span(original_span);\n \n             let message = outer_generator\n-                .and_then(|generator_did| Some(\n-                    match self.tcx.generator_kind(generator_did).unwrap() {\n+                .and_then(|generator_did| {\n+                    Some(match self.tcx.generator_kind(generator_did).unwrap() {\n                         GeneratorKind::Gen => format!(\"generator is not {}\", trait_name),\n-                        GeneratorKind::Async(AsyncGeneratorKind::Fn) =>\n-                            self.tcx.parent(generator_did)\n-                                .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n-                                .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n-                                .map(|name| format!(\"future returned by `{}` is not {}\",\n-                                                    name, trait_name))?,\n-                        GeneratorKind::Async(AsyncGeneratorKind::Block) =>\n-                            format!(\"future created by async block is not {}\", trait_name),\n-                        GeneratorKind::Async(AsyncGeneratorKind::Closure) =>\n-                            format!(\"future created by async closure is not {}\", trait_name),\n-                    }\n-                ))\n+                        GeneratorKind::Async(AsyncGeneratorKind::Fn) => self\n+                            .tcx\n+                            .parent(generator_did)\n+                            .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                            .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n+                            .map(|name| {\n+                                format!(\"future returned by `{}` is not {}\", name, trait_name)\n+                            })?,\n+                        GeneratorKind::Async(AsyncGeneratorKind::Block) => {\n+                            format!(\"future created by async block is not {}\", trait_name)\n+                        }\n+                        GeneratorKind::Async(AsyncGeneratorKind::Closure) => {\n+                            format!(\"future created by async closure is not {}\", trait_name)\n+                        }\n+                    })\n+                })\n                 .unwrap_or_else(|| format!(\"{} is not {}\", future_or_generator, trait_name));\n \n             span.push_span_label(original_span, message);\n@@ -1384,10 +1390,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         if let Some(await_span) = from_awaited_ty {\n             // The type causing this obligation is one being awaited at await_span.\n             let mut span = MultiSpan::from_span(await_span);\n-            span.push_span_label(\n-                await_span,\n-                \"await occurs here\".to_string(),\n-            );\n+            span.push_span_label(await_span, \"await occurs here\".to_string());\n \n             if target_span != await_span {\n                 push_target_span(&mut span);\n@@ -1422,7 +1425,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n             err.span_note(\n                 span,\n-                &format!(\"{} as this value is used across an {}\", trait_explanation, await_or_yield),\n+                &format!(\n+                    \"{} as this value is used across an {}\",\n+                    trait_explanation, await_or_yield\n+                ),\n             );\n         }\n \n@@ -1784,8 +1790,9 @@ impl<'v> Visitor<'v> for AwaitsVisitor {\n \n     fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n         match ex.kind {\n-            hir::ExprKind::Yield(_, hir::YieldSource::Await { expr: Some(id) }) =>\n-                self.awaits.push(id),\n+            hir::ExprKind::Yield(_, hir::YieldSource::Await { expr: Some(id) }) => {\n+                self.awaits.push(id)\n+            }\n             _ => (),\n         }\n         hir::intravisit::walk_expr(self, ex)"}]}