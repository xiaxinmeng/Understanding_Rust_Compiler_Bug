{"sha": "544c14f3ef872e0b804fbdbddaf47ba450751c16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NGMxNGYzZWY4NzJlMGI4MDRmYmRiZGRhZjQ3YmE0NTA3NTFjMTY=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-25T17:32:12Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-25T17:32:12Z"}, "message": "Merge pull request #230 from birkenfeld/eq_op_fix\n\neq_op: cut back to expressions that are guaranteed side effect free", "tree": {"sha": "1984925aabacae8489c925fa7058898db9600106", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1984925aabacae8489c925fa7058898db9600106"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/544c14f3ef872e0b804fbdbddaf47ba450751c16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/544c14f3ef872e0b804fbdbddaf47ba450751c16", "html_url": "https://github.com/rust-lang/rust/commit/544c14f3ef872e0b804fbdbddaf47ba450751c16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/544c14f3ef872e0b804fbdbddaf47ba450751c16/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2", "html_url": "https://github.com/rust-lang/rust/commit/aa4a135e97e8f439b0aa153c2a846fb06d0eb0a2"}, {"sha": "64cd1fc6ba266fdcfe96415a293a732df5741a04", "url": "https://api.github.com/repos/rust-lang/rust/commits/64cd1fc6ba266fdcfe96415a293a732df5741a04", "html_url": "https://github.com/rust-lang/rust/commit/64cd1fc6ba266fdcfe96415a293a732df5741a04"}], "stats": {"total": 217, "additions": 26, "deletions": 191}, "files": [{"sha": "3b4f47b556276d391c00e083bc4fd8210f75f713", "filename": "src/eq_op.rs", "status": "modified", "additions": 26, "deletions": 185, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/544c14f3ef872e0b804fbdbddaf47ba450751c16/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/544c14f3ef872e0b804fbdbddaf47ba450751c16/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=544c14f3ef872e0b804fbdbddaf47ba450751c16", "patch": "@@ -2,7 +2,6 @@ use rustc::lint::*;\n use syntax::ast::*;\n use syntax::ast_util as ast_util;\n use syntax::ptr::P;\n-use syntax::codemap as code;\n \n use consts::constant;\n use utils::span_lint;\n@@ -33,42 +32,27 @@ impl LintPass for EqOp {\n }\n \n pub fn is_exp_equal(cx: &Context, left : &Expr, right : &Expr) -> bool {\n-    if match (&left.node, &right.node) {\n-        (&ExprBinary(ref lop, ref ll, ref lr),\n-                &ExprBinary(ref rop, ref rl, ref rr)) =>\n-            lop.node == rop.node &&\n-            is_exp_equal(cx, ll, rl) && is_exp_equal(cx, lr, rr),\n-        (&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) =>\n-            both(lpl, rpl, |l, r| is_exp_equal(cx, l, r)) &&\n-                is_exp_equal(cx, lbox, rbox),\n-        (&ExprCall(ref lcallee, ref largs),\n-         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(cx, lcallee,\n-            rcallee) && is_exps_equal(cx, largs, rargs),\n-        (&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) =>\n-            is_ty_equal(cx, lty, rty) && is_exp_equal(cx, lc, rc),\n+    if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n+        if l == r {\n+            return true;\n+        }\n+    }\n+    match (&left.node, &right.node) {\n         (&ExprField(ref lfexp, ref lfident),\n                 &ExprField(ref rfexp, ref rfident)) =>\n             lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprMethodCall(ref lident, ref lcty, ref lmargs),\n-                &ExprMethodCall(ref rident, ref rcty, ref rmargs)) =>\n-            lident.node == rident.node && is_tys_equal(cx, lcty, rcty) &&\n-                is_exps_equal(cx, lmargs, rmargs),\n         (&ExprParen(ref lparen), _) => is_exp_equal(cx, lparen, right),\n         (_, &ExprParen(ref rparen)) => is_exp_equal(cx, left, rparen),\n         (&ExprPath(ref lqself, ref lsubpath),\n                 &ExprPath(ref rqself, ref rsubpath)) =>\n-            both(lqself, rqself, |l, r| is_qself_equal(l, r)) &&\n+            both(lqself, rqself, is_qself_equal) &&\n                 is_path_equal(lsubpath, rsubpath),\n         (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n             is_exps_equal(cx, ltup, rtup),\n-        (&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) =>\n-            lunop == runop && is_exp_equal(cx, l, r),\n         (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n-        _ => false\n-    } { return true; }\n-    match (constant(cx, left), constant(cx, right)) {\n-        (Some(l), Some(r)) => l == r,\n+        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) =>\n+            is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n         _ => false\n     }\n }\n@@ -90,166 +74,6 @@ fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n     left.ty.node == right.ty.node && left.position == right.position\n }\n \n-fn is_ty_equal(cx: &Context, left : &Ty, right : &Ty) -> bool {\n-    match (&left.node, &right.node) {\n-    (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(cx, lvec, rvec),\n-    (&TyFixedLengthVec(ref lfvty, ref lfvexp),\n-            &TyFixedLengthVec(ref rfvty, ref rfvexp)) =>\n-        is_ty_equal(cx, lfvty, rfvty) && is_exp_equal(cx, lfvexp, rfvexp),\n-    (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(cx, lmut, rmut),\n-    (&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) =>\n-        both(ltime, rtime, is_lifetime_equal) &&\n-        is_mut_ty_equal(cx, lrmut, rrmut),\n-    (&TyBareFn(ref lbare), &TyBareFn(ref rbare)) =>\n-        is_bare_fn_ty_equal(cx, lbare, rbare),\n-    (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(cx, ltup, rtup),\n-    (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n-        both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n-    (&TyObjectSum(ref lsumty, ref lobounds),\n-            &TyObjectSum(ref rsumty, ref robounds)) =>\n-        is_ty_equal(cx, lsumty, rsumty) &&\n-        is_param_bounds_equal(lobounds, robounds),\n-    (&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) =>\n-        is_param_bounds_equal(ltbounds, rtbounds),\n-    (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(cx, lty, rty),\n-    (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(cx, lof, rof),\n-    (&TyInfer, &TyInfer) => true,\n-    _ => false\n-    }\n-}\n-\n-fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound)\n-        -> bool {\n-    match(left, right) {\n-    (&TraitTyParamBound(ref lpoly, ref lmod),\n-            &TraitTyParamBound(ref rpoly, ref rmod)) =>\n-        lmod == rmod && is_poly_traitref_equal(lpoly, rpoly),\n-    (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) =>\n-        is_lifetime_equal(ltime, rtime),\n-    _ => false\n-    }\n-}\n-\n-fn is_poly_traitref_equal(left : &PolyTraitRef, right : &PolyTraitRef)\n-        -> bool {\n-    is_lifetimedefs_equal(&left.bound_lifetimes, &right.bound_lifetimes)\n-        && is_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n-}\n-\n-fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds)\n-        -> bool {\n-    over(left, right, is_param_bound_equal)\n-}\n-\n-fn is_mut_ty_equal(cx: &Context, left : &MutTy, right : &MutTy) -> bool {\n-    left.mutbl == right.mutbl && is_ty_equal(cx, &left.ty, &right.ty)\n-}\n-\n-fn is_bare_fn_ty_equal(cx: &Context, left : &BareFnTy, right : &BareFnTy) -> bool {\n-    left.unsafety == right.unsafety && left.abi == right.abi &&\n-        is_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) &&\n-            is_fndecl_equal(cx, &left.decl, &right.decl)\n-}\n-\n-fn is_fndecl_equal(cx: &Context, left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n-    left.variadic == right.variadic &&\n-        is_args_equal(cx, &left.inputs, &right.inputs) &&\n-        is_fnret_ty_equal(cx, &left.output, &right.output)\n-}\n-\n-fn is_fnret_ty_equal(cx: &Context, left : &FunctionRetTy,\n-        right : &FunctionRetTy) -> bool {\n-    match (left, right) {\n-    (&NoReturn(_), &NoReturn(_)) |\n-    (&DefaultReturn(_), &DefaultReturn(_)) => true,\n-    (&Return(ref lty), &Return(ref rty)) => is_ty_equal(cx, lty, rty),\n-    _ => false\n-    }\n-}\n-\n-fn is_arg_equal(cx: &Context, l: &Arg, r : &Arg) -> bool {\n-    is_ty_equal(cx, &l.ty, &r.ty) && is_pat_equal(cx, &l.pat, &r.pat)\n-}\n-\n-fn is_args_equal(cx: &Context, left : &[Arg], right : &[Arg]) -> bool {\n-    over(left, right, |l, r| is_arg_equal(cx, l, r))\n-}\n-\n-fn is_pat_equal(cx: &Context, left : &Pat, right : &Pat) -> bool {\n-    match(&left.node, &right.node) {\n-    (&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n-    (&PatIdent(ref lmode, ref lident, Option::None),\n-            &PatIdent(ref rmode, ref rident, Option::None)) =>\n-        lmode == rmode && is_ident_equal(&lident.node, &rident.node),\n-    (&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)),\n-            &PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n-        lmode == rmode && is_ident_equal(&lident.node, &rident.node) &&\n-            is_pat_equal(cx, lpat, rpat),\n-    (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) =>\n-        is_path_equal(lpath, rpath) && both(lenum, renum, |l, r|\n-            is_pats_equal(cx, l, r)),\n-    (&PatStruct(ref lpath, ref lfieldpat, lbool),\n-            &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n-        lbool == rbool && is_path_equal(lpath, rpath) &&\n-            is_spanned_fieldpats_equal(cx, lfieldpat, rfieldpat),\n-    (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(cx, ltup, rtup),\n-    (&PatBox(ref lboxed), &PatBox(ref rboxed)) =>\n-        is_pat_equal(cx, lboxed, rboxed),\n-    (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) =>\n-        is_pat_equal(cx, lpat, rpat) && lmut == rmut,\n-    (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(cx, llit, rlit),\n-    (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n-        is_exp_equal(cx, lfrom, rfrom) && is_exp_equal(cx, lto, rto),\n-    (&PatVec(ref lfirst, Option::None, ref llast),\n-            &PatVec(ref rfirst, Option::None, ref rlast)) =>\n-        is_pats_equal(cx, lfirst, rfirst) && is_pats_equal(cx, llast, rlast),\n-    (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast),\n-            &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n-        is_pats_equal(cx, lfirst, rfirst) && is_pat_equal(cx, lpat, rpat) &&\n-            is_pats_equal(cx, llast, rlast),\n-    // I don't match macros for now, the code is slow enough as is ;-)\n-    _ => false\n-    }\n-}\n-\n-fn is_spanned_fieldpats_equal(cx: &Context, left : &[code::Spanned<FieldPat>],\n-        right : &[code::Spanned<FieldPat>]) -> bool {\n-    over(left, right, |l, r| is_fieldpat_equal(cx, &l.node, &r.node))\n-}\n-\n-fn is_fieldpat_equal(cx: &Context, left : &FieldPat, right : &FieldPat) -> bool {\n-    left.is_shorthand == right.is_shorthand &&\n-        is_ident_equal(&left.ident, &right.ident) &&\n-        is_pat_equal(cx, &left.pat, &right.pat)\n-}\n-\n-fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n-    &left.name == &right.name && left.ctxt == right.ctxt\n-}\n-\n-fn is_pats_equal(cx: &Context, left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n-    over(left, right, |l, r| is_pat_equal(cx, l, r))\n-}\n-\n-fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef)\n-        -> bool {\n-    is_lifetime_equal(&left.lifetime, &right.lifetime) &&\n-        over(&left.bounds, &right.bounds, is_lifetime_equal)\n-}\n-\n-fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef])\n-        -> bool {\n-    over(left, right, is_lifetimedef_equal)\n-}\n-\n-fn is_lifetime_equal(left : &Lifetime, right : &Lifetime) -> bool {\n-    left.name == right.name\n-}\n-\n-fn is_tys_equal(cx: &Context, left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n-    over(left, right, |l, r| is_ty_equal(cx, l, r))\n-}\n-\n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n         where F: FnMut(&X, &X) -> bool {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)|\n@@ -269,3 +93,20 @@ fn is_cmp_or_bit(op : &BinOp) -> bool {\n         _ => false\n     }\n }\n+\n+fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n+    match (&left.node, &right.node) {\n+        (&TyVec(ref lvec), &TyVec(ref rvec)) => is_cast_ty_equal(lvec, rvec),\n+        (&TyPtr(ref lmut), &TyPtr(ref rmut)) =>\n+            lmut.mutbl == rmut.mutbl &&\n+            is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n+        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) =>\n+            lrmut.mutbl == rrmut.mutbl &&\n+            is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty),\n+        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n+            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n+        (&TyParen(ref lty), &TyParen(ref rty)) => is_cast_ty_equal(lty, rty),\n+        (&TyInfer, &TyInfer) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "fc59c2739a2e3e3c604805831a52ca6cdbc4780a", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/544c14f3ef872e0b804fbdbddaf47ba450751c16/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/544c14f3ef872e0b804fbdbddaf47ba450751c16/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=544c14f3ef872e0b804fbdbddaf47ba450751c16", "patch": "@@ -1,10 +1,6 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-fn id<X>(x: X) -> X {\n-    x\n-}\n-\n #[deny(eq_op)]\n #[allow(identity_op)]\n fn main() {\n@@ -19,7 +15,6 @@ fn main() {\n     // casts, methods, parentheses\n     (1 as u64) & (1 as u64); //~ERROR equal expressions\n     1 ^ ((((((1)))))); //~ERROR equal expressions\n-    id((1)) | id(1); //~ERROR equal expressions\n \n     // unary and binary operators\n     (-(2) < -(2));  //~ERROR equal expressions\n@@ -32,7 +27,6 @@ fn main() {\n     // various other things\n     ([1] != [1]); //~ERROR equal expressions\n     ((1, 2) != (1, 2)); //~ERROR equal expressions\n-    [1].len() == [1].len(); //~ERROR equal expressions\n     vec![1, 2, 3] == vec![1, 2, 3]; //no error yet, as we don't match macros\n \n     // const folding"}]}