{"sha": "810c5176ad564190bd7c836aa671b8fb3c3ca302", "node_id": "C_kwDOAAsO6NoAKDgxMGM1MTc2YWQ1NjQxOTBiZDdjODM2YWE2NzFiOGZiM2MzY2EzMDI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-06-12T09:18:20Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-06-12T09:27:56Z"}, "message": "Revert \"List matching impls on type aliases\"\n\nThis reverts commit 4b1d13d9841c815915433ca2a3088a8e3e97ad96.", "tree": {"sha": "2213f3fb40fe21a6311e1e6fb51b8e60f303ef6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2213f3fb40fe21a6311e1e6fb51b8e60f303ef6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/810c5176ad564190bd7c836aa671b8fb3c3ca302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/810c5176ad564190bd7c836aa671b8fb3c3ca302", "html_url": "https://github.com/rust-lang/rust/commit/810c5176ad564190bd7c836aa671b8fb3c3ca302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/810c5176ad564190bd7c836aa671b8fb3c3ca302/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d2361dcb53565012e8e8d4c69250a3e067e543", "url": "https://api.github.com/repos/rust-lang/rust/commits/87d2361dcb53565012e8e8d4c69250a3e067e543", "html_url": "https://github.com/rust-lang/rust/commit/87d2361dcb53565012e8e8d4c69250a3e067e543"}], "stats": {"total": 138, "additions": 28, "deletions": 110}, "files": [{"sha": "f205ff15ec3d030ae7d3d8bc334378b5bb13881a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 12, "deletions": 78, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/810c5176ad564190bd7c836aa671b8fb3c3ca302/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/810c5176ad564190bd7c836aa671b8fb3c3ca302/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=810c5176ad564190bd7c836aa671b8fb3c3ca302", "patch": "@@ -53,15 +53,12 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::{\n     symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n-use rustc_trait_selection::traits::ObligationCtxt;\n use serde::ser::{SerializeMap, SerializeSeq};\n use serde::{Serialize, Serializer};\n \n@@ -1115,76 +1112,28 @@ fn render_assoc_items<'a, 'cx: 'a>(\n     containing_item: &'a clean::Item,\n     it: DefId,\n     what: AssocItemRender<'a>,\n-    aliased_type: Option<DefId>,\n ) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n     display_fn(move |f| {\n-        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs, aliased_type);\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n         Ok(())\n     })\n }\n \n-/// Check whether `impl_def_id` may apply to *some instantiation* of `item_def_id`.\n-fn is_valid_impl_for(tcx: TyCtxt<'_>, item_def_id: DefId, impl_def_id: DefId) -> bool {\n-    let infcx = tcx.infer_ctxt().intercrate(true).build();\n-    let ocx = ObligationCtxt::new(&infcx);\n-    let param_env = ParamEnv::empty();\n-\n-    let alias_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, item_def_id);\n-    let alias_ty = tcx.type_of(item_def_id).subst(tcx, alias_substs);\n-    let alias_bounds = tcx.predicates_of(item_def_id).instantiate(tcx, alias_substs);\n-\n-    let impl_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, impl_def_id);\n-    let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n-    let impl_bounds = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n-\n-    if ocx.eq(&ObligationCause::dummy(), param_env, impl_self_ty, alias_ty).is_err() {\n-        return false;\n-    }\n-    ocx.register_obligations(\n-        alias_bounds\n-            .iter()\n-            .chain(impl_bounds)\n-            .map(|(p, _)| Obligation::new(tcx, ObligationCause::dummy(), param_env, p)),\n-    );\n-\n-    let errors = ocx.select_where_possible();\n-    errors.is_empty()\n-}\n-\n-// If `aliased_type` is `Some`, it means `it` is a type alias and `aliased_type` is the \"actual\"\n-// type aliased behind `it`. It is used to check whether or not the implementation of the aliased\n-// type can be displayed on the alias doc page.\n fn render_assoc_items_inner(\n     mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n     derefs: &mut DefIdSet,\n-    aliased_type: Option<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let shared = Rc::clone(&cx.shared);\n     let cache = &shared.cache;\n-    let empty = Vec::new();\n-    let v = match cache.impls.get(&it) {\n-        Some(v) => v,\n-        None => &empty,\n-    };\n-    let v2 = match aliased_type {\n-        Some(aliased_type) => cache.impls.get(&aliased_type).unwrap_or(&empty),\n-        None => &empty,\n-    };\n-    if v.is_empty() && v2.is_empty() {\n-        return;\n-    }\n-    let mut saw_impls = FxHashSet::default();\n-    let (non_trait, traits): (Vec<_>, _) =\n-        v.iter().chain(v2).partition(|i| i.inner_impl().trait_.is_none());\n-    let tcx = cx.tcx();\n-    let is_alias = aliased_type.is_some();\n+    let Some(v) = cache.impls.get(&it) else { return };\n+    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n         let mut tmp_buf = Buffer::html();\n         let (render_mode, id, class_html) = match what {\n@@ -1216,12 +1165,6 @@ fn render_assoc_items_inner(\n         };\n         let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n-            if !saw_impls.insert(i.def_id()) {\n-                continue;\n-            }\n-            if is_alias && !is_valid_impl_for(tcx, it, i.def_id()) {\n-                continue;\n-            }\n             render_impl(\n                 &mut impls_buf,\n                 cx,\n@@ -1250,14 +1193,9 @@ fn render_assoc_items_inner(\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n-        if let Some(impl_) = deref_impl &&\n-            (!is_alias || is_valid_impl_for(tcx, it, impl_.def_id()))\n-        {\n+        if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n-                traits.iter().any(|t| {\n-                    t.trait_did() == cx.tcx().lang_items().deref_mut_trait() &&\n-                    (!is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n-                });\n+                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n             render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n@@ -1267,14 +1205,10 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) = traits\n-            .into_iter()\n-            .filter(|t| saw_impls.insert(t.def_id()))\n-            .partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&Impl>, _) = concrete\n-            .into_iter()\n-            .filter(|t| !is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n-            .partition(|t| t.inner_impl().kind.is_blanket());\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n+            concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n         render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n@@ -1313,10 +1247,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n         }\n     }\n }"}, {"sha": "383e3c170881a20ca9301dd867acf246b9ff25a4", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/810c5176ad564190bd7c836aa671b8fb3c3ca302/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/810c5176ad564190bd7c836aa671b8fb3c3ca302/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=810c5176ad564190bd7c836aa671b8fb3c3ca302", "patch": "@@ -129,7 +129,7 @@ macro_rules! item_template_methods {\n             display_fn(move |f| {\n                 let (item, mut cx) = self.item_and_mut_cx();\n                 let def_id = item.item_id.expect_def_id();\n-                let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All, None);\n+                let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n                 write!(f, \"{v}\")\n             })\n         }\n@@ -953,11 +953,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    );\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1189,12 +1185,8 @@ fn item_trait_alias(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    )\n-    .unwrap();\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_opaque_ty(\n@@ -1222,12 +1214,8 @@ fn item_opaque_ty(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    )\n-    .unwrap();\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -1251,11 +1239,11 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, def_id, AssocItemRender::All, t.type_.def_id(&cx.cache()))\n-    );\n+    // Render any items associated directly to this alias, as otherwise they\n+    // won't be visible anywhere in the docs. It would be nice to also show\n+    // associated items from the aliased type (see discussion in #32077), but\n+    // we need #14072 to make sense of the generics.\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1494,7 +1482,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1537,7 +1525,7 @@ fn item_primitive(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Ite\n     let def_id = it.item_id.expect_def_id();\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None)).unwrap();\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All)).unwrap();\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1642,7 +1630,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1677,12 +1665,8 @@ fn item_foreign_type(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::\n     });\n \n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n-    write!(\n-        w,\n-        \"{}\",\n-        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n-    )\n-    .unwrap();\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n+        .unwrap();\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}]}