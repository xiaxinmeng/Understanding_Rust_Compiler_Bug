{"sha": "def72bda47977b3bc36143eba9692bff12a8303c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZjcyYmRhNDc5NzdiM2JjMzYxNDNlYmE5NjkyYmZmMTJhODMwM2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-01T18:36:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-02T14:47:25Z"}, "message": "retool inline encoding to handle methods, fix tests", "tree": {"sha": "20dc1277106ddb56ded43fec53318b17c51baee1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20dc1277106ddb56ded43fec53318b17c51baee1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/def72bda47977b3bc36143eba9692bff12a8303c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/def72bda47977b3bc36143eba9692bff12a8303c", "html_url": "https://github.com/rust-lang/rust/commit/def72bda47977b3bc36143eba9692bff12a8303c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/def72bda47977b3bc36143eba9692bff12a8303c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c68bcd6df325cc369adce018c07dfe3e2b767a", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c68bcd6df325cc369adce018c07dfe3e2b767a", "html_url": "https://github.com/rust-lang/rust/commit/12c68bcd6df325cc369adce018c07dfe3e2b767a"}], "stats": {"total": 1006, "additions": 599, "deletions": 407}, "files": [{"sha": "c24c80cf74b2dd40158c9357709c5422ca67a4dc", "filename": "src/comp/metadata/astencode.rs", "status": "modified", "additions": 127, "deletions": 35, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -31,6 +31,8 @@ import syntax::print::pprust;\n \n export encode_inlined_item;\n export decode_inlined_item;\n+export encode_inlined_method;\n+export decode_inlined_method;\n \n type decode_ctxt = @{\n     cdata: cstore::crate_metadata,\n@@ -49,49 +51,125 @@ iface tr {\n }\n \n // ______________________________________________________________________\n-// Enumerating the IDs which appear in an AST\n+// Top-level methods.\n+\n+// The type inline_fn should be a type that can represent both methods\n+// and top-level items. As it happens, the type ast::method is perfect\n+// for this purpose, but I use this typedef just to keep clear when\n+// the thing may not, in fact, be an actual method in the AST but\n+// rather some sort of function.\n+enum inline_fn = @ast::method;\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        ebml_w: ebml::writer,\n                        path: ast_map::path,\n                        item: @ast::item) {\n+    let ifn = inline_fn(alt item.node {\n+      ast::item_fn(decl, tps, body) {\n+          @{ident: item.ident,\n+            attrs: item.attrs,\n+            tps: tps,\n+            decl: decl,\n+            body: body,\n+            id: item.id,\n+            span: item.span}\n+      }\n+\n+      _ {\n+          ecx.ccx.sess.span_bug(item.span, \"Cannot inline non-function\")\n+      }\n+    });\n+\n+    encode_inlined_fn(ecx, ebml_w, path, ifn);\n+}\n+\n+fn decode_inlined_item(cdata: cstore::crate_metadata,\n+                       tcx: ty::ctxt,\n+                       maps: maps,\n+                       path: ast_map::path,\n+                       par_doc: ebml::doc) -> option<@ast::item> {\n+    let oifn = decode_inlined_fn(cdata, tcx, maps, path, par_doc);\n+    option::map(oifn) {|ifn|\n+        let item = @{ident: ifn.ident,\n+                     attrs: ifn.attrs,\n+                     id: ifn.id,\n+                     node: ast::item_fn(ifn.decl, ifn.tps, ifn.body),\n+                     span: ifn.span};\n+        ast_map::map_decoded_item(tcx.items, path, item);\n+        item\n+    }\n+}\n+\n+fn encode_inlined_method(ecx: @e::encode_ctxt,\n+                         ebml_w: ebml::writer,\n+                         path: ast_map::path,\n+                         mthd: @ast::method) {\n+    encode_inlined_fn(ecx, ebml_w, path, inline_fn(mthd))\n+}\n+\n+fn decode_inlined_method(cdata: cstore::crate_metadata,\n+                         tcx: ty::ctxt,\n+                         maps: maps,\n+                         path: ast_map::path,\n+                         par_doc: ebml::doc) -> option<@ast::method> {\n+    let oifn = decode_inlined_fn(cdata, tcx, maps, path, par_doc);\n+    option::map(oifn) {|ifn|\n+        ast_map::map_decoded_method(tcx.items, path, *ifn);\n+        *ifn\n+    }\n+}\n+\n+fn encode_inlined_fn(ecx: @e::encode_ctxt,\n+                     ebml_w: ebml::writer,\n+                     path: ast_map::path,\n+                     ifn: inline_fn) {\n+\n     #debug[\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path),\n-           item.ident,\n+           ifn.ident,\n            ebml_w.writer.tell()];\n-    let id_range = compute_id_range(item);\n+\n+    let id_range = compute_id_range(ifn);\n     ebml_w.wr_tag(c::tag_ast as uint) {||\n         encode_id_range(ebml_w, id_range);\n-        encode_ast(ebml_w, item);\n-        encode_side_tables_for_item(ecx, ebml_w, item);\n+        encode_ast(ebml_w, ifn);\n+        encode_side_tables_for_ifn(ecx, ebml_w, ifn);\n     }\n-    #debug[\"< Encoded inlined item: %s (%u)\",\n+\n+    #debug[\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path),\n+           ifn.ident,\n            ebml_w.writer.tell()];\n }\n \n-fn decode_inlined_item(cdata: cstore::crate_metadata,\n-                       tcx: ty::ctxt,\n-                       maps: maps,\n-                       path: ast_map::path,\n-                       par_doc: ebml::doc) -> option<@ast::item> {\n+// Decodes the inlined function and associated side tables.  Does\n+// *not* insert the function into the ast_map, since the correct way\n+// to do this depends on whether this is an inlined item or method;\n+// therefore, you ought to be invoking decode_inlined_item() or\n+// decode_inlined_method() and not this helper function.\n+fn decode_inlined_fn(cdata: cstore::crate_metadata,\n+                     tcx: ty::ctxt,\n+                     maps: maps,\n+                     path: ast_map::path,\n+                     par_doc: ebml::doc) -> option<inline_fn> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     alt par_doc.opt_child(c::tag_ast) {\n       none { none }\n       some(ast_doc) {\n-        #debug[\"> Decoding inlined item: %s\", ast_map::path_to_str(path)];\n+        #debug[\"> Decoding inlined fn: %s\", ast_map::path_to_str(path)];\n         let from_id_range = decode_id_range(ast_doc);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = @{dcx: dcx,\n                     from_id_range: from_id_range,\n                     to_id_range: to_id_range};\n-        let raw_item = decode_ast(ast_doc);\n-        let item = renumber_ast(xcx, raw_item);\n-        #debug[\">> Item named: %s\", item.ident];\n-        ast_map::map_decoded_item(dcx.tcx.items, path, item);\n+        let raw_ifn = decode_ast(ast_doc);\n+        let ifn = renumber_ast(xcx, raw_ifn);\n+        #debug[\"Fn named: %s\", ifn.ident];\n         decode_side_tables(xcx, ast_doc);\n-        #debug[\"< Decoded inlined item: %s\", ast_map::path_to_str(path)];\n-        some(item)\n+        #debug[\"< Decoded inlined fn: %s::%s\",\n+               ast_map::path_to_str(path),\n+               ifn.ident];\n+        some(ifn)\n       }\n     }\n }\n@@ -105,7 +183,7 @@ fn empty(range: id_range) -> bool {\n     range.min >= range.max\n }\n \n-fn visit_ids(item: @ast::item, vfn: fn@(ast::node_id)) {\n+fn visit_ids(ifn: inline_fn, vfn: fn@(ast::node_id)) {\n     let visitor = visit::mk_simple_visitor(@{\n         visit_mod: fn@(_m: ast::_mod, _sp: span, id: ast::node_id) {\n             vfn(id)\n@@ -214,13 +292,13 @@ fn visit_ids(item: @ast::item, vfn: fn@(ast::node_id)) {\n         }\n     });\n \n-    visitor.visit_item(item, (), visitor);\n+    visit::visit_method_helper(*ifn, (), visitor);\n }\n \n-fn compute_id_range(item: @ast::item) -> id_range {\n+fn compute_id_range(ifn: inline_fn) -> id_range {\n     let min = @mutable int::max_value;\n     let max = @mutable int::min_value;\n-    visit_ids(item) {|id|\n+    visit_ids(ifn) {|id|\n         *min = int::min(*min, id);\n         *max = int::max(*max, id + 1);\n     }\n@@ -317,25 +395,25 @@ impl deserializer_helpers<D: serialization::deserializer> for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: ebml::writer, item: @ast::item) {\n+fn encode_ast(ebml_w: ebml::writer, ifn: inline_fn) {\n     ebml_w.wr_tag(c::tag_tree as uint) {||\n-        astencode_gen::serialize_syntax_ast_item(ebml_w, *item);\n+        astencode_gen::serialize_syntax_ast_method(ebml_w, **ifn)\n     }\n }\n \n-fn decode_ast(par_doc: ebml::doc) -> @ast::item {\n+fn decode_ast(par_doc: ebml::doc) -> inline_fn {\n     let chi_doc = par_doc[c::tag_tree];\n     let d = serialization::mk_ebml_deserializer(chi_doc);\n-    @astencode_gen::deserialize_syntax_ast_item(d)\n+    inline_fn(@astencode_gen::deserialize_syntax_ast_method(d))\n }\n \n-fn renumber_ast(xcx: extended_decode_ctxt, item: @ast::item) -> @ast::item {\n+fn renumber_ast(xcx: extended_decode_ctxt, ifn: inline_fn) -> inline_fn {\n     let fld = fold::make_fold({\n         new_id: xcx.tr_id(_),\n         new_span: xcx.tr_span(_)\n         with *fold::default_ast_fold()\n     });\n-    fld.fold_item(item)\n+    inline_fn(fld.fold_method(*ifn))\n }\n \n // ______________________________________________________________________\n@@ -586,11 +664,11 @@ impl writer for ebml::writer {\n     }\n }\n \n-fn encode_side_tables_for_item(ecx: @e::encode_ctxt,\n-                               ebml_w: ebml::writer,\n-                               item: @ast::item) {\n+fn encode_side_tables_for_ifn(ecx: @e::encode_ctxt,\n+                              ebml_w: ebml::writer,\n+                              ifn: inline_fn) {\n     ebml_w.wr_tag(c::tag_table as uint) {||\n-        visit_ids(item, fn@(id: ast::node_id) {\n+        visit_ids(ifn, fn@(id: ast::node_id) {\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it has mutable fields.  But I believe it's harmless since\n             // we generate balanced EBML.\n@@ -820,7 +898,21 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n }\n \n // ______________________________________________________________________\n-// Testing\n+// Testing of astencode_gen\n+\n+#[cfg(test)]\n+fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n+    ebml_w.wr_tag(c::tag_tree as uint) {||\n+        astencode_gen::serialize_syntax_ast_item(ebml_w, *item);\n+    }\n+}\n+\n+#[cfg(test)]\n+fn decode_item_ast(par_doc: ebml::doc) -> @ast::item {\n+    let chi_doc = par_doc[c::tag_tree];\n+    let d = serialization::mk_ebml_deserializer(chi_doc);\n+    @astencode_gen::deserialize_syntax_ast_item(d)\n+}\n \n #[cfg(test)]\n fn new_parse_sess() -> parser::parse_sess {\n@@ -864,9 +956,9 @@ fn roundtrip(in_item: @ast::item) {\n     #debug[\"in_item = %s\", pprust::item_to_str(in_item)];\n     let mbuf = io::mk_mem_buffer();\n     let ebml_w = ebml::mk_writer(io::mem_buffer_writer(mbuf));\n-    encode_ast(ebml_w, in_item);\n+    encode_item_ast(ebml_w, in_item);\n     let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));\n-    let out_item = decode_ast(ebml_doc);\n+    let out_item = decode_item_ast(ebml_doc);\n     #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n     assert in_item == out_item;\n }"}, {"sha": "abbe7376e1bfa46ea374a7a763ef887482088581", "filename": "src/comp/metadata/astencode_gen.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -8748,3 +8748,12 @@ fn deserialize_syntax_ast_def_id<S: std::serialization::deserializer>(s: S) ->\n    syntax::ast::def_id {\n     deserialize_162(s)\n }\n+fn serialize_syntax_ast_method<S: std::serialization::serializer>(s: S,\n+                                                                  v:\n+                                                                      syntax::ast::method) {\n+    serialize_160(s, v);\n+}\n+fn deserialize_syntax_ast_method<S: std::serialization::deserializer>(s: S) ->\n+   syntax::ast::method {\n+    deserialize_160(s)\n+}"}, {"sha": "b5944402bb253eac7c235148ac5531e2f198e3ad", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -73,6 +73,15 @@ fn map_decoded_item(map: map, path: path, i: @item) {\n     v.visit_item(i, cx, v);\n }\n \n+fn map_decoded_method(map: map, path: path, m: @method) {\n+    // As above.\n+    let cx = {map: map,\n+              mutable path: path,\n+              mutable local_id: 0u};\n+    let v = mk_ast_map_visitor();\n+    visit::visit_method_helper(m, cx, v);\n+}\n+\n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for a in decl.inputs {"}, {"sha": "55958abd7af6f6b4c48f2b8717f93e2a585dd50c", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -130,8 +130,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n         v.visit_ty(ty, e, v);\n         for m in methods {\n-            v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n-                       m.id, e, v);\n+            visit_method_helper(m, e, v)\n         }\n       }\n       item_class(tps, members, _, ctor_decl, ctor_blk) {\n@@ -252,6 +251,15 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     v.visit_ty(fd.output, e, v);\n }\n \n+// Note: there is no visit_method() method in the visitor, instead override\n+// visit_fn() and check for fk_method().  I named this visit_method_helper()\n+// because it is not a default impl of any method, though I doubt that really\n+// clarifies anything. - Niko\n+fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n+    v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n+               m.id, e, v);\n+}\n+\n fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n                _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);"}, {"sha": "517da771c0a6e0eb97a36c599619ead3c9f47d3d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -289,10 +289,15 @@ fn compile_test(config: config, props: test_props,\n                 testfile: str) -> procres {\n     vec::iter(props.aux_builds) {|rel_ab|\n         let abs_ab = fs::connect(config.aux_base, rel_ab);\n-        compose_and_run(config, abs_ab,\n-                        make_compile_args(_, props, [\"--lib\"],\n-                                          make_lib_name, _),\n-                        config.compile_lib_path, option::none);\n+        let auxres = compose_and_run(config, abs_ab,\n+                                     make_compile_args(_, props, [\"--lib\"],\n+                                                       make_lib_name, _),\n+                                     config.compile_lib_path, option::none);\n+        if auxres.status != 0 {\n+            fatal_procres(\n+                #fmt[\"auxiliary build of %s failed to compile: \", abs_ab],\n+                auxres);\n+        }\n     }\n \n     compose_and_run(config, testfile,"}, {"sha": "2be64dab78489102164a73b4b9778a26e0b2ba1d", "filename": "src/etc/gen-astencode", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fetc%2Fgen-astencode", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Fetc%2Fgen-astencode", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgen-astencode?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -16,7 +16,8 @@ function msg {\n \n M=src/comp/metadata\n GEN_TYPES=\"syntax::ast::item syntax::ast::def middle::typeck::method_origin \\\n-           middle::freevars::freevar_entry syntax::ast::def_id\"\n+           middle::freevars::freevar_entry syntax::ast::def_id\n+           syntax::ast::method\"\n \n # Find serializer tool:\n for S in build/*/stage1/bin/serializer; do"}, {"sha": "7532177246ccd1adc98446f66554366971e820cf", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -20,12 +20,15 @@ native mod rustrt {\n     fn unsupervise();\n     fn shape_log_str<T>(t: *sys::type_desc, data: T) -> str;\n     fn rust_set_exit_status(code: ctypes::intptr_t);\n-    fn rust_frame_address() -> ctypes::uintptr_t;\n }\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     fn get_type_desc<T>() -> *type_desc;\n+\n+    // Invokes __builtin_frame_address().\n+    // See <http://gcc.gnu.org/onlinedocs/gcc/Return-Address.html>.\n+    fn frame_address(n: ctypes::c_uint) -> ctypes::uintptr_t;\n }\n \n /*\n@@ -78,10 +81,6 @@ fn log_str<T>(t: T) -> str {\n     rustrt::shape_log_str(get_type_desc::<T>(), t)\n }\n \n-fn frame_address() -> uint {\n-    rustrt::rust_frame_address()\n-}\n-\n #[doc(\n     brief = \"Sets the process exit code\",\n     desc = \"Sets the exit code returned by the process if all supervised \\"}, {"sha": "d36bdf8767517338060af6859f70855dc5db1427", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -166,3 +166,9 @@ upcall_vec_push(rust_vec** vp,\n \t\ttype_desc* elt_ty, void* elt) {\n   upcall_intrinsic_vec_push(vp, elt_ty, elt);\n }\n+\n+extern \"C\" CDECL void\n+rust_intrinsic_frame_address(void **p, unsigned n) {\n+    *p = __builtin_frame_address(n);\n+}\n+"}, {"sha": "a03bed031181438da00ba6bd6d09352be570e4bb", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "modified", "additions": 167, "deletions": 171, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -1,240 +1,236 @@\n ; ModuleID = 'src/rt/intrinsics/intrinsics.cpp'\n-; target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:32:32-n8:16:32-S128\"\n+; target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32\"\n target triple = \"@CFG_TARGET_TRIPLE@\"\n \n-%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, i8*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n-%struct.rust_shape_tables = type { i8*, i8* }\n+%0 = type { i32, %struct.rust_task**, i32 }\n+%1 = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n+%class.array_list = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n+%class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n+%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n+%class.context = type { %struct.registers_t, %class.context*, [12 x i8] }\n+%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n+%class.hash_map = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%class.indexed_list = type { i32 (...)**, %0 }\n+%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t* }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i32 }\n+%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i32, i32, %1, %class.lock_and_signal, i32, %class.lock_and_signal, i32, %\"class.std::map\", %\"class.std::vector\", %struct.rust_env* }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n+%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.circular_buffer, %class.lock_and_signal }\n+%class.rust_port_selector = type { %class.rust_port**, i32, %class.lock_and_signal }\n+%class.rust_scheduler = type opaque\n+%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n+%class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n+%class.rust_thread = type { i32 (...)**, %struct._opaque_pthread_t*, i32 }\n+%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" }\n+%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%\"class.std::vector\" = type { %\"struct.std::_Vector_base\" }\n+%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.rust_vec = type { i32, i32, [0 x i8] }\n-%struct.rust_fn = type { i32*, %struct.rust_box* }\n-%struct.rust_box = type opaque\n-%struct.rust_task = type { i32, i32, i8, %struct.chan_handle, [12 x i8], %class.context, %struct.stk_seg*, i32, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map.3, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, i8, i8, %struct.stk_seg*, i32, i32, %class.rust_port_selector, [8 x i8] }\n+%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n+%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n+%struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n+%struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n+%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n %struct.chan_handle = type { i32, i32 }\n-%class.context = type { %struct.registers_t, %class.context*, [12 x i8] }\n+%\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n+%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n+%\"struct.memory_region::alloc_header\" = type { i8 }\n+%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n %struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32, [12 x i8] }\n-%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i32, i32, i32, i32, [0 x i8] }\n-%class.rust_scheduler = type opaque\n-%struct.rust_task_thread = type { %class.rust_thread, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, [8 x i8], %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [4 x i8] }\n-%class.rust_thread = type { i32 (...)**, i32, i32 }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n-%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n+%struct.rust_box = type opaque\n %struct.rust_env = type { i32, i32, i32, i8*, i8, i8, i8* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n-%class.array_list = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n-%\"struct.memory_region::alloc_header\" = type { i8 }\n-%class.lock_and_signal = type { i32 (...)**, %union.pthread_cond_t, %union.pthread_mutex_t, i32 }\n-%union.pthread_cond_t = type { %struct.anon, [4 x i8] }\n-%struct.anon = type { i32, i32, i64, i64, i64, i8*, i32, i32 }\n-%union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n-%\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, %union.anon }\n-%union.anon = type { i32 }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n-%class.array_list.1 = type { i32, %struct.rust_task**, i32 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i32 }\n+%struct.rust_fn = type { i32*, %struct.rust_box* }\n %struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n-%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i32, i32, %class.hash_map, %class.lock_and_signal, i32, %class.lock_and_signal, i32, i32, %\"class.std::map\", %struct.rust_env* }\n-%class.hash_map = type { %\"struct.hash_map<int, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<int, rust_task *>::map_entry\" = type opaque\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<int, std::pair<const int, rust_scheduler *>, std::_Select1st<std::pair<const int, rust_scheduler *> >, std::less<int>, std::allocator<std::pair<const int, rust_scheduler *> > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<int, std::pair<const int, rust_scheduler *>, std::_Select1st<std::pair<const int, rust_scheduler *> >, std::less<int>, std::allocator<std::pair<const int, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i32 }\n-%\"struct.std::less\" = type { i8 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%union.pthread_attr_t = type { i32, [32 x i8] }\n-%struct.rust_cond = type { i8 }\n-%class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n-%struct.rust_opaque_box = type { i32, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n-%class.hash_map.3 = type { %\"struct.hash_map<int, rust_port *>::map_entry\"* }\n-%\"struct.hash_map<int, rust_port *>::map_entry\" = type opaque\n-%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n %struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i32, i32, i32, [0 x i8] }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map.4\" }\n-%\"class.std::map.4\" = type { %\"class.std::_Rb_tree.5\" }\n-%\"class.std::_Rb_tree.5\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less.9\", %\"struct.std::_Rb_tree_node_base\", i32 }\n-%\"struct.std::less.9\" = type { i8 }\n-%class.rust_port_selector = type { %class.rust_port**, i32, %class.lock_and_signal }\n-%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.circular_buffer, %class.lock_and_signal }\n-%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n+%struct.rust_opaque_box = type { i32, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n+%struct.rust_shape_tables = type { i8*, i8* }\n+%struct.rust_task = type { i32, i32, i8, %struct.chan_handle, [12 x i8], %class.context, %struct.stk_seg*, i32, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %\"struct.memory_region::alloc_header\"*, i8*, %struct.rust_task*, i32, i32, i32*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, i8, i8, %struct.stk_seg*, i32, i32, %class.rust_port_selector, [8 x i8] }\n+%struct.rust_task_thread = type { %class.rust_thread, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i32, %struct._opaque_pthread_attr_t, %struct.rust_env*, [4 x i8], %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [4 x i8] }\n+%struct.rust_vec = type { i32, i32, [0 x i8] }\n+%\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.memory_region::alloc_header\", %\"struct.std::_Rb_tree_node_base\", i32 }\n+%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n+%\"struct.std::_Vector_base\" = type { %\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" }\n+%\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" = type { i32*, i32*, i32* }\n+%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i32, i32, i32, i32, [0 x i8] }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, i8*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n \n define void @rust_intrinsic_vec_len(i32* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n-entry:\n-  %0 = load %struct.rust_vec** %vp, align 4, !tbaa !0\n-  %fill = getelementptr inbounds %struct.rust_vec* %0, i32 0, i32 0\n-  %1 = load i32* %fill, align 4, !tbaa !3\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %size, align 4, !tbaa !3\n-  %div = udiv i32 %1, %2\n-  store i32 %div, i32* %retptr, align 4, !tbaa !3\n+  %1 = load %struct.rust_vec** %vp, align 4\n+  %2 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 0\n+  %3 = load i32* %2, align 4\n+  %4 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %5 = load i32* %4, align 4\n+  %6 = udiv i32 %3, %5\n+  store i32 %6, i32* %retptr, align 4\n   ret void\n }\n \n define void @rust_intrinsic_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %0 = load i32* %size, align 4, !tbaa !3\n-  %mul = mul i32 %0, %count\n-  %arrayidx = getelementptr inbounds i8* %ptr, i32 %mul\n-  store i8* %arrayidx, i8** %retptr, align 4, !tbaa !0\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %2 = load i32* %1, align 4\n+  %3 = mul i32 %2, %count\n+  %4 = getelementptr inbounds i8* %ptr, i32 %3\n+  store i8* %4, i8** %retptr, align 4\n   ret void\n }\n \n define void @rust_intrinsic_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) nounwind {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n-  %0 = load i32* %size, align 4, !tbaa !3\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %0, i32 1, i1 false)\n+  %1 = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n+  %2 = load i32* %1, align 4\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %2, i32 1, i1 false)\n   ret void\n }\n \n declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n \n define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n-entry:\n-  store i8* %valptr, i8** %retptr, align 4, !tbaa !0\n+  store i8* %valptr, i8** %retptr, align 4\n   ret void\n }\n \n define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) {\n-entry:\n-  %fn1 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 0\n-  %0 = load i32** %fn1, align 4, !tbaa !0\n-  %1 = bitcast i32* %0 to void (i8**, i8*, i8**)*\n-  %env2 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 1\n-  %2 = load %struct.rust_box** %env2, align 4, !tbaa !0\n-  %3 = bitcast %struct.rust_box* %2 to i8*\n-  tail call void %1(i8** null, i8* %3, i8** %retptr)\n+  %1 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 0\n+  %2 = load i32** %1, align 4\n+  %3 = bitcast i32* %2 to void (i8**, i8*, i8**)*\n+  %4 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 1\n+  %5 = load %struct.rust_box** %4, align 4\n+  %6 = bitcast %struct.rust_box* %5 to i8*\n+  tail call void %3(i8** null, i8* %6, i8** %retptr)\n   ret void\n }\n \n define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n-entry:\n   %ty.c = bitcast %struct.type_desc* %ty to i8*\n-  store i8* %ty.c, i8** %retptr, align 4, !tbaa !0\n+  store i8* %ty.c, i8** %retptr, align 4\n   ret void\n }\n \n define void @rust_intrinsic_task_yield(i8** nocapture %retptr, i8* nocapture %env, %struct.rust_task* %task, i8* %killed) {\n-entry:\n   tail call void @rust_task_yield(%struct.rust_task* %task, i8* %killed)\n   ret void\n }\n \n declare void @rust_task_yield(%struct.rust_task*, i8*)\n \n define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i32 %count) nounwind {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %0 = load i32* %size, align 4, !tbaa !3\n-  %mul = mul i32 %0, %count\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %mul, i32 1, i1 false)\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %2 = load i32* %1, align 4\n+  %3 = mul i32 %2, %count\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %3, i32 1, i1 false)\n   ret void\n }\n \n define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i32 %count) nounwind {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %0 = load i32* %size, align 4, !tbaa !3\n-  %mul = mul i32 %0, %count\n-  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %mul, i32 1, i1 false)\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %2 = load i32* %1, align 4\n+  %3 = mul i32 %2, %count\n+  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %3, i32 1, i1 false)\n   ret void\n }\n \n declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n \n define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind readnone {\n-entry:\n   ret void\n }\n \n define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n-entry:\n-  %0 = load %struct.rust_vec** %vp, align 4, !tbaa !0\n-  %fill = getelementptr inbounds %struct.rust_vec* %0, i32 0, i32 0\n-  %1 = load i32* %fill, align 4, !tbaa !3\n-  %size = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 1\n-  %2 = load i32* %size, align 4, !tbaa !3\n-  %add = add i32 %2, %1\n-  %alloc.i = getelementptr inbounds %struct.rust_vec* %0, i32 0, i32 1\n-  %3 = load i32* %alloc.i, align 4, !tbaa !3\n-  %cmp.i = icmp ult i32 %3, %add\n-  br i1 %cmp.i, label %if.then.i, label %_Z16reserve_vec_fastPP8rust_vecj.exit\n-\n-if.then.i:                                        ; preds = %entry\n-  %sub.i.i = add i32 %add, -1\n-  %shr.i.i = lshr i32 %sub.i.i, 1\n-  %or.i.i = or i32 %shr.i.i, %sub.i.i\n-  %shr1.i.i = lshr i32 %or.i.i, 2\n-  %or2.i.i = or i32 %shr1.i.i, %or.i.i\n-  %shr3.i.i = lshr i32 %or2.i.i, 4\n-  %or4.i.i = or i32 %shr3.i.i, %or2.i.i\n-  %shr5.i.i = lshr i32 %or4.i.i, 8\n-  %or6.i.i = or i32 %shr5.i.i, %or4.i.i\n-  %shr7.i.i = lshr i32 %or6.i.i, 16\n-  %or8.i.i = or i32 %shr7.i.i, %or6.i.i\n-  %add.i.i = add i32 %or8.i.i, 1\n-  %add.i = add i32 %or8.i.i, 9\n-  %4 = bitcast %struct.rust_vec* %0 to i8*\n-  %call1.i = tail call i8* @upcall_shared_realloc(i8* %4, i32 %add.i)\n-  %5 = bitcast i8* %call1.i to %struct.rust_vec*\n-  store %struct.rust_vec* %5, %struct.rust_vec** %vp, align 4, !tbaa !0\n-  %alloc2.i = getelementptr inbounds i8* %call1.i, i32 4\n-  %6 = bitcast i8* %alloc2.i to i32*\n-  store i32 %add.i.i, i32* %6, align 4, !tbaa !3\n-  %.pr = load i32* %size, align 4\n-  %fill1.phi.trans.insert = bitcast i8* %call1.i to i32*\n-  %.pre = load i32* %fill1.phi.trans.insert, align 4, !tbaa !3\n-  br label %_Z16reserve_vec_fastPP8rust_vecj.exit\n-\n-_Z16reserve_vec_fastPP8rust_vecj.exit:            ; preds = %entry, %if.then.i\n-  %7 = phi i32 [ %1, %entry ], [ %.pre, %if.then.i ]\n-  %8 = phi %struct.rust_vec* [ %0, %entry ], [ %5, %if.then.i ]\n-  %9 = phi i32 [ %2, %entry ], [ %.pr, %if.then.i ]\n-  %fill1 = getelementptr inbounds %struct.rust_vec* %8, i32 0, i32 0\n-  %add.ptr = getelementptr inbounds %struct.rust_vec* %8, i32 0, i32 2, i32 %7\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %add.ptr, i8* %elt, i32 %9, i32 1, i1 false)\n-  %take_glue.i = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 3\n-  %10 = load void (i8*, i8*, %struct.type_desc**, i8*)** %take_glue.i, align 4, !tbaa !0\n-  %tobool.i = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %10, null\n-  br i1 %tobool.i, label %_ZL13copy_elementsP9type_descPvS1_j.exit, label %if.then.i6\n-\n-if.then.i6:                                       ; preds = %_Z16reserve_vec_fastPP8rust_vecj.exit\n-  %11 = load i32* %size, align 4, !tbaa !3\n-  %first_param.i = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 0\n-  %12 = load %struct.type_desc*** %first_param.i, align 4, !tbaa !0\n-  %add.ptr.sum = add i32 %7, %9\n-  %add.ptr.i = getelementptr inbounds %struct.rust_vec* %8, i32 0, i32 2, i32 %add.ptr.sum\n-  %cmp4.i = icmp sgt i32 %9, 0\n-  br i1 %cmp4.i, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_j.exit\n-\n-for.body.i:                                       ; preds = %if.then.i6, %for.body.i\n-  %p.05.i = phi i8* [ %add.ptr3.i, %for.body.i ], [ %add.ptr, %if.then.i6 ]\n-  tail call void %10(i8* null, i8* null, %struct.type_desc** %12, i8* %p.05.i)\n-  %add.ptr3.i = getelementptr inbounds i8* %p.05.i, i32 %11\n-  %cmp.i7 = icmp ult i8* %add.ptr3.i, %add.ptr.i\n-  br i1 %cmp.i7, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_j.exit\n-\n-_ZL13copy_elementsP9type_descPvS1_j.exit:         ; preds = %for.body.i, %_Z16reserve_vec_fastPP8rust_vecj.exit, %if.then.i6\n-  %13 = load i32* %size, align 4, !tbaa !3\n-  %14 = load i32* %fill1, align 4, !tbaa !3\n-  %add5 = add i32 %14, %13\n-  store i32 %add5, i32* %fill1, align 4, !tbaa !3\n+; <label>:0\n+  %1 = load %struct.rust_vec** %vp, align 4\n+  %2 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 0\n+  %3 = load i32* %2, align 4\n+  %4 = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 1\n+  %5 = load i32* %4, align 4\n+  %6 = add i32 %5, %3\n+  %7 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 1\n+  %8 = load i32* %7, align 4\n+  %9 = icmp ult i32 %8, %6\n+  br i1 %9, label %10, label %_Z16reserve_vec_fastPP8rust_vecm.exit\n+\n+; <label>:10                                      ; preds = %0\n+  %11 = add i32 %6, -1\n+  %12 = lshr i32 %11, 1\n+  %13 = or i32 %12, %11\n+  %14 = lshr i32 %13, 2\n+  %15 = or i32 %14, %13\n+  %16 = lshr i32 %15, 4\n+  %17 = or i32 %16, %15\n+  %18 = lshr i32 %17, 8\n+  %19 = or i32 %18, %17\n+  %20 = lshr i32 %19, 16\n+  %21 = or i32 %20, %19\n+  %22 = add i32 %21, 1\n+  %23 = add i32 %21, 9\n+  %24 = bitcast %struct.rust_vec* %1 to i8*\n+  %25 = tail call i8* @upcall_shared_realloc(i8* %24, i32 %23)\n+  %26 = bitcast i8* %25 to %struct.rust_vec*\n+  store %struct.rust_vec* %26, %struct.rust_vec** %vp, align 4\n+  %27 = getelementptr inbounds i8* %25, i32 4\n+  %28 = bitcast i8* %27 to i32*\n+  store i32 %22, i32* %28, align 4\n+  %.pr = load i32* %4, align 4\n+  %.pre = load %struct.rust_vec** %vp, align 4\n+  %.phi.trans.insert = getelementptr inbounds %struct.rust_vec* %.pre, i32 0, i32 0\n+  %.pre4 = load i32* %.phi.trans.insert, align 4\n+  br label %_Z16reserve_vec_fastPP8rust_vecm.exit\n+\n+_Z16reserve_vec_fastPP8rust_vecm.exit:            ; preds = %0, %10\n+  %29 = phi i32 [ %3, %0 ], [ %.pre4, %10 ]\n+  %30 = phi %struct.rust_vec* [ %1, %0 ], [ %.pre, %10 ]\n+  %31 = phi i32 [ %5, %0 ], [ %.pr, %10 ]\n+  %32 = getelementptr inbounds %struct.rust_vec* %30, i32 0, i32 0\n+  %33 = getelementptr inbounds %struct.rust_vec* %30, i32 0, i32 2, i32 %29\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %33, i8* %elt, i32 %31, i32 1, i1 false)\n+  %34 = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 3\n+  %35 = load void (i8*, i8*, %struct.type_desc**, i8*)** %34, align 4\n+  %36 = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %35, null\n+  br i1 %36, label %_ZL13copy_elementsP9type_descPvS1_m.exit, label %37\n+\n+; <label>:37                                      ; preds = %_Z16reserve_vec_fastPP8rust_vecm.exit\n+  %38 = load i32* %4, align 4\n+  %39 = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 0\n+  %40 = load %struct.type_desc*** %39, align 4\n+  %41 = icmp sgt i32 %31, 0\n+  br i1 %41, label %.lr.ph.i.preheader, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n+\n+.lr.ph.i.preheader:                               ; preds = %37\n+  %scevgep = getelementptr %struct.rust_vec* %30, i32 1, i32 0\n+  %scevgep2 = bitcast i32* %scevgep to i8*\n+  br label %.lr.ph.i\n+\n+.lr.ph.i:                                         ; preds = %.lr.ph.i.preheader, %.lr.ph.i\n+  %indvar.i = phi i32 [ %indvar.next.i, %.lr.ph.i ], [ 0, %.lr.ph.i.preheader ]\n+  %tmp = mul i32 %38, %indvar.i\n+  %tmp2.i = add i32 %38, %tmp\n+  %tmp3 = add i32 %29, %tmp\n+  %p.01.i = getelementptr i8* %scevgep2, i32 %tmp3\n+  tail call void %35(i8* null, i8* null, %struct.type_desc** %40, i8* %p.01.i)\n+  %42 = icmp slt i32 %tmp2.i, %31\n+  %indvar.next.i = add i32 %indvar.i, 1\n+  br i1 %42, label %.lr.ph.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n+\n+_ZL13copy_elementsP9type_descPvS1_m.exit:         ; preds = %.lr.ph.i, %_Z16reserve_vec_fastPP8rust_vecm.exit, %37\n+  %43 = load i32* %4, align 4\n+  %44 = load i32* %32, align 4\n+  %45 = add i32 %44, %43\n+  store i32 %45, i32* %32, align 4\n   ret void\n }\n \n define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n-entry:\n   tail call void @upcall_intrinsic_vec_push(%struct.rust_vec** %vp, %struct.type_desc* %elt_ty, i8* %elt)\n   ret void\n }\n \n-declare i8* @upcall_shared_realloc(i8*, i32)\n+define void @rust_intrinsic_frame_address(i8** nocapture %p) nounwind {\n+  %1 = tail call i8* @llvm.frameaddress(i32 1)\n+  store i8* %1, i8** %p, align 4\n+  ret void\n+}\n+\n+declare i8* @llvm.frameaddress(i32) nounwind readnone\n \n-!0 = metadata !{metadata !\"any pointer\", metadata !1}\n-!1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n-!2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n-!3 = metadata !{metadata !\"int\", metadata !1}\n+declare i8* @upcall_shared_realloc(i8*, i32)"}, {"sha": "d18c1f7c9e4264ce27e0cb3d4a098fef72bc8e05", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "modified", "additions": 178, "deletions": 183, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -1,242 +1,237 @@\n ; ModuleID = 'src/rt/intrinsics/intrinsics.cpp'\n-; target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+; target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\n target triple = \"@CFG_TARGET_TRIPLE@\"\n \n-%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, i8*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n-%struct.rust_shape_tables = type { i8*, i8* }\n-%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n-%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i64, i32, i32, i32, i32 }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.rust_vec = type { i64, i64, [0 x i8] }\n-%struct.rust_fn = type { i64*, %struct.rust_box* }\n-%struct.rust_box = type opaque\n-%struct.rust_task = type { i64, i64, i8, %struct.chan_handle, [8 x i8], %class.context, %struct.stk_seg*, i64, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, i64*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map.3, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64, i8, i8, %struct.stk_seg*, i64, i64, %class.rust_port_selector, [8 x i8] }\n-%struct.chan_handle = type { i64, i64 }\n+%0 = type { i64, %struct.rust_task**, i64 }\n+%1 = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n+%class.array_list = type { i64, %\"struct.memory_region::alloc_header\"**, i64 }\n+%class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n+%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n %class.context = type { %struct.registers_t, %class.context*, [8 x i8] }\n-%struct.registers_t = type { [22 x i64] }\n-%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i64, i32, i64, [0 x i8] }\n-%class.rust_scheduler = type opaque\n-%struct.rust_task_thread = type { %class.rust_thread, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [8 x i8] }\n-%class.rust_thread = type { i32 (...)**, i64, i64 }\n+%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n+%class.hash_map = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%class.indexed_list = type { i32 (...)**, %0 }\n+%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_attr_t, %struct._opaque_pthread_t* }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i64 }\n+%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i64, i64, %1, %class.lock_and_signal, i32, %class.lock_and_signal, i64, %\"class.std::map\", %\"class.std::vector\", %struct.rust_env* }\n %class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n+%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, i64, %class.circular_buffer, %class.lock_and_signal }\n+%class.rust_port_selector = type { %class.rust_port**, i64, %class.lock_and_signal }\n+%class.rust_scheduler = type opaque\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n-%struct.rust_env = type { i64, i64, i64, i8*, i8, i8, i8* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n-%class.array_list = type { i64, %\"struct.memory_region::alloc_header\"**, i64 }\n-%\"struct.memory_region::alloc_header\" = type { i8 }\n-%class.lock_and_signal = type { i32 (...)**, %union.pthread_cond_t, %union.pthread_mutex_t, i64 }\n-%union.pthread_cond_t = type { %struct.anon }\n-%struct.anon = type { i32, i32, i64, i64, i64, i8*, i32, i32 }\n-%union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n-%\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, i32, %struct.__pthread_internal_list }\n-%struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }\n %class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n-%class.array_list.1 = type { i64, %struct.rust_task**, i64 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i64 }\n-%struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n-%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n-%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i64, i64, %class.hash_map, %class.lock_and_signal, i32, %class.lock_and_signal, i64, i64, %\"class.std::map\", %struct.rust_env* }\n-%class.hash_map = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%class.rust_thread = type { i32 (...)**, %struct._opaque_pthread_t*, i64 }\n %\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i64 }\n-%\"struct.std::less\" = type { i8 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%union.pthread_attr_t = type { i64, [48 x i8] }\n-%struct.rust_cond = type { i8 }\n-%class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n-%struct.rust_opaque_box = type { i64, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n-%class.hash_map.3 = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n+%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n+%\"class.std::vector\" = type { %\"struct.std::_Vector_base\" }\n+%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n+%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n+%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i64, i32, i32, i32, i32 }\n+%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n+%struct._opaque_pthread_attr_t = type { i64, [56 x i8] }\n+%struct._opaque_pthread_cond_t = type { i64, [40 x i8] }\n+%struct._opaque_pthread_t = type { i64, %struct.__darwin_pthread_handler_rec*, [1168 x i8] }\n+%struct.chan_handle = type { i64, i64 }\n %\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n-%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n+%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n+%\"struct.memory_region::alloc_header\" = type { i8 }\n+%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n+%struct.registers_t = type { [22 x i64] }\n+%struct.rust_box = type opaque\n+%struct.rust_env = type { i64, i64, i64, i8*, i8, i8, i8* }\n+%struct.rust_fn = type { i64*, %struct.rust_box* }\n+%struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n %struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i64, i64, i64, [0 x i8] }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map.4\" }\n-%\"class.std::map.4\" = type { %\"class.std::_Rb_tree.5\" }\n-%\"class.std::_Rb_tree.5\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n-%\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less.9\", %\"struct.std::_Rb_tree_node_base\", i64 }\n-%\"struct.std::less.9\" = type { i8 }\n-%class.rust_port_selector = type { %class.rust_port**, i64, %class.lock_and_signal }\n-%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, i64, %class.circular_buffer, %class.lock_and_signal }\n-%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n+%struct.rust_opaque_box = type { i64, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n+%struct.rust_shape_tables = type { i8*, i8* }\n+%struct.rust_task = type { i64, i64, i8, %struct.chan_handle, [8 x i8], %class.context, %struct.stk_seg*, i64, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %\"struct.memory_region::alloc_header\"*, i8*, %struct.rust_task*, i32, i64, i64*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64, i8, i8, %struct.stk_seg*, i64, i64, %class.rust_port_selector }\n+%struct.rust_task_thread = type { %class.rust_thread, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i64, %struct._opaque_pthread_attr_t, %struct.rust_env*, %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [8 x i8] }\n+%struct.rust_vec = type { i64, i64, [0 x i8] }\n+%\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.memory_region::alloc_header\", %\"struct.std::_Rb_tree_node_base\", i64 }\n+%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n+%\"struct.std::_Vector_base\" = type { %\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" }\n+%\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" = type { i64*, i64*, i64* }\n+%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i64, i32, i64, [0 x i8] }\n+%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, i8*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n \n-define void @rust_intrinsic_vec_len(i64* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind uwtable {\n-entry:\n-  %0 = load %struct.rust_vec** %vp, align 8, !tbaa !0\n-  %fill = getelementptr inbounds %struct.rust_vec* %0, i64 0, i32 0\n-  %1 = load i64* %fill, align 8, !tbaa !3\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %size, align 8, !tbaa !3\n-  %div = udiv i64 %1, %2\n-  store i64 %div, i64* %retptr, align 8, !tbaa !3\n+define void @rust_intrinsic_vec_len(i64* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n+  %1 = load %struct.rust_vec** %vp, align 8\n+  %2 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 0\n+  %3 = load i64* %2, align 8\n+  %4 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %5 = load i64* %4, align 8\n+  %6 = udiv i64 %3, %5\n+  store i64 %6, i64* %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i64 %count) nounwind uwtable {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %0 = load i64* %size, align 8, !tbaa !3\n-  %mul = mul i64 %0, %count\n-  %arrayidx = getelementptr inbounds i8* %ptr, i64 %mul\n-  store i8* %arrayidx, i8** %retptr, align 8, !tbaa !0\n+define void @rust_intrinsic_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i64 %count) nounwind {\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %2 = load i64* %1, align 8\n+  %3 = mul i64 %2, %count\n+  %4 = getelementptr inbounds i8* %ptr, i64 %3\n+  store i8* %4, i8** %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) nounwind uwtable {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %t1, i64 0, i32 1\n-  %0 = load i64* %size, align 8, !tbaa !3\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %retptr, i8* %src, i64 %0, i32 1, i1 false)\n+define void @rust_intrinsic_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) nounwind {\n+  %1 = getelementptr inbounds %struct.type_desc* %t1, i64 0, i32 1\n+  %2 = load i64* %1, align 8\n+  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %retptr, i8* %src, i64 %2, i32 1, i1 false)\n   ret void\n }\n \n declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n \n-define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind uwtable {\n-entry:\n-  store i8* %valptr, i8** %retptr, align 8, !tbaa !0\n+define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n+  store i8* %valptr, i8** %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) uwtable {\n-entry:\n-  %fn1 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 0\n-  %0 = load i64** %fn1, align 8, !tbaa !0\n-  %1 = bitcast i64* %0 to void (i8**, i8*, i8**)*\n-  %env2 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 1\n-  %2 = load %struct.rust_box** %env2, align 8, !tbaa !0\n-  %3 = bitcast %struct.rust_box* %2 to i8*\n-  tail call void %1(i8** null, i8* %3, i8** %retptr)\n+define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) {\n+  %1 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 0\n+  %2 = load i64** %1, align 8\n+  %3 = bitcast i64* %2 to void (i8**, i8*, i8**)*\n+  %4 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 1\n+  %5 = load %struct.rust_box** %4, align 8\n+  %6 = bitcast %struct.rust_box* %5 to i8*\n+  tail call void %3(i8** null, i8* %6, i8** %retptr)\n   ret void\n }\n \n-define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind uwtable {\n-entry:\n+define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n   %ty.c = bitcast %struct.type_desc* %ty to i8*\n-  store i8* %ty.c, i8** %retptr, align 8, !tbaa !0\n+  store i8* %ty.c, i8** %retptr, align 8\n   ret void\n }\n \n-define void @rust_intrinsic_task_yield(i8** nocapture %retptr, i8* nocapture %env, %struct.rust_task* %task, i8* %killed) uwtable {\n-entry:\n+define void @rust_intrinsic_task_yield(i8** nocapture %retptr, i8* nocapture %env, %struct.rust_task* %task, i8* %killed) {\n   tail call void @rust_task_yield(%struct.rust_task* %task, i8* %killed)\n   ret void\n }\n \n declare void @rust_task_yield(%struct.rust_task*, i8*)\n \n-define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind uwtable {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %0 = load i64* %size, align 8, !tbaa !3\n-  %mul = mul i64 %0, %count\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %mul, i32 1, i1 false)\n+define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind {\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %2 = load i64* %1, align 8\n+  %3 = mul i64 %2, %count\n+  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %3, i32 1, i1 false)\n   ret void\n }\n \n-define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind uwtable {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %0 = load i64* %size, align 8, !tbaa !3\n-  %mul = mul i64 %0, %count\n-  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %mul, i32 1, i1 false)\n+define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind {\n+  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n+  %2 = load i64* %1, align 8\n+  %3 = mul i64 %2, %count\n+  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %3, i32 1, i1 false)\n   ret void\n }\n \n declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n \n-define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind uwtable readnone {\n-entry:\n+define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind readnone {\n   ret void\n }\n \n-define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) uwtable {\n-entry:\n-  %0 = load %struct.rust_vec** %vp, align 8, !tbaa !0\n-  %fill = getelementptr inbounds %struct.rust_vec* %0, i64 0, i32 0\n-  %1 = load i64* %fill, align 8, !tbaa !3\n-  %size = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 1\n-  %2 = load i64* %size, align 8, !tbaa !3\n-  %add = add i64 %2, %1\n-  %alloc.i = getelementptr inbounds %struct.rust_vec* %0, i64 0, i32 1\n-  %3 = load i64* %alloc.i, align 8, !tbaa !3\n-  %cmp.i = icmp ult i64 %3, %add\n-  br i1 %cmp.i, label %if.then.i, label %_Z16reserve_vec_fastPP8rust_vecm.exit\n-\n-if.then.i:                                        ; preds = %entry\n-  %sub.i.i = add i64 %add, -1\n-  %shr.i.i = lshr i64 %sub.i.i, 1\n-  %or.i.i = or i64 %shr.i.i, %sub.i.i\n-  %shr1.i.i = lshr i64 %or.i.i, 2\n-  %or2.i.i = or i64 %shr1.i.i, %or.i.i\n-  %shr3.i.i = lshr i64 %or2.i.i, 4\n-  %or4.i.i = or i64 %shr3.i.i, %or2.i.i\n-  %shr5.i.i = lshr i64 %or4.i.i, 8\n-  %or6.i.i = or i64 %shr5.i.i, %or4.i.i\n-  %shr7.i.i = lshr i64 %or6.i.i, 16\n-  %or8.i.i = or i64 %shr7.i.i, %or6.i.i\n-  %shr9.i.i = lshr i64 %or8.i.i, 32\n-  %or10.i.i = or i64 %shr9.i.i, %or8.i.i\n-  %add.i.i = add i64 %or10.i.i, 1\n-  %add.i = add i64 %or10.i.i, 17\n-  %4 = bitcast %struct.rust_vec* %0 to i8*\n-  %call1.i = tail call i8* @upcall_shared_realloc(i8* %4, i64 %add.i)\n-  %5 = bitcast i8* %call1.i to %struct.rust_vec*\n-  store %struct.rust_vec* %5, %struct.rust_vec** %vp, align 8, !tbaa !0\n-  %alloc2.i = getelementptr inbounds i8* %call1.i, i64 8\n-  %6 = bitcast i8* %alloc2.i to i64*\n-  store i64 %add.i.i, i64* %6, align 8, !tbaa !3\n-  %.pr = load i64* %size, align 8\n-  %fill1.phi.trans.insert = bitcast i8* %call1.i to i64*\n-  %.pre = load i64* %fill1.phi.trans.insert, align 8, !tbaa !3\n+define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n+; <label>:0\n+  %1 = load %struct.rust_vec** %vp, align 8\n+  %2 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 0\n+  %3 = load i64* %2, align 8\n+  %4 = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 1\n+  %5 = load i64* %4, align 8\n+  %6 = add i64 %5, %3\n+  %7 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 1\n+  %8 = load i64* %7, align 8\n+  %9 = icmp ult i64 %8, %6\n+  br i1 %9, label %10, label %_Z16reserve_vec_fastPP8rust_vecm.exit\n+\n+; <label>:10                                      ; preds = %0\n+  %11 = add i64 %6, -1\n+  %12 = lshr i64 %11, 1\n+  %13 = or i64 %12, %11\n+  %14 = lshr i64 %13, 2\n+  %15 = or i64 %14, %13\n+  %16 = lshr i64 %15, 4\n+  %17 = or i64 %16, %15\n+  %18 = lshr i64 %17, 8\n+  %19 = or i64 %18, %17\n+  %20 = lshr i64 %19, 16\n+  %21 = or i64 %20, %19\n+  %22 = lshr i64 %21, 32\n+  %23 = or i64 %22, %21\n+  %24 = add i64 %23, 1\n+  %25 = add i64 %23, 17\n+  %26 = bitcast %struct.rust_vec* %1 to i8*\n+  %27 = tail call i8* @upcall_shared_realloc(i8* %26, i64 %25)\n+  %28 = bitcast i8* %27 to %struct.rust_vec*\n+  store %struct.rust_vec* %28, %struct.rust_vec** %vp, align 8\n+  %29 = getelementptr inbounds i8* %27, i64 8\n+  %30 = bitcast i8* %29 to i64*\n+  store i64 %24, i64* %30, align 8\n+  %.pr = load i64* %4, align 8\n+  %.pre = load %struct.rust_vec** %vp, align 8\n+  %.phi.trans.insert = getelementptr inbounds %struct.rust_vec* %.pre, i64 0, i32 0\n+  %.pre4 = load i64* %.phi.trans.insert, align 8\n   br label %_Z16reserve_vec_fastPP8rust_vecm.exit\n \n-_Z16reserve_vec_fastPP8rust_vecm.exit:            ; preds = %entry, %if.then.i\n-  %7 = phi i64 [ %1, %entry ], [ %.pre, %if.then.i ]\n-  %8 = phi %struct.rust_vec* [ %0, %entry ], [ %5, %if.then.i ]\n-  %9 = phi i64 [ %2, %entry ], [ %.pr, %if.then.i ]\n-  %fill1 = getelementptr inbounds %struct.rust_vec* %8, i64 0, i32 0\n-  %add.ptr = getelementptr inbounds %struct.rust_vec* %8, i64 0, i32 2, i64 %7\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr, i8* %elt, i64 %9, i32 1, i1 false)\n-  %take_glue.i = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 3\n-  %10 = load void (i8*, i8*, %struct.type_desc**, i8*)** %take_glue.i, align 8, !tbaa !0\n-  %tobool.i = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %10, null\n-  br i1 %tobool.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit, label %if.then.i6\n-\n-if.then.i6:                                       ; preds = %_Z16reserve_vec_fastPP8rust_vecm.exit\n-  %11 = load i64* %size, align 8, !tbaa !3\n-  %first_param.i = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 0\n-  %12 = load %struct.type_desc*** %first_param.i, align 8, !tbaa !0\n-  %add.ptr.sum = add i64 %7, %9\n-  %add.ptr.i = getelementptr inbounds %struct.rust_vec* %8, i64 0, i32 2, i64 %add.ptr.sum\n-  %cmp4.i = icmp sgt i64 %9, 0\n-  br i1 %cmp4.i, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n-\n-for.body.i:                                       ; preds = %if.then.i6, %for.body.i\n-  %p.05.i = phi i8* [ %add.ptr3.i, %for.body.i ], [ %add.ptr, %if.then.i6 ]\n-  tail call void %10(i8* null, i8* null, %struct.type_desc** %12, i8* %p.05.i)\n-  %add.ptr3.i = getelementptr inbounds i8* %p.05.i, i64 %11\n-  %cmp.i7 = icmp ult i8* %add.ptr3.i, %add.ptr.i\n-  br i1 %cmp.i7, label %for.body.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n-\n-_ZL13copy_elementsP9type_descPvS1_m.exit:         ; preds = %for.body.i, %_Z16reserve_vec_fastPP8rust_vecm.exit, %if.then.i6\n-  %13 = load i64* %size, align 8, !tbaa !3\n-  %14 = load i64* %fill1, align 8, !tbaa !3\n-  %add5 = add i64 %14, %13\n-  store i64 %add5, i64* %fill1, align 8, !tbaa !3\n+_Z16reserve_vec_fastPP8rust_vecm.exit:            ; preds = %0, %10\n+  %31 = phi i64 [ %3, %0 ], [ %.pre4, %10 ]\n+  %32 = phi %struct.rust_vec* [ %1, %0 ], [ %.pre, %10 ]\n+  %33 = phi i64 [ %5, %0 ], [ %.pr, %10 ]\n+  %34 = getelementptr inbounds %struct.rust_vec* %32, i64 0, i32 0\n+  %35 = getelementptr inbounds %struct.rust_vec* %32, i64 0, i32 2, i64 %31\n+  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %35, i8* %elt, i64 %33, i32 1, i1 false)\n+  %36 = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 3\n+  %37 = load void (i8*, i8*, %struct.type_desc**, i8*)** %36, align 8\n+  %38 = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %37, null\n+  br i1 %38, label %_ZL13copy_elementsP9type_descPvS1_m.exit, label %39\n+\n+; <label>:39                                      ; preds = %_Z16reserve_vec_fastPP8rust_vecm.exit\n+  %40 = load i64* %4, align 8\n+  %41 = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 0\n+  %42 = load %struct.type_desc*** %41, align 8\n+  %43 = icmp sgt i64 %33, 0\n+  br i1 %43, label %.lr.ph.i.preheader, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n+\n+.lr.ph.i.preheader:                               ; preds = %39\n+  %scevgep = getelementptr %struct.rust_vec* %32, i64 1, i32 0\n+  %scevgep2 = bitcast i64* %scevgep to i8*\n+  br label %.lr.ph.i\n+\n+.lr.ph.i:                                         ; preds = %.lr.ph.i.preheader, %.lr.ph.i\n+  %indvar.i = phi i64 [ %indvar.next.i, %.lr.ph.i ], [ 0, %.lr.ph.i.preheader ]\n+  %tmp = mul i64 %40, %indvar.i\n+  %tmp2.i = add i64 %40, %tmp\n+  %tmp3 = add i64 %31, %tmp\n+  %p.01.i = getelementptr i8* %scevgep2, i64 %tmp3\n+  tail call void %37(i8* null, i8* null, %struct.type_desc** %42, i8* %p.01.i)\n+  %44 = icmp slt i64 %tmp2.i, %33\n+  %indvar.next.i = add i64 %indvar.i, 1\n+  br i1 %44, label %.lr.ph.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n+\n+_ZL13copy_elementsP9type_descPvS1_m.exit:         ; preds = %.lr.ph.i, %_Z16reserve_vec_fastPP8rust_vecm.exit, %39\n+  %45 = load i64* %4, align 8\n+  %46 = load i64* %34, align 8\n+  %47 = add i64 %46, %45\n+  store i64 %47, i64* %34, align 8\n   ret void\n }\n \n-define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) uwtable {\n-entry:\n+define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n   tail call void @upcall_intrinsic_vec_push(%struct.rust_vec** %vp, %struct.type_desc* %elt_ty, i8* %elt)\n   ret void\n }\n \n-declare i8* @upcall_shared_realloc(i8*, i64)\n+define void @rust_intrinsic_frame_address(i8** nocapture %p) nounwind {\n+  %1 = tail call i8* @llvm.frameaddress(i32 1)\n+  store i8* %1, i8** %p, align 8\n+  ret void\n+}\n+\n+declare i8* @llvm.frameaddress(i32) nounwind readnone\n \n-!0 = metadata !{metadata !\"any pointer\", metadata !1}\n-!1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n-!2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n-!3 = metadata !{metadata !\"long\", metadata !1}\n+declare i8* @upcall_shared_realloc(i8*, i64)"}, {"sha": "cacae7259caa4170bbef9dd66b36fb7326e32250", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -682,11 +682,6 @@ rust_dbg_call(dbg_callback cb, void *data) {\n     return cb(data);\n }\n \n-extern \"C\" CDECL void *\n-rust_frame_address() {\n-    return __builtin_frame_address(1);\n-}\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "79255a63dd80f8dd4a9c3da4a15b605417fafe52", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -101,4 +101,3 @@ rust_dbg_lock_unlock\n rust_dbg_lock_wait\n rust_dbg_lock_signal\n rust_dbg_call\n-rust_frame_address"}, {"sha": "47fa5a11bdf0cb72df9db1fee3c70b498395aaa4", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -0,0 +1,10 @@\n+impl helpers for uint {\n+    #[inline]\n+    fn to(v: uint, f: fn(uint)) {\n+        let i = self;\n+        while i < v {\n+            f(i);\n+            i += 1u;\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "ff6b923035dd69aaf806f505f593440b03ae0309", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -0,0 +1,9 @@\n+// same as cci_iter_lib, more-or-less, but not marked inline\n+fn iter(v: [uint], f: fn(uint)) {\n+    let i = 0u;\n+    let n = vec::len(v);\n+    while i < n {\n+        f(v[i]);\n+        i += 1u;\n+    }\n+}"}, {"sha": "a34e185adccc92a694180901a9856c15c38ed225", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -0,0 +1,19 @@\n+// aux-build:cci_impl_lib.rs\n+\n+use std;\n+use cci_impl_lib;\n+import std::io;\n+import cci_impl_lib::helpers;\n+\n+fn main() {\n+    //let bt0 = sys::frame_address();\n+    //#debug[\"%?\", bt0];\n+\n+    3u.to(10u) {|i|\n+        io::print(#fmt[\"%u\\n\", i]);\n+\n+        //let bt1 = sys::frame_address();\n+        //#debug[\"%?\", bt1];\n+        //assert bt0 == bt1;\n+    }\n+}"}, {"sha": "6799daf93e8312de484097ad8c97add0713344b2", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:cci_iter_lib.rs\n+\n+use std;\n+use cci_iter_lib;\n+\n+import std::io;\n+\n+fn main() {\n+    //let bt0 = sys::rusti::frame_address(1u32);\n+    //#debug[\"%?\", bt0];\n+    cci_iter_lib::iter([1, 2, 3]) {|i|\n+        io::print(#fmt[\"%d\", i]);\n+        //assert bt0 == sys::rusti::frame_address(2u32);\n+    }\n+}"}, {"sha": "eca86bcf82cc7dee2a3643fe704f38b614d256fe", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def72bda47977b3bc36143eba9692bff12a8303c/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=def72bda47977b3bc36143eba9692bff12a8303c", "patch": "@@ -0,0 +1,25 @@\n+// aux-build:cci_no_inline_lib.rs\n+\n+use std;\n+use cci_no_inline_lib;\n+import cci_no_inline_lib::iter;\n+\n+import std::io;\n+\n+fn main() {\n+    // Check that a cross-crate call function not marked as inline\n+    // does not, in fact, get inlined.  Also, perhaps more\n+    // importantly, checks that our scheme of using\n+    // sys::frame_address() to determine if we are inlining is\n+    // actually working.\n+    //let bt0 = sys::frame_address();\n+    //#debug[\"%?\", bt0];\n+    iter([1u, 2u, 3u]) {|i|\n+        io::print(#fmt[\"%u\\n\", i]);\n+\n+        //let bt1 = sys::frame_address();\n+        //#debug[\"%?\", bt1];\n+\n+        //assert bt0 != bt1;\n+    }\n+}"}]}