{"sha": "6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkY2QxMmRjMjJlYjg5MWM3MjZkYmY1YzFjNDE3N2Q0ZTcyODc0ZDg=", "commit": {"author": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-02-01T15:01:21Z"}, "committer": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-02-04T03:41:49Z"}, "message": "Implement quasi-quoting of multiple syntatic categories.", "tree": {"sha": "7def5cc5933131b87e0bc3223eaf93e7622e305b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7def5cc5933131b87e0bc3223eaf93e7622e305b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "html_url": "https://github.com/rust-lang/rust/commit/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/comments", "author": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a199c0361946fbab75212c3a7d23ab03520598", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a199c0361946fbab75212c3a7d23ab03520598", "html_url": "https://github.com/rust-lang/rust/commit/35a199c0361946fbab75212c3a7d23ab03520598"}], "stats": {"total": 138, "additions": 114, "deletions": 24}, "files": [{"sha": "20f04bf5cd5fe3e3a9fffe0d7cae1dfae32960cc", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "patch": "@@ -8,7 +8,7 @@ import vec;\n import syntax::ast::{crate, expr_, expr_mac, mac_invoc, mac_qq};\n import syntax::fold::*;\n import syntax::ext::base::*;\n-import syntax::ext::qquote::expand_qquote;\n+import syntax::ext::qquote::{expand_qquote,qq_helper};\n import syntax::parse::parser::parse_expr_from_source_str;\n \n import codemap::span;"}, {"sha": "174c58d807c6dcca8b9d26c64ac5326251f18f73", "filename": "src/comp/syntax/ext/qquote.rs", "status": "modified", "additions": 111, "deletions": 21, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs?ref=6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "patch": "@@ -9,7 +9,7 @@ import syntax::visit::*;\n import syntax::ext::base::*;\n import syntax::ext::build::*;\n import syntax::parse::parser;\n-import syntax::parse::parser::{parse_from_source_str};\n+import syntax::parse::parser::{parser, parse_from_source_str};\n \n import syntax::print::*;\n import std::io::*;\n@@ -19,12 +19,53 @@ import codemap::span;\n type aq_ctxt = @{lo: uint,\n                  mutable gather: [{lo: uint, hi: uint, e: @ast::expr}]};\n \n-fn gather_anti_quotes(lo: uint, e: @ast::expr) -> aq_ctxt\n+iface qq_helper {\n+    fn span() -> span;\n+    fn visit(aq_ctxt, vt<aq_ctxt>);\n+    fn mk_parse_fn(ext_ctxt,span) -> @ast::expr;\n+}\n+impl of qq_helper for @ast::expr {\n+    fn span() -> span {self.span}\n+    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n+    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n+        mk_path(cx, sp, [\"syntax\", \"parse\", \"parser\", \"parse_expr\"])\n+    }\n+}\n+impl of qq_helper for @ast::ty {\n+    fn span() -> span {self.span}\n+    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n+    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n+        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_ty\"])\n+    }\n+}\n+impl of qq_helper for @ast::item {\n+    fn span() -> span {self.span}\n+    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n+    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n+        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_item\"])\n+    }\n+}\n+impl of qq_helper for @ast::stmt {\n+    fn span() -> span {self.span}\n+    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n+    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n+        mk_path(cx, sp, [\"syntax\", \"ext\", \"qquote\", \"parse_stmt\"])\n+    }\n+}\n+impl of qq_helper for @ast::pat {\n+    fn span() -> span {self.span}\n+    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n+    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n+        mk_path(cx, sp, [\"syntax\", \"parse\", \"parser\", \"parse_pat\"])\n+    }\n+}\n+\n+fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n {\n     let v = @{visit_expr: visit_expr_aq\n               with *default_visitor()};\n     let cx = @{lo:lo, mutable gather: []};\n-    visit_expr_aq(e, cx, mk_vt(v));\n+    node.visit(cx, mk_vt(v));\n     ret cx;\n }\n \n@@ -43,31 +84,78 @@ fn is_space(c: char) -> bool {\n     syntax::parse::lexer::is_whitespace(c)\n }\n \n-fn expand_ast(ecx: ext_ctxt, _sp: span, _arg:\n-              ast::mac_arg, body: ast::mac_body)\n+fn expand_ast(ecx: ext_ctxt, _sp: span,\n+              arg: ast::mac_arg, body: ast::mac_body)\n     -> @ast::expr\n {\n+    let what = \"expr\";\n+    option::may(arg) {|arg|\n+        let args: [@ast::expr] =\n+            alt arg.node {\n+              ast::expr_vec(elts, _) { elts }\n+              _ {\n+                ecx.span_fatal\n+                    (_sp, \"#ast requires arguments of the form `[...]`.\")\n+              }\n+            };\n+        if vec::len::<@ast::expr>(args) != 1u {\n+            ecx.span_fatal(_sp, \"#ast requires exactly one arg\");\n+        }\n+        alt (args[0].node) {\n+          ast::expr_path(@{node: {idents: id, _},_}) if vec::len(id) == 1u\n+              {what = id[0]}\n+          _ {ecx.span_fatal(args[0].span, \"expected an identifier\");}\n+        }\n+    }\n     let body = get_mac_body(ecx,_sp,body);\n-    let cm = ecx.session().parse_sess.cm;\n-    let str = @codemap::span_to_snippet(body.span, cm);\n-    let (fname, ss) = codemap::get_substr_info(cm,\n-                                               body.span.lo, body.span.hi);\n-    let {node: e, _} = parse_from_source_str(parser::parse_expr,\n-                                             fname, some(ss), str,\n-                                             ecx.session().opts.cfg,\n-                                             ecx.session().parse_sess);\n-    ret expand_qquote(ecx, e.span, some(*str), e);\n-}\n-\n-fn expand_qquote(ecx: ext_ctxt, sp: span, maybe_str: option::t<str>,\n-                 e: @ast::expr)\n+    fn finish<T: qq_helper>(ecx: ext_ctxt, body: ast::mac_body_,\n+                            f: fn (p: parser) -> T)\n+        -> @ast::expr\n+    {\n+        let cm = ecx.session().parse_sess.cm;\n+        let str = @codemap::span_to_snippet(body.span, cm);\n+        let (fname, ss) = codemap::get_substr_info\n+            (cm, body.span.lo, body.span.hi);\n+        let node = parse_from_source_str\n+            (f, fname, some(ss), str,\n+             ecx.session().opts.cfg, ecx.session().parse_sess);\n+        ret expand_qquote(ecx, node.span(), some(*str), node);\n+    }\n+\n+    ret alt what {\n+      \"expr\" {finish(ecx, body, parser::parse_expr)}\n+      \"ty\" {finish(ecx, body, parse_ty)}\n+      \"item\" {finish(ecx, body, parse_item)}\n+      \"stmt\" {finish(ecx, body, parse_stmt)}\n+      \"pat\" {finish(ecx, body, parser::parse_pat)}\n+      _ {ecx.span_fatal(_sp, \"unsupported ast type\")}\n+    };\n+}\n+\n+fn parse_ty(p: parser) -> @ast::ty {\n+    parser::parse_ty(p, false)\n+}\n+\n+fn parse_stmt(p: parser) -> @ast::stmt {\n+    parser::parse_stmt(p, [])\n+}\n+\n+fn parse_item(p: parser) -> @ast::item {\n+    alt (parser::parse_item(p, [])) {\n+      some(item) {item}\n+      none {fail; /* FIXME: Error message, somehow */}\n+    }\n+}\n+\n+fn expand_qquote<N: qq_helper>\n+    (ecx: ext_ctxt, sp: span, maybe_str: option::t<str>, node: N)\n     -> @ast::expr\n {\n     let str = alt(maybe_str) {\n       some(s) {s}\n       none {codemap::span_to_snippet(sp, ecx.session().parse_sess.cm)}\n     };\n-    let qcx = gather_anti_quotes(sp.lo, e);\n+    let qcx = gather_anti_quotes(sp.lo, node);\n     let cx = qcx;\n     let prev = 0u;\n     for {lo: lo, _} in cx.gather {\n@@ -107,8 +195,10 @@ fn expand_qquote(ecx: ext_ctxt, sp: span, maybe_str: option::t<str>,\n                                      []);\n     let pcall = mk_call(cx,sp,\n                        [\"syntax\", \"parse\", \"parser\",\n-                        \"parse_expr_from_source_str\"],\n-                       [mk_str(cx,sp, \"<anon>\"),\n+                        \"parse_from_source_str\"],\n+                       [node.mk_parse_fn(cx,sp),\n+                        mk_str(cx,sp, \"<anon>\"),\n+                        mk_path(cx,sp, [\"option\",\"none\"]),\n                         mk_unary(cx,sp, ast::box(ast::imm),\n                                  mk_str(cx,sp, str2)),\n                         mk_access_(cx,sp,"}, {"sha": "2327350eb822d39c6f51d143383597f7e4a9e8d9", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dcd12dc22eb891c726dbf5c1c4177d4e72874d8/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6dcd12dc22eb891c726dbf5c1c4177d4e72874d8", "patch": "@@ -2548,13 +2548,13 @@ fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n                             name: str, ss: codemap::file_substr,\n                             source: @str, cfg: ast::crate_cfg,\n                             sess: parse_sess)\n-    -> {node: T, fm: codemap::filemap}\n+    -> T\n {\n     let p = new_parser_from_source_str(sess, cfg, name, ss, source);\n     let r = f(p);\n     sess.chpos = p.reader.chpos;\n     sess.byte_pos = sess.byte_pos + p.reader.pos;\n-    ret {node: r, fm: option::get(vec::last(sess.cm.files))};\n+    ret r;\n }\n \n fn parse_crate_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,"}]}