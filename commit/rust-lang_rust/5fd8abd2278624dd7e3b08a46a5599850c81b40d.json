{"sha": "5fd8abd2278624dd7e3b08a46a5599850c81b40d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZDhhYmQyMjc4NjI0ZGQ3ZTNiMDhhNDZhNTU5OTg1MGM4MWI0MGQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-28T23:26:25Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-28T23:26:25Z"}, "message": "Ensure that we don't cause *new* hard errors if we suddenly can evaluate more constants during const prop", "tree": {"sha": "4948cb82d239cac8d97d3863cd8c002570331904", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4948cb82d239cac8d97d3863cd8c002570331904"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fd8abd2278624dd7e3b08a46a5599850c81b40d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd8abd2278624dd7e3b08a46a5599850c81b40d", "html_url": "https://github.com/rust-lang/rust/commit/5fd8abd2278624dd7e3b08a46a5599850c81b40d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fd8abd2278624dd7e3b08a46a5599850c81b40d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3abebd78dcab1cadf7535271ff2ac6188b33cb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3abebd78dcab1cadf7535271ff2ac6188b33cb8", "html_url": "https://github.com/rust-lang/rust/commit/b3abebd78dcab1cadf7535271ff2ac6188b33cb8"}], "stats": {"total": 70, "additions": 41, "deletions": 29}, "files": [{"sha": "c36f7935115536b22d53c7529b39ebe8928b324a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5fd8abd2278624dd7e3b08a46a5599850c81b40d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd8abd2278624dd7e3b08a46a5599850c81b40d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=5fd8abd2278624dd7e3b08a46a5599850c81b40d", "patch": "@@ -6,6 +6,7 @@ use std::cell::Cell;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::HirId;\n use rustc::mir::interpret::{InterpResult, PanicInfo, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n@@ -33,7 +34,6 @@ use crate::interpret::{\n     ScalarMaybeUndef, StackPopCleanup,\n };\n use crate::rustc::ty::subst::Subst;\n-use crate::rustc::ty::TypeFoldable;\n use crate::transform::{MirPass, MirSource};\n \n /// The maximum number of bytes that we'll allocate space for a return value.\n@@ -261,6 +261,9 @@ struct ConstPropagator<'mir, 'tcx> {\n     source_scopes: IndexVec<SourceScope, SourceScopeData>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     ret: Option<OpTy<'tcx, ()>>,\n+    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n+    // the last known `SourceInfo` here and just keep revisiting it.\n+    source_info: Option<SourceInfo>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -339,6 +342,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             ret: ret.map(Into::into),\n+            source_info: None,\n         }\n     }\n \n@@ -360,6 +364,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n     }\n \n+    fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n+        match &self.source_scopes[source_info.scope].local_data {\n+            ClearCrossCrate::Set(data) => Some(data.lint_root),\n+            ClearCrossCrate::Clear => None,\n+        }\n+    }\n+\n     fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n@@ -368,10 +379,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // FIXME(eddyb) move this to the `Panic(_)` error case, so that\n         // `f(self)` is always called, and that the only difference when the\n         // scope's `local_data` is missing, is that the lint isn't emitted.\n-        let lint_root = match &self.source_scopes[source_info.scope].local_data {\n-            ClearCrossCrate::Set(data) => data.lint_root,\n-            ClearCrossCrate::Clear => return None,\n-        };\n+        let lint_root = self.lint_root(source_info)?;\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -417,19 +425,31 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         r\n     }\n \n-    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n-        // `eval_const_to_op` uses `Instance::resolve` which still has a bug (#66901) in the\n-        // presence of trait items with a default body. So we just bail out if we aren't 100%\n-        // monomorphic.\n-        if c.literal.needs_subst() {\n-            return None;\n-        }\n+    fn eval_constant(\n+        &mut self,\n+        c: &Constant<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = c.span;\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let err = error_to_const_error(&self.ecx, error);\n-                err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                match self.lint_root(source_info) {\n+                    Some(lint_root) if c.literal.needs_subst() => {\n+                        // Out of backwards compatibility we cannot report hard errors in unused\n+                        // generic functions using associated constants of the generic parameters.\n+                        err.report_as_lint(\n+                            self.ecx.tcx,\n+                            \"erroneous constant used\",\n+                            lint_root,\n+                            Some(c.span),\n+                        );\n+                    }\n+                    _ => {\n+                        err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                    }\n+                }\n                 None\n             }\n         }\n@@ -442,7 +462,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c),\n+            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 self.eval_place(place, source_info)\n             }\n@@ -509,10 +529,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     let right_size = r.layout.size;\n                     let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n                     if r_bits.map_or(false, |b| b >= left_bits as u128) {\n-                        let lint_root = match &self.source_scopes[source_info.scope].local_data {\n-                            ClearCrossCrate::Set(data) => data.lint_root,\n-                            ClearCrossCrate::Clear => return None,\n-                        };\n+                        let lint_root = self.lint_root(source_info)?;\n                         let dir = if *op == BinOp::Shr { \"right\" } else { \"left\" };\n                         self.tcx.lint_hir(\n                             ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n@@ -570,13 +587,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             _ => {}\n         }\n \n-        // `eval_rvalue_into_place` uses `Instance::resolve` for constants which still has a bug\n-        // (#66901) in the presence of trait items with a default body. So we just bail out if we\n-        // aren't 100% monomorphic.\n-        if rvalue.needs_subst() {\n-            return None;\n-        }\n-\n         self.use_ecx(source_info, |this| {\n             trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n             this.ecx.eval_rvalue_into_place(rvalue, place)?;\n@@ -769,18 +779,19 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant);\n+        self.eval_constant(constant, self.source_info.unwrap());\n     }\n \n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n+        let source_info = statement.source_info;\n+        self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (ref place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(local) = place.as_local() {\n-                    let source = statement.source_info;\n                     let can_const_prop = self.can_const_prop[local];\n-                    if let Some(()) = self.const_prop(rval, place_layout, source, place) {\n+                    if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n                         if can_const_prop == ConstPropMode::FullConstProp\n                             || can_const_prop == ConstPropMode::OnlyPropagateInto\n                         {\n@@ -823,8 +834,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n-        self.super_terminator(terminator, location);\n         let source_info = terminator.source_info;\n+        self.source_info = Some(source_info);\n+        self.super_terminator(terminator, location);\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n                 if let Some(value) = self.eval_operand(&cond, source_info) {"}]}