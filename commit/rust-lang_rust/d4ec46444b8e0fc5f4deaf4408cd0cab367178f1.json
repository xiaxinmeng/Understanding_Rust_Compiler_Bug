{"sha": "d4ec46444b8e0fc5f4deaf4408cd0cab367178f1", "node_id": "C_kwDOAAsO6NoAKGQ0ZWM0NjQ0NGI4ZTBmYzVmNGRlYWY0NDA4Y2QwY2FiMzY3MTc4ZjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-20T22:37:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-20T22:37:40Z"}, "message": "Rollup merge of #93102 - dtolnay:ringbuffer, r=lcnr\n\nPretty printer algorithm revamp step 3\n\nThis PR follows #93065 as a third chunk of minor modernizations backported from https://github.com/dtolnay/prettyplease into rustc_ast_pretty.\n\nI've broken this up into atomic commits that hopefully are sensible in isolation. At every commit, the pretty printer is compilable and has runtime behavior that is identical to before and after the PR. None of the refactoring so far changes behavior.\n\nThis PR is the last chunk of non-behavior-changing cleanup. After this the **next PR** will begin backporting behavior changes from `prettyplease`, starting with block indentation:\n\n```rust\nmacro_rules! print_expr {\n    ($expr:expr) => {\n        println!(\"{}\", stringify!($expr));\n    };\n}\n\nfn main() {\n    print_expr!(Struct { x: 0, y: 0 });\n    print_expr!(Structtttttttttttttttttttttttttttttttttttttttttttttttttt { xxxxxxxxx: 0, yyyyyyyyy: 0 });\n}\n```\n\nOutput currently on master (nowhere near modern Rust style):\n\n```console\nStruct{x: 0, y: 0,}\nStructtttttttttttttttttttttttttttttttttttttttttttttttttt{xxxxxxxxx: 0,\n                                                         yyyyyyyyy: 0,}\n```\n\nAfter the upcoming PR for block indentation (based on https://github.com/dtolnay/prettyplease/commit/401d60c04213e6c66565e0e69a95b4588db5fdba):\n\n```console\nStruct { x: 0, y: 0, }\nStructtttttttttttttttttttttttttttttttttttttttttttttttttt {\n    xxxxxxxxx: 0,\n    yyyyyyyyy: 0,\n}\n```\n\nAnd the PR after that, for intelligent trailing commas (based on https://github.com/dtolnay/prettyplease/commit/e2a0297f1781b787b90bca5aba1bdb4966661882):\n\n```console\nStruct { x: 0, y: 0 }\nStructtttttttttttttttttttttttttttttttttttttttttttttttttt {\n    xxxxxxxxx: 0,\n    yyyyyyyyy: 0,\n}\n```", "tree": {"sha": "f4c5b8a48fb4c44b336a12c294099335b9e1b212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4c5b8a48fb4c44b336a12c294099335b9e1b212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6eQ1CRBK7hj4Ov3rIwAAaHAIAB+j1gu9cn+mNz4CPs6yO6ft\ng8uaWJY/ukPdKDaWaZgh+HriqguOwz/gZCL9Fp3UW9QAR/HTs5Qd3Vlcc0MJGPNj\ndBIj6PGidhhxd2h3/eS0hqv7yYkrkn72q306b5YDQuQaY4NuJihr19MpjY6oJlKE\nDBlcI6sNj5H6ZdvuP9YYqSxoUvwVABC5uX7KvAiWRuwe+7+Bd3SxASwR6UZIcIJs\nxadwHu3BE2omgh/RbHVg6WMqS1yIJhaGtxqSP+KGEAYx7ZsLkcv1or9hOwUKG14q\nd1mbhmCfTN2tRTqnVT7m5cDSeDvSD6ks1qO8+5hpTMrHA6uDAq5EMWk27G4NF9Q=\n=ZUyV\n-----END PGP SIGNATURE-----\n", "payload": "tree f4c5b8a48fb4c44b336a12c294099335b9e1b212\nparent 51fd48f1579b3bb8e0ecf311eb33db2dae674f09\nparent 21c1571e79e7f25f1a683befee33758c91693b6a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642718260 +0100\ncommitter GitHub <noreply@github.com> 1642718260 +0100\n\nRollup merge of #93102 - dtolnay:ringbuffer, r=lcnr\n\nPretty printer algorithm revamp step 3\n\nThis PR follows #93065 as a third chunk of minor modernizations backported from https://github.com/dtolnay/prettyplease into rustc_ast_pretty.\n\nI've broken this up into atomic commits that hopefully are sensible in isolation. At every commit, the pretty printer is compilable and has runtime behavior that is identical to before and after the PR. None of the refactoring so far changes behavior.\n\nThis PR is the last chunk of non-behavior-changing cleanup. After this the **next PR** will begin backporting behavior changes from `prettyplease`, starting with block indentation:\n\n```rust\nmacro_rules! print_expr {\n    ($expr:expr) => {\n        println!(\"{}\", stringify!($expr));\n    };\n}\n\nfn main() {\n    print_expr!(Struct { x: 0, y: 0 });\n    print_expr!(Structtttttttttttttttttttttttttttttttttttttttttttttttttt { xxxxxxxxx: 0, yyyyyyyyy: 0 });\n}\n```\n\nOutput currently on master (nowhere near modern Rust style):\n\n```console\nStruct{x: 0, y: 0,}\nStructtttttttttttttttttttttttttttttttttttttttttttttttttt{xxxxxxxxx: 0,\n                                                         yyyyyyyyy: 0,}\n```\n\nAfter the upcoming PR for block indentation (based on https://github.com/dtolnay/prettyplease/commit/401d60c04213e6c66565e0e69a95b4588db5fdba):\n\n```console\nStruct { x: 0, y: 0, }\nStructtttttttttttttttttttttttttttttttttttttttttttttttttt {\n    xxxxxxxxx: 0,\n    yyyyyyyyy: 0,\n}\n```\n\nAnd the PR after that, for intelligent trailing commas (based on https://github.com/dtolnay/prettyplease/commit/e2a0297f1781b787b90bca5aba1bdb4966661882):\n\n```console\nStruct { x: 0, y: 0 }\nStructtttttttttttttttttttttttttttttttttttttttttttttttttt {\n    xxxxxxxxx: 0,\n    yyyyyyyyy: 0,\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1", "html_url": "https://github.com/rust-lang/rust/commit/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51fd48f1579b3bb8e0ecf311eb33db2dae674f09", "url": "https://api.github.com/repos/rust-lang/rust/commits/51fd48f1579b3bb8e0ecf311eb33db2dae674f09", "html_url": "https://github.com/rust-lang/rust/commit/51fd48f1579b3bb8e0ecf311eb33db2dae674f09"}, {"sha": "21c1571e79e7f25f1a683befee33758c91693b6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/21c1571e79e7f25f1a683befee33758c91693b6a", "html_url": "https://github.com/rust-lang/rust/commit/21c1571e79e7f25f1a683befee33758c91693b6a"}], "stats": {"total": 216, "additions": 83, "deletions": 133}, "files": [{"sha": "82c40868d18f5c47f14b7364dccb0cda6f850fb8", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 77, "deletions": 128, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=d4ec46444b8e0fc5f4deaf4408cd0cab367178f1", "patch": "@@ -137,7 +137,7 @@ mod ring;\n use ring::RingBuffer;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::fmt;\n+use std::iter;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]\n@@ -175,27 +175,10 @@ impl Token {\n     }\n }\n \n-impl fmt::Display for Token {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Token::String(ref s) => write!(f, \"STR({},{})\", s, s.len()),\n-            Token::Break(_) => f.write_str(\"BREAK\"),\n-            Token::Begin(_) => f.write_str(\"BEGIN\"),\n-            Token::End => f.write_str(\"END\"),\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n-enum PrintStackBreak {\n+enum PrintFrame {\n     Fits,\n-    Broken(Breaks),\n-}\n-\n-#[derive(Copy, Clone)]\n-struct PrintStackElem {\n-    offset: isize,\n-    pbreak: PrintStackBreak,\n+    Broken { offset: isize, breaks: Breaks },\n }\n \n const SIZE_INFINITY: isize = 0xffff;\n@@ -220,7 +203,7 @@ pub struct Printer {\n     /// advancing.\n     scan_stack: VecDeque<usize>,\n     /// Stack of blocks-in-progress being flushed by print\n-    print_stack: Vec<PrintStackElem>,\n+    print_stack: Vec<PrintFrame>,\n     /// Buffered indentation to avoid writing trailing whitespace\n     pending_indentation: isize,\n     /// The token most recently popped from the left boundary of the\n@@ -260,8 +243,8 @@ impl Printer {\n     }\n \n     /// Be very careful with this!\n-    pub fn replace_last_token_still_buffered(&mut self, t: Token) {\n-        self.buf.last_mut().unwrap().token = t;\n+    pub fn replace_last_token_still_buffered(&mut self, token: Token) {\n+        self.buf.last_mut().unwrap().token = token;\n     }\n \n     fn scan_eof(&mut self) {\n@@ -271,53 +254,53 @@ impl Printer {\n         }\n     }\n \n-    fn scan_begin(&mut self, b: BeginToken) {\n+    fn scan_begin(&mut self, token: BeginToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n             self.buf.clear();\n         }\n-        let right = self.buf.push(BufEntry { token: Token::Begin(b), size: -self.right_total });\n-        self.scan_stack.push_front(right);\n+        let right = self.buf.push(BufEntry { token: Token::Begin(token), size: -self.right_total });\n+        self.scan_stack.push_back(right);\n     }\n \n     fn scan_end(&mut self) {\n         if self.scan_stack.is_empty() {\n             self.print_end();\n         } else {\n             let right = self.buf.push(BufEntry { token: Token::End, size: -1 });\n-            self.scan_stack.push_front(right);\n+            self.scan_stack.push_back(right);\n         }\n     }\n \n-    fn scan_break(&mut self, b: BreakToken) {\n+    fn scan_break(&mut self, token: BreakToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n             self.buf.clear();\n         } else {\n             self.check_stack(0);\n         }\n-        let right = self.buf.push(BufEntry { token: Token::Break(b), size: -self.right_total });\n-        self.scan_stack.push_front(right);\n-        self.right_total += b.blank_space;\n+        let right = self.buf.push(BufEntry { token: Token::Break(token), size: -self.right_total });\n+        self.scan_stack.push_back(right);\n+        self.right_total += token.blank_space;\n     }\n \n-    fn scan_string(&mut self, s: Cow<'static, str>) {\n+    fn scan_string(&mut self, string: Cow<'static, str>) {\n         if self.scan_stack.is_empty() {\n-            self.print_string(&s);\n+            self.print_string(&string);\n         } else {\n-            let len = s.len() as isize;\n-            self.buf.push(BufEntry { token: Token::String(s), size: len });\n+            let len = string.len() as isize;\n+            self.buf.push(BufEntry { token: Token::String(string), size: len });\n             self.right_total += len;\n             self.check_stream();\n         }\n     }\n \n     fn check_stream(&mut self) {\n         while self.right_total - self.left_total > self.space {\n-            if *self.scan_stack.back().unwrap() == self.buf.index_of_first() {\n-                self.scan_stack.pop_back().unwrap();\n+            if *self.scan_stack.front().unwrap() == self.buf.index_of_first() {\n+                self.scan_stack.pop_front().unwrap();\n                 self.buf.first_mut().unwrap().size = SIZE_INFINITY;\n             }\n             self.advance_left();\n@@ -328,152 +311,118 @@ impl Printer {\n     }\n \n     fn advance_left(&mut self) {\n-        let mut left_size = self.buf.first().unwrap().size;\n-\n-        while left_size >= 0 {\n-            let left = self.buf.first().unwrap().token.clone();\n+        while self.buf.first().unwrap().size >= 0 {\n+            let left = self.buf.pop_first().unwrap();\n \n-            let len = match left {\n-                Token::Break(b) => b.blank_space,\n-                Token::String(ref s) => {\n-                    let len = s.len() as isize;\n-                    assert_eq!(len, left_size);\n-                    len\n+            match &left.token {\n+                Token::String(string) => {\n+                    self.left_total += string.len() as isize;\n+                    self.print_string(string);\n                 }\n-                _ => 0,\n-            };\n-\n-            self.print(left, left_size);\n+                Token::Break(token) => {\n+                    self.left_total += token.blank_space;\n+                    self.print_break(*token, left.size);\n+                }\n+                Token::Begin(token) => self.print_begin(*token, left.size),\n+                Token::End => self.print_end(),\n+            }\n \n-            self.left_total += len;\n+            self.last_printed = Some(left.token);\n \n-            self.buf.advance_left();\n             if self.buf.is_empty() {\n                 break;\n             }\n-\n-            left_size = self.buf.first().unwrap().size;\n         }\n     }\n \n-    fn check_stack(&mut self, mut k: usize) {\n-        while let Some(&x) = self.scan_stack.front() {\n-            let mut entry = &mut self.buf[x];\n+    fn check_stack(&mut self, mut depth: usize) {\n+        while let Some(&index) = self.scan_stack.back() {\n+            let mut entry = &mut self.buf[index];\n             match entry.token {\n                 Token::Begin(_) => {\n-                    if k == 0 {\n+                    if depth == 0 {\n                         break;\n                     }\n-                    self.scan_stack.pop_front().unwrap();\n+                    self.scan_stack.pop_back().unwrap();\n                     entry.size += self.right_total;\n-                    k -= 1;\n+                    depth -= 1;\n                 }\n                 Token::End => {\n                     // paper says + not =, but that makes no sense.\n-                    self.scan_stack.pop_front().unwrap();\n+                    self.scan_stack.pop_back().unwrap();\n                     entry.size = 1;\n-                    k += 1;\n+                    depth += 1;\n                 }\n                 _ => {\n-                    self.scan_stack.pop_front().unwrap();\n+                    self.scan_stack.pop_back().unwrap();\n                     entry.size += self.right_total;\n-                    if k == 0 {\n+                    if depth == 0 {\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn print_newline(&mut self, amount: isize) {\n-        self.out.push('\\n');\n-        self.pending_indentation = 0;\n-        self.indent(amount);\n-    }\n-\n-    fn indent(&mut self, amount: isize) {\n-        self.pending_indentation += amount;\n+    fn get_top(&self) -> PrintFrame {\n+        *self\n+            .print_stack\n+            .last()\n+            .unwrap_or(&PrintFrame::Broken { offset: 0, breaks: Breaks::Inconsistent })\n     }\n \n-    fn get_top(&self) -> PrintStackElem {\n-        *self.print_stack.last().unwrap_or({\n-            &PrintStackElem { offset: 0, pbreak: PrintStackBreak::Broken(Breaks::Inconsistent) }\n-        })\n-    }\n-\n-    fn print_begin(&mut self, b: BeginToken, l: isize) {\n-        if l > self.space {\n-            let col = self.margin - self.space + b.offset;\n-            self.print_stack\n-                .push(PrintStackElem { offset: col, pbreak: PrintStackBreak::Broken(b.breaks) });\n+    fn print_begin(&mut self, token: BeginToken, size: isize) {\n+        if size > self.space {\n+            let col = self.margin - self.space + token.offset;\n+            self.print_stack.push(PrintFrame::Broken { offset: col, breaks: token.breaks });\n         } else {\n-            self.print_stack.push(PrintStackElem { offset: 0, pbreak: PrintStackBreak::Fits });\n+            self.print_stack.push(PrintFrame::Fits);\n         }\n     }\n \n     fn print_end(&mut self) {\n         self.print_stack.pop().unwrap();\n     }\n \n-    fn print_break(&mut self, b: BreakToken, l: isize) {\n-        let top = self.get_top();\n-        match top.pbreak {\n-            PrintStackBreak::Fits => {\n-                self.space -= b.blank_space;\n-                self.indent(b.blank_space);\n-            }\n-            PrintStackBreak::Broken(Breaks::Consistent) => {\n-                self.print_newline(top.offset + b.offset);\n-                self.space = self.margin - (top.offset + b.offset);\n-            }\n-            PrintStackBreak::Broken(Breaks::Inconsistent) => {\n-                if l > self.space {\n-                    self.print_newline(top.offset + b.offset);\n-                    self.space = self.margin - (top.offset + b.offset);\n-                } else {\n-                    self.indent(b.blank_space);\n-                    self.space -= b.blank_space;\n+    fn print_break(&mut self, token: BreakToken, size: isize) {\n+        let break_offset =\n+            match self.get_top() {\n+                PrintFrame::Fits => None,\n+                PrintFrame::Broken { offset, breaks: Breaks::Consistent } => Some(offset),\n+                PrintFrame::Broken { offset, breaks: Breaks::Inconsistent } => {\n+                    if size > self.space { Some(offset) } else { None }\n                 }\n-            }\n+            };\n+        if let Some(offset) = break_offset {\n+            self.out.push('\\n');\n+            self.pending_indentation = offset + token.offset;\n+            self.space = self.margin - (offset + token.offset);\n+        } else {\n+            self.pending_indentation += token.blank_space;\n+            self.space -= token.blank_space;\n         }\n     }\n \n-    fn print_string(&mut self, s: &str) {\n-        let len = s.len() as isize;\n-        // assert!(len <= space);\n-        self.space -= len;\n-\n+    fn print_string(&mut self, string: &str) {\n         // Write the pending indent. A more concise way of doing this would be:\n         //\n         //   write!(self.out, \"{: >n$}\", \"\", n = self.pending_indentation as usize)?;\n         //\n         // But that is significantly slower. This code is sufficiently hot, and indents can get\n         // sufficiently large, that the difference is significant on some workloads.\n         self.out.reserve(self.pending_indentation as usize);\n-        self.out.extend(std::iter::repeat(' ').take(self.pending_indentation as usize));\n+        self.out.extend(iter::repeat(' ').take(self.pending_indentation as usize));\n         self.pending_indentation = 0;\n-        self.out.push_str(s);\n-    }\n \n-    fn print(&mut self, token: Token, l: isize) {\n-        match &token {\n-            Token::Begin(b) => self.print_begin(*b, l),\n-            Token::End => self.print_end(),\n-            Token::Break(b) => self.print_break(*b, l),\n-            Token::String(s) => {\n-                let len = s.len() as isize;\n-                assert_eq!(len, l);\n-                self.print_string(s);\n-            }\n-        }\n-        self.last_printed = Some(token);\n+        self.out.push_str(string);\n+        self.space -= string.len() as isize;\n     }\n \n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n-    pub fn rbox(&mut self, indent: usize, b: Breaks) {\n-        self.scan_begin(BeginToken { offset: indent as isize, breaks: b })\n+    pub fn rbox(&mut self, indent: usize, breaks: Breaks) {\n+        self.scan_begin(BeginToken { offset: indent as isize, breaks })\n     }\n \n     /// Inconsistent breaking box\n@@ -500,8 +449,8 @@ impl Printer {\n     }\n \n     pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) {\n-        let s = wrd.into();\n-        self.scan_string(s)\n+        let string = wrd.into();\n+        self.scan_string(string)\n     }\n \n     fn spaces(&mut self, n: usize) {"}, {"sha": "8187394fe30e004ebabfc17ba75208d53d668bd1", "filename": "compiler/rustc_ast_pretty/src/pp/ring.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ec46444b8e0fc5f4deaf4408cd0cab367178f1/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs?ref=d4ec46444b8e0fc5f4deaf4408cd0cab367178f1", "patch": "@@ -32,11 +32,6 @@ impl<T> RingBuffer<T> {\n         index\n     }\n \n-    pub fn advance_left(&mut self) {\n-        self.data.pop_front().unwrap();\n-        self.offset += 1;\n-    }\n-\n     pub fn clear(&mut self) {\n         self.data.clear();\n     }\n@@ -53,6 +48,12 @@ impl<T> RingBuffer<T> {\n         self.data.front_mut()\n     }\n \n+    pub fn pop_first(&mut self) -> Option<T> {\n+        let first = self.data.pop_front()?;\n+        self.offset += 1;\n+        Some(first)\n+    }\n+\n     pub fn last(&self) -> Option<&T> {\n         self.data.back()\n     }"}]}