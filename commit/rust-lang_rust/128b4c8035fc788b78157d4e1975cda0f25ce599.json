{"sha": "128b4c8035fc788b78157d4e1975cda0f25ce599", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGI0YzgwMzVmYzc4OGI3ODE1N2Q0ZTE5NzVjZGEwZjI1Y2U1OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T00:37:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T00:37:48Z"}, "message": "Auto merge of #60969 - Centril:rollup-3j71mqj, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #60590 (Test interaction of unions with non-zero/niche-filling optimization)\n - #60745 (Perform constant propagation into terminators)\n - #60895 (Enable thumbv7a-pc-windows-msvc target build end to end in rust/master)\n - #60908 (Fix lints handling in rustdoc)\n - #60960 (Stop using gensyms in HIR lowering)\n - #60962 (Fix data types indication)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2821ec0ae0c94f2b83d5cf37c68c0ad95220d549", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2821ec0ae0c94f2b83d5cf37c68c0ad95220d549"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128b4c8035fc788b78157d4e1975cda0f25ce599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128b4c8035fc788b78157d4e1975cda0f25ce599", "html_url": "https://github.com/rust-lang/rust/commit/128b4c8035fc788b78157d4e1975cda0f25ce599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128b4c8035fc788b78157d4e1975cda0f25ce599/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5000c5098d08d9240d875fcb4231533fb922ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5000c5098d08d9240d875fcb4231533fb922ead", "html_url": "https://github.com/rust-lang/rust/commit/a5000c5098d08d9240d875fcb4231533fb922ead"}, {"sha": "614ffe56c6a0a3bf0dc649388d5cb7d6a3f0d0c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/614ffe56c6a0a3bf0dc649388d5cb7d6a3f0d0c1", "html_url": "https://github.com/rust-lang/rust/commit/614ffe56c6a0a3bf0dc649388d5cb7d6a3f0d0c1"}], "stats": {"total": 530, "additions": 402, "deletions": 128}, "files": [{"sha": "be0af8be7b272bc615aab84985faa07db286c449", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -683,7 +683,7 @@ impl Step for RustdocUi {\n             target: self.target,\n             mode: \"ui\",\n             suite: \"rustdoc-ui\",\n-            path: None,\n+            path: Some(\"src/test/rustdoc-ui\"),\n             compare_mode: None,\n         })\n     }"}, {"sha": "2f6d745d146d647d3fd5716e57db7dc020964b39", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -886,7 +886,7 @@ pub trait Pointer {\n ///\n /// # Examples\n ///\n-/// Basic usage with `i32`:\n+/// Basic usage with `f64`:\n ///\n /// ```\n /// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n@@ -929,7 +929,7 @@ pub trait LowerExp {\n ///\n /// # Examples\n ///\n-/// Basic usage with `f32`:\n+/// Basic usage with `f64`:\n ///\n /// ```\n /// let x = 42.0; // 42.0 is '4.2E1' in scientific notation"}, {"sha": "3ec4d4e8cc8f68350eba397be435676d2c89fc91", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -855,10 +855,6 @@ impl<'a> LoweringContext<'a> {\n         self.sess.diagnostic()\n     }\n \n-    fn str_to_ident(&self, s: &'static str) -> Ident {\n-        Ident::with_empty_ctxt(Symbol::gensym(s))\n-    }\n-\n     fn with_anonymous_lifetime_mode<R>(\n         &mut self,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n@@ -4621,18 +4617,18 @@ impl<'a> LoweringContext<'a> {\n                 );\n                 head.span = desugared_span;\n \n-                let iter = self.str_to_ident(\"iter\");\n+                let iter = Ident::with_empty_ctxt(sym::iter);\n \n-                let next_ident = self.str_to_ident(\"__next\");\n+                let next_ident = Ident::with_empty_ctxt(sym::__next);\n                 let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     next_ident,\n                     hir::BindingAnnotation::Mutable,\n                 );\n \n-                // `::std::option::Option::Some(val) => next = val`\n+                // `::std::option::Option::Some(val) => __next = val`\n                 let pat_arm = {\n-                    let val_ident = self.str_to_ident(\"val\");\n+                    let val_ident = Ident::with_empty_ctxt(sym::val);\n                     let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n                     let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n                     let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n@@ -4771,17 +4767,13 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n-                    Some(vec![\n-                        Symbol::intern(\"try_trait\")\n-                    ].into()),\n+                    Some(vec![sym::try_trait].into()),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n                 let try_span = self.sess.source_map().mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n-                    Some(vec![\n-                        Symbol::intern(\"try_trait\")\n-                    ].into()),\n+                    Some(vec![sym::try_trait].into()),\n                 );\n \n                 // `Try::into_result(<expr>)`\n@@ -4802,7 +4794,8 @@ impl<'a> LoweringContext<'a> {\n                     // `allow(unreachable_code)`\n                     let allow = {\n                         let allow_ident = Ident::with_empty_ctxt(sym::allow).with_span_pos(e.span);\n-                        let uc_ident = Ident::from_str(\"unreachable_code\").with_span_pos(e.span);\n+                        let uc_ident = Ident::with_empty_ctxt(sym::unreachable_code)\n+                            .with_span_pos(e.span);\n                         let uc_nested = attr::mk_nested_word_item(uc_ident);\n                         attr::mk_list_item(e.span, allow_ident, vec![uc_nested])\n                     };\n@@ -4812,7 +4805,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n-                    let val_ident = self.str_to_ident(\"val\");\n+                    let val_ident = Ident::with_empty_ctxt(sym::val);\n                     let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n                     let val_expr = P(self.expr_ident_with_attrs(\n                         e.span,\n@@ -4828,7 +4821,7 @@ impl<'a> LoweringContext<'a> {\n                 // `Err(err) => #[allow(unreachable_code)]\n                 //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n-                    let err_ident = self.str_to_ident(\"err\");\n+                    let err_ident = Ident::with_empty_ctxt(sym::err);\n                     let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n                     let from_expr = {\n                         let from_path = &[sym::convert, sym::From, sym::from];\n@@ -5552,7 +5545,7 @@ impl<'a> LoweringContext<'a> {\n         //         match ::std::future::poll_with_tls_context(unsafe {\n         //             ::std::pin::Pin::new_unchecked(&mut pinned)\n         //         }) {\n-        //             ::std::task::Poll::Ready(x) => break x,\n+        //             ::std::task::Poll::Ready(result) => break result,\n         //             ::std::task::Poll::Pending => {},\n         //         }\n         //         yield ();\n@@ -5580,12 +5573,12 @@ impl<'a> LoweringContext<'a> {\n         let gen_future_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n-            Some(vec![Symbol::intern(\"gen_future\")].into()),\n+            Some(vec![sym::gen_future].into()),\n         );\n \n         // let mut pinned = <expr>;\n         let expr = P(self.lower_expr(expr));\n-        let pinned_ident = self.str_to_ident(\"pinned\");\n+        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n@@ -5621,11 +5614,11 @@ impl<'a> LoweringContext<'a> {\n             ))\n         };\n \n-        // `::std::task::Poll::Ready(x) => break x`\n+        // `::std::task::Poll::Ready(result) => break result`\n         let loop_node_id = self.sess.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n-            let x_ident = self.str_to_ident(\"x\");\n+            let x_ident = Ident::with_empty_ctxt(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n             let ready_pat = self.pat_std_enum("}, {"sha": "9c4683e094634eea384d348ff8c2b9785a6c6dfe", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -778,6 +778,9 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n \n     let push = builder.levels.push(&krate.attrs);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n+    for macro_def in &krate.exported_macros {\n+       builder.levels.register_id(macro_def.hir_id);\n+    }\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n "}, {"sha": "66ba95810a62516a109462f740955fed5c54afb8", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -795,10 +795,10 @@ fn create_msvc_imps(\n         return\n     }\n     // The x86 ABI seems to require that leading underscores are added to symbol\n-    // names, so we need an extra underscore on 32-bit. There's also a leading\n+    // names, so we need an extra underscore on x86. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g., no extra\n     // underscores added in front).\n-    let prefix = if cgcx.target_pointer_width == \"32\" {\n+    let prefix = if cgcx.target_arch == \"x86\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\""}, {"sha": "1c793996c83db65cc1cc2960546f358197812253", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -248,6 +248,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub tm_factory: TargetMachineFactory<B>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n+    pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n \n     // Number of cgus excluding the allocator/metadata modules\n@@ -1103,6 +1104,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n+        target_arch: tcx.sess.target.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n         assembler_cmd,\n     };"}, {"sha": "8f3dd72c4f2450a82ca151b53d8ebbe9128b72d6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 108, "deletions": 67, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -546,6 +546,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             }\n         }\n     }\n+\n+    fn should_const_prop(&self) -> bool {\n+        self.tcx.sess.opts.debugging_opts.mir_opt_level >= 2\n+    }\n }\n \n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -639,7 +643,7 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             assert!(self.places[local].is_none());\n                             self.places[local] = Some(value);\n \n-                            if self.tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+                            if self.should_const_prop() {\n                                 self.replace_with_const(rval, value, statement.source_info.span);\n                             }\n                         }\n@@ -656,75 +660,112 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         location: Location,\n     ) {\n         self.super_terminator(terminator, location);\n-        let source_info = terminator.source_info;;\n-        if let TerminatorKind::Assert { expected, msg, cond, .. } = &terminator.kind {\n-            if let Some(value) = self.eval_operand(&cond, source_info) {\n-                trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n-                if expected != self.ecx.read_scalar(value).unwrap() {\n-                    // poison all places this operand references so that further code\n-                    // doesn't use the invalid value\n-                    match cond {\n-                        Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                            let mut place = place;\n-                            while let Place::Projection(ref proj) = *place {\n-                                place = &proj.base;\n-                            }\n-                            if let Place::Base(PlaceBase::Local(local)) = *place {\n-                                self.places[local] = None;\n+        let source_info = terminator.source_info;\n+        match &mut terminator.kind {\n+            TerminatorKind::Assert { expected, msg, ref mut cond, .. } => {\n+                if let Some(value) = self.eval_operand(&cond, source_info) {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n+                    let value_const = self.ecx.read_scalar(value).unwrap();\n+                    if expected != value_const {\n+                        // poison all places this operand references so that further code\n+                        // doesn't use the invalid value\n+                        match cond {\n+                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                                let mut place = place;\n+                                while let Place::Projection(ref proj) = *place {\n+                                    place = &proj.base;\n+                                }\n+                                if let Place::Base(PlaceBase::Local(local)) = *place {\n+                                    self.places[local] = None;\n+                                }\n+                            },\n+                            Operand::Constant(_) => {}\n+                        }\n+                        let span = terminator.source_info.span;\n+                        let hir_id = self\n+                            .tcx\n+                            .hir()\n+                            .as_local_hir_id(self.source.def_id())\n+                            .expect(\"some part of a failing const eval must be local\");\n+                        use rustc::mir::interpret::InterpError::*;\n+                        let msg = match msg {\n+                            Overflow(_) |\n+                            OverflowNeg |\n+                            DivisionByZero |\n+                            RemainderByZero => msg.description().to_owned(),\n+                            BoundsCheck { ref len, ref index } => {\n+                                let len = self\n+                                    .eval_operand(len, source_info)\n+                                    .expect(\"len must be const\");\n+                                let len = match self.ecx.read_scalar(len) {\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                        bits, ..\n+                                    })) => bits,\n+                                    other => bug!(\"const len not primitive: {:?}\", other),\n+                                };\n+                                let index = self\n+                                    .eval_operand(index, source_info)\n+                                    .expect(\"index must be const\");\n+                                let index = match self.ecx.read_scalar(index) {\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                        bits, ..\n+                                    })) => bits,\n+                                    other => bug!(\"const index not primitive: {:?}\", other),\n+                                };\n+                                format!(\n+                                    \"index out of bounds: \\\n+                                    the len is {} but the index is {}\",\n+                                    len,\n+                                    index,\n+                                )\n+                            },\n+                            // Need proper const propagator for these\n+                            _ => return,\n+                        };\n+                        self.tcx.lint_hir(\n+                            ::rustc::lint::builtin::CONST_ERR,\n+                            hir_id,\n+                            span,\n+                            &msg,\n+                        );\n+                    } else {\n+                        if self.should_const_prop() {\n+                            if let ScalarMaybeUndef::Scalar(scalar) = value_const {\n+                                *cond = self.operand_from_scalar(\n+                                    scalar,\n+                                    self.tcx.types.bool,\n+                                    source_info.span,\n+                                );\n                             }\n-                        },\n-                        Operand::Constant(_) => {}\n+                        }\n                     }\n-                    let span = terminator.source_info.span;\n-                    let hir_id = self\n-                        .tcx\n-                        .hir()\n-                        .as_local_hir_id(self.source.def_id())\n-                        .expect(\"some part of a failing const eval must be local\");\n-                    use rustc::mir::interpret::InterpError::*;\n-                    let msg = match msg {\n-                        Overflow(_) |\n-                        OverflowNeg |\n-                        DivisionByZero |\n-                        RemainderByZero => msg.description().to_owned(),\n-                        BoundsCheck { ref len, ref index } => {\n-                            let len = self\n-                                .eval_operand(len, source_info)\n-                                .expect(\"len must be const\");\n-                            let len = match self.ecx.read_scalar(len) {\n-                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                    bits, ..\n-                                })) => bits,\n-                                other => bug!(\"const len not primitive: {:?}\", other),\n-                            };\n-                            let index = self\n-                                .eval_operand(index, source_info)\n-                                .expect(\"index must be const\");\n-                            let index = match self.ecx.read_scalar(index) {\n-                                Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                    bits, ..\n-                                })) => bits,\n-                                other => bug!(\"const index not primitive: {:?}\", other),\n-                            };\n-                            format!(\n-                                \"index out of bounds: \\\n-                                the len is {} but the index is {}\",\n-                                len,\n-                                index,\n-                            )\n-                        },\n-                        // Need proper const propagator for these\n-                        _ => return,\n-                    };\n-                    self.tcx.lint_hir(\n-                        ::rustc::lint::builtin::CONST_ERR,\n-                        hir_id,\n-                        span,\n-                        &msg,\n-                    );\n                 }\n-            }\n+            },\n+            TerminatorKind::SwitchInt { ref mut discr, switch_ty, .. } => {\n+                if self.should_const_prop() {\n+                    if let Some(value) = self.eval_operand(&discr, source_info) {\n+                        if let ScalarMaybeUndef::Scalar(scalar) =\n+                                self.ecx.read_scalar(value).unwrap() {\n+                            *discr = self.operand_from_scalar(scalar, switch_ty, source_info.span);\n+                        }\n+                    }\n+                }\n+            },\n+            //none of these have Operands to const-propagate\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Abort |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::DropAndReplace { .. } |\n+            TerminatorKind::Yield { .. } |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::FalseEdges { .. } |\n+            TerminatorKind::FalseUnwind { .. } => { }\n+            //FIXME(wesleywiser) Call does have Operands that could be const-propagated\n+            TerminatorKind::Call { .. } => { }\n         }\n     }\n }"}, {"sha": "e434623d4a12759fe3f1bb82cef4fa0cd11fca18", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -3408,6 +3408,7 @@ pub struct Span {\n     pub locol: usize,\n     pub hiline: usize,\n     pub hicol: usize,\n+    pub original: syntax_pos::Span,\n }\n \n impl Span {\n@@ -3416,8 +3417,13 @@ impl Span {\n             filename: FileName::Anon(0),\n             loline: 0, locol: 0,\n             hiline: 0, hicol: 0,\n+            original: syntax_pos::DUMMY_SP,\n         }\n     }\n+\n+    pub fn span(&self) -> syntax_pos::Span {\n+        self.original\n+    }\n }\n \n impl Clean<Span> for syntax_pos::Span {\n@@ -3436,6 +3442,7 @@ impl Clean<Span> for syntax_pos::Span {\n             locol: lo.col.to_usize(),\n             hiline: hi.line,\n             hicol: hi.col.to_usize(),\n+            original: *self,\n         }\n     }\n }"}, {"sha": "2c382a1c1759632806bb316f621aa582564b9fe0", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             res\n                         } else {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             // This could just be a normal link or a broken link\n                             // we could potentially check if something is\n                             // \"intra-doc-link-like\" and warn in that case.\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if let Ok(res) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             res\n                         } else {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             // This could just be a normal link.\n                             continue;\n                         }\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         };\n \n                         if candidates.is_empty() {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             // this could just be a normal link\n                             continue;\n                         }\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         } else {\n                             ambiguity_error(\n                                 cx,\n-                                &item.attrs,\n+                                &item,\n                                 path_str,\n                                 &dox,\n                                 link_range,\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if let Some(res) = macro_resolve(cx, path_str) {\n                             (res, None)\n                         } else {\n-                            resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n+                            resolution_failure(cx, &item, path_str, &dox, link_range);\n                             continue\n                         }\n                     }\n@@ -452,16 +452,24 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n /// line containing the failure as a note as well.\n fn resolution_failure(\n     cx: &DocContext<'_>,\n-    attrs: &Attributes,\n+    item: &Item,\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n ) {\n+    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            // If non-local, no need to check anything.\n+            return;\n+        }\n+    };\n+    let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs);\n \n     let mut diag = cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-        hir::CRATE_HIR_ID,\n+        hir_id,\n         sp,\n         &format!(\"`[{}]` cannot be resolved, ignoring it...\", path_str),\n     );\n@@ -495,12 +503,20 @@ fn resolution_failure(\n \n fn ambiguity_error(\n     cx: &DocContext<'_>,\n-    attrs: &Attributes,\n+    item: &Item,\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n     candidates: PerNS<Option<Res>>,\n ) {\n+    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            // If non-local, no need to check anything.\n+            return;\n+        }\n+    };\n+    let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs);\n \n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -532,7 +548,7 @@ fn ambiguity_error(\n \n     let mut diag = cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-        hir::CRATE_HIR_ID,\n+        hir_id,\n         sp,\n         &msg,\n     );"}, {"sha": "d9af33ac5b622a39f288c14b3eca760c02900245", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -1,7 +1,6 @@\n //! Contains information about \"passes\", used to modify crate information during the documentation\n //! process.\n \n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n@@ -314,10 +313,13 @@ pub fn look_for_tests<'tcx>(\n     item: &Item,\n     check_missing_code: bool,\n ) {\n-    if cx.as_local_hir_id(item.def_id).is_none() {\n-        // If non-local, no need to check anything.\n-        return;\n-    }\n+    let hir_id = match cx.as_local_hir_id(item.def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            // If non-local, no need to check anything.\n+            return;\n+        }\n+    };\n \n     struct Tests {\n         found_tests: usize,\n@@ -336,18 +338,19 @@ pub fn look_for_tests<'tcx>(\n     find_testable_code(&dox, &mut tests, ErrorCodes::No);\n \n     if check_missing_code == true && tests.found_tests == 0 {\n+        let sp = span_of_attrs(&item.attrs).substitute_dummy(item.source.span());\n         let mut diag = cx.tcx.struct_span_lint_hir(\n             lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-            hir::CRATE_HIR_ID,\n-            span_of_attrs(&item.attrs),\n+            hir_id,\n+            sp,\n             \"Missing code example in this documentation\");\n         diag.emit();\n     } else if check_missing_code == false &&\n               tests.found_tests > 0 &&\n               !cx.renderinfo.borrow().access_levels.is_doc_reachable(item.def_id) {\n         let mut diag = cx.tcx.struct_span_lint_hir(\n             lint::builtin::PRIVATE_DOC_TESTS,\n-            hir::CRATE_HIR_ID,\n+            hir_id,\n             span_of_attrs(&item.attrs),\n             \"Documentation test in private item\");\n         diag.emit();"}, {"sha": "97b22282668ad1b77d27e00391d49b0e5cb4fba4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -229,6 +229,7 @@ symbols! {\n         eh_personality,\n         eh_unwind_resume,\n         enable,\n+        err,\n         Err,\n         except,\n         exclusive_range_pattern,\n@@ -260,6 +261,7 @@ symbols! {\n         fundamental,\n         future,\n         Future,\n+        gen_future,\n         generators,\n         generic_associated_types,\n         generic_param_attrs,\n@@ -361,6 +363,7 @@ symbols! {\n         never,\n         never_type,\n         next,\n+        __next,\n         nll,\n         no_builtins,\n         no_core,\n@@ -406,6 +409,7 @@ symbols! {\n         Pending,\n         pin,\n         Pin,\n+        pinned,\n         platform_intrinsics,\n         plugin,\n         plugin_registrar,\n@@ -569,6 +573,7 @@ symbols! {\n         trivial_bounds,\n         Try,\n         try_blocks,\n+        try_trait,\n         tuple_indexing,\n         ty,\n         type_alias_enum_variants,\n@@ -587,6 +592,7 @@ symbols! {\n         uniform_paths,\n         universal_impl_trait,\n         unmarked_api,\n+        unreachable_code,\n         unrestricted_attribute_tokens,\n         unsafe_destructor_blind_to_params,\n         unsafe_no_drop_flag,\n@@ -601,6 +607,7 @@ symbols! {\n         use_nested_groups,\n         usize,\n         v1,\n+        val,\n         vis,\n         visible_private_types,\n         volatile,"}, {"sha": "7f7db2a21251ac8864bcc07faf4a30001c2d6634", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -37,12 +37,13 @@ extern crate libc;\n use term;\n \n // FIXME(#54291): rustc and/or LLVM don't yet support building with panic-unwind\n-//                on aarch64-pc-windows-msvc, so we don't link libtest against\n-//                libunwind (for the time being), even though it means that\n-//                libtest won't be fully functional on this platform.\n+//                on aarch64-pc-windows-msvc, or thumbv7a-pc-windows-msvc\n+//                so we don't link libtest against libunwind (for the time being)\n+//                even though it means that libtest won't be fully functional on\n+//                these platforms.\n //\n // See also: https://github.com/rust-lang/rust/issues/54190#issuecomment-422904437\n-#[cfg(not(all(windows, target_arch = \"aarch64\")))]\n+#[cfg(not(all(windows, any(target_arch = \"aarch64\", target_arch = \"arm\"))))]\n extern crate panic_unwind;\n \n pub use self::ColorConfig::*;"}, {"sha": "dd22eb5d604ea51b84d8586ebfc26c6e16bcb038", "filename": "src/test/mir-opt/const_prop/array_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -23,7 +23,7 @@ fn main() {\n //  bb0: {\n //      ...\n //      _5 = const true;\n-//      assert(move _5, \"index out of bounds: the len is move _4 but the index is _3\") -> bb1;\n+//      assert(const true, \"index out of bounds: the len is move _4 but the index is _3\") -> bb1;\n //  }\n //  bb1: {\n //      _1 = _2[_3];"}, {"sha": "fe98cf24eec009ecc6416033e5b7a38e787a6dae", "filename": "src/test/mir-opt/const_prop/checked_add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -16,6 +16,6 @@ fn main() {\n //  bb0: {\n //      ...\n //      _2 = (const 2u32, const false);\n-//      assert(!move (_2.1: bool), \"attempt to add with overflow\") -> bb1;\n+//      assert(!const false, \"attempt to add with overflow\") -> bb1;\n //  }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "0df1112ec3eb7283ced4451208e1f1e31f9ad7bb", "filename": "src/test/mir-opt/const_prop/switch_int.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -0,0 +1,38 @@\n+#[inline(never)]\n+fn foo(_: i32) { }\n+\n+fn main() {\n+    match 1 {\n+        1 => foo(0),\n+        _ => foo(-1),\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.ConstProp.before.mir\n+//  bb0: {\n+//      ...\n+//      _1 = const 1i32;\n+//      switchInt(_1) -> [1i32: bb1, otherwise: bb2];\n+//  }\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+//  bb0: {\n+//      ...\n+//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//  }\n+// END rustc.main.ConstProp.after.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.before.mir\n+//  bb0: {\n+//      ...\n+//      _1 = const 1i32;\n+//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//  }\n+// END rustc.main.SimplifyBranches-after-const-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.after.mir\n+//  bb0: {\n+//      ...\n+//      _1 = const 1i32;\n+//      goto -> bb1;\n+//  }\n+// END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "35512b94c0c8cf8f96c87db6ab2350ae51118525", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -5,15 +5,15 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.main.SimplifyBranches-after-copy-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.before.mir\n // bb0: {\n //     ...\n //     switchInt(const false) -> [false: bb3, otherwise: bb1];\n // }\n-// END rustc.main.SimplifyBranches-after-copy-prop.before.mir\n-// START rustc.main.SimplifyBranches-after-copy-prop.after.mir\n+// END rustc.main.SimplifyBranches-after-const-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-const-prop.after.mir\n // bb0: {\n //     ...\n //     goto -> bb3;\n // }\n-// END rustc.main.SimplifyBranches-after-copy-prop.after.mir\n+// END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "bd84b46bf3d234a9e6bbb3db18775974d837241b", "filename": "src/test/run-pass/union/union-nonzero.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frun-pass%2Funion%2Funion-nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frun-pass%2Funion%2Funion-nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-nonzero.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -0,0 +1,51 @@\n+// run-pass\n+#![allow(dead_code)]\n+\n+// Tests that unions aren't subject to unsafe non-zero/niche-filling optimizations.\n+//\n+// For example, if a union `U` can contain both a `&T` and a `*const T`, there's definitely no\n+// bit-value that an `Option<U>` could reuse as `None`; this test makes sure that isn't done.\n+//\n+// Secondly, this tests the status quo (not a guarantee; subject to change!) to not apply such\n+// optimizations to types containing unions even if they're theoretically possible. (discussion:\n+// https://github.com/rust-lang/rust/issues/36394)\n+//\n+// Notably this nails down part of the behavior that `MaybeUninit` assumes: that a\n+// `Option<MaybeUninit<&u8>>` does not take advantage of non-zero optimization, and thus is a safe\n+// construct.\n+\n+use std::mem::{size_of, transmute};\n+\n+union U1<A: Copy> {\n+    a: A,\n+}\n+\n+union U2<A: Copy, B: Copy> {\n+    a: A,\n+    b: B,\n+}\n+\n+// Option<E> uses a value other than 0 and 1 as None\n+#[derive(Clone,Copy)]\n+enum E {\n+    A = 0,\n+    B = 1,\n+}\n+\n+fn main() {\n+    // Unions do not participate in niche-filling/non-zero optimization...\n+    assert!(size_of::<Option<U2<&u8, u8>>>() > size_of::<U2<&u8, u8>>());\n+    assert!(size_of::<Option<U2<&u8, ()>>>() > size_of::<U2<&u8, ()>>());\n+    assert!(size_of::<Option<U2<u8, E>>>() > size_of::<U2<u8, E>>());\n+\n+    // ...even when theoretically possible:\n+    assert!(size_of::<Option<U1<&u8>>>() > size_of::<U1<&u8>>());\n+    assert!(size_of::<Option<U2<&u8, &u8>>>() > size_of::<U2<&u8, &u8>>());\n+\n+    // The unused bits of the () variant can have any value.\n+    let zeroed: U2<&u8, ()> = unsafe { transmute(std::ptr::null::<u8>()) };\n+\n+    if let None = Some(zeroed) {\n+        panic!()\n+    }\n+}"}, {"sha": "4b2a91e9c812722f4a6f66beb1692e8ea56037a6", "filename": "src/test/rustdoc-ui/doc-without-codeblock.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -1,6 +1,4 @@\n-//~ ERROR Missing code example in this documentation\n-\n-#![deny(missing_doc_code_examples)]\n+#![deny(missing_doc_code_examples)] //~ ERROR Missing code example in this documentation\n \n /// Some docs.\n //~^ ERROR Missing code example in this documentation"}, {"sha": "23c07c4d32d64359d43a4a4ead40dbac4ba40050", "filename": "src/test/rustdoc-ui/doc-without-codeblock.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -1,25 +1,35 @@\n error: Missing code example in this documentation\n+  --> $DIR/doc-without-codeblock.rs:1:1\n+   |\n+LL | / #![deny(missing_doc_code_examples)]\n+LL | |\n+LL | | /// Some docs.\n+LL | |\n+...  |\n+LL | |     pub fn bar() {}\n+LL | | }\n+   | |_^\n    |\n note: lint level defined here\n-  --> $DIR/doc-without-codeblock.rs:3:9\n+  --> $DIR/doc-without-codeblock.rs:1:9\n    |\n LL | #![deny(missing_doc_code_examples)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Missing code example in this documentation\n-  --> $DIR/doc-without-codeblock.rs:5:1\n+  --> $DIR/doc-without-codeblock.rs:3:1\n    |\n LL | /// Some docs.\n    | ^^^^^^^^^^^^^^\n \n error: Missing code example in this documentation\n-  --> $DIR/doc-without-codeblock.rs:9:1\n+  --> $DIR/doc-without-codeblock.rs:7:1\n    |\n LL | /// And then, the princess died.\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: Missing code example in this documentation\n-  --> $DIR/doc-without-codeblock.rs:12:5\n+  --> $DIR/doc-without-codeblock.rs:10:5\n    |\n LL |     /// Or maybe not because she saved herself!\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "ffe0ddcd8c9b2fc800d724db7a371c10a95f36fb", "filename": "src/test/rustdoc-ui/lint-missing-doc-code-example.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -0,0 +1,40 @@\n+#![deny(missing_docs)]\n+#![deny(missing_doc_code_examples)]\n+\n+//! crate level doc\n+//! ```\n+//! println!(\"hello\"):\n+//! ```\n+\n+\n+/// doc\n+///\n+/// ```\n+/// println!(\"hello\");\n+/// ```\n+fn test() {\n+}\n+\n+#[allow(missing_docs)]\n+mod module1 { //~ ERROR\n+}\n+\n+#[allow(missing_doc_code_examples)]\n+/// doc\n+mod module2 {\n+\n+  /// doc\n+  pub fn test() {}\n+}\n+\n+/// doc\n+///\n+/// ```\n+/// println!(\"hello\");\n+/// ```\n+pub mod module3 {\n+\n+  /// doc\n+  //~^ ERROR\n+  pub fn test() {}\n+}"}, {"sha": "97a52a13e3f652d5688bb7e58d66d9876b4ab265", "filename": "src/test/rustdoc-ui/lint-missing-doc-code-example.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -0,0 +1,21 @@\n+error: Missing code example in this documentation\n+  --> $DIR/lint-missing-doc-code-example.rs:19:1\n+   |\n+LL | / mod module1 {\n+LL | | }\n+   | |_^\n+   |\n+note: lint level defined here\n+  --> $DIR/lint-missing-doc-code-example.rs:2:9\n+   |\n+LL | #![deny(missing_doc_code_examples)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Missing code example in this documentation\n+  --> $DIR/lint-missing-doc-code-example.rs:37:3\n+   |\n+LL |   /// doc\n+   |   ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "0127261b2b7d0a6111f68b71c1af2690c5c7819b", "filename": "src/test/ui/print_type_sizes/niche-filling.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -57,6 +57,15 @@ pub enum Enum4<A, B, C, D> {\n     Four(D)\n }\n \n+pub union Union1<A: Copy> {\n+    a: A,\n+}\n+\n+pub union Union2<A: Copy, B: Copy> {\n+    a: A,\n+    b: B,\n+}\n+\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n     let _x: MyOption<NonZeroU32> = Default::default();\n@@ -69,5 +78,13 @@ fn start(_: isize, _: *const *const u8) -> isize {\n     let _e: Enum4<(), char, (), ()> = Enum4::One(());\n     let _f: Enum4<(), (), bool, ()> = Enum4::One(());\n     let _g: Enum4<(), (), (), MyOption<u8>> = Enum4::One(());\n+\n+    // Unions do not currently participate in niche filling.\n+    let _h: MyOption<Union2<NonZeroU32, u32>> = Default::default();\n+\n+    // ...even when theoretically possible.\n+    let _i: MyOption<Union1<NonZeroU32>> = Default::default();\n+    let _j: MyOption<Union2<NonZeroU32, NonZeroU32>> = Default::default();\n+\n     0\n }"}, {"sha": "301edc0d086b11fee1b251fd47b5ab7ebba36190", "filename": "src/test/ui/print_type_sizes/niche-filling.stdout", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/128b4c8035fc788b78157d4e1975cda0f25ce599/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout?ref=128b4c8035fc788b78157d4e1975cda0f25ce599", "patch": "@@ -14,6 +14,21 @@ print-type-size         field `.post`: 2 bytes\n print-type-size         field `.pre`: 1 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     end padding: 1 bytes\n+print-type-size type: `MyOption<Union1<std::num::NonZeroU32>>`: 8 bytes, alignment: 4 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size type: `MyOption<Union2<std::num::NonZeroU32, std::num::NonZeroU32>>`: 8 bytes, alignment: 4 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n+print-type-size type: `MyOption<Union2<std::num::NonZeroU32, u32>>`: 8 bytes, alignment: 4 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `None`: 0 bytes\n print-type-size type: `NestedNonZero`: 8 bytes, alignment: 4 bytes\n print-type-size     field `.val`: 4 bytes\n print-type-size     field `.post`: 2 bytes\n@@ -36,6 +51,17 @@ print-type-size type: `MyOption<std::num::NonZeroU32>`: 4 bytes, alignment: 4 by\n print-type-size     variant `Some`: 4 bytes\n print-type-size         field `.0`: 4 bytes\n print-type-size     variant `None`: 0 bytes\n+print-type-size type: `Union1<std::num::NonZeroU32>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `Union1`: 4 bytes\n+print-type-size         field `.a`: 4 bytes\n+print-type-size type: `Union2<std::num::NonZeroU32, std::num::NonZeroU32>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `Union2`: 4 bytes\n+print-type-size         field `.a`: 4 bytes\n+print-type-size         field `.b`: 4 bytes, offset: 0 bytes, alignment: 4 bytes\n+print-type-size type: `Union2<std::num::NonZeroU32, u32>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `Union2`: 4 bytes\n+print-type-size         field `.a`: 4 bytes\n+print-type-size         field `.b`: 4 bytes, offset: 0 bytes, alignment: 4 bytes\n print-type-size type: `std::num::NonZeroU32`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.0`: 4 bytes\n print-type-size type: `Enum4<(), (), (), MyOption<u8>>`: 2 bytes, alignment: 1 bytes"}]}