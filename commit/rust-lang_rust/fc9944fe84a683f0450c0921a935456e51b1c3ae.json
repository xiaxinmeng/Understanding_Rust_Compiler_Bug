{"sha": "fc9944fe84a683f0450c0921a935456e51b1c3ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOTk0NGZlODRhNjgzZjA0NTBjMDkyMWE5MzU0NTZlNTFiMWMzYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-12T11:20:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-12T11:20:47Z"}, "message": "Auto merge of #80499 - matthiaskrgr:red_clos, r=estebank\n\nremove redundant closures (clippy::redundant_closure)", "tree": {"sha": "19fb0b7698b10c57d4a75cd832531b3b9e6d16dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19fb0b7698b10c57d4a75cd832531b3b9e6d16dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc9944fe84a683f0450c0921a935456e51b1c3ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9944fe84a683f0450c0921a935456e51b1c3ae", "html_url": "https://github.com/rust-lang/rust/commit/fc9944fe84a683f0450c0921a935456e51b1c3ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc9944fe84a683f0450c0921a935456e51b1c3ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6b461652a9bebfb4ddabcae896ee7237cf0962a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6b461652a9bebfb4ddabcae896ee7237cf0962a", "html_url": "https://github.com/rust-lang/rust/commit/b6b461652a9bebfb4ddabcae896ee7237cf0962a"}, {"sha": "e2272cdffc0e2c658f5a4221f8ce700087d950a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2272cdffc0e2c658f5a4221f8ce700087d950a4", "html_url": "https://github.com/rust-lang/rust/commit/e2272cdffc0e2c658f5a4221f8ce700087d950a4"}], "stats": {"total": 85, "additions": 41, "deletions": 44}, "files": [{"sha": "444a9d4ba0463105752724f1537528583193aabf", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -292,7 +292,7 @@ fn add_unreachable_coverage<'tcx>(\n         if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n             let def_ids = unreachable_def_ids_by_file\n                 .entry(*non_codegenned_file_name)\n-                .or_insert_with(|| Vec::new());\n+                .or_insert_with(Vec::new);\n             def_ids.push(non_codegenned_def_id);\n         }\n     }"}, {"sha": "549b8d41f513011939b6e0900c490cdce4f86602", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -170,30 +170,30 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         // `expression_index`s lower than the referencing `Expression`. Therefore, it is\n         // reasonable to look up the new index of an expression operand while the `new_indexes`\n         // vector is only complete up to the current `ExpressionIndex`.\n-        let id_to_counter =\n-            |new_indexes: &IndexVec<InjectedExpressionIndex, Option<MappedExpressionIndex>>,\n-             id: ExpressionOperandId| {\n-                if id == ExpressionOperandId::ZERO {\n-                    Some(Counter::zero())\n-                } else if id.index() < self.counters.len() {\n-                    // Note: Some codegen-injected Counters may be only referenced by `Expression`s,\n-                    // and may not have their own `CodeRegion`s,\n-                    let index = CounterValueReference::from(id.index());\n-                    Some(Counter::counter_value_reference(index))\n-                } else {\n-                    let index = self.expression_index(u32::from(id));\n-                    self.expressions\n-                        .get(index)\n-                        .expect(\"expression id is out of range\")\n-                        .as_ref()\n-                        // If an expression was optimized out, assume it would have produced a count\n-                        // of zero. This ensures that expressions dependent on optimized-out\n-                        // expressions are still valid.\n-                        .map_or(Some(Counter::zero()), |_| {\n-                            new_indexes[index].map(|new_index| Counter::expression(new_index))\n-                        })\n-                }\n-            };\n+        let id_to_counter = |new_indexes: &IndexVec<\n+            InjectedExpressionIndex,\n+            Option<MappedExpressionIndex>,\n+        >,\n+                             id: ExpressionOperandId| {\n+            if id == ExpressionOperandId::ZERO {\n+                Some(Counter::zero())\n+            } else if id.index() < self.counters.len() {\n+                // Note: Some codegen-injected Counters may be only referenced by `Expression`s,\n+                // and may not have their own `CodeRegion`s,\n+                let index = CounterValueReference::from(id.index());\n+                Some(Counter::counter_value_reference(index))\n+            } else {\n+                let index = self.expression_index(u32::from(id));\n+                self.expressions\n+                    .get(index)\n+                    .expect(\"expression id is out of range\")\n+                    .as_ref()\n+                    // If an expression was optimized out, assume it would have produced a count\n+                    // of zero. This ensures that expressions dependent on optimized-out\n+                    // expressions are still valid.\n+                    .map_or(Some(Counter::zero()), |_| new_indexes[index].map(Counter::expression))\n+            }\n+        };\n \n         for (original_index, expression) in\n             self.expressions.iter_enumerated().filter_map(|(original_index, entry)| {"}, {"sha": "f2345ff2707e953d081b4aaee3064ddea877071a", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -92,7 +92,7 @@ crate fn matches_codepattern(a: &str, b: &str) -> bool {\n \n /// Advances the given peekable `Iterator` until it reaches a non-whitespace character.\n fn scan_for_non_ws_or_end<I: Iterator<Item = char>>(iter: &mut Peekable<I>) {\n-    while iter.peek().copied().map(|c| rustc_lexer::is_whitespace(c)) == Some(true) {\n+    while iter.peek().copied().map(rustc_lexer::is_whitespace) == Some(true) {\n         iter.next();\n     }\n }"}, {"sha": "70b8197f5ef384b313df25c0e4891c94a64ac5ea", "filename": "compiler/rustc_graphviz/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -55,7 +55,7 @@ impl NodeLabels<&'static str> {\n     fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n         match self {\n             UnlabelledNodes(len) => vec![None; len],\n-            AllNodesLabelled(lbls) => lbls.into_iter().map(|l| Some(l)).collect(),\n+            AllNodesLabelled(lbls) => lbls.into_iter().map(Some).collect(),\n             SomeNodesLabelled(lbls) => lbls.into_iter().collect(),\n         }\n     }"}, {"sha": "94186d490c3c29d7a49e889dd517971dcc0e0286", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -1438,22 +1438,21 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(|value| PredicateAtom::RegionOutlives(value))\n+        self.map_bound(PredicateAtom::RegionOutlives)\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(|value| PredicateAtom::TypeOutlives(value))\n+        self.map_bound(PredicateAtom::TypeOutlives)\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(|value| PredicateAtom::Projection(value))\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateAtom::Projection).potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n "}, {"sha": "2cd0dc6b1f2fdf3c35d0639e2f92aebbf7c807bb", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -130,7 +130,7 @@ const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n pub(super) fn debug_options<'a>() -> &'a DebugOptions {\n     static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n \n-    &DEBUG_OPTIONS.get_or_init(|| DebugOptions::from_env())\n+    &DEBUG_OPTIONS.get_or_init(DebugOptions::from_env)\n }\n \n /// Parses and maintains coverage-specific debug options captured from the environment variable\n@@ -430,7 +430,7 @@ impl GraphvizData {\n         {\n             bcb_to_coverage_spans_with_counters\n                 .entry(bcb)\n-                .or_insert_with(|| Vec::new())\n+                .or_insert_with(Vec::new)\n                 .push((coverage_span.clone(), counter_kind.clone()));\n         }\n     }\n@@ -456,7 +456,7 @@ impl GraphvizData {\n         if let Some(bcb_to_dependency_counters) = self.some_bcb_to_dependency_counters.as_mut() {\n             bcb_to_dependency_counters\n                 .entry(bcb)\n-                .or_insert_with(|| Vec::new())\n+                .or_insert_with(Vec::new)\n                 .push(counter_kind.clone());\n         }\n     }\n@@ -527,8 +527,8 @@ impl UsedExpressions {\n     pub fn add_expression_operands(&mut self, expression: &CoverageKind) {\n         if let Some(used_expression_operands) = self.some_used_expression_operands.as_mut() {\n             if let CoverageKind::Expression { id, lhs, rhs, .. } = *expression {\n-                used_expression_operands.entry(lhs).or_insert_with(|| Vec::new()).push(id);\n-                used_expression_operands.entry(rhs).or_insert_with(|| Vec::new()).push(id);\n+                used_expression_operands.entry(lhs).or_insert_with(Vec::new).push(id);\n+                used_expression_operands.entry(rhs).or_insert_with(Vec::new).push(id);\n             }\n         }\n     }"}, {"sha": "e58b915f1264c46a5774aa9da0dfa86855706747", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -394,7 +394,7 @@ impl BasicCoverageBlockData {\n         let operand = counter_kind.as_operand_id();\n         if let Some(replaced) = self\n             .edge_from_bcbs\n-            .get_or_insert_with(|| FxHashMap::default())\n+            .get_or_insert_with(FxHashMap::default)\n             .insert(from_bcb, counter_kind)\n         {\n             Error::from_string(format!("}, {"sha": "66aefc9a787fd8d0cdd99bef4b89775a8994717d", "filename": "compiler/rustc_span/src/analyze_source_file/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file%2Ftests.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -12,7 +12,7 @@ macro_rules! test {\n             let (lines, multi_byte_chars, non_narrow_chars) =\n                 analyze_source_file($text, BytePos($source_file_start_pos));\n \n-            let expected_lines: Vec<BytePos> = $lines.into_iter().map(|pos| BytePos(pos)).collect();\n+            let expected_lines: Vec<BytePos> = $lines.into_iter().map(BytePos).collect();\n \n             assert_eq!(lines, expected_lines);\n "}, {"sha": "90e20afc8f53865e79b4c3f88d80a6280f4231e2", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -4,7 +4,7 @@ use super::*;\n fn test_lev_distance() {\n     use std::char::{from_u32, MAX};\n     // Test bytelength agnosticity\n-    for c in (0..MAX as u32).filter_map(|i| from_u32(i)).map(|i| i.to_string()) {\n+    for c in (0..MAX as u32).filter_map(from_u32).map(|i| i.to_string()) {\n         assert_eq!(lev_distance(&c[..], &c[..]), 0);\n     }\n "}, {"sha": "405a88fd639f30053047f4bdf4b74174050a0a9b", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc9944fe84a683f0450c0921a935456e51b1c3ae/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=fc9944fe84a683f0450c0921a935456e51b1c3ae", "patch": "@@ -1256,17 +1256,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n         });\n \n-        let regular_trait_predicates = existential_trait_refs.map(|trait_ref| {\n-            trait_ref.map_bound(|trait_ref| ty::ExistentialPredicate::Trait(trait_ref))\n-        });\n+        let regular_trait_predicates = existential_trait_refs\n+            .map(|trait_ref| trait_ref.map_bound(ty::ExistentialPredicate::Trait));\n         let auto_trait_predicates = auto_traits.into_iter().map(|trait_ref| {\n             ty::Binder::dummy(ty::ExistentialPredicate::AutoTrait(trait_ref.trait_ref().def_id()))\n         });\n         let mut v = regular_trait_predicates\n             .chain(auto_trait_predicates)\n             .chain(\n-                existential_projections\n-                    .map(|x| x.map_bound(|x| ty::ExistentialPredicate::Projection(x))),\n+                existential_projections.map(|x| x.map_bound(ty::ExistentialPredicate::Projection)),\n             )\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));"}]}