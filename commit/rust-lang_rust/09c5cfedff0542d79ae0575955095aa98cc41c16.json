{"sha": "09c5cfedff0542d79ae0575955095aa98cc41c16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YzVjZmVkZmYwNTQyZDc5YWUwNTc1OTU1MDk1YWE5OGNjNDFjMTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-17T10:53:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-17T10:53:22Z"}, "message": "Merge #4914\n\n4914: Fix panic in match checking r=flodiebold a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/4416\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "b3f2c5e81e224e0b043ec5a78bbfefd4717e5dc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3f2c5e81e224e0b043ec5a78bbfefd4717e5dc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09c5cfedff0542d79ae0575955095aa98cc41c16", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe6fYjCRBK7hj4Ov3rIwAAdHIIAI4hmjiIsLEkPByaPRD95d7Y\nkolJNn7+j4dTBuw1Lsb9lZJD7pfpQKlZbgkKl6agxFcCbaLbXSJAnWyw+KB6pUj/\nezoBe3TW8TjbKczoaOeIZbj/WkMlE+p4tjq9Zx6gf+mzM5zqr0UM1TN2HdJJbu6E\nEE3hU6TxmY7daN8zURY6VvBi1A/RztwEaB+v51d/C2fZY5NzoNn3z861vDdcFMuV\n4W4sbInRuI9DjhJ1si2/NsZRFWl54mxDPTIOzYtPEDegJ5gDJmbO2TDMM9l4R8yy\nyBKBTtJpgyr3ND1vXQ6BJ7D8Z4TNxkJV+qAqj0OUWpkG1Kxl+jIBvGLTT8q6mQ8=\n=n/hB\n-----END PGP SIGNATURE-----\n", "payload": "tree b3f2c5e81e224e0b043ec5a78bbfefd4717e5dc1\nparent e9ddd12e8ac7c5e64b38aee10af6754015b6307c\nparent d8af7983b15d82f19c01e08e90b93708164df320\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592391202 +0000\ncommitter GitHub <noreply@github.com> 1592391202 +0000\n\nMerge #4914\n\n4914: Fix panic in match checking r=flodiebold a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/4416\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09c5cfedff0542d79ae0575955095aa98cc41c16", "html_url": "https://github.com/rust-lang/rust/commit/09c5cfedff0542d79ae0575955095aa98cc41c16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09c5cfedff0542d79ae0575955095aa98cc41c16/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ddd12e8ac7c5e64b38aee10af6754015b6307c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ddd12e8ac7c5e64b38aee10af6754015b6307c", "html_url": "https://github.com/rust-lang/rust/commit/e9ddd12e8ac7c5e64b38aee10af6754015b6307c"}, {"sha": "d8af7983b15d82f19c01e08e90b93708164df320", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8af7983b15d82f19c01e08e90b93708164df320", "html_url": "https://github.com/rust-lang/rust/commit/d8af7983b15d82f19c01e08e90b93708164df320"}], "stats": {"total": 790, "additions": 406, "deletions": 384}, "files": [{"sha": "02a7a61f129f98d40c6c3a28a89db2178968f914", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 406, "deletions": 384, "changes": 790, "blob_url": "https://github.com/rust-lang/rust/blob/09c5cfedff0542d79ae0575955095aa98cc41c16/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c5cfedff0542d79ae0575955095aa98cc41c16/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=09c5cfedff0542d79ae0575955095aa98cc41c16", "patch": "@@ -362,7 +362,12 @@ impl PatStack {\n         cx: &MatchCheckCtx,\n         constructor: &Constructor,\n     ) -> MatchCheckResult<Option<PatStack>> {\n-        let result = match (self.head().as_pat(cx), constructor) {\n+        if self.is_empty() {\n+            return Ok(None);\n+        }\n+\n+        let head_pat = self.head().as_pat(cx);\n+        let result = match (head_pat, constructor) {\n             (Pat::Tuple { args: ref pat_ids, ellipsis }, Constructor::Tuple { arity: _ }) => {\n                 if ellipsis.is_some() {\n                     // If there are ellipsis here, we should add the correct number of\n@@ -531,7 +536,7 @@ impl Matrix {\n     }\n \n     fn heads(&self) -> Vec<PatIdOrWild> {\n-        self.0.iter().map(|p| p.head()).collect()\n+        self.0.iter().flat_map(|p| p.get_head()).collect()\n     }\n \n     /// Computes `D(self)` for each contained PatStack.\n@@ -837,224 +842,223 @@ mod tests {\n \n     pub(super) use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n \n-    pub(super) fn check_diagnostic_message(content: &str) -> String {\n-        TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().0\n+    pub(super) fn check_diagnostic_message(ra_fixture: &str) -> String {\n+        TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().0\n     }\n \n-    pub(super) fn check_diagnostic(content: &str) {\n+    pub(super) fn check_diagnostic(ra_fixture: &str) {\n         let diagnostic_count =\n-            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n+            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n     }\n \n-    pub(super) fn check_no_diagnostic(content: &str) {\n+    pub(super) fn check_no_diagnostic(ra_fixture: &str) {\n         let diagnostic_count =\n-            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n+            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n     }\n \n     #[test]\n     fn empty_tuple_no_arms_diagnostic_message() {\n-        let content = r\"\n-            fn test_fn() {\n-                match () {\n-                }\n-            }\n-        \";\n-\n         assert_snapshot!(\n-            check_diagnostic_message(content),\n+            check_diagnostic_message(r\"\n+                fn test_fn() {\n+                    match () {\n+                    }\n+                }\n+            \"),\n             @\"\\\"()\\\": Missing match arm\\n\"\n         );\n     }\n \n     #[test]\n     fn empty_tuple_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match () {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn empty_tuple_wild() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match () {\n                     _ => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn empty_tuple_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match () {\n                     () => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_empty_tuple_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (()) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_empty_tuple_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (()) {\n                     (()) => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_two_empty_tuple_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match ((), ()) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_two_empty_tuple_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match ((), ()) {\n                     ((), ()) => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn bool_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match false {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn bool_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match false {\n                     true => {}\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn bool_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match false {\n                     true => {}\n                     false => {}\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, true) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (false, true) => {},\n                     (false, false) => {},\n                     (true, false) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_wilds() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (false, _) => {},\n                     (true, false) => {},\n                     (_, true) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, true) => {},\n@@ -1063,108 +1067,108 @@ mod tests {\n                     (false, false) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_binding_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, _x) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_binding_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true) {\n                     (true, _x) => {},\n                     (false, true) => {},\n                     (false, false) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (false, ..) => {},\n                     (true, ..) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (.., false) => {},\n                     (.., true) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (..) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, ((), true)) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, ((), true)) => {},\n@@ -1173,42 +1177,42 @@ mod tests {\n                     (false, ((), false)) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, _) => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, ((), false)) {\n                     (true, ((), true)) => {},\n                     (true, ((), false)) => {},\n                     (false, _) => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1217,14 +1221,14 @@ mod tests {\n                 match Either::A {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1234,14 +1238,14 @@ mod tests {\n                     Either::A => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1252,14 +1256,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_ref_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1269,14 +1273,14 @@ mod tests {\n                     Either::A => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_ref_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1287,14 +1291,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1303,14 +1307,14 @@ mod tests {\n                 match Either::B {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1321,14 +1325,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1340,14 +1344,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_with_wild_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1358,14 +1362,14 @@ mod tests {\n                     _ => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_containing_bool_with_wild_2_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B,\n@@ -1376,14 +1380,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_different_sizes_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1394,14 +1398,14 @@ mod tests {\n                     Either::B(false, _) => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_different_sizes_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1413,14 +1417,14 @@ mod tests {\n                     Either::B(false, _) => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn or_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1432,14 +1436,14 @@ mod tests {\n                     Either::B(false, _) => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_enum_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool),\n                 B(bool, bool),\n@@ -1456,14 +1460,16 @@ mod tests {\n                     (Either::B(_, _), Either2::D) => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn mismatched_types() {\n-        let content = r\"\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1478,47 +1484,47 @@ mod tests {\n                     Either2::D => (),\n                 }\n             }\n-        \";\n-\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn mismatched_types_with_different_arity() {\n-        let content = r\"\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (true, false) {\n                     (true, false, true) => (),\n                     (true) => (),\n                 }\n             }\n-        \";\n-\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_missing_pattern() {\n-        let content = r\"\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (0) {\n                     () => (),\n                 }\n             }\n-        \";\n-\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_enum_missing_pattern() {\n-        let content = r\"\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B(u32),\n@@ -1529,32 +1535,30 @@ mod tests {\n                     Either::B() => (),\n                 }\n             }\n-        \";\n-\n-        // We are testing to be sure we don't panic here when the match\n-        // arm `Either::B` is missing its pattern.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_not_in_scope() {\n-        let content = r\"\n+        // The enum is not in scope so we don't perform exhaustiveness\n+        // checking, but we want to be sure we don't panic here (and\n+        // we don't create a diagnostic).\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match Foo::Bar {\n                     Foo::Baz => (),\n                 }\n             }\n-        \";\n-\n-        // The enum is not in scope so we don't perform exhaustiveness\n-        // checking, but we want to be sure we don't panic here (and\n-        // we don't create a diagnostic).\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_diverges() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1565,14 +1569,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_loop_with_break() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1583,14 +1587,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_partially_diverges() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either<T> {\n                 A(T),\n                 B,\n@@ -1604,14 +1608,14 @@ mod tests {\n                     Either::B => 0,\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_no_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1621,14 +1625,14 @@ mod tests {\n                 match a {\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_missing_arms() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1639,14 +1643,14 @@ mod tests {\n                     Either::A { foo: true } => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1659,14 +1663,17 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_missing_field_no_diagnostic() {\n-        let content = r\"\n+        // When `Either::A` is missing a struct member, we don't want\n+        // to fire the missing match arm diagnostic. This should fire\n+        // some other diagnostic.\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1678,17 +1685,16 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        // When `Either::A` is missing a struct member, we don't want\n-        // to fire the missing match arm diagnostic. This should fire\n-        // some other diagnostic.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_missing_field_missing_match_arm() {\n-        let content = r\"\n+        // Even though `Either::A` is missing fields, we still want to fire\n+        // the missing arm diagnostic here, since we know `Either::B` is missing.\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1699,16 +1705,14 @@ mod tests {\n                     Either::A { } => (),\n                 }\n             }\n-        \";\n-\n-        // Even though `Either::A` is missing fields, we still want to fire\n-        // the missing arm diagnostic here, since we know `Either::B` is missing.\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_no_diagnostic_wild() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool },\n                 B,\n@@ -1720,14 +1724,14 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_fields_out_of_order_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool, bar: () },\n                 B,\n@@ -1739,14 +1743,14 @@ mod tests {\n                     Either::A { foo: true, bar: () } => (),\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_fields_out_of_order_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A { foo: bool, bar: () },\n                 B,\n@@ -1759,89 +1763,89 @@ mod tests {\n                     Either::B => (),\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_missing_arm() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 match Either::B {\n-                     Either::A { foo: true, .. } => (),\n-                     Either::B => (),\n-                 }\n-             }\n-         \";\n-\n-        check_diagnostic(content);\n+        check_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A { foo: true, .. } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_no_diagnostic() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 let a = Either::A { foo: true };\n-                 match a {\n-                     Either::A { foo: true, .. } => (),\n-                     Either::A { foo: false, .. } => (),\n-                     Either::B => (),\n-                 }\n-             }\n-         \";\n-\n-        check_no_diagnostic(content);\n+        check_no_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: true, .. } => (),\n+                    Either::A { foo: false, .. } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_all_fields_missing_arm() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 let a = Either::B;\n-                 match a {\n-                     Either::A { .. } => (),\n-                 }\n-             }\n-         \";\n-\n-        check_diagnostic(content);\n+        check_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { .. } => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_record_ellipsis_all_fields_no_diagnostic() {\n-        let content = r\"\n-             enum Either {\n-                 A { foo: bool, bar: bool },\n-                 B,\n-             }\n-             fn test_fn() {\n-                 let a = Either::B;\n-                 match a {\n-                     Either::A { .. } => (),\n-                     Either::B => (),\n-                 }\n-             }\n-         \";\n-\n-        check_no_diagnostic(content);\n+        check_no_diagnostic(\n+            r\"\n+            enum Either {\n+                A { foo: bool, bar: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { .. } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1855,14 +1859,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1876,14 +1880,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1896,14 +1900,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_partial_ellipsis_2_missing_arm() {\n-        let content = r\"\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1916,14 +1920,14 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_tuple_ellipsis_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A(bool, bool, bool, bool),\n                 B,\n@@ -1934,51 +1938,51 @@ mod tests {\n                     Either::B => {},\n                 }\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_never() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Never {}\n \n             fn test_fn(never: Never) {\n                 match never {}\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn type_never() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn(never: !) {\n                 match never {}\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn enum_never_ref() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Never {}\n \n             fn test_fn(never: &Never) {\n                 match never {}\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_diverges_missing_arm() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -1988,9 +1992,27 @@ mod tests {\n                     Either::A => (),\n                 }\n             }\n-        \";\n+        \",\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern_panic() {\n+        check_no_diagnostic(\n+            r\"\n+            pub enum Category {\n+                Infinity,\n+                Zero,\n+            }\n \n-        check_no_diagnostic(content);\n+            fn panic(a: Category, b: Category) {\n+                match (a, b) {\n+                    (Category::Zero | Category::Infinity, _) => {}\n+                    (_, Category::Zero | Category::Infinity) => {}\n+                }\n+            }\n+        \",\n+        );\n     }\n }\n \n@@ -2010,23 +2032,26 @@ mod false_negatives {\n \n     #[test]\n     fn integers() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently check integer exhaustiveness.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match 5 {\n                     10 => (),\n                     11..20 => (),\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently check integer exhaustiveness.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn internal_or() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We do not currently handle patterns with internal `or`s.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 enum Either {\n                     A(bool),\n@@ -2036,16 +2061,18 @@ mod false_negatives {\n                     Either::A(true | false) => (),\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We do not currently handle patterns with internal `or`s.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn expr_loop_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n+        // causes us to skip the diagnostic since `Either::A` doesn't type check\n+        // with `!`.\n+        check_diagnostic(\n+            r\"\n             enum Either {\n                 A,\n                 B,\n@@ -2055,48 +2082,46 @@ mod false_negatives {\n                     Either::A => (),\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n-        // causes us to skip the diagnostic since `Either::A` doesn't type check\n-        // with `!`.\n-        check_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently handle tuple patterns with ellipsis.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (false, ..) => {},\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently handle tuple patterns with ellipsis.\n+        check_no_diagnostic(\n+            r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (.., false) => {},\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn struct_missing_arm() {\n-        let content = r\"\n+        // This is a false negative.\n+        // We don't currently handle structs.\n+        check_no_diagnostic(\n+            r\"\n             struct Foo {\n                 a: bool,\n             }\n@@ -2105,10 +2130,7 @@ mod false_negatives {\n                     Foo { a: true } => {},\n                 }\n             }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle structs.\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n }"}]}