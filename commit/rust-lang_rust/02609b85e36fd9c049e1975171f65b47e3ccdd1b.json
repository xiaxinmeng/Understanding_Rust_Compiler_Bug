{"sha": "02609b85e36fd9c049e1975171f65b47e3ccdd1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNjA5Yjg1ZTM2ZmQ5YzA0OWUxOTc1MTcxZjY1YjQ3ZTNjY2RkMWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-03T15:58:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:19Z"}, "message": "rename from \"in constraint\" to \"pick constraint\"", "tree": {"sha": "84b78f547e593287502c6d6aab0b8d08f9fa3a5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b78f547e593287502c6d6aab0b8d08f9fa3a5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02609b85e36fd9c049e1975171f65b47e3ccdd1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02609b85e36fd9c049e1975171f65b47e3ccdd1b", "html_url": "https://github.com/rust-lang/rust/commit/02609b85e36fd9c049e1975171f65b47e3ccdd1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02609b85e36fd9c049e1975171f65b47e3ccdd1b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c36205b48e83517e96a2887296114db3df831e21", "url": "https://api.github.com/repos/rust-lang/rust/commits/c36205b48e83517e96a2887296114db3df831e21", "html_url": "https://github.com/rust-lang/rust/commit/c36205b48e83517e96a2887296114db3df831e21"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "d00da11d17d45a39b28befb96c5b22837964c19b", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=02609b85e36fd9c049e1975171f65b47e3ccdd1b", "patch": "@@ -654,14 +654,14 @@ pub fn make_query_outlives<'tcx>(\n         constraints,\n         verifys,\n         givens,\n-        in_constraints,\n+        pick_constraints,\n     } = region_constraints;\n \n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n     // FIXME(ndm) -- we have to think about what to do here, perhaps\n-    assert!(in_constraints.is_empty());\n+    assert!(pick_constraints.is_empty());\n \n     let outlives: Vec<_> = constraints\n         .into_iter()"}, {"sha": "a37eff82e6eb316ac37436d51de260e396f72a8e", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=02609b85e36fd9c049e1975171f65b47e3ccdd1b", "patch": "@@ -2,7 +2,7 @@\n \n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n-use crate::infer::region_constraints::InConstraint;\n+use crate::infer::region_constraints::PickConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n@@ -118,7 +118,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        self.enforce_in_constraints(&graph, &mut var_data);\n+        self.enforce_pick_constraints(&graph, &mut var_data);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -200,63 +200,63 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ///     - if `'o[i] <= 'b` is false, then `'o[i]` is not an option\n     ///\n     /// Hopefully this narrows it down to just one option.\n-    fn enforce_in_constraints(\n+    fn enforce_pick_constraints(\n         &self,\n         graph: &RegionGraph<'tcx>,\n         var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) {\n-        for in_constraint in &self.data.in_constraints {\n-            let _ = self.enforce_in_constraint(graph, in_constraint, var_values);\n+        for pick_constraint in &self.data.pick_constraints {\n+            let _ = self.enforce_pick_constraint(graph, pick_constraint, var_values);\n         }\n     }\n \n-    fn enforce_in_constraint(\n+    fn enforce_pick_constraint(\n         &self,\n         graph: &RegionGraph<'tcx>,\n-        in_constraint: &InConstraint<'tcx>,\n+        pick_constraint: &PickConstraint<'tcx>,\n         var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) -> Result<(), ()> {\n-        debug!(\"enforce_in_constraint(in_constraint={:#?})\", in_constraint);\n+        debug!(\"enforce_pick_constraint(pick_constraint={:#?})\", pick_constraint);\n \n         // the constraint is some inference variable (`vid`) which\n         // must be equal to one of the options\n-        let vid = match in_constraint.region {\n+        let pick_vid = match pick_constraint.pick_region {\n             ty::ReVar(vid) => *vid,\n             _ => return Err(()),\n         };\n \n         // find all the \"bounds\" -- that is, each region `b` such that\n         // `r0 <= b` must hold.\n-        let (bounds, _) = self.collect_concrete_regions(graph, vid, OUTGOING, None);\n+        let (pick_bounds, _) = self.collect_concrete_regions(graph, pick_vid, OUTGOING, None);\n \n         // get an iterator over the *available options* -- that is,\n         // each constraint regions `o` where `o <= b` for all the\n         // bounds `b`.\n-        debug!(\"enforce_in_constraint: bounds={:#?}\", bounds);\n-        let mut options = in_constraint.in_regions.iter().filter(|option| {\n-            bounds.iter().all(|bound| self.sub_concrete_regions(option, bound.region))\n+        debug!(\"enforce_pick_constraint: bounds={:#?}\", pick_bounds);\n+        let mut options = pick_constraint.option_regions.iter().filter(|option| {\n+            pick_bounds.iter().all(|bound| self.sub_concrete_regions(option, bound.region))\n         });\n \n         // if there >1 option, we only make a choice if there is a\n         // single *least* choice -- i.e., some available region that\n         // is `<=` all the others.\n         let mut least_choice = options.next().ok_or(())?;\n-        debug!(\"enforce_in_constraint: least_choice={:?}\", least_choice);\n+        debug!(\"enforce_pick_constraint: least_choice={:?}\", least_choice);\n         for option in options {\n-            debug!(\"enforce_in_constraint: option={:?}\", option);\n+            debug!(\"enforce_pick_constraint: option={:?}\", option);\n             if !self.sub_concrete_regions(least_choice, option) {\n                 if self.sub_concrete_regions(option, least_choice) {\n-                    debug!(\"enforce_in_constraint: new least choice\");\n+                    debug!(\"enforce_pick_constraint: new least choice\");\n                     least_choice = option;\n                 } else {\n-                    debug!(\"enforce_in_constraint: no least choice\");\n+                    debug!(\"enforce_pick_constraint: no least choice\");\n                     return Err(());\n                 }\n             }\n         }\n \n-        debug!(\"enforce_in_constraint: final least choice = {:?}\", least_choice);\n-        *var_values.value_mut(vid) = VarValue::Value(least_choice);\n+        debug!(\"enforce_pick_constraint: final least choice = {:?}\", least_choice);\n+        *var_values.value_mut(pick_vid) = VarValue::Value(least_choice);\n \n         Ok(())\n     }"}, {"sha": "ba42c7a54418efa73fd22a6fd31842b0be7516d3", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=02609b85e36fd9c049e1975171f65b47e3ccdd1b", "patch": "@@ -907,15 +907,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Require that the region `r` be equal to one of the regions in\n     /// the set `regions`.\n-    pub fn in_constraint(\n+    pub fn pick_constraint(\n         &self,\n         origin: SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         in_regions: &Rc<Vec<ty::Region<'tcx>>>,\n     ) {\n         debug!(\"sub_regions({:?} <: {:?})\", region, in_regions);\n         self.borrow_region_constraints()\n-            .in_constraint(origin, region, in_regions);\n+            .pick_constraint(origin, region, in_regions);\n     }\n \n     pub fn subtype_predicate("}, {"sha": "733155ad501a1ebbbe9858902a7d20eb4e51fe7c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=02609b85e36fd9c049e1975171f65b47e3ccdd1b", "patch": "@@ -421,7 +421,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             tcx: self.tcx,\n-            op: |r| self.in_constraint(infer::CallReturn(span), r, &in_regions),\n+            op: |r| self.pick_constraint(infer::CallReturn(span), r, &in_regions),\n         });\n     }\n "}, {"sha": "fa64690ded474b1c99a82a21c589b9df5ed996f8", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02609b85e36fd9c049e1975171f65b47e3ccdd1b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=02609b85e36fd9c049e1975171f65b47e3ccdd1b", "patch": "@@ -79,10 +79,10 @@ pub struct RegionConstraintData<'tcx> {\n     /// be a region variable (or neither, as it happens).\n     pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n \n-    /// Constraints of the form `R0 in [R1, ..., Rn]`, meaning that\n+    /// Constraints of the form `pick R0 from [R1, ..., Rn]`, meaning that\n     /// `R0` must be equal to one of the regions `R1..Rn`. These occur\n     /// with `impl Trait` quite frequently.\n-    pub in_constraints: Vec<InConstraint<'tcx>>,\n+    pub pick_constraints: Vec<PickConstraint<'tcx>>,\n \n     /// A \"verify\" is something that we need to verify after inference\n     /// is done, but which does not directly affect inference in any\n@@ -143,12 +143,17 @@ impl Constraint<'_> {\n     }\n }\n \n-/// Requires that `region` must be equal to one of the regions in `in_regions`.\n+/// Requires that `region` must be equal to one of the regions in `option_regions`.\n+/// We often denote this using the syntax:\n+///\n+/// ```\n+/// pick R0 from [O1..On]\n+/// ```\n #[derive(Debug, Clone)]\n-pub struct InConstraint<'tcx> {\n+pub struct PickConstraint<'tcx> {\n     pub origin: SubregionOrigin<'tcx>,\n-    pub region: Region<'tcx>,\n-    pub in_regions: Rc<Vec<Region<'tcx>>>,\n+    pub pick_region: Region<'tcx>,\n+    pub option_regions: Rc<Vec<Region<'tcx>>>,\n }\n \n /// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n@@ -657,20 +662,20 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn in_constraint(\n+    pub fn pick_constraint(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n-        region: ty::Region<'tcx>,\n-        in_regions: &Rc<Vec<ty::Region<'tcx>>>,\n+        pick_region: ty::Region<'tcx>,\n+        option_regions: &Rc<Vec<ty::Region<'tcx>>>,\n     ) {\n-        debug!(\"in_constraint({:?} in {:#?})\", region, in_regions);\n+        debug!(\"pick_constraint({:?} in {:#?})\", pick_region, option_regions);\n \n-        if in_regions.iter().any(|&r| r == region) {\n+        if option_regions.iter().any(|&r| r == pick_region) {\n             return;\n         }\n \n-        self.data.in_constraints.push(InConstraint {\n-            origin, region, in_regions: in_regions.clone()\n+        self.data.pick_constraints.push(PickConstraint {\n+            origin, pick_region, option_regions: option_regions.clone()\n         });\n \n     }\n@@ -938,10 +943,10 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,\n-            in_constraints,\n+            pick_constraints,\n             verifys,\n             givens,\n         } = self;\n-        constraints.is_empty() && in_constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n+        constraints.is_empty() && pick_constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n     }\n }"}]}