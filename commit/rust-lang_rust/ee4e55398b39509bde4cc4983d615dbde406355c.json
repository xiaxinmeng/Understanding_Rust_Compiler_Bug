{"sha": "ee4e55398b39509bde4cc4983d615dbde406355c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNGU1NTM5OGIzOTUwOWJkZTRjYzQ5ODNkNjE1ZGJkZTQwNjM1NWM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-03T20:15:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-09T22:03:54Z"}, "message": "Introduce TyCtxt::expect_def/expect_resolution helpers and use them where possible", "tree": {"sha": "1b5f331cb8fd834678574e19a5b0dc9308b7fd85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b5f331cb8fd834678574e19a5b0dc9308b7fd85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee4e55398b39509bde4cc4983d615dbde406355c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4e55398b39509bde4cc4983d615dbde406355c", "html_url": "https://github.com/rust-lang/rust/commit/ee4e55398b39509bde4cc4983d615dbde406355c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee4e55398b39509bde4cc4983d615dbde406355c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c30f6405c80fe2cd5f1789838ded06020a50457", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c30f6405c80fe2cd5f1789838ded06020a50457", "html_url": "https://github.com/rust-lang/rust/commit/4c30f6405c80fe2cd5f1789838ded06020a50457"}], "stats": {"total": 750, "additions": 277, "deletions": 473}, "files": [{"sha": "18ea17f48162f1b66c168c00d3246d8b9b7712b3", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -574,8 +574,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             return *self.loop_scopes.last().unwrap();\n         }\n \n-        match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-            Some(Def::Label(loop_id)) => {\n+        match self.tcx.expect_def(expr.id) {\n+            Def::Label(loop_id) => {\n                 for l in &self.loop_scopes {\n                     if l.loop_id == loop_id {\n                         return *l;"}, {"sha": "72261c473e5c5d6a252733f988b43956f681ef78", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -67,6 +67,10 @@ pub struct PathResolution {\n }\n \n impl PathResolution {\n+    pub fn new(def: Def) -> PathResolution {\n+        PathResolution { base_def: def, depth: 0 }\n+    }\n+\n     /// Get the definition, if fully resolved, otherwise panic.\n     pub fn full_def(&self) -> Def {\n         if self.depth != 0 {\n@@ -75,20 +79,6 @@ impl PathResolution {\n         self.base_def\n     }\n \n-    /// Get the DefId, if fully resolved, otherwise panic.\n-    pub fn def_id(&self) -> DefId {\n-        self.full_def().def_id()\n-    }\n-\n-    pub fn new(base_def: Def,\n-               depth: usize)\n-               -> PathResolution {\n-        PathResolution {\n-            base_def: base_def,\n-            depth: depth,\n-        }\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         if self.depth != 0 {\n             \"associated item\""}, {"sha": "69cf5baa26fecc5d7013fb94f01f67e2e2363e9a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -866,7 +866,7 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n+                        match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n                             // `None` can occur in body-less function signatures\n                             None | Some(Def::Local(..)) => {\n                                 hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n@@ -1238,14 +1238,10 @@ impl<'a> LoweringContext<'a> {\n                             position: position,\n                         }\n                     });\n-                    let rename = if qself.is_none() && path.segments.len() == 1 {\n-                        // Only local variables are renamed\n-                        match self.resolver.get_resolution(e.id).map(|d| d.full_def()) {\n-                            Some(Def::Local(..)) | Some(Def::Upvar(..)) => true,\n-                            _ => false,\n-                        }\n-                    } else {\n-                        false\n+                    // Only local variables are renamed\n+                    let rename = match self.resolver.get_resolution(e.id).map(|d| d.base_def) {\n+                        Some(Def::Local(..)) | Some(Def::Upvar(..)) => true,\n+                        _ => false,\n                     };\n                     hir::ExprPath(hir_qself, self.lower_path_full(path, rename))\n                 }"}, {"sha": "27896b09981210d91ba2cbc32beb802a60b6bd18", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -1357,17 +1357,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyPath(ref maybe_qself, ref path) => {\n-                    let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n-                        None => {\n-                            self.tcx\n-                                .sess\n-                                .fatal(&format!(\n-                                        \"unbound path {}\",\n-                                        pprust::path_to_string(path)))\n-                        }\n-                        Some(d) => d.full_def()\n-                    };\n-                    match a_def {\n+                    match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n                             let generics = self.tcx.lookup_item_type(did).generics;\n "}, {"sha": "f132212415f2f4d43ca4d7a84b3ca60cd7a49b93", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -65,13 +65,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// to it.\n     pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n         if let ast::TyPath(None, ref path) = ast_ty.node {\n-            let def = match self.def_map.borrow().get(&ast_ty.id) {\n-                None => {\n-                    span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n-                }\n-                Some(d) => d.full_def()\n-            };\n-            if let Def::PrimTy(nty) = def {\n+            if let Def::PrimTy(nty) = self.expect_def(ast_ty.id) {\n                 Some(self.prim_ty_to_ty(&path.segments, nty))\n             } else {\n                 None"}, {"sha": "e65074a4f07b3b64e8480b4a249af5cf1f4e6873", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -84,36 +84,35 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n+    fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n         use ty::TypeVariants::{TyEnum, TyStruct};\n \n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n-        self.tcx.tables.borrow().item_substs.get(id)\n+        self.tcx.tables.borrow().item_substs.get(&id)\n             .and_then(|substs| substs.substs.self_ty())\n             .map(|ty| match ty.sty {\n                 TyEnum(tyid, _) | TyStruct(tyid, _) => self.check_def_id(tyid.did),\n                 _ => (),\n             });\n \n-        self.tcx.def_map.borrow().get(id).map(|def| {\n-            match def.full_def() {\n-                Def::Const(_) | Def::AssociatedConst(..) => {\n-                    self.check_def_id(def.def_id());\n-                }\n-                _ if self.ignore_non_const_paths => (),\n-                Def::PrimTy(_) => (),\n-                Def::SelfTy(..) => (),\n-                Def::Variant(enum_id, variant_id) => {\n-                    self.check_def_id(enum_id);\n-                    if !self.ignore_variant_stack.contains(&variant_id) {\n-                        self.check_def_id(variant_id);\n-                    }\n-                }\n-                _ => {\n-                    self.check_def_id(def.def_id());\n+        let def = self.tcx.expect_def(id);\n+        match def {\n+            Def::Const(_) | Def::AssociatedConst(..) => {\n+                self.check_def_id(def.def_id());\n+            }\n+            _ if self.ignore_non_const_paths => (),\n+            Def::PrimTy(_) => (),\n+            Def::SelfTy(..) => (),\n+            Def::Variant(enum_id, variant_id) => {\n+                self.check_def_id(enum_id);\n+                if !self.ignore_variant_stack.contains(&variant_id) {\n+                    self.check_def_id(variant_id);\n                 }\n             }\n-        });\n+            _ => {\n+                self.check_def_id(def.def_id());\n+            }\n+        }\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n@@ -138,10 +137,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let def = self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def();\n-        let pat_ty = self.tcx.node_id_to_type(lhs.id);\n-        let variant = match pat_ty.sty {\n-            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => adt.variant_of_def(def),\n+        let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n+            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => {\n+                adt.variant_of_def(self.tcx.expect_def(lhs.id))\n+            }\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -272,7 +271,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             }\n             _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {\n                 // it might be the only use of a const\n-                self.lookup_and_handle_definition(&pat.id)\n+                self.lookup_and_handle_definition(pat.id)\n             }\n             _ => ()\n         }\n@@ -283,12 +282,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(&id);\n+        self.lookup_and_handle_definition(id);\n         intravisit::walk_path(self, path);\n     }\n \n     fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n-        self.lookup_and_handle_definition(&item.node.id());\n+        self.lookup_and_handle_definition(item.node.id());\n         intravisit::walk_path_list_item(self, path, item);\n     }\n }"}, {"sha": "24816d2b497295e81c1a7d207fac0c68efe4f86c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             hir::ExprPath(..) => {\n-                if let Def::Static(_, true) = self.tcx.resolve_expr(expr) {\n+                if let Def::Static(_, true) = self.tcx.expect_def(expr.id) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }"}, {"sha": "3b571ed057602955c855148fffe1f1e152036a95", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -955,9 +955,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n \n+        let tcx = &self.tcx();\n         let mc = &self.mc;\n         let infcx = self.mc.infcx;\n-        let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             match pat.node {\n@@ -972,8 +972,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                     // Each match binding is effectively an assignment to the\n                     // binding being produced.\n-                    let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n-                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n+                                                        tcx.expect_def(pat.id)) {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n \n@@ -1002,14 +1002,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            let def_map = def_map.borrow();\n-            let tcx = infcx.tcx;\n-\n             match pat.node {\n                 PatKind::Struct(..) | PatKind::TupleStruct(..) |\n                 PatKind::Path(..) | PatKind::QPath(..) => {\n-                    match def_map.get(&pat.id).map(|d| d.full_def()) {\n-                        Some(Def::Variant(enum_did, variant_did)) => {\n+                    match tcx.expect_def(pat.id) {\n+                        Def::Variant(enum_did, variant_did) => {\n                             let downcast_cmt =\n                                 if tcx.lookup_adt_def(enum_did).is_univariant() {\n                                     cmt_pat\n@@ -1025,7 +1022,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n \n-                        Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => {\n+                        Def::Struct(..) | Def::TyAlias(..) => {\n                             // A struct (in either the value or type\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n@@ -1037,8 +1034,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n \n-                        Some(Def::Const(..)) |\n-                        Some(Def::AssociatedConst(..)) => {\n+                        Def::Const(..) | Def::AssociatedConst(..) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call."}, {"sha": "70158e9b9dff7704e12c16461b3999277db354da", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n-            match self.infcx.tcx.resolve_expr(expr) {\n+            match self.infcx.tcx.expect_def(expr.id) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n                     let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {"}, {"sha": "ceffa366413fa3aaf0893c13f90325f217e1abb4", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -445,7 +445,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprPath(..) => {\n-        let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n+        let def = ir.tcx.expect_def(expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let Def::Local(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -695,8 +695,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                    Some(Def::Label(loop_id)) => loop_id,\n+                match self.ir.tcx.expect_def(id) {\n+                    Def::Label(loop_id) => loop_id,\n                     _ => span_bug!(sp, \"label on break/loop \\\n                                         doesn't refer to a loop\")\n                 }\n@@ -1269,7 +1269,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n+        match self.ir.tcx.expect_def(expr.id) {\n           Def::Local(_, nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1534,9 +1534,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let Def::Local(_, nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n-                                                                      .unwrap()\n-                                                                      .full_def() {\n+                if let Def::Local(_, nid) = self.ir.tcx.expect_def(expr.id) {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "d2a5cd73503314def22dab92ef0d216b5c65d929", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -517,8 +517,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(..) => {\n-            let def = self.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n-            self.cat_def(expr.id, expr.span, expr_ty, def)\n+            self.cat_def(expr.id, expr.span, expr_ty, self.tcx().expect_def(expr.id))\n           }\n \n           hir::ExprType(ref e, _) => {\n@@ -1106,12 +1105,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         (*op)(self, cmt.clone(), pat);\n \n+        // This function can be used during region checking when not all paths are fully\n+        // resolved. Partially resolved paths in patterns can only legally refer to\n+        // associated constants which don't require categorization.\n         let opt_def = if let Some(path_res) = self.tcx().def_map.borrow().get(&pat.id) {\n             if path_res.depth != 0 || path_res.base_def == Def::Err {\n-                // Since patterns can be associated constants\n-                // which are resolved during typeck, we might have\n-                // some unresolved patterns reaching this stage\n-                // without aborting\n                 return Err(());\n             }\n             Some(path_res.full_def())"}, {"sha": "6ea0fa20c572689c00b6804c74c1818e077dd04c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -92,13 +92,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                let def = match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(d) => d.full_def(),\n-                    None => {\n-                        span_bug!(expr.span, \"def ID not in def map?!\")\n-                    }\n-                };\n-\n+                let def = self.tcx.expect_def(expr.id);\n                 let def_id = def.def_id();\n                 if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "3744f564fa27117b46b37ababc40dddf1ee1d617", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -494,7 +494,7 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n         hir::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n-            let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n+            let trait_did = tcx.expect_def(t.ref_id).def_id();\n             let trait_items = tcx.trait_items(trait_did);\n \n             for impl_item in impl_items {\n@@ -580,7 +580,8 @@ pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>,\n                                            &Option<Deprecation>)) {\n-    match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+    // Paths in import prefixes may have no resolution.\n+    match tcx.expect_def_or_none(id) {\n         Some(Def::PrimTy(..)) => {}\n         Some(Def::SelfTy(..)) => {}\n         Some(def) => {\n@@ -595,12 +596,11 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n                                                      &Option<Deprecation>)) {\n-    match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n-        Some(Def::PrimTy(..)) => {}\n-        Some(def) => {\n+    match tcx.expect_def(item.node.id()) {\n+        Def::PrimTy(..) => {}\n+        def => {\n             maybe_do_stability_check(tcx, def.def_id(), item.span, cb);\n         }\n-        None => {}\n     }\n }\n "}, {"sha": "28266809266373aa96b8df2efb1c0b88d5817d44", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -22,7 +22,7 @@ use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n use middle::cstore::{self, LOCAL_CRATE};\n-use hir::def::{self, Def, ExportMap};\n+use hir::def::{Def, PathResolution, ExportMap};\n use hir::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n@@ -308,13 +308,11 @@ impl Visibility {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { id, .. } => match tcx.def_map.borrow().get(&id) {\n-                Some(resolution) => Visibility::Restricted({\n-                    tcx.map.as_local_node_id(resolution.base_def.def_id()).unwrap()\n-                }),\n+            hir::Visibility::Restricted { id, .. } => match tcx.expect_def(id) {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n-                None => Visibility::Public,\n+                Def::Err => Visibility::Public,\n+                def => Visibility::Restricted(tcx.map.as_local_node_id(def.def_id()).unwrap()),\n             },\n             hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n         }\n@@ -2249,34 +2247,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_expr(self, expr: &hir::Expr) -> Def {\n-        match self.def_map.borrow().get(&expr.id) {\n-            Some(def) => def.full_def(),\n-            None => {\n-                span_bug!(expr.span, \"no def-map entry for expr {}\", expr.id);\n-            }\n-        }\n-    }\n-\n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(..) => {\n-                // We can't use resolve_expr here, as this needs to run on broken\n-                // programs. We don't need to through - associated items are all\n-                // rvalues.\n-                match self.def_map.borrow().get(&expr.id) {\n-                    Some(&def::PathResolution {\n-                        base_def: Def::Static(..), ..\n-                    }) | Some(&def::PathResolution {\n-                        base_def: Def::Upvar(..), ..\n-                    }) | Some(&def::PathResolution {\n-                        base_def: Def::Local(..), ..\n-                    }) => {\n-                        true\n-                    }\n-                    Some(&def::PathResolution { base_def: Def::Err, .. })=> true,\n-                    Some(..) => false,\n-                    None => span_bug!(expr.span, \"no def for path {}\", expr.id)\n+                // This function can be used during type checking when not all paths are\n+                // fully resolved. Partially resolved paths in expressions can only legally\n+                // refer to associated items which are always rvalues.\n+                match self.expect_resolution(expr.id).base_def {\n+                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    _ => false,\n                 }\n             }\n \n@@ -2459,8 +2438,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn trait_ref_to_def_id(self, tr: &hir::TraitRef) -> DefId {\n-        self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n+    /// Returns a path resolution for node id if it exists, panics otherwise.\n+    pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n+        *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n+    }\n+\n+    /// Returns a fully resolved definition for node id if it exists, panics otherwise.\n+    pub fn expect_def(self, id: NodeId) -> Def {\n+        self.expect_resolution(id).full_def()\n+    }\n+\n+    /// Returns a fully resolved definition for node id if it exists, or none if no\n+    /// definition exists, panics on partial resolutions to catch errors.\n+    pub fn expect_def_or_none(self, id: NodeId) -> Option<Def> {\n+        self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n     }\n \n     pub fn def_key(self, id: DefId) -> ast_map::DefKey {"}, {"sha": "f183736b9ed577ad562d3143bdb06b7f5bf58c6e", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -245,8 +245,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n             let pat_ty = cx.tcx.pat_ty(p);\n             if let ty::TyEnum(edef, _) = pat_ty.sty {\n-                let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-                if let Some(Def::Local(..)) = def {\n+                if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n                     if edef.variants.iter().any(|variant|\n                         variant.name == name.node.unhygienize()\n                             && variant.kind() == VariantKind::Unit\n@@ -492,9 +491,8 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n             PatKind::Path(..) | PatKind::QPath(..) => {\n-                let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n-                match def {\n-                    Some(Def::AssociatedConst(did)) | Some(Def::Const(did)) => {\n+                match self.tcx.expect_def(pat.id) {\n+                    Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n@@ -788,7 +786,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     let pat = raw_pat(p);\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+            match cx.tcx.expect_def(pat.id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've \\\n                                          been rewritten\"),\n@@ -903,21 +901,19 @@ pub fn specialize<'a, 'b, 'tcx>(\n             Some(vec![dummy_pat; arity]),\n \n         PatKind::Path(..) => {\n-            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n-            match def {\n+            match cx.tcx.expect_def(pat_id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n-                _ => span_bug!(pat_span, \"specialize: unexpected \\\n+                def => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n             }\n         }\n \n         PatKind::TupleStruct(_, ref args, ddpos) => {\n-            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n-            match def {\n+            match cx.tcx.expect_def(pat_id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n@@ -944,10 +940,9 @@ pub fn specialize<'a, 'b, 'tcx>(\n         }\n \n         PatKind::Struct(_, ref pattern_fields, _) => {\n-            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = constructor.variant_for_adt(adt);\n-            let def_variant = adt.variant_of_def(def);\n+            let def_variant = adt.variant_of_def(cx.tcx.expect_def(pat_id));\n             if variant.did == def_variant.did {\n                 Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.name == sf.name) {"}, {"sha": "c3db252584cce28f864e4a5693d9f384d66080f5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::{self, InlinedItem};\n use rustc::traits;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n@@ -276,11 +276,11 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      .collect()), None),\n \n         hir::ExprCall(ref callee, ref args) => {\n-            let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n+            let def = tcx.expect_def(callee.id);\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n-               entry.insert(def);\n+               entry.insert(PathResolution::new(def));\n             }\n-            let path = match def.full_def() {\n+            let path = match def {\n                 Def::Struct(def_id) => def_to_path(tcx, def_id),\n                 Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n@@ -322,12 +322,9 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         hir::ExprPath(_, ref path) => {\n-            let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n-            match opt_def {\n-                Some(Def::Struct(..)) | Some(Def::Variant(..)) =>\n-                    PatKind::Path(path.clone()),\n-                Some(Def::Const(def_id)) |\n-                Some(Def::AssociatedConst(def_id)) => {\n+            match tcx.expect_def(expr.id) {\n+                Def::Struct(..) | Def::Variant(..) => PatKind::Path(path.clone()),\n+                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n@@ -714,21 +711,13 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n       }\n       hir::ExprPath(..) => {\n-          let opt_def = if let Some(def) = tcx.def_map.borrow().get(&e.id) {\n-              // After type-checking, def_map contains definition of the\n-              // item referred to by the path. During type-checking, it\n-              // can contain the raw output of path resolution, which\n-              // might be a partially resolved path.\n-              // FIXME: There's probably a better way to make sure we don't\n-              // panic here.\n-              if def.depth != 0 {\n-                  signal!(e, UnresolvedPath);\n-              }\n-              def.full_def()\n-          } else {\n-              signal!(e, NonConstPath);\n-          };\n-          match opt_def {\n+          // This function can be used before type checking when not all paths are fully resolved.\n+          // FIXME: There's probably a better way to make sure we don't panic here.\n+          let resolution = tcx.expect_resolution(e.id);\n+          if resolution.depth != 0 {\n+              signal!(e, UnresolvedPath);\n+          }\n+          match resolution.base_def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {"}, {"sha": "54e5824cbc78686f014c0f671c43fadb05b1f2da", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -276,7 +276,7 @@ impl LateLintPass for NonSnakeCase {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &PatKind::Binding(_, ref path1, _) = &p.node {\n             // Exclude parameter names from foreign functions (they have no `Def`)\n-            if cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def()).is_some() {\n+            if cx.tcx.expect_def_or_none(p.id).is_some() {\n                 self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n             }\n         }\n@@ -362,8 +362,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(ref path) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Some(Def::Const(..)) = cx.tcx.def_map.borrow().get(&p.id)\n-                                                                     .map(|d| d.full_def()) {\n+                if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n                     NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                           path.segments[0].name, path.span);\n                 }"}, {"sha": "2bd2997566e0dcf81b1fd38f4cc06be7908a54d4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -157,20 +157,11 @@ impl LintPass for NonShorthandFieldPatterns {\n \n impl LateLintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        let def_map = cx.tcx.def_map.borrow();\n-        if let PatKind::Struct(_, ref v, _) = pat.node {\n-            let field_pats = v.iter().filter(|fieldpat| {\n+        if let PatKind::Struct(_, ref field_pats, _) = pat.node {\n+            for fieldpat in field_pats {\n                 if fieldpat.node.is_shorthand {\n-                    return false;\n-                }\n-                let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n-                if let Some(def_id) = cx.tcx.map.opt_local_def_id(fieldpat.node.pat.id) {\n-                    def == Some(Def::Local(def_id, fieldpat.node.pat.id))\n-                } else {\n-                    false\n+                    continue;\n                 }\n-            });\n-            for fieldpat in field_pats {\n                 if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.unhygienize() == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n@@ -377,7 +368,7 @@ impl LateLintPass for MissingDoc {\n             hir::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n+                let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n@@ -780,11 +771,9 @@ impl LateLintPass for UnconditionalRecursion {\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.def_map\n-                       .borrow()\n-                       .get(&callee.id)\n-                       .map_or(false,\n-                               |def| def.def_id() == tcx.map.local_def_id(fn_id))\n+                    tcx.expect_def_or_none(callee.id).map_or(false, |def| {\n+                        def.def_id() == tcx.map.local_def_id(fn_id)\n+                    })\n                 }\n                 _ => false\n             }\n@@ -820,7 +809,9 @@ impl LateLintPass for UnconditionalRecursion {\n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n+                    // The callee is an arbitrary expression,\n+                    // it doesn't necessarily have a definition.\n+                    match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n                             let item_substs = tcx.node_id_item_substs(callee.id);\n                             method_call_refers_to_method(\n@@ -1057,7 +1048,7 @@ impl LateLintPass for MutableTransmutes {\n                 hir::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let Def::Fn(did) = cx.tcx.resolve_expr(expr) {\n+            if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "78825aca4188e443caead4e22b74f922eaa3657f", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -719,7 +719,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    if let Some(def) = tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+    if let Some(def) = tcx.expect_def_or_none(id) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n             def.encode(rbml_w).unwrap();\n@@ -1133,10 +1133,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                 match value {\n                     c::tag_table_def => {\n                         let def = decode_def(dcx, val_dsr);\n-                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n-                            base_def: def,\n-                            depth: 0\n-                        });\n+                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);"}, {"sha": "47f94e5b3154923876b607bf3d70846630106c39", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -264,7 +264,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 let adt_data = if let hir::ExprPath(..) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n-                        match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n+                        match cx.tcx.expect_def(fun.id) {\n                             Def::Variant(_, variant_id) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n@@ -472,7 +472,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 }\n                 ty::TyEnum(adt, substs) => {\n-                    match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n+                    match cx.tcx.expect_def(expr.id) {\n                         Def::Variant(enum_id, variant_id) => {\n                             debug_assert!(adt.did == enum_id);\n                             assert!(base.is_none());\n@@ -675,7 +675,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      -> ExprKind<'tcx> {\n     let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n     // Otherwise there may be def_map borrow conflicts\n-    let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n+    let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function.\n         Def::Fn(def_id) | Def::Method(def_id) => def_id,\n@@ -731,14 +731,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             id: node_id,\n         },\n \n-        def @ Def::Local(..) |\n-        def @ Def::Upvar(..) => return convert_var(cx, expr, def),\n+        Def::Local(..) | Def::Upvar(..) => return convert_var(cx, expr, def),\n \n-        def =>\n-            span_bug!(\n-                expr.span,\n-                \"def `{:?}` not yet implemented\",\n-                def),\n+        _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n     };\n     ExprKind::Literal {\n         literal: Literal::Item { def_id: def_id, substs: substs }\n@@ -1039,11 +1034,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn loop_label<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                               expr: &'tcx hir::Expr) -> CodeExtent {\n-    match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-        Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n-        d => {\n-            span_bug!(expr.span, \"loop scope resolved to {:?}\", d);\n-        }\n+    match cx.tcx.expect_def(expr.id) {\n+        Def::Label(loop_id) => cx.tcx.region_maps.node_extent(loop_id),\n+        d => span_bug!(expr.span, \"loop scope resolved to {:?}\", d),\n     }\n }\n "}, {"sha": "c1f3dc1562395f00a50d4e31c4db7b7c3d350b3c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -85,8 +85,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             PatKind::Path(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n-                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-                match def {\n+                match self.cx.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.cx.tcx.global_tcx();\n                         let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n@@ -111,7 +110,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    _ =>\n+                    def =>\n                         span_bug!(\n                             pat.span,\n                             \"def not a constant: {:?}\",\n@@ -219,8 +218,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to struct or enum\"),\n                 };\n-                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-                let variant_def = adt_def.variant_of_def(def);\n+                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                         subpatterns.iter()\n@@ -243,9 +241,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             \"struct pattern not applied to struct or enum\");\n                     }\n                 };\n-\n-                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-                let variant_def = adt_def.variant_of_def(def);\n+                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                     fields.iter()\n@@ -324,8 +320,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                        pat: &hir::Pat,\n                        subpatterns: Vec<FieldPattern<'tcx>>)\n                        -> PatternKind<'tcx> {\n-        let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-        match def {\n+        match self.cx.tcx.expect_def(pat.id) {\n             Def::Variant(enum_id, variant_id) => {\n                 let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n@@ -343,7 +338,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            _ => {\n+            def => {\n                 span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n             }\n         }"}, {"sha": "774d19a06558bce5a884067e2af6f80fc38f1399", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -499,38 +499,36 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         hir::ExprPath(..) => {\n-            let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n-            match def {\n-                Some(Def::Variant(..)) => {\n+            match v.tcx.expect_def(e.id) {\n+                Def::Variant(..) => {\n                     // Count the discriminator or function pointer.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n-                Some(Def::Struct(..)) => {\n+                Def::Struct(..) => {\n                     if let ty::TyFnDef(..) = node_ty.sty {\n                         // Count the function pointer.\n                         v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n                 }\n-                Some(Def::Fn(..)) | Some(Def::Method(..)) => {\n+                Def::Fn(..) | Def::Method(..) => {\n                     // Count the function pointer.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n-                Some(Def::Static(..)) => {\n+                Def::Static(..) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n                         Mode::Const | Mode::ConstFn => {}\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n-                Some(Def::Const(did)) |\n-                Some(Def::AssociatedConst(did)) => {\n+                Def::Const(did) | Def::AssociatedConst(did) => {\n                     let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n                     if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     }\n                 }\n-                Some(Def::Local(..)) if v.mode == Mode::ConstFn => {\n+                Def::Local(..) if v.mode == Mode::ConstFn => {\n                     // Sadly, we can't determine whether the types are zero-sized.\n                     v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n                 }\n@@ -550,8 +548,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     _ => break\n                 };\n             }\n-            let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            let is_const = match def {\n+            // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n+            let is_const = match v.tcx.expect_def_or_none(callee.id) {\n                 Some(Def::Struct(..)) => true,\n                 Some(Def::Variant(..)) => {\n                     // Count the discriminator.\n@@ -586,8 +584,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         hir::ExprStruct(..) => {\n-            let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n-            if did == v.tcx.lang_items.unsafe_cell_type() {\n+            if v.tcx.expect_def(e.id).def_id() == v.tcx.lang_items.unsafe_cell_type().unwrap() {\n                 v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }"}, {"sha": "918c149ef8589e897df80d3e3829fd67f36446aa", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -65,7 +65,7 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n         if let hir::TyPath(..) = ty.node {\n-            match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n+            match self.tcx.expect_def(ty.id) {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     Some(AccessLevel::Public)\n                 }\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn trait_level(&self, trait_ref: &hir::TraitRef) -> Option<AccessLevel> {\n-        let did = self.tcx.trait_ref_to_def_id(trait_ref);\n+        let did = self.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n             self.get(node_id)\n         } else {\n@@ -317,7 +317,7 @@ impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n-            let def = self.ev.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n+            let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n                 Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n                 Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n@@ -343,7 +343,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n-        let def_id = self.ev.tcx.trait_ref_to_def_id(trait_ref);\n+        let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n             self.ev.update(item.id, Some(AccessLevel::Reachable));\n@@ -426,7 +426,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(self.tcx.resolve_expr(expr));\n+                let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n                 // (i.e. `all_fields - fields`), just check them all.\n@@ -436,7 +436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprPath(..) => {\n \n-                if let Def::Struct(..) = self.tcx.resolve_expr(expr) {\n+                if let Def::Struct(..) = self.tcx.expect_def(expr.id) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {\n                         ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n@@ -470,8 +470,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match pattern.node {\n             PatKind::Struct(_, ref fields, _) => {\n                 let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n-                let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n-                let variant = adt.variant_of_def(def);\n+                let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n                     self.check_field(pattern.span, adt, variant.field_named(field.node.name));\n                 }\n@@ -534,10 +533,9 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n-            // `int` etc. (None doesn't seem to occur.)\n-            None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => return false,\n-            Some(def) => def.def_id(),\n+        let did = match self.tcx.expect_def(path_id) {\n+            Def::PrimTy(..) | Def::SelfTy(..) => return false,\n+            def => def.def_id(),\n         };\n \n         // A path can only be private if:\n@@ -653,7 +651,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = self.tcx.trait_ref_to_def_id(tr);\n+                        let did = self.tcx.expect_def(tr.ref_id).def_id();\n \n                         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n                             self.trait_is_public(node_id)\n@@ -911,8 +909,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n-            let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n-            match def {\n+            match self.tcx.expect_def(ty.id) {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n@@ -962,7 +959,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n+        let def_id = self.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);"}, {"sha": "13a3d53d49766d629837497dbc3cbe9fdafe47dd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -1081,7 +1081,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n \n     fn record_resolution(&mut self, id: NodeId, def: Def) {\n-        self.def_map.insert(id, PathResolution { base_def: def, depth: 0 });\n+        self.def_map.insert(id, PathResolution::new(def));\n     }\n \n     fn definitions(&mut self) -> Option<&mut Definitions> {\n@@ -1674,7 +1674,7 @@ impl<'a> Resolver<'a> {\n                                                                    TypeNS) {\n                                 Ok(binding) => {\n                                     let def = binding.def().unwrap();\n-                                    self.record_def(item.id, PathResolution::new(def, 0));\n+                                    self.record_def(item.id, PathResolution::new(def));\n                                 }\n                                 Err(true) => self.record_def(item.id, err_path_resolution()),\n                                 Err(false) => {\n@@ -2239,15 +2239,19 @@ impl<'a> Resolver<'a> {\n                                        unexpected pattern source {:?}\", pat_src);\n             }\n             None => {\n-                // A completely fresh binding, add to the lists\n-                bindings_list.insert(renamed, outer_pat_id);\n+                // A completely fresh binding, add to the lists.\n+                // FIXME: Later stages are not ready to deal with `Def::Err` here yet, so\n+                // define `Invalid` bindings as `Def::Local`, just don't add them to the lists.\n                 let def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n-                self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n+                if ident.node.name != keywords::Invalid.name() {\n+                    bindings_list.insert(renamed, outer_pat_id);\n+                    self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n+                }\n                 def\n             }\n         };\n \n-        PathResolution { base_def: def, depth: 0 }\n+        PathResolution::new(def)\n     }\n \n     fn resolve_pattern_path<ExpectedFn>(&mut self,\n@@ -2316,11 +2320,6 @@ impl<'a> Resolver<'a> {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n                         match resolution.base_def {\n-                            // Def::Err => {\n-                            //     // Just pass it through, the error is already\n-                            //     // reported if it was necessary.\n-                            //     resolution\n-                            // }\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n                                 // A constant, unit variant, etc pattern.\n@@ -2417,7 +2416,7 @@ impl<'a> Resolver<'a> {\n                     // FIXME: Create some fake resolution that can't possibly be a type.\n                     return Some(PathResolution {\n                         base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len()\n+                        depth: path.segments.len(),\n                     });\n                 }\n                 max_assoc_types = path.segments.len() - qself.position;\n@@ -2457,7 +2456,7 @@ impl<'a> Resolver<'a> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n-        let mk_res = |def| PathResolution::new(def, path_depth);\n+        let mk_res = |def| PathResolution { base_def: def, depth: path_depth };\n \n         if path.global {\n             let binding = self.resolve_crate_relative_path(span, segments, namespace);\n@@ -2725,19 +2724,18 @@ impl<'a> Resolver<'a> {\n \n         if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n             // Look for a field with the same name in the current self_type.\n-            match self.def_map.get(&node_id).map(|d| d.full_def()) {\n-                Some(Def::Enum(did)) |\n-                Some(Def::TyAlias(did)) |\n-                Some(Def::Struct(did)) |\n-                Some(Def::Variant(_, did)) => match self.structs.get(&did) {\n-                    None => {}\n-                    Some(fields) => {\n-                        if fields.iter().any(|&field_name| name == field_name) {\n-                            return Field;\n+            if let Some(resolution) = self.def_map.get(&node_id) {\n+                match resolution.base_def {\n+                    Def::Enum(did) | Def::TyAlias(did) |\n+                    Def::Struct(did) | Def::Variant(_, did) if resolution.depth == 0 => {\n+                        if let Some(fields) = self.structs.get(&did) {\n+                            if fields.iter().any(|&field_name| name == field_name) {\n+                                return Field;\n+                            }\n                         }\n                     }\n-                },\n-                _ => {} // Self type didn't resolve properly\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -3000,11 +2998,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read.\n-                        self.record_def(expr.id,\n-                                        PathResolution {\n-                                            base_def: def,\n-                                            depth: 0,\n-                                        })\n+                        self.record_def(expr.id, PathResolution::new(def))\n                     }\n                     Some(_) => {\n                         span_bug!(expr.span, \"label wasn't mapped to a label def!\")\n@@ -3271,11 +3265,11 @@ impl<'a> Resolver<'a> {\n         };\n \n         let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n+        let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, path.span) {\n             Success(module) => {\n                 let def = module.def.unwrap();\n-                let path_resolution = PathResolution { base_def: def, depth: 0 };\n-                self.def_map.insert(id, path_resolution);\n+                path_resolution = PathResolution::new(def);\n                 ty::Visibility::Restricted(self.definitions.as_local_node_id(def.def_id()).unwrap())\n             }\n             Failed(Some((span, msg))) => {\n@@ -3287,6 +3281,7 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Public\n             }\n         };\n+        self.def_map.insert(id, path_resolution);\n         if !self.is_accessible(vis) {\n             let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n             self.session.span_err(path.span, &msg);\n@@ -3487,13 +3482,9 @@ fn module_to_string(module: Module) -> String {\n }\n \n fn err_path_resolution() -> PathResolution {\n-    PathResolution {\n-        base_def: Def::Err,\n-        depth: 0,\n-    }\n+    PathResolution::new(Def::Err)\n }\n \n-\n #[derive(PartialEq,Copy, Clone)]\n pub enum MakeGlobMap {\n     Yes,"}, {"sha": "3082a8b43076f24218f4c2c94a6a220a36818176", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             Some(def) => def,\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n-        let path_resolution = PathResolution { base_def: def, depth: 0 };\n+        let path_resolution = PathResolution::new(def);\n         self.resolver.def_map.insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -644,7 +644,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n-            let resolution = PathResolution { base_def: Def::Mod(did), depth: 0 };\n+            let resolution = PathResolution::new(Def::Mod(did));\n             self.resolver.def_map.insert(directive.id, resolution);\n         }\n "}, {"sha": "216d188a503e3a2b73477bea643c82b56191608d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -269,14 +269,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n-        }\n-        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n-        match def {\n+        match self.tcx.expect_def(ref_id) {\n             Def::PrimTy(..) => None,\n             Def::SelfTy(..) => None,\n-            _ => Some(def.def_id()),\n+            def => Some(def.def_id()),\n         }\n     }\n \n@@ -290,13 +286,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             return;\n         }\n \n-        let def_map = self.tcx.def_map.borrow();\n-        if !def_map.contains_key(&ref_id) {\n-            span_bug!(span,\n-                      \"def_map has no key for {} in lookup_def_kind\",\n-                      ref_id);\n-        }\n-        let def = def_map.get(&ref_id).unwrap().full_def();\n+        let def = self.tcx.expect_def(ref_id);\n         match def {\n             Def::Mod(_) |\n             Def::ForeignMod(_) => {\n@@ -853,9 +843,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n \n         // Modules or types in the path prefix.\n-        let def_map = self.tcx.def_map.borrow();\n-        let def = def_map.get(&id).unwrap().full_def();\n-        match def {\n+        match self.tcx.expect_def(id) {\n             Def::Method(did) => {\n                 let ti = self.tcx.impl_or_trait_item(did);\n                 if let ty::MethodTraitItem(m) = ti {\n@@ -924,8 +912,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n                 let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n-                let def = self.tcx.def_map.borrow()[&p.id].full_def();\n-                let variant = adt.variant_of_def(def);\n+                let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n@@ -1269,7 +1256,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n-                let def = self.tcx.resolve_expr(&hir_expr);\n+                let def = self.tcx.expect_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprKind::MethodCall(_, _, ref args) => self.process_method_call(ex, args),\n@@ -1366,12 +1353,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n \n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n-            let def_map = self.tcx.def_map.borrow();\n-            if !def_map.contains_key(&id) {\n-                span_bug!(p.span, \"def_map has no key for {} in visit_arm\", id);\n-            }\n-            let def = def_map.get(&id).unwrap().full_def();\n-            match def {\n+            match self.tcx.expect_def(id) {\n                 Def::Local(_, id) => {\n                     let value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n@@ -1401,8 +1383,8 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 Def::Static(_, _) |\n                 Def::Const(..) |\n                 Def::AssociatedConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            def),\n+                def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                              def),\n             }\n         }\n "}, {"sha": "27f15756a9130ec6f6c4e9a84556e8b93485a906", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -465,11 +465,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n-        let def_map = self.tcx.def_map.borrow();\n-        if !def_map.contains_key(&id) {\n-            span_bug!(path.span, \"def_map has no key for {} in visit_expr\", id);\n-        }\n-        let def = def_map.get(&id).unwrap().full_def();\n+        let def = self.tcx.expect_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n@@ -637,13 +633,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n-        }\n-        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n-        match def {\n+        match self.tcx.expect_def(ref_id) {\n             Def::PrimTy(_) | Def::SelfTy(..) => None,\n-            _ => Some(def.def_id()),\n+            def => Some(def.def_id()),\n         }\n     }\n "}, {"sha": "8ad1ba2a61418b554abd218c35ad362e4adc6fac", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -657,9 +657,8 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n             PatKind::Path(..) | PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n-                let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n-                match opt_def {\n-                    Some(Def::Variant(enum_id, var_id)) => {\n+                match tcx.expect_def(cur.id) {\n+                    Def::Variant(enum_id, var_id) => {\n                         let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n                         Variant(Disr::from(variant.disr_val),\n                                 adt::represent_node(bcx, cur.id),\n@@ -796,7 +795,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n         match pat.node {\n             PatKind::Tuple(..) => true,\n             PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n-                match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+                match tcx.expect_def(pat.id) {\n                     Def::Struct(..) | Def::TyAlias(..) => true,\n                     _ => false,\n                 }\n@@ -1444,19 +1443,19 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool {\n     let (vid, field) = match discr.node {\n-        hir::ExprPath(..) => match bcx.def(discr.id) {\n+        hir::ExprPath(..) => match bcx.tcx().expect_def(discr.id) {\n             Def::Local(_, vid) | Def::Upvar(_, vid, _, _) => (vid, None),\n             _ => return false\n         },\n         hir::ExprField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+            let vid = match bcx.tcx().expect_def_or_none(base.id) {\n                 Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node)))\n         },\n         hir::ExprTupField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+            let vid = match bcx.tcx().expect_def_or_none(base.id) {\n                 Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n@@ -1835,9 +1834,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         PatKind::TupleStruct(_, ref sub_pats, ddpos) => {\n-            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n-            match opt_def {\n-                Some(Def::Variant(enum_id, var_id)) => {\n+            match bcx.tcx().expect_def(pat.id) {\n+                Def::Variant(enum_id, var_id) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n@@ -1853,7 +1851,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             cleanup_scope);\n                     }\n                 }\n-                Some(Def::Struct(..)) => {\n+                Def::Struct(..) => {\n                     let expected_len = match *ccx.tcx().pat_ty(&pat) {\n                         ty::TyS{sty: ty::TyStruct(adt_def, _), ..} => {\n                             adt_def.struct_variant().fields.len()"}, {"sha": "6b8198881c83c61820236c76e2e7fc4e3066c0e3", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -260,8 +260,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n \n     /// Return the variant corresponding to a given node (e.g. expr)\n     pub fn of_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n-        let node_def = tcx.def_map.borrow().get(&id).map(|v| v.full_def());\n-        Self::from_ty(tcx, ty, node_def)\n+        Self::from_ty(tcx, ty, Some(tcx.expect_def(id)))\n     }\n \n     pub fn field_index(&self, name: ast::Name) -> usize {\n@@ -656,15 +655,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.tcx().map.node_to_string(id).to_string()\n     }\n \n-    pub fn def(&self, nid: ast::NodeId) -> Def {\n-        match self.tcx().def_map.borrow().get(&nid) {\n-            Some(v) => v.full_def(),\n-            None => {\n-                bug!(\"no def associated with node id {}\", nid);\n-            }\n-        }\n-    }\n-\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }"}, {"sha": "e988d2e6ac31482725ebd2eb47194be5c64a77f9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -297,8 +297,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // `def` must be its own statement and cannot be in the `match`\n         // otherwise the `def_map` will be borrowed for the entire match instead\n         // of just to get the `def` value\n-        let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n-        match def {\n+        match ccx.tcx().expect_def(expr.id) {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                     debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n@@ -803,8 +802,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     _ => break,\n                 }\n             }\n-            let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n-            if let Some(Def::Static(def_id, _)) = opt_def {\n+            if let Some(Def::Static(def_id, _)) = cx.tcx().expect_def_or_none(cur.id) {\n                 get_static(cx, def_id).val\n             } else {\n                 // If this isn't the address of a static, then keep going through\n@@ -891,8 +889,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         },\n         hir::ExprPath(..) => {\n-            let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n-            match def {\n+            match cx.tcx().expect_def(e.id) {\n                 Def::Local(_, id) => {\n                     if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n                         val\n@@ -937,9 +934,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     _ => break,\n                 };\n             }\n-            let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n             let arg_vals = map_list(args)?;\n-            match def {\n+            match cx.tcx().expect_def(callee.id) {\n                 Def::Fn(did) | Def::Method(did) => {\n                     const_fn_call(\n                         cx,"}, {"sha": "8845f124218bc437b3da19d2a9048be5c97eba88", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -318,8 +318,8 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n-                Some(Def::Label(loop_id)) => loop_id,\n+            match bcx.tcx().expect_def(expr.id) {\n+                Def::Label(loop_id) => loop_id,\n                 r => {\n                     bug!(\"{:?} in def-map for label\", r)\n                 }"}, {"sha": "652886ff2a0449a5d2c1f38e8571162484710a8d", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -153,7 +153,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // have side effects. This seems to be reached through tuple struct constructors being\n             // passed zero-size constants.\n             if let hir::ExprPath(..) = expr.node {\n-                match bcx.def(expr.id) {\n+                match bcx.tcx().expect_def(expr.id) {\n                     Def::Const(_) | Def::AssociatedConst(_) => {\n                         assert!(type_is_zero_size(bcx.ccx(), bcx.tcx().node_id_to_type(expr.id)));\n                         return bcx;\n@@ -172,7 +172,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // `[x; N]` somewhere within.\n             match expr.node {\n                 hir::ExprPath(..) => {\n-                    match bcx.def(expr.id) {\n+                    match bcx.tcx().expect_def(expr.id) {\n                         Def::Const(did) | Def::AssociatedConst(did) => {\n                             let empty_substs = bcx.tcx().mk_substs(Substs::empty());\n                             let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n@@ -651,7 +651,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans(bcx, &e)\n         }\n         hir::ExprPath(..) => {\n-            let var = trans_var(bcx, bcx.def(expr.id));\n+            let var = trans_var(bcx, bcx.tcx().expect_def(expr.id));\n             DatumBlock::new(bcx, var.to_expr_datum())\n         }\n         hir::ExprField(ref base, name) => {\n@@ -1073,7 +1073,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_into(bcx, &e, dest)\n         }\n         hir::ExprPath(..) => {\n-            trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n+            trans_def_dps_unadjusted(bcx, expr, bcx.tcx().expect_def(expr.id), dest)\n         }\n         hir::ExprIf(ref cond, ref thn, ref els) => {\n             controlflow::trans_if(bcx, expr.id, &cond, &thn, els.as_ref().map(|e| &**e), dest)\n@@ -2373,7 +2373,7 @@ fn expr_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, expr: &hir::Expr) -> ExprKin\n \n     match expr.node {\n         hir::ExprPath(..) => {\n-            match tcx.resolve_expr(expr) {\n+            match tcx.expect_def(expr.id) {\n                 // Put functions and ctors with the ADTs, as they\n                 // are zero-sized, so DPS is the cheapest option.\n                 Def::Struct(..) | Def::Variant(..) |"}, {"sha": "350ebf201653cd931611476abbadd86be356d370", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -734,7 +734,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n-        match ::lookup_full_def(self.tcx(), path.span, trait_ref.ref_id) {\n+        match self.tcx().expect_def(trait_ref.ref_id) {\n             Def::Trait(trait_def_id) => trait_def_id,\n             Def::Err => {\n                 self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n@@ -1064,12 +1064,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         match ty.node {\n             hir::TyPath(None, ref path) => {\n-                let def = match self.tcx().def_map.borrow().get(&ty.id) {\n-                    Some(&def::PathResolution { base_def, depth: 0, .. }) => Some(base_def),\n-                    _ => None\n-                };\n-                match def {\n-                    Some(Def::Trait(trait_def_id)) => {\n+                let resolution = self.tcx().expect_resolution(ty.id);\n+                match resolution.base_def {\n+                    Def::Trait(trait_def_id) if resolution.depth == 0 => {\n                         let mut projection_bounds = Vec::new();\n                         let trait_ref =\n                             self.object_path_to_poly_trait_ref(rscope,\n@@ -1721,11 +1718,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n-                let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n-                    d\n-                } else {\n-                    span_bug!(ast_ty.span, \"unbound path {:?}\", ast_ty)\n-                };\n+                let path_res = tcx.expect_resolution(ast_ty.id);\n                 let def = path_res.base_def;\n                 let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n@@ -1742,10 +1735,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 if path_res.depth != 0 && ty.sty != ty::TyError {\n                     // Write back the new resolution.\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n-                        base_def: def,\n-                        depth: 0\n-                    });\n+                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution::new(def));\n                 }\n \n                 ty\n@@ -2226,7 +2216,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n+                match tcx.expect_def(b.trait_ref.ref_id) {\n                     Def::Trait(trait_did) => {\n                         if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {"}, {"sha": "ce8ac2a8dbcd322c82c47f6aef19894a8057c4ed", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -150,24 +150,20 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n             PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-                if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n-                    let const_did = pat_def.def_id();\n-                    let const_scheme = tcx.lookup_item_type(const_did);\n-                    assert!(const_scheme.generics.is_empty());\n-                    let const_ty = self.instantiate_type_scheme(pat.span,\n-                                                                &Substs::empty(),\n-                                                                &const_scheme.ty);\n-                    self.write_ty(pat.id, const_ty);\n-\n-                    // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-                    // As with PatKind::Lit, what we really want here is that there\n-                    // exist a LUB, but for the cases that can occur, subtype\n-                    // is good enough.\n-                    self.demand_suptype(pat.span, expected, const_ty);\n-                } else {\n-                    self.write_error(pat.id);\n-                }\n+                let const_did = tcx.expect_def(pat.id).def_id();\n+                let const_scheme = tcx.lookup_item_type(const_did);\n+                assert!(const_scheme.generics.is_empty());\n+                let const_ty = self.instantiate_type_scheme(pat.span,\n+                                                            &Substs::empty(),\n+                                                            &const_scheme.ty);\n+                self.write_ty(pat.id, const_ty);\n+\n+                // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+                // As with PatKind::Lit, what we really want here is that there\n+                // exist a LUB, but for the cases that can occur, subtype\n+                // is good enough.\n+                self.demand_suptype(pat.span, expected, const_ty);\n             }\n             PatKind::Binding(bm, ref path, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n@@ -217,18 +213,12 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n             PatKind::QPath(ref qself, ref path) => {\n                 let self_ty = self.to_ty(&qself.ty);\n-                let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n-                    if d.base_def == Def::Err {\n-                        self.set_tainted_by_errors();\n-                        self.write_error(pat.id);\n-                        return;\n-                    }\n-                    d\n-                } else {\n-                    debug!(\"unbound path {:?}\", pat);\n+                let path_res = tcx.expect_resolution(pat.id);\n+                if path_res.base_def == Def::Err {\n+                    self.set_tainted_by_errors();\n                     self.write_error(pat.id);\n                     return;\n-                };\n+                }\n                 if let Some((opt_ty, segments, def)) =\n                         self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n                                                      path, pat.span, pat.id) {\n@@ -582,7 +572,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                             etc: bool, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n \n-        let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+        let def = tcx.expect_def(pat.id);\n         let variant = match self.def_struct_variant(def, path.span) {\n             Some((_, variant)) => variant,\n             None => {\n@@ -623,18 +613,16 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n         // Typecheck the path.\n         let tcx = self.tcx;\n \n-        let path_res = match tcx.def_map.borrow().get(&pat.id) {\n-            Some(&path_res) if path_res.base_def != Def::Err => path_res,\n-            _ => {\n-                self.set_tainted_by_errors();\n-                self.write_error(pat.id);\n+        let path_res = tcx.expect_resolution(pat.id);\n+        if path_res.base_def == Def::Err {\n+            self.set_tainted_by_errors();\n+            self.write_error(pat.id);\n \n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n-                return;\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err);\n             }\n-        };\n+            return;\n+        }\n \n         let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n                                                                          None, path,"}, {"sha": "58abf8db2c33d0c909b9696c8f6218b8bc291a28", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let tcx = self.tcx;\n                     if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n                         if pr.depth == 0 && pr.base_def != Def::Err {\n-                            if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n+                            if let Some(span) = tcx.map.span_if_local(pr.base_def.def_id()) {\n                                 err.span_note(span, \"defined here\");\n                             }\n                         }"}, {"sha": "5deef3bc19b9980f523170820d3a17e1dfc29dd2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -102,7 +102,7 @@ use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::{Session, CompileResult};\n-use {CrateCtxt, lookup_full_def};\n+use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n@@ -3158,7 +3158,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n \n         // Find the relevant variant\n-        let def = lookup_full_def(tcx, path.span, expr.id);\n+        let def = tcx.expect_def(expr.id);\n         if def == Def::Err {\n             self.set_tainted_by_errors();\n             self.check_struct_fields_on_error(expr.id, fields, base_expr);\n@@ -3350,12 +3350,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   self.to_ty(&qself.ty)\n               });\n \n-              let path_res = if let Some(&d) = tcx.def_map.borrow().get(&id) {\n-                  d\n-              } else {\n-                  span_bug!(expr.span, \"unbound path {:?}\", expr)\n-              };\n-\n+              let path_res = tcx.expect_resolution(id);\n               if let Some((opt_ty, segments, def)) =\n                       self.resolve_ty_and_def_ufcs(path_res, opt_self_ty, path,\n                                                    expr.span, expr.id) {\n@@ -3746,10 +3741,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(def) = def {\n                 // Write back the new resolution.\n-                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution {\n-                    base_def: def,\n-                    depth: 0,\n-                });\n+                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution::new(def));\n                 Some((Some(ty), slice::ref_slice(item_segment), def))\n             } else {\n                 self.write_error(node_id);\n@@ -4556,7 +4548,7 @@ pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n         if let hir::ExprBreak(Some(_)) = e.node {\n-            lookup_full_def(tcx, e.span, e.id) == Def::Label(id)\n+            tcx.expect_def(e.id) == Def::Label(id)\n         } else {\n             false\n         }"}, {"sha": "586c4f5c1858de3973ad5d519da0acdb246f9775", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -532,17 +532,13 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       -> bool\n {\n     if let hir::TyPath(None, _) = ast_ty.node {\n-        let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n+        let path_res = tcx.expect_resolution(ast_ty.id);\n         match path_res.base_def {\n-            Def::SelfTy(Some(def_id), None) => {\n-                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n-            }\n-            Def::TyParam(_, _, def_id, _) => {\n-                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n-            }\n-            _ => {\n-                false\n+            Def::SelfTy(Some(def_id), None) |\n+            Def::TyParam(_, _, def_id, _) if path_res.depth == 0 => {\n+                def_id == tcx.map.local_def_id(param_id)\n             }\n+            _ => false\n         }\n     } else {\n         false\n@@ -1719,7 +1715,7 @@ fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = tcx.trait_ref_to_def_id(tpb);\n+            let trait_def_id = tcx.expect_def(tpb.ref_id).def_id();\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n                     tcx.sess.span_warn(span,"}, {"sha": "7017cb9f6a22b0b61b27e5f371616edd6523b0f9", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -4125,7 +4125,7 @@ register_diagnostics! {\n //  E0239, // `next` method of `Iterator` trait has unexpected type\n //  E0240,\n //  E0241,\n-    E0242, // internal error looking up a definition\n+//  E0242,\n     E0245, // not a trait\n //  E0246, // invalid recursive type\n //  E0247,"}, {"sha": "c6c575719c0158b2d8889a4da4eb2477780dea3b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -103,7 +103,6 @@ pub use rustc::util;\n \n use dep_graph::DepNode;\n use hir::map as hir_map;\n-use hir::def::Def;\n use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -176,15 +175,6 @@ fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn lookup_full_def(tcx: TyCtxt, sp: Span, id: ast::NodeId) -> Def {\n-    match tcx.def_map.borrow().get(&id) {\n-        Some(x) => x.full_def(),\n-        None => {\n-            span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n-        }\n-    }\n-}\n-\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,"}, {"sha": "e49b96cbfd02ef9e98f0f539c9fc9ec62081d305", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -50,8 +50,8 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n         Some(tcx) => tcx,\n         None => return None,\n     };\n-    let def = match tcx.def_map.borrow().get(&id) {\n-        Some(d) => d.full_def(),\n+    let def = match tcx.expect_def_or_none(id) {\n+        Some(def) => def,\n         None => return None,\n     };\n     let did = def.def_id();"}, {"sha": "14ca63403163c85c0fb258dc875a6ad47c0e3560", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -2631,7 +2631,7 @@ fn resolve_type(cx: &DocContext,\n             };\n         }\n     };\n-    let def = tcx.def_map.borrow().get(&id).expect(\"unresolved id not in defmap\").full_def();\n+    let def = tcx.expect_def(id);\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n@@ -2700,7 +2700,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().get(&id).map(|d| register_def(cx, d.full_def()))\n+        tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n     })\n }\n "}, {"sha": "c7b571c2d1911438e3b33b647dceb0b6cf8b50d9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4e55398b39509bde4cc4983d615dbde406355c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ee4e55398b39509bde4cc4983d615dbde406355c", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = tcx.def_map.borrow()[&id];\n+        let def = tcx.expect_def(id);\n         let def_did = def.def_id();\n \n         let use_attrs = tcx.map.attrs(id).clean(self.cx);\n@@ -251,10 +251,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // reachable in documentation - a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront)\n-        if !def.def_id().is_local() && !is_no_inline {\n+        if !def_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, tcx, def_did);\n             let self_is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n-            match def.base_def {\n+            match def {\n                 Def::Trait(did) |\n                 Def::Struct(did) |\n                 Def::Enum(did) |"}]}