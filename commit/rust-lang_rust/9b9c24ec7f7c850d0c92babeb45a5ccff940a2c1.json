{"sha": "9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "node_id": "C_kwDOAAsO6NoAKDliOWMyNGVjN2Y3Yzg1MGQwYzkyYmFiZWI0NWE1Y2NmZjk0MGEyYzE", "commit": {"author": {"name": "John Kugelman", "email": "john@kugelman.name", "date": "2021-09-22T01:14:32Z"}, "committer": {"name": "John Kugelman", "email": "john@kugelman.name", "date": "2021-09-22T04:54:27Z"}, "message": "Fix read_to_end to not grow an exact size buffer\n\nIf you know how much data to expect and use `Vec::with_capacity` to\npre-allocate a buffer of that capacity, `Read::read_to_end` will still\ndouble its capacity. It needs some space to perform a read, even though\nthat read ends up returning `0`.\n\nIt's a bummer to carefully pre-allocate 1GB to read a 1GB file into\nmemory and end up using 2GB.\n\nThis fixes that behavior by special casing a full buffer and reading\ninto a small \"probe\" buffer instead. If that read returns `0` then it's\nconfirmed that the buffer was the perfect size. If it doesn't, the probe\nbuffer is appended to the normal buffer and the read loop continues.\n\nFixing this allows several workarounds in the standard library to be\nremoved:\n\n- `Take` no longer needs to override `Read::read_to_end`.\n- The `reservation_size` callback that allowed `Take` to inhibit the\n  previous over-allocation behavior isn't needed.\n- `fs::read` doesn't need to reserve an extra byte in\n  `initial_buffer_size`.\n\nCuriously, there was a unit test that specifically checked that\n`Read::read_to_end` *does* over-allocate. I removed that test, too.", "tree": {"sha": "1f6f7db6e75a35d9699a131590ad6938f399adcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f6f7db6e75a35d9699a131590ad6938f399adcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "html_url": "https://github.com/rust-lang/rust/commit/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/comments", "author": {"login": "jkugelman", "id": 4551859, "node_id": "MDQ6VXNlcjQ1NTE4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4551859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkugelman", "html_url": "https://github.com/jkugelman", "followers_url": "https://api.github.com/users/jkugelman/followers", "following_url": "https://api.github.com/users/jkugelman/following{/other_user}", "gists_url": "https://api.github.com/users/jkugelman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkugelman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkugelman/subscriptions", "organizations_url": "https://api.github.com/users/jkugelman/orgs", "repos_url": "https://api.github.com/users/jkugelman/repos", "events_url": "https://api.github.com/users/jkugelman/events{/privacy}", "received_events_url": "https://api.github.com/users/jkugelman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jkugelman", "id": 4551859, "node_id": "MDQ6VXNlcjQ1NTE4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4551859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkugelman", "html_url": "https://github.com/jkugelman", "followers_url": "https://api.github.com/users/jkugelman/followers", "following_url": "https://api.github.com/users/jkugelman/following{/other_user}", "gists_url": "https://api.github.com/users/jkugelman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkugelman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkugelman/subscriptions", "organizations_url": "https://api.github.com/users/jkugelman/orgs", "repos_url": "https://api.github.com/users/jkugelman/repos", "events_url": "https://api.github.com/users/jkugelman/events{/privacy}", "received_events_url": "https://api.github.com/users/jkugelman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7743c9fadd64886d537966ba224b9c20e6014a59", "url": "https://api.github.com/repos/rust-lang/rust/commits/7743c9fadd64886d537966ba224b9c20e6014a59", "html_url": "https://github.com/rust-lang/rust/commit/7743c9fadd64886d537966ba224b9c20e6014a59"}], "stats": {"total": 78, "additions": 37, "deletions": 41}, "files": [{"sha": "bcc1f9a8b94dda77e4ea406d3d1d662b1b1549b1", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "patch": "@@ -200,10 +200,9 @@ pub struct DirBuilder {\n \n /// Indicates how large a buffer to pre-allocate before reading the entire file.\n fn initial_buffer_size(file: &File) -> usize {\n-    // Allocate one extra byte so the buffer doesn't need to grow before the\n-    // final `read` call at the end of the file.  Don't worry about `usize`\n-    // overflow because reading will fail regardless in that case.\n-    file.metadata().map(|m| m.len() as usize + 1).unwrap_or(0)\n+    // Don't worry about `usize` overflow because reading will fail regardless\n+    // in that case.\n+    file.metadata().map(|m| m.len() as usize).unwrap_or(0)\n }\n \n /// Read the entire contents of a file into a bytes vector."}, {"sha": "52b04680745c9a73d7b2fa98db2b1719e0ac1c98", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "patch": "@@ -362,22 +362,18 @@ where\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    read_to_end_with_reservation(r, buf, |_| 32)\n-}\n-\n-fn read_to_end_with_reservation<R, F>(\n-    r: &mut R,\n-    buf: &mut Vec<u8>,\n-    mut reservation_size: F,\n-) -> Result<usize>\n-where\n-    R: Read + ?Sized,\n-    F: FnMut(&R) -> usize,\n-{\n     let start_len = buf.len();\n+    let start_cap = buf.capacity();\n     let mut g = Guard { len: buf.len(), buf };\n     loop {\n-        if g.len == g.buf.len() {\n+        // If we've read all the way up to the capacity, reserve more space.\n+        if g.len == g.buf.capacity() {\n+            g.buf.reserve(32);\n+        }\n+\n+        // Initialize any excess capacity and adjust the length so we can write\n+        // to it.\n+        if g.buf.len() < g.buf.capacity() {\n             unsafe {\n                 // FIXME(danielhenrymantilla): #42788\n                 //\n@@ -387,7 +383,6 @@ where\n                 //   - Only the standard library gets to soundly \"ignore\" this,\n                 //     based on its privileged knowledge of unstable rustc\n                 //     internals;\n-                g.buf.reserve(reservation_size(r));\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -404,9 +399,30 @@ where\n                 assert!(n <= buf.len());\n                 g.len += n;\n             }\n-            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         }\n+\n+        if g.len == g.buf.capacity() && g.buf.capacity() == start_cap {\n+            // The buffer might be an exact fit. Let's read into a probe buffer\n+            // and see if it returns `Ok(0)`. If so, we've avoided an\n+            // unnecessary doubling of the capacity. But if not, append the\n+            // probe buffer to the primary buffer and let its capacity grow.\n+            let mut probe = [0u8; 32];\n+\n+            loop {\n+                match r.read(&mut probe) {\n+                    Ok(0) => return Ok(g.len - start_len),\n+                    Ok(n) => {\n+                        g.buf.extend_from_slice(&probe[..n]);\n+                        g.len += n;\n+                        break;\n+                    }\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -2583,13 +2599,6 @@ impl<T: Read> Read for Take<T> {\n     unsafe fn initializer(&self) -> Initializer {\n         self.inner.initializer()\n     }\n-\n-    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        // Pass in a reservation_size closure that respects the current value\n-        // of limit for each read. If we hit the read limit, this prevents the\n-        // final zero-byte read from allocating again.\n-        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "58b2d1d14c9279cc9f8aabe1e1bb26c0269c1388", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=9b9c24ec7f7c850d0c92babeb45a5ccff940a2c1", "patch": "@@ -362,24 +362,12 @@ impl<'a> Read for ExampleSliceReader<'a> {\n fn test_read_to_end_capacity() -> io::Result<()> {\n     let input = &b\"foo\"[..];\n \n-    // read_to_end() generally needs to over-allocate, both for efficiency\n-    // and so that it can distinguish EOF. Assert that this is the case\n-    // with this simple ExampleSliceReader struct, which uses the default\n-    // implementation of read_to_end. Even though vec1 is allocated with\n-    // exactly enough capacity for the read, read_to_end will allocate more\n-    // space here.\n+    // read_to_end() takes care not to over-allocate when a buffer is the\n+    // exact size needed.\n     let mut vec1 = Vec::with_capacity(input.len());\n     ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n     assert_eq!(vec1.len(), input.len());\n-    assert!(vec1.capacity() > input.len(), \"allocated more\");\n-\n-    // However, std::io::Take includes an implementation of read_to_end\n-    // that will not allocate when the limit has already been reached. In\n-    // this case, vec2 never grows.\n-    let mut vec2 = Vec::with_capacity(input.len());\n-    ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n-    assert_eq!(vec2.len(), input.len());\n-    assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+    assert_eq!(vec1.capacity(), input.len(), \"did not allocate more\");\n \n     Ok(())\n }"}]}