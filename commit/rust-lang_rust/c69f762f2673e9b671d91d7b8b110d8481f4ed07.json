{"sha": "c69f762f2673e9b671d91d7b8b110d8481f4ed07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OWY3NjJmMjY3M2U5YjY3MWQ5MWQ3YjhiMTEwZDg0ODFmNGVkMDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-21T13:15:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-21T13:15:12Z"}, "message": "Merge #9356\n\n9356: internal: Move out and regroup more completion tests r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e2d812e08875ef8d1f123e549c8269544bb9842c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2d812e08875ef8d1f123e549c8269544bb9842c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c69f762f2673e9b671d91d7b8b110d8481f4ed07", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg0JDgCRBK7hj4Ov3rIwAAaU4IACuZ0Mr2Y1G3PsMXNqsYln27\nszt/zteJuGoNVIo+Q16Ks+hz6y6WKcgmyGepdayWIOExxQf/toupbEImzlb3uwC7\n1pujVoBDf5PVoF8lXJYMGJJuzuYF7AzrNFJ19RLJU1C58htlA8AHSq33KYXDyiV7\n5r3f38xEGdrcktdqhA3JhT62V5XBxe349AFC5l82EpWwqGRazh/9YTy5klTagXxp\nCRRoO7mFaqFzMcAZSxgz+ufXpDDX9KHX+BO9YCe6fxc0xvb3uRYHAnOvR02uFqR6\nRrG3gyzBeJYY6mnRjwVMvowi/npiF4Su3rIu0zspgVRo1IfgMgPqZnvPh42KWm4=\n=k0hZ\n-----END PGP SIGNATURE-----\n", "payload": "tree e2d812e08875ef8d1f123e549c8269544bb9842c\nparent 488c9ef9c0c04e0afa291164db5d115d5515b00d\nparent 0729913525a55cad3ffe9876c1eb05f7b880d22d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624281312 +0000\ncommitter GitHub <noreply@github.com> 1624281312 +0000\n\nMerge #9356\n\n9356: internal: Move out and regroup more completion tests r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c69f762f2673e9b671d91d7b8b110d8481f4ed07", "html_url": "https://github.com/rust-lang/rust/commit/c69f762f2673e9b671d91d7b8b110d8481f4ed07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c69f762f2673e9b671d91d7b8b110d8481f4ed07/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488c9ef9c0c04e0afa291164db5d115d5515b00d", "url": "https://api.github.com/repos/rust-lang/rust/commits/488c9ef9c0c04e0afa291164db5d115d5515b00d", "html_url": "https://github.com/rust-lang/rust/commit/488c9ef9c0c04e0afa291164db5d115d5515b00d"}, {"sha": "0729913525a55cad3ffe9876c1eb05f7b880d22d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0729913525a55cad3ffe9876c1eb05f7b880d22d", "html_url": "https://github.com/rust-lang/rust/commit/0729913525a55cad3ffe9876c1eb05f7b880d22d"}], "stats": {"total": 1234, "additions": 557, "deletions": 677}, "files": [{"sha": "407f796efe4282c7c593210d1a3171ccb806e792", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     if !ctx.has_visibility_prev_sibling()\n-        && (expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_record_field())\n+        && (expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_field())\n     {\n         add_keyword(\"pub(crate)\", \"pub(crate) \");\n         add_keyword(\"pub\", \"pub \");\n@@ -122,6 +122,10 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n     }\n \n+    if ctx.expects_type() {\n+        return;\n+    }\n+\n     if ctx.expects_expression() {\n         if !has_block_expr_parent {\n             add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n@@ -372,28 +376,6 @@ fn quux() -> i32 {\n         );\n     }\n \n-    #[test]\n-    fn test_mut_in_ref_and_in_fn_parameters_list() {\n-        check(\n-            r\"fn my_fn(&$0) {}\",\n-            expect![[r#\"\n-                kw mut\n-            \"#]],\n-        );\n-        check(\n-            r\"fn my_fn($0) {}\",\n-            expect![[r#\"\n-                kw mut\n-            \"#]],\n-        );\n-        check(\n-            r\"fn my_fn() { let &$0 }\",\n-            expect![[r#\"\n-                kw mut\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn no_keyword_completion_in_comments() {\n         cov_mark::check!(no_keyword_completion_in_comments);"}, {"sha": "bd13a62d7571e953d4bb6ef5fb83343f45939855", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -55,398 +55,3 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     });\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{\n-        tests::{check_edit, filtered_completion_list},\n-        CompletionKind,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Reference);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    fn check_snippet(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Snippet);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    #[test]\n-    fn completes_enum_variants_and_modules() {\n-        check(\n-            r#\"\n-enum E { X }\n-use self::E::X;\n-const Z: E = E::X;\n-mod m {}\n-\n-static FOO: E = E::X;\n-struct Bar { f: u32 }\n-\n-fn foo() {\n-   match E::X { a$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                en E\n-                ct Z\n-                st Bar\n-                ev X\n-                md m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_complete_non_fn_macros() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-enum E { X }\n-\n-#[rustc_builtin_macro]\n-macro Clone {}\n-\n-fn foo() {\n-   match E::X { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev E::X  ()\n-                en E\n-                ma m!(\u2026) macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_call() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-enum E { X }\n-\n-fn foo() {\n-   m!(match E::X { a$0 })\n-}\n-\"#,\n-            expect![[r#\"\n-                ev E::X  ()\n-                en E\n-                ma m!(\u2026) macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_irrefutable_let() {\n-        check(\n-            r#\"\n-enum E { X }\n-use self::E::X;\n-const Z: E = E::X;\n-mod m {}\n-\n-static FOO: E = E::X;\n-struct Bar { f: u32 }\n-\n-fn foo() {\n-   let a$0\n-}\n-\"#,\n-            expect![[r#\"\n-                st Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_param() {\n-        check(\n-            r#\"\n-enum E { X }\n-\n-static FOO: E = E::X;\n-struct Bar { f: u32 }\n-\n-fn foo(a$0) {\n-}\n-\"#,\n-            expect![[r#\"\n-                st Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_pat_in_let() {\n-        check_snippet(\n-            r#\"\n-struct Bar { f: u32 }\n-\n-fn foo() {\n-   let a$0\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Bar Bar { f$1 }$0\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_param_pattern() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: String, baz: String }\n-struct Bar(String, String);\n-struct Baz;\n-fn outer(a$0) {}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, baz$2 }: Foo$0\n-                bn Bar Bar($1, $2): Bar$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_let_pattern() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: String, baz: String }\n-struct Bar(String, String);\n-struct Baz;\n-fn outer() {\n-    let a$0\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, baz$2 }$0\n-                bn Bar Bar($1, $2)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_refutable_pattern() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: i32, baz: i32 }\n-struct Bar(String, String);\n-struct Baz;\n-fn outer() {\n-    match () {\n-        a$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, baz$2 }$0\n-                bn Bar Bar($1, $2)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn omits_private_fields_pat() {\n-        check_snippet(\n-            r#\"\n-mod foo {\n-    pub struct Foo { pub bar: i32, baz: i32 }\n-    pub struct Bar(pub String, String);\n-    pub struct Invisible(String, String);\n-}\n-use foo::*;\n-\n-fn outer() {\n-    match () {\n-        a$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1, .. }$0\n-                bn Bar Bar($1, ..)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn only_shows_ident_completion() {\n-        check_edit(\n-            \"Foo\",\n-            r#\"\n-struct Foo(i32);\n-fn main() {\n-    match Foo(92) {\n-        a$0(92) => (),\n-    }\n-}\n-\"#,\n-            r#\"\n-struct Foo(i32);\n-fn main() {\n-    match Foo(92) {\n-        Foo(92) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_self_pats() {\n-        check_snippet(\n-            r#\"\n-struct Foo(i32);\n-impl Foo {\n-    fn foo() {\n-        match () {\n-            a$0\n-        }\n-    }\n-}\n-    \"#,\n-            expect![[r#\"\n-                bn Self Self($1)$0\n-                bn Foo  Foo($1)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_qualified_variant() {\n-        check_snippet(\n-            r#\"\n-enum Foo {\n-    Bar { baz: i32 }\n-}\n-impl Foo {\n-    fn foo() {\n-        match {Foo::Bar { baz: 0 }} {\n-            B$0\n-        }\n-    }\n-}\n-    \"#,\n-            expect![[r#\"\n-                bn Self::Bar Self::Bar { baz$1 }$0\n-                bn Foo::Bar  Foo::Bar { baz$1 }$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_matcharm() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn main() {\n-    let foo = Foo::Quux;\n-    match foo { Qu$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_matcharm_ref() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn main() {\n-    let foo = Foo::Quux;\n-    match &foo { Qu$0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_iflet() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn main() {\n-    let foo = Foo::Quux;\n-    if let Qu$0 = foo { }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_impl() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-impl Foo {\n-    fn foo() { match Foo::Bar { Q$0 } }\n-}\n-\"#,\n-            expect![[r#\"\n-                ev Self::Bar  ()\n-                ev Self::Baz  ()\n-                ev Self::Quux ()\n-                ev Foo::Bar   ()\n-                ev Foo::Baz   ()\n-                ev Foo::Quux  ()\n-                sp Self\n-                en Foo\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_in_record_field_pat() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: Bar }\n-struct Bar(u32);\n-fn outer(Foo { bar: $0 }: Foo) {}\n-\"#,\n-            expect![[r#\"\n-                bn Foo Foo { bar$1 }$0\n-                bn Bar Bar($1)$0\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn skips_in_record_field_pat_name() {\n-        check_snippet(\n-            r#\"\n-struct Foo { bar: Bar }\n-struct Bar(u32);\n-fn outer(Foo { bar$0 }: Foo) {}\n-\"#,\n-            expect![[r#\"\"#]],\n-        )\n-    }\n-}"}, {"sha": "1b8997ecf37b9234d16181f616aa5ae6eb7a6095", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -218,36 +218,6 @@ mod tests {\n         expect.assert_eq(&actual);\n     }\n \n-    #[test]\n-    fn dont_complete_values_in_type_pos() {\n-        check(\n-            r#\"\n-const FOO: () = ();\n-static BAR: () = ();\n-struct Baz;\n-fn foo() {\n-    let _: self::$0;\n-}\n-\"#,\n-            expect![[r#\"\n-                st Baz\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_complete_enum_variants_in_type_pos() {\n-        check(\n-            r#\"\n-enum Foo { Bar }\n-fn foo() {\n-    let _: Foo::$0;\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n     #[test]\n     fn dont_complete_primitive_in_use() {\n         check_builtin(r#\"use self::$0;\"#, expect![[\"\"]]);\n@@ -258,32 +228,6 @@ fn foo() {\n         check_builtin(r#\"fn foo() { self::$0 }\"#, expect![[\"\"]]);\n     }\n \n-    #[test]\n-    fn completes_primitives() {\n-        check_builtin(\n-            r#\"fn main() { let _: $0 = 92; }\"#,\n-            expect![[r#\"\n-                bt u32\n-                bt bool\n-                bt u8\n-                bt isize\n-                bt u16\n-                bt u64\n-                bt u128\n-                bt f32\n-                bt i128\n-                bt i16\n-                bt str\n-                bt i64\n-                bt char\n-                bt f64\n-                bt i32\n-                bt i8\n-                bt usize\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_enum_variant() {\n         check(\n@@ -749,24 +693,4 @@ fn main() {\n             \"#]],\n         );\n     }\n-\n-    #[test]\n-    fn completes_types_and_const_in_arg_list() {\n-        check(\n-            r#\"\n-mod foo {\n-    pub const CONST: () = ();\n-    pub type Type = ();\n-}\n-\n-struct Foo<T>(t);\n-\n-fn foo(_: Foo<foo::$0>) {}\n-\"#,\n-            expect![[r#\"\n-                ta Type\n-                ct CONST\n-            \"#]],\n-        );\n-    }\n }"}, {"sha": "380c1e07977916d14e05742277be18601ea73e0e", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -112,78 +112,6 @@ mod tests {\n         expect.assert_eq(&actual)\n     }\n \n-    #[test]\n-    fn dont_complete_values_in_type_pos() {\n-        check(\n-            r#\"\n-const FOO: () = ();\n-static BAR: () = ();\n-enum Foo {\n-    Bar\n-}\n-struct Baz;\n-fn foo() {\n-    let local = ();\n-    let _: $0;\n-}\n-\"#,\n-            expect![[r#\"\n-                en Foo\n-                st Baz\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn bind_pat_and_path_ignore_at() {\n-        check(\n-            r#\"\n-enum Enum { A, B }\n-fn quux(x: Option<Enum>) {\n-    match x {\n-        None => (),\n-        Some(en$0 @ Enum::A) => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn bind_pat_and_path_ignore_ref() {\n-        check(\n-            r#\"\n-enum Enum { A, B }\n-fn quux(x: Option<Enum>) {\n-    match x {\n-        None => (),\n-        Some(ref en$0) => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn bind_pat_and_path() {\n-        check(\n-            r#\"\n-enum Enum { A, B }\n-fn quux(x: Option<Enum>) {\n-    match x {\n-        None => (),\n-        Some(En$0) => (),\n-    }\n-}\n-\"#,\n-            expect![[r#\"\n-                en Enum\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_bindings_from_let() {\n         check(\n@@ -288,29 +216,6 @@ fn main() {\n         );\n     }\n \n-    #[test]\n-    fn completes_generic_params_in_struct() {\n-        check(\n-            r#\"struct S<T> { x: $0}\"#,\n-            expect![[r#\"\n-                sp Self\n-                tp T\n-                st S<\u2026>\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_self_in_enum() {\n-        check(\n-            r#\"enum X { Y($0) }\"#,\n-            expect![[r#\"\n-                sp Self\n-                en X\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_module_items() {\n         check(\n@@ -364,19 +269,6 @@ mod m {\n         );\n     }\n \n-    #[test]\n-    fn completes_return_type() {\n-        check(\n-            r#\"\n-struct Foo;\n-fn x() -> $0\n-\"#,\n-            expect![[r#\"\n-                st Foo\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn dont_show_both_completions_for_shadowing() {\n         check(\n@@ -558,19 +450,6 @@ fn foo() { $0 }\n         );\n     }\n \n-    #[test]\n-    fn completes_macros_as_type() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-fn main() { let x: $0 }\n-\"#,\n-            expect![[r#\"\n-                ma foo!(\u2026) macro_rules! foo\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_macros_as_stmt() {\n         check(\n@@ -716,30 +595,4 @@ fn f() {}\n             expect![[\"\"]],\n         )\n     }\n-\n-    #[test]\n-    fn completes_types_and_const_in_arg_list() {\n-        check(\n-            r#\"\n-enum Bar {\n-    Baz\n-}\n-trait Foo {\n-    type Bar;\n-}\n-\n-const CONST: () = ();\n-\n-fn foo<T: Foo<$0>, const CONST_PARAM: usize>(_: T) {}\n-\"#,\n-            expect![[r#\"\n-                ta Bar =       type Bar;\n-                tp T\n-                cp CONST_PARAM\n-                tt Foo\n-                en Bar\n-                ct CONST\n-            \"#]],\n-        );\n-    }\n }"}, {"sha": "f0da98739fd30a43166f80dbcb3cd645bffc7530", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -286,8 +286,11 @@ impl<'a> CompletionContext<'a> {\n         )\n     }\n \n-    pub(crate) fn expect_record_field(&self) -> bool {\n-        matches!(self.completion_location, Some(ImmediateLocation::RecordField))\n+    pub(crate) fn expect_field(&self) -> bool {\n+        matches!(\n+            self.completion_location,\n+            Some(ImmediateLocation::RecordField | ImmediateLocation::TupleField)\n+        )\n     }\n \n     pub(crate) fn in_use_tree(&self) -> bool {"}, {"sha": "757c9a3daa394adf5d2405edd543e8f3467ce164", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -31,6 +31,7 @@ pub(crate) enum ImmediateLocation {\n     Impl,\n     Trait,\n     RecordField,\n+    TupleField,\n     RefExpr,\n     IdentPat,\n     BlockExpr,\n@@ -187,7 +188,13 @@ pub(crate) fn determine_location(\n             ast::SourceFile(_it) => ImmediateLocation::ItemList,\n             ast::ItemList(_it) => ImmediateLocation::ItemList,\n             ast::RefExpr(_it) => ImmediateLocation::RefExpr,\n-            ast::RecordField(_it) => ImmediateLocation::RecordField,\n+            ast::RecordField(it) => if it.ty().map_or(false, |it| it.syntax().text_range().contains(offset)) {\n+                return None;\n+            } else {\n+                ImmediateLocation::RecordField\n+            },\n+            ast::TupleField(_it) => ImmediateLocation::TupleField,\n+            ast::TupleFieldList(_it) => ImmediateLocation::TupleField,\n             ast::AssocItemList(it) => match it.syntax().parent().map(|it| it.kind()) {\n                 Some(IMPL) => ImmediateLocation::Impl,\n                 Some(TRAIT) => ImmediateLocation::Trait,"}, {"sha": "97298ff27d05e4bdf0ffbf7100a8794f510fc0eb", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -7,6 +7,10 @@\n mod item_list;\n mod use_tree;\n mod items;\n+mod pattern;\n+mod type_pos;\n+\n+use std::mem;\n \n use hir::{PrefixKind, Semantics};\n use ide_db::{\n@@ -45,7 +49,16 @@ pub(crate) fn completion_list(code: &str) -> String {\n }\n \n fn completion_list_with_config(config: CompletionConfig, code: &str) -> String {\n-    render_completion_list(get_all_items(config, code))\n+    // filter out all but one builtintype completion for smaller test outputs\n+    let items = get_all_items(config, code);\n+    let mut bt_seen = false;\n+    let items = items\n+        .into_iter()\n+        .filter(|it| {\n+            it.completion_kind != CompletionKind::BuiltinType || !mem::replace(&mut bt_seen, true)\n+        })\n+        .collect();\n+    render_completion_list(items)\n }\n \n /// Creates analysis from a multi-file fixture, returns positions marked with $0."}, {"sha": "b98baffd6cea47dd60ad7a65ddcb6b32a163cb77", "filename": "crates/ide_completion/src/tests/items.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitems.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -35,22 +35,6 @@ impl Tra$0\n             ma foo!(\u2026) #[macro_export] macro_rules! foo\n             ma foo!(\u2026) #[macro_export] macro_rules! foo\n             bt u32\n-            bt bool\n-            bt u8\n-            bt isize\n-            bt u16\n-            bt u64\n-            bt u128\n-            bt f32\n-            bt i128\n-            bt i16\n-            bt str\n-            bt i64\n-            bt char\n-            bt f64\n-            bt i32\n-            bt i8\n-            bt usize\n         \"##]],\n     )\n }\n@@ -69,22 +53,6 @@ impl Trait for Str$0\n             ma foo!(\u2026) #[macro_export] macro_rules! foo\n             ma foo!(\u2026) #[macro_export] macro_rules! foo\n             bt u32\n-            bt bool\n-            bt u8\n-            bt isize\n-            bt u16\n-            bt u64\n-            bt u128\n-            bt f32\n-            bt i128\n-            bt i16\n-            bt str\n-            bt i64\n-            bt char\n-            bt f64\n-            bt i32\n-            bt i8\n-            bt usize\n         \"##]],\n     )\n }"}, {"sha": "1ad5ccd97afa61d3b0f9746490e908c378fbaf60", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -0,0 +1,348 @@\n+//! Completions tests for pattern position.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::completion_list;\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n+fn check_with(ra_fixture: &str, expect: Expect) {\n+    let base = r#\"\n+enum Enum { TupleV(u32), RecordV { field: u32 }, UnitV }\n+use self::Enum::TupleV;\n+mod module {}\n+\n+static STATIC: Unit = Unit;\n+const CONST: Unit = Unit;\n+struct Record { field: u32 }\n+struct Tuple(u32);\n+struct Unit\n+macro_rules! makro {}\n+\"#;\n+    let actual = completion_list(&format!(\"{}\\n{}\", base, ra_fixture));\n+    expect.assert_eq(&actual)\n+}\n+\n+#[test]\n+fn ident_rebind_pat() {\n+    check(\n+        r#\"\n+fn quux() {\n+    let en$0 @ x\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn ident_ref_pat() {\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref en$0 @ x\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn ident_ref_mut_pat() {\n+    // FIXME mut is already here, don't complete it again\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref mut en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn quux() {\n+    let ref mut en$0 @ x\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn ref_pat() {\n+    check(\n+        r#\"\n+fn quux() {\n+    let &en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+    // FIXME mut is already here, don't complete it again\n+    check(\n+        r#\"\n+fn quux() {\n+    let &mut en$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn refutable() {\n+    check_with(\n+        r#\"\n+fn foo() {\n+    if let a$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1 }$0\n+            st Record\n+            en Enum\n+            bn Tuple     Tuple($1)$0\n+            st Tuple\n+            md module\n+            bn TupleV    TupleV($1)$0\n+            ev TupleV\n+            st Unit\n+            ct CONST\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn irrefutable() {\n+    check_with(\n+        r#\"\n+fn foo() {\n+   let a$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1 }$0\n+            st Record\n+            bn Tuple     Tuple($1)$0\n+            st Tuple\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_param() {\n+    check_with(\n+        r#\"\n+fn foo(a$0) {\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1 }: Record$0\n+            st Record\n+            bn Tuple     Tuple($1): Tuple$0\n+            st Tuple\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn only_fn_like_macros() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+\n+#[rustc_builtin_macro]\n+macro Clone {}\n+\n+fn foo() {\n+    let x$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            ma m!(\u2026) macro_rules! m\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_simple_macro_call() {\n+    check(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+enum E { X }\n+\n+fn foo() {\n+   m!(match E::X { a$0 })\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            ev E::X  ()\n+            en E\n+            ma m!(\u2026) macro_rules! m\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn omits_private_fields_pat() {\n+    check(\n+        r#\"\n+mod foo {\n+    pub struct Record { pub field: i32, _field: i32 }\n+    pub struct Tuple(pub u32, u32);\n+    pub struct Invisible(u32, u32);\n+}\n+use foo::*;\n+\n+fn outer() {\n+    if let a$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Record    Record { field$1, .. }$0\n+            st Record\n+            bn Tuple     Tuple($1, ..)$0\n+            st Tuple\n+            st Invisible\n+            md foo\n+        \"#]],\n+    )\n+}\n+\n+// #[test]\n+// fn only_shows_ident_completion() {\n+//     check_edit(\n+//         \"Foo\",\n+//         r#\"\n+// struct Foo(i32);\n+// fn main() {\n+//     match Foo(92) {\n+//         a$0(92) => (),\n+//     }\n+// }\n+// \"#,\n+//         r#\"\n+// struct Foo(i32);\n+// fn main() {\n+//     match Foo(92) {\n+//         Foo(92) => (),\n+//     }\n+// }\n+// \"#,\n+//     );\n+// }\n+\n+#[test]\n+fn completes_self_pats() {\n+    check(\n+        r#\"\n+struct Foo(i32);\n+impl Foo {\n+    fn foo() {\n+        match Foo(0) {\n+            a$0\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Self Self($1)$0\n+            sp Self\n+            bn Foo  Foo($1)$0\n+            st Foo\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_qualified_variant() {\n+    check(\n+        r#\"\n+enum Foo {\n+    Bar { baz: i32 }\n+}\n+impl Foo {\n+    fn foo() {\n+        match {Foo::Bar { baz: 0 }} {\n+            B$0\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Self::Bar Self::Bar { baz$1 }$0\n+            ev Self::Bar { baz: i32 }\n+            bn Foo::Bar  Foo::Bar { baz$1 }$0\n+            ev Foo::Bar  { baz: i32 }\n+            sp Self\n+            en Foo\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_in_record_field_pat() {\n+    check(\n+        r#\"\n+struct Foo { bar: Bar }\n+struct Bar(u32);\n+fn outer(Foo { bar: $0 }: Foo) {}\n+\"#,\n+        expect![[r#\"\n+            kw mut\n+            bn Foo Foo { bar$1 }$0\n+            st Foo\n+            bn Bar Bar($1)$0\n+            st Bar\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn skips_in_record_field_pat_name() {\n+    check(\n+        r#\"\n+struct Foo { bar: Bar }\n+struct Bar(u32);\n+fn outer(Foo { bar$0 }: Foo) {}\n+\"#,\n+        expect![[r#\"\"#]],\n+    )\n+}"}, {"sha": "1ab47b27e8516754576fb4bb2e41db2bbd2fb42e", "filename": "crates/ide_completion/src/tests/type_pos.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69f762f2673e9b671d91d7b8b110d8481f4ed07/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=c69f762f2673e9b671d91d7b8b110d8481f4ed07", "patch": "@@ -0,0 +1,177 @@\n+//! Completions tests for type position.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::completion_list;\n+\n+fn check_with(ra_fixture: &str, expect: Expect) {\n+    let base = r#\"\n+enum Enum { TupleV(u32), RecordV { field: u32 }, UnitV }\n+use self::Enum::TupleV;\n+mod module {}\n+\n+trait Trait {}\n+static STATIC: Unit = Unit;\n+const CONST: Unit = Unit;\n+struct Record { field: u32 }\n+struct Tuple(u32);\n+struct Unit\n+macro_rules! makro {}\n+\"#;\n+    let actual = completion_list(&format!(\"{}\\n{}\", base, ra_fixture));\n+    expect.assert_eq(&actual)\n+}\n+\n+#[test]\n+fn record_field_ty() {\n+    check_with(\n+        r#\"\n+struct Foo<'lt, T, const C: usize> {\n+    f: $0\n+}\n+\"#,\n+        expect![[r#\"\n+            sp Self\n+            tp T\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Foo<\u2026>\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn tuple_struct_field() {\n+    check_with(\n+        r#\"\n+struct Foo<'lt, T, const C: usize>(f$0);\n+\"#,\n+        expect![[r#\"\n+            kw pub(crate)\n+            kw pub\n+            sp Self\n+            tp T\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Foo<\u2026>\n+            st Unit\n+            ma makro!(\u2026)  macro_rules! makro\n+            bt u32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn fn_return_type() {\n+    check_with(\n+        r#\"\n+fn x<'lt, T, const C: usize>() -> $0\n+\"#,\n+        expect![[r#\"\n+            tp T\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn body_type_pos() {\n+    check_with(\n+        r#\"\n+fn foo<'lt, T, const C: usize>() {\n+    let local = ();\n+    let _: $0;\n+}\n+\"#,\n+        expect![[r#\"\n+            tp T\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+            ma makro!(\u2026) macro_rules! makro\n+            bt u32\n+        \"#]],\n+    );\n+    check_with(\n+        r#\"\n+fn foo<'lt, T, const C: usize>() {\n+    let local = ();\n+    let _: self::$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_types_and_const_in_arg_list() {\n+    // FIXME: we should complete the lifetime here for now\n+    check_with(\n+        r#\"\n+trait Trait2 {\n+    type Foo;\n+}\n+\n+fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n+\"#,\n+        expect![[r#\"\n+            ta Foo =       type Foo;\n+            tp T\n+            cp CONST_PARAM\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            tt Trait2\n+            md module\n+            st Unit\n+            ct CONST\n+            ma makro!(\u2026)   macro_rules! makro\n+            bt u32\n+        \"#]],\n+    );\n+    check_with(\n+        r#\"\n+trait Trait2 {\n+    type Foo;\n+}\n+\n+fn foo<'lt, T: Trait2<self::$0>, const CONST_PARAM: usize>(_: T) {}\n+    \"#,\n+        expect![[r#\"\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            tt Trait2\n+            md module\n+            st Unit\n+            ct CONST\n+        \"#]],\n+    );\n+}"}]}