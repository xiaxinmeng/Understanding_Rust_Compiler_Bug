{"sha": "14f42a732ff9562fb5f07eca5a7f92224dbe8881", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZjQyYTczMmZmOTU2MmZiNWYwN2VjYTVhN2Y5MjIyNGRiZTg4ODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-14T18:06:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-14T18:06:20Z"}, "message": "Auto merge of #55032 - oli-obk:the_early_unwrap_gets_the_panic, r=Mark-Simulacrum\n\nCheck the invariant for `principal` inside the method\n\nr? @Mark-Simulacrum", "tree": {"sha": "8999fb9fcbcc928072393c6b9c45ce00a1767958", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8999fb9fcbcc928072393c6b9c45ce00a1767958"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14f42a732ff9562fb5f07eca5a7f92224dbe8881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14f42a732ff9562fb5f07eca5a7f92224dbe8881", "html_url": "https://github.com/rust-lang/rust/commit/14f42a732ff9562fb5f07eca5a7f92224dbe8881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14f42a732ff9562fb5f07eca5a7f92224dbe8881/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68df4330378c9f22e9f8eae4a7a6764814b3e296", "url": "https://api.github.com/repos/rust-lang/rust/commits/68df4330378c9f22e9f8eae4a7a6764814b3e296", "html_url": "https://github.com/rust-lang/rust/commit/68df4330378c9f22e9f8eae4a7a6764814b3e296"}, {"sha": "585490d816b219dac781f763c2e3e4d2028b68ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/585490d816b219dac781f763c2e3e4d2028b68ab", "html_url": "https://github.com/rust-lang/rust/commit/585490d816b219dac781f763c2e3e4d2028b68ab"}], "stats": {"total": 336, "additions": 147, "deletions": 189}, "files": [{"sha": "817e9ffcbb55d786bbcb9ab7f56269472241d038", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -418,9 +418,7 @@ fn fundamental_ty(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::Ref(..) => true,\n         ty::Adt(def, _) => def.is_fundamental(),\n-        ty::Dynamic(ref data, ..) => {\n-            data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n-        }\n+        ty::Dynamic(ref data, ..) => tcx.has_attr(data.principal().def_id(), \"fundamental\"),\n         _ => false\n     }\n }\n@@ -467,11 +465,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n \n-        ty::Dynamic(ref tt, ..) => {\n-            tt.principal().map_or(false, |p|\n-                def_id_is_local(p.def_id(), in_crate)\n-            )\n-        }\n+        ty::Dynamic(ref tt, ..) => def_id_is_local(tt.principal().def_id(), in_crate),\n \n         ty::Error => true,\n "}, {"sha": "8e8024e51da7f43b4ce54854d055c9c23c1f71b8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -2088,10 +2088,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         return;\n                     }\n \n-                    match data.principal() {\n-                        Some(p) => p.with_self_ty(this.tcx(), self_ty),\n-                        None => return,\n-                    }\n+                    data.principal().with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -2183,15 +2180,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 //\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n-                match (data_a.principal(), data_b.principal()) {\n-                    (Some(a), Some(b)) => {\n-                        a.def_id() == b.def_id()\n-                            && data_b.auto_traits()\n-                            // All of a's auto traits need to be in b's auto traits.\n-                            .all(|b| data_a.auto_traits().any(|a| a == b))\n-                    }\n-                    _ => false,\n-                }\n+                data_a.principal().def_id() == data_b.principal().def_id()\n+                    && data_b.auto_traits()\n+                    // All of a's auto traits need to be in b's auto traits.\n+                    .all(|b| data_a.auto_traits().any(|a| a == b))\n             }\n \n             // T -> Trait.\n@@ -2981,7 +2973,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::Dynamic(ref data, ..) => {\n-                data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n+                data.principal().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n@@ -3244,10 +3236,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n                 let existential_predicates = data_a.map_bound(|data_a| {\n-                    let principal = data_a.principal();\n-                    let iter = principal\n-                        .into_iter()\n-                        .map(ty::ExistentialPredicate::Trait)\n+                    let iter = iter::once(ty::ExistentialPredicate::Trait(data_a.principal()))\n                         .chain(\n                             data_a\n                                 .projection_bounds()\n@@ -3285,7 +3274,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // T -> Trait.\n             (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids = data.auto_traits()\n-                    .chain(data.principal().map(|p| p.def_id()));\n+                    .chain(iter::once(data.principal().def_id()));\n                 if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n                     return Err(TraitNotObjectSafe(did));\n                 }"}, {"sha": "d886d5ed204139d22deaede765828a80f14cdad0", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -208,8 +208,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::FnDef(..) => \"fn item\".into(),\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n-                inner.principal().map_or_else(|| \"trait\".into(),\n-                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())).into())\n+                format!(\"trait {}\", tcx.item_path_str(inner.principal().def_id())).into()\n             }\n             ty::Closure(..) => \"closure\".into(),\n             ty::Generator(..) => \"generator\".into(),"}, {"sha": "e6aaf8b1bb20604a7046b991d1f520b0afccc27a", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -78,7 +78,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n         ty::RawPtr(_) => Some(PtrSimplifiedType),\n         ty::Dynamic(ref trait_info, ..) => {\n-            trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n+            Some(TraitSimplifiedType(trait_info.principal().def_id()))\n         }\n         ty::Ref(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we"}, {"sha": "c4a25971da3ad15145514e407ad45874c7d80130", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -436,7 +436,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     match ty.sty {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n-        ty::Dynamic(data, ..) => data.principal().map(|p| p.def_id()),\n+        ty::Dynamic(data, ..) => Some(data.principal().def_id()),\n \n         ty::Array(subty, _) |\n         ty::Slice(subty) => characteristic_def_id_of_type(subty),"}, {"sha": "cc6e6b2861ecb8578cb48180132d475185793aa6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -559,10 +559,10 @@ impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n-    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n-        match self.get(0) {\n-            Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n-            _ => None,\n+    pub fn principal(&self) -> ExistentialTraitRef<'tcx> {\n+        match self[0] {\n+            ExistentialPredicate::Trait(tr) => tr,\n+            other => bug!(\"first predicate is {:?}\", other),\n         }\n     }\n \n@@ -589,8 +589,8 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n }\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n-    pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n-        self.skip_binder().principal().map(Binder::bind)\n+    pub fn principal(&self) -> PolyExistentialTraitRef<'tcx> {\n+        Binder::bind(self.skip_binder().principal())\n     }\n \n     #[inline]\n@@ -1825,9 +1825,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             Dynamic(ref obj, region) => {\n                 let mut v = vec![region];\n-                if let Some(p) = obj.principal() {\n-                    v.extend(p.skip_binder().substs.regions());\n-                }\n+                v.extend(obj.principal().skip_binder().substs.regions());\n                 v\n             }\n             Adt(_, substs) | Opaque(_, substs) => {"}, {"sha": "27747970f76b2ca74caf955f9198ba8a85baa647", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                     let cause = self.cause(traits::MiscObligation);\n                     let component_traits =\n-                        data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n+                        data.auto_traits().chain(once(data.principal().def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),"}, {"sha": "f3b5503b8d0fc7df660296fb7ab503bb2f93bc14", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -621,16 +621,16 @@ define_print! {\n                 // Use a type that can't appear in defaults of type parameters.\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n \n-                if let Some(p) = self.principal() {\n-                    let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n-                        .with_self_ty(tcx, dummy_self);\n-                    let projections = self.projection_bounds().map(|p| {\n-                        tcx.lift(&p)\n-                            .expect(\"could not lift projection for printing\")\n-                            .with_self_ty(tcx, dummy_self)\n-                    }).collect::<Vec<_>>();\n-                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n-                }\n+                let principal = tcx\n+                    .lift(&self.principal())\n+                    .expect(\"could not lift TraitRef for printing\")\n+                    .with_self_ty(tcx, dummy_self);\n+                let projections = self.projection_bounds().map(|p| {\n+                    tcx.lift(&p)\n+                        .expect(\"could not lift projection for printing\")\n+                        .with_self_ty(tcx, dummy_self)\n+                }).collect::<Vec<_>>();\n+                cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n \n                 // Builtin bounds.\n                 for did in self.auto_traits() {"}, {"sha": "e619742373801770920da7f89326fa0862f90f72", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -59,7 +59,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, &'a Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>),\n                                    &'a Value>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'a Value>>,"}, {"sha": "6eff086a2ba0517b7d6c6524c55622c9466fe6df", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -435,12 +435,7 @@ fn trait_pointer_metadata(\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n-        ty::Dynamic(ref data, ..) => if let Some(principal) = data.principal() {\n-            let def_id = principal.def_id();\n-            Some(get_namespace_for_item(cx, def_id))\n-        } else {\n-            NO_SCOPE_METADATA\n-        },\n+        ty::Dynamic(ref data, ..) => Some(get_namespace_for_item(cx, data.principal().def_id())),\n         _ => {\n             bug!(\"debuginfo: Unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\","}, {"sha": "06b9318a5e8300037f413e9eb4ba178a5ae60a53", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -116,14 +116,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         },\n         ty::Dynamic(ref trait_data, ..) => {\n-            if let Some(principal) = trait_data.principal() {\n-                let principal = cx.tcx.normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &principal,\n-                );\n-                push_item_name(cx, principal.def_id, false, output);\n-                push_type_params(cx, principal.substs, output);\n-            }\n+            let principal = cx.tcx.normalize_erasing_late_bound_regions(\n+                ty::ParamEnv::reveal_all(),\n+                &trait_data.principal(),\n+            );\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let sig = t.fn_sig(cx.tcx);"}, {"sha": "db06b87f44e1ed99fd4e47846f3d48be58b97d66", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> VirtualIndex {\n pub fn get_vtable(\n     cx: &CodegenCx<'ll, 'tcx>,\n     ty: Ty<'tcx>,\n-    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n ) -> &'ll Value {\n     let tcx = cx.tcx;\n \n@@ -86,23 +86,19 @@ pub fn get_vtable(\n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::i8p(cx));\n \n+    let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n+    let methods = methods.iter().cloned().map(|opt_mth| {\n+        opt_mth.map_or(nullptr, |(def_id, substs)| {\n+            callee::resolve_and_get_fn(cx, def_id, substs)\n+        })\n+    });\n+\n     let (size, align) = cx.size_and_align_of(ty);\n-    let mut components: Vec<_> = [\n+    let components: Vec<_> = [\n         callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n         C_usize(cx, size.bytes()),\n         C_usize(cx, align.abi())\n-    ].iter().cloned().collect();\n-\n-    if let Some(trait_ref) = trait_ref {\n-        let trait_ref = trait_ref.with_self_ty(tcx, ty);\n-        let methods = tcx.vtable_methods(trait_ref);\n-        let methods = methods.iter().cloned().map(|opt_mth| {\n-            opt_mth.map_or(nullptr, |(def_id, substs)| {\n-                callee::resolve_and_get_fn(cx, def_id, substs)\n-            })\n-        });\n-        components.extend(methods);\n-    }\n+    ].iter().cloned().chain(methods).collect();\n \n     let vtable_const = C_struct(cx, &components, false);\n     let align = cx.data_layout().pointer_align;"}, {"sha": "f4ddfa5293e1e93df12af2908a1d0b61d6594549", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n-                let trait_ref = data.principal().unwrap().with_self_ty(\n+                let trait_ref = data.principal().with_self_ty(\n                     *self.tcx,\n                     src_pointee_ty,\n                 );"}, {"sha": "dd83d3157ba61dbc9c87c0fecae14b0ac3152852", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -907,22 +907,20 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n     if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n-        if let Some(principal) = trait_ty.principal() {\n-            let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n-            assert!(!poly_trait_ref.has_escaping_regions());\n-\n-            // Walk all methods of the trait, including those of its supertraits\n-            let methods = tcx.vtable_methods(poly_trait_ref);\n-            let methods = methods.iter().cloned().filter_map(|method| method)\n-                .map(|(def_id, substs)| ty::Instance::resolve(\n-                        tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        def_id,\n-                        substs).unwrap())\n-                .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n-                .map(|instance| create_fn_mono_item(instance));\n-            output.extend(methods);\n-        }\n+        let poly_trait_ref = trait_ty.principal().with_self_ty(tcx, impl_ty);\n+        assert!(!poly_trait_ref.has_escaping_regions());\n+\n+        // Walk all methods of the trait, including those of its supertraits\n+        let methods = tcx.vtable_methods(poly_trait_ref);\n+        let methods = methods.iter().cloned().filter_map(|method| method)\n+            .map(|(def_id, substs)| ty::Instance::resolve(\n+                    tcx,\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    substs).unwrap())\n+            .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n+            .map(|instance| create_fn_mono_item(instance));\n+        output.extend(methods);\n         // Also add the destructor\n         visit_drop_use(tcx, impl_ty, false, output);\n     }"}, {"sha": "4c4d56c8938386af83b716168b4c2ea82f12f9cf", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -320,12 +320,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 output.push(']');\n             },\n             ty::Dynamic(ref trait_data, ..) => {\n-                if let Some(principal) = trait_data.principal() {\n-                    self.push_def_path(principal.def_id(), output);\n-                    self.push_type_params(principal.skip_binder().substs,\n-                        trait_data.projection_bounds(),\n-                        output);\n-                }\n+                let principal = trait_data.principal();\n+                self.push_def_path(principal.def_id(), output);\n+                self.push_type_params(\n+                    principal.skip_binder().substs,\n+                    trait_data.projection_bounds(),\n+                    output,\n+                );\n             },\n             ty::Foreign(did) => self.push_def_path(did, output),\n             ty::FnDef(..) |"}, {"sha": "989851bb1b9b4d126bed1496346b6ce77716e19c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -93,8 +93,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n             ty::Adt(adt, _) => adt.did,\n             ty::Foreign(did) => did,\n-            ty::Dynamic(ref obj, ..) if obj.principal().is_some() =>\n-                obj.principal().unwrap().def_id(),\n+            ty::Dynamic(ref obj, ..) => obj.principal().def_id(),\n             ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n@@ -484,7 +483,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n         let ty_def_id = match ty.sty {\n             ty::Adt(adt, _) => Some(adt.did),\n             ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n             ty::Projection(ref proj) => Some(proj.item_def_id),\n             ty::FnDef(def_id, ..) |\n             ty::Closure(def_id, ..) |\n@@ -1456,7 +1455,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n         let ty_def_id = match ty.sty {\n             ty::Adt(adt, _) => Some(adt.did),\n             ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n             ty::Projection(ref proj) => {\n                 if self.required_visibility == ty::Visibility::Invisible {\n                     // Conservatively approximate the whole type alias as public without"}, {"sha": "e0ee26cba082842aab75d16aa133f5b5f0a903d3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -73,7 +73,7 @@ enum PointerKind<'tcx> {\n     /// No metadata attached, ie pointer to sized type or foreign type\n     Thin,\n     /// A trait object\n-    Vtable(Option<DefId>),\n+    Vtable(DefId),\n     /// Slice\n     Length,\n     /// The unsize info of this projection\n@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(match t.sty {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n             ty::Dynamic(ref tty, ..) =>\n-                Some(PointerKind::Vtable(tty.principal().map(|p| p.def_id()))),\n+                Some(PointerKind::Vtable(tty.principal().def_id())),\n             ty::Adt(def, substs) if def.is_struct() => {\n                 match def.non_enum_variant().fields.last() {\n                     None => Some(PointerKind::Thin),"}, {"sha": "940fa4d3916bc3a0fdc1459200f748f5a37c680b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -198,9 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n-                let kind = object_type\n-                    .principal()\n-                    .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n+                let kind = self.tcx.lang_items().fn_trait_kind(object_type.principal().def_id());\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),"}, {"sha": "75f5bf74c6aef32e40019bf29f57f2f75ea754a7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .include_raw_pointers()\n             .filter_map(|(ty, _)|\n                 match ty.sty {\n-                    ty::Dynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n+                    ty::Dynamic(ref data, ..) => Some(closure(self, ty, data.principal())),\n                     _ => None,\n                 }\n             )"}, {"sha": "ae02cd64c38916bf0c03413e5dd21f87ffd2fd3b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -452,10 +452,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         match self_ty.sty {\n             ty::Dynamic(ref data, ..) => {\n-                if let Some(p) = data.principal() {\n-                    self.assemble_inherent_candidates_from_object(self_ty, p);\n-                    self.assemble_inherent_impl_candidates_for_type(p.def_id());\n-                }\n+                let p = data.principal();\n+                self.assemble_inherent_candidates_from_object(self_ty, p);\n+                self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);"}, {"sha": "2006796a1008927f9dcd011c2d0d27d734208b44", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -663,8 +663,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n \n-                ty::Dynamic(ref tr, ..) => tr.principal()\n-                    .map_or(false, |p| p.def_id().is_local()),\n+                ty::Dynamic(ref tr, ..) => tr.principal().def_id().is_local(),\n \n                 ty::Param(_) => true,\n "}, {"sha": "ec979dea4fd03fb0a03ba73cb85140f53c12b7b3", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::Foreign(did) => {\n                 self.check_def_id(item, did);\n             }\n-            ty::Dynamic(ref data, ..) if data.principal().is_some() => {\n-                self.check_def_id(item, data.principal().unwrap().def_id());\n+            ty::Dynamic(ref data, ..) => {\n+                self.check_def_id(item, data.principal().def_id());\n             }\n             ty::Char => {\n                 self.check_primitive_impl(def_id,"}, {"sha": "9b17654d4690c7f24add30b5ac58919e8e7240b3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -181,13 +181,12 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-        if data.principal().map_or(true, |p| !tcx.is_object_safe(p.def_id())) {\n+        if !tcx.is_object_safe(data.principal().def_id()) {\n             // This is an error, but it will be reported by wfcheck.  Ignore it here.\n             // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n         } else {\n             let mut supertrait_def_ids =\n-                traits::supertrait_def_ids(tcx,\n-                                           data.principal().unwrap().def_id());\n+                traits::supertrait_def_ids(tcx, data.principal().def_id());\n             if supertrait_def_ids.any(|d| d == trait_def_id) {\n                 let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n                 struct_span_err!(tcx.sess,"}, {"sha": "132da8f5cea8dc472ad3119bce6817aad1fc2f89", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -203,28 +203,27 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Dynamic\");\n                 debug!(\"field_ty = {}\", &field_ty);\n                 debug!(\"ty in field = {}\", &ty);\n-                if let Some(ex_trait_ref) = obj.principal() {\n-                    // Here, we are passing the type `usize` as a\n-                    // placeholder value with the function\n-                    // `with_self_ty`, since there is no concrete type\n-                    // `Self` for a `dyn Trait` at this\n-                    // stage. Therefore when checking explicit\n-                    // predicates in `check_explicit_predicates` we\n-                    // need to ignore checking the explicit_map for\n-                    // Self type.\n-                    let substs = ex_trait_ref\n-                        .with_self_ty(tcx, tcx.types.usize)\n-                        .skip_binder()\n-                        .substs;\n-                    check_explicit_predicates(\n-                        tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n-                        substs,\n-                        required_predicates,\n-                        explicit_map,\n-                        IgnoreSelfTy(true),\n-                    );\n-                }\n+                let ex_trait_ref = obj.principal();\n+                // Here, we are passing the type `usize` as a\n+                // placeholder value with the function\n+                // `with_self_ty`, since there is no concrete type\n+                // `Self` for a `dyn Trait` at this\n+                // stage. Therefore when checking explicit\n+                // predicates in `check_explicit_predicates` we\n+                // need to ignore checking the explicit_map for\n+                // Self type.\n+                let substs = ex_trait_ref\n+                    .with_self_ty(tcx, tcx.types.usize)\n+                    .skip_binder()\n+                    .substs;\n+                check_explicit_predicates(\n+                    tcx,\n+                    &ex_trait_ref.skip_binder().def_id,\n+                    substs,\n+                    required_predicates,\n+                    explicit_map,\n+                    IgnoreSelfTy(true),\n+                );\n             }\n \n             ty::Projection(obj) => {"}, {"sha": "3e523c0c7f559c1481e400ea98c9c2f4a72fa011", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -311,11 +311,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, r, contra);\n \n-                if let Some(p) = data.principal() {\n-                    let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(\n-                        current, *poly_trait_ref.skip_binder(), variance);\n-                }\n+                let poly_trait_ref = data\n+                    .principal()\n+                    .with_self_ty(self.tcx(), self.tcx().types.err);\n+                self.add_constraints_from_trait_ref(\n+                    current, *poly_trait_ref.skip_binder(), variance);\n \n                 for projection in data.projection_bounds() {\n                     self.add_constraints_from_ty("}, {"sha": "2ba1f103971f074548fae0f23f5c994178435f8f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f42a732ff9562fb5f07eca5a7f92224dbe8881/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=14f42a732ff9562fb5f07eca5a7f92224dbe8881", "patch": "@@ -2632,47 +2632,44 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }\n             }\n             ty::Dynamic(ref obj, ref reg) => {\n-                if let Some(principal) = obj.principal() {\n-                    let did = principal.def_id();\n+                let principal = obj.principal();\n+                let did = principal.def_id();\n+                inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+\n+                let mut typarams = vec![];\n+                reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n+                for did in obj.auto_traits() {\n+                    let empty = cx.tcx.intern_substs(&[]);\n+                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                        Some(did), false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+                    let bound = GenericBound::TraitBound(PolyTrait {\n+                        trait_: ResolvedPath {\n+                            path,\n+                            typarams: None,\n+                            did,\n+                            is_generic: false,\n+                        },\n+                        generic_params: Vec::new(),\n+                    }, hir::TraitBoundModifier::None);\n+                    typarams.push(bound);\n+                }\n \n-                    let mut typarams = vec![];\n-                    reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n-                    for did in obj.auto_traits() {\n-                        let empty = cx.tcx.intern_substs(&[]);\n-                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n-                            Some(did), false, vec![], empty);\n-                        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-                        let bound = GenericBound::TraitBound(PolyTrait {\n-                            trait_: ResolvedPath {\n-                                path,\n-                                typarams: None,\n-                                did,\n-                                is_generic: false,\n-                            },\n-                            generic_params: Vec::new(),\n-                        }, hir::TraitBoundModifier::None);\n-                        typarams.push(bound);\n-                    }\n-\n-                    let mut bindings = vec![];\n-                    for pb in obj.projection_bounds() {\n-                        bindings.push(TypeBinding {\n-                            name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n-                            ty: pb.skip_binder().ty.clean(cx)\n-                        });\n-                    }\n+                let mut bindings = vec![];\n+                for pb in obj.projection_bounds() {\n+                    bindings.push(TypeBinding {\n+                        name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n+                        ty: pb.skip_binder().ty.clean(cx)\n+                    });\n+                }\n \n-                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n-                        false, bindings, principal.skip_binder().substs);\n-                    ResolvedPath {\n-                        path,\n-                        typarams: Some(typarams),\n-                        did,\n-                        is_generic: false,\n-                    }\n-                } else {\n-                    Never\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n+                    false, bindings, principal.skip_binder().substs);\n+                ResolvedPath {\n+                    path,\n+                    typarams: Some(typarams),\n+                    did,\n+                    is_generic: false,\n                 }\n             }\n             ty::Tuple(ref t) => Tuple(t.clean(cx)),"}]}