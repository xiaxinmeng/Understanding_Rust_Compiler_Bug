{"sha": "a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5N2U1ZWI4NWQxYThhMmEwNzY2M2FiYmQ5YmVhYWUzMTdmZGIyNGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-01T16:41:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-01T16:41:43Z"}, "message": "Centralize all config", "tree": {"sha": "32589015b770dc8c9d1c21085dd0c93b6aa2e586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32589015b770dc8c9d1c21085dd0c93b6aa2e586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "html_url": "https://github.com/rust-lang/rust/commit/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e012eb991da7344f2423ce1447917c3eb388e87", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e012eb991da7344f2423ce1447917c3eb388e87", "html_url": "https://github.com/rust-lang/rust/commit/1e012eb991da7344f2423ce1447917c3eb388e87"}], "stats": {"total": 479, "additions": 151, "deletions": 328}, "files": [{"sha": "f3d6f8f5f961beee042b3dd520fcd989a1b035e6", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -22,12 +22,22 @@ use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n pub use crate::conv::url_from_path_with_drive_lowercasing;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n     CargoCommand { command: String, all_targets: bool, extra_args: Vec<String> },\n     CustomCommand { command: String, args: Vec<String> },\n }\n \n+impl Default for FlycheckConfig {\n+    fn default() -> Self {\n+        FlycheckConfig::CargoCommand {\n+            command: \"check\".to_string(),\n+            all_targets: true,\n+            extra_args: Vec::new(),\n+        }\n+    }\n+}\n+\n /// Flycheck wraps the shared state and communication machinery used for\n /// running `cargo check` (or other compatible command) and providing\n /// diagnostics based on the output."}, {"sha": "483f50ce638f9c35a2ffb0bffb39c396baa12a5e", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -5,7 +5,7 @@ mod args;\n \n use lsp_server::Connection;\n \n-use rust_analyzer::{cli, from_json, show_message, Result, ServerConfig};\n+use rust_analyzer::{cli, from_json, Config, Result};\n \n use crate::args::HelpPrinted;\n \n@@ -78,24 +78,18 @@ fn run_server() -> Result<()> {\n         .filter(|workspaces| !workspaces.is_empty())\n         .unwrap_or_else(|| vec![root]);\n \n-    let server_config = initialize_params\n-        .initialization_options\n-        .and_then(|v| {\n-            from_json::<ServerConfig>(\"config\", v)\n-                .map_err(|e| {\n-                    log::error!(\"{}\", e);\n-                    show_message(lsp_types::MessageType::Error, e.to_string(), &connection.sender);\n-                })\n-                .ok()\n-        })\n-        .unwrap_or_default();\n-\n-    rust_analyzer::main_loop(\n-        workspace_roots,\n-        initialize_params.capabilities,\n-        server_config,\n-        connection,\n-    )?;\n+    let config = {\n+        let mut config = Config::default();\n+        if let Some(value) = &initialize_params.initialization_options {\n+            config.update(value);\n+        }\n+        if let Some(caps) = &initialize_params.capabilities.text_document {\n+            config.update_caps(caps);\n+        }\n+        config\n+    };\n+\n+    rust_analyzer::main_loop(workspace_roots, config, connection)?;\n \n     log::info!(\"shutting down IO...\");\n     io_threads.join()?;"}, {"sha": "c07626e5cd88323a364e35e19541f28acf8fe539", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 93, "deletions": 158, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -7,14 +7,11 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use rustc_hash::FxHashMap;\n-\n-use crate::feature_flags::FeatureFlags;\n use lsp_types::TextDocumentClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n use ra_ide::{CompletionConfig, InlayHintsConfig};\n use ra_project_model::CargoFeatures;\n-use serde::{Deserialize, Deserializer};\n+use serde::Deserialize;\n \n #[derive(Debug, Clone)]\n pub struct Config {\n@@ -61,171 +58,109 @@ impl Default for RustfmtConfig {\n     }\n }\n \n-pub(crate) fn get_config(\n-    config: &ServerConfig,\n-    text_document_caps: Option<&TextDocumentClientCapabilities>,\n-) -> Config {\n-    let feature_flags = get_feature_flags(config);\n-    Config {\n-        publish_decorations: config.publish_decorations,\n-        publish_diagnostics: feature_flags.get(\"lsp.diagnostics\"),\n-        notifications: NotificationsConfig {\n-            workspace_loaded: feature_flags.get(\"notifications.workspace-loaded\"),\n-            cargo_toml_not_found: feature_flags.get(\"notifications.cargo-toml-not-found\"),\n-        },\n-        supports_location_link: text_document_caps\n-            .and_then(|it| it.definition)\n-            .and_then(|it| it.link_support)\n-            .unwrap_or(false),\n-        line_folding_only: text_document_caps\n-            .and_then(|it| it.folding_range.as_ref())\n-            .and_then(|it| it.line_folding_only)\n-            .unwrap_or(false),\n-        inlay_hints: InlayHintsConfig {\n-            type_hints: config.inlay_hints_type,\n-            parameter_hints: config.inlay_hints_parameter,\n-            chaining_hints: config.inlay_hints_chaining,\n-            max_length: config.inlay_hints_max_length,\n-        },\n-        completion: CompletionConfig {\n-            enable_postfix_completions: feature_flags.get(\"completion.enable-postfix\"),\n-            add_call_parenthesis: feature_flags.get(\"completion.insertion.add-call-parenthesis\"),\n-            add_call_argument_snippets: feature_flags\n-                .get(\"completion.insertion.add-argument-snippets\"),\n-        },\n-        call_info_full: feature_flags.get(\"call-info.full\"),\n-        check: if config.cargo_watch_enable {\n-            Some(FlycheckConfig::CargoCommand {\n-                command: config.cargo_watch_command.clone(),\n-                all_targets: config.cargo_watch_all_targets,\n-                extra_args: config.cargo_watch_args.clone(),\n-            })\n-        } else {\n-            None\n-        },\n-        rustfmt: RustfmtConfig::Rustfmt { extra_args: config.rustfmt_args.clone() },\n-        vscode_lldb: config.vscode_lldb,\n-        proc_macro_srv: None, // FIXME: get this from config\n-        lru_capacity: config.lru_capacity,\n-        use_client_watching: config.use_client_watching,\n-        exclude_globs: config.exclude_globs.clone(),\n-        cargo: config.cargo_features.clone(),\n-        with_sysroot: config.with_sysroot,\n-    }\n-}\n-\n-fn get_feature_flags(config: &ServerConfig) -> FeatureFlags {\n-    let mut ff = FeatureFlags::default();\n-    for (flag, &value) in &config.feature_flags {\n-        if ff.set(flag.as_str(), value).is_err() {\n-            log::error!(\"unknown feature flag: {:?}\", flag);\n+impl Default for Config {\n+    fn default() -> Self {\n+        Config {\n+            publish_decorations: false,\n+            publish_diagnostics: true,\n+            notifications: NotificationsConfig {\n+                workspace_loaded: true,\n+                cargo_toml_not_found: true,\n+            },\n+            supports_location_link: false,\n+            line_folding_only: false,\n+            inlay_hints: InlayHintsConfig {\n+                type_hints: true,\n+                parameter_hints: true,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n+            completion: CompletionConfig {\n+                enable_postfix_completions: true,\n+                add_call_parenthesis: true,\n+                add_call_argument_snippets: true,\n+            },\n+            call_info_full: true,\n+            rustfmt: RustfmtConfig::default(),\n+            check: Some(FlycheckConfig::default()),\n+            vscode_lldb: false,\n+            proc_macro_srv: None,\n+            lru_capacity: None,\n+            use_client_watching: false,\n+            exclude_globs: Vec::new(),\n+            cargo: CargoFeatures::default(),\n+            with_sysroot: true,\n         }\n     }\n-    log::info!(\"feature_flags: {:#?}\", ff);\n-    ff\n }\n \n-/// Client provided initialization options\n-#[derive(Deserialize, Clone, Debug, PartialEq, Eq)]\n-#[serde(rename_all = \"camelCase\", default)]\n-pub struct ServerConfig {\n-    /// Whether the client supports our custom highlighting publishing decorations.\n-    /// This is different to the highlightingOn setting, which is whether the user\n-    /// wants our custom highlighting to be used.\n-    ///\n-    /// Defaults to `false`\n-    #[serde(deserialize_with = \"nullable_bool_false\")]\n-    pub publish_decorations: bool,\n-\n-    pub exclude_globs: Vec<String>,\n-    #[serde(deserialize_with = \"nullable_bool_false\")]\n-    pub use_client_watching: bool,\n-\n-    pub lru_capacity: Option<usize>,\n-\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub inlay_hints_type: bool,\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub inlay_hints_parameter: bool,\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub inlay_hints_chaining: bool,\n-    pub inlay_hints_max_length: Option<usize>,\n-\n-    pub cargo_watch_enable: bool,\n-    pub cargo_watch_args: Vec<String>,\n-    pub cargo_watch_command: String,\n-    pub cargo_watch_all_targets: bool,\n-\n-    /// For internal usage to make integrated tests faster.\n-    #[serde(deserialize_with = \"nullable_bool_true\")]\n-    pub with_sysroot: bool,\n+impl Config {\n+    #[rustfmt::skip]\n+    pub fn update(&mut self, value: &serde_json::Value) {\n+        let line_folding_only = self.line_folding_only;\n+        let supports_location_link = self.supports_location_link;\n+        *self = Default::default();\n+        self.line_folding_only = line_folding_only;\n+        self.supports_location_link = supports_location_link;\n+\n+        set(value, \"publishDecorations\", &mut self.publish_decorations);\n+        set(value, \"excludeGlobs\", &mut self.exclude_globs);\n+        set(value, \"useClientWatching\", &mut self.use_client_watching);\n+        set(value, \"lruCapacity\", &mut self.lru_capacity);\n+\n+        set(value, \"inlayHintsType\", &mut self.inlay_hints.type_hints);\n+        set(value, \"inlayHintsParameter\", &mut self.inlay_hints.parameter_hints);\n+        set(value, \"inlayHintsChaining\", &mut self.inlay_hints.chaining_hints);\n+        set(value, \"inlayHintsMaxLength\", &mut self.inlay_hints.max_length);\n+\n+        if let Some(false) = get(value, \"cargo_watch_enable\") {\n+            self.check = None\n+        } else {\n+            if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets }) = &mut self.check\n+            {\n+                set(value, \"cargoWatchArgs\", extra_args);\n+                set(value, \"cargoWatchCommand\", command);\n+                set(value, \"cargoWatchAllTargets\", all_targets);\n+            }\n+        };\n+\n+        set(value, \"withSysroot\", &mut self.with_sysroot);\n+        if let RustfmtConfig::Rustfmt { extra_args } = &mut self.rustfmt {\n+            set(value, \"rustfmtArgs\", extra_args);\n+        }\n \n-    /// Fine grained feature flags to disable specific features.\n-    pub feature_flags: FxHashMap<String, bool>,\n+        set(value, \"cargoFeatures/noDefaultFeatures\", &mut self.cargo.no_default_features);\n+        set(value, \"cargoFeatures/allFeatures\", &mut self.cargo.all_features);\n+        set(value, \"cargoFeatures/features\", &mut self.cargo.features);\n+        set(value, \"cargoFeatures/loadOutDirsFromCheck\", &mut self.cargo.load_out_dirs_from_check);\n \n-    pub rustfmt_args: Vec<String>,\n+        set(value, \"vscodeLldb\", &mut self.vscode_lldb);\n \n-    /// Cargo feature configurations.\n-    pub cargo_features: CargoFeatures,\n+        set(value, \"featureFlags/lsp.diagnostics\", &mut self.publish_diagnostics);\n+        set(value, \"featureFlags/notifications.workspace-loaded\", &mut self.notifications.workspace_loaded);\n+        set(value, \"featureFlags/notifications.cargo-toml-not-found\", &mut self.notifications.cargo_toml_not_found);\n+        set(value, \"featureFlags/completion.enable-postfix\", &mut self.completion.enable_postfix_completions);\n+        set(value, \"featureFlags/completion.insertion.add-call-parenthesis\", &mut self.completion.add_call_parenthesis);\n+        set(value, \"featureFlags/completion.insertion.add-argument-snippets\", &mut self.completion.add_call_argument_snippets);\n+        set(value, \"featureFlags/call-info.full\", &mut self.call_info_full);\n \n-    /// Enabled if the vscode_lldb extension is available.\n-    pub vscode_lldb: bool,\n-}\n+        fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n+            value.pointer(pointer).and_then(|it| T::deserialize(it).ok())\n+        }\n \n-impl Default for ServerConfig {\n-    fn default() -> ServerConfig {\n-        ServerConfig {\n-            publish_decorations: false,\n-            exclude_globs: Vec::new(),\n-            use_client_watching: false,\n-            lru_capacity: None,\n-            inlay_hints_type: true,\n-            inlay_hints_parameter: true,\n-            inlay_hints_chaining: true,\n-            inlay_hints_max_length: None,\n-            cargo_watch_enable: true,\n-            cargo_watch_args: Vec::new(),\n-            cargo_watch_command: \"check\".to_string(),\n-            cargo_watch_all_targets: true,\n-            with_sysroot: true,\n-            feature_flags: FxHashMap::default(),\n-            cargo_features: Default::default(),\n-            rustfmt_args: Vec::new(),\n-            vscode_lldb: false,\n+        fn set<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str, slot: &mut T) {\n+            if let Some(new_value) = get(value, pointer) {\n+                *slot = new_value\n+            }\n         }\n     }\n-}\n-\n-/// Deserializes a null value to a bool false by default\n-fn nullable_bool_false<'de, D>(deserializer: D) -> Result<bool, D::Error>\n-where\n-    D: Deserializer<'de>,\n-{\n-    let opt = Option::deserialize(deserializer)?;\n-    Ok(opt.unwrap_or(false))\n-}\n \n-/// Deserializes a null value to a bool true by default\n-fn nullable_bool_true<'de, D>(deserializer: D) -> Result<bool, D::Error>\n-where\n-    D: Deserializer<'de>,\n-{\n-    let opt = Option::deserialize(deserializer)?;\n-    Ok(opt.unwrap_or(true))\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn deserialize_init_options_defaults() {\n-        // check that null == default for both fields\n-        let default = ServerConfig::default();\n-        assert_eq!(default, serde_json::from_str(r#\"{}\"#).unwrap());\n-        assert_eq!(\n-            default,\n-            serde_json::from_str(r#\"{\"publishDecorations\":null, \"lruCapacity\":null}\"#).unwrap()\n-        );\n+    pub fn update_caps(&mut self, caps: &TextDocumentClientCapabilities) {\n+        if let Some(value) = caps.definition.as_ref().and_then(|it| it.link_support) {\n+            self.supports_location_link = value;\n+        }\n+        if let Some(value) = caps.folding_range.as_ref().and_then(|it| it.line_folding_only) {\n+            self.line_folding_only = value\n+        }\n     }\n }"}, {"sha": "dbb3f50a0956be9cc3f4d2bbf5c746c1a6cd6455", "filename": "crates/rust-analyzer/src/feature_flags.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1e012eb991da7344f2423ce1447917c3eb388e87/crates%2Frust-analyzer%2Fsrc%2Ffeature_flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e012eb991da7344f2423ce1447917c3eb388e87/crates%2Frust-analyzer%2Fsrc%2Ffeature_flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffeature_flags.rs?ref=1e012eb991da7344f2423ce1447917c3eb388e87", "patch": "@@ -1,77 +0,0 @@\n-//! See docs for `FeatureFlags`.\n-\n-use rustc_hash::FxHashMap;\n-\n-// FIXME: looks like a much better design is to pass options to each call,\n-// rather than to have a global ambient feature flags -- that way, the clients\n-// can issue two successive calls with different options.\n-\n-/// Feature flags hold fine-grained toggles for all *user-visible* features of\n-/// rust-analyzer.\n-///\n-/// The exists such that users are able to disable any annoying feature (and,\n-/// with many users and many features,  some features are bound to be annoying\n-/// for some users)\n-///\n-/// Note that we purposefully use run-time checked strings, and not something\n-/// checked at compile time, to keep things simple and flexible.\n-///\n-/// Also note that, at the moment, `FeatureFlags` also store features for\n-/// `rust-analyzer`. This should be benign layering violation.\n-#[derive(Debug)]\n-pub struct FeatureFlags {\n-    flags: FxHashMap<String, bool>,\n-}\n-\n-impl FeatureFlags {\n-    fn new(flags: &[(&str, bool)]) -> FeatureFlags {\n-        let flags = flags\n-            .iter()\n-            .map(|&(name, value)| {\n-                check_flag_name(name);\n-                (name.to_string(), value)\n-            })\n-            .collect();\n-        FeatureFlags { flags }\n-    }\n-\n-    pub fn set(&mut self, flag: &str, value: bool) -> Result<(), ()> {\n-        match self.flags.get_mut(flag) {\n-            None => Err(()),\n-            Some(slot) => {\n-                *slot = value;\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    pub fn get(&self, flag: &str) -> bool {\n-        match self.flags.get(flag) {\n-            None => panic!(\"unknown flag: {:?}\", flag),\n-            Some(value) => *value,\n-        }\n-    }\n-}\n-\n-impl Default for FeatureFlags {\n-    fn default() -> FeatureFlags {\n-        FeatureFlags::new(&[\n-            (\"lsp.diagnostics\", true),\n-            (\"completion.insertion.add-call-parenthesis\", true),\n-            (\"completion.insertion.add-argument-snippets\", true),\n-            (\"completion.enable-postfix\", true),\n-            (\"call-info.full\", true),\n-            (\"notifications.workspace-loaded\", true),\n-            (\"notifications.cargo-toml-not-found\", true),\n-        ])\n-    }\n-}\n-\n-fn check_flag_name(flag: &str) {\n-    for c in flag.bytes() {\n-        match c {\n-            b'a'..=b'z' | b'-' | b'.' => (),\n-            _ => panic!(\"flag name does not match conventions: {:?}\", flag),\n-        }\n-    }\n-}"}, {"sha": "6062d09843c43d94891107833c09701767ee5f27", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -37,14 +37,13 @@ mod config;\n mod world;\n mod diagnostics;\n mod semantic_tokens;\n-mod feature_flags;\n \n use serde::de::DeserializeOwned;\n \n pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;\n pub use crate::{\n+    config::Config,\n     caps::server_capabilities,\n-    config::ServerConfig,\n     main_loop::LspError,\n     main_loop::{main_loop, show_message},\n };"}, {"sha": "00f92dbd5a4c460a5c5a3fc6768d31dba868dafe", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -17,9 +17,8 @@ use std::{\n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n-    ClientCapabilities, NumberOrString, TextDocumentClientCapabilities, WorkDoneProgress,\n-    WorkDoneProgressBegin, WorkDoneProgressCreateParams, WorkDoneProgressEnd,\n-    WorkDoneProgressReport,\n+    NumberOrString, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressCreateParams,\n+    WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n use ra_flycheck::{url_from_path_with_drive_lowercasing, CheckTask};\n use ra_ide::{Canceled, FileId, LibraryData, SourceRootId};\n@@ -31,15 +30,15 @@ use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n-    config::get_config,\n+    config::Config,\n     diagnostics::DiagnosticTask,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n     req,\n     world::{WorldSnapshot, WorldState},\n-    Result, ServerConfig,\n+    Result,\n };\n use req::ConfigurationParams;\n \n@@ -65,14 +64,7 @@ impl fmt::Display for LspError {\n \n impl Error for LspError {}\n \n-pub fn main_loop(\n-    ws_roots: Vec<PathBuf>,\n-    client_caps: ClientCapabilities,\n-    config: ServerConfig,\n-    connection: Connection,\n-) -> Result<()> {\n-    let text_document_caps = client_caps.text_document.as_ref();\n-    let config = get_config(&config, text_document_caps);\n+pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n \n     // Windows scheduler implements priority boosts: if thread waits for an\n@@ -205,7 +197,6 @@ pub fn main_loop(\n                 &task_sender,\n                 &libdata_sender,\n                 &connection,\n-                text_document_caps,\n                 &mut world_state,\n                 &mut loop_state,\n                 event,\n@@ -316,7 +307,6 @@ fn loop_turn(\n     task_sender: &Sender<Task>,\n     libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    text_document_caps: Option<&TextDocumentClientCapabilities>,\n     world_state: &mut WorldState,\n     loop_state: &mut LoopState,\n     event: Event,\n@@ -370,27 +360,14 @@ fn loop_turn(\n                     log::debug!(\"config update response: '{:?}\", resp);\n                     let Response { error, result, .. } = resp;\n \n-                    match (\n-                        error,\n-                        result.map(|result| serde_json::from_value::<Vec<ServerConfig>>(result)),\n-                    ) {\n+                    match (error, result) {\n                         (Some(err), _) => {\n                             log::error!(\"failed to fetch the server settings: {:?}\", err)\n                         }\n-                        (None, Some(Ok(new_config))) => {\n-                            let new_config = new_config\n-                                .first()\n-                                .expect(\n-                                    \"the client is expected to always send a non-empty config data\",\n-                                )\n-                                .to_owned();\n-                            world_state.update_configuration(\n-                                new_config.lru_capacity,\n-                                get_config(&new_config, text_document_caps),\n-                            );\n-                        }\n-                        (None, Some(Err(e))) => {\n-                            log::error!(\"failed to parse client config response: {}\", e)\n+                        (None, Some(new_config)) => {\n+                            let mut config = world_state.config.clone();\n+                            config.update(&new_config);\n+                            world_state.update_configuration(config);\n                         }\n                         (None, None) => {\n                             log::error!(\"received empty server settings response from the client\")"}, {"sha": "5674f42ef3f800f3b4f29f0795a12b0133772d4e", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -11,7 +11,7 @@ use std::{\n use crossbeam_channel::{unbounded, Receiver};\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_flycheck::{url_from_path_with_drive_lowercasing, Flycheck};\n+use ra_flycheck::{url_from_path_with_drive_lowercasing, Flycheck, FlycheckConfig};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData, SourceRootId,\n };\n@@ -30,9 +30,7 @@ use crate::{\n use ra_db::ExternSourceId;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(workspaces: &[ProjectWorkspace], config: &Config) -> Option<Flycheck> {\n-    let check_config = config.check.as_ref()?;\n-\n+fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) -> Option<Flycheck> {\n     // FIXME: Figure out the multi-workspace situation\n     workspaces\n         .iter()\n@@ -42,7 +40,7 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &Config) -> Option<F\n         })\n         .map(|cargo| {\n             let cargo_project_root = cargo.workspace_root().to_path_buf();\n-            Some(Flycheck::new(check_config.clone(), cargo_project_root))\n+            Some(Flycheck::new(config.clone(), cargo_project_root))\n         })\n         .unwrap_or_else(|| {\n             log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n@@ -187,7 +185,7 @@ impl WorldState {\n             });\n         change.set_crate_graph(crate_graph);\n \n-        let flycheck = create_flycheck(&workspaces, &config);\n+        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n@@ -204,9 +202,13 @@ impl WorldState {\n         }\n     }\n \n-    pub fn update_configuration(&mut self, lru_capacity: Option<usize>, config: Config) {\n-        self.analysis_host.update_lru_capacity(lru_capacity);\n-        self.flycheck = create_flycheck(&self.workspaces, &config);\n+    pub fn update_configuration(&mut self, config: Config) {\n+        self.analysis_host.update_lru_capacity(config.lru_capacity);\n+        if config.check != self.config.check {\n+            self.flycheck =\n+                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n+        }\n+\n         self.config = config;\n     }\n "}, {"sha": "63881331123ef2a08a131b4d6b9dc4c50d69ea1c", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -615,7 +615,7 @@ fn main() { message(); }\n \"###,\n     )\n     .with_config(|config| {\n-        config.cargo_features.load_out_dirs_from_check = true;\n+        config.cargo.load_out_dirs_from_check = true;\n     })\n     .server();\n     server.wait_until_workspace_is_loaded();"}, {"sha": "c83cb8adb9183871f69f50b01b1aabeb0c74743b", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a97e5eb85d1a8a2a07663abbd9beaae317fdb24d/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=a97e5eb85d1a8a2a07663abbd9beaae317fdb24d", "patch": "@@ -11,23 +11,22 @@ use lsp_server::{Connection, Message, Notification, Request};\n use lsp_types::{\n     notification::{DidOpenTextDocument, Exit},\n     request::Shutdown,\n-    ClientCapabilities, DidOpenTextDocumentParams, GotoCapability, TextDocumentClientCapabilities,\n-    TextDocumentIdentifier, TextDocumentItem, Url, WorkDoneProgress,\n+    DidOpenTextDocumentParams, TextDocumentIdentifier, TextDocumentItem, Url, WorkDoneProgress,\n };\n use serde::Serialize;\n use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, parse_fixture};\n \n use req::{ProgressParams, ProgressParamsValue};\n-use rust_analyzer::{main_loop, req, ServerConfig};\n+use rust_analyzer::{main_loop, req, Config};\n \n pub struct Project<'a> {\n     fixture: &'a str,\n     with_sysroot: bool,\n     tmp_dir: Option<TempDir>,\n     roots: Vec<PathBuf>,\n-    config: Option<Box<dyn Fn(&mut ServerConfig)>>,\n+    config: Option<Box<dyn Fn(&mut Config)>>,\n }\n \n impl<'a> Project<'a> {\n@@ -50,7 +49,7 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub fn with_config(mut self, config: impl Fn(&mut ServerConfig) + 'static) -> Project<'a> {\n+    pub fn with_config(mut self, config: impl Fn(&mut Config) + 'static) -> Project<'a> {\n         self.config = Some(Box::new(config));\n         self\n     }\n@@ -78,8 +77,11 @@ impl<'a> Project<'a> {\n \n         let roots = self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect();\n \n-        let mut config =\n-            ServerConfig { with_sysroot: self.with_sysroot, ..ServerConfig::default() };\n+        let mut config = Config {\n+            supports_location_link: true,\n+            with_sysroot: self.with_sysroot,\n+            ..Config::default()\n+        };\n \n         if let Some(f) = &self.config {\n             f(&mut config)\n@@ -105,7 +107,7 @@ pub struct Server {\n impl Server {\n     fn new(\n         dir: TempDir,\n-        config: ServerConfig,\n+        config: Config,\n         roots: Vec<PathBuf>,\n         files: Vec<(PathBuf, String)>,\n     ) -> Server {\n@@ -116,26 +118,7 @@ impl Server {\n \n         let _thread = jod_thread::Builder::new()\n             .name(\"test server\".to_string())\n-            .spawn(move || {\n-                main_loop(\n-                    roots,\n-                    ClientCapabilities {\n-                        workspace: None,\n-                        text_document: Some(TextDocumentClientCapabilities {\n-                            definition: Some(GotoCapability {\n-                                dynamic_registration: None,\n-                                link_support: Some(true),\n-                            }),\n-                            ..Default::default()\n-                        }),\n-                        window: None,\n-                        experimental: None,\n-                    },\n-                    config,\n-                    connection,\n-                )\n-                .unwrap()\n-            })\n+            .spawn(move || main_loop(roots, config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");\n \n         let res ="}]}