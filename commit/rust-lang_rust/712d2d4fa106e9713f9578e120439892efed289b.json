{"sha": "712d2d4fa106e9713f9578e120439892efed289b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMmQyZDRmYTEwNmU5NzEzZjk1NzhlMTIwNDM5ODkyZWZlZDI4OWI=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-08-22T21:34:52Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2018-08-22T21:34:52Z"}, "message": "rustup, fix breakage introduced by https://github.com/rust-lang/rust/pull/53581", "tree": {"sha": "4676d81f8df76353e00e1738d14564baca87f0f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4676d81f8df76353e00e1738d14564baca87f0f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/712d2d4fa106e9713f9578e120439892efed289b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/712d2d4fa106e9713f9578e120439892efed289b", "html_url": "https://github.com/rust-lang/rust/commit/712d2d4fa106e9713f9578e120439892efed289b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/712d2d4fa106e9713f9578e120439892efed289b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05a1038b59cd4217e58b3aef7a0751a0efd01e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a1038b59cd4217e58b3aef7a0751a0efd01e4", "html_url": "https://github.com/rust-lang/rust/commit/f05a1038b59cd4217e58b3aef7a0751a0efd01e4"}], "stats": {"total": 315, "additions": 158, "deletions": 157}, "files": [{"sha": "6d086c13ff8e65137221cf5cdcdcfbf195e64533", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n+                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args) ="}, {"sha": "ff189d6e893e404536ee3e081a367a5ceee98d4d", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -123,12 +123,12 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: &ty::TypeVariants<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: &ty::TyKind<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n             (&Constant::Int(l), &Constant::Int(r)) => {\n-                if let ty::TyInt(int_ty) = *cmp_type {\n+                if let ty::Int(int_ty) = *cmp_type {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n@@ -166,8 +166,8 @@ pub fn lit_to_constant<'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, _) |\n         LitKind::FloatUnsuffixed(ref is) => match ty.sty {\n-            ty::TyFloat(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n-            ty::TyFloat(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n+            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n+            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n             _ => bug!(),\n         },\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -220,7 +220,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n                 let n = match self.tables.expr_ty(e).sty {\n-                    ty::TyArray(_, n) => n.assert_usize(self.tcx).expect(\"array length\"),\n+                    ty::Array(_, n) => n.assert_usize(self.tcx).expect(\"array length\"),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n as u64))\n@@ -243,8 +243,8 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             Int(value) => {\n                 let value = !value;\n                 match ty.sty {\n-                    ty::TyInt(ity) => Some(Int(unsext(self.tcx, value as i128, ity))),\n-                    ty::TyUint(ity) => Some(Int(clip(self.tcx, value, ity))),\n+                    ty::Int(ity) => Some(Int(unsext(self.tcx, value as i128, ity))),\n+                    ty::Uint(ity) => Some(Int(clip(self.tcx, value, ity))),\n                     _ => None,\n                 }\n             },\n@@ -257,7 +257,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         match *o {\n             Int(value) => {\n                 let ity = match ty.sty {\n-                    ty::TyInt(ity) => ity,\n+                    ty::Int(ity) => ity,\n                     _ => return None,\n                 };\n                 // sign extend\n@@ -336,7 +336,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         match (l, r) {\n             (Constant::Int(l), Some(Constant::Int(r))) => {\n                 match self.tables.expr_ty(left).sty {\n-                    ty::TyInt(ity) => {\n+                    ty::Int(ity) => {\n                         let l = sext(self.tcx, l, ity);\n                         let r = sext(self.tcx, r, ity);\n                         let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n@@ -360,7 +360,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                             _ => None,\n                         }\n                     }\n-                    ty::TyUint(_) => {\n+                    ty::Uint(_) => {\n                         match op.node {\n                             BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n                             BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n@@ -429,18 +429,18 @@ pub fn miri_to_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, result: &ty::Const<'\n     use rustc::mir::interpret::{Scalar, ScalarMaybeUndef, ConstValue};\n     match result.val {\n         ConstValue::Scalar(Scalar::Bits{ bits: b, ..}) => match result.ty.sty {\n-            ty::TyBool => Some(Constant::Bool(b == 1)),\n-            ty::TyUint(_) | ty::TyInt(_) => Some(Constant::Int(b)),\n-            ty::TyFloat(FloatTy::F32) => Some(Constant::F32(f32::from_bits(b as u32))),\n-            ty::TyFloat(FloatTy::F64) => Some(Constant::F64(f64::from_bits(b as u64))),\n+            ty::Bool => Some(Constant::Bool(b == 1)),\n+            ty::Uint(_) | ty::Int(_) => Some(Constant::Int(b)),\n+            ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(b as u32))),\n+            ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(b as u64))),\n             // FIXME: implement other conversion\n             _ => None,\n         },\n         ConstValue::ScalarPair(Scalar::Ptr(ptr),\n                                ScalarMaybeUndef::Scalar(\n                                 Scalar::Bits { bits: n, .. })) => match result.ty.sty {\n-            ty::TyRef(_, tam, _) => match tam.sty {\n-                ty::TyStr => {\n+            ty::Ref(_, tam, _) => match tam.sty {\n+                ty::Str => {\n                     let alloc = tcx\n                         .alloc_map\n                         .lock()"}, {"sha": "93074eadd659c552d607e2bae707d6eb094ef21b", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -159,9 +159,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                 walk_expr(self, e);\n                 let ty = self.cx.tables.node_id_to_type(callee.hir_id);\n                 match ty.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                    ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = ty.fn_sig(self.cx.tcx);\n-                        if sig.skip_binder().output().sty == ty::TyNever {\n+                        if sig.skip_binder().output().sty == ty::Never {\n                             self.divergence += 1;\n                         }\n                     },"}, {"sha": "f01e106df2615e6415b41fb1d88c7a1bd26c40ca", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::{declare_lint, lint_array};\n use if_chain::if_chain;\n-use rustc::ty::TypeVariants;\n+use rustc::ty::TyKind;\n \n use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n \n@@ -51,7 +51,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n                         let expr_ty = cx.tables.expr_ty(expr);\n-                        if let TypeVariants::TyAdt(..) = expr_ty.sty {\n+                        if let TyKind::Adt(..) = expr_ty.sty {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg(\n                                 cx,"}, {"sha": "e3abfe93810c75cc756f8e5dd435ca3c790df657", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -141,18 +141,18 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n         }\n \n         match ty.sty {\n-            ty::TyAdt(def, _) if def.is_union() => return,\n+            ty::Adt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            ty::TyAdt(def, substs) => for variant in &def.variants {\n+            ty::Adt(def, substs) => for variant in &def.variants {\n                 for field in &variant.fields {\n-                    if let ty::TyFnDef(..) = field.ty(cx.tcx, substs).sty {\n+                    if let ty::FnDef(..) = field.ty(cx.tcx, substs).sty {\n                         return;\n                     }\n                 }\n                 for subst in substs {\n                     if let ty::subst::UnpackedKind::Type(subst) = subst.unpack() {\n-                        if let ty::TyParam(_) = subst.sty {\n+                        if let ty::Param(_) = subst.sty {\n                             return;\n                         }\n                     }"}, {"sha": "1e6189e38390089332bbc7b583093ef044ebd4d2", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let arg = &args[0];\n                 let arg_ty = cx.tables.expr_ty(arg);\n \n-                if let ty::TyRef(..) = arg_ty.sty {\n+                if let ty::Ref(..) = arg_ty.sty {\n                     if match_def_path(cx.tcx, def_id, &paths::DROP) {\n                         lint = DROP_REF;\n                         msg = DROP_REF_SUMMARY.to_string();"}, {"sha": "2551f624cb123b2f4cef23f52db84d261a620053", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -63,19 +63,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                     let constant = cx.tcx.const_eval(param_env.and(cid)).ok();\n                     if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n                         let mut ty = cx.tcx.type_of(did);\n-                        if let ty::TyAdt(adt, _) = ty.sty {\n+                        if let ty::Adt(adt, _) = ty.sty {\n                             if adt.is_enum() {\n                                 ty = adt.repr.discr_type().to_ty(cx.tcx);\n                             }\n                         }\n                         match ty.sty {\n-                            ty::TyInt(IntTy::Isize) => {\n+                            ty::Int(IntTy::Isize) => {\n                                 let val = ((val as i128) << 64) >> 64;\n                                 if val <= i128::from(i32::max_value()) && val >= i128::from(i32::min_value()) {\n                                     continue;\n                                 }\n                             }\n-                            ty::TyUint(UintTy::Usize) if val > u128::from(u32::max_value()) => {},\n+                            ty::Uint(UintTy::Usize) if val > u128::from(u32::max_value()) => {},\n                             _ => continue,\n                         }\n                         span_lint("}, {"sha": "260cca76c8c4a1046dd6a6fcf059450e2010b9a5", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -67,9 +67,9 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n             let fn_ty = cx.tables.expr_ty(caller);\n             match fn_ty.sty {\n                 // Is it an unsafe function? They don't implement the closure traits\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                ty::FnDef(..) | ty::FnPtr(_) => {\n                     let sig = fn_ty.fn_sig(cx.tcx);\n-                    if sig.skip_binder().unsafety == Unsafety::Unsafe || sig.skip_binder().output().sty == ty::TyNever {\n+                    if sig.skip_binder().unsafety == Unsafety::Unsafe || sig.skip_binder().output().sty == ty::Never {\n                         return;\n                     }\n                 },"}, {"sha": "9ddc3ddbfe74ae0561714f488804b03020d4c8c0", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -130,9 +130,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n             ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n                 match typ.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                    ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n-                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&sig).output().sty {\n+                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().sty {\n                             self.report_diverging_sub_expr(e);\n                         }\n                     },"}, {"sha": "52af7e129ab4e41b15869727d15c94cff0c78b9f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::lint::*;\n use rustc::{declare_lint, lint_array};\n use if_chain::if_chain;\n-use rustc::ty::TypeVariants;\n+use rustc::ty::TyKind;\n use std::f32;\n use std::f64;\n use std::fmt;\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n-            if let TypeVariants::TyFloat(fty) = ty.sty;\n+            if let TyKind::Float(fty) = ty.sty;\n             if let hir::ExprKind::Lit(ref lit) = expr.node;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);"}, {"sha": "22f6df655061364e708ab8ba61cc71736fe332f8", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -130,7 +130,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n \n fn match_type(tcx: ty::TyCtxt<'_, '_, '_>, ty: ty::Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyAdt(adt, _) => match_def_path(tcx, adt.did, path),\n+        ty::Adt(adt, _) => match_def_path(tcx, adt.did, path),\n         _ => false,\n     }\n }"}, {"sha": "4f83caa43dd4c0c18906fd36f5ad5c98c782a736", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -122,7 +122,7 @@ fn get_single_string_arg(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Span>\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-            if ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING) {\n+            if ty.sty == ty::Str || match_type(cx, ty, &paths::STRING) {\n                 if let ExprKind::Tup(ref values) = match_expr.node {\n                     return Some(values[0].span);\n                 }"}, {"sha": "31e955dc570c99a9b8522574ebbafb2ae8df31f8", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -63,8 +63,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n fn check(cx: &LateContext<'_, '_>, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         let check = match cx.tables.expr_ty(e).sty {\n-            ty::TyInt(ity) => unsext(cx.tcx, -1_i128, ity),\n-            ty::TyUint(uty) => clip(cx.tcx, !0, uty),\n+            ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n+            ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,\n         };\n         if match m {"}, {"sha": "9ec9c9f83b4753fc6382abb064aac7f3eac34a7c", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n-                if let ty::TyArray(_, s) = ty.sty {\n+                if let ty::Array(_, s) = ty.sty {\n                     let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n                     // Index is a constant range.\n                     if let Some((start, end)) = to_const_range(cx, range, size) {\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n                 );\n             } else {\n                 // Catchall non-range index, i.e. [n] or [n << m]\n-                if let ty::TyArray(..) = ty.sty {\n+                if let ty::Array(..) = ty.sty {\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.tables, index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays."}, {"sha": "9c7d4626e0a5025d0e4cf8127832538031c8ce80", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n             if let ExprKind::Call(ref path, ref args) = expr.node;\n             if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 0;\n-            if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty;\n+            if let ty::Ref(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             then {\n                 let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) |"}, {"sha": "2fb4c691ce8a702d82436d086e68f2cb90eb5608", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -265,12 +265,12 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n-        ty::TyDynamic(ref tt, ..) => cx.tcx\n+        ty::Dynamic(ref tt, ..) => cx.tcx\n             .associated_items(tt.principal().expect(\"trait impl not found\").def_id())\n             .any(|item| is_is_empty(cx, &item)),\n-        ty::TyProjection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n-        ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n-        ty::TyArray(..) | ty::TySlice(..) | ty::TyStr => true,\n+        ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n+        ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n+        ty::Array(..) | ty::Slice(..) | ty::Str => true,\n         _ => false,\n     }\n }"}, {"sha": "973b706801ae027c1706e5df9f871cdaf381b1e5", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -759,8 +759,8 @@ struct FixedOffsetVar {\n \n fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     let is_slice = match ty.sty {\n-        ty::TyRef(_, subty, _) => is_slice_like(cx, subty),\n-        ty::TySlice(..) | ty::TyArray(..) => true,\n+        ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n+        ty::Slice(..) | ty::Array(..) => true,\n         _ => false,\n     };\n \n@@ -1149,8 +1149,8 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n                         Constant::Int(start_idx),\n                         Constant::Int(end_idx),\n                     ) => (match ty.sty {\n-                        ty::TyInt(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n-                        ty::TyUint(_) => start_idx > end_idx,\n+                        ty::Int(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n+                        ty::Uint(_) => start_idx > end_idx,\n                         _ => false,\n                     }, start_idx == end_idx),\n                     _ => (false, false),\n@@ -1239,7 +1239,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n                     match cx.tables.expr_ty(&args[0]).sty {\n                         // If the length is greater than 32 no traits are implemented for array and\n                         // therefore we cannot use `&`.\n-                        ty::TypeVariants::TyArray(_, size) if size.assert_usize(cx.tcx).expect(\"array size\") > 32 => (),\n+                        ty::TyKind::Array(_, size) if size.assert_usize(cx.tcx).expect(\"array size\") > 32 => (),\n                         _ => lint_iter_method(cx, args, arg, method_name),\n                     };\n                 } else {\n@@ -1381,7 +1381,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).sty {\n-                ty::TyRef(_, ty, mutbl) => match (&pat[0].node, &pat[1].node) {\n+                ty::Ref(_, ty, mutbl) => match (&pat[0].node, &pat[1].node) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, MutImmutable),\n                     _ => return,\n@@ -1721,7 +1721,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 for expr in args {\n                     let ty = self.cx.tables.expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n-                    if let ty::TyRef(_, _, mutbl) = ty.sty {\n+                    if let ty::Ref(_, _, mutbl) = ty.sty {\n                         if mutbl == MutMutable {\n                             self.prefer_mutable = true;\n                         }\n@@ -1733,7 +1733,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 let def_id = self.cx.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n-                    if let ty::TyRef(_, _, mutbl) = ty.sty {\n+                    if let ty::Ref(_, _, mutbl) = ty.sty {\n                         if mutbl == MutMutable {\n                             self.prefer_mutable = true;\n                         }\n@@ -1814,7 +1814,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n fn is_iterable_array(ty: Ty<'_>, cx: &LateContext<'_, '_>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n-        ty::TyArray(_, n) => (0..=32).contains(&n.assert_usize(cx.tcx).expect(\"array length\")),\n+        ty::Array(_, n) => (0..=32).contains(&n.assert_usize(cx.tcx).expect(\"array length\")),\n         _ => false,\n     }\n }"}, {"sha": "c570f0b32bfd036a6ed1050f4b83f31d9e98d14b", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     walk_ptrs_ty_depth(cx.tables.pat_ty(&first_arg.pat)).1 == 1\n                                 {\n                                     // the argument is not an &mut T\n-                                    if let ty::TyRef(_, _, mutbl) = ty.sty {\n+                                    if let ty::Ref(_, _, mutbl) = ty.sty {\n                                         if mutbl == MutImmutable {\n                                             span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                                 \"you seem to be using .map() to clone the contents of an {}, consider \\"}, {"sha": "eff00896c7f94d9fe4ab0ba8546e0c5015f146ec", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -86,16 +86,16 @@ impl LintPass for Pass {\n \n fn is_unit_type(ty: ty::Ty<'_>) -> bool {\n     match ty.sty {\n-        ty::TyTuple(slice) => slice.is_empty(),\n-        ty::TyNever => true,\n+        ty::Tuple(slice) => slice.is_empty(),\n+        ty::Never => true,\n         _ => false,\n     }\n }\n \n fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n-    if let ty::TyFnDef(id, _) = ty.sty {\n+    if let ty::FnDef(id, _) = ty.sty {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_late_bound_regions() {\n             return is_unit_type(fn_type.output());\n         }"}, {"sha": "691d61f55baa3ef52e68f20dbf01a5932aa8d9a8", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -224,7 +224,7 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n             return;\n         };\n         let ty = cx.tables.expr_ty(ex);\n-        if ty.sty != ty::TyBool || is_allowed(cx, MATCH_BOOL, ex.id) {\n+        if ty.sty != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }\n@@ -295,7 +295,7 @@ fn check_single_match_opt_like(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]\n \n fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n-    if cx.tables.expr_ty(ex).sty == ty::TyBool {\n+    if cx.tables.expr_ty(ex).sty == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,"}, {"sha": "1c31c414d2b3747efd8ddb6c5999e34b35924ffc", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -784,7 +784,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n \n                 match self_ty.sty {\n-                    ty::TyRef(_, ty, _) if ty.sty == ty::TyStr => for &(method, pos) in &PATTERN_METHODS {\n+                    ty::Ref(_, ty, _) if ty.sty == ty::Str => for &(method, pos) in &PATTERN_METHODS {\n                         if method_call.ident.name == method && args.len() > pos {\n                             lint_single_char_pattern(cx, expr, &args[pos]);\n                         }\n@@ -1113,8 +1113,8 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'_>) {\n     let ty = cx.tables.expr_ty(expr);\n-    if let ty::TyRef(_, inner, _) = arg_ty.sty {\n-        if let ty::TyRef(_, innermost, _) = inner.sty {\n+    if let ty::Ref(_, inner, _) = arg_ty.sty {\n+        if let ty::Ref(_, innermost, _) = inner.sty {\n             span_lint_and_then(\n                 cx,\n                 CLONE_DOUBLE_REF,\n@@ -1124,7 +1124,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n                 |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                     let mut ty = innermost;\n                     let mut n = 0;\n-                    while let ty::TyRef(_, inner, _) = ty.sty {\n+                    while let ty::Ref(_, inner, _) = ty.sty {\n                         ty = inner;\n                         n += 1;\n                     }\n@@ -1142,7 +1142,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n     if is_copy(cx, ty) {\n         let snip;\n         if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n-            if let ty::TyRef(..) = cx.tables.expr_ty(arg).sty {\n+            if let ty::Ref(..) = cx.tables.expr_ty(arg).sty {\n                 let parent = cx.tcx.hir.get_parent_node(expr.id);\n                 match cx.tcx.hir.get(parent) {\n                     hir::map::NodeExpr(parent) => match parent.node {\n@@ -1182,7 +1182,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n-    if let ty::TyAdt(_, subst) = obj_ty.sty {\n+    if let ty::Adt(_, subst) = obj_ty.sty {\n         let caller_type = if match_type(cx, obj_ty, &paths::RC) {\n             \"Rc\"\n         } else if match_type(cx, obj_ty, &paths::ARC) {\n@@ -1210,7 +1210,7 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = walk_ptrs_ty(cx.tables.expr_ty(target));\n-        let ref_str = if self_ty.sty == ty::TyStr {\n+        let ref_str = if self_ty.sty == ty::Str {\n             \"\"\n         } else if match_type(cx, self_ty, &paths::STRING) {\n             \"&\"\n@@ -1442,11 +1442,11 @@ fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Option<sugg::Sugg<'static>> {\n     fn may_slice(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         match ty.sty {\n-            ty::TySlice(_) => true,\n-            ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n-            ty::TyAdt(..) => match_type(cx, ty, &paths::VEC),\n-            ty::TyArray(_, size) => size.assert_usize(cx.tcx).expect(\"array length\") < 32,\n-            ty::TyRef(_, inner, _) => may_slice(cx, inner),\n+            ty::Slice(_) => true,\n+            ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n+            ty::Adt(..) => match_type(cx, ty, &paths::VEC),\n+            ty::Array(_, size) => size.assert_usize(cx.tcx).expect(\"array length\") < 32,\n+            ty::Ref(_, inner, _) => may_slice(cx, inner),\n             _ => false,\n         }\n     }\n@@ -1459,9 +1459,9 @@ fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Op\n         }\n     } else {\n         match ty.sty {\n-            ty::TySlice(_) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::TyAdt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::TyRef(_, inner, _) => if may_slice(cx, inner) {\n+            ty::Slice(_) => sugg::Sugg::hir_opt(cx, expr),\n+            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => sugg::Sugg::hir_opt(cx, expr),\n+            ty::Ref(_, inner, _) => if may_slice(cx, inner) {\n                 sugg::Sugg::hir_opt(cx, expr)\n             } else {\n                 None\n@@ -1812,7 +1812,7 @@ fn lint_chars_cmp(\n         then {\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n \n-            if self_ty.sty != ty::TyStr {\n+            if self_ty.sty != ty::Str {\n                 return false;\n             }\n \n@@ -1939,7 +1939,7 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n-    if let ty::TyAdt(_, substs) = ty.sty {\n+    if let ty::Adt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n         } else {"}, {"sha": "a43c60f111f06e9934d0ea9183790a8f62e59f41", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -465,7 +465,7 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::TyFloat(_))\n+    matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::Float(_))\n }\n \n fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {"}, {"sha": "d85612410016d62d1694c3bea00ff597e785526b", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::TyRef(\n+            } else if let ty::Ref(\n                 _,\n                 _,\n                 hir::MutMutable,"}, {"sha": "02a80a19e79df1c24e149b295ad10a9d232daf75", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -58,16 +58,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n \n fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], type_definition: Ty<'tcx>, name: &str) {\n     match type_definition.sty {\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    ty::TyRef(\n+                    ty::Ref(\n                         _,\n                         _,\n                         MutImmutable,\n                     ) |\n-                    ty::TyRawPtr(ty::TypeAndMut {\n+                    ty::RawPtr(ty::TypeAndMut {\n                         mutbl: MutImmutable,\n                         ..\n                     }) => if let ExprKind::AddrOf(MutMutable, _) = argument.node {"}, {"sha": "8b56526f49556230225a209407d88bc8f6a2ad69", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -60,7 +60,7 @@ pub struct MutexAtomic;\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let ty = cx.tables.expr_ty(expr);\n-        if let ty::TyAdt(_, subst) = ty.sty {\n+        if let ty::Adt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n@@ -70,8 +70,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n                         atomic_name\n                     );\n                     match mutex_param.sty {\n-                        ty::TyUint(t) if t != ast::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n-                        ty::TyInt(t) if t != ast::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::Uint(t) if t != ast::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::Int(t) if t != ast::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n                     };\n                 }\n@@ -82,10 +82,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n \n fn get_atomic_name(ty: Ty<'_>) -> Option<(&'static str)> {\n     match ty.sty {\n-        ty::TyBool => Some(\"AtomicBool\"),\n-        ty::TyUint(_) => Some(\"AtomicUsize\"),\n-        ty::TyInt(_) => Some(\"AtomicIsize\"),\n-        ty::TyRawPtr(_) => Some(\"AtomicPtr\"),\n+        ty::Bool => Some(\"AtomicBool\"),\n+        ty::Uint(_) => Some(\"AtomicUsize\"),\n+        ty::Int(_) => Some(\"AtomicIsize\"),\n+        ty::RawPtr(_) => Some(\"AtomicPtr\"),\n         _ => None,\n     }\n }"}, {"sha": "ae931e58326a677f8fcbb5b313075fdd90232f20", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(MutImmutable, ref inner) = e.node {\n-            if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n+            if let ty::Ref(..) = cx.tables.expr_ty(inner).sty {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_),\n@@ -90,9 +90,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, _, name, _) = pat.node;\n-            if let ty::TyRef(_, tam, mutbl) = cx.tables.pat_ty(pat).sty;\n+            if let ty::Ref(_, tam, mutbl) = cx.tables.pat_ty(pat).sty;\n             if mutbl == MutImmutable;\n-            if let ty::TyRef(_, _, mutbl) = tam.sty;\n+            if let ty::Ref(_, _, mutbl) = tam.sty;\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n             if mutbl == MutImmutable;\n             then {"}, {"sha": "c93cda55724c62f9f60eee43681a262075a5362c", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n                     // Dereference suggestion\n                     let sugg = |db: &mut DiagnosticBuilder<'_>| {\n-                        if let ty::TypeVariants::TyAdt(def, ..) = ty.sty {\n+                        if let ty::TyKind::Adt(def, ..) = ty.sty {\n                             if let Some(span) = cx.tcx.hir.span_if_local(def.did) {\n                                 if cx.param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n                                     db.span_help(span, \"consider marking this type as Copy\");"}, {"sha": "90a1ee14a6d05fb3fb9e4a83cfd6fc3ee8fba98e", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n-            if let ty::TyAdt(def, _) = ty.sty {\n+            if let ty::Adt(def, _) = ty.sty {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint(\n                         cx,"}, {"sha": "224326b3d179f0e76a037c60a4d037da4a35e99b", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -169,7 +169,7 @@ fn create_new_without_default_suggest_msg(ty: Ty<'_>) -> String {\n \n fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n     match ty.sty {\n-        ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {\n+        ty::Adt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n                 if !implements_trait(cx, f_ty, default_trait_id, &[]) {"}, {"sha": "b040bd91f8dabed3c1f062c18dc53cefd8832ddc", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -152,7 +152,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id:\n     let fn_ty = sig.skip_binder();\n \n     for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n-        if let ty::TyRef(\n+        if let ty::Ref(\n             _,\n             ty,\n             MutImmutable"}, {"sha": "cc4aa129870597662863fb6b42b0dc03232c90c9", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -155,7 +155,7 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables.node_id_to_type(pat_id);\n     match var_ty.sty {\n-        ty::TyAdt(..) => false,\n+        ty::Adt(..) => false,\n         _ => true,\n     }\n }"}, {"sha": "8b10396443f2f92a4bbe71b0704751eee24f7bed", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -93,8 +93,8 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n-                                if matches!(ty.sty, ty::TySlice(_)) ||\n-                                    matches!(ty.sty, ty::TyArray(_, _)) ||\n+                                if matches!(ty.sty, ty::Slice(_)) ||\n+                                    matches!(ty.sty, ty::Array(_, _)) ||\n                                     match_type(cx, ty, &paths::VEC) ||\n                                     match_type(cx, ty, &paths::VEC_DEQUE) {\n                                         return Some((lhs1, idx1, idx2));"}, {"sha": "28c5971e852c47ac0111ef7360c07866d76f363e", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 e.span,\n                                 &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n                             ),\n-                            (&ty::TyRef(_, rty, rty_mutbl), &ty::TyRawPtr(ptr_ty)) => span_lint_and_then(\n+                            (&ty::Ref(_, rty, rty_mutbl), &ty::RawPtr(ptr_ty)) => span_lint_and_then(\n                                 cx,\n                                 USELESS_TRANSMUTE,\n                                 e.span,\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                 },\n                             ),\n-                            (&ty::TyInt(_), &ty::TyRawPtr(_)) | (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n+                            (&ty::Int(_), &ty::RawPtr(_)) | (&ty::Uint(_), &ty::RawPtr(_)) => {\n                                 span_lint_and_then(\n                                     cx,\n                                     USELESS_TRANSMUTE,\n@@ -259,16 +259,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     },\n                                 )\n                             },\n-                            (&ty::TyFloat(_), &ty::TyRef(..)) |\n-                            (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n-                            (&ty::TyChar, &ty::TyRef(..)) |\n-                            (&ty::TyChar, &ty::TyRawPtr(_)) => span_lint(\n+                            (&ty::Float(_), &ty::Ref(..)) |\n+                            (&ty::Float(_), &ty::RawPtr(_)) |\n+                            (&ty::Char, &ty::Ref(..)) |\n+                            (&ty::Char, &ty::RawPtr(_)) => span_lint(\n                                 cx,\n                                 WRONG_TRANSMUTE,\n                                 e.span,\n                                 &format!(\"transmute from a `{}` to a pointer\", from_ty),\n                             ),\n-                            (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n+                            (&ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n                                 cx,\n                                 CROSSPOINTER_TRANSMUTE,\n                                 e.span,\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     to_ty\n                                 ),\n                             ),\n-                            (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n+                            (_, &ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n                                 cx,\n                                 CROSSPOINTER_TRANSMUTE,\n                                 e.span,\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     to_ty\n                                 ),\n                             ),\n-                            (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_ref_ty, mutbl)) => span_lint_and_then(\n+                            (&ty::RawPtr(from_pty), &ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n                                 cx,\n                                 TRANSMUTE_PTR_TO_REF,\n                                 e.span,\n@@ -315,16 +315,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n                                 },\n                             ),\n-                            (&ty::TyInt(ast::IntTy::I32), &ty::TyChar) |\n-                            (&ty::TyUint(ast::UintTy::U32), &ty::TyChar) => span_lint_and_then(\n+                            (&ty::Int(ast::IntTy::I32), &ty::Char) |\n+                            (&ty::Uint(ast::UintTy::U32), &ty::Char) => span_lint_and_then(\n                                 cx,\n                                 TRANSMUTE_INT_TO_CHAR,\n                                 e.span,\n                                 &format!(\"transmute from a `{}` to a `char`\", from_ty),\n                                 |db| {\n                                     let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let arg = if let ty::TyInt(_) = from_ty.sty {\n-                                        arg.as_ty(ty::TyUint(ast::UintTy::U32))\n+                                    let arg = if let ty::Int(_) = from_ty.sty {\n+                                        arg.as_ty(ty::Uint(ast::UintTy::U32))\n                                     } else {\n                                         arg\n                                     };\n@@ -335,10 +335,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     );\n                                 },\n                             ),\n-                            (&ty::TyRef(_, ty_from, from_mutbl), &ty::TyRef(_, ty_to, to_mutbl)) => {\n+                            (&ty::Ref(_, ty_from, from_mutbl), &ty::Ref(_, ty_to, to_mutbl)) => {\n                                 if_chain! {\n-                                    if let (&ty::TySlice(slice_ty), &ty::TyStr) = (&ty_from.sty, &ty_to.sty);\n-                                    if let ty::TyUint(ast::UintTy::U8) = slice_ty.sty;\n+                                    if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.sty, &ty_to.sty);\n+                                    if let ty::Uint(ast::UintTy::U8) = slice_ty.sty;\n                                     if from_mutbl == to_mutbl;\n                                     then {\n                                         let postfix = if from_mutbl == Mutability::MutMutable {\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     }\n                                 }\n                             },\n-                            (&ty::TyRawPtr(_), &ty::TyRawPtr(to_ty)) => span_lint_and_then(\n+                            (&ty::RawPtr(_), &ty::RawPtr(to_ty)) => span_lint_and_then(\n                                 cx,\n                                 TRANSMUTE_PTR_TO_PTR,\n                                 e.span,\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                 },\n                             ),\n-                            (&ty::TyInt(ast::IntTy::I8), &ty::TyBool) | (&ty::TyUint(ast::UintTy::U8), &ty::TyBool) => {\n+                            (&ty::Int(ast::IntTy::I8), &ty::Bool) | (&ty::Uint(ast::UintTy::U8), &ty::Bool) => {\n                                 span_lint_and_then(\n                                     cx,\n                                     TRANSMUTE_INT_TO_BOOL,\n@@ -414,15 +414,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     },\n                                 )\n                             },\n-                            (&ty::TyInt(_), &ty::TyFloat(_)) | (&ty::TyUint(_), &ty::TyFloat(_)) => {\n+                            (&ty::Int(_), &ty::Float(_)) | (&ty::Uint(_), &ty::Float(_)) => {\n                                 span_lint_and_then(\n                                     cx,\n                                     TRANSMUTE_INT_TO_FLOAT,\n                                     e.span,\n                                     &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                                     |db| {\n                                         let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                        let arg = if let ty::TyInt(int_ty) = from_ty.sty {\n+                                        let arg = if let ty::Int(int_ty) = from_ty.sty {\n                                             arg.as_ty(format!(\n                                                 \"u{}\",\n                                                 int_ty"}, {"sha": "d88a970db75dca08327784d566d3b5fcb468ea58", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -1,13 +1,14 @@\n use std::cmp;\n \n use matches::matches;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::map::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n use rustc::{declare_lint, lint_array};\n use if_chain::if_chain;\n-use rustc::ty::TypeVariants;\n+use rustc::ty::TyKind;\n use rustc::session::config::Config as SessionConfig;\n use rustc_target::spec::abi::Abi;\n use rustc_target::abi::LayoutOf;\n@@ -125,8 +126,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         // argument. In that case we can't switch to pass-by-value as the\n         // argument will not live long enough.\n         let output_lts = match fn_sig.output().sty {\n-            TypeVariants::TyRef(output_lt, _, _) => vec![output_lt],\n-            TypeVariants::TyAdt(_, substs) => substs.regions().collect(),\n+            TyKind::Ref(output_lt, _, _) => vec![output_lt],\n+            TyKind::Adt(_, substs) => substs.regions().collect(),\n             _ => vec![],\n         };\n \n@@ -137,12 +138,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n             }\n \n             if_chain! {\n-                if let TypeVariants::TyRef(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n+                if let TyKind::Ref(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n                 if !output_lts.contains(&input_lt);\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                 if size <= self.limit;\n-                if let TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n                 then {\n                     let value_type = if is_self(arg) {\n                         \"self\".into()"}, {"sha": "024aba7e85e64da57a7495a5ace0b3473206e200", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -550,7 +550,7 @@ fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n \n fn is_unit(ty: Ty<'_>) -> bool {\n     match ty.sty {\n-        ty::TyTuple(slice) if slice.is_empty() => true,\n+        ty::Tuple(slice) if slice.is_empty() => true,\n         _ => false,\n     }\n }\n@@ -755,15 +755,15 @@ declare_clippy_lint! {\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n     match typ.sty {\n-        ty::TyInt(i) => match i {\n+        ty::Int(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n             IntTy::I8 => 8,\n             IntTy::I16 => 16,\n             IntTy::I32 => 32,\n             IntTy::I64 => 64,\n             IntTy::I128 => 128,\n         },\n-        ty::TyUint(i) => match i {\n+        ty::Uint(i) => match i {\n             UintTy::Usize => tcx.data_layout.pointer_size.bits(),\n             UintTy::U8 => 8,\n             UintTy::U16 => 16,\n@@ -777,7 +777,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n     match typ.sty {\n-        ty::TyInt(IntTy::Isize) | ty::TyUint(UintTy::Usize) => true,\n+        ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => true,\n         _ => false,\n     }\n }\n@@ -973,7 +973,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-                        let to_nbits = if let ty::TyFloat(FloatTy::F32) = cast_to.sty {\n+                        let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.sty {\n                             32\n                         } else {\n                             64\n@@ -1014,7 +1014,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                         check_lossless(cx, expr, ex, cast_from, cast_to);\n                     },\n                     (false, false) => {\n-                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty)\n+                        if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty)\n                         {\n                             span_lint(\n                                 cx,\n@@ -1023,7 +1023,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                                 \"casting f64 to f32 may truncate the value\",\n                             );\n                         }\n-                        if let (&ty::TyFloat(FloatTy::F32), &ty::TyFloat(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty)\n+                        if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty)\n                         {\n                             span_lossless_lint(cx, expr, ex, cast_from, cast_to);\n                         }\n@@ -1032,9 +1032,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n             }\n \n             match &cast_from.sty {\n-                ty::TyFnDef(..) |\n-                ty::TyFnPtr(..) => {\n-                    if cast_to.is_numeric() && cast_to.sty != ty::TyUint(UintTy::Usize){\n+                ty::FnDef(..) |\n+                ty::FnPtr(..) => {\n+                    if cast_to.is_numeric() && cast_to.sty != ty::Uint(UintTy::Usize){\n                         let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n                         let pointer_nbits = cx.tcx.data_layout.pointer_size.bits();\n                         if to_nbits < pointer_nbits || (to_nbits == pointer_nbits && cast_to.is_signed()) {\n@@ -1063,8 +1063,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n             }\n \n             if_chain!{\n-                if let ty::TyRawPtr(from_ptr_ty) = &cast_from.sty;\n-                if let ty::TyRawPtr(to_ptr_ty) = &cast_to.sty;\n+                if let ty::RawPtr(from_ptr_ty) = &cast_from.sty;\n+                if let ty::RawPtr(to_ptr_ty) = &cast_to.sty;\n                 if let Some(from_align) = cx.layout_of(from_ptr_ty.ty).ok().map(|a| a.align.abi());\n                 if let Some(to_align) = cx.layout_of(to_ptr_ty.ty).ok().map(|a| a.align.abi());\n                 if from_align < to_align;\n@@ -1294,7 +1294,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n         if let ExprKind::Cast(ref e, _) = expr.node {\n             if let ExprKind::Lit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n-                    if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(expr.span) {\n+                    if ty::Uint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n@@ -1434,13 +1434,13 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -\n     let cv = constant(cx, cx.tables, expr)?.0;\n \n     let which = match (&ty.sty, cv) {\n-        (&ty::TyBool, Constant::Bool(false)) |\n-        (&ty::TyUint(_), Constant::Int(0)) => Minimum,\n-        (&ty::TyInt(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Minimum,\n+        (&ty::Bool, Constant::Bool(false)) |\n+        (&ty::Uint(_), Constant::Int(0)) => Minimum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Minimum,\n \n-        (&ty::TyBool, Constant::Bool(true)) => Maximum,\n-        (&ty::TyInt(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Maximum,\n-        (&ty::TyUint(uty), Constant::Int(i)) if clip(cx.tcx, u128::max_value(), uty) == i => Maximum,\n+        (&ty::Bool, Constant::Bool(true)) => Maximum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Maximum,\n+        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::max_value(), uty) == i => Maximum,\n \n         _ => return None,\n     };\n@@ -1574,7 +1574,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n             return None;\n         }\n         match pre_cast_ty.sty {\n-            ty::TyInt(int_ty) => Some(match int_ty {\n+            ty::Int(int_ty) => Some(match int_ty {\n                 IntTy::I8 => (FullInt::S(i128::from(i8::min_value())), FullInt::S(i128::from(i8::max_value()))),\n                 IntTy::I16 => (\n                     FullInt::S(i128::from(i16::min_value())),\n@@ -1591,7 +1591,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n                 IntTy::I128 => (FullInt::S(i128::min_value() as i128), FullInt::S(i128::max_value() as i128)),\n                 IntTy::Isize => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n             }),\n-            ty::TyUint(uint_ty) => Some(match uint_ty {\n+            ty::Uint(uint_ty) => Some(match uint_ty {\n                 UintTy::U8 => (FullInt::U(u128::from(u8::min_value())), FullInt::U(u128::from(u8::max_value()))),\n                 UintTy::U16 => (\n                     FullInt::U(u128::from(u16::min_value())),\n@@ -1619,8 +1619,8 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     let val = constant(cx, cx.tables, expr)?.0;\n     if let Constant::Int(const_int) = val {\n         match cx.tables.expr_ty(expr).sty {\n-            ty::TyInt(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n-            ty::TyUint(_) => Some(FullInt::U(const_int)),\n+            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+            ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n         }\n     } else {"}, {"sha": "65d58c4e55b882f48660152812e1203af48c49a7", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -48,7 +48,7 @@ pub struct Range<'a> {\n pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> Option<Range<'b>> {\n \n     let def_path = match cx.tables.expr_ty(expr).sty {\n-        ty::TyAdt(def, _) => cx.tcx.def_path(def.did),\n+        ty::Adt(def, _) => cx.tcx.def_path(def.did),\n         _ => return None,\n     };\n "}, {"sha": "b753f8072d03abf84bb3c18536551399b16cfb81", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -101,7 +101,7 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n /// Check if type is struct, enum or union type with given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n+        ty::Adt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n@@ -631,7 +631,7 @@ pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n /// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n     match ty.sty {\n-        ty::TyRef(_, ty, _) => walk_ptrs_ty(ty),\n+        ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n     }\n }\n@@ -641,7 +641,7 @@ pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.sty {\n-            ty::TyRef(_, ty, _) => inner(ty, depth + 1),\n+            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n         }\n     }\n@@ -842,7 +842,7 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n /// Return whether the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n+        ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n@@ -927,7 +927,7 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::TyAlias(id) |\n         Def::AssociatedTy(id) |\n         Def::TyParam(id) |\n-        Def::TyForeign(id) |\n+        Def::ForeignTy(id) |\n         Def::Struct(id) |\n         Def::StructCtor(id, ..) |\n         Def::Union(id) |"}, {"sha": "f86ce5ab7868a5b211b1dee683450da66b7807e1", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712d2d4fa106e9713f9578e120439892efed289b/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=712d2d4fa106e9713f9578e120439892efed289b", "patch": "@@ -37,8 +37,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::TyRef(_, ty, _) = cx.tables.expr_ty_adjusted(expr).sty;\n-            if let ty::TySlice(..) = ty.sty;\n+            if let ty::Ref(_, ty, _) = cx.tables.expr_ty_adjusted(expr).sty;\n+            if let ty::Slice(..) = ty.sty;\n             if let ExprKind::AddrOf(_, ref addressee) = expr.node;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n@@ -95,7 +95,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n-    if let ty::TyAdt(_, substs) = ty.sty {\n+    if let ty::Adt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {\n         panic!(\"The type of `vec!` is a not a struct?\");"}]}