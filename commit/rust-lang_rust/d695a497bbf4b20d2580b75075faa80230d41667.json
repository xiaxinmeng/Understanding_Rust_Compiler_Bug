{"sha": "d695a497bbf4b20d2580b75075faa80230d41667", "node_id": "C_kwDOAAsO6NoAKGQ2OTVhNDk3YmJmNGIyMGQyNTgwYjc1MDc1ZmFhODAyMzBkNDE2Njc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-16T11:36:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-16T11:36:19Z"}, "message": "Auto merge of #96482 - willcrichton:fix-trait-suggestion-for-binops, r=estebank\n\nAdd Output = expected type trait obligation for known binary operators\n\nThis PR is a follow-on to #94034 that addresses #96442. That is, after replacing the trait-suggestion logic in `op.rs` with a more generic path that analyzes a general set of `Obligation`s, then we lost some specificity in the suggestions where the bounds on the associated type `Output=` would not get suggested.\n\nThis PR fixes this issue by changing `FnCtxt::construct_obligation_for_trait` to include a new `ProjectionPredicate` obligation for binary operators that obliges that `Output` is the same as the expected type of the expression. Additionally, to get the expected type of the expression, this PR threads the `Expectation<'tcx>` structure throughout several functions.\n\nSee src/test/ui/generic-associated-types/missing-bounds.stderr for an example of how this works.\n\nOne side effect of this change is it causes type-check failures with binops to include additional information. Specifically, many now say\n\n```\nerror: type mismatch resolving `<Lhs as TheBinop>::Output == ExpectedTy`\n```\n\nIt's up for discussion whether this added context is worth it to the user.\n\nr? `@estebank`", "tree": {"sha": "03672505bf97758e06289b0544aa029499bd79f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03672505bf97758e06289b0544aa029499bd79f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d695a497bbf4b20d2580b75075faa80230d41667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d695a497bbf4b20d2580b75075faa80230d41667", "html_url": "https://github.com/rust-lang/rust/commit/d695a497bbf4b20d2580b75075faa80230d41667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d695a497bbf4b20d2580b75075faa80230d41667/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6c43cf8b98e4837bbee1cab225621001a3f2230", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c43cf8b98e4837bbee1cab225621001a3f2230", "html_url": "https://github.com/rust-lang/rust/commit/e6c43cf8b98e4837bbee1cab225621001a3f2230"}, {"sha": "2f15dfab0b444e757dcb32d935a716a5785b2155", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f15dfab0b444e757dcb32d935a716a5785b2155", "html_url": "https://github.com/rust-lang/rust/commit/2f15dfab0b444e757dcb32d935a716a5785b2155"}], "stats": {"total": 262, "additions": 218, "deletions": 44}, "files": [{"sha": "945cdfbb0e97812e305df649e27391ee790fc361", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -12,7 +12,7 @@ pub mod util;\n use crate::infer::canonical::Canonical;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, Ty, TyCtxt};\n+use crate::ty::{self, AdtKind, Predicate, Ty, TyCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n@@ -414,6 +414,7 @@ pub enum ObligationCauseCode<'tcx> {\n     BinOp {\n         rhs_span: Option<Span>,\n         is_lit: bool,\n+        output_pred: Option<Predicate<'tcx>>,\n     },\n }\n "}, {"sha": "3536d946db2793c9c08cf2cb0bf12bc76866e81a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -1033,6 +1033,24 @@ impl<'tcx> Predicate<'tcx> {\n         }\n     }\n \n+    pub fn to_opt_poly_projection_pred(self) -> Option<PolyProjectionPredicate<'tcx>> {\n+        let predicate = self.kind();\n+        match predicate.skip_binder() {\n+            PredicateKind::Projection(t) => Some(predicate.rebind(t)),\n+            PredicateKind::Trait(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::Coerce(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..)\n+            | PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        }\n+    }\n+\n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n         let predicate = self.kind();\n         match predicate.skip_binder() {"}, {"sha": "c1af1a05972399c90e21f31addb9a14e85724a35", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -665,6 +665,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n                                 trait_predicate,\n+                                None,\n                                 obligation.cause.body_id,\n                             );\n                         } else if !suggested {"}, {"sha": "bca80e7ab8abfb1aecc4599ea461f3f2d0b17c5d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -24,7 +24,8 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    ProjectionPredicate, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n@@ -172,6 +173,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n         body_id: hir::HirId,\n     );\n \n@@ -457,6 +459,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n+        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n         body_id: hir::HirId,\n     ) {\n         let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n@@ -589,9 +592,28 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n-                    let constraint = with_no_trimmed_paths!(\n+                    let mut constraint = with_no_trimmed_paths!(\n                         trait_pred.print_modifiers_and_trait_path().to_string()\n                     );\n+\n+                    if let Some(proj_pred) = proj_pred {\n+                        let ProjectionPredicate { projection_ty, term } = proj_pred.skip_binder();\n+                        let item = self.tcx.associated_item(projection_ty.item_def_id);\n+\n+                        // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n+                        // That should be extracted into a helper function.\n+                        if constraint.ends_with('>') {\n+                            constraint = format!(\n+                                \"{}, {}={}>\",\n+                                &constraint[..constraint.len() - 1],\n+                                item.name,\n+                                term.to_string()\n+                            );\n+                        } else {\n+                            constraint.push_str(&format!(\"<{}={}>\", item.name, term.to_string()));\n+                        }\n+                    }\n+\n                     if suggest_constraining_type_param(\n                         self.tcx,\n                         generics,\n@@ -2825,7 +2847,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) {\n         let rhs_span = match obligation.cause.code() {\n-            ObligationCauseCode::BinOp { rhs_span: Some(span), is_lit } if *is_lit => span,\n+            ObligationCauseCode::BinOp { rhs_span: Some(span), is_lit, .. } if *is_lit => span,\n             _ => return,\n         };\n         match ("}, {"sha": "b52cb8e99d186514a4506a1458ed1f0e52bc8885", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -282,11 +282,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match expr.kind {\n             ExprKind::Box(subexpr) => self.check_expr_box(subexpr, expected),\n             ExprKind::Lit(ref lit) => self.check_lit(&lit, expected),\n-            ExprKind::Binary(op, lhs, rhs) => self.check_binop(expr, op, lhs, rhs),\n+            ExprKind::Binary(op, lhs, rhs) => self.check_binop(expr, op, lhs, rhs, expected),\n             ExprKind::Assign(lhs, rhs, span) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n-            ExprKind::AssignOp(op, lhs, rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n+            ExprKind::AssignOp(op, lhs, rhs) => {\n+                self.check_binop_assign(expr, op, lhs, rhs, expected)\n+            }\n             ExprKind::Unary(unop, oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n             ExprKind::AddrOf(kind, mutbl, oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n@@ -404,14 +406,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 hir::UnOp::Not => {\n-                    let result = self.check_user_unop(expr, oprnd_t, unop);\n+                    let result = self.check_user_unop(expr, oprnd_t, unop, expected_inner);\n                     // If it's builtin, we can reuse the type, this helps inference.\n                     if !(oprnd_t.is_integral() || *oprnd_t.kind() == ty::Bool) {\n                         oprnd_t = result;\n                     }\n                 }\n                 hir::UnOp::Neg => {\n-                    let result = self.check_user_unop(expr, oprnd_t, unop);\n+                    let result = self.check_user_unop(expr, oprnd_t, unop, expected_inner);\n                     // If it's builtin, we can reuse the type, this helps inference.\n                     if !oprnd_t.is_numeric() {\n                         oprnd_t = result;"}, {"sha": "d33b5b21403624d10d10672050a91c94fb154d0e", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -413,6 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, ExprKind::Lit(_))),\n+                    output_pred: None,\n                 },\n             ),\n             self.param_env,"}, {"sha": "c09f63f1e8f117844bc06b014718c8a6351d44e4", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -10,7 +10,7 @@ mod suggest;\n pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n-use crate::check::FnCtxt;\n+use crate::check::{Expectation, FnCtxt};\n use crate::ObligationCause;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n@@ -20,8 +20,10 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TypeVisitable};\n-use rustc_middle::ty::{DefIdTree, GenericParamDefKind};\n+use rustc_middle::ty::{\n+    self, AssocKind, DefIdTree, GenericParamDefKind, ProjectionPredicate, ProjectionTy, Term,\n+    ToPredicate, Ty, TypeVisitable,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n@@ -318,6 +320,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         opt_input_type: Option<Ty<'tcx>>,\n         opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        expected: Expectation<'tcx>,\n     ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n     {\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n@@ -339,6 +342,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n+        let opt_output_ty =\n+            expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n+        let opt_output_assoc_item = self.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n+            self.tcx,\n+            Ident::from_str(\"Output\"),\n+            AssocKind::Type,\n+            trait_def_id,\n+        );\n+        let output_pred =\n+            opt_output_ty.zip(opt_output_assoc_item).map(|(output_ty, output_assoc_item)| {\n+                ty::Binder::dummy(ty::PredicateKind::Projection(ProjectionPredicate {\n+                    projection_ty: ProjectionTy { substs, item_def_id: output_assoc_item.def_id },\n+                    term: Term::Ty(output_ty),\n+                }))\n+                .to_predicate(self.tcx)\n+            });\n+\n         (\n             traits::Obligation::new(\n                 traits::ObligationCause::new(\n@@ -348,6 +368,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_span: opt_input_expr.map(|expr| expr.span),\n                         is_lit: opt_input_expr\n                             .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                        output_pred,\n                     },\n                 ),\n                 self.param_env,\n@@ -397,13 +418,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         opt_input_type: Option<Ty<'tcx>>,\n         opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         let (obligation, substs) = self.obligation_for_op_method(\n             span,\n             trait_def_id,\n             self_ty,\n             opt_input_type,\n             opt_input_expr,\n+            expected,\n         );\n         self.construct_obligation_for_trait(\n             span,\n@@ -505,6 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                    output_pred: None,\n                 },\n             )\n         } else {"}, {"sha": "d4bb3d43effe41afcb28a460451109ea1f947c7b", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -2,10 +2,12 @@\n \n use super::method::MethodCallee;\n use super::{has_expected_num_generic_args, FnCtxt};\n+use crate::check::Expectation;\n use rustc_ast as ast;\n use rustc_errors::{self, struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n@@ -30,9 +32,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: hir::BinOp,\n         lhs: &'tcx hir::Expr<'tcx>,\n         rhs: &'tcx hir::Expr<'tcx>,\n+        expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let (lhs_ty, rhs_ty, return_ty) =\n-            self.check_overloaded_binop(expr, lhs, rhs, op, IsAssign::Yes);\n+            self.check_overloaded_binop(expr, lhs, rhs, op, IsAssign::Yes, expected);\n \n         let ty =\n             if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n@@ -50,6 +53,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Some(rhs_ty),\n                         Some(rhs),\n                         Op::Binary(op, IsAssign::Yes),\n+                        expected,\n                     )\n                     .is_ok()\n                 {\n@@ -70,6 +74,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: hir::BinOp,\n         lhs_expr: &'tcx hir::Expr<'tcx>,\n         rhs_expr: &'tcx hir::Expr<'tcx>,\n+        expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n@@ -94,8 +99,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Otherwise, we always treat operators as if they are\n                 // overloaded. This is the way to be most flexible w/r/t\n                 // types that get inferred.\n-                let (lhs_ty, rhs_ty, return_ty) =\n-                    self.check_overloaded_binop(expr, lhs_expr, rhs_expr, op, IsAssign::No);\n+                let (lhs_ty, rhs_ty, return_ty) = self.check_overloaded_binop(\n+                    expr,\n+                    lhs_expr,\n+                    rhs_expr,\n+                    op,\n+                    IsAssign::No,\n+                    expected,\n+                );\n \n                 // Supply type inference hints if relevant. Probably these\n                 // hints should be enforced during select as part of the\n@@ -176,6 +187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rhs_expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n         is_assign: IsAssign,\n+        expected: Expectation<'tcx>,\n     ) -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>) {\n         debug!(\n             \"check_overloaded_binop(expr.hir_id={}, op={:?}, is_assign={:?})\",\n@@ -222,6 +234,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(rhs_ty_var),\n             Some(rhs_expr),\n             Op::Binary(op, is_assign),\n+            expected,\n         );\n \n         // see `NB` above\n@@ -282,7 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n                 let source_map = self.tcx.sess.source_map();\n-                let (mut err, missing_trait, _use_output) = match is_assign {\n+                let (mut err, missing_trait, use_output) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -406,6 +419,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 rhs_expr,\n                                 op,\n                                 is_assign,\n+                                expected,\n                             );\n                             self.add_type_neq_err_label(\n                                 &mut err,\n@@ -415,6 +429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 lhs_expr,\n                                 op,\n                                 is_assign,\n+                                expected,\n                             );\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n@@ -429,6 +444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Some(rhs_ty),\n                             Some(rhs_expr),\n                             Op::Binary(op, is_assign),\n+                            expected,\n                         )\n                         .is_ok()\n                     {\n@@ -490,19 +506,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Some(rhs_ty),\n                                 Some(rhs_expr),\n                                 Op::Binary(op, is_assign),\n+                                expected,\n                             )\n                             .unwrap_err();\n-                        let predicates = errors\n-                            .into_iter()\n-                            .filter_map(|error| error.obligation.predicate.to_opt_poly_trait_pred())\n-                            .collect::<Vec<_>>();\n-                        if !predicates.is_empty() {\n-                            for pred in predicates {\n-                                self.infcx.suggest_restricting_param_bound(\n-                                    &mut err,\n-                                    pred,\n-                                    self.body_id,\n-                                );\n+                        if !errors.is_empty() {\n+                            for error in errors {\n+                                if let Some(trait_pred) =\n+                                    error.obligation.predicate.to_opt_poly_trait_pred()\n+                                {\n+                                    let proj_pred = match error.obligation.cause.code() {\n+                                        ObligationCauseCode::BinOp {\n+                                            output_pred: Some(output_pred),\n+                                            ..\n+                                        } if use_output => {\n+                                            output_pred.to_opt_poly_projection_pred()\n+                                        }\n+                                        _ => None,\n+                                    };\n+\n+                                    self.infcx.suggest_restricting_param_bound(\n+                                        &mut err,\n+                                        trait_pred,\n+                                        proj_pred,\n+                                        self.body_id,\n+                                    );\n+                                }\n                             }\n                         } else if *ty != lhs_ty {\n                             // When we know that a missing bound is responsible, we don't show\n@@ -532,6 +560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         other_expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n         is_assign: IsAssign,\n+        expected: Expectation<'tcx>,\n     ) -> bool /* did we suggest to call a function because of missing parentheses? */ {\n         err.span_label(span, ty.to_string());\n         if let FnDef(def_id, _) = *ty.kind() {\n@@ -561,6 +590,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     Some(other_ty),\n                     Some(other_expr),\n                     Op::Binary(op, is_assign),\n+                    expected,\n                 )\n                 .is_ok()\n             {\n@@ -677,9 +707,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ex: &'tcx hir::Expr<'tcx>,\n         operand_ty: Ty<'tcx>,\n         op: hir::UnOp,\n+        expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span)) {\n+        match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span), expected) {\n             Ok(method) => {\n                 self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n@@ -712,6 +743,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.infcx.suggest_restricting_param_bound(\n                                 &mut err,\n                                 pred,\n+                                None,\n                                 self.body_id,\n                             );\n                         }\n@@ -772,6 +804,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         other_ty: Option<Ty<'tcx>>,\n         other_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         op: Op,\n+        expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n         let lang = self.tcx.lang_items();\n \n@@ -856,7 +889,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let opname = Ident::with_dummy_span(opname);\n         let method = trait_did.and_then(|trait_did| {\n-            self.lookup_op_method_in_trait(span, opname, trait_did, lhs_ty, other_ty, other_ty_expr)\n+            self.lookup_op_method_in_trait(\n+                span,\n+                opname,\n+                trait_did,\n+                lhs_ty,\n+                other_ty,\n+                other_ty_expr,\n+                expected,\n+            )\n         });\n \n         match (method, trait_did) {\n@@ -867,8 +908,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             (None, None) => Err(vec![]),\n             (None, Some(trait_did)) => {\n-                let (obligation, _) =\n-                    self.obligation_for_op_method(span, trait_did, lhs_ty, other_ty, other_ty_expr);\n+                let (obligation, _) = self.obligation_for_op_method(\n+                    span,\n+                    trait_did,\n+                    lhs_ty,\n+                    other_ty,\n+                    other_ty_expr,\n+                    expected,\n+                );\n                 let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n                 fulfill.register_predicate_obligation(self, obligation);\n                 Err(fulfill.select_where_possible(&self.infcx))"}, {"sha": "2315810a47ace850f1f6b27ae385604690f2cfc7", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -0,0 +1,46 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add + Add<Output = B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add + Add<Output = B>> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B: std::ops::Add<Output=B>> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+struct E<B>(B);\n+\n+impl<B: Add + Add<Output = B>> Add for E<B> where B: Add<Output = B> {\n+    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ffafff5e9f586d2543061aaaa616eec501040f8a", "filename": "src/test/ui/generic-associated-types/missing-bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n use std::ops::Add;\n \n struct A<B>(B);"}, {"sha": "138c642dd7952181918a88d5e492b826d6af4cbb", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -1,5 +1,5 @@\n error: equality constraints are not yet supported in `where` clauses\n-  --> $DIR/missing-bounds.rs:35:33\n+  --> $DIR/missing-bounds.rs:37:33\n    |\n LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n@@ -11,7 +11,7 @@ LL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n    |                                 ~~~~~~~~~~~~~~~~~~\n \n error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:9:11\n+  --> $DIR/missing-bounds.rs:11:11\n    |\n LL | impl<B> Add for A<B> where B: Add {\n    |      - this type parameter\n@@ -24,7 +24,7 @@ LL |         A(self.0 + rhs.0)\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n note: tuple struct defined here\n-  --> $DIR/missing-bounds.rs:3:8\n+  --> $DIR/missing-bounds.rs:5:8\n    |\n LL | struct A<B>(B);\n    |        ^\n@@ -34,7 +34,7 @@ LL | impl<B> Add for A<B> where B: Add + Add<Output = B> {\n    |                                   +++++++++++++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:19:14\n+  --> $DIR/missing-bounds.rs:21:14\n    |\n LL | impl<B: Add> Add for C<B> {\n    |      - this type parameter\n@@ -47,7 +47,7 @@ LL |         Self(self.0 + rhs.0)\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n note: tuple struct defined here\n-  --> $DIR/missing-bounds.rs:13:8\n+  --> $DIR/missing-bounds.rs:15:8\n    |\n LL | struct C<B>(B);\n    |        ^\n@@ -57,7 +57,7 @@ LL | impl<B: Add + Add<Output = B>> Add for C<B> {\n    |             +++++++++++++++++\n \n error[E0369]: cannot add `B` to `B`\n-  --> $DIR/missing-bounds.rs:29:21\n+  --> $DIR/missing-bounds.rs:31:21\n    |\n LL |         Self(self.0 + rhs.0)\n    |              ------ ^ ----- B\n@@ -66,11 +66,11 @@ LL |         Self(self.0 + rhs.0)\n    |\n help: consider restricting type parameter `B`\n    |\n-LL | impl<B: std::ops::Add> Add for D<B> {\n-   |       +++++++++++++++\n+LL | impl<B: std::ops::Add<Output=B>> Add for D<B> {\n+   |       +++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/missing-bounds.rs:40:14\n+  --> $DIR/missing-bounds.rs:42:14\n    |\n LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n    |      - this type parameter\n@@ -83,7 +83,7 @@ LL |         Self(self.0 + rhs.0)\n    = note: expected type parameter `B`\n              found associated type `<B as Add>::Output`\n note: tuple struct defined here\n-  --> $DIR/missing-bounds.rs:33:8\n+  --> $DIR/missing-bounds.rs:35:8\n    |\n LL | struct E<B>(B);\n    |        ^"}, {"sha": "73ca9f97b43a360b986a47f9be217e01ba766851", "filename": "src/test/ui/suggestions/issue-97677.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn add_ten<N: std::ops::Add<i32, Output=N>>(n: N) -> N {\n+    n + 10\n+    //~^ ERROR cannot add `{integer}` to `N`\n+}\n+\n+fn main() { add_ten(0); }"}, {"sha": "2abf2af33845c5a5d8ea8afec8da5cc523109557", "filename": "src/test/ui/suggestions/issue-97677.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.rs?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -1,6 +1,8 @@\n+// run-rustfix\n+\n fn add_ten<N>(n: N) -> N {\n     n + 10\n     //~^ ERROR cannot add `{integer}` to `N`\n }\n \n-fn main() {}\n+fn main() { add_ten(0); }"}, {"sha": "069b184ac636c45bdfaa6dc045afca4f647f3c57", "filename": "src/test/ui/suggestions/issue-97677.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d695a497bbf4b20d2580b75075faa80230d41667/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr?ref=d695a497bbf4b20d2580b75075faa80230d41667", "patch": "@@ -1,5 +1,5 @@\n error[E0369]: cannot add `{integer}` to `N`\n-  --> $DIR/issue-97677.rs:2:7\n+  --> $DIR/issue-97677.rs:4:7\n    |\n LL |     n + 10\n    |     - ^ -- {integer}\n@@ -8,8 +8,8 @@ LL |     n + 10\n    |\n help: consider restricting type parameter `N`\n    |\n-LL | fn add_ten<N: std::ops::Add<i32>>(n: N) -> N {\n-   |             ++++++++++++++++++++\n+LL | fn add_ten<N: std::ops::Add<i32, Output=N>>(n: N) -> N {\n+   |             ++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}]}