{"sha": "0c766cb8bc62fcd016165db2313188e7f6de71dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNzY2Y2I4YmM2MmZjZDAxNjE2NWRiMjMxMzE4OGU3ZjZkZTcxZGQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-09T00:23:29Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-09T00:24:39Z"}, "message": "save-analysis: API-ify methods", "tree": {"sha": "723f4e6e7994c273a8e9f1127c5942738433f74d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/723f4e6e7994c273a8e9f1127c5942738433f74d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c766cb8bc62fcd016165db2313188e7f6de71dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c766cb8bc62fcd016165db2313188e7f6de71dd", "html_url": "https://github.com/rust-lang/rust/commit/0c766cb8bc62fcd016165db2313188e7f6de71dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c766cb8bc62fcd016165db2313188e7f6de71dd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df5a1ca8809d2d57e18cfe0c9d186a5699da6414", "url": "https://api.github.com/repos/rust-lang/rust/commits/df5a1ca8809d2d57e18cfe0c9d186a5699da6414", "html_url": "https://github.com/rust-lang/rust/commit/df5a1ca8809d2d57e18cfe0c9d186a5699da6414"}], "stats": {"total": 210, "additions": 116, "deletions": 94}, "files": [{"sha": "c5196d09e00a14f48ad97dc7c3d2afd28e872ea7", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 26, "deletions": 90, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0c766cb8bc62fcd016165db2313188e7f6de71dd/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c766cb8bc62fcd016165db2313188e7f6de71dd/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=0c766cb8bc62fcd016165db2313188e7f6de71dd", "patch": "@@ -34,13 +34,11 @@ use session::Session;\n \n use middle::def;\n use middle::ty::{self, Ty};\n-use rustc::ast_map::NodeItem;\n \n use std::cell::Cell;\n use std::fs::File;\n use std::path::Path;\n \n-use syntax::ast_util;\n use syntax::ast::{self, NodeId, DefId};\n use syntax::codemap::*;\n use syntax::parse::token::{self, get_ident, keywords};\n@@ -298,101 +296,34 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_method(&mut self, sig: &ast::MethodSig,\n+    fn process_method(&mut self,\n+                      sig: &ast::MethodSig,\n                       body: Option<&ast::Block>,\n-                      id: ast::NodeId, name: ast::Name,\n+                      id: ast::NodeId,\n+                      name: ast::Name,\n                       span: Span) {\n         if generated_code(span) {\n             return;\n         }\n \n         debug!(\"process_method: {}:{}\", id, token::get_name(name));\n \n-        let scope_id;\n-        // The qualname for a method is the trait name or name of the struct in an impl in\n-        // which the method is declared in, followed by the method's name.\n-        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n-            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n-                NodeItem(item) => {\n-                    scope_id = item.id;\n-                    match item.node {\n-                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n-                            let mut result = String::from(\"<\");\n-                            result.push_str(&ty_to_string(&**ty));\n-\n-                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n-                                Some(def_id) => {\n-                                    result.push_str(\" as \");\n-                                    result.push_str(\n-                                        &self.tcx.item_path_str(def_id));\n-                                },\n-                                None => {}\n-                            }\n-                            result.push_str(\">\");\n-                            result\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Container {} for method {} not an impl?\",\n-                                         impl_id.node, id));\n-                        },\n-                    }\n-                },\n-                _ => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n-                },\n-            },\n-            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n-                Some(def_id) => {\n-                    scope_id = def_id.node;\n-                    match self.tcx.map.get(def_id.node) {\n-                        NodeItem(_) => {\n-                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n-                        }\n-                        _ => {\n-                            self.sess.span_bug(span,\n-                                &format!(\"Could not find container {} for method {}\",\n-                                         def_id.node, id));\n-                        }\n-                    }\n-                },\n-                None => {\n-                    self.sess.span_bug(span,\n-                        &format!(\"Could not find container for method {}\", id));\n-                },\n-            },\n-        };\n-\n-        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n+        let method_data = self.save_ctxt.get_method_data(id, name, span);\n \n-        // record the decl for this def (if it has one)\n-        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n-            .and_then(|new_id| {\n-                let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n-                    Some(def_id)\n-                } else {\n-                    None\n-                }\n-            });\n-\n-        let sub_span = self.span.sub_span_after_keyword(span, keywords::Fn);\n         if body.is_some() {\n             self.fmt.method_str(span,\n-                                sub_span,\n-                                id,\n-                                qualname,\n-                                decl_id,\n-                                scope_id);\n-            self.process_formals(&sig.decl.inputs, qualname);\n+                                Some(method_data.span),\n+                                method_data.id,\n+                                &method_data.qualname,\n+                                method_data.declaration,\n+                                method_data.scope);\n+            self.process_formals(&sig.decl.inputs, &method_data.qualname);\n         } else {\n             self.fmt.method_decl_str(span,\n-                                     sub_span,\n-                                     id,\n-                                     qualname,\n-                                     scope_id);\n+                                     Some(method_data.span),\n+                                     method_data.id,\n+                                     &method_data.qualname,\n+                                     method_data.scope);\n         }\n \n         // walk arg and return types\n@@ -411,7 +342,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         self.process_generic_params(&sig.generics,\n                                     span,\n-                                    qualname,\n+                                    &method_data.qualname,\n                                     id);\n     }\n \n@@ -432,7 +363,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                 parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            down_cast_data!(field_data, VariableData, self, field.span);\n             self.fmt.field_str(field.span,\n                                Some(field_data.span),\n                                field_data.id,\n@@ -1087,8 +1017,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                    trait_item.span, &*ty, &*expr);\n             }\n             ast::MethodTraitItem(ref sig, ref body) => {\n-                self.process_method(sig, body.as_ref().map(|x| &**x),\n-                                    trait_item.id, trait_item.ident.name, trait_item.span);\n+                self.process_method(sig,\n+                                    body.as_ref().map(|x| &**x),\n+                                    trait_item.id,\n+                                    trait_item.ident.name,\n+                                    trait_item.span);\n             }\n             ast::ConstTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n@@ -1102,8 +1035,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                    impl_item.span, &ty, &expr);\n             }\n             ast::MethodImplItem(ref sig, ref body) => {\n-                self.process_method(sig, Some(body), impl_item.id,\n-                                    impl_item.ident.name, impl_item.span);\n+                self.process_method(sig,\n+                                    Some(body),\n+                                    impl_item.id,\n+                                    impl_item.ident.name,\n+                                    impl_item.span);\n             }\n             ast::TypeImplItem(_) |\n             ast::MacImplItem(_) => {}"}, {"sha": "4e0b34b7ef8ac3efe2d06c3800bfb5b39a0a66be", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0c766cb8bc62fcd016165db2313188e7f6de71dd/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c766cb8bc62fcd016165db2313188e7f6de71dd/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=0c766cb8bc62fcd016165db2313188e7f6de71dd", "patch": "@@ -15,6 +15,8 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n+use rustc::ast_map::NodeItem;\n+\n use syntax::{attr};\n use syntax::ast::{self, NodeId, DefId};\n use syntax::ast_util;\n@@ -227,7 +229,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: selfenclosing_scope(item.id),\n+                    scope: self.enclosing_scope(item.id),\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n                 })\n@@ -303,7 +305,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<Data> {\n+    pub fn get_field_data(&self, field: &ast::StructField, scope: NodeId) -> Option<VariableData> {\n         match field.node.kind {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n@@ -313,20 +315,104 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n                                                .to_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n-                Some(Data::VariableData(VariableData {\n+                Some(VariableData {\n                     id: field.node.id,\n                     name: get_ident(ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: scope,\n                     value: \"\".to_owned(),\n                     type_value: typ,\n-                }))\n+                })\n             },\n             _ => None,\n         }\n     }\n \n+    // FIXME would be nice to take a MethodItem here, but the ast provides both\n+    // trait and impl flavours, so the caller must do the disassembly.\n+    pub fn get_method_data(&self,\n+                           id: ast::NodeId,\n+                           name: ast::Name,\n+                           span: Span) -> FunctionData {\n+        // The qualname for a method is the trait name or name of the struct in an impl in\n+        // which the method is declared in, followed by the method's name.\n+        let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {\n+            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n+                NodeItem(item) => {\n+                    match item.node {\n+                        ast::ItemImpl(_, _, _, _, ref ty, _) => {\n+                            let mut result = String::from(\"<\");\n+                            result.push_str(&ty_to_string(&**ty));\n+\n+                            match self.tcx.trait_of_item(ast_util::local_def(id)) {\n+                                Some(def_id) => {\n+                                    result.push_str(\" as \");\n+                                    result.push_str(\n+                                        &self.tcx.item_path_str(def_id));\n+                                },\n+                                None => {}\n+                            }\n+                            result.push_str(\">\");\n+                            result\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(span,\n+                                &format!(\"Container {} for method {} not an impl?\",\n+                                         impl_id.node, id));\n+                        },\n+                    }\n+                },\n+                _ => {\n+                    self.tcx.sess.span_bug(span,\n+                        &format!(\"Container {} for method {} is not a node item {:?}\",\n+                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n+                },\n+            },\n+            None => match self.tcx.trait_of_item(ast_util::local_def(id)) {\n+                Some(def_id) => {\n+                    match self.tcx.map.get(def_id.node) {\n+                        NodeItem(_) => {\n+                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(span,\n+                                &format!(\"Could not find container {} for method {}\",\n+                                         def_id.node, id));\n+                        }\n+                    }\n+                },\n+                None => {\n+                    self.tcx.sess.span_bug(span,\n+                        &format!(\"Could not find container for method {}\", id));\n+                },\n+            },\n+        };\n+\n+        let qualname = format!(\"{}::{}\", qualname, &token::get_name(name));\n+\n+        let decl_id = self.tcx.trait_item_of_item(ast_util::local_def(id))\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n+                } else {\n+                    None\n+                }\n+            });\n+\n+        let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n+\n+        FunctionData {\n+            id: id,\n+            name: token::get_name(name).to_string(),\n+            qualname: qualname,\n+            declaration: decl_id,\n+            span: sub_span.unwrap(),\n+            scope: self.enclosing_scope(id),\n+        }\n+    }\n+\n     pub fn get_trait_ref_data(&self,\n                               trait_ref: &ast::TraitRef,\n                               parent: NodeId)"}]}