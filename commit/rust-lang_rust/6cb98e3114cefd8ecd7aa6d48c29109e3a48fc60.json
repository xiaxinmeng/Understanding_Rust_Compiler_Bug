{"sha": "6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYjk4ZTMxMTRjZWZkOGVjZDdhYTZkNDhjMjkxMDllM2E0OGZjNjA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-22T00:14:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-22T00:14:41Z"}, "message": "Rollup merge of #75711 - CohenArthur:split-up-astconv, r=oli-obk\n\nSplit `astconv.rs` into its own submodule\n\nFixes #67418\n\nThis changed induced a few changes across the Type checker, but only there. Mostly, it was just renaming `Self::` into something else to call specific methods from a subtrait instead of having a 2500+ lines one.\n\nI split up the `astconv.rs` file into its own module. This way, directives such as\n```rust\nuse crate::astconv::AstConv;\n```\nare still valid, and doing\n```rust\nuse crate::astconv::{AstConv, AstConvGeneric};\n```\nis possible\n\n(instead of having two modules, one named `astconv_generic.rs` for example and `astconv.rs`)\n\nI'm not entirely sure that the name `AstConvGeneric` is a good one. However, only methods related to lifetimes or generics have been moved over to this module. Sorry about the large diff.\n\nI'd be very happy to make any correction you deem necessary.\n\nr? @oli-obk", "tree": {"sha": "6309d2474cfc1f3e406e9eb97c2188e123fa7d4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6309d2474cfc1f3e406e9eb97c2188e123fa7d4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfQGNxCRBK7hj4Ov3rIwAAdHIIAJQcmmw9Yscc7zlU2B1MItHa\nZRSMOIhKmlPxsL9QJWCxqMxreNemfL0Yl0tlJpG0B2ySrM5QhesjweDKRRbtP4FT\nec5J7MLD+Jt6GK93zffSdLUcTERjbrMxutUoQDRebJpcG/9ulFXv42I12E0DL+sQ\ng+FLRuz/FuLOUYbYweo9BuwudIEFSXR4MKi3/mDzKFaKiIDnVxn37uvatLa206x9\nb1iev/GY9lm/yrc9oOAWscU7dDvkhm1Fi3EuG01rngLY0p52Hdr1pyqf/GHTPm5d\nzGGaHWBpVtBruOGQAeFfMlZ6BeKImMeT50/PD388KaIB/cYjEZN5peKHHKXxp88=\n=1wXK\n-----END PGP SIGNATURE-----\n", "payload": "tree 6309d2474cfc1f3e406e9eb97c2188e123fa7d4c\nparent 8af33add1ac4e5430e9b45e84c2ff13d17c70140\nparent e6642e41e0e827557dce08a3c0522e93c751e39c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1598055281 +0200\ncommitter GitHub <noreply@github.com> 1598055281 +0200\n\nRollup merge of #75711 - CohenArthur:split-up-astconv, r=oli-obk\n\nSplit `astconv.rs` into its own submodule\n\nFixes #67418\n\nThis changed induced a few changes across the Type checker, but only there. Mostly, it was just renaming `Self::` into something else to call specific methods from a subtrait instead of having a 2500+ lines one.\n\nI split up the `astconv.rs` file into its own module. This way, directives such as\n```rust\nuse crate::astconv::AstConv;\n```\nare still valid, and doing\n```rust\nuse crate::astconv::{AstConv, AstConvGeneric};\n```\nis possible\n\n(instead of having two modules, one named `astconv_generic.rs` for example and `astconv.rs`)\n\nI'm not entirely sure that the name `AstConvGeneric` is a good one. However, only methods related to lifetimes or generics have been moved over to this module. Sorry about the large diff.\n\nI'd be very happy to make any correction you deem necessary.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "html_url": "https://github.com/rust-lang/rust/commit/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8af33add1ac4e5430e9b45e84c2ff13d17c70140", "url": "https://api.github.com/repos/rust-lang/rust/commits/8af33add1ac4e5430e9b45e84c2ff13d17c70140", "html_url": "https://github.com/rust-lang/rust/commit/8af33add1ac4e5430e9b45e84c2ff13d17c70140"}, {"sha": "e6642e41e0e827557dce08a3c0522e93c751e39c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6642e41e0e827557dce08a3c0522e93c751e39c", "html_url": "https://github.com/rust-lang/rust/commit/e6642e41e0e827557dce08a3c0522e93c751e39c"}], "stats": {"total": 2155, "additions": 1096, "deletions": 1059}, "files": [{"sha": "685243f54cb903b35069fac7c876255b0a404caf", "filename": "src/librustc_typeck/astconv/errors.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv%2Ferrors.rs?ref=6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "patch": "@@ -0,0 +1,388 @@\n+use crate::astconv::AstConv;\n+use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{pluralize, struct_span_err, Applicability};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty;\n+use rustc_session::parse::feature_err;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::collections::BTreeSet;\n+\n+impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n+    /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n+    /// the type parameter's name as a placeholder.\n+    pub(crate) fn complain_about_missing_type_params(\n+        &self,\n+        missing_type_params: Vec<String>,\n+        def_id: DefId,\n+        span: Span,\n+        empty_generic_args: bool,\n+    ) {\n+        if missing_type_params.is_empty() {\n+            return;\n+        }\n+        let display =\n+            missing_type_params.iter().map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            span,\n+            E0393,\n+            \"the type parameter{} {} must be explicitly specified\",\n+            pluralize!(missing_type_params.len()),\n+            display,\n+        );\n+        err.span_label(\n+            self.tcx().def_span(def_id),\n+            &format!(\n+                \"type parameter{} {} must be specified for this\",\n+                pluralize!(missing_type_params.len()),\n+                display,\n+            ),\n+        );\n+        let mut suggested = false;\n+        if let (Ok(snippet), true) = (\n+            self.tcx().sess.source_map().span_to_snippet(span),\n+            // Don't suggest setting the type params if there are some already: the order is\n+            // tricky to get right and the user will already know what the syntax is.\n+            empty_generic_args,\n+        ) {\n+            if snippet.ends_with('>') {\n+                // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n+                // we would have to preserve the right order. For now, as clearly the user is\n+                // aware of the syntax, we do nothing.\n+            } else {\n+                // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                // least we can clue them to the correct syntax `Iterator<Type>`.\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"set the type parameter{plural} to the desired type{plural}\",\n+                        plural = pluralize!(missing_type_params.len()),\n+                    ),\n+                    format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n+                    Applicability::HasPlaceholders,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        if !suggested {\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"missing reference{} to {}\",\n+                    pluralize!(missing_type_params.len()),\n+                    display,\n+                ),\n+            );\n+        }\n+        err.note(\n+            \"because of the default `Self` reference, type parameters must be \\\n+                  specified on object types\",\n+        );\n+        err.emit();\n+    }\n+\n+    /// When the code is using the `Fn` traits directly, instead of the `Fn(A) -> B` syntax, emit\n+    /// an error and attempt to build a reasonable structured suggestion.\n+    pub(crate) fn complain_about_internal_fn_trait(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        trait_segment: &'a hir::PathSegment<'a>,\n+    ) {\n+        let trait_def = self.tcx().trait_def(trait_def_id);\n+\n+        if !self.tcx().features().unboxed_closures\n+            && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n+        {\n+            let sess = &self.tcx().sess.parse_sess;\n+            // For now, require that parenthetical notation be used only with `Fn()` etc.\n+            let (msg, sugg) = if trait_def.paren_sugar {\n+                (\n+                    \"the precise format of `Fn`-family traits' type parameters is subject to \\\n+                     change\",\n+                    Some(format!(\n+                        \"{}{} -> {}\",\n+                        trait_segment.ident,\n+                        trait_segment\n+                            .args\n+                            .as_ref()\n+                            .and_then(|args| args.args.get(0))\n+                            .and_then(|arg| match arg {\n+                                hir::GenericArg::Type(ty) => match ty.kind {\n+                                    hir::TyKind::Tup(t) => t\n+                                        .iter()\n+                                        .map(|e| sess.source_map().span_to_snippet(e.span))\n+                                        .collect::<Result<Vec<_>, _>>()\n+                                        .map(|a| a.join(\", \")),\n+                                    _ => sess.source_map().span_to_snippet(ty.span),\n+                                }\n+                                .map(|s| format!(\"({})\", s))\n+                                .ok(),\n+                                _ => None,\n+                            })\n+                            .unwrap_or_else(|| \"()\".to_string()),\n+                        trait_segment\n+                            .generic_args()\n+                            .bindings\n+                            .iter()\n+                            .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n+                                (true, hir::TypeBindingKind::Equality { ty }) => {\n+                                    sess.source_map().span_to_snippet(ty.span).ok()\n+                                }\n+                                _ => None,\n+                            })\n+                            .unwrap_or_else(|| \"()\".to_string()),\n+                    )),\n+                )\n+            } else {\n+                (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n+            };\n+            let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n+            if let Some(sugg) = sugg {\n+                let msg = \"use parenthetical notation instead\";\n+                err.span_suggestion(span, msg, sugg, Applicability::MaybeIncorrect);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    pub(crate) fn complain_about_assoc_type_not_found<I>(\n+        &self,\n+        all_candidates: impl Fn() -> I,\n+        ty_param_name: &str,\n+        assoc_name: Ident,\n+        span: Span,\n+    ) where\n+        I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+    {\n+        // The fallback span is needed because `assoc_name` might be an `Fn()`'s `Output` without a\n+        // valid span, so we point at the whole path segment instead.\n+        let span = if assoc_name.span != DUMMY_SP { assoc_name.span } else { span };\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            span,\n+            E0220,\n+            \"associated type `{}` not found for `{}`\",\n+            assoc_name,\n+            ty_param_name\n+        );\n+\n+        let all_candidate_names: Vec<_> = all_candidates()\n+            .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n+            .flatten()\n+            .filter_map(\n+                |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n+            )\n+            .collect();\n+\n+        if let (Some(suggested_name), true) = (\n+            find_best_match_for_name(all_candidate_names.iter(), assoc_name.name, None),\n+            assoc_name.span != DUMMY_SP,\n+        ) {\n+            err.span_suggestion(\n+                assoc_name.span,\n+                \"there is an associated type with a similar name\",\n+                suggested_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(span, format!(\"associated type `{}` not found\", assoc_name));\n+        }\n+\n+        err.emit();\n+    }\n+\n+    /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n+    /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n+    /// same trait bound have the same name (as they come from different super-traits), we instead\n+    /// emit a generic note suggesting using a `where` clause to constraint instead.\n+    pub(crate) fn complain_about_missing_associated_types(\n+        &self,\n+        associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n+        potential_assoc_types: Vec<Span>,\n+        trait_bounds: &[hir::PolyTraitRef<'_>],\n+    ) {\n+        if associated_types.values().all(|v| v.is_empty()) {\n+            return;\n+        }\n+        let tcx = self.tcx();\n+        // FIXME: Marked `mut` so that we can replace the spans further below with a more\n+        // appropriate one, but this should be handled earlier in the span assignment.\n+        let mut associated_types: FxHashMap<Span, Vec<_>> = associated_types\n+            .into_iter()\n+            .map(|(span, def_ids)| {\n+                (span, def_ids.into_iter().map(|did| tcx.associated_item(did)).collect())\n+            })\n+            .collect();\n+        let mut names = vec![];\n+\n+        // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n+        // `issue-22560.rs`.\n+        let mut trait_bound_spans: Vec<Span> = vec![];\n+        for (span, items) in &associated_types {\n+            if !items.is_empty() {\n+                trait_bound_spans.push(*span);\n+            }\n+            for assoc_item in items {\n+                let trait_def_id = assoc_item.container.id();\n+                names.push(format!(\n+                    \"`{}` (from trait `{}`)\",\n+                    assoc_item.ident,\n+                    tcx.def_path_str(trait_def_id),\n+                ));\n+            }\n+        }\n+        if let ([], [bound]) = (&potential_assoc_types[..], &trait_bounds) {\n+            match &bound.trait_ref.path.segments[..] {\n+                // FIXME: `trait_ref.path.span` can point to a full path with multiple\n+                // segments, even though `trait_ref.path.segments` is of length `1`. Work\n+                // around that bug here, even though it should be fixed elsewhere.\n+                // This would otherwise cause an invalid suggestion. For an example, look at\n+                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^ help: specify the associated type:\n+                //    |                              `BitXor<Output = Type>`\n+                //\n+                // we would output:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^^^^^^^^ help: specify the associated type:\n+                //    |                                     `BitXor::bitor<Output = Type>`\n+                [segment] if segment.args.is_none() => {\n+                    trait_bound_spans = vec![segment.ident.span];\n+                    associated_types = associated_types\n+                        .into_iter()\n+                        .map(|(_, items)| (segment.ident.span, items))\n+                        .collect();\n+                }\n+                _ => {}\n+            }\n+        }\n+        names.sort();\n+        trait_bound_spans.sort();\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            trait_bound_spans,\n+            E0191,\n+            \"the value of the associated type{} {} must be specified\",\n+            pluralize!(names.len()),\n+            names.join(\", \"),\n+        );\n+        let mut suggestions = vec![];\n+        let mut types_count = 0;\n+        let mut where_constraints = vec![];\n+        for (span, assoc_items) in &associated_types {\n+            let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+            for item in assoc_items {\n+                types_count += 1;\n+                *names.entry(item.ident.name).or_insert(0) += 1;\n+            }\n+            let mut dupes = false;\n+            for item in assoc_items {\n+                let prefix = if names[&item.ident.name] > 1 {\n+                    let trait_def_id = item.container.id();\n+                    dupes = true;\n+                    format!(\"{}::\", tcx.def_path_str(trait_def_id))\n+                } else {\n+                    String::new()\n+                };\n+                if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n+                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n+                }\n+            }\n+            if potential_assoc_types.len() == assoc_items.len() {\n+                // Only suggest when the amount of missing associated types equals the number of\n+                // extra type arguments present, as that gives us a relatively high confidence\n+                // that the user forgot to give the associtated type's name. The canonical\n+                // example would be trying to use `Iterator<isize>` instead of\n+                // `Iterator<Item = isize>`.\n+                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n+                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n+                    }\n+                }\n+            } else if let (Ok(snippet), false) =\n+                (tcx.sess.source_map().span_to_snippet(*span), dupes)\n+            {\n+                let types: Vec<_> =\n+                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n+                let code = if snippet.ends_with('>') {\n+                    // The user wrote `Trait<'a>` or similar and we don't have a type we can\n+                    // suggest, but at least we can clue them to the correct syntax\n+                    // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n+                    // suggestion.\n+                    format!(\"{}, {}>\", &snippet[..snippet.len() - 1], types.join(\", \"))\n+                } else {\n+                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                    // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n+                    format!(\"{}<{}>\", snippet, types.join(\", \"))\n+                };\n+                suggestions.push((*span, code));\n+            } else if dupes {\n+                where_constraints.push(*span);\n+            }\n+        }\n+        let where_msg = \"consider introducing a new type parameter, adding `where` constraints \\\n+                         using the fully-qualified path to the associated types\";\n+        if !where_constraints.is_empty() && suggestions.is_empty() {\n+            // If there are duplicates associated type names and a single trait bound do not\n+            // use structured suggestion, it means that there are multiple super-traits with\n+            // the same associated type name.\n+            err.help(where_msg);\n+        }\n+        if suggestions.len() != 1 {\n+            // We don't need this label if there's an inline suggestion, show otherwise.\n+            for (span, assoc_items) in &associated_types {\n+                let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+                for item in assoc_items {\n+                    types_count += 1;\n+                    *names.entry(item.ident.name).or_insert(0) += 1;\n+                }\n+                let mut label = vec![];\n+                for item in assoc_items {\n+                    let postfix = if names[&item.ident.name] > 1 {\n+                        let trait_def_id = item.container.id();\n+                        format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n+                    } else {\n+                        String::new()\n+                    };\n+                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n+                }\n+                if !label.is_empty() {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"associated type{} {} must be specified\",\n+                            pluralize!(label.len()),\n+                            label.join(\", \"),\n+                        ),\n+                    );\n+                }\n+            }\n+        }\n+        if !suggestions.is_empty() {\n+            err.multipart_suggestion(\n+                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n+                suggestions,\n+                Applicability::HasPlaceholders,\n+            );\n+            if !where_constraints.is_empty() {\n+                err.span_help(where_constraints, where_msg);\n+            }\n+        }\n+        err.emit();\n+    }\n+}"}, {"sha": "84dab6de9581981094f2ce20de383e4a2a3fcf78", "filename": "src/librustc_typeck/astconv/generics.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv%2Fgenerics.rs?ref=6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "patch": "@@ -0,0 +1,596 @@\n+use crate::astconv::{\n+    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n+};\n+use rustc_ast::ast::ParamKindOrd;\n+use rustc_errors::{pluralize, struct_span_err, DiagnosticId, ErrorReported};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{GenericArg, GenericArgs};\n+use rustc_middle::ty::{\n+    self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, Ty, TyCtxt,\n+};\n+use rustc_session::{lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS, Session};\n+use rustc_span::{symbol::kw, MultiSpan, Span};\n+\n+use smallvec::SmallVec;\n+\n+impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n+    /// Report an error that a generic argument did not match the generic parameter that was\n+    /// expected.\n+    fn generic_arg_mismatch_err(\n+        sess: &Session,\n+        arg: &GenericArg<'_>,\n+        kind: &'static str,\n+        help: Option<&str>,\n+    ) {\n+        let mut err = struct_span_err!(\n+            sess,\n+            arg.span(),\n+            E0747,\n+            \"{} provided when a {} was expected\",\n+            arg.descr(),\n+            kind,\n+        );\n+\n+        let unordered = sess.features_untracked().const_generics;\n+        let kind_ord = match kind {\n+            \"lifetime\" => ParamKindOrd::Lifetime,\n+            \"type\" => ParamKindOrd::Type,\n+            \"constant\" => ParamKindOrd::Const { unordered },\n+            // It's more concise to match on the string representation, though it means\n+            // the match is non-exhaustive.\n+            _ => bug!(\"invalid generic parameter kind {}\", kind),\n+        };\n+        let arg_ord = match arg {\n+            GenericArg::Lifetime(_) => ParamKindOrd::Lifetime,\n+            GenericArg::Type(_) => ParamKindOrd::Type,\n+            GenericArg::Const(_) => ParamKindOrd::Const { unordered },\n+        };\n+\n+        // This note is only true when generic parameters are strictly ordered by their kind.\n+        if kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+            let (first, last) =\n+                if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n+            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+            if let Some(help) = help {\n+                err.help(help);\n+            }\n+        }\n+\n+        err.emit();\n+    }\n+\n+    /// Creates the relevant generic argument substitutions\n+    /// corresponding to a set of generic parameters. This is a\n+    /// rather complex function. Let us try to explain the role\n+    /// of each of its parameters:\n+    ///\n+    /// To start, we are given the `def_id` of the thing we are\n+    /// creating the substitutions for, and a partial set of\n+    /// substitutions `parent_substs`. In general, the substitutions\n+    /// for an item begin with substitutions for all the \"parents\" of\n+    /// that item -- e.g., for a method it might include the\n+    /// parameters from the impl.\n+    ///\n+    /// Therefore, the method begins by walking down these parents,\n+    /// starting with the outermost parent and proceed inwards until\n+    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n+    /// first to see if the parent's substitutions are listed in there. If so,\n+    /// we can append those and move on. Otherwise, it invokes the\n+    /// three callback functions:\n+    ///\n+    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n+    ///   generic arguments that were given to that parent from within\n+    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n+    ///   might refer to the trait `Foo`, and the arguments might be\n+    ///   `[T]`. The boolean value indicates whether to infer values\n+    ///   for arguments whose values were not explicitly provided.\n+    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n+    ///   instantiate a `GenericArg`.\n+    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n+    ///   creates a suitable inference variable.\n+    pub fn create_substs_for_generic_args<'b>(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        parent_substs: &[subst::GenericArg<'tcx>],\n+        has_self: bool,\n+        self_ty: Option<Ty<'tcx>>,\n+        arg_count: GenericArgCountResult,\n+        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n+        mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n+        mut inferred_kind: impl FnMut(\n+            Option<&[subst::GenericArg<'tcx>]>,\n+            &GenericParamDef,\n+            bool,\n+        ) -> subst::GenericArg<'tcx>,\n+    ) -> SubstsRef<'tcx> {\n+        // Collect the segments of the path; we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n+        let mut parent_defs = tcx.generics_of(def_id);\n+        let count = parent_defs.count();\n+        let mut stack = vec![(def_id, parent_defs)];\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = tcx.generics_of(def_id);\n+            stack.push((def_id, parent_defs));\n+        }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in `subst.rs`, so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, instead of trying to match each pair.\n+        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n+        // Iterate over each segment of the path.\n+        while let Some((def_id, defs)) = stack.pop() {\n+            let mut params = defs.params.iter().peekable();\n+\n+            // If we have already computed substitutions for parents, we can use those directly.\n+            while let Some(&param) = params.peek() {\n+                if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                    substs.push(kind);\n+                    params.next();\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            // `Self` is handled first, unless it's been handled in `parent_substs`.\n+            if has_self {\n+                if let Some(&param) = params.peek() {\n+                    if param.index == 0 {\n+                        if let GenericParamDefKind::Type { .. } = param.kind {\n+                            substs.push(\n+                                self_ty\n+                                    .map(|ty| ty.into())\n+                                    .unwrap_or_else(|| inferred_kind(None, param, true)),\n+                            );\n+                            params.next();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check whether this segment takes generic arguments and the user has provided any.\n+            let (generic_args, infer_args) = args_for_def_id(def_id);\n+\n+            let mut args =\n+                generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n+\n+            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+            // If we later encounter a lifetime, we know that the arguments were provided in the\n+            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+            // inferred, so we can use it for diagnostics later.\n+            let mut force_infer_lt = None;\n+\n+            loop {\n+                // We're going to iterate through the generic arguments that the user\n+                // provided, matching them with the generic parameters we expect.\n+                // Mismatches can occur as a result of elided lifetimes, or for malformed\n+                // input. We try to handle both sensibly.\n+                match (args.peek(), params.peek()) {\n+                    (Some(&arg), Some(&param)) => {\n+                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n+                            | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n+                                substs.push(provided_kind(param, arg));\n+                                args.next();\n+                                params.next();\n+                            }\n+                            (\n+                                GenericArg::Type(_) | GenericArg::Const(_),\n+                                GenericParamDefKind::Lifetime,\n+                                _,\n+                            ) => {\n+                                // We expected a lifetime argument, but got a type or const\n+                                // argument. That means we're inferring the lifetimes.\n+                                substs.push(inferred_kind(None, param, infer_args));\n+                                force_infer_lt = Some(arg);\n+                                params.next();\n+                            }\n+                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                                // We've come across a lifetime when we expected something else in\n+                                // the presence of explicit late bounds. This is most likely\n+                                // due to the presence of the explicit bound so we're just going to\n+                                // ignore it.\n+                                args.next();\n+                            }\n+                            (_, kind, _) => {\n+                                // We expected one kind of parameter, but the user provided\n+                                // another. This is an error. However, if we already know that\n+                                // the arguments don't match up with the parameters, we won't issue\n+                                // an additional error, as the user already knows what's wrong.\n+                                if arg_count.correct.is_ok()\n+                                    && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                                {\n+                                    // We're going to iterate over the parameters to sort them out, and\n+                                    // show that order to the user as a possible order for the parameters\n+                                    let mut param_types_present = defs\n+                                        .params\n+                                        .clone()\n+                                        .into_iter()\n+                                        .map(|param| {\n+                                            (\n+                                                match param.kind {\n+                                                    GenericParamDefKind::Lifetime => {\n+                                                        ParamKindOrd::Lifetime\n+                                                    }\n+                                                    GenericParamDefKind::Type { .. } => {\n+                                                        ParamKindOrd::Type\n+                                                    }\n+                                                    GenericParamDefKind::Const => {\n+                                                        ParamKindOrd::Const {\n+                                                            unordered: tcx\n+                                                                .sess\n+                                                                .features_untracked()\n+                                                                .const_generics,\n+                                                        }\n+                                                    }\n+                                                },\n+                                                param,\n+                                            )\n+                                        })\n+                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                    let (mut param_types_present, ordered_params): (\n+                                        Vec<ParamKindOrd>,\n+                                        Vec<GenericParamDef>,\n+                                    ) = param_types_present.into_iter().unzip();\n+                                    param_types_present.dedup();\n+\n+                                    Self::generic_arg_mismatch_err(\n+                                        tcx.sess,\n+                                        arg,\n+                                        kind.descr(),\n+                                        Some(&format!(\n+                                            \"reorder the arguments: {}: `<{}>`\",\n+                                            param_types_present\n+                                                .into_iter()\n+                                                .map(|ord| format!(\"{}s\", ord.to_string()))\n+                                                .collect::<Vec<String>>()\n+                                                .join(\", then \"),\n+                                            ordered_params\n+                                                .into_iter()\n+                                                .filter_map(|param| {\n+                                                    if param.name == kw::SelfUpper {\n+                                                        None\n+                                                    } else {\n+                                                        Some(param.name.to_string())\n+                                                    }\n+                                                })\n+                                                .collect::<Vec<String>>()\n+                                                .join(\", \")\n+                                        )),\n+                                    );\n+                                }\n+\n+                                // We've reported the error, but we want to make sure that this\n+                                // problem doesn't bubble down and create additional, irrelevant\n+                                // errors. In this case, we're simply going to ignore the argument\n+                                // and any following arguments. The rest of the parameters will be\n+                                // inferred.\n+                                while args.next().is_some() {}\n+                            }\n+                        }\n+                    }\n+\n+                    (Some(&arg), None) => {\n+                        // We should never be able to reach this point with well-formed input.\n+                        // There are three situations in which we can encounter this issue.\n+                        //\n+                        //  1.  The number of arguments is incorrect. In this case, an error\n+                        //      will already have been emitted, and we can ignore it.\n+                        //  2.  There are late-bound lifetime parameters present, yet the\n+                        //      lifetime arguments have also been explicitly specified by the\n+                        //      user.\n+                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n+                        //      after a type or const). We want to throw an error in this case.\n+\n+                        if arg_count.correct.is_ok()\n+                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                        {\n+                            let kind = arg.descr();\n+                            assert_eq!(kind, \"lifetime\");\n+                            let provided =\n+                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, None);\n+                        }\n+\n+                        break;\n+                    }\n+\n+                    (None, Some(&param)) => {\n+                        // If there are fewer arguments than parameters, it means\n+                        // we're inferring the remaining arguments.\n+                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n+                        params.next();\n+                    }\n+\n+                    (None, None) => break,\n+                }\n+            }\n+        }\n+\n+        tcx.intern_substs(&substs)\n+    }\n+\n+    /// Checks that the correct number of generic arguments have been provided.\n+    /// Used specifically for function calls.\n+    pub fn check_generic_arg_count_for_call(\n+        tcx: TyCtxt<'_>,\n+        span: Span,\n+        def: &ty::Generics,\n+        seg: &hir::PathSegment<'_>,\n+        is_method_call: bool,\n+    ) -> GenericArgCountResult {\n+        let empty_args = hir::GenericArgs::none();\n+        let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n+        Self::check_generic_arg_count(\n+            tcx,\n+            span,\n+            def,\n+            if let Some(ref args) = seg.args { args } else { &empty_args },\n+            if is_method_call { GenericArgPosition::MethodCall } else { GenericArgPosition::Value },\n+            def.parent.is_none() && def.has_self, // `has_self`\n+            seg.infer_args || suppress_mismatch,  // `infer_args`\n+        )\n+    }\n+\n+    /// Checks that the correct number of generic arguments have been provided.\n+    /// This is used both for datatypes and function calls.\n+    pub(crate) fn check_generic_arg_count(\n+        tcx: TyCtxt<'_>,\n+        span: Span,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs<'_>,\n+        position: GenericArgPosition,\n+        has_self: bool,\n+        infer_args: bool,\n+    ) -> GenericArgCountResult {\n+        // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n+        // that lifetimes will proceed types. So it suffices to check the number of each generic\n+        // arguments in order to validate them with respect to the generic parameters.\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        let mut defaults: ty::GenericParamCount = Default::default();\n+        for param in &def.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    defaults.types += has_default as usize\n+                }\n+                GenericParamDefKind::Const => {\n+                    // FIXME(const_generics:defaults)\n+                }\n+            };\n+        }\n+\n+        if position != GenericArgPosition::Type && !args.bindings.is_empty() {\n+            Self::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n+        }\n+\n+        let explicit_late_bound =\n+            Self::prohibit_explicit_late_bound_lifetimes(tcx, def, args, position);\n+\n+        let check_kind_count = |kind,\n+                                required,\n+                                permitted,\n+                                provided,\n+                                offset,\n+                                unexpected_spans: &mut Vec<Span>,\n+                                silent| {\n+            debug!(\n+                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                kind, required, permitted, provided, offset\n+            );\n+            // We enforce the following: `required` <= `provided` <= `permitted`.\n+            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n+            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n+            if required <= provided && provided <= permitted {\n+                return Ok(());\n+            }\n+\n+            if silent {\n+                return Err(true);\n+            }\n+\n+            // Unfortunately lifetime and type parameter mismatches are typically styled\n+            // differently in diagnostics, which means we have a few cases to consider here.\n+            let (bound, quantifier) = if required != permitted {\n+                if provided < required {\n+                    (required, \"at least \")\n+                } else {\n+                    // provided > permitted\n+                    (permitted, \"at most \")\n+                }\n+            } else {\n+                (required, \"\")\n+            };\n+\n+            let (spans, label) = if required == permitted && provided > permitted {\n+                // In the case when the user has provided too many arguments,\n+                // we want to point to the unexpected arguments.\n+                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span())\n+                    .collect();\n+                unexpected_spans.extend(spans.clone());\n+                (spans, format!(\"unexpected {} argument\", kind))\n+            } else {\n+                (\n+                    vec![span],\n+                    format!(\n+                        \"expected {}{} {} argument{}\",\n+                        quantifier,\n+                        bound,\n+                        kind,\n+                        pluralize!(bound),\n+                    ),\n+                )\n+            };\n+\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                spans.clone(),\n+                &format!(\n+                    \"wrong number of {} arguments: expected {}{}, found {}\",\n+                    kind, quantifier, bound, provided,\n+                ),\n+                DiagnosticId::Error(\"E0107\".into()),\n+            );\n+            for span in spans {\n+                err.span_label(span, label.as_str());\n+            }\n+            err.emit();\n+\n+            Err(true)\n+        };\n+\n+        let mut arg_count_correct = Ok(());\n+        let mut unexpected_spans = vec![];\n+\n+        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n+            arg_count_correct = check_kind_count(\n+                \"lifetime\",\n+                param_counts.lifetimes,\n+                param_counts.lifetimes,\n+                arg_counts.lifetimes,\n+                0,\n+                &mut unexpected_spans,\n+                explicit_late_bound == ExplicitLateBound::Yes,\n+            )\n+            .and(arg_count_correct);\n+        }\n+        // FIXME(const_generics:defaults)\n+        if !infer_args || arg_counts.consts > param_counts.consts {\n+            arg_count_correct = check_kind_count(\n+                \"const\",\n+                param_counts.consts,\n+                param_counts.consts,\n+                arg_counts.consts,\n+                arg_counts.lifetimes + arg_counts.types,\n+                &mut unexpected_spans,\n+                false,\n+            )\n+            .and(arg_count_correct);\n+        }\n+        // Note that type errors are currently be emitted *after* const errors.\n+        if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n+        {\n+            arg_count_correct = check_kind_count(\n+                \"type\",\n+                param_counts.types - defaults.types - has_self as usize,\n+                param_counts.types - has_self as usize,\n+                arg_counts.types,\n+                arg_counts.lifetimes,\n+                &mut unexpected_spans,\n+                false,\n+            )\n+            .and(arg_count_correct);\n+        }\n+\n+        GenericArgCountResult {\n+            explicit_late_bound,\n+            correct: arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n+                reported: if reported_err { Some(ErrorReported) } else { None },\n+                invalid_args: unexpected_spans,\n+            }),\n+        }\n+    }\n+\n+    /// Report error if there is an explicit type parameter when using `impl Trait`.\n+    pub(crate) fn check_impl_trait(\n+        tcx: TyCtxt<'_>,\n+        seg: &hir::PathSegment<'_>,\n+        generics: &ty::Generics,\n+    ) -> bool {\n+        let explicit = !seg.infer_args;\n+        let impl_trait = generics.params.iter().any(|param| match param.kind {\n+            ty::GenericParamDefKind::Type {\n+                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                ..\n+            } => true,\n+            _ => false,\n+        });\n+\n+        if explicit && impl_trait {\n+            let spans = seg\n+                .generic_args()\n+                .args\n+                .iter()\n+                .filter_map(|arg| match arg {\n+                    GenericArg::Type(_) => Some(arg.span()),\n+                    _ => None,\n+                })\n+                .collect::<Vec<_>>();\n+\n+            let mut err = struct_span_err! {\n+                tcx.sess,\n+                spans.clone(),\n+                E0632,\n+                \"cannot provide explicit generic arguments when `impl Trait` is \\\n+                used in argument position\"\n+            };\n+\n+            for span in spans {\n+                err.span_label(span, \"explicit generic argument not allowed\");\n+            }\n+\n+            err.emit();\n+        }\n+\n+        impl_trait\n+    }\n+\n+    /// Emits an error regarding forbidden type binding associations\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0229,\n+            \"associated type bindings are not allowed here\"\n+        );\n+        err.span_label(span, \"associated type not allowed here\").emit();\n+    }\n+\n+    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+    /// are present. This is used both for datatypes and function calls.\n+    pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n+        tcx: TyCtxt<'_>,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs<'_>,\n+        position: GenericArgPosition,\n+    ) -> ExplicitLateBound {\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        if infer_lifetimes {\n+            ExplicitLateBound::No\n+        } else if let Some(span_late) = def.has_late_bound_regions {\n+            let msg = \"cannot specify lifetime arguments explicitly \\\n+                       if late bound lifetime parameters are present\";\n+            let note = \"the late bound lifetime parameter is introduced here\";\n+            let span = args.args[0].span();\n+            if position == GenericArgPosition::Value\n+                && arg_counts.lifetimes != param_counts.lifetimes\n+            {\n+                let mut err = tcx.sess.struct_span_err(span, msg);\n+                err.span_note(span_late, note);\n+                err.emit();\n+            } else {\n+                let mut multispan = MultiSpan::from_span(span);\n+                multispan.push_span_label(span_late, note.to_string());\n+                tcx.struct_span_lint_hir(\n+                    LATE_BOUND_LIFETIME_ARGUMENTS,\n+                    args.args[0].id(),\n+                    multispan,\n+                    |lint| lint.build(msg).emit(),\n+                );\n+            }\n+            ExplicitLateBound::Yes\n+        } else {\n+            ExplicitLateBound::No\n+        }\n+    }\n+}"}, {"sha": "15c19afdb4a207e2a8765d653a930aa3120fd81a", "filename": "src/librustc_typeck/astconv/mod.rs", "status": "renamed", "additions": 14, "deletions": 1057, "changes": 1071, "blob_url": "https://github.com/rust-lang/rust/blob/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv%2Fmod.rs?ref=6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "patch": "@@ -1,33 +1,29 @@\n-// ignore-tidy-filelength FIXME(#67418) Split up this file.\n //! Conversion from AST representation of types to the `ty.rs` representation.\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n-// ignore-tidy-filelength\n+mod errors;\n+mod generics;\n \n+use crate::bounds::Bounds;\n use crate::collect::PlaceholderHirTyCollector;\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n-use rustc_ast::{util::lev_distance::find_best_match_for_name, ParamKindOrd};\n+use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::ErrorReported;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n+use rustc_errors::{struct_span_err, Applicability, ErrorReported, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::lang_items::SizedTraitLangItem;\n use rustc_hir::{Constness, GenericArg, GenericArgs};\n use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{\n-    self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n-use rustc_middle::ty::{GenericParamDef, GenericParamDefKind};\n-use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n-use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_middle::ty::GenericParamDefKind;\n+use rustc_middle::ty::{self, Const, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_session::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -138,8 +134,10 @@ pub enum ExplicitLateBound {\n     No,\n }\n \n+/// Denotes the \"position\" of a generic argument, indicating if it is a generic type,\n+/// generic function or generic method call.\n #[derive(Copy, Clone, PartialEq)]\n-enum GenericArgPosition {\n+pub(crate) enum GenericArgPosition {\n     Type,\n     Value, // e.g., functions\n     MethodCall,\n@@ -243,533 +241,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         substs\n     }\n \n-    /// Report error if there is an explicit type parameter when using `impl Trait`.\n-    fn check_impl_trait(\n-        tcx: TyCtxt<'_>,\n-        seg: &hir::PathSegment<'_>,\n-        generics: &ty::Generics,\n-    ) -> bool {\n-        let explicit = !seg.infer_args;\n-        let impl_trait = generics.params.iter().any(|param| match param.kind {\n-            ty::GenericParamDefKind::Type {\n-                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                ..\n-            } => true,\n-            _ => false,\n-        });\n-\n-        if explicit && impl_trait {\n-            let spans = seg\n-                .generic_args()\n-                .args\n-                .iter()\n-                .filter_map(|arg| match arg {\n-                    GenericArg::Type(_) => Some(arg.span()),\n-                    _ => None,\n-                })\n-                .collect::<Vec<_>>();\n-\n-            let mut err = struct_span_err! {\n-                tcx.sess,\n-                spans.clone(),\n-                E0632,\n-                \"cannot provide explicit generic arguments when `impl Trait` is \\\n-                used in argument position\"\n-            };\n-\n-            for span in spans {\n-                err.span_label(span, \"explicit generic argument not allowed\");\n-            }\n-\n-            err.emit();\n-        }\n-\n-        impl_trait\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// Used specifically for function calls.\n-    pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def: &ty::Generics,\n-        seg: &hir::PathSegment<'_>,\n-        is_method_call: bool,\n-    ) -> GenericArgCountResult {\n-        let empty_args = hir::GenericArgs::none();\n-        let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n-        Self::check_generic_arg_count(\n-            tcx,\n-            span,\n-            def,\n-            if let Some(ref args) = seg.args { args } else { &empty_args },\n-            if is_method_call { GenericArgPosition::MethodCall } else { GenericArgPosition::Value },\n-            def.parent.is_none() && def.has_self, // `has_self`\n-            seg.infer_args || suppress_mismatch,  // `infer_args`\n-        )\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// This is used both for datatypes and function calls.\n-    fn check_generic_arg_count(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-        has_self: bool,\n-        infer_args: bool,\n-    ) -> GenericArgCountResult {\n-        // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n-        // that lifetimes will proceed types. So it suffices to check the number of each generic\n-        // arguments in order to validate them with respect to the generic parameters.\n-        let param_counts = def.own_counts();\n-        let arg_counts = args.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n-\n-        let mut defaults: ty::GenericParamCount = Default::default();\n-        for param in &def.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {}\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    defaults.types += has_default as usize\n-                }\n-                GenericParamDefKind::Const => {\n-                    // FIXME(const_generics:defaults)\n-                }\n-            };\n-        }\n-\n-        if position != GenericArgPosition::Type && !args.bindings.is_empty() {\n-            AstConv::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n-        }\n-\n-        let explicit_late_bound =\n-            Self::prohibit_explicit_late_bound_lifetimes(tcx, def, args, position);\n-\n-        let check_kind_count = |kind,\n-                                required,\n-                                permitted,\n-                                provided,\n-                                offset,\n-                                unexpected_spans: &mut Vec<Span>,\n-                                silent| {\n-            debug!(\n-                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n-                kind, required, permitted, provided, offset\n-            );\n-            // We enforce the following: `required` <= `provided` <= `permitted`.\n-            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n-            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n-            if required <= provided && provided <= permitted {\n-                return Ok(());\n-            }\n-\n-            if silent {\n-                return Err(true);\n-            }\n-\n-            // Unfortunately lifetime and type parameter mismatches are typically styled\n-            // differently in diagnostics, which means we have a few cases to consider here.\n-            let (bound, quantifier) = if required != permitted {\n-                if provided < required {\n-                    (required, \"at least \")\n-                } else {\n-                    // provided > permitted\n-                    (permitted, \"at most \")\n-                }\n-            } else {\n-                (required, \"\")\n-            };\n-\n-            let (spans, label) = if required == permitted && provided > permitted {\n-                // In the case when the user has provided too many arguments,\n-                // we want to point to the unexpected arguments.\n-                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n-                    .iter()\n-                    .map(|arg| arg.span())\n-                    .collect();\n-                unexpected_spans.extend(spans.clone());\n-                (spans, format!(\"unexpected {} argument\", kind))\n-            } else {\n-                (\n-                    vec![span],\n-                    format!(\n-                        \"expected {}{} {} argument{}\",\n-                        quantifier,\n-                        bound,\n-                        kind,\n-                        pluralize!(bound),\n-                    ),\n-                )\n-            };\n-\n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                spans.clone(),\n-                &format!(\n-                    \"wrong number of {} arguments: expected {}{}, found {}\",\n-                    kind, quantifier, bound, provided,\n-                ),\n-                DiagnosticId::Error(\"E0107\".into()),\n-            );\n-            for span in spans {\n-                err.span_label(span, label.as_str());\n-            }\n-            err.emit();\n-\n-            Err(true)\n-        };\n-\n-        let mut arg_count_correct = Ok(());\n-        let mut unexpected_spans = vec![];\n-\n-        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n-            arg_count_correct = check_kind_count(\n-                \"lifetime\",\n-                param_counts.lifetimes,\n-                param_counts.lifetimes,\n-                arg_counts.lifetimes,\n-                0,\n-                &mut unexpected_spans,\n-                explicit_late_bound == ExplicitLateBound::Yes,\n-            )\n-            .and(arg_count_correct);\n-        }\n-        // FIXME(const_generics:defaults)\n-        if !infer_args || arg_counts.consts > param_counts.consts {\n-            arg_count_correct = check_kind_count(\n-                \"const\",\n-                param_counts.consts,\n-                param_counts.consts,\n-                arg_counts.consts,\n-                arg_counts.lifetimes + arg_counts.types,\n-                &mut unexpected_spans,\n-                false,\n-            )\n-            .and(arg_count_correct);\n-        }\n-        // Note that type errors are currently be emitted *after* const errors.\n-        if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n-        {\n-            arg_count_correct = check_kind_count(\n-                \"type\",\n-                param_counts.types - defaults.types - has_self as usize,\n-                param_counts.types - has_self as usize,\n-                arg_counts.types,\n-                arg_counts.lifetimes,\n-                &mut unexpected_spans,\n-                false,\n-            )\n-            .and(arg_count_correct);\n-        }\n-\n-        GenericArgCountResult {\n-            explicit_late_bound,\n-            correct: arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n-                reported: if reported_err { Some(ErrorReported) } else { None },\n-                invalid_args: unexpected_spans,\n-            }),\n-        }\n-    }\n-\n-    /// Report an error that a generic argument did not match the generic parameter that was\n-    /// expected.\n-    fn generic_arg_mismatch_err(\n-        sess: &Session,\n-        arg: &GenericArg<'_>,\n-        kind: &'static str,\n-        help: Option<&str>,\n-    ) {\n-        let mut err = struct_span_err!(\n-            sess,\n-            arg.span(),\n-            E0747,\n-            \"{} provided when a {} was expected\",\n-            arg.descr(),\n-            kind,\n-        );\n-\n-        let unordered = sess.features_untracked().const_generics;\n-        let kind_ord = match kind {\n-            \"lifetime\" => ParamKindOrd::Lifetime,\n-            \"type\" => ParamKindOrd::Type,\n-            \"constant\" => ParamKindOrd::Const { unordered },\n-            // It's more concise to match on the string representation, though it means\n-            // the match is non-exhaustive.\n-            _ => bug!(\"invalid generic parameter kind {}\", kind),\n-        };\n-        let arg_ord = match arg {\n-            GenericArg::Lifetime(_) => ParamKindOrd::Lifetime,\n-            GenericArg::Type(_) => ParamKindOrd::Type,\n-            GenericArg::Const(_) => ParamKindOrd::Const { unordered },\n-        };\n-\n-        // This note is only true when generic parameters are strictly ordered by their kind.\n-        if kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n-            let (first, last) =\n-                if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n-            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-            if let Some(help) = help {\n-                err.help(help);\n-            }\n-        }\n-\n-        err.emit();\n-    }\n-\n-    /// Creates the relevant generic argument substitutions\n-    /// corresponding to a set of generic parameters. This is a\n-    /// rather complex function. Let us try to explain the role\n-    /// of each of its parameters:\n-    ///\n-    /// To start, we are given the `def_id` of the thing we are\n-    /// creating the substitutions for, and a partial set of\n-    /// substitutions `parent_substs`. In general, the substitutions\n-    /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- e.g., for a method it might include the\n-    /// parameters from the impl.\n-    ///\n-    /// Therefore, the method begins by walking down these parents,\n-    /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n-    /// first to see if the parent's substitutions are listed in there. If so,\n-    /// we can append those and move on. Otherwise, it invokes the\n-    /// three callback functions:\n-    ///\n-    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n-    ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n-    ///   might refer to the trait `Foo`, and the arguments might be\n-    ///   `[T]`. The boolean value indicates whether to infer values\n-    ///   for arguments whose values were not explicitly provided.\n-    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `GenericArg`.\n-    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n-    ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'b>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        parent_substs: &[subst::GenericArg<'tcx>],\n-        has_self: bool,\n-        self_ty: Option<Ty<'tcx>>,\n-        arg_count: GenericArgCountResult,\n-        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n-        mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n-        mut inferred_kind: impl FnMut(\n-            Option<&[subst::GenericArg<'tcx>]>,\n-            &GenericParamDef,\n-            bool,\n-        ) -> subst::GenericArg<'tcx>,\n-    ) -> SubstsRef<'tcx> {\n-        // Collect the segments of the path; we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n-        }\n-\n-        // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs`, so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter().peekable();\n-\n-            // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(&param) = params.peek() {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    substs.push(kind);\n-                    params.next();\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            // `Self` is handled first, unless it's been handled in `parent_substs`.\n-            if has_self {\n-                if let Some(&param) = params.peek() {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            substs.push(\n-                                self_ty\n-                                    .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| inferred_kind(None, param, true)),\n-                            );\n-                            params.next();\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = args_for_def_id(def_id);\n-\n-            let mut args =\n-                generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n-\n-            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n-            // If we later encounter a lifetime, we know that the arguments were provided in the\n-            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n-            // inferred, so we can use it for diagnostics later.\n-            let mut force_infer_lt = None;\n-\n-            loop {\n-                // We're going to iterate through the generic arguments that the user\n-                // provided, matching them with the generic parameters we expect.\n-                // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                // input. We try to handle both sensibly.\n-                match (args.peek(), params.peek()) {\n-                    (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n-                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n-                            | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n-                                substs.push(provided_kind(param, arg));\n-                                args.next();\n-                                params.next();\n-                            }\n-                            (\n-                                GenericArg::Type(_) | GenericArg::Const(_),\n-                                GenericParamDefKind::Lifetime,\n-                                _,\n-                            ) => {\n-                                // We expected a lifetime argument, but got a type or const\n-                                // argument. That means we're inferring the lifetimes.\n-                                substs.push(inferred_kind(None, param, infer_args));\n-                                force_infer_lt = Some(arg);\n-                                params.next();\n-                            }\n-                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n-                                // We've come across a lifetime when we expected something else in\n-                                // the presence of explicit late bounds. This is most likely\n-                                // due to the presence of the explicit bound so we're just going to\n-                                // ignore it.\n-                                args.next();\n-                            }\n-                            (_, kind, _) => {\n-                                // We expected one kind of parameter, but the user provided\n-                                // another. This is an error. However, if we already know that\n-                                // the arguments don't match up with the parameters, we won't issue\n-                                // an additional error, as the user already knows what's wrong.\n-                                if arg_count.correct.is_ok()\n-                                    && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                                {\n-                                    // We're going to iterate over the parameters to sort them out, and\n-                                    // show that order to the user as a possible order for the parameters\n-                                    let mut param_types_present = defs\n-                                        .params\n-                                        .clone()\n-                                        .into_iter()\n-                                        .map(|param| {\n-                                            (\n-                                                match param.kind {\n-                                                    GenericParamDefKind::Lifetime => {\n-                                                        ParamKindOrd::Lifetime\n-                                                    }\n-                                                    GenericParamDefKind::Type { .. } => {\n-                                                        ParamKindOrd::Type\n-                                                    }\n-                                                    GenericParamDefKind::Const => {\n-                                                        ParamKindOrd::Const {\n-                                                            unordered: tcx\n-                                                                .sess\n-                                                                .features_untracked()\n-                                                                .const_generics,\n-                                                        }\n-                                                    }\n-                                                },\n-                                                param,\n-                                            )\n-                                        })\n-                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n-                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n-                                    let (mut param_types_present, ordered_params): (\n-                                        Vec<ParamKindOrd>,\n-                                        Vec<GenericParamDef>,\n-                                    ) = param_types_present.into_iter().unzip();\n-                                    param_types_present.dedup();\n-\n-                                    Self::generic_arg_mismatch_err(\n-                                        tcx.sess,\n-                                        arg,\n-                                        kind.descr(),\n-                                        Some(&format!(\n-                                            \"reorder the arguments: {}: `<{}>`\",\n-                                            param_types_present\n-                                                .into_iter()\n-                                                .map(|ord| format!(\"{}s\", ord.to_string()))\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", then \"),\n-                                            ordered_params\n-                                                .into_iter()\n-                                                .filter_map(|param| {\n-                                                    if param.name == kw::SelfUpper {\n-                                                        None\n-                                                    } else {\n-                                                        Some(param.name.to_string())\n-                                                    }\n-                                                })\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", \")\n-                                        )),\n-                                    );\n-                                }\n-\n-                                // We've reported the error, but we want to make sure that this\n-                                // problem doesn't bubble down and create additional, irrelevant\n-                                // errors. In this case, we're simply going to ignore the argument\n-                                // and any following arguments. The rest of the parameters will be\n-                                // inferred.\n-                                while args.next().is_some() {}\n-                            }\n-                        }\n-                    }\n-\n-                    (Some(&arg), None) => {\n-                        // We should never be able to reach this point with well-formed input.\n-                        // There are three situations in which we can encounter this issue.\n-                        //\n-                        //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it.\n-                        //  2.  There are late-bound lifetime parameters present, yet the\n-                        //      lifetime arguments have also been explicitly specified by the\n-                        //      user.\n-                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                        //      after a type or const). We want to throw an error in this case.\n-\n-                        if arg_count.correct.is_ok()\n-                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                        {\n-                            let kind = arg.descr();\n-                            assert_eq!(kind, \"lifetime\");\n-                            let provided =\n-                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, None);\n-                        }\n-\n-                        break;\n-                    }\n-\n-                    (None, Some(&param)) => {\n-                        // If there are fewer arguments than parameters, it means\n-                        // we're inferring the remaining arguments.\n-                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n-                        params.next();\n-                    }\n-\n-                    (None, None) => break,\n-                }\n-            }\n-        }\n-\n-        tcx.intern_substs(&substs)\n-    }\n-\n     /// Given the type/lifetime/const arguments provided to some path (along with\n     /// an implicit `Self`, if this is a trait reference), returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n@@ -1023,79 +494,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n-    /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n-    /// the type parameter's name as a placeholder.\n-    fn complain_about_missing_type_params(\n-        &self,\n-        missing_type_params: Vec<String>,\n-        def_id: DefId,\n-        span: Span,\n-        empty_generic_args: bool,\n-    ) {\n-        if missing_type_params.is_empty() {\n-            return;\n-        }\n-        let display =\n-            missing_type_params.iter().map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n-        let mut err = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0393,\n-            \"the type parameter{} {} must be explicitly specified\",\n-            pluralize!(missing_type_params.len()),\n-            display,\n-        );\n-        err.span_label(\n-            self.tcx().def_span(def_id),\n-            &format!(\n-                \"type parameter{} {} must be specified for this\",\n-                pluralize!(missing_type_params.len()),\n-                display,\n-            ),\n-        );\n-        let mut suggested = false;\n-        if let (Ok(snippet), true) = (\n-            self.tcx().sess.source_map().span_to_snippet(span),\n-            // Don't suggest setting the type params if there are some already: the order is\n-            // tricky to get right and the user will already know what the syntax is.\n-            empty_generic_args,\n-        ) {\n-            if snippet.ends_with('>') {\n-                // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n-                // we would have to preserve the right order. For now, as clearly the user is\n-                // aware of the syntax, we do nothing.\n-            } else {\n-                // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n-                // least we can clue them to the correct syntax `Iterator<Type>`.\n-                err.span_suggestion(\n-                    span,\n-                    &format!(\n-                        \"set the type parameter{plural} to the desired type{plural}\",\n-                        plural = pluralize!(missing_type_params.len()),\n-                    ),\n-                    format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n-                    Applicability::HasPlaceholders,\n-                );\n-                suggested = true;\n-            }\n-        }\n-        if !suggested {\n-            err.span_label(\n-                span,\n-                format!(\n-                    \"missing reference{} to {}\",\n-                    pluralize!(missing_type_params.len()),\n-                    display,\n-                ),\n-            );\n-        }\n-        err.note(\n-            \"because of the default `Self` reference, type parameters must be \\\n-                  specified on object types\",\n-        );\n-        err.emit();\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the `DefId` of the defining trait.\n     /// The type _cannot_ be a type other than a trait type.\n@@ -1242,76 +640,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n         if let Some(b) = assoc_bindings.first() {\n-            AstConv::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    /// When the code is using the `Fn` traits directly, instead of the `Fn(A) -> B` syntax, emit\n-    /// an error and attempt to build a reasonable structured suggestion.\n-    fn complain_about_internal_fn_trait(\n-        &self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        trait_segment: &'a hir::PathSegment<'a>,\n-    ) {\n-        let trait_def = self.tcx().trait_def(trait_def_id);\n-\n-        if !self.tcx().features().unboxed_closures\n-            && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n-        {\n-            let sess = &self.tcx().sess.parse_sess;\n-            // For now, require that parenthetical notation be used only with `Fn()` etc.\n-            let (msg, sugg) = if trait_def.paren_sugar {\n-                (\n-                    \"the precise format of `Fn`-family traits' type parameters is subject to \\\n-                     change\",\n-                    Some(format!(\n-                        \"{}{} -> {}\",\n-                        trait_segment.ident,\n-                        trait_segment\n-                            .args\n-                            .as_ref()\n-                            .and_then(|args| args.args.get(0))\n-                            .and_then(|arg| match arg {\n-                                hir::GenericArg::Type(ty) => match ty.kind {\n-                                    hir::TyKind::Tup(t) => t\n-                                        .iter()\n-                                        .map(|e| sess.source_map().span_to_snippet(e.span))\n-                                        .collect::<Result<Vec<_>, _>>()\n-                                        .map(|a| a.join(\", \")),\n-                                    _ => sess.source_map().span_to_snippet(ty.span),\n-                                }\n-                                .map(|s| format!(\"({})\", s))\n-                                .ok(),\n-                                _ => None,\n-                            })\n-                            .unwrap_or_else(|| \"()\".to_string()),\n-                        trait_segment\n-                            .generic_args()\n-                            .bindings\n-                            .iter()\n-                            .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n-                                (true, hir::TypeBindingKind::Equality { ty }) => {\n-                                    sess.source_map().span_to_snippet(ty.span).ok()\n-                                }\n-                                _ => None,\n-                            })\n-                            .unwrap_or_else(|| \"()\".to_string()),\n-                    )),\n-                )\n-            } else {\n-                (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n-            };\n-            let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n-            if let Some(sugg) = sugg {\n-                let msg = \"use parenthetical notation instead\";\n-                err.span_suggestion(span, msg, sugg, Applicability::MaybeIncorrect);\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     fn create_substs_for_ast_trait_ref<'a>(\n         &self,\n         span: Span,\n@@ -1912,196 +1245,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n-    /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n-    /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n-    /// same trait bound have the same name (as they come from different super-traits), we instead\n-    /// emit a generic note suggesting using a `where` clause to constraint instead.\n-    fn complain_about_missing_associated_types(\n-        &self,\n-        associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n-        potential_assoc_types: Vec<Span>,\n-        trait_bounds: &[hir::PolyTraitRef<'_>],\n-    ) {\n-        if associated_types.values().all(|v| v.is_empty()) {\n-            return;\n-        }\n-        let tcx = self.tcx();\n-        // FIXME: Marked `mut` so that we can replace the spans further below with a more\n-        // appropriate one, but this should be handled earlier in the span assignment.\n-        let mut associated_types: FxHashMap<Span, Vec<_>> = associated_types\n-            .into_iter()\n-            .map(|(span, def_ids)| {\n-                (span, def_ids.into_iter().map(|did| tcx.associated_item(did)).collect())\n-            })\n-            .collect();\n-        let mut names = vec![];\n-\n-        // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n-        // `issue-22560.rs`.\n-        let mut trait_bound_spans: Vec<Span> = vec![];\n-        for (span, items) in &associated_types {\n-            if !items.is_empty() {\n-                trait_bound_spans.push(*span);\n-            }\n-            for assoc_item in items {\n-                let trait_def_id = assoc_item.container.id();\n-                names.push(format!(\n-                    \"`{}` (from trait `{}`)\",\n-                    assoc_item.ident,\n-                    tcx.def_path_str(trait_def_id),\n-                ));\n-            }\n-        }\n-        if let ([], [bound]) = (&potential_assoc_types[..], &trait_bounds) {\n-            match &bound.trait_ref.path.segments[..] {\n-                // FIXME: `trait_ref.path.span` can point to a full path with multiple\n-                // segments, even though `trait_ref.path.segments` is of length `1`. Work\n-                // around that bug here, even though it should be fixed elsewhere.\n-                // This would otherwise cause an invalid suggestion. For an example, look at\n-                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n-                //\n-                //   error[E0191]: the value of the associated type `Output`\n-                //                 (from trait `std::ops::BitXor`) must be specified\n-                //   --> $DIR/issue-28344.rs:4:17\n-                //    |\n-                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-                //    |                 ^^^^^^ help: specify the associated type:\n-                //    |                              `BitXor<Output = Type>`\n-                //\n-                // we would output:\n-                //\n-                //   error[E0191]: the value of the associated type `Output`\n-                //                 (from trait `std::ops::BitXor`) must be specified\n-                //   --> $DIR/issue-28344.rs:4:17\n-                //    |\n-                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-                //    |                 ^^^^^^^^^^^^^ help: specify the associated type:\n-                //    |                                     `BitXor::bitor<Output = Type>`\n-                [segment] if segment.args.is_none() => {\n-                    trait_bound_spans = vec![segment.ident.span];\n-                    associated_types = associated_types\n-                        .into_iter()\n-                        .map(|(_, items)| (segment.ident.span, items))\n-                        .collect();\n-                }\n-                _ => {}\n-            }\n-        }\n-        names.sort();\n-        trait_bound_spans.sort();\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            trait_bound_spans,\n-            E0191,\n-            \"the value of the associated type{} {} must be specified\",\n-            pluralize!(names.len()),\n-            names.join(\", \"),\n-        );\n-        let mut suggestions = vec![];\n-        let mut types_count = 0;\n-        let mut where_constraints = vec![];\n-        for (span, assoc_items) in &associated_types {\n-            let mut names: FxHashMap<_, usize> = FxHashMap::default();\n-            for item in assoc_items {\n-                types_count += 1;\n-                *names.entry(item.ident.name).or_insert(0) += 1;\n-            }\n-            let mut dupes = false;\n-            for item in assoc_items {\n-                let prefix = if names[&item.ident.name] > 1 {\n-                    let trait_def_id = item.container.id();\n-                    dupes = true;\n-                    format!(\"{}::\", tcx.def_path_str(trait_def_id))\n-                } else {\n-                    String::new()\n-                };\n-                if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n-                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n-                }\n-            }\n-            if potential_assoc_types.len() == assoc_items.len() {\n-                // Only suggest when the amount of missing associated types equals the number of\n-                // extra type arguments present, as that gives us a relatively high confidence\n-                // that the user forgot to give the associtated type's name. The canonical\n-                // example would be trying to use `Iterator<isize>` instead of\n-                // `Iterator<Item = isize>`.\n-                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n-                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n-                    }\n-                }\n-            } else if let (Ok(snippet), false) =\n-                (tcx.sess.source_map().span_to_snippet(*span), dupes)\n-            {\n-                let types: Vec<_> =\n-                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n-                let code = if snippet.ends_with('>') {\n-                    // The user wrote `Trait<'a>` or similar and we don't have a type we can\n-                    // suggest, but at least we can clue them to the correct syntax\n-                    // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n-                    // suggestion.\n-                    format!(\"{}, {}>\", &snippet[..snippet.len() - 1], types.join(\", \"))\n-                } else {\n-                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n-                    // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n-                    format!(\"{}<{}>\", snippet, types.join(\", \"))\n-                };\n-                suggestions.push((*span, code));\n-            } else if dupes {\n-                where_constraints.push(*span);\n-            }\n-        }\n-        let where_msg = \"consider introducing a new type parameter, adding `where` constraints \\\n-                         using the fully-qualified path to the associated types\";\n-        if !where_constraints.is_empty() && suggestions.is_empty() {\n-            // If there are duplicates associated type names and a single trait bound do not\n-            // use structured suggestion, it means that there are multiple super-traits with\n-            // the same associated type name.\n-            err.help(where_msg);\n-        }\n-        if suggestions.len() != 1 {\n-            // We don't need this label if there's an inline suggestion, show otherwise.\n-            for (span, assoc_items) in &associated_types {\n-                let mut names: FxHashMap<_, usize> = FxHashMap::default();\n-                for item in assoc_items {\n-                    types_count += 1;\n-                    *names.entry(item.ident.name).or_insert(0) += 1;\n-                }\n-                let mut label = vec![];\n-                for item in assoc_items {\n-                    let postfix = if names[&item.ident.name] > 1 {\n-                        let trait_def_id = item.container.id();\n-                        format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n-                    } else {\n-                        String::new()\n-                    };\n-                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n-                }\n-                if !label.is_empty() {\n-                    err.span_label(\n-                        *span,\n-                        format!(\n-                            \"associated type{} {} must be specified\",\n-                            pluralize!(label.len()),\n-                            label.join(\", \"),\n-                        ),\n-                    );\n-                }\n-            }\n-        }\n-        if !suggestions.is_empty() {\n-            err.multipart_suggestion(\n-                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n-                suggestions,\n-                Applicability::HasPlaceholders,\n-            );\n-            if !where_constraints.is_empty() {\n-                err.span_help(where_constraints, where_msg);\n-            }\n-        }\n-        err.emit();\n-    }\n-\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,\n@@ -2289,52 +1432,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n-    fn complain_about_assoc_type_not_found<I>(\n-        &self,\n-        all_candidates: impl Fn() -> I,\n-        ty_param_name: &str,\n-        assoc_name: Ident,\n-        span: Span,\n-    ) where\n-        I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-    {\n-        // The fallback span is needed because `assoc_name` might be an `Fn()`'s `Output` without a\n-        // valid span, so we point at the whole path segment instead.\n-        let span = if assoc_name.span != DUMMY_SP { assoc_name.span } else { span };\n-        let mut err = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0220,\n-            \"associated type `{}` not found for `{}`\",\n-            assoc_name,\n-            ty_param_name\n-        );\n-\n-        let all_candidate_names: Vec<_> = all_candidates()\n-            .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n-            .flatten()\n-            .filter_map(\n-                |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n-            )\n-            .collect();\n-\n-        if let (Some(suggested_name), true) = (\n-            find_best_match_for_name(all_candidate_names.iter(), assoc_name.name, None),\n-            assoc_name.span != DUMMY_SP,\n-        ) {\n-            err.span_suggestion(\n-                assoc_name.span,\n-                \"there is an associated type with a similar name\",\n-                suggested_name.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            err.span_label(span, format!(\"associated type `{}` not found\", assoc_name));\n-        }\n-\n-        err.emit();\n-    }\n-\n     // Create a type from a path to an associated type.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n@@ -2637,57 +1734,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         has_err\n     }\n \n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0229,\n-            \"associated type bindings are not allowed here\"\n-        );\n-        err.span_label(span, \"associated type not allowed here\").emit();\n-    }\n-\n-    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n-    /// are present. This is used both for datatypes and function calls.\n-    fn prohibit_explicit_late_bound_lifetimes(\n-        tcx: TyCtxt<'_>,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-    ) -> ExplicitLateBound {\n-        let param_counts = def.own_counts();\n-        let arg_counts = args.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n-\n-        if infer_lifetimes {\n-            ExplicitLateBound::No\n-        } else if let Some(span_late) = def.has_late_bound_regions {\n-            let msg = \"cannot specify lifetime arguments explicitly \\\n-                       if late bound lifetime parameters are present\";\n-            let note = \"the late bound lifetime parameter is introduced here\";\n-            let span = args.args[0].span();\n-            if position == GenericArgPosition::Value\n-                && arg_counts.lifetimes != param_counts.lifetimes\n-            {\n-                let mut err = tcx.sess.struct_span_err(span, msg);\n-                err.span_note(span_late, note);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(span);\n-                multispan.push_span_label(span_late, note.to_string());\n-                tcx.struct_span_lint_hir(\n-                    LATE_BOUND_LIFETIME_ARGUMENTS,\n-                    args.args[0].id(),\n-                    multispan,\n-                    |lint| lint.build(msg).emit(),\n-                );\n-            }\n-            ExplicitLateBound::Yes\n-        } else {\n-            ExplicitLateBound::No\n-        }\n-    }\n-\n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n     pub fn def_ids_for_value_path_segments(\n         &self,\n@@ -3248,92 +2294,3 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Some(r)\n     }\n }\n-\n-/// Collects together a list of bounds that are applied to some type,\n-/// after they've been converted into `ty` form (from the HIR\n-/// representations). These lists of bounds occur in many places in\n-/// Rust's syntax:\n-///\n-/// ```text\n-/// trait Foo: Bar + Baz { }\n-///            ^^^^^^^^^ supertrait list bounding the `Self` type parameter\n-///\n-/// fn foo<T: Bar + Baz>() { }\n-///           ^^^^^^^^^ bounding the type parameter `T`\n-///\n-/// impl dyn Bar + Baz\n-///          ^^^^^^^^^ bounding the forgotten dynamic type\n-/// ```\n-///\n-/// Our representation is a bit mixed here -- in some cases, we\n-/// include the self type (e.g., `trait_bounds`) but in others we do\n-#[derive(Default, PartialEq, Eq, Clone, Debug)]\n-pub struct Bounds<'tcx> {\n-    /// A list of region bounds on the (implicit) self type. So if you\n-    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n-    /// the `T` is not explicitly included).\n-    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n-\n-    /// A list of trait bounds. So if you had `T: Debug` this would be\n-    /// `T: Debug`. Note that the self-type is explicit here.\n-    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, Constness)>,\n-\n-    /// A list of projection equality bounds. So if you had `T:\n-    /// Iterator<Item = u32>` this would include `<T as\n-    /// Iterator>::Item => u32`. Note that the self-type is explicit\n-    /// here.\n-    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n-\n-    /// `Some` if there is *no* `?Sized` predicate. The `span`\n-    /// is the location in the source of the `T` declaration which can\n-    /// be cited as the source of the `T: Sized` requirement.\n-    pub implicitly_sized: Option<Span>,\n-}\n-\n-impl<'tcx> Bounds<'tcx> {\n-    /// Converts a bounds list into a flat set of predicates (like\n-    /// where-clauses). Because some of our bounds listings (e.g.,\n-    /// regions) don't include the self-type, you must supply the\n-    /// self-type here (the `param_ty` parameter).\n-    pub fn predicates(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_ty: Ty<'tcx>,\n-    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-        // If it could be sized, and is, add the `Sized` predicate.\n-        let sized_predicate = self.implicitly_sized.and_then(|span| {\n-            tcx.lang_items().sized_trait().map(|sized| {\n-                let trait_ref = ty::Binder::bind(ty::TraitRef {\n-                    def_id: sized,\n-                    substs: tcx.mk_substs_trait(param_ty, &[]),\n-                });\n-                (trait_ref.without_const().to_predicate(tcx), span)\n-            })\n-        });\n-\n-        sized_predicate\n-            .into_iter()\n-            .chain(\n-                self.region_bounds\n-                    .iter()\n-                    .map(|&(region_bound, span)| {\n-                        // Account for the binder being introduced below; no need to shift `param_ty`\n-                        // because, at present at least, it either only refers to early-bound regions,\n-                        // or it's a generic associated type that deliberately has escaping bound vars.\n-                        let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n-                        let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n-                    })\n-                    .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n-                        let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n-                        (predicate, span)\n-                    }))\n-                    .chain(\n-                        self.projection_bounds\n-                            .iter()\n-                            .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n-                    ),\n-            )\n-            .collect()\n-    }\n-}", "previous_filename": "src/librustc_typeck/astconv.rs"}, {"sha": "63295f5faacc9c8b4d6aea95025c1ea17de1be56", "filename": "src/librustc_typeck/bounds.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fbounds.rs?ref=6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "patch": "@@ -0,0 +1,93 @@\n+//! Bounds are restrictions applied to some types after they've been converted into the\n+//! `ty` form from the HIR.\n+\n+use rustc_hir::Constness;\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_span::Span;\n+\n+/// Collects together a list of type bounds. These lists of bounds occur in many places\n+/// in Rust's syntax:\n+///\n+/// ```text\n+/// trait Foo: Bar + Baz { }\n+///            ^^^^^^^^^ supertrait list bounding the `Self` type parameter\n+///\n+/// fn foo<T: Bar + Baz>() { }\n+///           ^^^^^^^^^ bounding the type parameter `T`\n+///\n+/// impl dyn Bar + Baz\n+///          ^^^^^^^^^ bounding the forgotten dynamic type\n+/// ```\n+///\n+/// Our representation is a bit mixed here -- in some cases, we\n+/// include the self type (e.g., `trait_bounds`) but in others we do not\n+#[derive(Default, PartialEq, Eq, Clone, Debug)]\n+pub struct Bounds<'tcx> {\n+    /// A list of region bounds on the (implicit) self type. So if you\n+    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n+    /// the `T` is not explicitly included).\n+    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n+\n+    /// A list of trait bounds. So if you had `T: Debug` this would be\n+    /// `T: Debug`. Note that the self-type is explicit here.\n+    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, Constness)>,\n+\n+    /// A list of projection equality bounds. So if you had `T:\n+    /// Iterator<Item = u32>` this would include `<T as\n+    /// Iterator>::Item => u32`. Note that the self-type is explicit\n+    /// here.\n+    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n+\n+    /// `Some` if there is *no* `?Sized` predicate. The `span`\n+    /// is the location in the source of the `T` declaration which can\n+    /// be cited as the source of the `T: Sized` requirement.\n+    pub implicitly_sized: Option<Span>,\n+}\n+\n+impl<'tcx> Bounds<'tcx> {\n+    /// Converts a bounds list into a flat set of predicates (like\n+    /// where-clauses). Because some of our bounds listings (e.g.,\n+    /// regions) don't include the self-type, you must supply the\n+    /// self-type here (the `param_ty` parameter).\n+    pub fn predicates(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_ty: Ty<'tcx>,\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n+        // If it could be sized, and is, add the `Sized` predicate.\n+        let sized_predicate = self.implicitly_sized.and_then(|span| {\n+            tcx.lang_items().sized_trait().map(|sized| {\n+                let trait_ref = ty::Binder::bind(ty::TraitRef {\n+                    def_id: sized,\n+                    substs: tcx.mk_substs_trait(param_ty, &[]),\n+                });\n+                (trait_ref.without_const().to_predicate(tcx), span)\n+            })\n+        });\n+\n+        sized_predicate\n+            .into_iter()\n+            .chain(\n+                self.region_bounds\n+                    .iter()\n+                    .map(|&(region_bound, span)| {\n+                        // Account for the binder being introduced below; no need to shift `param_ty`\n+                        // because, at present at least, it either only refers to early-bound regions,\n+                        // or it's a generic associated type that deliberately has escaping bound vars.\n+                        let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n+                        let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n+                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n+                    })\n+                    .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n+                        let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n+                        (predicate, span)\n+                    }))\n+                    .chain(\n+                        self.projection_bounds\n+                            .iter()\n+                            .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n+                    ),\n+            )\n+            .collect()\n+    }\n+}"}, {"sha": "9afac60bb5bb78b669b15f989408d476212a9dc0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "patch": "@@ -14,7 +14,8 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use crate::astconv::{AstConv, Bounds, SizedByDefault};\n+use crate::astconv::{AstConv, SizedByDefault};\n+use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n use crate::middle::resolve_lifetime as rl;"}, {"sha": "62f92fe7ffa484859e2699610230ba8ae827740a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6cb98e3114cefd8ecd7aa6d48c29109e3a48fc60", "patch": "@@ -79,6 +79,7 @@ pub mod check;\n pub mod expr_use_visitor;\n \n mod astconv;\n+mod bounds;\n mod check_unused;\n mod coherence;\n mod collect;\n@@ -109,7 +110,8 @@ use rustc_trait_selection::traits::{\n \n use std::iter;\n \n-use astconv::{AstConv, Bounds};\n+use astconv::AstConv;\n+use bounds::Bounds;\n \n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {"}]}