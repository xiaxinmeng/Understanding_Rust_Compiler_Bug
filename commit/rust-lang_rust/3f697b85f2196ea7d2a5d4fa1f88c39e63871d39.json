{"sha": "3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "node_id": "C_kwDOAAsO6NoAKDNmNjk3Yjg1ZjIxOTZlYTdkMmE1ZDRmYTFmODhjMzllNjM4NzFkMzk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-14T17:25:37Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-14T19:29:36Z"}, "message": "Drive-by: actual -> rcvr_ty", "tree": {"sha": "6c8eb82d3e3d0b26bd60cb88fc2308ebec13e50a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c8eb82d3e3d0b26bd60cb88fc2308ebec13e50a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "html_url": "https://github.com/rust-lang/rust/commit/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4d6307c633c954971f3ca7876d4f29f3fe83614", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d6307c633c954971f3ca7876d4f29f3fe83614", "html_url": "https://github.com/rust-lang/rust/commit/e4d6307c633c954971f3ca7876d4f29f3fe83614"}], "stats": {"total": 58, "additions": 30, "deletions": 28}, "files": [{"sha": "94df6817bf5262ca54839ff27f5c0a14279a4d22", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "patch": "@@ -263,15 +263,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = self.ty_to_string(actual);\n+                let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n+                let ty_str = self.ty_to_string(rcvr_ty);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n                     \"method\"\n-                } else if actual.is_enum() {\n+                } else if rcvr_ty.is_enum() {\n                     \"variant or associated item\"\n                 } else {\n-                    match (item_name.as_str().chars().next(), actual.is_fresh_ty()) {\n+                    match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n                         (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n                         (Some(_), false) => \"associated item\",\n                         (Some(_), true) | (None, false) => \"variant or associated item\",\n@@ -280,19 +280,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n \n                 if self.suggest_wrapping_range_with_parens(\n-                    tcx, actual, source, span, item_name, &ty_str,\n+                    tcx, rcvr_ty, source, span, item_name, &ty_str,\n                 ) || self.suggest_constraining_numerical_ty(\n-                    tcx, actual, source, span, item_kind, item_name, &ty_str,\n+                    tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n                 ) {\n                     return None;\n                 }\n                 span = item_name.span;\n \n                 // Don't show generic arguments when the method can't be found in any implementation (#81576).\n                 let mut ty_str_reported = ty_str.clone();\n-                if let ty::Adt(_, generics) = actual.kind() {\n+                if let ty::Adt(_, generics) = rcvr_ty.kind() {\n                     if generics.len() > 0 {\n-                        let mut autoderef = self.autoderef(span, actual);\n+                        let mut autoderef = self.autoderef(span, rcvr_ty);\n                         let candidate_found = autoderef.any(|(ty, _)| {\n                             if let ty::Adt(adt_def, _) = ty.kind() {\n                                 self.tcx\n@@ -321,16 +321,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"no {} named `{}` found for {} `{}` in the current scope\",\n                     item_kind,\n                     item_name,\n-                    actual.prefix_string(self.tcx),\n+                    rcvr_ty.prefix_string(self.tcx),\n                     ty_str_reported,\n                 );\n-                if actual.references_error() {\n+                if rcvr_ty.references_error() {\n                     err.downgrade_to_delayed_bug();\n                 }\n \n                 if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n                     self.suggest_await_before_method(\n-                        &mut err, item_name, actual, cal, span,\n+                        &mut err, item_name, rcvr_ty, cal, span,\n                     );\n                 }\n                 if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-                if let ty::RawPtr(_) = &actual.kind() {\n+                if let ty::RawPtr(_) = &rcvr_ty.kind() {\n                     err.note(\n                         \"try using `<*const T>::as_ref()` to get a reference to the \\\n                          type behind the pointer: https://doc.rust-lang.org/std/\\\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                let ty_span = match actual.kind() {\n+                let ty_span = match rcvr_ty.kind() {\n                     ty::Param(param_type) => Some(\n                         param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n                     ),\n@@ -365,7 +365,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         format!(\n                             \"{item_kind} `{item_name}` not found for this {}\",\n-                            actual.prefix_string(self.tcx)\n+                            rcvr_ty.prefix_string(self.tcx)\n                         ),\n                     );\n                 }\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // original type that has the associated function for accurate suggestions.\n                         // (#61411)\n                         let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                        match (&ty.peel_refs().kind(), &rcvr_ty.peel_refs().kind()) {\n                             (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n                                 // If there are any inferred arguments, (`{integer}`), we should replace\n                                 // them with underscores to allow the compiler to infer them\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => self.ty_to_value_string(ty.peel_refs()),\n                         }\n                     } else {\n-                        self.ty_to_value_string(actual.peel_refs())\n+                        self.ty_to_value_string(rcvr_ty.peel_refs())\n                     };\n                     if let SelfSource::MethodCall(_) = source {\n                         let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) &&\n@@ -523,7 +523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut bound_spans = vec![];\n                 let mut restrict_type_params = false;\n                 let mut unsatisfied_bounds = false;\n-                if item_name.name == sym::count && self.is_slice_ty(actual, span) {\n+                if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n                     let msg = \"consider using `len` instead\";\n                     if let SelfSource::MethodCall(_expr) = source {\n                         err.span_suggestion_short(\n@@ -537,7 +537,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n                         let iterator_trait = self.tcx.def_path_str(iterator_trait);\n-                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{actual}` does not implement\"));\n+                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"));\n                     }\n                 } else if !unsatisfied_predicates.is_empty() {\n                     let mut type_params = FxHashMap::default();\n@@ -876,7 +876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .map(|(_, path)| path)\n                             .collect::<Vec<_>>()\n                             .join(\"\\n\");\n-                        let actual_prefix = actual.prefix_string(self.tcx);\n+                        let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n                         info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n                         let (primary_message, label) =\n                             if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     .next()\n                                     .map(|(_, (trait_ref, obligation))| {\n                                         if trait_ref.self_ty().references_error()\n-                                            || actual.references_error()\n+                                            || rcvr_ty.references_error()\n                                         {\n                                             // Avoid crashing.\n                                             return (None, None);\n@@ -921,7 +921,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let label_span_not_found = |err: &mut Diagnostic| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        let is_string_or_ref_str = match actual.kind() {\n+                        let is_string_or_ref_str = match rcvr_ty.kind() {\n                             ty::Ref(_, ty, _) => {\n                                 ty.is_str()\n                                     || matches!(\n@@ -957,7 +957,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                 // different from the received one\n                                                 // So we avoid suggestion method with Box<Self>\n                                                 // for instance\n-                                                self.tcx.at(span).type_of(*def_id) != actual\n+                                                self.tcx.at(span).type_of(*def_id) != rcvr_ty\n                                                     && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n                                             }\n                                             (Mode::Path, false, _) => true,\n@@ -1017,18 +1017,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n                 // can't be called due to `typeof(expr): Clone` not holding.\n                 if unsatisfied_predicates.is_empty() {\n-                    self.suggest_calling_method_on_field(&mut err, source, span, actual, item_name);\n+                    self.suggest_calling_method_on_field(\n+                        &mut err, source, span, rcvr_ty, item_name,\n+                    );\n                 }\n \n-                self.check_for_inner_self(&mut err, source, span, actual, item_name);\n+                self.check_for_inner_self(&mut err, source, span, rcvr_ty, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n                 for (span, msg) in bound_spans.into_iter() {\n                     err.span_label(span, &msg);\n                 }\n \n-                if actual.is_numeric() && actual.is_fresh() || restrict_type_params {\n+                if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n                 } else {\n                     self.suggest_traits_to_import(\n                         &mut err,\n@@ -1046,8 +1048,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // Don't emit a suggestion if we found an actual method\n                 // that had unsatisfied trait bounds\n-                if unsatisfied_predicates.is_empty() && actual.is_enum() {\n-                    let adt_def = actual.ty_adt_def().expect(\"enum is not an ADT\");\n+                if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n+                    let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggestion) = lev_distance::find_best_match_for_name(\n                         &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                         item_name.name,\n@@ -1062,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if item_name.name == sym::as_str && actual.peel_refs().is_str() {\n+                if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n                     let msg = \"remove this method call\";\n                     let mut fallback_span = true;\n                     if let SelfSource::MethodCall(expr) = source {"}]}