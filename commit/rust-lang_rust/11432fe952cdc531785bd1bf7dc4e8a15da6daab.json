{"sha": "11432fe952cdc531785bd1bf7dc4e8a15da6daab", "node_id": "C_kwDOAAsO6NoAKDExNDMyZmU5NTJjZGM1MzE3ODViZDFiZjdkYzRlOGExNWRhNmRhYWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T07:40:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T07:40:56Z"}, "message": "Auto merge of #102080 - yanchen4791:issue-99824-fix, r=cjgillot\n\nFix missing explanation of where the borrowed reference is used when the same borrow occurs multiple times due to loop iterations\n\nFix #99824.\n\nProblem of the issue:\nIf a borrow occurs in a loop, the borrowed reference could be invalidated at the same place at next iteration of the loop. When this happens, the point where the borrow occurs is the same as the intervening point that might invalidate the reference in the loop. This causes a problem for the current code finding the point where the resulting reference is used, so that the explanation of the cause will be missing. As the second point of \"explain all errors in terms of three points\" (see [leveraging intuition framing errors in terms of points\"](https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points), this explanation is very helpful for user to understand the error.\n\nIn the current implementation, the searching region for finding the location where the borrowed reference is used is limited to between the place where the borrow occurs and the place where the reference is invalidated. If those two places happen to be the same, which indicates that the borrow and invalidation occur at the same place in a loop, the search will fail.\n\nOne solution to the problem is when these two places are the same,  find the terminator of the loop, and then use the location of the loop terminator instead of the location of the borrow for the region to find the place where the borrowed reference is used.", "tree": {"sha": "eb8077a047dd7b6d830105390e99748fe4a1eeef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb8077a047dd7b6d830105390e99748fe4a1eeef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11432fe952cdc531785bd1bf7dc4e8a15da6daab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11432fe952cdc531785bd1bf7dc4e8a15da6daab", "html_url": "https://github.com/rust-lang/rust/commit/11432fe952cdc531785bd1bf7dc4e8a15da6daab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11432fe952cdc531785bd1bf7dc4e8a15da6daab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e928a4656f729a4df2cdc6874abf2bf06e47cef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e928a4656f729a4df2cdc6874abf2bf06e47cef9", "html_url": "https://github.com/rust-lang/rust/commit/e928a4656f729a4df2cdc6874abf2bf06e47cef9"}, {"sha": "b3bf931aa2ca95c60ec49b7f6519a1e74dae3c1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3bf931aa2ca95c60ec49b7f6519a1e74dae3c1d", "html_url": "https://github.com/rust-lang/rust/commit/b3bf931aa2ca95c60ec49b7f6519a1e74dae3c1d"}], "stats": {"total": 205, "additions": 63, "deletions": 142}, "files": [{"sha": "582d683dd359320679164d3aff5c75991122b2a7", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 23, "deletions": 133, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/11432fe952cdc531785bd1bf7dc4e8a15da6daab/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11432fe952cdc531785bd1bf7dc4e8a15da6daab/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=11432fe952cdc531785bd1bf7dc4e8a15da6daab", "patch": "@@ -1,8 +1,5 @@\n //! Print diagnostics to explain why values are borrowed.\n \n-use std::collections::VecDeque;\n-\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n@@ -359,19 +356,37 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_region_vid = borrow.region;\n         debug!(?borrow_region_vid);\n \n-        let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n+        let mut region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(?region_sub);\n \n-        match find_use::find(body, regioncx, tcx, region_sub, location) {\n+        let mut use_location = location;\n+        let mut use_in_later_iteration_of_loop = false;\n+\n+        if region_sub == borrow_region_vid {\n+            // When `region_sub` is the same as `borrow_region_vid` (the location where the borrow is\n+            // issued is the same location that invalidates the reference), this is likely a loop iteration\n+            // - in this case, try using the loop terminator location in `find_sub_region_live_at`.\n+            if let Some(loop_terminator_location) =\n+                regioncx.find_loop_terminator_location(borrow.region, body)\n+            {\n+                region_sub = self\n+                    .regioncx\n+                    .find_sub_region_live_at(borrow_region_vid, loop_terminator_location);\n+                debug!(\"explain_why_borrow_contains_point: region_sub in loop={:?}\", region_sub);\n+                use_location = loop_terminator_location;\n+                use_in_later_iteration_of_loop = true;\n+            }\n+        }\n+\n+        match find_use::find(body, regioncx, tcx, region_sub, use_location) {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = body.source_info(location).span;\n                 let spans = self\n                     .move_spans(Place::from(local).as_ref(), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n-                let borrow_location = location;\n-                if self.is_use_in_later_iteration_of_loop(borrow_location, location) {\n-                    let later_use = self.later_use_kind(borrow, spans, location);\n+                if use_in_later_iteration_of_loop {\n+                    let later_use = self.later_use_kind(borrow, spans, use_location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1, later_use.2)\n                 } else {\n                     // Check if the location represents a `FakeRead`, and adapt the error\n@@ -425,131 +440,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// true if `borrow_location` can reach `use_location` by going through a loop and\n-    /// `use_location` is also inside of that loop\n-    fn is_use_in_later_iteration_of_loop(\n-        &self,\n-        borrow_location: Location,\n-        use_location: Location,\n-    ) -> bool {\n-        let back_edge = self.reach_through_backedge(borrow_location, use_location);\n-        back_edge.map_or(false, |back_edge| self.can_reach_head_of_loop(use_location, back_edge))\n-    }\n-\n-    /// Returns the outmost back edge if `from` location can reach `to` location passing through\n-    /// that back edge\n-    fn reach_through_backedge(&self, from: Location, to: Location) -> Option<Location> {\n-        let mut visited_locations = FxHashSet::default();\n-        let mut pending_locations = VecDeque::new();\n-        visited_locations.insert(from);\n-        pending_locations.push_back(from);\n-        debug!(\"reach_through_backedge: from={:?} to={:?}\", from, to,);\n-\n-        let mut outmost_back_edge = None;\n-        while let Some(location) = pending_locations.pop_front() {\n-            debug!(\n-                \"reach_through_backedge: location={:?} outmost_back_edge={:?}\n-                   pending_locations={:?} visited_locations={:?}\",\n-                location, outmost_back_edge, pending_locations, visited_locations\n-            );\n-\n-            if location == to && outmost_back_edge.is_some() {\n-                // We've managed to reach the use location\n-                debug!(\"reach_through_backedge: found!\");\n-                return outmost_back_edge;\n-            }\n-\n-            let block = &self.body.basic_blocks[location.block];\n-\n-            if location.statement_index < block.statements.len() {\n-                let successor = location.successor_within_block();\n-                if visited_locations.insert(successor) {\n-                    pending_locations.push_back(successor);\n-                }\n-            } else {\n-                pending_locations.extend(\n-                    block\n-                        .terminator()\n-                        .successors()\n-                        .map(|bb| Location { statement_index: 0, block: bb })\n-                        .filter(|s| visited_locations.insert(*s))\n-                        .map(|s| {\n-                            if self.is_back_edge(location, s) {\n-                                match outmost_back_edge {\n-                                    None => {\n-                                        outmost_back_edge = Some(location);\n-                                    }\n-\n-                                    Some(back_edge)\n-                                        if location.dominates(back_edge, &self.dominators) =>\n-                                    {\n-                                        outmost_back_edge = Some(location);\n-                                    }\n-\n-                                    Some(_) => {}\n-                                }\n-                            }\n-\n-                            s\n-                        }),\n-                );\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// true if `from` location can reach `loop_head` location and `loop_head` dominates all the\n-    /// intermediate nodes\n-    fn can_reach_head_of_loop(&self, from: Location, loop_head: Location) -> bool {\n-        self.find_loop_head_dfs(from, loop_head, &mut FxHashSet::default())\n-    }\n-\n-    fn find_loop_head_dfs(\n-        &self,\n-        from: Location,\n-        loop_head: Location,\n-        visited_locations: &mut FxHashSet<Location>,\n-    ) -> bool {\n-        visited_locations.insert(from);\n-\n-        if from == loop_head {\n-            return true;\n-        }\n-\n-        if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.body.basic_blocks[from.block];\n-\n-            if from.statement_index < block.statements.len() {\n-                let successor = from.successor_within_block();\n-\n-                if !visited_locations.contains(&successor)\n-                    && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n-                {\n-                    return true;\n-                }\n-            } else {\n-                for bb in block.terminator().successors() {\n-                    let successor = Location { statement_index: 0, block: bb };\n-\n-                    if !visited_locations.contains(&successor)\n-                        && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n-                    {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// True if an edge `source -> target` is a backedge -- in other words, if the target\n-    /// dominates the source.\n-    fn is_back_edge(&self, source: Location, target: Location) -> bool {\n-        target.dominates(source, &self.dominators)\n-    }\n-\n     /// Determine how the borrow was later used.\n     /// First span returned points to the location of the conflicting use\n     /// Second span if `Some` is returned in the case of closures and points"}, {"sha": "8b63294fbab0ee3af1abd29c58269aa2546352e5", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/11432fe952cdc531785bd1bf7dc4e8a15da6daab/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11432fe952cdc531785bd1bf7dc4e8a15da6daab/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=11432fe952cdc531785bd1bf7dc4e8a15da6daab", "patch": "@@ -15,7 +15,7 @@ use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound,\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, ReturnConstraint,\n+    ConstraintCategory, Local, Location, ReturnConstraint, TerminatorKind,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n@@ -2236,6 +2236,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n         self.universe_causes[&universe].clone()\n     }\n+\n+    /// Tries to find the terminator of the loop in which the region 'r' resides.\n+    /// Returns the location of the terminator if found.\n+    pub(crate) fn find_loop_terminator_location(\n+        &self,\n+        r: RegionVid,\n+        body: &Body<'_>,\n+    ) -> Option<Location> {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let locations = self.scc_values.locations_outlived_by(scc);\n+        for location in locations {\n+            let bb = &body[location.block];\n+            if let Some(terminator) = &bb.terminator {\n+                // terminator of a loop should be TerminatorKind::FalseUnwind\n+                if let TerminatorKind::FalseUnwind { .. } = terminator.kind {\n+                    return Some(location);\n+                }\n+            }\n+        }\n+        None\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}, {"sha": "d2b845619c784da6c34789b2da83f713d08eb6e0", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11432fe952cdc531785bd1bf7dc4e8a15da6daab/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11432fe952cdc531785bd1bf7dc4e8a15da6daab/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr?ref=11432fe952cdc531785bd1bf7dc4e8a15da6daab", "patch": "@@ -25,7 +25,10 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:12:30\n    |\n LL |             _ => { addr.push(&mut x); }\n-   |                              ^^^^^^ `x` was mutably borrowed here in the previous iteration of the loop\n+   |                    ----------^^^^^^-\n+   |                    |         |\n+   |                    |         `x` was mutably borrowed here in the previous iteration of the loop\n+   |                    first borrow used here, in later iteration of loop\n \n error: aborting due to 3 previous errors\n "}, {"sha": "22f9b39dfeecbc19ccb8f965b0ab22ccac2ddec9", "filename": "src/test/ui/borrowck/two-phase-across-loop.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11432fe952cdc531785bd1bf7dc4e8a15da6daab/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-across-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11432fe952cdc531785bd1bf7dc4e8a15da6daab/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-across-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-across-loop.stderr?ref=11432fe952cdc531785bd1bf7dc4e8a15da6daab", "patch": "@@ -2,7 +2,10 @@ error[E0499]: cannot borrow `foo` as mutable more than once at a time\n   --> $DIR/two-phase-across-loop.rs:17:22\n    |\n LL |         strings.push(foo.get_string());\n-   |                      ^^^^^^^^^^^^^^^^ `foo` was mutably borrowed here in the previous iteration of the loop\n+   |         -------------^^^^^^^^^^^^^^^^-\n+   |         |            |\n+   |         |            `foo` was mutably borrowed here in the previous iteration of the loop\n+   |         first borrow used here, in later iteration of loop\n \n error: aborting due to previous error\n "}, {"sha": "1c1a31d356d6f4e4423332c45a2043fd41082a42", "filename": "src/test/ui/nll/closures-in-loops.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11432fe952cdc531785bd1bf7dc4e8a15da6daab/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/11432fe952cdc531785bd1bf7dc4e8a15da6daab/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr?ref=11432fe952cdc531785bd1bf7dc4e8a15da6daab", "patch": "@@ -13,17 +13,21 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/closures-in-loops.rs:13:16\n    |\n LL |         v.push(|| x = String::new());\n-   |                ^^ - borrows occur due to use of `x` in closure\n-   |                |\n-   |                `x` was mutably borrowed here in the previous iteration of the loop\n+   |         -------^^-------------------\n+   |         |      |  |\n+   |         |      |  borrows occur due to use of `x` in closure\n+   |         |      `x` was mutably borrowed here in the previous iteration of the loop\n+   |         first borrow used here, in later iteration of loop\n \n error[E0524]: two closures require unique access to `x` at the same time\n   --> $DIR/closures-in-loops.rs:20:16\n    |\n LL |         v.push(|| *x = String::new());\n-   |                ^^ -- borrows occur due to use of `x` in closure\n-   |                |\n-   |                closures are constructed here in different iterations of loop\n+   |         -------^^--------------------\n+   |         |      |  |\n+   |         |      |  borrows occur due to use of `x` in closure\n+   |         |      closures are constructed here in different iterations of loop\n+   |         first borrow used here, in later iteration of loop\n \n error: aborting due to 3 previous errors\n "}]}