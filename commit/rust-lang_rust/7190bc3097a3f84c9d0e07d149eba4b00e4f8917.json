{"sha": "7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "node_id": "C_kwDOAAsO6NoAKDcxOTBiYzMwOTdhM2Y4NGM5ZDBlMDdkMTQ5ZWJhNGIwMGU0Zjg5MTc", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-05-15T21:56:28Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-24T20:02:09Z"}, "message": "Account for incorrect `impl Foo<const N: ty> {}` syntax\n\nFix #84946", "tree": {"sha": "c3c03074b83b4ca2c87fb6622ad3c7f0fd8ff393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c03074b83b4ca2c87fb6622ad3c7f0fd8ff393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "html_url": "https://github.com/rust-lang/rust/commit/7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "url": "https://api.github.com/repos/rust-lang/rust/commits/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b", "html_url": "https://github.com/rust-lang/rust/commit/311fa1f14dd8ffbbe83b229a94b17f7f1ecaf33b"}], "stats": {"total": 260, "additions": 206, "deletions": 54}, "files": [{"sha": "55b243a84a9a342768b8387294b050bcbe85b003", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -405,6 +405,21 @@ pub struct GenericParam {\n     pub kind: GenericParamKind,\n }\n \n+impl GenericParam {\n+    pub fn span(&self) -> Span {\n+        match &self.kind {\n+            GenericParamKind::Lifetime | GenericParamKind::Type { default: None } => {\n+                self.ident.span\n+            }\n+            GenericParamKind::Type { default: Some(ty) } => self.ident.span.to(ty.span),\n+            GenericParamKind::Const { kw_span, default: Some(default), .. } => {\n+                kw_span.to(default.value.span)\n+            }\n+            GenericParamKind::Const { kw_span, default: None, ty } => kw_span.to(ty.span),\n+        }\n+    }\n+}\n+\n /// Represents lifetime, type and const parameters attached to a declaration of\n /// a function, enum, trait, etc.\n #[derive(Clone, Encodable, Decodable, Debug)]"}, {"sha": "16ab798708c469a8e14da9a77de9da2cbaf7db37", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 6, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -6,9 +6,11 @@ use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n-use rustc_ast::{AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec};\n-use rustc_ast::{BinOpKind, BindingMode, Block, BlockCheckMode, Expr, ExprKind, GenericArg, Item};\n-use rustc_ast::{ItemKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QSelf, Ty, TyKind};\n+use rustc_ast::{\n+    AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingMode, Block,\n+    BlockCheckMode, Expr, ExprKind, GenericArg, Generics, Item, ItemKind, Mutability, Param, Pat,\n+    PatKind, Path, PathSegment, QSelf, Ty, TyKind,\n+};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err};\n@@ -662,7 +664,7 @@ impl<'a> Parser<'a> {\n             let snapshot = self.clone();\n             self.bump();\n             let lo = self.token.span;\n-            match self.parse_angle_args() {\n+            match self.parse_angle_args(None) {\n                 Ok(args) => {\n                     let span = lo.to(self.prev_token.span);\n                     // Detect trailing `>` like in `x.collect::Vec<_>>()`.\n@@ -719,7 +721,7 @@ impl<'a> Parser<'a> {\n                     let x = self.parse_seq_to_before_end(\n                         &token::Gt,\n                         SeqSep::trailing_allowed(token::Comma),\n-                        |p| p.parse_generic_arg(),\n+                        |p| p.parse_generic_arg(None),\n                     );\n                     match x {\n                         Ok((_, _, false)) => {\n@@ -1103,7 +1105,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::ModSep)?;\n \n         let mut path = ast::Path { segments: Vec::new(), span: DUMMY_SP, tokens: None };\n-        self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n+        self.parse_path_segments(&mut path.segments, T::PATH_STYLE, None)?;\n         path.span = ty_span.to(self.prev_token.span);\n \n         let ty_str = self.span_to_snippet(ty_span).unwrap_or_else(|_| pprust::ty_to_string(&ty));\n@@ -1909,6 +1911,74 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n+    fn recover_const_param_decl(\n+        &mut self,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, Option<GenericArg>> {\n+        let snapshot = self.clone();\n+        let param = match self.parse_const_param(vec![]) {\n+            Ok(param) => param,\n+            Err(mut err) => {\n+                err.cancel();\n+                *self = snapshot;\n+                return Err(err);\n+            }\n+        };\n+        let mut err =\n+            self.struct_span_err(param.ident.span, \"unexpected `const` parameter declaration\");\n+        err.span_label(\n+            param.ident.span,\n+            \"expected a `const` expression, not a parameter declaration\",\n+        );\n+        if let (Some(generics), Ok(snippet)) =\n+            (ty_generics, self.sess.source_map().span_to_snippet(param.span()))\n+        {\n+            let (span, sugg) = match &generics.params[..] {\n+                [] => (generics.span, format!(\"<{}>\", snippet)),\n+                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {}\", snippet)),\n+            };\n+            err.multipart_suggestion(\n+                \"`const` parameters must be declared for the `impl`\",\n+                vec![(span, sugg), (param.span(), param.ident.to_string())],\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        let value = self.mk_expr_err(param.span());\n+        err.emit();\n+        return Ok(Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value })));\n+    }\n+\n+    pub fn recover_const_param_declaration(\n+        &mut self,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, Option<GenericArg>> {\n+        // We have to check for a few different cases.\n+        if let Ok(arg) = self.recover_const_param_decl(ty_generics) {\n+            return Ok(arg);\n+        }\n+\n+        // We haven't consumed `const` yet.\n+        let start = self.token.span;\n+        self.bump(); // `const`\n+\n+        // Detect and recover from the old, pre-RFC2000 syntax for const generics.\n+        let mut err = self\n+            .struct_span_err(start, \"expected lifetime, type, or constant, found keyword `const`\");\n+        if self.check_const_arg() {\n+            err.span_suggestion_verbose(\n+                start.until(self.token.span),\n+                \"the `const` keyword is only needed in the definition of the type\",\n+                String::new(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            err.emit();\n+            Ok(Some(GenericArg::Const(self.parse_const_arg()?)))\n+        } else {\n+            let after_kw_const = self.token.span;\n+            self.recover_const_arg(after_kw_const, err).map(Some)\n+        }\n+    }\n+\n     /// Try to recover from possible generic const argument without `{` and `}`.\n     ///\n     /// When encountering code like `foo::< bar + 3 >` or `foo::< bar - baz >` we suggest"}, {"sha": "54f28ea0058dbe914d9bf9732f4fd2ccf7e3a6cb", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -1150,7 +1150,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let fn_span_lo = self.token.span;\n-        let mut segment = self.parse_path_segment(PathStyle::Expr)?;\n+        let mut segment = self.parse_path_segment(PathStyle::Expr, None)?;\n         self.check_trailing_angle_brackets(&segment, &[&token::OpenDelim(token::Paren)]);\n         self.check_turbofish_missing_angle_brackets(&mut segment);\n "}, {"sha": "a9ab2cd3f68ef77278f97e72961d5ed30bd8aa0b", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -48,7 +48,10 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn parse_const_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, GenericParam> {\n+    crate fn parse_const_param(\n+        &mut self,\n+        preceding_attrs: Vec<Attribute>,\n+    ) -> PResult<'a, GenericParam> {\n         let const_span = self.token.span;\n \n         self.expect_keyword(kw::Const)?;"}, {"sha": "24a8df49ac7eefb20653314af14b2372d899f5dc", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -514,7 +514,7 @@ impl<'a> Parser<'a> {\n                 tokens: None,\n             })\n         } else {\n-            self.parse_ty()?\n+            self.parse_ty_with_generics_recovery(&generics)?\n         };\n \n         // If `for` is missing we try to recover."}, {"sha": "7f8fadb33bd8af58de28ee95c09865d98c17bc90", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -3,10 +3,11 @@ use super::{Parser, TokenType};\n use crate::maybe_whole;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n-use rustc_ast::{self as ast, AngleBracketedArg, AngleBracketedArgs, ParenthesizedArgs};\n-use rustc_ast::{AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use rustc_ast::{GenericArg, GenericArgs};\n-use rustc_ast::{Path, PathSegment, QSelf};\n+use rustc_ast::{\n+    self as ast, AngleBracketedArg, AngleBracketedArgs, AnonConst, AssocTyConstraint,\n+    AssocTyConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n+    Path, PathSegment, QSelf,\n+};\n use rustc_errors::{pluralize, Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -78,7 +79,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let qself = QSelf { ty, path_span, position: path.segments.len() };\n-        self.parse_path_segments(&mut path.segments, style)?;\n+        self.parse_path_segments(&mut path.segments, style, None)?;\n \n         Ok((\n             qself,\n@@ -119,6 +120,10 @@ impl<'a> Parser<'a> {\n         true\n     }\n \n+    pub(super) fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+        self.parse_path_inner(style, None)\n+    }\n+\n     /// Parses simple paths.\n     ///\n     /// `path = [::] segment+`\n@@ -129,7 +134,11 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub(super) fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+    pub(super) fn parse_path_inner(\n+        &mut self,\n+        style: PathStyle,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {\n@@ -152,7 +161,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::ModSep) {\n             segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n-        self.parse_path_segments(&mut segments, style)?;\n+        self.parse_path_segments(&mut segments, style, ty_generics)?;\n \n         Ok(Path { segments, span: lo.to(self.prev_token.span), tokens: None })\n     }\n@@ -161,9 +170,10 @@ impl<'a> Parser<'a> {\n         &mut self,\n         segments: &mut Vec<PathSegment>,\n         style: PathStyle,\n+        ty_generics: Option<&Generics>,\n     ) -> PResult<'a, ()> {\n         loop {\n-            let segment = self.parse_path_segment(style)?;\n+            let segment = self.parse_path_segment(style, ty_generics)?;\n             if style == PathStyle::Expr {\n                 // In order to check for trailing angle brackets, we must have finished\n                 // recursing (`parse_path_segment` can indirectly call this function),\n@@ -191,7 +201,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n+    pub(super) fn parse_path_segment(\n+        &mut self,\n+        style: PathStyle,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, PathSegment> {\n         let ident = self.parse_path_segment_ident()?;\n         let is_args_start = |token: &Token| {\n             matches!(\n@@ -229,18 +243,21 @@ impl<'a> Parser<'a> {\n                 let lo = self.token.span;\n                 let args = if self.eat_lt() {\n                     // `<'a, T, A = U>`\n-                    let args =\n-                        self.parse_angle_args_with_leading_angle_bracket_recovery(style, lo)?;\n+                    let args = self.parse_angle_args_with_leading_angle_bracket_recovery(\n+                        style,\n+                        lo,\n+                        ty_generics,\n+                    )?;\n                     self.expect_gt()?;\n                     let span = lo.to(self.prev_token.span);\n                     AngleBracketedArgs { args, span }.into()\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                     let inputs_span = lo.to(self.prev_token.span);\n-                    let span = ident.span.to(self.prev_token.span);\n                     let output =\n                         self.parse_ret_ty(AllowPlus::No, RecoverQPath::No, RecoverReturnSign::No)?;\n+                    let span = ident.span.to(self.prev_token.span);\n                     ParenthesizedArgs { span, inputs, inputs_span, output }.into()\n                 };\n \n@@ -275,6 +292,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         style: PathStyle,\n         lo: Span,\n+        ty_generics: Option<&Generics>,\n     ) -> PResult<'a, Vec<AngleBracketedArg>> {\n         // We need to detect whether there are extra leading left angle brackets and produce an\n         // appropriate error and suggestion. This cannot be implemented by looking ahead at\n@@ -350,7 +368,7 @@ impl<'a> Parser<'a> {\n         let snapshot = if is_first_invocation { Some(self.clone()) } else { None };\n \n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n-        match self.parse_angle_args() {\n+        match self.parse_angle_args(ty_generics) {\n             Ok(args) => Ok(args),\n             Err(mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n                 // Swap `self` with our backup of the parser state before attempting to parse\n@@ -403,7 +421,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n \n                     // Try again without unmatched angle bracket characters.\n-                    self.parse_angle_args()\n+                    self.parse_angle_args(ty_generics)\n                 }\n             }\n             Err(e) => Err(e),\n@@ -412,9 +430,12 @@ impl<'a> Parser<'a> {\n \n     /// Parses (possibly empty) list of generic arguments / associated item constraints,\n     /// possibly including trailing comma.\n-    pub(super) fn parse_angle_args(&mut self) -> PResult<'a, Vec<AngleBracketedArg>> {\n+    pub(super) fn parse_angle_args(\n+        &mut self,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, Vec<AngleBracketedArg>> {\n         let mut args = Vec::new();\n-        while let Some(arg) = self.parse_angle_arg()? {\n+        while let Some(arg) = self.parse_angle_arg(ty_generics)? {\n             args.push(arg);\n             if !self.eat(&token::Comma) {\n                 if !self.token.kind.should_end_const_arg() {\n@@ -431,9 +452,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a single argument in the angle arguments `<...>` of a path segment.\n-    fn parse_angle_arg(&mut self) -> PResult<'a, Option<AngleBracketedArg>> {\n+    fn parse_angle_arg(\n+        &mut self,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, Option<AngleBracketedArg>> {\n         let lo = self.token.span;\n-        let arg = self.parse_generic_arg()?;\n+        let arg = self.parse_generic_arg(ty_generics)?;\n         match arg {\n             Some(arg) => {\n                 if self.check(&token::Colon) | self.check(&token::Eq) {\n@@ -476,7 +500,7 @@ impl<'a> Parser<'a> {\n     /// That is, parse `<term>` in `Item = <term>`.\n     /// Right now, this only admits types in `<term>`.\n     fn parse_assoc_equality_term(&mut self, ident: Ident, eq: Span) -> PResult<'a, P<ast::Ty>> {\n-        let arg = self.parse_generic_arg()?;\n+        let arg = self.parse_generic_arg(None)?;\n         let span = ident.span.to(self.prev_token.span);\n         match arg {\n             Some(GenericArg::Type(ty)) => return Ok(ty),\n@@ -563,7 +587,10 @@ impl<'a> Parser<'a> {\n \n     /// Parse a generic argument in a path segment.\n     /// This does not include constraints, e.g., `Item = u8`, which is handled in `parse_angle_arg`.\n-    pub(super) fn parse_generic_arg(&mut self) -> PResult<'a, Option<GenericArg>> {\n+    pub(super) fn parse_generic_arg(\n+        &mut self,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, Option<GenericArg>> {\n         let start = self.token.span;\n         let arg = if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n             // Parse lifetime argument.\n@@ -580,25 +607,8 @@ impl<'a> Parser<'a> {\n                     return self.recover_const_arg(start, err).map(Some);\n                 }\n             }\n-        } else if self.eat_keyword_noexpect(kw::Const) {\n-            // Detect and recover from the old, pre-RFC2000 syntax for const generics.\n-            let mut err = self.struct_span_err(\n-                start,\n-                \"expected lifetime, type, or constant, found keyword `const`\",\n-            );\n-            if self.check_const_arg() {\n-                err.span_suggestion_verbose(\n-                    start.until(self.token.span),\n-                    \"the `const` keyword is only needed in the definition of the type\",\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n-                GenericArg::Const(self.parse_const_arg()?)\n-            } else {\n-                let after_kw_const = self.token.span;\n-                return self.recover_const_arg(after_kw_const, err).map(Some);\n-            }\n+        } else if self.token.is_keyword(kw::Const) {\n+            return self.recover_const_param_declaration(ty_generics);\n         } else {\n             return Ok(None);\n         };"}, {"sha": "9bfde0e3900da7f086197b832653f8bf72e5cd96", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -4,9 +4,10 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token, TokenKind};\n-use rustc_ast::{self as ast, BareFnTy, FnRetTy, GenericParam, Lifetime, MutTy, Ty, TyKind};\n-use rustc_ast::{GenericBound, GenericBounds, MacCall, Mutability};\n-use rustc_ast::{PolyTraitRef, TraitBoundModifier, TraitObjectSyntax};\n+use rustc_ast::{\n+    self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n+    MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n+};\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym};\n@@ -98,6 +99,20 @@ impl<'a> Parser<'a> {\n             AllowCVariadic::No,\n             RecoverQPath::Yes,\n             RecoverReturnSign::Yes,\n+            None,\n+        )\n+    }\n+\n+    pub(super) fn parse_ty_with_generics_recovery(\n+        &mut self,\n+        ty_params: &Generics,\n+    ) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(\n+            AllowPlus::Yes,\n+            AllowCVariadic::No,\n+            RecoverQPath::Yes,\n+            RecoverReturnSign::Yes,\n+            Some(ty_params),\n         )\n     }\n \n@@ -110,6 +125,7 @@ impl<'a> Parser<'a> {\n             AllowCVariadic::Yes,\n             RecoverQPath::Yes,\n             RecoverReturnSign::Yes,\n+            None,\n         )\n     }\n \n@@ -125,6 +141,7 @@ impl<'a> Parser<'a> {\n             AllowCVariadic::No,\n             RecoverQPath::Yes,\n             RecoverReturnSign::Yes,\n+            None,\n         )\n     }\n \n@@ -135,6 +152,7 @@ impl<'a> Parser<'a> {\n             AllowCVariadic::Yes,\n             RecoverQPath::Yes,\n             RecoverReturnSign::OnlyFatArrow,\n+            None,\n         )\n     }\n \n@@ -152,6 +170,7 @@ impl<'a> Parser<'a> {\n                 AllowCVariadic::No,\n                 recover_qpath,\n                 recover_return_sign,\n+                None,\n             )?;\n             FnRetTy::Ty(ty)\n         } else if recover_return_sign.can_recover(&self.token.kind) {\n@@ -171,6 +190,7 @@ impl<'a> Parser<'a> {\n                 AllowCVariadic::No,\n                 recover_qpath,\n                 recover_return_sign,\n+                None,\n             )?;\n             FnRetTy::Ty(ty)\n         } else {\n@@ -184,6 +204,7 @@ impl<'a> Parser<'a> {\n         allow_c_variadic: AllowCVariadic,\n         recover_qpath: RecoverQPath,\n         recover_return_sign: RecoverReturnSign,\n+        ty_generics: Option<&Generics>,\n     ) -> PResult<'a, P<Ty>> {\n         let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n@@ -233,7 +254,7 @@ impl<'a> Parser<'a> {\n             let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.check_path() {\n-            self.parse_path_start_ty(lo, allow_plus)?\n+            self.parse_path_start_ty(lo, allow_plus, ty_generics)?\n         } else if self.can_begin_bound() {\n             self.parse_bare_trait_object(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n@@ -512,9 +533,14 @@ impl<'a> Parser<'a> {\n     /// 1. a type macro, `mac!(...)`,\n     /// 2. a bare trait object, `B0 + ... + Bn`,\n     /// 3. or a path, `path::to::MyType`.\n-    fn parse_path_start_ty(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n+    fn parse_path_start_ty(\n+        &mut self,\n+        lo: Span,\n+        allow_plus: AllowPlus,\n+        ty_generics: Option<&Generics>,\n+    ) -> PResult<'a, TyKind> {\n         // Simple path\n-        let path = self.parse_path(PathStyle::Type)?;\n+        let path = self.parse_path_inner(PathStyle::Type, ty_generics)?;\n         if self.eat(&token::Not) {\n             // Macro invocation in type position\n             Ok(TyKind::MacCall(MacCall {"}, {"sha": "ecdfce1e19e6b6290e587073a7ff922dfe9190f6", "filename": "src/test/ui/parser/const-param-decl-on-type-instead-of-impl.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/src%2Ftest%2Fui%2Fparser%2Fconst-param-decl-on-type-instead-of-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/src%2Ftest%2Fui%2Fparser%2Fconst-param-decl-on-type-instead-of-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fconst-param-decl-on-type-instead-of-impl.rs?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -0,0 +1,6 @@\n+struct NInts<const N: usize>([u8; N]);\n+impl NInts<const N: usize> {} //~ ERROR unexpected `const` parameter declaration\n+\n+fn main() {\n+    let _: () = 42; //~ ERROR mismatched types\n+}"}, {"sha": "07c7c69f8d63e528b365381397a7185e1debe95c", "filename": "src/test/ui/parser/const-param-decl-on-type-instead-of-impl.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/src%2Ftest%2Fui%2Fparser%2Fconst-param-decl-on-type-instead-of-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7190bc3097a3f84c9d0e07d149eba4b00e4f8917/src%2Ftest%2Fui%2Fparser%2Fconst-param-decl-on-type-instead-of-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fconst-param-decl-on-type-instead-of-impl.stderr?ref=7190bc3097a3f84c9d0e07d149eba4b00e4f8917", "patch": "@@ -0,0 +1,22 @@\n+error: unexpected `const` parameter declaration\n+  --> $DIR/const-param-decl-on-type-instead-of-impl.rs:2:18\n+   |\n+LL | impl NInts<const N: usize> {}\n+   |                  ^ expected a `const` expression, not a parameter declaration\n+   |\n+help: `const` parameters must be declared for the `impl`\n+   |\n+LL | impl<const N: usize> NInts<N> {}\n+   |     ++++++++++++++++       ~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/const-param-decl-on-type-instead-of-impl.rs:5:17\n+   |\n+LL |     let _: () = 42;\n+   |            --   ^^ expected `()`, found integer\n+   |            |\n+   |            expected due to this\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}