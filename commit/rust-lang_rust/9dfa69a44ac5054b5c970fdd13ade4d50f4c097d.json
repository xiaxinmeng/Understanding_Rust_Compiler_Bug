{"sha": "9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZmE2OWE0NGFjNTA1NGI1Yzk3MGZkZDEzYWRlNGQ1MGY0YzA5N2Q=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-04T13:28:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-04T13:28:05Z"}, "message": "Merge #5935\n\n5935: Rewrite import insertion r=matklad a=Veykril\n\nThis is my attempt at refactoring the import insertion #3947. I hope what I created here is somewhat in line with what was requested, it wouldn't surprise me .\r\n\r\n`common_prefix` is a copy from `merge_imports.rs` so those should be unified somewhere, `try_merge_trees` is also copied from there but slighly modified to take the `MergeBehaviour` enum into account.\r\n`MergeBehaviour` should in the end become a configuration option, and the order if `ImportGroup` probably as well?\r\n\r\nI'm not too familiar with the assist stuff and the like which is why I dont know what i have to do with `insert_use_statement` and `find_insert_use_container` for now.\r\n\r\nI will most likely add more test cases in the end as well as I currently only tried to hit every path in `find_insert_position`. \r\nSome of the merge tests also fail atm due to them not sorting what they insert. There is also this test case I'm not sure if we want to support it. I would assume we want to? https://github.com/rust-analyzer/rust-analyzer/pull/5935/files#diff-6923916dd8bdd2f1ab4b984adacd265fR540-R547\r\n\r\nThe entire module was rewritten so looking at the the file itself is probably better than looking at the diff.\r\n\r\nRegarding the sub issues of #3947:\r\n- #3301: This is fixed with the rewrite, what this implementation does is that it scans through the first occurence of groupings and picks the appropriate one out. This means the user can actually rearrange the groupings on a per file basis to their liking. If a group isnt being found it is inserted according to the `ImportGroup` variant order(Would be nice if this was configurable I imagine).\r\n- #3831: This should be fixed with the introduced `MergeBehaviour` enum and it's `Last` variant.\r\n- #3946: This should also be [fixed](https://github.com/rust-analyzer/rust-analyzer/pull/5935/files#diff-6923916dd8bdd2f1ab4b984adacd265fR87)\r\n- #5795: This is fixed in the sense that the grouping search picks the first group that is of the same kind as the import that is being added. So if  there is a random import in the middle of the program it should only be considered if there is no group of the same kind in the file already present.\r\n- the last point in the list I havent checked yet, tho I got the feeling that it's not gonna be too simple as that will require knowledge of whether in this example `ast` is a crate or the module that is already imported.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "58b1f9069d022c985ef57a74212fcefd03a877c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58b1f9069d022c985ef57a74212fcefd03a877c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfUkDlCRBK7hj4Ov3rIwAAdHIIAAPOkhuP02rKsBpDy0oS/w3u\n6QgYU+rLGZbYXhEEulvv9DuC+eqlBF0vcMA1Oa/VOtaqVz1th6BWhASR3US8c7aQ\ndGcUmqlpugZE/ehPrO89WAWVF1m1yD0mzL/kvHVNfUDnPMEVViNiEzpaTp6489WY\n73Mf09KwH/zS51MMBlGgPRJmezlZw+m3jiIJBuTg2JxONaVDvsCpH/WT18vId7a3\nVo9b18u2guT/B/h2vFGOWL7qtm0ts10j/+CbsqVidSq424SzaRgf7sgp/Bmi+DIm\nAW0UZVbbiV3G5rq0wPhhVoXk1O4GSsSxsJDUaiIEyvvvtyQ3FTUX7fNKBuCUI3w=\n=+qC7\n-----END PGP SIGNATURE-----\n", "payload": "tree 58b1f9069d022c985ef57a74212fcefd03a877c3\nparent 8a21b2c96acb351baa81422f6633462b5db2298a\nparent 82f61e6629f709d7f347fd801ef5c31f476ff29e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1599226085 +0000\ncommitter GitHub <noreply@github.com> 1599226085 +0000\n\nMerge #5935\n\n5935: Rewrite import insertion r=matklad a=Veykril\n\nThis is my attempt at refactoring the import insertion #3947. I hope what I created here is somewhat in line with what was requested, it wouldn't surprise me .\r\n\r\n`common_prefix` is a copy from `merge_imports.rs` so those should be unified somewhere, `try_merge_trees` is also copied from there but slighly modified to take the `MergeBehaviour` enum into account.\r\n`MergeBehaviour` should in the end become a configuration option, and the order if `ImportGroup` probably as well?\r\n\r\nI'm not too familiar with the assist stuff and the like which is why I dont know what i have to do with `insert_use_statement` and `find_insert_use_container` for now.\r\n\r\nI will most likely add more test cases in the end as well as I currently only tried to hit every path in `find_insert_position`. \r\nSome of the merge tests also fail atm due to them not sorting what they insert. There is also this test case I'm not sure if we want to support it. I would assume we want to? https://github.com/rust-analyzer/rust-analyzer/pull/5935/files#diff-6923916dd8bdd2f1ab4b984adacd265fR540-R547\r\n\r\nThe entire module was rewritten so looking at the the file itself is probably better than looking at the diff.\r\n\r\nRegarding the sub issues of #3947:\r\n- #3301: This is fixed with the rewrite, what this implementation does is that it scans through the first occurence of groupings and picks the appropriate one out. This means the user can actually rearrange the groupings on a per file basis to their liking. If a group isnt being found it is inserted according to the `ImportGroup` variant order(Would be nice if this was configurable I imagine).\r\n- #3831: This should be fixed with the introduced `MergeBehaviour` enum and it's `Last` variant.\r\n- #3946: This should also be [fixed](https://github.com/rust-analyzer/rust-analyzer/pull/5935/files#diff-6923916dd8bdd2f1ab4b984adacd265fR87)\r\n- #5795: This is fixed in the sense that the grouping search picks the first group that is of the same kind as the import that is being added. So if  there is a random import in the middle of the program it should only be considered if there is no group of the same kind in the file already present.\r\n- the last point in the list I havent checked yet, tho I got the feeling that it's not gonna be too simple as that will require knowledge of whether in this example `ast` is a crate or the module that is already imported.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "html_url": "https://github.com/rust-lang/rust/commit/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a21b2c96acb351baa81422f6633462b5db2298a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a21b2c96acb351baa81422f6633462b5db2298a", "html_url": "https://github.com/rust-lang/rust/commit/8a21b2c96acb351baa81422f6633462b5db2298a"}, {"sha": "82f61e6629f709d7f347fd801ef5c31f476ff29e", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f61e6629f709d7f347fd801ef5c31f476ff29e", "html_url": "https://github.com/rust-lang/rust/commit/82f61e6629f709d7f347fd801ef5c31f476ff29e"}], "stats": {"total": 1279, "additions": 744, "deletions": 535}, "files": [{"sha": "66e8191548a5c391749c51080330fd4d5cdbb10a", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "patch": "@@ -1,19 +1,22 @@\n use std::collections::BTreeSet;\n \n+use ast::make;\n use either::Either;\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n };\n use ide_db::{imports_locator, RootDatabase};\n+use insert_use::ImportScope;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, AstNode},\n     SyntaxNode,\n };\n \n use crate::{\n-    utils::insert_use_statement, AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n+    utils::{insert_use, MergeBehaviour},\n+    AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n \n // Assist: auto_import\n@@ -44,19 +47,22 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n     let group = auto_import_assets.get_import_group_message();\n+    let scope =\n+        ImportScope::find_insert_use_container(&auto_import_assets.syntax_under_caret, ctx)?;\n+    let syntax = scope.as_syntax_node();\n     for import in proposed_imports {\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n             format!(\"Import `{}`\", &import),\n             range,\n             |builder| {\n-                insert_use_statement(\n-                    &auto_import_assets.syntax_under_caret,\n-                    &import.to_string(),\n-                    ctx,\n-                    builder.text_edit_builder(),\n+                let new_syntax = insert_use(\n+                    &scope,\n+                    make::path_from_text(&import.to_string()),\n+                    Some(MergeBehaviour::Full),\n                 );\n+                builder.replace(syntax.text_range(), new_syntax.to_string())\n             },\n         );\n     }\n@@ -358,7 +364,7 @@ mod tests {\n             }\n             \",\n             r\"\n-            use PubMod::{PubStruct2, PubStruct1};\n+            use PubMod::{PubStruct1, PubStruct2};\n \n             struct Test {\n                 test: PubStruct2<u8>,"}, {"sha": "80c62d8bba7ff78ded65d04ca5dad2fb5e93701b", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "patch": "@@ -10,9 +10,12 @@ use syntax::{\n };\n \n use crate::{\n-    assist_context::AssistBuilder, utils::insert_use_statement, AssistContext, AssistId,\n-    AssistKind, Assists,\n+    assist_context::AssistBuilder,\n+    utils::{insert_use, MergeBehaviour},\n+    AssistContext, AssistId, AssistKind, Assists,\n };\n+use ast::make;\n+use insert_use::ImportScope;\n \n // Assist: extract_struct_from_enum_variant\n //\n@@ -94,6 +97,7 @@ fn existing_struct_def(db: &RootDatabase, variant_name: &str, variant: &EnumVari\n         .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n+#[allow(dead_code)]\n fn insert_import(\n     ctx: &AssistContext,\n     builder: &mut AssistBuilder,\n@@ -107,12 +111,16 @@ fn insert_import(\n     if let Some(mut mod_path) = mod_path {\n         mod_path.segments.pop();\n         mod_path.segments.push(variant_hir_name.clone());\n-        insert_use_statement(\n-            path.syntax(),\n-            &mod_path.to_string(),\n-            ctx,\n-            builder.text_edit_builder(),\n+        let scope = ImportScope::find_insert_use_container(path.syntax(), ctx)?;\n+        let syntax = scope.as_syntax_node();\n+\n+        let new_syntax = insert_use(\n+            &scope,\n+            make::path_from_text(&mod_path.to_string()),\n+            Some(MergeBehaviour::Full),\n         );\n+        // FIXME: this will currently panic as multiple imports will have overlapping text ranges\n+        builder.replace(syntax.text_range(), new_syntax.to_string())\n     }\n     Some(())\n }\n@@ -167,9 +175,9 @@ fn update_reference(\n     builder: &mut AssistBuilder,\n     reference: Reference,\n     source_file: &SourceFile,\n-    enum_module_def: &ModuleDef,\n-    variant_hir_name: &Name,\n-    visited_modules_set: &mut FxHashSet<Module>,\n+    _enum_module_def: &ModuleDef,\n+    _variant_hir_name: &Name,\n+    _visited_modules_set: &mut FxHashSet<Module>,\n ) -> Option<()> {\n     let path_expr: ast::PathExpr = find_node_at_offset::<ast::PathExpr>(\n         source_file.syntax(),\n@@ -178,20 +186,22 @@ fn update_reference(\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let list = call.arg_list()?;\n     let segment = path_expr.path()?.segment()?;\n-    let module = ctx.sema.scope(&path_expr.syntax()).module()?;\n+    let _module = ctx.sema.scope(&path_expr.syntax()).module()?;\n     let list_range = list.syntax().text_range();\n     let inside_list_range = TextRange::new(\n         list_range.start().checked_add(TextSize::from(1))?,\n         list_range.end().checked_sub(TextSize::from(1))?,\n     );\n     builder.edit_file(reference.file_range.file_id);\n+    /* FIXME: this most likely requires AST-based editing, see `insert_import`\n     if !visited_modules_set.contains(&module) {\n         if insert_import(ctx, builder, &path_expr, &module, enum_module_def, variant_hir_name)\n             .is_some()\n         {\n             visited_modules_set.insert(module);\n         }\n     }\n+    */\n     builder.replace(inside_list_range, format!(\"{}{}\", segment, list));\n     Some(())\n }\n@@ -250,6 +260,7 @@ pub enum A { One(One) }\"#,\n     }\n \n     #[test]\n+    #[ignore] // FIXME: this currently panics if `insert_import` is used\n     fn test_extract_struct_with_complex_imports() {\n         check_assist(\n             extract_struct_from_enum_variant,"}, {"sha": "85c70d16b627fea1d0ff16dbf59e063a7d4d9741", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "patch": "@@ -2,9 +2,10 @@ use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode, TextRang\n use test_utils::mark;\n \n use crate::{\n-    utils::{find_insert_use_container, insert_use_statement},\n+    utils::{insert_use, ImportScope, MergeBehaviour},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n+use ast::make;\n \n // Assist: replace_qualified_name_with_use\n //\n@@ -32,7 +33,7 @@ pub(crate) fn replace_qualified_name_with_use(\n         mark::hit!(dont_import_trivial_paths);\n         return None;\n     }\n-    let path_to_import = path.to_string().clone();\n+    let path_to_import = path.to_string();\n     let path_to_import = match path.segment()?.generic_arg_list() {\n         Some(generic_args) => {\n             let generic_args_start =\n@@ -43,28 +44,26 @@ pub(crate) fn replace_qualified_name_with_use(\n     };\n \n     let target = path.syntax().text_range();\n+    let scope = ImportScope::find_insert_use_container(path.syntax(), ctx)?;\n+    let syntax = scope.as_syntax_node();\n     acc.add(\n         AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n         \"Replace qualified path with use\",\n         target,\n         |builder| {\n-            let container = match find_insert_use_container(path.syntax(), ctx) {\n-                Some(c) => c,\n-                None => return,\n-            };\n-            insert_use_statement(\n-                path.syntax(),\n-                &path_to_import.to_string(),\n-                ctx,\n-                builder.text_edit_builder(),\n-            );\n-\n             // Now that we've brought the name into scope, re-qualify all paths that could be\n             // affected (that is, all paths inside the node we added the `use` to).\n             let mut rewriter = SyntaxRewriter::default();\n-            let syntax = container.either(|l| l.syntax().clone(), |r| r.syntax().clone());\n-            shorten_paths(&mut rewriter, syntax, path);\n-            builder.rewrite(rewriter);\n+            shorten_paths(&mut rewriter, syntax.clone(), path);\n+            let rewritten_syntax = rewriter.rewrite(&syntax);\n+            if let Some(ref import_scope) = ImportScope::from(rewritten_syntax) {\n+                let new_syntax = insert_use(\n+                    import_scope,\n+                    make::path_from_text(path_to_import),\n+                    Some(MergeBehaviour::Full),\n+                );\n+                builder.replace(syntax.text_range(), new_syntax.to_string())\n+            }\n         },\n     )\n }\n@@ -220,9 +219,10 @@ impl std::fmt::Debug<|> for Foo {\n }\n     \",\n             r\"\n-use stdx;\n use std::fmt::Debug;\n \n+use stdx;\n+\n impl Debug for Foo {\n }\n     \",\n@@ -274,7 +274,7 @@ impl std::io<|> for Foo {\n }\n     \",\n             r\"\n-use std::{io, fmt};\n+use std::{fmt, io};\n \n impl io for Foo {\n }\n@@ -293,7 +293,7 @@ impl std::fmt::Debug<|> for Foo {\n }\n     \",\n             r\"\n-use std::fmt::{self, Debug, };\n+use std::fmt::{self, Debug};\n \n impl Debug for Foo {\n }\n@@ -312,7 +312,7 @@ impl std::fmt<|> for Foo {\n }\n     \",\n             r\"\n-use std::fmt::{self, Debug};\n+use std::fmt::{Debug, self};\n \n impl fmt for Foo {\n }\n@@ -330,8 +330,9 @@ use std::fmt::{Debug, nested::{Display}};\n impl std::fmt::nested<|> for Foo {\n }\n \",\n+            // FIXME(veykril): should be nested::{self, Display} here\n             r\"\n-use std::fmt::{Debug, nested::{Display, self}};\n+use std::fmt::{Debug, nested::{Display}, nested};\n \n impl nested for Foo {\n }\n@@ -349,8 +350,9 @@ use std::fmt::{Debug, nested::{self, Display}};\n impl std::fmt::nested<|> for Foo {\n }\n \",\n+            // FIXME(veykril): nested is duplicated now\n             r\"\n-use std::fmt::{Debug, nested::{self, Display}};\n+use std::fmt::{Debug, nested::{self, Display}, nested};\n \n impl nested for Foo {\n }\n@@ -369,7 +371,7 @@ impl std::fmt::nested::Debug<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{Debug, nested::{Display, Debug}};\n+use std::fmt::{Debug, nested::{Display}, nested::Debug};\n \n impl Debug for Foo {\n }\n@@ -388,7 +390,7 @@ impl std::fmt::nested::Display<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{nested::Display, Debug};\n+use std::fmt::{Debug, nested::Display};\n \n impl Display for Foo {\n }\n@@ -407,7 +409,7 @@ impl std::fmt::Display<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{Display, nested::Debug};\n+use std::fmt::{nested::Debug, Display};\n \n impl Display for Foo {\n }\n@@ -427,11 +429,12 @@ use crate::{\n \n fn foo() { crate::ty::lower<|>::trait_env() }\n \",\n+            // FIXME(veykril): formatting broke here\n             r\"\n use crate::{\n-    ty::{Substs, Ty, lower},\n+    ty::{Substs, Ty},\n     AssocItem,\n-};\n+ty::lower};\n \n fn foo() { lower::trait_env() }\n \",\n@@ -451,6 +454,8 @@ impl foo::Debug<|> for Foo {\n             r\"\n use std::fmt as foo;\n \n+use foo::Debug;\n+\n impl Debug for Foo {\n }\n \",\n@@ -515,6 +520,7 @@ fn main() {\n     \",\n             r\"\n #![allow(dead_code)]\n+\n use std::fmt::Debug;\n \n fn main() {\n@@ -627,7 +633,7 @@ fn main() {\n }\n     \",\n             r\"\n-use std::fmt::{self, Display};\n+use std::fmt::{Display, self};\n \n fn main() {\n     fmt;\n@@ -647,9 +653,8 @@ impl std::io<|> for Foo {\n }\n     \",\n             r\"\n-use std::io;\n-\n pub use std::fmt;\n+use std::io;\n \n impl io for Foo {\n }\n@@ -668,9 +673,8 @@ impl std::io<|> for Foo {\n }\n     \",\n             r\"\n-use std::io;\n-\n pub(crate) use std::fmt;\n+use std::io;\n \n impl io for Foo {\n }"}, {"sha": "7559ddd6381177c963dc04caf436201a47b09584", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "patch": "@@ -16,7 +16,7 @@ use syntax::{\n \n use crate::assist_config::SnippetCap;\n \n-pub(crate) use insert_use::{find_insert_use_container, insert_use_statement};\n+pub(crate) use insert_use::{insert_use, ImportScope, MergeBehaviour};\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block)"}, {"sha": "8a4c8520d73336acffc5bb3c71ada89ddd42590e", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 661, "deletions": 483, "changes": 1144, "blob_url": "https://github.com/rust-lang/rust/blob/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "patch": "@@ -1,546 +1,724 @@\n //! Handle syntactic aspects of inserting a new `use`.\n-// FIXME: rewrite according to the plan, outlined in\n-// https://github.com/rust-analyzer/rust-analyzer/issues/3301#issuecomment-592931553\n+use std::iter::{self, successors};\n \n-use std::iter::successors;\n-\n-use either::Either;\n+use algo::skip_trivia_token;\n+use ast::{\n+    edit::{AstNodeEdit, IndentLevel},\n+    PathSegmentKind, VisibilityOwner,\n+};\n use syntax::{\n-    ast::{self, NameOwner, VisibilityOwner},\n-    AstNode, AstToken, Direction, SmolStr,\n-    SyntaxKind::{PATH, PATH_SEGMENT},\n-    SyntaxNode, SyntaxToken, T,\n+    algo,\n+    ast::{self, make, AstNode},\n+    Direction, InsertPosition, SyntaxElement, SyntaxNode, T,\n };\n-use text_edit::TextEditBuilder;\n-\n-use crate::assist_context::AssistContext;\n-\n-/// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n-pub(crate) fn find_insert_use_container(\n-    position: &SyntaxNode,\n-    ctx: &AssistContext,\n-) -> Option<Either<ast::ItemList, ast::SourceFile>> {\n-    ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n-        if let Some(module) = ast::Module::cast(n.clone()) {\n-            return module.item_list().map(|it| Either::Left(it));\n-        }\n-        Some(Either::Right(ast::SourceFile::cast(n)?))\n-    })\n-}\n+use test_utils::mark;\n \n-/// Creates and inserts a use statement for the given path to import.\n-/// The use statement is inserted in the scope most appropriate to the\n-/// the cursor position given, additionally merged with the existing use imports.\n-pub(crate) fn insert_use_statement(\n-    // Ideally the position of the cursor, used to\n-    position: &SyntaxNode,\n-    path_to_import: &str,\n-    ctx: &AssistContext,\n-    builder: &mut TextEditBuilder,\n-) {\n-    let target = path_to_import.split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = find_insert_use_container(position, ctx);\n-\n-    if let Some(container) = container {\n-        let syntax = container.either(|l| l.syntax().clone(), |r| r.syntax().clone());\n-        let action = best_action_for_target(syntax, position.clone(), &target);\n-        make_assist(&action, &target, builder);\n-    }\n+#[derive(Debug)]\n+pub enum ImportScope {\n+    File(ast::SourceFile),\n+    Module(ast::ItemList),\n }\n \n-fn collect_path_segments_raw(\n-    segments: &mut Vec<ast::PathSegment>,\n-    mut path: ast::Path,\n-) -> Option<usize> {\n-    let oldlen = segments.len();\n-    loop {\n-        let mut children = path.syntax().children_with_tokens();\n-        let (first, second, third) = (\n-            children.next().map(|n| (n.clone(), n.kind())),\n-            children.next().map(|n| (n.clone(), n.kind())),\n-            children.next().map(|n| (n.clone(), n.kind())),\n-        );\n-        match (first, second, third) {\n-            (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n-                path = ast::Path::cast(subpath.as_node()?.clone())?;\n-                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n-            }\n-            (Some((segment, PATH_SEGMENT)), _, _) => {\n-                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n-                break;\n-            }\n-            (_, _, _) => return None,\n+impl ImportScope {\n+    pub fn from(syntax: SyntaxNode) -> Option<Self> {\n+        if let Some(module) = ast::Module::cast(syntax.clone()) {\n+            module.item_list().map(ImportScope::Module)\n+        } else if let this @ Some(_) = ast::SourceFile::cast(syntax.clone()) {\n+            this.map(ImportScope::File)\n+        } else {\n+            ast::ItemList::cast(syntax).map(ImportScope::Module)\n         }\n     }\n-    // We need to reverse only the new added segments\n-    let only_new_segments = segments.split_at_mut(oldlen).1;\n-    only_new_segments.reverse();\n-    Some(segments.len() - oldlen)\n-}\n \n-fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n-    let mut iter = segments.iter();\n-    if let Some(s) = iter.next() {\n-        buf.push_str(s);\n-    }\n-    for s in iter {\n-        buf.push_str(\"::\");\n-        buf.push_str(s);\n+    /// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n+    pub(crate) fn find_insert_use_container(\n+        position: &SyntaxNode,\n+        ctx: &crate::assist_context::AssistContext,\n+    ) -> Option<Self> {\n+        ctx.sema.ancestors_with_macros(position.clone()).find_map(Self::from)\n     }\n-}\n-\n-/// Returns the number of common segments.\n-fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n-    left.iter().zip(right).take_while(|(l, r)| compare_path_segment(l, r)).count()\n-}\n \n-fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n-    if let Some(kb) = b.kind() {\n-        match kb {\n-            ast::PathSegmentKind::Name(nameref_b) => a == nameref_b.text(),\n-            ast::PathSegmentKind::SelfKw => a == \"self\",\n-            ast::PathSegmentKind::SuperKw => a == \"super\",\n-            ast::PathSegmentKind::CrateKw => a == \"crate\",\n-            ast::PathSegmentKind::Type { .. } => false, // not allowed in imports\n+    pub(crate) fn as_syntax_node(&self) -> &SyntaxNode {\n+        match self {\n+            ImportScope::File(file) => file.syntax(),\n+            ImportScope::Module(item_list) => item_list.syntax(),\n         }\n-    } else {\n-        false\n     }\n-}\n-\n-fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n-    a == b.text()\n-}\n-\n-#[derive(Clone, Debug)]\n-enum ImportAction {\n-    Nothing,\n-    // Add a brand new use statement.\n-    AddNewUse {\n-        anchor: Option<SyntaxNode>, // anchor node\n-        add_after_anchor: bool,\n-    },\n-\n-    // To split an existing use statement creating a nested import.\n-    AddNestedImport {\n-        // how may segments matched with the target path\n-        common_segments: usize,\n-        path_to_split: ast::Path,\n-        // the first segment of path_to_split we want to add into the new nested list\n-        first_segment_to_split: Option<ast::PathSegment>,\n-        // Wether to add 'self' in addition to the target path\n-        add_self: bool,\n-    },\n-    // To add the target path to an existing nested import tree list.\n-    AddInTreeList {\n-        common_segments: usize,\n-        // The UseTreeList where to add the target path\n-        tree_list: ast::UseTreeList,\n-        add_self: bool,\n-    },\n-}\n \n-impl ImportAction {\n-    fn add_new_use(anchor: Option<SyntaxNode>, add_after_anchor: bool) -> Self {\n-        ImportAction::AddNewUse { anchor, add_after_anchor }\n-    }\n-\n-    fn add_nested_import(\n-        common_segments: usize,\n-        path_to_split: ast::Path,\n-        first_segment_to_split: Option<ast::PathSegment>,\n-        add_self: bool,\n-    ) -> Self {\n-        ImportAction::AddNestedImport {\n-            common_segments,\n-            path_to_split,\n-            first_segment_to_split,\n-            add_self,\n+    fn indent_level(&self) -> IndentLevel {\n+        match self {\n+            ImportScope::File(file) => file.indent_level(),\n+            ImportScope::Module(item_list) => item_list.indent_level() + 1,\n         }\n     }\n \n-    fn add_in_tree_list(\n-        common_segments: usize,\n-        tree_list: ast::UseTreeList,\n-        add_self: bool,\n-    ) -> Self {\n-        ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n-    }\n-\n-    fn better(left: ImportAction, right: ImportAction) -> ImportAction {\n-        if left.is_better(&right) {\n-            left\n-        } else {\n-            right\n+    fn first_insert_pos(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+        match self {\n+            ImportScope::File(_) => (InsertPosition::First, AddBlankLine::AfterTwice),\n+            // don't insert the imports before the item list's opening curly brace\n+            ImportScope::Module(item_list) => item_list\n+                .l_curly_token()\n+                .map(|b| (InsertPosition::After(b.into()), AddBlankLine::Around))\n+                .unwrap_or((InsertPosition::First, AddBlankLine::AfterTwice)),\n         }\n     }\n \n-    fn is_better(&self, other: &ImportAction) -> bool {\n-        match (self, other) {\n-            (ImportAction::Nothing, _) => true,\n-            (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n-            (\n-                ImportAction::AddNestedImport { common_segments: n, .. },\n-                ImportAction::AddInTreeList { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddInTreeList { common_segments: n, .. },\n-                ImportAction::AddNestedImport { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddInTreeList { common_segments: n, .. },\n-                ImportAction::AddInTreeList { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddNestedImport { common_segments: n, .. },\n-                ImportAction::AddNestedImport { common_segments: m, .. },\n-            ) => n > m,\n-            (ImportAction::AddInTreeList { .. }, _) => true,\n-            (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n-            (ImportAction::AddNestedImport { .. }, _) => true,\n-            (ImportAction::AddNewUse { .. }, _) => false,\n+    fn insert_pos_after_inner_attribute(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+        // check if the scope has inner attributes, we dont want to insert in front of them\n+        match self\n+            .as_syntax_node()\n+            .children()\n+            // no flat_map here cause we want to short circuit the iterator\n+            .map(ast::Attr::cast)\n+            .take_while(|attr| {\n+                attr.as_ref().map(|attr| attr.kind() == ast::AttrKind::Inner).unwrap_or(false)\n+            })\n+            .last()\n+            .flatten()\n+        {\n+            Some(attr) => {\n+                (InsertPosition::After(attr.syntax().clone().into()), AddBlankLine::BeforeTwice)\n+            }\n+            None => self.first_insert_pos(),\n         }\n     }\n }\n \n-// Find out the best ImportAction to import target path against current_use_tree.\n-// If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n-fn walk_use_tree_for_best_action(\n-    current_path_segments: &mut Vec<ast::PathSegment>, // buffer containing path segments\n-    current_parent_use_tree_list: Option<ast::UseTreeList>, // will be Some value if we are in a nested import\n-    current_use_tree: ast::UseTree, // the use tree we are currently examinating\n-    target: &[SmolStr],             // the path we want to import\n-) -> ImportAction {\n-    // We save the number of segments in the buffer so we can restore the correct segments\n-    // before returning. Recursive call will add segments so we need to delete them.\n-    let prev_len = current_path_segments.len();\n-\n-    let tree_list = current_use_tree.use_tree_list();\n-    let alias = current_use_tree.rename();\n-\n-    let path = match current_use_tree.path() {\n-        Some(path) => path,\n-        None => {\n-            // If the use item don't have a path, it means it's broken (syntax error)\n-            return ImportAction::add_new_use(\n-                current_use_tree\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(ast::Use::cast)\n-                    .map(|it| it.syntax().clone()),\n-                true,\n-            );\n-        }\n-    };\n-\n-    // This can happen only if current_use_tree is a direct child of a UseItem\n-    if let Some(name) = alias.and_then(|it| it.name()) {\n-        if compare_path_segment_with_name(&target[0], &name) {\n-            return ImportAction::Nothing;\n+/// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n+pub(crate) fn insert_use(\n+    scope: &ImportScope,\n+    path: ast::Path,\n+    merge: Option<MergeBehaviour>,\n+) -> SyntaxNode {\n+    let use_item = make::use_(make::use_tree(path.clone(), None, None, false));\n+    // merge into existing imports if possible\n+    if let Some(mb) = merge {\n+        for existing_use in scope.as_syntax_node().children().filter_map(ast::Use::cast) {\n+            if let Some(merged) = try_merge_imports(&existing_use, &use_item, mb) {\n+                let to_delete: SyntaxElement = existing_use.syntax().clone().into();\n+                let to_delete = to_delete.clone()..=to_delete;\n+                let to_insert = iter::once(merged.syntax().clone().into());\n+                return algo::replace_children(scope.as_syntax_node(), to_delete, to_insert);\n+            }\n         }\n     }\n \n-    collect_path_segments_raw(current_path_segments, path.clone());\n-\n-    // We compare only the new segments added in the line just above.\n-    // The first prev_len segments were already compared in 'parent' recursive calls.\n-    let left = target.split_at(prev_len).1;\n-    let right = current_path_segments.split_at(prev_len).1;\n-    let common = compare_path_segments(left, &right);\n-    let mut action = match common {\n-        0 => ImportAction::add_new_use(\n-            // e.g: target is std::fmt and we can have\n-            // use foo::bar\n-            // We add a brand new use statement\n-            current_use_tree\n-                .syntax()\n-                .ancestors()\n-                .find_map(ast::Use::cast)\n-                .map(|it| it.syntax().clone()),\n-            true,\n-        ),\n-        common if common == left.len() && left.len() == right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // 1- use std::fmt;\n-            // 2- use std::fmt::{ ... }\n-            if let Some(list) = tree_list {\n-                // In case 2 we need to add self to the nested list\n-                // unless it's already there\n-                let has_self = list.use_trees().map(|it| it.path()).any(|p| {\n-                    p.and_then(|it| it.segment())\n-                        .and_then(|it| it.kind())\n-                        .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n-                        .is_some()\n-                });\n-\n-                if has_self {\n-                    ImportAction::Nothing\n-                } else {\n-                    ImportAction::add_in_tree_list(current_path_segments.len(), list, true)\n-                }\n-            } else {\n-                // Case 1\n-                ImportAction::Nothing\n+    // either we weren't allowed to merge or there is no import that fits the merge conditions\n+    // so look for the place we have to insert to\n+    let (insert_position, add_blank) = find_insert_position(scope, path);\n+\n+    let to_insert: Vec<SyntaxElement> = {\n+        let mut buf = Vec::new();\n+\n+        match add_blank {\n+            AddBlankLine::Before | AddBlankLine::Around => {\n+                buf.push(make::tokens::single_newline().into())\n             }\n+            AddBlankLine::BeforeTwice => buf.push(make::tokens::blank_line().into()),\n+            _ => (),\n         }\n-        common if common != left.len() && left.len() == right.len() => {\n-            // e.g: target is std::fmt and we have\n-            // use std::io;\n-            // We need to split.\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                false,\n-            )\n+\n+        if let ident_level @ 1..=usize::MAX = scope.indent_level().0 as usize {\n+            // FIXME: this alone doesnt properly re-align all cases\n+            buf.push(make::tokens::whitespace(&\" \".repeat(4 * ident_level)).into());\n         }\n-        common if common == right.len() && left.len() > right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // 1- use std;\n-            // 2- use std::{ ... };\n-\n-            // fallback action\n-            let mut better_action = ImportAction::add_new_use(\n-                current_use_tree\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(ast::Use::cast)\n-                    .map(|it| it.syntax().clone()),\n-                true,\n-            );\n-            if let Some(list) = tree_list {\n-                // Case 2, check recursively if the path is already imported in the nested list\n-                for u in list.use_trees() {\n-                    let child_action = walk_use_tree_for_best_action(\n-                        current_path_segments,\n-                        Some(list.clone()),\n-                        u,\n-                        target,\n-                    );\n-                    if child_action.is_better(&better_action) {\n-                        better_action = child_action;\n-                        if let ImportAction::Nothing = better_action {\n-                            return better_action;\n-                        }\n-                    }\n-                }\n-            } else {\n-                // Case 1, split adding self\n-                better_action = ImportAction::add_nested_import(prev_len + common, path, None, true)\n+        buf.push(use_item.syntax().clone().into());\n+\n+        match add_blank {\n+            AddBlankLine::After | AddBlankLine::Around => {\n+                buf.push(make::tokens::single_newline().into())\n             }\n-            better_action\n-        }\n-        common if common == left.len() && left.len() < right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // use std::fmt::Debug;\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                true,\n-            )\n-        }\n-        common if common < left.len() && common < right.len() => {\n-            // e.g: target is std::fmt::nested::Debug\n-            // use std::fmt::Display\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                false,\n-            )\n+            AddBlankLine::AfterTwice => buf.push(make::tokens::blank_line().into()),\n+            _ => (),\n         }\n-        _ => unreachable!(),\n-    };\n \n-    // If we are inside a UseTreeList adding a use statement become adding to the existing\n-    // tree list.\n-    action = match (current_parent_use_tree_list, action.clone()) {\n-        (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n-            ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n-        }\n-        (_, _) => action,\n+        buf\n     };\n \n-    // We remove the segments added\n-    current_path_segments.truncate(prev_len);\n-    action\n+    algo::insert_children(scope.as_syntax_node(), insert_position, to_insert)\n }\n \n-fn best_action_for_target(\n-    container: SyntaxNode,\n-    anchor: SyntaxNode,\n-    target: &[SmolStr],\n-) -> ImportAction {\n-    let mut storage = Vec::with_capacity(16); // this should be the only allocation\n-    let best_action = container\n-        .children()\n-        .filter_map(ast::Use::cast)\n-        .filter(|u| u.visibility().is_none())\n-        .filter_map(|it| it.use_tree())\n-        .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n-        .fold(None, |best, a| match best {\n-            Some(best) => Some(ImportAction::better(best, a)),\n-            None => Some(a),\n-        });\n+fn try_merge_imports(\n+    old: &ast::Use,\n+    new: &ast::Use,\n+    merge_behaviour: MergeBehaviour,\n+) -> Option<ast::Use> {\n+    // don't merge into re-exports\n+    if old.visibility().and_then(|vis| vis.pub_token()).is_some() {\n+        return None;\n+    }\n+    let old_tree = old.use_tree()?;\n+    let new_tree = new.use_tree()?;\n+    let merged = try_merge_trees(&old_tree, &new_tree, merge_behaviour)?;\n+    Some(old.with_use_tree(merged))\n+}\n \n-    match best_action {\n-        Some(action) => action,\n-        None => {\n-            // We have no action and no UseItem was found in container so we find\n-            // another item and we use it as anchor.\n-            // If there are no items above, we choose the target path itself as anchor.\n-            // todo: we should include even whitespace blocks as anchor candidates\n-            let anchor = container.children().next().or_else(|| Some(anchor));\n+/// Simple function that checks if a UseTreeList is deeper than one level\n+fn use_tree_list_is_nested(tl: &ast::UseTreeList) -> bool {\n+    tl.use_trees().any(|use_tree| {\n+        use_tree.use_tree_list().is_some() || use_tree.path().and_then(|p| p.qualifier()).is_some()\n+    })\n+}\n \n-            let add_after_anchor = anchor\n-                .clone()\n-                .and_then(ast::Attr::cast)\n-                .map(|attr| attr.kind() == ast::AttrKind::Inner)\n-                .unwrap_or(false);\n-            ImportAction::add_new_use(anchor, add_after_anchor)\n-        }\n+// FIXME: currently this merely prepends the new tree into old, ideally it would insert the items in a sorted fashion\n+pub fn try_merge_trees(\n+    old: &ast::UseTree,\n+    new: &ast::UseTree,\n+    merge_behaviour: MergeBehaviour,\n+) -> Option<ast::UseTree> {\n+    let lhs_path = old.path()?;\n+    let rhs_path = new.path()?;\n+\n+    let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n+    let lhs = old.split_prefix(&lhs_prefix);\n+    let rhs = new.split_prefix(&rhs_prefix);\n+    let lhs_tl = lhs.use_tree_list()?;\n+    let rhs_tl = rhs.use_tree_list()?;\n+\n+    // if we are only allowed to merge the last level check if the split off paths are only one level deep\n+    if merge_behaviour == MergeBehaviour::Last\n+        && (use_tree_list_is_nested(&lhs_tl) || use_tree_list_is_nested(&rhs_tl))\n+    {\n+        mark::hit!(test_last_merge_too_long);\n+        return None;\n     }\n-}\n \n-fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBuilder) {\n-    match action {\n-        ImportAction::AddNewUse { anchor, add_after_anchor } => {\n-            make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n-        }\n-        ImportAction::AddInTreeList { common_segments, tree_list, add_self } => {\n-            // We know that the fist n segments already exists in the use statement we want\n-            // to modify, so we want to add only the last target.len() - n segments.\n-            let segments_to_add = target.split_at(*common_segments).1;\n-            make_assist_add_in_tree_list(tree_list, segments_to_add, *add_self, edit)\n-        }\n-        ImportAction::AddNestedImport {\n-            common_segments,\n-            path_to_split,\n-            first_segment_to_split,\n-            add_self,\n-        } => {\n-            let segments_to_add = target.split_at(*common_segments).1;\n-            make_assist_add_nested_import(\n-                path_to_split,\n-                first_segment_to_split,\n-                segments_to_add,\n-                *add_self,\n-                edit,\n-            )\n-        }\n-        _ => {}\n+    let should_insert_comma = lhs_tl\n+        .r_curly_token()\n+        .and_then(|it| skip_trivia_token(it.prev_token()?, Direction::Prev))\n+        .map(|it| it.kind())\n+        != Some(T![,]);\n+    let mut to_insert: Vec<SyntaxElement> = Vec::new();\n+    if should_insert_comma {\n+        to_insert.push(make::token(T![,]).into());\n+        to_insert.push(make::tokens::single_space().into());\n     }\n+    to_insert.extend(\n+        rhs_tl.syntax().children_with_tokens().filter(|it| !matches!(it.kind(), T!['{'] | T!['}'])),\n+    );\n+    let pos = InsertPosition::Before(lhs_tl.r_curly_token()?.into());\n+    let use_tree_list = lhs_tl.insert_children(pos, to_insert);\n+    Some(lhs.with_use_tree_list(use_tree_list))\n }\n \n-fn make_assist_add_new_use(\n-    anchor: &Option<SyntaxNode>,\n-    after: bool,\n-    target: &[SmolStr],\n-    edit: &mut TextEditBuilder,\n-) {\n-    if let Some(anchor) = anchor {\n-        let indent = leading_indent(anchor);\n-        let mut buf = String::new();\n-        if after {\n-            buf.push_str(\"\\n\");\n-            if let Some(spaces) = &indent {\n-                buf.push_str(spaces);\n-            }\n+/// Traverses both paths until they differ, returning the common prefix of both.\n+fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Path)> {\n+    let mut res = None;\n+    let mut lhs_curr = first_path(&lhs);\n+    let mut rhs_curr = first_path(&rhs);\n+    loop {\n+        match (lhs_curr.segment(), rhs_curr.segment()) {\n+            (Some(lhs), Some(rhs)) if lhs.syntax().text() == rhs.syntax().text() => (),\n+            _ => break,\n         }\n-        buf.push_str(\"use \");\n-        fmt_segments_raw(target, &mut buf);\n-        buf.push_str(\";\");\n-        if !after {\n-            buf.push_str(\"\\n\\n\");\n-            if let Some(spaces) = &indent {\n-                buf.push_str(&spaces);\n+        res = Some((lhs_curr.clone(), rhs_curr.clone()));\n+\n+        match lhs_curr.parent_path().zip(rhs_curr.parent_path()) {\n+            Some((lhs, rhs)) => {\n+                lhs_curr = lhs;\n+                rhs_curr = rhs;\n             }\n+            _ => break,\n         }\n-        let position = if after { anchor.text_range().end() } else { anchor.text_range().start() };\n-        edit.insert(position, buf);\n     }\n+\n+    res\n }\n \n-fn make_assist_add_in_tree_list(\n-    tree_list: &ast::UseTreeList,\n-    target: &[SmolStr],\n-    add_self: bool,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let last = tree_list.use_trees().last();\n-    if let Some(last) = last {\n-        let mut buf = String::new();\n-        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == T![,]);\n-        let offset = if let Some(comma) = comma {\n-            comma.text_range().end()\n-        } else {\n-            buf.push_str(\",\");\n-            last.syntax().text_range().end()\n-        };\n-        if add_self {\n-            buf.push_str(\" self\")\n-        } else {\n-            buf.push_str(\" \");\n-        }\n-        fmt_segments_raw(target, &mut buf);\n-        edit.insert(offset, buf);\n-    } else {\n-    }\n+/// What type of merges are allowed.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum MergeBehaviour {\n+    /// Merge everything together creating deeply nested imports.\n+    Full,\n+    /// Only merge the last import level, doesn't allow import nesting.\n+    Last,\n }\n \n-fn make_assist_add_nested_import(\n-    path: &ast::Path,\n-    first_segment_to_split: &Option<ast::PathSegment>,\n-    target: &[SmolStr],\n-    add_self: bool,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n-    if let Some(use_tree) = use_tree {\n-        let (start, add_colon_colon) = if let Some(first_segment_to_split) = first_segment_to_split\n-        {\n-            (first_segment_to_split.syntax().text_range().start(), false)\n-        } else {\n-            (use_tree.syntax().text_range().end(), true)\n+#[derive(Eq, PartialEq, PartialOrd, Ord)]\n+enum ImportGroup {\n+    // the order here defines the order of new group inserts\n+    Std,\n+    ExternCrate,\n+    ThisCrate,\n+    ThisModule,\n+    SuperModule,\n+}\n+\n+impl ImportGroup {\n+    fn new(path: &ast::Path) -> ImportGroup {\n+        let default = ImportGroup::ExternCrate;\n+\n+        let first_segment = match first_segment(path) {\n+            Some(it) => it,\n+            None => return default,\n         };\n-        let end = use_tree.syntax().text_range().end();\n \n-        let mut buf = String::new();\n-        if add_colon_colon {\n-            buf.push_str(\"::\");\n-        }\n-        buf.push_str(\"{\");\n-        if add_self {\n-            buf.push_str(\"self, \");\n-        }\n-        fmt_segments_raw(target, &mut buf);\n-        if !target.is_empty() {\n-            buf.push_str(\", \");\n+        let kind = first_segment.kind().unwrap_or(PathSegmentKind::SelfKw);\n+        match kind {\n+            PathSegmentKind::SelfKw => ImportGroup::ThisModule,\n+            PathSegmentKind::SuperKw => ImportGroup::SuperModule,\n+            PathSegmentKind::CrateKw => ImportGroup::ThisCrate,\n+            PathSegmentKind::Name(name) => match name.text().as_str() {\n+                \"std\" => ImportGroup::Std,\n+                \"core\" => ImportGroup::Std,\n+                // FIXME: can be ThisModule as well\n+                _ => ImportGroup::ExternCrate,\n+            },\n+            PathSegmentKind::Type { .. } => unreachable!(),\n         }\n-        edit.insert(start, buf);\n-        edit.insert(end, \"}\".to_string());\n     }\n }\n \n-/// If the node is on the beginning of the line, calculate indent.\n-fn leading_indent(node: &SyntaxNode) -> Option<SmolStr> {\n-    for token in prev_tokens(node.first_token()?) {\n-        if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n-            let ws_text = ws.text();\n-            if let Some(pos) = ws_text.rfind('\\n') {\n-                return Some(ws_text[pos + 1..].into());\n+fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n+    first_path(path).segment()\n+}\n+\n+fn first_path(path: &ast::Path) -> ast::Path {\n+    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n+}\n+\n+fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n+    path.syntax().children().flat_map(ast::PathSegment::cast)\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum AddBlankLine {\n+    Before,\n+    BeforeTwice,\n+    Around,\n+    After,\n+    AfterTwice,\n+}\n+\n+fn find_insert_position(\n+    scope: &ImportScope,\n+    insert_path: ast::Path,\n+) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+    let group = ImportGroup::new(&insert_path);\n+    let path_node_iter = scope\n+        .as_syntax_node()\n+        .children()\n+        .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n+        .flat_map(|(use_, node)| use_.use_tree().and_then(|tree| tree.path()).zip(Some(node)));\n+    // Iterator that discards anything thats not in the required grouping\n+    // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n+    let group_iter = path_node_iter\n+        .clone()\n+        .skip_while(|(path, _)| ImportGroup::new(path) != group)\n+        .take_while(|(path, _)| ImportGroup::new(path) == group);\n+\n+    let segments = segment_iter(&insert_path);\n+    // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n+    let mut last = None;\n+    // find the element that would come directly after our new import\n+    let post_insert =\n+        group_iter.inspect(|(_, node)| last = Some(node.clone())).find(|(path, _)| {\n+            let check_segments = segment_iter(&path);\n+            segments\n+                .clone()\n+                .zip(check_segments)\n+                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n+                .all(|(l, r)| l.text() <= r.text())\n+        });\n+    match post_insert {\n+        // insert our import before that element\n+        Some((_, node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n+        // there is no element after our new import, so append it to the end of the group\n+        None => match last {\n+            Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n+            // the group we were looking for actually doesnt exist, so insert\n+            None => {\n+                // similar concept here to the `last` from above\n+                let mut last = None;\n+                // find the group that comes after where we want to insert\n+                let post_group = path_node_iter\n+                    .inspect(|(_, node)| last = Some(node.clone()))\n+                    .find(|(p, _)| ImportGroup::new(p) > group);\n+                match post_group {\n+                    Some((_, node)) => {\n+                        (InsertPosition::Before(node.into()), AddBlankLine::AfterTwice)\n+                    }\n+                    // there is no such group, so append after the last one\n+                    None => match last {\n+                        Some(node) => {\n+                            (InsertPosition::After(node.into()), AddBlankLine::BeforeTwice)\n+                        }\n+                        // there are no imports in this file at all\n+                        None => scope.insert_pos_after_inner_attribute(),\n+                    },\n+                }\n             }\n-        }\n-        if token.text().contains('\\n') {\n-            break;\n-        }\n+        },\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use test_utils::assert_eq_text;\n+\n+    #[test]\n+    fn insert_start() {\n+        check_none(\n+            \"std::bar::AA\",\n+            r\"\n+use std::bar::B;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"\n+use std::bar::AA;\n+use std::bar::B;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_middle() {\n+        check_none(\n+            \"std::bar::EE\",\n+            r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::EE;\n+use std::bar::F;\n+use std::bar::G;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_end() {\n+        check_none(\n+            \"std::bar::ZZ\",\n+            r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"\n+use std::bar::A;\n+use std::bar::D;\n+use std::bar::F;\n+use std::bar::G;\n+use std::bar::ZZ;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_middle_nested() {\n+        check_none(\n+            \"std::bar::EE\",\n+            r\"\n+use std::bar::A;\n+use std::bar::{D, Z}; // example of weird imports due to user\n+use std::bar::F;\n+use std::bar::G;\",\n+            r\"\n+use std::bar::A;\n+use std::bar::EE;\n+use std::bar::{D, Z}; // example of weird imports due to user\n+use std::bar::F;\n+use std::bar::G;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_middle_groups() {\n+        check_none(\n+            \"foo::bar::GG\",\n+            r\"\n+use std::bar::A;\n+use std::bar::D;\n+\n+use foo::bar::F;\n+use foo::bar::H;\",\n+            r\"\n+use std::bar::A;\n+use std::bar::D;\n+\n+use foo::bar::F;\n+use foo::bar::GG;\n+use foo::bar::H;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_first_matching_group() {\n+        check_none(\n+            \"foo::bar::GG\",\n+            r\"\n+use foo::bar::A;\n+use foo::bar::D;\n+\n+use std;\n+\n+use foo::bar::F;\n+use foo::bar::H;\",\n+            r\"\n+use foo::bar::A;\n+use foo::bar::D;\n+use foo::bar::GG;\n+\n+use std;\n+\n+use foo::bar::F;\n+use foo::bar::H;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_missing_group_std() {\n+        check_none(\n+            \"std::fmt\",\n+            r\"\n+use foo::bar::A;\n+use foo::bar::D;\",\n+            r\"\n+use std::fmt;\n+\n+use foo::bar::A;\n+use foo::bar::D;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_missing_group_self() {\n+        check_none(\n+            \"self::fmt\",\n+            r\"\n+use foo::bar::A;\n+use foo::bar::D;\",\n+            r\"\n+use foo::bar::A;\n+use foo::bar::D;\n+\n+use self::fmt;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_no_imports() {\n+        check_full(\n+            \"foo::bar\",\n+            \"fn main() {}\",\n+            r\"use foo::bar;\n+\n+fn main() {}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_empty_file() {\n+        // empty files will get two trailing newlines\n+        // this is due to the test case insert_no_imports above\n+        check_full(\n+            \"foo::bar\",\n+            \"\",\n+            r\"use foo::bar;\n+\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn insert_after_inner_attr() {\n+        check_full(\n+            \"foo::bar\",\n+            r\"#![allow(unused_imports)]\",\n+            r\"#![allow(unused_imports)]\n+\n+use foo::bar;\",\n+        )\n     }\n-    return None;\n-    fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n-        successors(token.prev_token(), |token| token.prev_token())\n+\n+    #[test]\n+    fn insert_after_inner_attr2() {\n+        check_full(\n+            \"foo::bar\",\n+            r\"#![allow(unused_imports)]\n+\n+fn main() {}\",\n+            r\"#![allow(unused_imports)]\n+\n+use foo::bar;\n+\n+fn main() {}\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups() {\n+        check_last(\"std::io\", r\"use std::fmt;\", r\"use std::{fmt, io};\")\n+    }\n+\n+    #[test]\n+    fn merge_groups_last() {\n+        check_last(\n+            \"std::io\",\n+            r\"use std::fmt::{Result, Display};\",\n+            r\"use std::fmt::{Result, Display};\n+use std::io;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_full() {\n+        check_full(\n+            \"std::io\",\n+            r\"use std::fmt::{Result, Display};\",\n+            r\"use std::{fmt::{Result, Display}, io};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_long_full() {\n+        check_full(\n+            \"std::foo::bar::Baz\",\n+            r\"use std::foo::bar::Qux;\",\n+            r\"use std::foo::bar::{Qux, Baz};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_long_last() {\n+        check_last(\n+            \"std::foo::bar::Baz\",\n+            r\"use std::foo::bar::Qux;\",\n+            r\"use std::foo::bar::{Qux, Baz};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_long_full_list() {\n+        check_full(\n+            \"std::foo::bar::Baz\",\n+            r\"use std::foo::bar::{Qux, Quux};\",\n+            r\"use std::foo::bar::{Qux, Quux, Baz};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_long_last_list() {\n+        check_last(\n+            \"std::foo::bar::Baz\",\n+            r\"use std::foo::bar::{Qux, Quux};\",\n+            r\"use std::foo::bar::{Qux, Quux, Baz};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_long_full_nested() {\n+        check_full(\n+            \"std::foo::bar::Baz\",\n+            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}, Baz};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_long_last_nested() {\n+        check_last(\n+            \"std::foo::bar::Baz\",\n+            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+            r\"use std::foo::bar::Baz;\n+use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_skip_pub() {\n+        check_full(\n+            \"std::io\",\n+            r\"pub use std::fmt::{Result, Display};\",\n+            r\"pub use std::fmt::{Result, Display};\n+use std::io;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_skip_pub_crate() {\n+        check_full(\n+            \"std::io\",\n+            r\"pub(crate) use std::fmt::{Result, Display};\",\n+            r\"pub(crate) use std::fmt::{Result, Display};\n+use std::io;\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore] // FIXME: Support this\n+    fn split_out_merge() {\n+        check_last(\n+            \"std::fmt::Result\",\n+            r\"use std::{fmt, io};\",\n+            r\"use std::{self, fmt::Result};\n+use std::io;\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_groups_self() {\n+        check_full(\"std::fmt::Debug\", r\"use std::fmt;\", r\"use std::fmt::{self, Debug};\")\n+    }\n+\n+    #[test]\n+    fn merge_self_glob() {\n+        check_full(\n+            \"token::TokenKind\",\n+            r\"use token::TokenKind::*;\",\n+            r\"use token::TokenKind::{self::*, self};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_last_too_long() {\n+        mark::check!(test_last_merge_too_long);\n+        check_last(\n+            \"foo::bar\",\n+            r\"use foo::bar::baz::Qux;\",\n+            r\"use foo::bar::baz::Qux;\n+use foo::bar;\",\n+        );\n+    }\n+\n+    fn check(\n+        path: &str,\n+        ra_fixture_before: &str,\n+        ra_fixture_after: &str,\n+        mb: Option<MergeBehaviour>,\n+    ) {\n+        let file = super::ImportScope::from(\n+            ast::SourceFile::parse(ra_fixture_before).tree().syntax().clone(),\n+        )\n+        .unwrap();\n+        let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n+            .tree()\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::Path::cast)\n+            .unwrap();\n+\n+        let result = insert_use(&file, path, mb).to_string();\n+        assert_eq_text!(&result, ra_fixture_after);\n+    }\n+\n+    fn check_full(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Full))\n+    }\n+\n+    fn check_last(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        check(path, ra_fixture_before, ra_fixture_after, Some(MergeBehaviour::Last))\n+    }\n+\n+    fn check_none(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        check(path, ra_fixture_before, ra_fixture_after, None)\n     }\n }"}, {"sha": "33f1ad7b34e1da6fe7bf892b3c05bc4e66f17d5e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dfa69a44ac5054b5c970fdd13ade4d50f4c097d/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=9dfa69a44ac5054b5c970fdd13ade4d50f4c097d", "patch": "@@ -339,7 +339,7 @@ pub mod tokens {\n     use crate::{ast, AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken};\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n-        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true)\\n;\"));\n+        Lazy::new(|| SourceFile::parse(\"const C: <()>::Item = (1 != 1, 2 == 2, !true)\\n;\\n\\n\"));\n \n     pub fn single_space() -> SyntaxToken {\n         SOURCE_FILE\n@@ -379,6 +379,16 @@ pub mod tokens {\n             .unwrap()\n     }\n \n+    pub fn blank_line() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\\n\")\n+            .unwrap()\n+    }\n+\n     pub struct WsBuilder(SourceFile);\n \n     impl WsBuilder {"}]}