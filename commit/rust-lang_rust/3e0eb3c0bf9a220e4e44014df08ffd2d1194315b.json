{"sha": "3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMGViM2MwYmY5YTIyMGU0ZTQ0MDE0ZGYwOGZmZDJkMTE5NDMxNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-02T12:16:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-02T12:16:17Z"}, "message": "auto merge of #11982 : eddyb/rust/generic-default-type-params, r=pcwalton\n\nFixes #11964 and closes #8998.", "tree": {"sha": "ed17a9c56bac4f0fa5cda4a977491fa8eba2d7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed17a9c56bac4f0fa5cda4a977491fa8eba2d7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "html_url": "https://github.com/rust-lang/rust/commit/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb663c3cc98b371af2077b44d936dc0ea139d9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb663c3cc98b371af2077b44d936dc0ea139d9c0", "html_url": "https://github.com/rust-lang/rust/commit/fb663c3cc98b371af2077b44d936dc0ea139d9c0"}, {"sha": "fdf985cd14d7f83181527c7d911b1b7b7d7b3d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf985cd14d7f83181527c7d911b1b7b7d7b3d65", "html_url": "https://github.com/rust-lang/rust/commit/fdf985cd14d7f83181527c7d911b1b7b7d7b3d65"}], "stats": {"total": 325, "additions": 245, "deletions": 80}, "files": [{"sha": "7176b512c719ff6bf0b7a03b56c4b8f669973e62", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 128, "deletions": 43, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -13,18 +13,27 @@\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n+use util::ppaux::Repr;\n \n use std::rc::Rc;\n+use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n // Just call `foo.subst(tcx, substs)` to perform a substitution across\n // `foo`.\n+// Or use `foo.subst_spanned(tcx, substs, Some(span))` when there is more\n+// information available (for better errors).\n \n pub trait Subst {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self;\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self {\n+        self.subst_spanned(tcx, substs, None)\n+    }\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> Self;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,19 +45,32 @@ pub trait Subst {\n // our current method/trait matching algorithm. - Niko\n \n impl Subst for ty::t {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n-        if ty::substs_is_noop(substs) {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::t {\n+        if ty::substs_is_noop(substs) && !ty::type_has_params(*self) {\n             *self\n         } else {\n-            let mut folder = SubstFolder {tcx: tcx, substs: substs};\n+            let mut folder = SubstFolder {\n+                tcx: tcx,\n+                substs: substs,\n+                span: span,\n+                root_ty: Some(*self)\n+            };\n             folder.fold_ty(*self)\n         }\n     }\n }\n \n struct SubstFolder<'a> {\n     tcx: ty::ctxt,\n-    substs: &'a ty::substs\n+    substs: &'a ty::substs,\n+\n+    // The location for which the substitution is performed, if available.\n+    span: Option<Span>,\n+\n+    // The root type that is being substituted, if available.\n+    root_ty: Option<ty::t>\n }\n \n impl<'a> TypeFolder for SubstFolder<'a> {\n@@ -65,14 +87,42 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n \n         match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                self.substs.tps[p.idx]\n+                if p.idx < self.substs.tps.len() {\n+                    self.substs.tps[p.idx]\n+                } else {\n+                    let root_msg = match self.root_ty {\n+                        Some(root) => format!(\" in the substitution of `{}`\",\n+                                              root.repr(self.tcx)),\n+                        None => ~\"\"\n+                    };\n+                    let m = format!(\"missing type param `{}`{}\",\n+                                    t.repr(self.tcx), root_msg);\n+                    match self.span {\n+                        Some(span) => self.tcx.sess.span_err(span, m),\n+                        None => self.tcx.sess.err(m)\n+                    }\n+                    ty::mk_err()\n+                }\n             }\n             ty::ty_self(_) => {\n-                self.substs.self_ty.expect(\"ty_self not found in substs\")\n-            }\n-            _ => {\n-                ty_fold::super_fold_ty(self, t)\n+                match self.substs.self_ty {\n+                    Some(ty) => ty,\n+                    None => {\n+                        let root_msg = match self.root_ty {\n+                            Some(root) => format!(\" in the substitution of `{}`\",\n+                                                  root.repr(self.tcx)),\n+                            None => ~\"\"\n+                        };\n+                        let m = format!(\"missing `Self` type param{}\", root_msg);\n+                        match self.span {\n+                            Some(span) => self.tcx.sess.span_err(span, m),\n+                            None => self.tcx.sess.err(m)\n+                        }\n+                        ty::mk_err()\n+                    }\n+                }\n             }\n+            _ => ty_fold::super_fold_ty(self, t)\n         }\n     }\n }\n@@ -81,112 +131,145 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n // Other types\n \n impl<T:Subst> Subst for ~[T] {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ~[T] {\n-        self.map(|t| t.subst(tcx, substs))\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ~[T] {\n+        self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n impl<T:Subst> Subst for Rc<T> {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Rc<T> {\n-        Rc::new(self.borrow().subst(tcx, substs))\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> Rc<T> {\n+        Rc::new(self.borrow().subst_spanned(tcx, substs, span))\n     }\n }\n \n impl<T:Subst> Subst for OptVec<T> {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> OptVec<T> {\n-        self.map(|t| t.subst(tcx, substs))\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> OptVec<T> {\n+        self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n \n impl<T:Subst + 'static> Subst for @T {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @T {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> @T {\n         match self {\n-            t => @(**t).subst(tcx, substs)\n+            t => @(**t).subst_spanned(tcx, substs, span)\n         }\n     }\n }\n \n impl<T:Subst> Subst for Option<T> {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Option<T> {\n-        self.as_ref().map(|t| t.subst(tcx, substs))\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> Option<T> {\n+        self.as_ref().map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n \n impl Subst for ty::TraitRef {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::TraitRef {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::TraitRef {\n         ty::TraitRef {\n             def_id: self.def_id,\n-            substs: self.substs.subst(tcx, substs)\n+            substs: self.substs.subst_spanned(tcx, substs, span)\n         }\n     }\n }\n \n impl Subst for ty::substs {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::substs {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::substs {\n         ty::substs {\n-            regions: self.regions.subst(tcx, substs),\n-            self_ty: self.self_ty.map(|typ| typ.subst(tcx, substs)),\n-            tps: self.tps.map(|typ| typ.subst(tcx, substs))\n+            regions: self.regions.subst_spanned(tcx, substs, span),\n+            self_ty: self.self_ty.map(|typ| typ.subst_spanned(tcx, substs, span)),\n+            tps: self.tps.map(|typ| typ.subst_spanned(tcx, substs, span))\n         }\n     }\n }\n \n impl Subst for ty::RegionSubsts {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::RegionSubsts {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::RegionSubsts {\n         match *self {\n             ty::ErasedRegions => {\n                 ty::ErasedRegions\n             }\n             ty::NonerasedRegions(ref regions) => {\n-                ty::NonerasedRegions(regions.subst(tcx, substs))\n+                ty::NonerasedRegions(regions.subst_spanned(tcx, substs, span))\n             }\n         }\n     }\n }\n \n impl Subst for ty::BareFnTy {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::BareFnTy {\n-        let mut folder = SubstFolder {tcx: tcx, substs: substs};\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::BareFnTy {\n+        let mut folder = SubstFolder {\n+            tcx: tcx,\n+            substs: substs,\n+            span: span,\n+            root_ty: None\n+        };\n         folder.fold_bare_fn_ty(self)\n     }\n }\n \n impl Subst for ty::ParamBounds {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::ParamBounds {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::ParamBounds {\n         ty::ParamBounds {\n             builtin_bounds: self.builtin_bounds,\n-            trait_bounds: self.trait_bounds.subst(tcx, substs)\n+            trait_bounds: self.trait_bounds.subst_spanned(tcx, substs, span)\n         }\n     }\n }\n \n impl Subst for ty::TypeParameterDef {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::TypeParameterDef {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::TypeParameterDef {\n         ty::TypeParameterDef {\n             ident: self.ident,\n             def_id: self.def_id,\n-            bounds: self.bounds.subst(tcx, substs),\n-            default: self.default.map(|x| x.subst(tcx, substs))\n+            bounds: self.bounds.subst_spanned(tcx, substs, span),\n+            default: self.default.map(|x| x.subst_spanned(tcx, substs, span))\n         }\n     }\n }\n \n impl Subst for ty::Generics {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Generics {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::Generics {\n         ty::Generics {\n-            type_param_defs: self.type_param_defs.subst(tcx, substs),\n-            region_param_defs: self.region_param_defs.subst(tcx, substs),\n+            type_param_defs: self.type_param_defs.subst_spanned(tcx, substs, span),\n+            region_param_defs: self.region_param_defs.subst_spanned(tcx, substs, span),\n         }\n     }\n }\n \n impl Subst for ty::RegionParameterDef {\n-    fn subst(&self, _: ty::ctxt, _: &ty::substs) -> ty::RegionParameterDef {\n+    fn subst_spanned(&self, _: ty::ctxt,\n+                     _: &ty::substs,\n+                     _: Option<Span>) -> ty::RegionParameterDef {\n         *self\n     }\n }\n \n impl Subst for ty::Region {\n-    fn subst(&self, _tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n+    fn subst_spanned(&self, _tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     _: Option<Span>) -> ty::Region {\n         // Note: This routine only handles regions that are bound on\n         // type declarationss and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n@@ -206,10 +289,12 @@ impl Subst for ty::Region {\n }\n \n impl Subst for ty::ty_param_bounds_and_ty {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::ty_param_bounds_and_ty {\n+    fn subst_spanned(&self, tcx: ty::ctxt,\n+                     substs: &ty::substs,\n+                     span: Option<Span>) -> ty::ty_param_bounds_and_ty {\n         ty::ty_param_bounds_and_ty {\n-            generics: self.generics.subst(tcx, substs),\n-            ty: self.ty.subst(tcx, substs)\n+            generics: self.generics.subst_spanned(tcx, substs, span),\n+            ty: self.ty.subst_spanned(tcx, substs, span)\n         }\n     }\n }"}, {"sha": "906bb504bb05326c9d698ef0bd66056331134289", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -52,6 +52,7 @@\n \n use middle::const_eval;\n use middle::lint;\n+use middle::subst::Subst;\n use middle::ty::{substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n@@ -228,16 +229,23 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                                  ~\"provided type arguments with defaults\");\n     }\n \n-    let defaults = decl_generics.type_param_defs().slice_from(supplied_ty_param_count)\n-                                .iter().map(|&x| x.default.unwrap());\n     let tps = path.segments.iter().flat_map(|s| s.types.iter())\n                             .map(|&a_t| ast_ty_to_ty(this, rscope, a_t))\n-                            .chain(defaults).collect();\n-    substs {\n+                            .collect();\n+\n+    let mut substs = substs {\n         regions: ty::NonerasedRegions(regions),\n         self_ty: self_ty,\n         tps: tps\n+    };\n+\n+    for param in decl_generics.type_param_defs()\n+                              .slice_from(supplied_ty_param_count).iter() {\n+        let ty = param.default.unwrap().subst_spanned(tcx, &substs, Some(path.span));\n+        substs.tps.push(ty);\n     }\n+\n+    substs\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,"}, {"sha": "74655914a27c99c6f315e07bef01c0a2f3658bed", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 26, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -3744,6 +3744,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n                 infer::BoundRegionInTypeOrImpl(span),\n                 num_expected_regions))\n     };\n+    let regions = ty::NonerasedRegions(regions);\n \n     // Special case: If there is a self parameter, omit it from the list of\n     // type parameters.\n@@ -3762,12 +3763,12 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n     // determine values for type parameters, using the values given by\n     // the user (if any) and otherwise using fresh type variables\n-    let tps = if ty_substs_len == 0 {\n-        fcx.infcx().next_ty_vars(ty_param_count)\n+    let (tps, regions) = if ty_substs_len == 0 {\n+        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n     } else if ty_param_count == 0 {\n         fcx.ccx.tcx.sess.span_err\n             (span, \"this item does not take type parameters\");\n-        fcx.infcx().next_ty_vars(ty_param_count)\n+        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n     } else if ty_substs_len > user_ty_param_count {\n         let expected = if user_ty_param_req < user_ty_param_count {\n             \"expected at most\"\n@@ -3778,7 +3779,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n             (span,\n              format!(\"too many type parameters provided: {} {}, found {}\",\n                   expected, user_ty_param_count, ty_substs_len));\n-        fcx.infcx().next_ty_vars(ty_param_count)\n+        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n     } else if ty_substs_len < user_ty_param_req {\n         let expected = if user_ty_param_req < user_ty_param_count {\n             \"expected at least\"\n@@ -3789,7 +3790,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n             (span,\n              format!(\"not enough type parameters provided: {} {}, found {}\",\n                   expected, user_ty_param_req, ty_substs_len));\n-        fcx.infcx().next_ty_vars(ty_param_count)\n+        (fcx.infcx().next_ty_vars(ty_param_count), regions)\n     } else {\n         if ty_substs_len > user_ty_param_req {\n             fcx.tcx().sess.add_lint(lint::DefaultTypeParamUsage, node_id, pth.span,\n@@ -3798,50 +3799,71 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         // Build up the list of type parameters, inserting the self parameter\n         // at the appropriate position.\n-        let mut result = ~[];\n+        let mut tps = ~[];\n         let mut pushed = false;\n+        for (i, ty) in pth.segments.iter()\n+                                   .flat_map(|segment| segment.types.iter())\n+                                   .map(|&ast_type| fcx.to_ty(ast_type))\n+                                   .enumerate() {\n+            match self_parameter_index {\n+                Some(index) if index == i => {\n+                    tps.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    pushed = true;\n+                }\n+                _ => {}\n+            }\n+            tps.push(ty)\n+        }\n+\n+        let mut substs = substs {\n+            regions: regions,\n+            self_ty: None,\n+            tps: tps\n+        };\n+\n         let defaults = tpt.generics.type_param_defs().iter()\n                           .enumerate().filter_map(|(i, x)| {\n             match self_parameter_index {\n                 Some(index) if index == i => None,\n                 _ => Some(x.default)\n             }\n-        }).skip(ty_substs_len).map(|x| match x {\n-            Some(default) => default,\n-            None => {\n-                fcx.tcx().sess.span_bug(span,\n-                    \"missing default for a not explicitely provided type param\")\n-            }\n         });\n-        for (i, ty) in pth.segments.iter()\n-                                   .flat_map(|segment| segment.types.iter())\n-                                   .map(|&ast_type| fcx.to_ty(ast_type))\n-                                   .chain(defaults).enumerate() {\n+        for (i, default) in defaults.skip(ty_substs_len).enumerate() {\n             match self_parameter_index {\n-                Some(index) if index == i => {\n-                    result.push(fcx.infcx().next_ty_vars(1)[0]);\n+                Some(index) if index == i + ty_substs_len => {\n+                    substs.tps.push(fcx.infcx().next_ty_vars(1)[0]);\n                     pushed = true;\n                 }\n                 _ => {}\n             }\n-            result.push(ty)\n+            match default {\n+                Some(default) => {\n+                    let ty = default.subst_spanned(fcx.tcx(), &substs, Some(span));\n+                    substs.tps.push(ty);\n+                }\n+                None => {\n+                    fcx.tcx().sess.span_bug(span,\n+                        \"missing default for a not explicitely provided type param\")\n+                }\n+            }\n         }\n \n         // If the self parameter goes at the end, insert it there.\n         if !pushed && self_parameter_index.is_some() {\n-            result.push(fcx.infcx().next_ty_vars(1)[0])\n+            substs.tps.push(fcx.infcx().next_ty_vars(1)[0])\n         }\n \n-        assert_eq!(result.len(), ty_param_count)\n-        result\n+        assert_eq!(substs.tps.len(), ty_param_count)\n+\n+        let substs {tps, regions, ..} = substs;\n+        (tps, regions)\n     };\n \n-    let substs = substs {\n-        regions: ty::NonerasedRegions(regions),\n+    fcx.write_ty_substs(node_id, tpt.ty, substs {\n+        regions: regions,\n         self_ty: None,\n         tps: tps\n-    };\n-    fcx.write_ty_substs(node_id, tpt.ty, substs);\n+    });\n \n     debug!(\"<<<\");\n }"}, {"sha": "334407ff12275ae321c022493a2c4d302731abed", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -525,13 +525,25 @@ pub fn parameterized(cx: ctxt,\n     } else {\n         ty::lookup_item_type(cx, did).generics\n     };\n-    let ty_params = generics.type_param_defs().iter();\n-    let num_defaults = ty_params.zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n-        match def.default {\n-            Some(default) => default == actual,\n-            None => false\n-        }\n-    }).len();\n+    let ty_params = generics.type_param_defs();\n+    let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n+    let num_defaults = if has_defaults {\n+        // We should have a borrowed version of substs instead of cloning.\n+        let mut substs = ty::substs {\n+            tps: tps.to_owned(),\n+            regions: regions.clone(),\n+            self_ty: None\n+        };\n+        ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n+            substs.tps.pop();\n+            match def.default {\n+                Some(default) => ty::subst(cx, &substs, default) == actual,\n+                None => false\n+            }\n+        }).len()\n+    } else {\n+        0\n+    };\n \n     for t in tps.slice_to(tps.len() - num_defaults).iter() {\n         strs.push(ty_to_str(cx, *t))"}, {"sha": "003ffdc8cc00dcb8ad02bb0b63f6e06bd7eac3b0", "filename": "src/test/compile-fail/generic-type-params-forward-mention.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-forward-mention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-forward-mention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-forward-mention.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(default_type_params)];\n+\n+// Ensure that we get an error and not an ICE for this problematic case.\n+struct Foo<T = Option<U>, U = bool>;\n+\n+fn main() {\n+    let x: Foo;\n+    //~^ ERROR missing type param `U` in the substitution of `std::option::Option<U>`\n+}"}, {"sha": "066bbc38e1a5f133681331dd04f1b028903010bc", "filename": "src/test/compile-fail/generic-type-params-name-repr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -15,6 +15,9 @@ struct B;\n struct C;\n struct Foo<T = A, U = B, V = C>;\n \n+struct Hash<T>;\n+struct HashMap<K, V, H = Hash<K>>;\n+\n fn main() {\n     // Ensure that the printed type doesn't include the default type params...\n     let _: Foo<int> = ();\n@@ -24,6 +27,12 @@ fn main() {\n     let _: Foo<int, B, C> = ();\n     //~^ ERROR mismatched types: expected `Foo<int>` but found `()`\n \n+    // Including cases where the default is using previous type params.\n+    let _: HashMap<~str, int> = ();\n+    //~^ ERROR mismatched types: expected `HashMap<~str,int>` but found `()`\n+    let _: HashMap<~str, int, Hash<~str>> = ();\n+    //~^ ERROR mismatched types: expected `HashMap<~str,int>` but found `()`\n+\n     // But not when there's a different type in between.\n     let _: Foo<A, int, C> = ();\n     //~^ ERROR mismatched types: expected `Foo<A,int>` but found `()`"}, {"sha": "1521710072dcd27f041295f2c67e09bdda7300e5", "filename": "src/test/run-pass/generic-default-type-params.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0eb3c0bf9a220e4e44014df08ffd2d1194315b/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs?ref=3e0eb3c0bf9a220e4e44014df08ffd2d1194315b", "patch": "@@ -52,6 +52,16 @@ fn default_foo(x: Foo) {\n     assert_eq!(x.baz(), (1, 'a'));\n }\n \n+#[deriving(Eq)]\n+struct BazHelper<T>(T);\n+\n+#[deriving(Eq)]\n+// Ensure that we can use previous type parameters in defaults.\n+struct Baz<T, U = BazHelper<T>, V = Option<U>>(T, U, V);\n+\n fn main() {\n     default_foo(Foo { a: (1, 'a') });\n+\n+    let x: Baz<bool> = Baz(true, BazHelper(false), Some(BazHelper(true)));\n+    assert_eq!(x, Baz(true, BazHelper(false), Some(BazHelper(true))));\n }"}]}