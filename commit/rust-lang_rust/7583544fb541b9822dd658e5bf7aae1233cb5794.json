{"sha": "7583544fb541b9822dd658e5bf7aae1233cb5794", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODM1NDRmYjU0MWI5ODIyZGQ2NThlNWJmN2FhZTEyMzNjYjU3OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T22:26:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T22:26:31Z"}, "message": "auto merge of #13912 : seanmonstar/rust/logrecord, r=alexcrichton\n\nThe logging macros now create a LogRecord, and pass that to the Logger. This will allow custom loggers to change the formatting, and possible filter on more properties of the log record.\r\n\r\nDefaultLogger's formatting was taken from Python's default formatting:\r\n`LEVEL:from: message`\r\n\r\nAlso included: fmt::Arguments now implement Show, so they can be used to\r\nextend format strings.\r\n\r\n@alexcrichton r?", "tree": {"sha": "7688efdf8aaee7d6c0b2b34a40ab556b76a71986", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7688efdf8aaee7d6c0b2b34a40ab556b76a71986"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7583544fb541b9822dd658e5bf7aae1233cb5794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7583544fb541b9822dd658e5bf7aae1233cb5794", "html_url": "https://github.com/rust-lang/rust/commit/7583544fb541b9822dd658e5bf7aae1233cb5794", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7583544fb541b9822dd658e5bf7aae1233cb5794/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "600507d5380ca7d6d5536fabc2d4aca400c21bb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/600507d5380ca7d6d5536fabc2d4aca400c21bb9", "html_url": "https://github.com/rust-lang/rust/commit/600507d5380ca7d6d5536fabc2d4aca400c21bb9"}, {"sha": "ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "html_url": "https://github.com/rust-lang/rust/commit/ceb29314a7e6fc2d9f3527e36534b2d1608394d8"}], "stats": {"total": 108, "additions": 92, "deletions": 16}, "files": [{"sha": "afbcf8c6ded5a7f35aadbb8614fd6d2995a401ed", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=7583544fb541b9822dd658e5bf7aae1233cb5794", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ascii::StrAsciiExt;\n use std::cmp;\n \n #[deriving(Show, Clone)]\n@@ -16,13 +17,13 @@ pub struct LogDirective {\n     pub level: u32,\n }\n \n-static LOG_LEVEL_NAMES: [&'static str, ..4] = [\"error\", \"warn\", \"info\",\n-                                               \"debug\"];\n+pub static LOG_LEVEL_NAMES: [&'static str, ..4] = [\"ERROR\", \"WARN\", \"INFO\",\n+                                               \"DEBUG\"];\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n     from_str::<u32>(level).or_else(|| {\n-        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name == level);\n+        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n         pos.map(|p| p as u32 + 1)\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }"}, {"sha": "d93922cf89d18b6707221106bd49c3270a7680a0", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=7583544fb541b9822dd658e5bf7aae1233cb5794", "patch": "@@ -129,6 +129,8 @@ use std::slice;\n \n use sync::one::{Once, ONCE_INIT};\n \n+use directive::LOG_LEVEL_NAMES;\n+\n pub mod macros;\n mod directive;\n \n@@ -162,19 +164,42 @@ local_data_key!(local_logger: ~Logger:Send)\n /// can have its own custom logger which can respond to logging messages\n /// however it likes.\n pub trait Logger {\n-    /// Logs a single message described by the `args` structure. The level is\n-    /// provided in case you want to do things like color the message, etc.\n-    fn log(&mut self, level: u32, args: &fmt::Arguments);\n+    /// Logs a single message described by the `record`.\n+    fn log(&mut self, record: &LogRecord);\n }\n \n struct DefaultLogger {\n     handle: LineBufferedWriter<io::stdio::StdWriter>,\n }\n \n+/// Wraps the log level with fmt implementations.\n+#[deriving(Eq, Ord)]\n+pub struct LogLevel(pub u32);\n+\n+impl fmt::Show for LogLevel {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let LogLevel(level) = *self;\n+        match LOG_LEVEL_NAMES.get(level as uint - 1) {\n+            Some(name) => name.fmt(fmt),\n+            None => level.fmt(fmt)\n+        }\n+    }\n+}\n+\n+impl fmt::Signed for LogLevel {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let LogLevel(level) = *self;\n+        write!(fmt.buf, \"{}\", level)\n+    }\n+}\n+\n impl Logger for DefaultLogger {\n-    // by default, just ignore the level\n-    fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n-        match fmt::writeln(&mut self.handle, args) {\n+    fn log(&mut self, record: &LogRecord) {\n+        match write!(&mut self.handle,\n+                     \"{}:{}: {}\",\n+                     record.level,\n+                     record.module_path,\n+                     record.args) {\n             Err(e) => fail!(\"failed to log: {}\", e),\n             Ok(()) => {}\n         }\n@@ -198,14 +223,21 @@ impl Drop for DefaultLogger {\n ///\n /// It is not recommended to call this function directly, rather it should be\n /// invoked through the logging family of macros.\n-pub fn log(level: u32, args: &fmt::Arguments) {\n+#[doc(hidden)]\n+pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n     let mut logger = local_data::pop(local_logger).unwrap_or_else(|| {\n         box DefaultLogger { handle: io::stderr() } as ~Logger:Send\n     });\n-    logger.log(level, args);\n+    logger.log(&LogRecord {\n+        level: LogLevel(level),\n+        args: args,\n+        file: loc.file,\n+        module_path: loc.module_path,\n+        line: loc.line,\n+    });\n     local_data::set(local_logger, logger);\n }\n \n@@ -223,6 +255,34 @@ pub fn set_logger(logger: ~Logger:Send) -> Option<~Logger:Send> {\n     return prev;\n }\n \n+/// A LogRecord is created by the logging macros, and passed as the only\n+/// argument to Loggers.\n+#[deriving(Show)]\n+pub struct LogRecord<'a> {\n+\n+    /// The module path of where the LogRecord originated.\n+    pub module_path: &'a str,\n+\n+    /// The LogLevel of this record.\n+    pub level: LogLevel,\n+\n+    /// The arguments from the log line.\n+    pub args: &'a fmt::Arguments<'a>,\n+\n+    /// The file of where the LogRecord originated.\n+    pub file: &'a str,\n+\n+    /// The line number of where the LogRecord originated.\n+    pub line: uint,\n+}\n+\n+#[doc(hidden)]\n+pub struct LogLocation {\n+    pub module_path: &'static str,\n+    pub file: &'static str,\n+    pub line: uint,\n+}\n+\n /// Tests whether a given module's name is enabled for a particular level of\n /// logging. This is the second layer of defense about determining whether a\n /// module's log statement should be emitted or not."}, {"sha": "3bb49c237f14686651e21ca731aa0156bd81fc42", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=7583544fb541b9822dd658e5bf7aae1233cb5794", "patch": "@@ -33,9 +33,14 @@\n #[macro_export]\n macro_rules! log(\n     ($lvl:expr, $($arg:tt)+) => ({\n+        static LOC: ::log::LogLocation = ::log::LogLocation {\n+            line: line!(),\n+            file: file!(),\n+            module_path: module_path!(),\n+        };\n         let lvl = $lvl;\n         if log_enabled!(lvl) {\n-            format_args!(|args| { ::log::log(lvl, args) }, $($arg)+)\n+            format_args!(|args| { ::log::log(lvl, &LOC, args) }, $($arg)+)\n         }\n     })\n )"}, {"sha": "e225dc42e057046333be8eaa73106c593a708e90", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=7583544fb541b9822dd658e5bf7aae1233cb5794", "patch": "@@ -565,6 +565,12 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n+impl<'a> Show for Arguments<'a> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, self)\n+    }\n+}\n+\n /// When a format is not otherwise specified, types are formatted by ascribing\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified."}, {"sha": "3859ed3a53d3ed21f2c570c4e2627683988516b2", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=7583544fb541b9822dd658e5bf7aae1233cb5794", "patch": "@@ -19,14 +19,14 @@ extern crate native;\n \n use std::fmt;\n use std::io::{ChanReader, ChanWriter};\n-use log::{set_logger, Logger};\n+use log::{set_logger, Logger, LogRecord};\n \n struct MyWriter(ChanWriter);\n \n impl Logger for MyWriter {\n-    fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n+    fn log(&mut self, record: &LogRecord) {\n         let MyWriter(ref mut inner) = *self;\n-        fmt::writeln(inner as &mut Writer, args);\n+        fmt::writeln(inner as &mut Writer, record.args);\n     }\n }\n "}, {"sha": "16b21f5f53729313b995393b981dfc1f361fd202", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7583544fb541b9822dd658e5bf7aae1233cb5794/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=7583544fb541b9822dd658e5bf7aae1233cb5794", "patch": "@@ -33,7 +33,7 @@ impl fmt::Signed for B {\n     }\n }\n \n-macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n+macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) })\n \n pub fn main() {\n     // Make sure there's a poly formatter that takes anything\n@@ -202,6 +202,10 @@ fn test_format_args() {\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");\n     t!(s, \"hello world\");\n+    let s = format_args!(|args| {\n+        format!(\"{}: {}\", \"args were\", args)\n+    }, \"hello {}\", \"world\");\n+    t!(s, \"args were: hello world\");\n }\n \n fn test_order() {"}]}