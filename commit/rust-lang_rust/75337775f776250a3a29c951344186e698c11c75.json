{"sha": "75337775f776250a3a29c951344186e698c11c75", "node_id": "C_kwDOAAsO6NoAKDc1MzM3Nzc1Zjc3NjI1MGEzYTI5Yzk1MTM0NDE4NmU2OThjMTFjNzU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-28T07:12:49Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-28T07:19:49Z"}, "message": "Remove `final_arg_types`, improve tuple wrapping suggestion", "tree": {"sha": "183204fc4e77f87a5af520d0eb0d09ae82e20ec8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/183204fc4e77f87a5af520d0eb0d09ae82e20ec8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75337775f776250a3a29c951344186e698c11c75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75337775f776250a3a29c951344186e698c11c75", "html_url": "https://github.com/rust-lang/rust/commit/75337775f776250a3a29c951344186e698c11c75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75337775f776250a3a29c951344186e698c11c75/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2277e03eeb112730e3f07fab0d6b91d195fe55c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2277e03eeb112730e3f07fab0d6b91d195fe55c", "html_url": "https://github.com/rust-lang/rust/commit/f2277e03eeb112730e3f07fab0d6b91d195fe55c"}], "stats": {"total": 378, "additions": 199, "deletions": 179}, "files": [{"sha": "e319f17b0e60d5fccc69536a0b085b279e2f4c91", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -342,8 +342,8 @@ pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         )\n         | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n         | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-        (&ty::Ref(reg_a, ty_a, mut_a), &ty::Ref(reg_b, ty_b, mut_b)) => {\n-            reg_a == reg_b && mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n+        (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n+            mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n         }\n         _ => a == b,\n     }"}, {"sha": "ede2ed5169f8049dc0aa90ab51d53d11a2465632", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 140, "deletions": 170, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -24,7 +24,6 @@ use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n use rustc_session::Session;\n@@ -35,12 +34,6 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpres\n use std::iter;\n use std::slice;\n \n-enum TupleMatchFound {\n-    None,\n-    Single,\n-    /// Beginning and end Span\n-    Multiple(Span, Span),\n-}\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&self) {\n         let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -216,14 +209,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let minimum_input_count = expected_input_tys.len();\n         let provided_arg_count = provided_args.len();\n \n-        // We'll also want to keep track of the fully coerced argument types, for an awkward hack near the end\n-        // FIXME(compiler-errors): Get rid of this, actually.\n-        let mut final_arg_types: Vec<Option<(Ty<'_>, Ty<'_>)>> = vec![None; provided_arg_count];\n-\n         // We introduce a helper function to demand that a given argument satisfy a given input\n         // This is more complicated than just checking type equality, as arguments could be coerced\n         // This version writes those types back so further type checking uses the narrowed types\n-        let demand_compatible = |idx, final_arg_types: &mut Vec<Option<(Ty<'tcx>, Ty<'tcx>)>>| {\n+        let demand_compatible = |idx| {\n             let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n             let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n             let provided_arg = &provided_args[idx];\n@@ -242,9 +231,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n             let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n \n-            // Keep track of these for below\n-            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n-\n             // Cause selection errors caused by resolving a single argument to point at the\n             // argument and not the call. This lets us customize the span pointed to in the\n             // fulfillment error to be more accurate.\n@@ -253,16 +239,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n-                        &final_arg_types,\n                         call_expr,\n                         call_span,\n                         provided_args,\n+                        &expected_input_tys,\n                     );\n                 });\n \n-            // Make sure we store the resolved type\n-            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n-\n             let coerce_error = self\n                 .try_coerce(provided_arg, checked_ty, coerced_ty, AllowTwoPhase::Yes, None)\n                 .err();\n@@ -320,10 +303,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n-                        &final_arg_types,\n                         call_expr,\n                         call_span,\n                         &provided_args,\n+                        &expected_input_tys,\n                     );\n                 })\n             }\n@@ -352,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let compatible = demand_compatible(idx, &mut final_arg_types);\n+                let compatible = demand_compatible(idx);\n                 let is_compatible = matches!(compatible, Compatibility::Compatible);\n                 compatibility_diagonal[idx] = compatible;\n \n@@ -445,72 +428,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 None => \"function\",\n             };\n \n-            let try_tuple_wrap_args = || {\n-                // The case where we expect a single tuple and wrapping all the args\n-                // in parentheses (or adding a comma to already existing parentheses)\n-                // will result in a tuple that satisfies the call.\n-                // This isn't super ideal code, because we copy code from elsewhere\n-                // and somewhat duplicate this. We also delegate to the general type\n-                // mismatch suggestions for the single arg case.\n-                match self.suggested_tuple_wrap(&expected_input_tys, provided_args) {\n-                    TupleMatchFound::Single => {\n-                        let expected_ty = expected_input_tys[0];\n-                        let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n-                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                        let cause = &self.misc(provided_args[0].span);\n-                        let compatibility = demand_compatible(0, &mut final_arg_types);\n-                        let type_error = match compatibility {\n-                            Compatibility::Incompatible(Some(error)) => error,\n-                            _ => TypeError::Mismatch,\n-                        };\n-                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                        let mut err = self.report_and_explain_type_error(trace, &type_error);\n-                        self.emit_coerce_suggestions(\n-                            &mut err,\n-                            &provided_args[0],\n-                            final_arg_types[0].map(|ty| ty.0).unwrap(),\n-                            final_arg_types[0].map(|ty| ty.1).unwrap(),\n-                            None,\n-                            None,\n-                        );\n-                        err.span_label(\n-                            full_call_span,\n-                            format!(\"arguments to this {} are incorrect\", call_name),\n-                        );\n-                        // Call out where the function is defined\n-                        label_fn_like(tcx, &mut err, fn_def_id);\n-                        err.emit();\n-                        return true;\n-                    }\n-                    TupleMatchFound::Multiple(start, end) => {\n-                        let mut err = tcx.sess.struct_span_err_with_code(\n-                            full_call_span,\n-                            &format!(\n-                                \"this {} takes {}{} but {} {} supplied\",\n-                                call_name,\n-                                if c_variadic { \"at least \" } else { \"\" },\n-                                potentially_plural_count(minimum_input_count, \"argument\"),\n-                                potentially_plural_count(provided_arg_count, \"argument\"),\n-                                if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                            ),\n-                            DiagnosticId::Error(err_code.to_owned()),\n-                        );\n-                        // Call out where the function is defined\n-                        label_fn_like(tcx, &mut err, fn_def_id);\n-                        err.multipart_suggestion(\n-                            \"use parentheses to construct a tuple\",\n-                            vec![(start, '('.to_string()), (end, ')'.to_string())],\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n-                        return true;\n-                    }\n-                    TupleMatchFound::None => {}\n-                }\n-                false\n-            };\n-\n             let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n             let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n                 minimum_input_count\n@@ -541,7 +458,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n-                try_tuple_wrap_args,\n             );\n         }\n     }\n@@ -558,7 +474,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n-        try_tuple_wrap_args: impl FnOnce() -> bool,\n     ) {\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n@@ -578,7 +493,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let (formal_input_ty, expected_input_ty) = formal_and_expected_inputs[expected_idx];\n             // If either is an error type, we defy the usual convention and consider them to *not* be\n-            // coercible.  This prevents our error message heuristic from trying to pass errors into\n+            // coercible. This prevents our error message heuristic from trying to pass errors into\n             // every argument.\n             if (formal_input_ty, expected_input_ty).references_error() {\n                 return Compatibility::Incompatible(None);\n@@ -599,16 +514,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(None);\n             }\n \n-            let subtyping_result = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n+            // Using probe here, since we don't want this subtyping to affect inference.\n+            let subtyping_error = self.probe(|_| {\n+                self.at(&self.misc(provided_arg.span), self.param_env)\n+                    .sup(formal_input_ty, coerced_ty)\n+                    .err()\n+            });\n \n             // Same as above: if either the coerce type or the checked type is an error type,\n             // consider them *not* compatible.\n             let references_error = (coerced_ty, checked_ty).references_error();\n-            match (references_error, &subtyping_result) {\n-                (false, Ok(_)) => Compatibility::Compatible,\n-                _ => Compatibility::Incompatible(subtyping_result.err()),\n+            match (references_error, subtyping_error) {\n+                (false, None) => Compatibility::Compatible,\n+                (_, subtyping_error) => Compatibility::Incompatible(subtyping_error),\n             }\n         };\n \n@@ -629,16 +547,105 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .map(|expr| {\n                 let ty = self\n-                    .in_progress_typeck_results\n-                    .as_ref()\n-                    .unwrap()\n+                    .typeck_results\n                     .borrow()\n                     .expr_ty_adjusted_opt(*expr)\n                     .unwrap_or_else(|| tcx.ty_error());\n                 (self.resolve_vars_if_possible(ty), expr.span)\n             })\n             .collect();\n \n+        // First, check if we just need to wrap some arguments in a tuple.\n+        if let Some((mismatch_idx, terr)) =\n+            compatibility_diagonal.iter().enumerate().find_map(|(i, c)| {\n+                if let Compatibility::Incompatible(Some(terr)) = c { Some((i, terr)) } else { None }\n+            })\n+        {\n+            // Is the first bad expected argument a tuple?\n+            // Do we have as many extra provided arguments as the tuple's length?\n+            // If so, we might have just forgotten to wrap some args in a tuple.\n+            if let Some(ty::Tuple(tys)) =\n+                formal_and_expected_inputs.get(mismatch_idx.into()).map(|tys| tys.1.kind())\n+                && provided_arg_tys.len() == formal_and_expected_inputs.len() - 1 + tys.len()\n+            {\n+                // Wrap up the N provided arguments starting at this position in a tuple.\n+                let provided_as_tuple = tcx.mk_tup(\n+                    provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx).take(tys.len()),\n+                );\n+\n+                let mut satisfied = true;\n+                // Check if the newly wrapped tuple + rest of the arguments are compatible.\n+                for ((_, expected_ty), provided_ty) in std::iter::zip(\n+                    formal_and_expected_inputs.iter().skip(mismatch_idx),\n+                    [provided_as_tuple].into_iter().chain(\n+                        provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx + tys.len()),\n+                    ),\n+                ) {\n+                    if !self.can_coerce(provided_ty, *expected_ty) {\n+                        satisfied = false;\n+                        break;\n+                    }\n+                }\n+\n+                // If they're compatible, suggest wrapping in an arg, and we're done!\n+                // Take some care with spans, so we don't suggest wrapping a macro's\n+                // innards in parenthesis, for example.\n+                if satisfied\n+                    && let Some(lo) =\n+                        provided_args[mismatch_idx.into()].span.find_ancestor_inside(error_span)\n+                    && let Some(hi) = provided_args[(mismatch_idx + tys.len() - 1).into()]\n+                        .span\n+                        .find_ancestor_inside(error_span)\n+                {\n+                    let mut err;\n+                    if tys.len() == 1 {\n+                        // A tuple wrap suggestion actually occurs within,\n+                        // so don't do anything special here.\n+                        err = self.report_and_explain_type_error(\n+                            TypeTrace::types(\n+                                &self.misc(lo),\n+                                true,\n+                                formal_and_expected_inputs[mismatch_idx.into()].1,\n+                                provided_arg_tys[mismatch_idx.into()].0,\n+                            ),\n+                            terr,\n+                        );\n+                        err.span_label(\n+                            full_call_span,\n+                            format!(\"arguments to this {} are incorrect\", call_name),\n+                        );\n+                    } else {\n+                        err = tcx.sess.struct_span_err_with_code(\n+                            full_call_span,\n+                            &format!(\n+                                \"this {} takes {}{} but {} {} supplied\",\n+                                call_name,\n+                                if c_variadic { \"at least \" } else { \"\" },\n+                                potentially_plural_count(\n+                                    formal_and_expected_inputs.len(),\n+                                    \"argument\"\n+                                ),\n+                                potentially_plural_count(provided_args.len(), \"argument\"),\n+                                if provided_args.len() == 1 { \"was\" } else { \"were\" }\n+                            ),\n+                            DiagnosticId::Error(err_code.to_owned()),\n+                        );\n+                        err.multipart_suggestion_verbose(\n+                            \"wrap these arguments in parentheses to construct a tuple\",\n+                            vec![\n+                                (lo.shrink_to_lo(), \"(\".to_string()),\n+                                (hi.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    };\n+                    label_fn_like(tcx, &mut err, fn_def_id);\n+                    err.emit();\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Okay, so here's where it gets complicated in regards to what errors\n         // we emit and how.\n         // There are 3 different \"types\" of errors we might encounter.\n@@ -666,7 +673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     )\n                     .note(\n                         \"we would appreciate a bug report: \\\n-                        https://github.com/rust-lang/rust-clippy/issues/new\",\n+                        https://github.com/rust-lang/rust/issues/new\",\n                     )\n                     .emit();\n             }\n@@ -727,13 +734,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        // Second, let's try tuple wrapping the args.\n-        // FIXME(compiler-errors): This is currently in its own closure because\n-        // I didn't want to factor it out.\n-        if try_tuple_wrap_args() {\n-            return;\n-        }\n-\n         let mut err = if formal_and_expected_inputs.len() == provided_args.len() {\n             struct_span_err!(\n                 tcx.sess,\n@@ -989,13 +989,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             String::new()\n                         };\n-                        // FIXME(compiler-errors): Why do we get permutations with the same type?\n-                        if expected_ty != provided_ty {\n-                            labels.push((\n-                                provided_span,\n-                                format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n-                            ));\n-                        }\n+                        labels.push((\n+                            provided_span,\n+                            format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n+                        ));\n                     }\n \n                     suggestion_text = match suggestion_text {\n@@ -1043,10 +1040,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     needs_comma = true;\n                 }\n-                let suggestion_text =\n-                    if let Some(provided_idx) = provided_idx\n+                let suggestion_text = if let Some(provided_idx) = provided_idx\n                     && let (_, provided_span) = provided_arg_tys[*provided_idx]\n-                    && let Ok(arg_text) = source_map.span_to_snippet(provided_span.source_callsite()) {\n+                    && let Ok(arg_text) =\n+                        source_map.span_to_snippet(provided_span.source_callsite())\n+                {\n                     arg_text\n                 } else {\n                     // Propose a placeholder of the correct type\n@@ -1073,38 +1071,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn suggested_tuple_wrap(\n-        &self,\n-        expected_input_tys: &[Ty<'tcx>],\n-        provided_args: &'tcx [hir::Expr<'tcx>],\n-    ) -> TupleMatchFound {\n-        // Only handle the case where we expect only one tuple arg\n-        let [expected_arg_type] = expected_input_tys[..] else { return TupleMatchFound::None };\n-        let &ty::Tuple(expected_types) = self.resolve_vars_if_possible(expected_arg_type).kind()\n-            else { return TupleMatchFound::None };\n-\n-        // First check that there are the same number of types.\n-        if expected_types.len() != provided_args.len() {\n-            return TupleMatchFound::None;\n-        }\n-\n-        let supplied_types: Vec<_> = provided_args.iter().map(|arg| self.check_expr(arg)).collect();\n-\n-        let all_match = iter::zip(expected_types, supplied_types)\n-            .all(|(expected, supplied)| self.can_eq(self.param_env, expected, supplied).is_ok());\n-\n-        if !all_match {\n-            return TupleMatchFound::None;\n-        }\n-        match provided_args {\n-            [] => TupleMatchFound::None,\n-            [_] => TupleMatchFound::Single,\n-            [first, .., last] => {\n-                TupleMatchFound::Multiple(first.span.shrink_to_lo(), last.span.shrink_to_hi())\n-            }\n-        }\n-    }\n-\n     // AST fragment checking\n     pub(in super::super) fn check_lit(\n         &self,\n@@ -1652,10 +1618,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n-        final_arg_types: &[Option<(Ty<'tcx>, Ty<'tcx>)>],\n         expr: &'tcx hir::Expr<'tcx>,\n         call_sp: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n+        expected_tys: &[Ty<'tcx>],\n     ) {\n         // We *do not* do this for desugared call spans to keep good diagnostics when involving\n         // the `?` operator.\n@@ -1688,39 +1654,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (result_code, code) = (code, parent);\n                 }\n             }\n-            let self_: ty::subst::GenericArg<'_> = match unpeel_to_top(error.obligation.cause.code()) {\n-                ObligationCauseCode::BuiltinDerivedObligation(code) |\n-                ObligationCauseCode::DerivedObligation(code) => {\n-                    code.parent_trait_pred.self_ty().skip_binder().into()\n-                }\n-                ObligationCauseCode::ImplDerivedObligation(code) => {\n-                    code.derived.parent_trait_pred.self_ty().skip_binder().into()\n-                }\n-                _ if let ty::PredicateKind::Trait(predicate) =\n-                    error.obligation.predicate.kind().skip_binder() => {\n+            let self_: ty::subst::GenericArg<'_> =\n+                match unpeel_to_top(error.obligation.cause.code()) {\n+                    ObligationCauseCode::BuiltinDerivedObligation(code)\n+                    | ObligationCauseCode::DerivedObligation(code) => {\n+                        code.parent_trait_pred.self_ty().skip_binder().into()\n+                    }\n+                    ObligationCauseCode::ImplDerivedObligation(code) => {\n+                        code.derived.parent_trait_pred.self_ty().skip_binder().into()\n+                    }\n+                    _ if let ty::PredicateKind::Trait(predicate) =\n+                        error.obligation.predicate.kind().skip_binder() =>\n+                    {\n                         predicate.self_ty().into()\n                     }\n-                _ =>  continue,\n-            };\n+                    _ => continue,\n+                };\n             let self_ = self.resolve_vars_if_possible(self_);\n \n             // Collect the argument position for all arguments that could have caused this\n             // `FulfillmentError`.\n-            let mut referenced_in = final_arg_types\n-                .iter()\n+            let typeck_results = self.typeck_results.borrow();\n+            let mut referenced_in: Vec<_> = std::iter::zip(expected_tys, args)\n                 .enumerate()\n-                .filter_map(|(i, arg)| match arg {\n-                    Some((checked_ty, coerce_ty)) => Some([(i, *checked_ty), (i, *coerce_ty)]),\n-                    _ => None,\n+                .flat_map(|(idx, (expected_ty, arg))| {\n+                    if let Some(arg_ty) = typeck_results.expr_ty_opt(arg) {\n+                        vec![(idx, arg_ty), (idx, *expected_ty)]\n+                    } else {\n+                        vec![]\n+                    }\n                 })\n-                .flatten()\n-                .flat_map(|(i, ty)| {\n+                .filter_map(|(i, ty)| {\n                     let ty = self.resolve_vars_if_possible(ty);\n                     // We walk the argument type because the argument's type could have\n                     // been `Option<T>`, but the `FulfillmentError` references `T`.\n                     if ty.walk().any(|arg| arg == self_) { Some(i) } else { None }\n                 })\n-                .collect::<Vec<usize>>();\n+                .collect();\n \n             // Both checked and coerced types could have matched, thus we need to remove\n             // duplicates."}, {"sha": "2448a5149654d318ef4067e2177a5e08815e4608", "filename": "src/test/ui/suggestions/args-instead-of-tuple.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -9,7 +9,7 @@ note: tuple variant defined here\n    |\n LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Result<(i32, i8), ()> = Ok((1, 2));\n    |                                       +    +\n@@ -25,7 +25,7 @@ note: tuple variant defined here\n    |\n LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Option<(i32, i8, &'static str)> = Some((1, 2, \"hi\"));\n    |                                                   +          +\n@@ -97,7 +97,7 @@ note: function defined here\n    |\n LL | fn two_ints(_: (i32, i32)) {\n    |    ^^^^^^^^ -------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     two_ints((1, 2));\n    |              +    +\n@@ -113,7 +113,7 @@ note: function defined here\n    |\n LL | fn with_generic<T: Copy + Send>((a, b): (i32, T)) {\n    |    ^^^^^^^^^^^^                 ----------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     with_generic((3, 4));\n    |                  +    +\n@@ -129,7 +129,7 @@ note: function defined here\n    |\n LL | fn with_generic<T: Copy + Send>((a, b): (i32, T)) {\n    |    ^^^^^^^^^^^^                 ----------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |         with_generic((a, b));\n    |                      +    +"}, {"sha": "089c703fda5c7a8101544a7b9148f78b447ba4fe", "filename": "src/test/ui/tuple/add-tuple-within-arguments.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -0,0 +1,10 @@\n+fn foo(s: &str, a: (i32, i32), s2: &str) {}\n+\n+fn bar(s: &str, a: (&str,), s2: &str) {}\n+\n+fn main() {\n+    foo(\"hi\", 1, 2, \"hi\");\n+    //~^ ERROR this function takes 3 arguments but 4 arguments were supplied\n+    bar(\"hi\", \"hi\", \"hi\");\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "95df96ca0dd4f2c09574f8b70cff237b97a06f5e", "filename": "src/test/ui/tuple/add-tuple-within-arguments.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -0,0 +1,40 @@\n+error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n+  --> $DIR/add-tuple-within-arguments.rs:6:5\n+   |\n+LL |     foo(\"hi\", 1, 2, \"hi\");\n+   |     ^^^\n+   |\n+note: function defined here\n+  --> $DIR/add-tuple-within-arguments.rs:1:4\n+   |\n+LL | fn foo(s: &str, a: (i32, i32), s2: &str) {}\n+   |    ^^^ -------  -------------  --------\n+help: wrap these arguments in parentheses to construct a tuple\n+   |\n+LL |     foo(\"hi\", (1, 2), \"hi\");\n+   |               +    +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/add-tuple-within-arguments.rs:8:15\n+   |\n+LL |     bar(\"hi\", \"hi\", \"hi\");\n+   |     ---       ^^^^ expected tuple, found `&str`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note:  expected tuple `(&str,)`\n+           found reference `&'static str`\n+note: function defined here\n+  --> $DIR/add-tuple-within-arguments.rs:3:4\n+   |\n+LL | fn bar(s: &str, a: (&str,), s2: &str) {}\n+   |    ^^^ -------  ----------  --------\n+help: use a trailing comma to create a tuple with one element\n+   |\n+LL |     bar(\"hi\", (\"hi\",), \"hi\");\n+   |               +    ++\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0308.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "0c2a4c41461fc4d108f5656c5bb8917e899df08a", "filename": "src/test/ui/tuple/wrong_argument_ice-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -9,7 +9,7 @@ note: function defined here\n    |\n LL | fn test(t: (i32, i32)) {}\n    |    ^^^^ -------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     test((x.qux(), x.qux()));\n    |          +                +"}, {"sha": "ec07f1e70cff6a135376c7f51c3529237dfdd66c", "filename": "src/test/ui/tuple/wrong_argument_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75337775f776250a3a29c951344186e698c11c75/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr?ref=75337775f776250a3a29c951344186e698c11c75", "patch": "@@ -9,7 +9,7 @@ note: associated function defined here\n    |\n LL |     pub fn push_back(&mut self, value: T) {\n    |            ^^^^^^^^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |         self.acc.push_back((self.current_provides, self.current_requires));\n    |                            +                                            +"}]}