{"sha": "d5ae6f7870ff937d69a20078bdbbc2093bde2279", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YWU2Zjc4NzBmZjkzN2Q2OWEyMDA3OGJkYmJjMjA5M2JkZTIyNzk=", "commit": {"author": {"name": "Rusty Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-09-28T05:16:29Z"}, "committer": {"name": "Rusty Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-09-28T11:43:48Z"}, "message": "[54015] NLL:Improve move error loop detection\n\nBefore this patch running the following command would generate the given output:\n$ rustc +stage1 src/test/ui/liveness/liveness-move-in-while.rs -Zborrowck=mir -Ztwo-phase-borrows\nerror[E0382]: borrow of moved value: `y`\n --> src/main.rs:8:24\n  |\n8 |         println!(\"{}\", y); //~ ERROR use of moved value: `y`\n  |                        ^ value borrowed here after move\n9 |         while true { while true { while true { x = y; x.clone(); } } }\n  |                                                    - value moved here\n  |\n  = note: move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n\nWe want to give the user more hint by telling them that the value was moved in the previous iteration of the\nloop. After this patch, the error message adds the phrase \"in previous iteration of loop\" and in totality\nlooks like this:\n\n$ rustc +stage1 src/test/ui/liveness/liveness-move-in-while.rs -Zborrowck=mir -Ztwo-phase-borrows\nerror[E0382]: borrow of moved value: `y`\n  --> src/test/ui/liveness/liveness-move-in-while.rs:17:24\n   |\n17 |         println!(\"{}\", y); //~ ERROR use of moved value: `y`\n   |                        ^ value borrowed here after move\n18 |         while true { while true { while true { x = y; x.clone(); } } }\n   |                                                    - value moved here, in previous iteration of loop\n   |\n   = note: move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait", "tree": {"sha": "d96c5175b9e093c99b724a8a38c46db4c11c9f81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d96c5175b9e093c99b724a8a38c46db4c11c9f81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5ae6f7870ff937d69a20078bdbbc2093bde2279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ae6f7870ff937d69a20078bdbbc2093bde2279", "html_url": "https://github.com/rust-lang/rust/commit/d5ae6f7870ff937d69a20078bdbbc2093bde2279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5ae6f7870ff937d69a20078bdbbc2093bde2279/comments", "author": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "html_url": "https://github.com/rust-lang/rust/commit/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39"}], "stats": {"total": 85, "additions": 60, "deletions": 25}, "files": [{"sha": "22b135bee492ac9e6a7e904e8bd4321c1723de1e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d5ae6f7870ff937d69a20078bdbbc2093bde2279/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ae6f7870ff937d69a20078bdbbc2093bde2279/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=d5ae6f7870ff937d69a20078bdbbc2093bde2279", "patch": "@@ -35,6 +35,17 @@ use dataflow::move_paths::indexes::MoveOutIndex;\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n+#[derive(Debug)]\n+struct MoveSite {\n+    /// Index of the \"move out\" that we found. The `MoveData` can\n+    /// then tell us where the move occurred.\n+    moi: MoveOutIndex,\n+\n+    /// True if we traversed a back edge while walking from the point\n+    /// of error to the move site.\n+    traversed_back_edge: bool\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n@@ -53,10 +64,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n-        let mois = self.get_moved_indexes(context, mpi);\n-        debug!(\"report_use_of_moved_or_uninitialized: mois={:?}\", mois);\n+        let move_site_vec = self.get_moved_indexes(context, mpi);\n+        debug!(\n+            \"report_use_of_moved_or_uninitialized: move_site_vec={:?}\",\n+            move_site_vec\n+        );\n+        let move_out_indices: Vec<_> = move_site_vec\n+            .iter()\n+            .map(|move_site| move_site.moi)\n+            .collect();\n \n-        if mois.is_empty() {\n+        if move_out_indices.is_empty() {\n             let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n \n             if self.uninitialized_error_reported\n@@ -91,14 +109,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             err.buffer(&mut self.errors_buffer);\n         } else {\n-            if let Some((reported_place, _)) = self.move_error_reported.get(&mois) {\n+            if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n                 if self.prefixes(&reported_place, PrefixSet::All)\n                     .any(|p| p == place)\n                 {\n                     debug!(\n                         \"report_use_of_moved_or_uninitialized place: error suppressed \\\n                          mois={:?}\",\n-                        mois\n+                        move_out_indices\n                     );\n                     return;\n                 }\n@@ -115,8 +133,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n \n             let mut is_loop_move = false;\n-            for moi in &mois {\n-                let move_out = self.move_data.moves[*moi];\n+            for move_site in &move_site_vec {\n+                let move_out = self.move_data.moves[(*move_site).moi];\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n \n                 let move_spans = self.move_spans(moved_place, move_out.source);\n@@ -131,9 +149,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if span == move_span {\n                     err.span_label(\n                         span,\n-                        format!(\"value moved{} here in previous iteration of loop\", move_msg),\n+                        format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                     is_loop_move = true;\n+                } else if move_site.traversed_back_edge {\n+                    err.span_label(\n+                        move_span,\n+                        format!(\n+                            \"value moved{} here, in previous iteration of loop\",\n+                            move_msg\n+                        ),\n+                    );\n                 } else {\n                     err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n                     move_spans.var_span_label(&mut err, \"variable moved due to use in closure\");\n@@ -171,7 +197,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 if needs_note {\n-                    let mpi = self.move_data.moves[mois[0]].path;\n+                    let mpi = self.move_data.moves[move_out_indices[0]].path;\n                     let place = &self.move_data.move_paths[mpi].place;\n \n                     if let Some(ty) = self.retrieve_type_for_place(place) {\n@@ -192,8 +218,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            if let Some((_, mut old_err)) =\n-                self.move_error_reported.insert(mois, (place.clone(), err))\n+            if let Some((_, mut old_err)) = self.move_error_reported\n+                .insert(move_out_indices, (place.clone(), err))\n             {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();\n@@ -733,29 +759,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveOutIndex> {\n+    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveSite> {\n         let mir = self.mir;\n \n         let mut stack = Vec::new();\n-        stack.extend(mir.predecessor_locations(context.loc));\n+        stack.extend(mir.predecessor_locations(context.loc).map(|predecessor| {\n+            let is_back_edge = context.loc.dominates(predecessor, &self.dominators);\n+            (predecessor, is_back_edge)\n+        }));\n \n         let mut visited = FxHashSet();\n         let mut result = vec![];\n \n-        'dfs: while let Some(l) = stack.pop() {\n+        'dfs: while let Some((location, is_back_edge)) = stack.pop() {\n             debug!(\n-                \"report_use_of_moved_or_uninitialized: current_location={:?}\",\n-                l\n+                \"report_use_of_moved_or_uninitialized: (current_location={:?}, back_edge={})\",\n+                location, is_back_edge\n             );\n \n-            if !visited.insert(l) {\n+            if !visited.insert(location) {\n                 continue;\n             }\n \n             // check for moves\n-            let stmt_kind = mir[l.block]\n+            let stmt_kind = mir[location.block]\n                 .statements\n-                .get(l.statement_index)\n+                .get(location.statement_index)\n                 .map(|s| &s.kind);\n             if let Some(StatementKind::StorageDead(..)) = stmt_kind {\n                 // this analysis only tries to find moves explicitly\n@@ -774,11 +803,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let move_paths = &self.move_data.move_paths;\n                 mpis.extend(move_paths[mpi].parents(move_paths));\n \n-                for moi in &self.move_data.loc_map[l] {\n+                for moi in &self.move_data.loc_map[location] {\n                     debug!(\"report_use_of_moved_or_uninitialized: moi={:?}\", moi);\n                     if mpis.contains(&self.move_data.moves[*moi].path) {\n                         debug!(\"report_use_of_moved_or_uninitialized: found\");\n-                        result.push(*moi);\n+                        result.push(MoveSite {\n+                            moi: *moi,\n+                            traversed_back_edge: is_back_edge,\n+                        });\n \n                         // Strictly speaking, we could continue our DFS here. There may be\n                         // other moves that can reach the point of error. But it is kind of\n@@ -807,7 +839,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.infcx.tcx,\n                 self.mir,\n                 self.move_data,\n-                l,\n+                location,\n                 |m| {\n                     if m == mpi {\n                         any_match = true;\n@@ -818,7 +850,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 continue 'dfs;\n             }\n \n-            stack.extend(mir.predecessor_locations(l));\n+            stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+                let back_edge = location.dominates(predecessor, &self.dominators);\n+                (predecessor, is_back_edge || back_edge)\n+            }));\n         }\n \n         result"}, {"sha": "8d1caec2d72d36392dbd129f0537ecdc55e46538", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ae6f7870ff937d69a20078bdbbc2093bde2279/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ae6f7870ff937d69a20078bdbbc2093bde2279/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=d5ae6f7870ff937d69a20078bdbbc2093bde2279", "patch": "@@ -46,9 +46,9 @@ impl<'tcx> BorrowExplanation<'tcx> {\n             },\n             BorrowExplanation::UsedLaterInLoop(is_in_closure, var_or_use_span) => {\n                 let message = if is_in_closure {\n-                    \"borrow captured here by closure in later iteration of loop\"\n+                    \"borrow captured here by closure, in later iteration of loop\"\n                 } else {\n-                    \"borrow used here in later iteration of loop\"\n+                    \"borrow used here, in later iteration of loop\"\n                 };\n                 err.span_label(var_or_use_span, message);\n             },"}]}