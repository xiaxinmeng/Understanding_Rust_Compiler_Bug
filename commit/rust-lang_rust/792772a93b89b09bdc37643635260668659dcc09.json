{"sha": "792772a93b89b09bdc37643635260668659dcc09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5Mjc3MmE5M2I4OWIwOWJkYzM3NjQzNjM1MjYwNjY4NjU5ZGNjMDk=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-05-20T22:04:00Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2018-06-24T21:15:13Z"}, "message": "Prohibit global_allocator in submodules for now\n\n- we need to figure out hygiene first\n- change the test to check that the prohibition works with a good error\n  msg\n- leaves some comments and debugging code\n- leaves some of our supposed fixes", "tree": {"sha": "d73963fc85a011566d4db2ef107b703c97050e3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d73963fc85a011566d4db2ef107b703c97050e3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/792772a93b89b09bdc37643635260668659dcc09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/792772a93b89b09bdc37643635260668659dcc09", "html_url": "https://github.com/rust-lang/rust/commit/792772a93b89b09bdc37643635260668659dcc09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/792772a93b89b09bdc37643635260668659dcc09/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "html_url": "https://github.com/rust-lang/rust/commit/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07"}], "stats": {"total": 132, "additions": 91, "deletions": 41}, "files": [{"sha": "64eea50e3e07e54bc04d2a2e9b54ea76b9341d27", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792772a93b89b09bdc37643635260668659dcc09/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/792772a93b89b09bdc37643635260668659dcc09/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=792772a93b89b09bdc37643635260668659dcc09", "patch": "@@ -2035,6 +2035,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"rustc_allocator\"\n version = \"0.0.0\"\n dependencies = [\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\","}, {"sha": "1cbde181cafae7e80ebab6815e6fbb2a3284b822", "filename": "src/librustc_allocator/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792772a93b89b09bdc37643635260668659dcc09/src%2Flibrustc_allocator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/792772a93b89b09bdc37643635260668659dcc09/src%2Flibrustc_allocator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2FCargo.toml?ref=792772a93b89b09bdc37643635260668659dcc09", "patch": "@@ -14,3 +14,4 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+log = \"0.4\""}, {"sha": "5c9bf99d15cff4a5d1ad1cfcf32f5e10fb3016b7", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 79, "deletions": 40, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/792772a93b89b09bdc37643635260668659dcc09/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792772a93b89b09bdc37643635260668659dcc09/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=792772a93b89b09bdc37643635260668659dcc09", "patch": "@@ -8,27 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unused_imports, unused_variables, dead_code)]\n-\n use rustc::middle::allocator::AllocatorKind;\n use rustc_errors;\n-use syntax::ast::{Attribute, Crate, LitKind, StrStyle};\n-use syntax::ast::{Arg, FnHeader, Generics, Mac, Mutability, Ty, Unsafety};\n-use syntax::ast::{self, Expr, Ident, Item, ItemKind, TyKind, VisibilityKind};\n-use syntax::attr;\n-use syntax::codemap::respan;\n-use syntax::codemap::{ExpnInfo, MacroAttribute};\n-use syntax::ext::base::ExtCtxt;\n-use syntax::ext::base::Resolver;\n-use syntax::ext::build::AstBuilder;\n-use syntax::ext::expand::ExpansionConfig;\n-use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n-use syntax::fold::{self, Folder};\n-use syntax::parse::ParseSess;\n-use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n-use syntax::util::small_vector::SmallVector;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax::{\n+    ast::{\n+        self, Arg, Attribute, Crate, Expr, FnHeader, Generics, Ident, Item, ItemKind,\n+        LitKind, Mod, Mutability, StrStyle, Ty, TyKind, Unsafety, VisibilityKind,\n+    },\n+    attr,\n+    codemap::{\n+        respan, ExpnInfo, MacroAttribute,\n+    },\n+    ext::{\n+        base::{ExtCtxt, Resolver},\n+        build::AstBuilder,\n+        expand::ExpansionConfig,\n+        hygiene::{self, Mark, SyntaxContext},\n+    },\n+    fold::{self, Folder},\n+    parse::ParseSess,\n+    ptr::P,\n+    symbol::Symbol,\n+    util::small_vector::SmallVector,\n+};\n+use syntax_pos::Span;\n \n use {AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n \n@@ -45,6 +48,7 @@ pub fn modify(\n         resolver,\n         found: false,\n         crate_name: Some(crate_name),\n+        in_submod: -1, // -1 to account for the \"root\" module\n     }.fold_crate(krate)\n }\n \n@@ -54,10 +58,16 @@ struct ExpandAllocatorDirectives<'a> {\n     sess: &'a ParseSess,\n     resolver: &'a mut Resolver,\n     crate_name: Option<String>,\n+\n+    // For now, we disallow `global_allocator` in submodules because hygiene is hard. Keep track of\n+    // whether we are in a submodule or not. If `in_submod > 0` we are in a submodule.\n+    in_submod: isize,\n }\n \n impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n     fn fold_item(&mut self, item: P<Item>) -> SmallVector<P<Item>> {\n+        info!(\"in submodule {}\", self.in_submod);\n+\n         let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n             \"global_allocator\"\n         } else {\n@@ -72,20 +82,23 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n             }\n         }\n \n+        if self.in_submod > 0 {\n+            self.handler\n+                .span_err(item.span, \"`global_allocator` cannot be used in submodules\");\n+            return SmallVector::one(item);\n+        }\n+\n         if self.found {\n-            self.handler.span_err(\n-                item.span,\n-                \"cannot define more than one \\\n-                 #[global_allocator]\",\n-            );\n+            self.handler\n+                .span_err(item.span, \"cannot define more than one #[global_allocator]\");\n             return SmallVector::one(item);\n         }\n         self.found = true;\n \n         // Create a fresh Mark for the new macro expansion we are about to do\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(ExpnInfo {\n-            call_site: item.span,\n+            call_site: item.span, // use the call site of the static\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(name)),\n             allow_internal_unstable: true,\n@@ -104,27 +117,55 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n             span,\n             kind: AllocatorKind::Global,\n             global: item.ident,\n-            core: Ident::with_empty_ctxt(Symbol::gensym(\"core\")),\n+            core: Ident::from_str(\"core\"),\n             cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n         };\n \n-        let extcore = {\n-            let extcore = f.cx.item_extern_crate(item.span, f.core);\n-            f.cx.monotonic_expander().fold_item(extcore).pop().unwrap()\n-        };\n+        // We will generate a new submodule. To `use` the static from that module, we need to get\n+        // the `super::...` path.\n+        let super_path = f.cx.path(f.span, vec![Ident::from_str(\"super\"), f.global]);\n+\n+        // Generate the items in the submodule\n+        let mut items = vec![\n+            // import `core` to use allocators\n+            f.cx.item_extern_crate(f.span, f.core),\n+            // `use` the `global_allocator` in `super`\n+            f.cx.item_use_simple(\n+                f.span,\n+                respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n+                super_path,\n+            ),\n+        ];\n+\n+        // Add the allocator methods to the submodule\n+        items.extend(\n+            ALLOCATOR_METHODS\n+                .iter()\n+                .map(|method| f.allocator_fn(method)),\n+        );\n \n-        let mut ret = SmallVector::new();\n+        // Generate the submodule itself\n+        let name = f.kind.fn_name(\"allocator_abi\");\n+        let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n+        let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n+        let module = f.cx.monotonic_expander().fold_item(module).pop().unwrap();\n+\n+        // Return the item and new submodule\n+        let mut ret = SmallVector::with_capacity(2);\n         ret.push(item);\n-        ret.push(extcore);\n-        ret.extend(ALLOCATOR_METHODS.iter().map(|method| {\n-            let method = f.allocator_fn(method);\n-            f.cx.monotonic_expander().fold_item(method).pop().unwrap()\n-        }));\n+        ret.push(module);\n+\n         return ret;\n     }\n \n-    fn fold_mac(&mut self, mac: Mac) -> Mac {\n-        fold::noop_fold_mac(mac, self)\n+    // If we enter a submodule, take note.\n+    fn fold_mod(&mut self, m: Mod) -> Mod {\n+        info!(\"enter submodule\");\n+        self.in_submod += 1;\n+        let ret = fold::noop_fold_mod(m, self);\n+        self.in_submod -= 1;\n+        info!(\"exit submodule\");\n+        ret\n     }\n }\n \n@@ -173,7 +214,6 @@ impl<'a> AllocFnFactory<'a> {\n         let method = self.cx.path(\n             self.span,\n             vec![\n-                Ident::from_str(\"self\"),\n                 self.core,\n                 Ident::from_str(\"alloc\"),\n                 Ident::from_str(\"GlobalAlloc\"),\n@@ -224,7 +264,6 @@ impl<'a> AllocFnFactory<'a> {\n                 let layout_new = self.cx.path(\n                     self.span,\n                     vec![\n-                        Ident::from_str(\"self\"),\n                         self.core,\n                         Ident::from_str(\"alloc\"),\n                         Ident::from_str(\"Layout\"),"}, {"sha": "b217d3665a24542306a6dceb838acbf80f7ab428", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/792772a93b89b09bdc37643635260668659dcc09/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792772a93b89b09bdc37643635260668659dcc09/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=792772a93b89b09bdc37643635260668659dcc09", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(rustc_private)]\n \n+#[macro_use] extern crate log;\n extern crate rustc;\n extern crate rustc_errors;\n extern crate rustc_target;"}, {"sha": "40e5940c558db3df6566f7c7bdfe51d5da87a15d", "filename": "src/test/ui/allocator-submodule.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/792772a93b89b09bdc37643635260668659dcc09/src%2Ftest%2Fui%2Fallocator-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792772a93b89b09bdc37643635260668659dcc09/src%2Ftest%2Fui%2Fallocator-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.rs?ref=792772a93b89b09bdc37643635260668659dcc09", "patch": "@@ -31,7 +31,7 @@ mod submod {\n     use super::MyAlloc;\n \n     #[global_allocator]\n-    static MY_HEAP: MyAlloc = MyAlloc;\n+    static MY_HEAP: MyAlloc = MyAlloc; //~ ERROR global_allocator\n }\n \n fn main() {}"}, {"sha": "6e7727f8889d4da07f2a19385085a205574fffb6", "filename": "src/test/ui/allocator-submodule.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792772a93b89b09bdc37643635260668659dcc09/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/792772a93b89b09bdc37643635260668659dcc09/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.stderr?ref=792772a93b89b09bdc37643635260668659dcc09", "patch": "@@ -0,0 +1,8 @@\n+error: `global_allocator` cannot be used in submodules\n+  --> $DIR/allocator-submodule.rs:34:5\n+   |\n+LL |     static MY_HEAP: MyAlloc = MyAlloc; //~ ERROR global_allocator\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}