{"sha": "3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmY2IxM2FlNDU4Y2U2ZTJlZWRkMzQ0NjFiNGU0M2M3YmUzMWI2YjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-05T18:15:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:27:52Z"}, "message": "handle projections with regions", "tree": {"sha": "c8121f901d03f27da22c893e3d6ef9fc154a54b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8121f901d03f27da22c893e3d6ef9fc154a54b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "html_url": "https://github.com/rust-lang/rust/commit/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5842afe1e10023d84b7c1d44155c356f8ae4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5842afe1e10023d84b7c1d44155c356f8ae4e0", "html_url": "https://github.com/rust-lang/rust/commit/3a5842afe1e10023d84b7c1d44155c356f8ae4e0"}], "stats": {"total": 1860, "additions": 1758, "deletions": 102}, "files": [{"sha": "f03e8bd7ac152593805c93f18dcac49dee93883f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 187, "deletions": 92, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n                  Location, Mir};\n use rustc::traits::ObligationCause;\n-use rustc::ty::{self, RegionVid, TypeFoldable};\n+use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt;\n use std::rc::Rc;\n@@ -478,7 +478,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n     ) -> bool {\n         let tcx = infcx.tcx;\n-        let gcx = tcx.global_tcx();\n \n         let TypeTest {\n             generic_kind,\n@@ -488,80 +487,158 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             test: _,\n         } = type_test;\n \n-        // TODO. For now, just fail to promote anything with a\n-        // region. This is obviously too strict: we will for example\n-        // fail to promote `<T as Foo<'static>>::Bar` to our\n-        // caller. But it is always sound not to promote, that just\n-        // means more errors, and ignoring regions is a convenient\n-        // starting point. This is because we would want to promote to\n-        // a type that references the region-vids of the closure, for\n-        // which we have no global representation just now.\n         let generic_ty = generic_kind.to_ty(tcx);\n-        if generic_ty.has_free_regions() {\n-            return false;\n-        }\n-        let generic_ty = gcx.lift(&generic_ty).unwrap();\n+        let subject = match self.try_promote_type_test_subject(infcx, generic_ty) {\n+            Some(s) => s,\n+            None => return false,\n+        };\n \n         // Find some bounding subject-region R+ that is a super-region\n         // of the existing subject-region R. This should be a non-local, universal\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n-        let lower_bound_plus = self.promoted_type_test_bound(*lower_bound);\n+        let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n         assert!(!self.universal_regions\n             .is_local_free_region(lower_bound_plus));\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n-            subject: ClosureOutlivesSubject::Ty(generic_ty),\n+            subject,\n             outlived_free_region: lower_bound_plus,\n             blame_span: *span,\n         });\n         true\n     }\n \n-    /// Here, `lower_bound` (henceforth, `'r`) represents the bound from\n-    /// some type-test `T: 'r`. We are a closure and have found that\n-    /// `T: 'r` is not locally satisfiable, so we want to propagate\n-    /// this constraint to our creator. It is sound for us to do so\n-    /// with some `'r+` known to our creator, where `'r+: 'r`.\n+    /// When we promote a type test `T: 'r`, we have to convert the\n+    /// type `T` into something we can store in a query result (so\n+    /// something allocated for `'gcx`). This is problematic if `ty`\n+    /// contains regions. During the course of NLL region checking, we\n+    /// will have replaced all of those regions with fresh inference\n+    /// variables. To create a test subject, we want to replace those\n+    /// inference variables with some region from the closure\n+    /// signature -- this is not always possible, so this is a\n+    /// fallible process. Presuming we do find a suitable region, we\n+    /// will represent it with a `ReClosureBound`, which is a\n+    /// `RegionKind` variant that can be allocated in the gcx.\n+    fn try_promote_type_test_subject<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<ClosureOutlivesSubject<'gcx>> {\n+        let tcx = infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+\n+        debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n+\n+        let ty = tcx.fold_regions(&ty, &mut false, |r, _depth| {\n+            let region_vid = self.to_region_vid(r);\n+\n+            // The challenge if this. We have some region variable `r`\n+            // whose value is a set of CFG points and universal\n+            // regions. We want to find if that set is *equivalent* to\n+            // any of the named regions found in the closure.\n+            //\n+            // To do so, we compute the\n+            // `non_local_universal_upper_bound`. This will be a\n+            // non-local, universal region that is greater than `r`.\n+            // However, it might not be *contained* within `r`, so\n+            // then we further check whether this bound is contained\n+            // in `r`. If so, we can say that `r` is equivalent to the\n+            // bound.\n+            //\n+            // Let's work through a few examples. For these, imagine\n+            // that we have 3 non-local regions (I'll denote them as\n+            // `'static`, `'a`, and `'b`, though of course in the code\n+            // they would be represented with indices) where:\n+            //\n+            // - `'static: 'a`\n+            // - `'static: 'b`\n+            //\n+            // First, let's assume that `r` is some existential\n+            // variable with an inferred value `{'a, 'static}` (plus\n+            // some CFG nodes). In this case, the non-local upper\n+            // bound is `'static`, since that outlives `'a`. `'static`\n+            // is also a member of `r` and hence we consider `r`\n+            // equivalent to `'static` (and replace it with\n+            // `'static`).\n+            //\n+            // Now let's consider the inferred value `{'a, 'b}`. This\n+            // means `r` is effectively `'a | 'b`. I'm not sure if\n+            // this can come about, actually, but assuming it did, we\n+            // would get a non-local upper bound of `'static`. Since\n+            // `'static` is not contained in `r`, we would fail to\n+            // find an equivalent.\n+            let upper_bound = self.non_local_universal_upper_bound(region_vid);\n+            if inferred_values.contains(region_vid, upper_bound) {\n+                tcx.mk_region(ty::ReClosureBound(upper_bound))\n+            } else {\n+                // In the case of a failure, use a `ReVar`\n+                // result. This will cause the `lift` later on to\n+                // fail.\n+                r\n+            }\n+        });\n+        debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n+\n+        // `lift` will only fail if we failed to promote some region.\n+        let ty = gcx.lift(&ty)?;\n+\n+        Some(ClosureOutlivesSubject::Ty(ty))\n+    }\n+\n+    /// Given some universal or existential region `r`, finds a\n+    /// non-local, universal region `r+` that outlives `r` at entry to (and\n+    /// exit from) the closure. In the worst case, this will be\n+    /// `'static`.\n     ///\n-    /// The tricky bit here: this region `'r` may contain (a) any\n-    /// number of points in the CFG and (b) any number of `end('x)`\n-    /// elements of universally quantified regions. To communicate with\n-    /// our creator, however, we have to pick exactly one universally\n-    /// quantified region -- in other words, exactly one `end('x)`\n-    /// element -- that they understand and which will be `'r+`.\n+    /// This is used for two purposes. First, if we are propagated\n+    /// some requirement `T: r`, we can use this method to enlarge `r`\n+    /// to something we can encode for our creator (which only knows\n+    /// about non-local, universal regions). It is also used when\n+    /// encoding `T` as part of `try_promote_type_test_subject` (see\n+    /// that fn for details).\n     ///\n-    /// We do this as follows:\n+    /// Since `r` is (potentially) an existential region, it has some\n+    /// value which may include (a) any number of points in the CFG\n+    /// and (b) any number of `end('x)` elements of universally\n+    /// quantified regions. To convert this into a single universal\n+    /// region we do as follows:\n     ///\n     /// - Ignore the CFG points in `'r`. All universally quantified regions\n     ///   include the CFG anyhow.\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n     /// - Finally, we take the non-local upper bound of `'y`.\n-    fn promoted_type_test_bound(&self, lower_bound: RegionVid) -> RegionVid {\n+    ///   - This uses `UniversalRegions::non_local_upper_bound`, which\n+    ///     is similar to this method but only works on universal\n+    ///     regions).\n+    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n \n         debug!(\n-            \"promoted_type_test_bound(lower_bound={:?}={})\",\n-            lower_bound,\n-            inferred_values.region_value_str(lower_bound)\n+            \"non_local_universal_upper_bound(r={:?}={})\",\n+            r,\n+            inferred_values.region_value_str(r)\n         );\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n         let mut lub = self.universal_regions.fr_fn_body;\n-        for ur in inferred_values.universal_regions_outlived_by(lower_bound) {\n+        for ur in inferred_values.universal_regions_outlived_by(r) {\n             lub = self.universal_regions.postdom_upper_bound(lub, ur);\n         }\n \n-        debug!(\"promoted_type_test_bound: lub={:?}\", lub);\n+        debug!(\"non_local_universal_upper_bound: lub={:?}\", lub);\n \n         // Grow further to get smallest universal region known to\n         // creator.\n         let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n \n         debug!(\n-            \"promoted_type_test_bound: non_local_lub={:?}\",\n+            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n             non_local_lub\n         );\n \n@@ -680,32 +757,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Go through each of the universal regions `fr` and check that\n         // they did not grow too large, accumulating any requirements\n         // for our caller into the `outlives_requirements` vector.\n-        let mut outlives_requirements = vec![];\n         for (fr, _) in universal_definitions {\n-            self.check_universal_region(infcx, fr, &mut outlives_requirements);\n-\n-            // Propagate unsatisfied requirements if possible, else\n-            // report them.\n-            if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n-                propagated_outlives_requirements.extend(outlives_requirements.drain(..));\n-            } else {\n-                for outlives_requirement in outlives_requirements.drain(..) {\n-                    let fr = match outlives_requirement.subject {\n-                        ClosureOutlivesSubject::Region(fr) => fr,\n-                        _ => span_bug!(\n-                            outlives_requirement.blame_span,\n-                            \"check_universal_region() produced requirement w/ non-region subject\"\n-                        ),\n-                    };\n-\n-                    self.report_error(\n-                        infcx,\n-                        fr,\n-                        outlives_requirement.outlived_free_region,\n-                        outlives_requirement.blame_span,\n-                    );\n-                }\n-            }\n+            self.check_universal_region(infcx, fr, &mut propagated_outlives_requirements);\n         }\n     }\n \n@@ -721,7 +774,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         longer_fr: RegionVid,\n-        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n \n@@ -743,33 +796,39 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let blame_span = self.blame_span(longer_fr, shorter_fr);\n \n-            // Shrink `fr` until we find a non-local region (if we do).\n-            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-            if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n-                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n-\n-                // Grow `shorter_fr` until we find a non-local\n-                // regon. (We always will.)  We'll call that\n-                // `shorter_fr+` -- it's ever so slightly larger than\n-                // `fr`.\n-                let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n-                debug!(\n-                    \"check_universal_region: shorter_fr_plus={:?}\",\n-                    shorter_fr_plus\n-                );\n+            if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n+                // Shrink `fr` until we find a non-local region (if we do).\n+                // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n+                if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                    debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                    // Grow `shorter_fr` until we find a non-local\n+                    // regon. (We always will.)  We'll call that\n+                    // `shorter_fr+` -- it's ever so slightly larger than\n+                    // `fr`.\n+                    let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                    debug!(\n+                        \"check_universal_region: shorter_fr_plus={:?}\",\n+                        shorter_fr_plus\n+                    );\n \n-                // Push the constraint `fr-: shorter_fr+`\n-                propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n-                    subject: ClosureOutlivesSubject::Region(fr_minus),\n-                    outlived_free_region: shorter_fr_plus,\n-                    blame_span: blame_span,\n-                });\n-                return;\n+                    // Push the constraint `fr-: shorter_fr+`\n+                    propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+                        subject: ClosureOutlivesSubject::Region(fr_minus),\n+                        outlived_free_region: shorter_fr_plus,\n+                        blame_span: blame_span,\n+                    });\n+                    return;\n+                }\n             }\n \n-            // If we could not shrink `fr` to something smaller that\n-            // the external users care about, then we can't pass the\n-            // buck; just report an error.\n+            // If we are not in a context where we can propagate\n+            // errors, or we could not shrink `fr` to something\n+            // smaller, then just report an error.\n+            //\n+            // Note: in this case, we use the unapproximated regions\n+            // to report the error. This gives better error messages\n+            // in some cases.\n             self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n         }\n     }\n@@ -878,18 +937,27 @@ impl fmt::Debug for Constraint {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt<'gcx> {\n-    fn apply_requirements<'tcx>(\n+pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n+    fn apply_requirements(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         body_id: ast::NodeId,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n     );\n+\n+    fn subst_closure_mapping<T>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n }\n \n-impl<'gcx> ClosureRegionRequirementsExt<'gcx> for ClosureRegionRequirements<'gcx> {\n+impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequirements<'gcx> {\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n@@ -902,7 +970,7 @@ impl<'gcx> ClosureRegionRequirementsExt<'gcx> for ClosureRegionRequirements<'gcx\n     /// a vector. Then we can just index into that vector to extract\n     /// out the corresponding region from T and apply the\n     /// requirements.\n-    fn apply_requirements<'tcx>(\n+    fn apply_requirements(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         body_id: ast::NodeId,\n@@ -927,7 +995,7 @@ impl<'gcx> ClosureRegionRequirementsExt<'gcx> for ClosureRegionRequirements<'gcx\n         // into a vector.  These are the regions that we will be\n         // relating to one another.\n         let closure_mapping =\n-            UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+            &UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n         debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n \n         // Create the predicates.\n@@ -943,15 +1011,24 @@ impl<'gcx> ClosureRegionRequirementsExt<'gcx> for ClosureRegionRequirements<'gcx\n                     debug!(\n                         \"apply_requirements: region={:?} \\\n                          outlived_region={:?} \\\n-                         outlives_requirements={:?}\",\n+                         outlives_requirement={:?}\",\n                         region,\n                         outlived_region,\n-                        outlives_requirement\n+                        outlives_requirement,\n                     );\n                     infcx.sub_regions(origin, outlived_region, region);\n                 }\n \n                 ClosureOutlivesSubject::Ty(ty) => {\n+                    let ty = self.subst_closure_mapping(infcx, closure_mapping, &ty);\n+                    debug!(\n+                        \"apply_requirements: ty={:?} \\\n+                         outlived_region={:?} \\\n+                         outlives_requirement={:?}\",\n+                        ty,\n+                        outlived_region,\n+                        outlives_requirement,\n+                    );\n                     infcx.register_region_obligation(\n                         body_id,\n                         RegionObligation {\n@@ -964,4 +1041,22 @@ impl<'gcx> ClosureRegionRequirementsExt<'gcx> for ClosureRegionRequirements<'gcx\n             }\n         }\n     }\n+\n+    fn subst_closure_mapping<T>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>\n+    {\n+        infcx.tcx.fold_regions(value, &mut false, |r, _depth| {\n+            if let ty::ReClosureBound(vid) = r {\n+                closure_mapping[*vid]\n+            } else {\n+                bug!(\"subst_closure_mapping: encountered non-closure bound free region {:?}\", r)\n+            }\n+        })\n+    }\n }"}, {"sha": "5f4a72542b20b06a752a693c8860a7cf6a84d55e", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -247,17 +247,24 @@ impl<'tcx> UniversalRegions<'tcx> {\n         (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n     }\n \n-    /// True if `r` is classied as a global region.\n+    /// True if `r` is classified as a global region.\n     pub fn is_global_free_region(&self, r: RegionVid) -> bool {\n         self.region_classification(r) == Some(RegionClassification::Global)\n     }\n \n-    /// True if `r` is classied as an external region.\n+    /// True if `r` is classified as an external region.\n     pub fn is_extern_free_region(&self, r: RegionVid) -> bool {\n         self.region_classification(r) == Some(RegionClassification::External)\n     }\n \n-    /// True if `r` is classied as an local region.\n+    /// True if `r` is a free region that is classified as global or\n+    /// extern.  This is an important category, because these regions\n+    /// can be referenced in `ClosureRegionRequirements`.\n+    pub fn is_non_local_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Local)\n+    }\n+\n+    /// True if `r` is classified as an local region.\n     pub fn is_local_free_region(&self, r: RegionVid) -> bool {\n         self.region_classification(r) == Some(RegionClassification::Local)\n     }\n@@ -324,6 +331,10 @@ impl<'tcx> UniversalRegions<'tcx> {\n         relation: &TransitiveRelation<RegionVid>,\n         fr0: RegionVid,\n     ) -> Option<RegionVid> {\n+        // This method assumes that `fr0` is one of the universally\n+        // quantified region variables.\n+        assert!(self.is_universal_region(fr0));\n+\n         let mut external_parents = vec![];\n         let mut queue = vec![&fr0];\n "}, {"sha": "b91c01fb671398e0e9074057294f349669c22c57", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+// Tests closures that propagate an outlives relationship to their\n+// creator where the subject is a projection with no regions (`<T as\n+// Iterator>::Item`, to be exact).\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+trait Anything { }\n+\n+impl<T> Anything for T { }\n+\n+fn with_signature<'a, T, F>(x: Box<T>, op: F) -> Box<dyn Anything + 'a>\n+    where F: FnOnce(Box<T>) -> Box<dyn Anything + 'a>\n+{\n+    op(x)\n+}\n+\n+#[rustc_regions]\n+fn no_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: Iterator,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+#[rustc_regions]\n+fn correct_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: 'a + Iterator,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+}\n+\n+#[rustc_regions]\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+#[rustc_regions]\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+    'b: 'a,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+}\n+\n+fn main() {}"}, {"sha": "1d124f2d49a0b1285f4e5c543cb611fadbb96758", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,157 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-no-regions-closure.rs:36:31\n+   |\n+36 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                               ^^^^^^^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-no-regions-closure.rs:54:31\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                               ^^^^^^^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:36:23\n+   |\n+36 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:15 ~ projection_no_regions_closure[317d]::no_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where <T as std::iter::Iterator>::Item: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:46:23\n+   |\n+46 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ projection_no_regions_closure[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where <T as std::iter::Iterator>::Item: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:54:23\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:22 ~ projection_no_regions_closure[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as std::iter::Iterator>::Item: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:65:23\n+   |\n+65 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:26 ~ projection_no_regions_closure[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as std::iter::Iterator>::Item: '_#3r\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1697 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#4r, point: bb0[5], span: $DIR/projection-no-regions-closure.rs:36:23: 36:49, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n+  --> $DIR/projection-no-regions-closure.rs:36:23\n+   |\n+36 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:32:1\n+   |\n+32 | / fn no_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+33 | | where\n+34 | |     T: Iterator,\n+35 | | {\n+...  |\n+38 | |     //~| ERROR failed type test\n+39 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ projection_no_regions_closure[317d]::no_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:42:1\n+   |\n+42 | / fn correct_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+43 | | where\n+44 | |     T: 'a + Iterator,\n+45 | | {\n+46 | |     with_signature(x, |mut y| Box::new(y.next()))\n+47 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:7 ~ projection_no_regions_closure[317d]::correct_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1697 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#6r, point: bb0[5], span: $DIR/projection-no-regions-closure.rs:54:23: 54:49, test: IsOutlivedByAnyRegionIn(['_#2r, '_#3r]) }\n+  --> $DIR/projection-no-regions-closure.rs:54:23\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:50:1\n+   |\n+50 | / fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+51 | | where\n+52 | |     T: 'b + Iterator,\n+53 | | {\n+...  |\n+56 | |     //~| ERROR failed type test\n+57 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_no_regions_closure[317d]::wrong_region[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:60:1\n+   |\n+60 | / fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+61 | | where\n+62 | |     T: 'b + Iterator,\n+63 | |     'b: 'a,\n+64 | | {\n+65 | |     with_signature(x, |mut y| Box::new(y.next()))\n+66 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_no_regions_closure[317d]::outlives_region[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b7822eb259b6db17e31c1cb80f8f35a1c7418c4b", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]", "previous_filename": "src/test/ui/nll/ty-outlives/projection-fn.rs"}, {"sha": "5c3bd04f3b1e640c040aa359ff74d1acfb0cb4e8", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.stderr", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -1,23 +1,23 @@\n warning: not reporting region error due to -Znll\n-  --> $DIR/projection-fn.rs:24:5\n+  --> $DIR/projection-no-regions-fn.rs:24:5\n    |\n 24 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n \n warning: not reporting region error due to -Znll\n-  --> $DIR/projection-fn.rs:40:5\n+  --> $DIR/projection-no-regions-fn.rs:40:5\n    |\n 40 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1695 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#4r, point: bb5[0], span: $DIR/projection-fn.rs:24:5: 24:23, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n-  --> $DIR/projection-fn.rs:24:5\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1697 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#4r, point: bb5[0], span: $DIR/projection-no-regions-fn.rs:24:5: 24:23, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n+  --> $DIR/projection-no-regions-fn.rs:24:5\n    |\n 24 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1695 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#5r, point: bb5[0], span: $DIR/projection-fn.rs:40:5: 40:23, test: IsOutlivedByAnyRegionIn(['_#2r, '_#3r]) }\n-  --> $DIR/projection-fn.rs:40:5\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1697 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#5r, point: bb5[0], span: $DIR/projection-no-regions-fn.rs:40:5: 40:23, test: IsOutlivedByAnyRegionIn(['_#2r, '_#3r]) }\n+  --> $DIR/projection-no-regions-fn.rs:40:5\n    |\n 40 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/nll/ty-outlives/projection-fn.stderr"}, {"sha": "cd9b1c2a8cedd5529c2bff0e5ab5e5b69128e7c4", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'b>>::AssocType` to\n+// outlive `'a` and there are no bounds in the trait definition of\n+// `Anything`. This means that the constraint can only be satisfied in two\n+// ways:\n+//\n+// - by ensuring that `T: 'a` and `'b: 'a`, or\n+// - by something in the where clauses.\n+//\n+// As of this writing, the where clause option does not work because\n+// of limitations in our region inferencing system (this is true both\n+// with and without NLL). See `projection_outlives`.\n+//\n+// Ensuring that both `T: 'a` and `'b: 'a` holds does work (`elements_outlive`).\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a> {\n+    type AssocType;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T: 'a,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "d187a094ec6294e4089d90ebb274f943620e3245", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,194 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-closure.rs:56:39\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-closure.rs:68:39\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-closure.rs:90:39\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:56:29\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ projection_one_region_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+   = note: where '_#1r: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:68:29\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:90:29\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+   --> $DIR/projection-one-region-closure.rs:103:29\n+    |\n+103 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:31 ~ projection_one_region_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+            ]\n+    = note: number of external vids: 4\n+    = note: where T: '_#3r\n+    = note: where '_#2r: '_#3r\n+\n+error: failed type test: TypeTest { generic_kind: T/#1, lower_bound: '_#5r, point: bb0[5], span: $DIR/projection-one-region-closure.rs:56:29: 56:55, test: IsOutlivedByAnyRegionIn(['_#3r]) }\n+  --> $DIR/projection-one-region-closure.rs:56:29\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+  --> $DIR/projection-one-region-closure.rs:56:20\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-closure.rs:52:1\n+   |\n+52 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+53 | | where\n+54 | |     T: Anything<'b>,\n+55 | | {\n+...  |\n+59 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+60 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: T/#2, lower_bound: '_#6r, point: bb0[5], span: $DIR/projection-one-region-closure.rs:68:29: 68:55, test: IsOutlivedByAnyRegionIn(['_#3r]) }\n+  --> $DIR/projection-one-region-closure.rs:68:29\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-closure.rs:68:20\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-closure.rs:63:1\n+   |\n+63 | / fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+64 | | where\n+65 | |     T: Anything<'b>,\n+66 | |     'a: 'a,\n+...  |\n+71 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+72 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_one_region_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: T/#2, lower_bound: '_#6r, point: bb0[5], span: $DIR/projection-one-region-closure.rs:90:29: 90:55, test: IsOutlivedByAnyRegionIn(['_#3r]) }\n+  --> $DIR/projection-one-region-closure.rs:90:29\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-closure.rs:90:20\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-closure.rs:75:1\n+   |\n+75 | / fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+76 | | where\n+77 | |     T: Anything<'b>,\n+78 | |     T::AssocType: 'a,\n+...  |\n+93 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+94 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_one_region_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+   --> $DIR/projection-one-region-closure.rs:97:1\n+    |\n+97  | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+98  | | where\n+99  | |     T: Anything<'b>,\n+100 | |     T: 'a,\n+...   |\n+103 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+104 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:11 ~ projection_one_region_closure[317d]::elements_outlive[0]) with substs [\n+                '_#1r,\n+                '_#2r,\n+                T\n+            ]\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "e179927dfb0b9f05b5033d5142e29d73de54d36e", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'b>>::AssocType` to\n+// outlive `'a` and there is a unique bound in the trait definition of\n+// `Anything` -- i.e., we know that `AssocType` outlives `'b`. In this\n+// case, the best way to satisfy the trait bound is to show that `'b:\n+// 'a`, which can be done in various ways.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a> {\n+    type AssocType: 'a;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'a>,\n+{\n+    // Note that in this case the closure still propagates an external\n+    // requirement between two variables in its signature, but the\n+    // creator maps both those two region variables to `'a` on its\n+    // side.\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "1088ae846fee54073aa815db2f3387dd75fb75ae", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,204 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:48:39\n+   |\n+48 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:39\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:39\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:48:29\n+   |\n+48 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:29\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:29\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:91:29\n+   |\n+91 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+   --> $DIR/projection-one-region-trait-bound-closure.rs:103:29\n+    |\n+103 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where '_#1r: '_#2r\n+\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:48:20\n+   |\n+48 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:44:1\n+   |\n+44 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+45 | | where\n+46 | |     T: Anything<'b>,\n+47 | | {\n+...  |\n+50 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+51 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:20\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:54:1\n+   |\n+54 | / fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+55 | | where\n+56 | |     T: Anything<'b>,\n+57 | |     'a: 'a,\n+...  |\n+61 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+62 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:20\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:65:1\n+   |\n+65 | / fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+66 | | where\n+67 | |     T: Anything<'b>,\n+68 | |     T::AssocType: 'a,\n+...  |\n+82 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+83 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_one_region_trait_bound_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:86:1\n+   |\n+86 | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+87 | | where\n+88 | |     T: Anything<'b>,\n+89 | |     'b: 'a,\n+90 | | {\n+91 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+92 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:11 ~ projection_one_region_trait_bound_closure[317d]::elements_outlive[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+   --> $DIR/projection-one-region-trait-bound-closure.rs:95:1\n+    |\n+95  | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+96  | | where\n+97  | |     T: Anything<'a>,\n+98  | | {\n+...   |\n+103 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+104 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:12 ~ projection_one_region_trait_bound_closure[317d]::one_region[0]) with substs [\n+                '_#1r,\n+                T\n+            ]\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "67e28af11469d1ad036d81339a7e8b64a3d1747f", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'b>>::AssocType` to\n+// outlive `'static`. In this case, we don't get any errors, and in fact\n+// we don't even propagate constraints from the closures to the callers.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// must-compile-successfully\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a> {\n+    type AssocType: 'static;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'a>,\n+{\n+    // Note that in this case the closure still propagates an external\n+    // requirement between two variables in its signature, but the\n+    // creator maps both those two region variables to `'a` on its\n+    // side.\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "986676d28d9209108d17d5ce412bb45750339f0e", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.stderr", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,155 @@\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:47:29\n+   |\n+47 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:56:29\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:75:29\n+   |\n+75 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_static_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:84:29\n+   |\n+84 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_static_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:96:29\n+   |\n+96 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_static_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:43:1\n+   |\n+43 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+44 | | where\n+45 | |     T: Anything<'b>,\n+46 | | {\n+47 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+48 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:51:1\n+   |\n+51 | / fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+52 | | where\n+53 | |     T: Anything<'b>,\n+54 | |     'a: 'a,\n+55 | | {\n+56 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+57 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:60:1\n+   |\n+60 | / fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+61 | | where\n+62 | |     T: Anything<'b>,\n+63 | |     T::AssocType: 'a,\n+...  |\n+75 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+76 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_one_region_trait_bound_static_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:79:1\n+   |\n+79 | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+80 | | where\n+81 | |     T: Anything<'b>,\n+82 | |     'b: 'a,\n+83 | | {\n+84 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+85 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:11 ~ projection_one_region_trait_bound_static_closure[317d]::elements_outlive[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:88:1\n+   |\n+88 | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+89 | | where\n+90 | |     T: Anything<'a>,\n+91 | | {\n+...  |\n+96 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+97 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:12 ~ projection_one_region_trait_bound_static_closure[317d]::one_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+"}, {"sha": "f8f3065fff431d0c3f7f699efa7c1679cd58583e", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'a, 'b>>::AssocType`\n+// to outlive `'a` and there are two bounds in the trait definition of\n+// `Anything` -- i.e., we know that `AssocType` outlives `'a` and\n+// `'b`. In this case, it's not clear what is the best way to satisfy\n+// the trait bound, and hence we propagate it to the caller as a type\n+// test.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a, 'b> {\n+    type AssocType: 'a + 'b;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, 'c, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive1<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive2<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    'c: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+}\n+\n+#[rustc_regions]\n+fn two_regions_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'b>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'a, 'a>,\n+{\n+    // Note that in this case the closure still propagates an external\n+    // requirement between two variables in its signature, but the\n+    // creator maps both those two region variables to `'a` on its\n+    // side.\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "026502141292517a8d8a9cd03117261a178f33a0", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=3fcb13ae458ce6e2eedd34461b4e43c7be31b6b1", "patch": "@@ -0,0 +1,326 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:49:39\n+   |\n+49 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:39\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:39\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:39\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                                       ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:49:29\n+   |\n+49 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:22 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:32 ~ projection_two_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:92:29\n+   |\n+92 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:37 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive1[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:101:29\n+    |\n+101 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:42 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive2[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                '_#3r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+            ]\n+    = note: number of external vids: 5\n+    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:29\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:46 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:120:29\n+    |\n+120 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:50 ~ projection_two_region_trait_bound_closure[317d]::two_regions_outlive[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+            ]\n+    = note: number of external vids: 4\n+    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:132:29\n+    |\n+132 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:53 ~ projection_two_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T, '_#5r, '_#6r]), item_def_id: DefId(0/0:5 ~ projection_two_region_trait_bound_closure[317d]::Anything[0]::AssocType[0]) }, lower_bound: '_#7r, point: bb0[5], span: $DIR/projection-two-region-trait-bound-closure.rs:49:29: 49:55, test: Any([IsOutlivedByAnyRegionIn(['_#6r, '_#5r]), All([IsOutlivedByAnyRegionIn(['_#4r]), IsOutlivedByAllRegionsIn(['_#5r, '_#6r])])]) }\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:49:29\n+   |\n+49 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:45:1\n+   |\n+45 | / fn no_relationships_late<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+46 | | where\n+47 | |     T: Anything<'b, 'c>,\n+48 | | {\n+...  |\n+51 | |     //~| ERROR failed type test\n+52 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T, '_#6r, '_#7r]), item_def_id: DefId(0/0:5 ~ projection_two_region_trait_bound_closure[317d]::Anything[0]::AssocType[0]) }, lower_bound: '_#8r, point: bb0[5], span: $DIR/projection-two-region-trait-bound-closure.rs:60:29: 60:55, test: Any([IsOutlivedByAnyRegionIn(['_#7r, '_#6r]), All([IsOutlivedByAnyRegionIn(['_#4r]), IsOutlivedByAllRegionsIn(['_#6r, '_#7r])])]) }\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:55:1\n+   |\n+55 | / fn no_relationships_early<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+56 | | where\n+57 | |     T: Anything<'b, 'c>,\n+58 | |     'a: 'a,\n+...  |\n+62 | |     //~| ERROR failed type test\n+63 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T\n+           ]\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T, '_#6r, '_#7r]), item_def_id: DefId(0/0:5 ~ projection_two_region_trait_bound_closure[317d]::Anything[0]::AssocType[0]) }, lower_bound: '_#8r, point: bb0[5], span: $DIR/projection-two-region-trait-bound-closure.rs:81:29: 81:55, test: Any([IsOutlivedByAnyRegionIn(['_#7r, '_#6r]), All([IsOutlivedByAnyRegionIn(['_#4r]), IsOutlivedByAllRegionsIn(['_#6r, '_#7r])])]) }\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:66:1\n+   |\n+66 | / fn projection_outlives<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+67 | | where\n+68 | |     T: Anything<'b, 'c>,\n+69 | |     T::AssocType: 'a,\n+...  |\n+83 | |     //~| ERROR failed type test\n+84 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_two_region_trait_bound_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:87:1\n+   |\n+87 | / fn elements_outlive1<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+88 | | where\n+89 | |     T: Anything<'b, 'c>,\n+90 | |     'b: 'a,\n+91 | | {\n+92 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+93 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:11 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive1[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T\n+           ]\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:96:1\n+    |\n+96  | / fn elements_outlive2<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+97  | | where\n+98  | |     T: Anything<'b, 'c>,\n+99  | |     'c: 'a,\n+100 | | {\n+101 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+102 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:12 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive2[0]) with substs [\n+                '_#1r,\n+                '_#2r,\n+                '_#3r,\n+                T\n+            ]\n+\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:20\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                    ^^^^\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:105:1\n+    |\n+105 | / fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+106 | | where\n+107 | |     T: Anything<'b, 'b>,\n+108 | | {\n+...   |\n+111 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+112 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]) with substs [\n+                '_#1r,\n+                T\n+            ]\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:115:1\n+    |\n+115 | / fn two_regions_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+116 | | where\n+117 | |     T: Anything<'b, 'b>,\n+118 | |     'b: 'a,\n+119 | | {\n+120 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+121 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:14 ~ projection_two_region_trait_bound_closure[317d]::two_regions_outlive[0]) with substs [\n+                '_#1r,\n+                '_#2r,\n+                T\n+            ]\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:124:1\n+    |\n+124 | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+125 | | where\n+126 | |     T: Anything<'a, 'a>,\n+127 | | {\n+...   |\n+132 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+133 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:15 ~ projection_two_region_trait_bound_closure[317d]::one_region[0]) with substs [\n+                '_#1r,\n+                T\n+            ]\n+\n+error: aborting due to 4 previous errors\n+"}]}