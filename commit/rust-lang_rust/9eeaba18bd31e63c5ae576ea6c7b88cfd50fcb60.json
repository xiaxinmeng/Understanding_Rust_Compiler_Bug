{"sha": "9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZWFiYTE4YmQzMWU2M2M1YWU1NzZlYTZjN2I4OGNmZDUwZmNiNjA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-09-18T15:37:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-09-23T11:00:25Z"}, "message": "Move NoLlvmMetadataLoader to rustc_trans_traits", "tree": {"sha": "76aead81d2b8472212f381b48572fab2d75754f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76aead81d2b8472212f381b48572fab2d75754f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "html_url": "https://github.com/rust-lang/rust/commit/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44c184382fda86692d61e4042d5ccecc83c43e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/44c184382fda86692d61e4042d5ccecc83c43e90", "html_url": "https://github.com/rust-lang/rust/commit/44c184382fda86692d61e4042d5ccecc83c43e90"}], "stats": {"total": 380, "additions": 169, "deletions": 211}, "files": [{"sha": "49db077849c20915e27c86cf9258763a9eb108a6", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -1781,10 +1781,14 @@ dependencies = [\n name = \"rustc_trans_traits\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n+ \"syntax 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "848b10d312cea476c8352d22690f3b63424fa399", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -159,10 +159,6 @@ fn main() {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n \n-        if env::var(\"RUSTC_LLVM_ENABLED\") == Ok(\"0\".to_string()) && stage != \"0\" {\n-            cmd.arg(\"-Zno-trans\");\n-        }\n-\n         // Set various options from config.toml to configure how we're building\n         // code.\n         if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {"}, {"sha": "8307a536c339d41999518a4c3a0597b1a8456c92", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -531,6 +531,9 @@ impl<'a> Builder<'a> {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n+        //\n+        // If LLVM support is disabled we need to use the snapshot compiler to compile\n+        // build scripts, as the new compiler doesnt support executables.\n         if mode == Mode::Libstd || !self.build.config.llvm_enabled {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());"}, {"sha": "aa0000653cc87d9ab20afafea4aa1a5dcc3400fd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![cfg_attr(not(feature=\"llvm\"), allow(dead_code))]\n-\n use rustc::dep_graph::DepGraph;\n use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n@@ -96,10 +94,6 @@ pub fn compile_input(sess: &Session,\n     }\n \n     if cfg!(not(feature=\"llvm\")) {\n-        if !sess.opts.debugging_opts.no_trans && sess.opts.output_types.should_trans() {\n-            sess.err(\"LLVM is not supported by this rustc. Please use -Z no-trans to compile\")\n-        }\n-\n         for cty in sess.opts.crate_types.iter() {\n             match *cty {\n                 CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n@@ -269,48 +263,36 @@ pub fn compile_input(sess: &Session,\n         })??\n     };\n \n-    if cfg!(not(feature=\"llvm\")) {\n-        let (_, _) = (outputs, trans);\n-\n-        if sess.opts.crate_types.contains(&CrateType::CrateTypeRlib)\n-            || sess.opts.crate_types.contains(&CrateType::CrateTypeDylib) {\n-            return Ok(())\n-        }\n-        sess.fatal(\"LLVM is not supported by this rustc\");\n+    if sess.opts.debugging_opts.print_type_sizes {\n+        sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    #[cfg(feature=\"llvm\")]\n-    {\n-        if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.borrow().print_type_sizes();\n-        }\n-\n-        let (phase5_result, trans) = phase_5_run_llvm_passes::<DefaultTransCrate>(sess, &dep_graph, trans);\n-\n-        controller_entry_point!(after_llvm,\n-                                sess,\n-                                CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                                phase5_result);\n-        phase5_result?;\n+    let (phase5_result, trans) = phase_5_run_llvm_passes::<DefaultTransCrate>(sess, &dep_graph, trans);\n \n-        phase_6_link_output::<DefaultTransCrate>(sess, &trans, &outputs);\n+    controller_entry_point!(after_llvm,\n+                            sess,\n+                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n+                            phase5_result);\n+    phase5_result?;\n \n-        // Now that we won't touch anything in the incremental compilation directory\n-        // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+    phase_6_link_output::<DefaultTransCrate>(sess, &trans, &outputs);\n \n-        if sess.opts.debugging_opts.perf_stats {\n-            sess.print_perf_stats();\n-        }\n+    // Now that we won't touch anything in the incremental compilation directory\n+    // any more, we can finalize it (which involves renaming it)\n+    #[cfg(feature=\"llvm\")]\n+    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n \n-        controller_entry_point!(\n-            compilation_done,\n-            sess,\n-            CompileState::state_when_compilation_done(input, sess, outdir, output),\n-            Ok(())\n-        );\n+    if sess.opts.debugging_opts.perf_stats {\n+        sess.print_perf_stats();\n     }\n \n+    controller_entry_point!(\n+        compilation_done,\n+        sess,\n+        CompileState::state_when_compilation_done(input, sess, outdir, output),\n+        Ok(())\n+    );\n+\n     Ok(())\n }\n \n@@ -1171,7 +1153,6 @@ pub fn phase_5_run_llvm_passes<T: TransCrate>(sess: &Session,\n \n /// Run the linker on any artifacts that resulted from the LLVM run.\n /// This should produce either a finished executable or library.\n-#[cfg(feature=\"llvm\")]\n pub fn phase_6_link_output<T: TransCrate>(sess: &Session,\n                            trans: &<T as TransCrate>::TranslatedCrate,\n                            outputs: &OutputFilenames) {"}, {"sha": "db56ff7afc334aebf0c23d215a1b9793f3cf188c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 163, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -25,8 +25,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n \n-extern crate ar;\n-extern crate flate2;\n extern crate arena;\n extern crate getopts;\n extern crate graphviz;\n@@ -155,173 +153,17 @@ pub fn run<F>(run_compiler: F) -> isize\n }\n \n #[cfg(not(feature=\"llvm\"))]\n-pub use trans_metadata_only::MetadataOnlyTransCrate as DefaultTransCrate;\n+pub use rustc_trans_traits::MetadataOnlyTransCrate as DefaultTransCrate;\n #[cfg(feature=\"llvm\")]\n pub use rustc_trans::LlvmTransCrate as DefaultTransCrate;\n \n-mod no_llvm_metadata_loader {\n-    extern crate owning_ref;\n-\n-    use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n-    use rustc_back::target::Target;\n-    use std::io;\n-    use std::fs::File;\n-    use std::path::Path;\n-\n-    use ar::Archive;\n-    use self::owning_ref::{OwningRef, ErasedBoxRef};\n-\n-    pub struct NoLlvmMetadataLoader;\n-\n-    impl MetadataLoaderTrait for NoLlvmMetadataLoader {\n-        fn get_rlib_metadata(\n-            &self,\n-            _: &Target,\n-            filename: &Path\n-        ) -> Result<ErasedBoxRef<[u8]>, String> {\n-            let file = File::open(filename).map_err(|e| {\n-                format!(\"metadata file open err: {:?}\", e)\n-            })?;\n-            let mut archive = Archive::new(file);\n-\n-            while let Some(entry_result) = archive.next_entry() {\n-                let mut entry = entry_result.map_err(|e| {\n-                    format!(\"metadata section read err: {:?}\", e)\n-                })?;\n-                if entry.header().identifier() == \"rust.metadata.bin\" {\n-                    let mut buf = Vec::new();\n-                    io::copy(&mut entry, &mut buf).unwrap();\n-                    let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n-                    return Ok(buf.map_owner_box().erase_owner());\n-                }\n-            }\n-\n-            Err(\"Couldnt find metadata section\".to_string())\n-        }\n-\n-        fn get_dylib_metadata(&self,\n-                            _target: &Target,\n-                            _filename: &Path)\n-                            -> Result<ErasedBoxRef<[u8]>, String> {\n-            // FIXME: Support reading dylibs from llvm enabled rustc\n-            self.get_rlib_metadata(_target, _filename)\n-        }\n-    }\n-}\n-\n-mod trans_metadata_only {\n-    use std::io::prelude::*;\n-    use std::io::Cursor;\n-    use std::fs::File;\n-\n-    use ar::{Builder, Header};\n-    use flate2::Compression;\n-    use flate2::write::DeflateEncoder;\n-\n-    use syntax::symbol::Symbol;\n-    use rustc::hir::def_id::LOCAL_CRATE;\n-    use rustc::session::Session;\n-    use rustc::session::config::{OutputFilenames, CrateType};\n-    use rustc::ty::{TyCtxt, CrateAnalysis};\n-    use rustc::ty::maps::Providers;\n-    use rustc::middle::cstore::{MetadataLoader, EncodedMetadata};\n-    use rustc::dep_graph::DepGraph;\n-    use rustc_incremental::IncrementalHashesMap;\n-    use rustc_trans_utils::find_exported_symbols;\n-    use rustc_trans_utils::link::{out_filename, build_link_meta};\n-    use rustc_trans_traits::TransCrate;\n-\n-    #[allow(dead_code)]\n-    pub struct MetadataOnlyTransCrate;\n-    pub struct OngoingCrateTranslation {\n-        metadata: EncodedMetadata,\n-        metadata_version: Vec<u8>,\n-        crate_name: Symbol,\n-    }\n-    pub struct TranslatedCrate(OngoingCrateTranslation);\n-\n-    impl MetadataOnlyTransCrate {\n-        #[allow(dead_code)]\n-        pub fn new(/*_sess: &Session*/) -> Self {\n-            MetadataOnlyTransCrate\n-        }\n-    }\n-\n-    impl TransCrate for MetadataOnlyTransCrate {\n-        type MetadataLoader = ::no_llvm_metadata_loader::NoLlvmMetadataLoader;\n-        type OngoingCrateTranslation = OngoingCrateTranslation;\n-        type TranslatedCrate = TranslatedCrate;\n-\n-        fn metadata_loader() -> Box<MetadataLoader> {\n-            box ::no_llvm_metadata_loader::NoLlvmMetadataLoader\n-        }\n-\n-        fn provide(_providers: &mut Providers) {}\n-\n-        fn trans_crate<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-            analysis: CrateAnalysis,\n-            incr_hashes_map: IncrementalHashesMap,\n-            _output_filenames: &OutputFilenames\n-        ) -> Self::OngoingCrateTranslation {\n-            let link_meta = build_link_meta(&incr_hashes_map);\n-            let exported_symbols = find_exported_symbols(tcx, &analysis.reachable);\n-            let (metadata, _hashes) = tcx.encode_metadata(&link_meta, &exported_symbols);\n-\n-            OngoingCrateTranslation {\n-                metadata: metadata,\n-                metadata_version: tcx.metadata_encoding_version().to_vec(),\n-                crate_name: tcx.crate_name(LOCAL_CRATE),\n-            }\n-        }\n-\n-        fn join_trans(\n-            trans: Self::OngoingCrateTranslation,\n-            _sess: &Session,\n-            _dep_graph: &DepGraph,\n-        ) -> Self::TranslatedCrate {\n-            TranslatedCrate(trans)\n-        }\n-\n-        fn link_binary(sess: &Session,\n-                       trans: &Self::TranslatedCrate,\n-                       outputs: &OutputFilenames) {\n-            for &crate_type in sess.opts.crate_types.iter() {\n-                if crate_type != CrateType::CrateTypeRlib &&\n-                   crate_type != CrateType::CrateTypeDylib {\n-                    continue;\n-                }\n-                let output_name =\n-                    out_filename(sess, crate_type, &outputs, &trans.0.crate_name.as_str());\n-                let mut compressed = trans.0.metadata_version.clone();\n-                let metadata = if crate_type == CrateType::CrateTypeDylib {\n-                    DeflateEncoder::new(&mut compressed, Compression::Fast)\n-                        .write_all(&trans.0.metadata.raw_data).unwrap();\n-                    &compressed\n-                } else {\n-                    &trans.0.metadata.raw_data\n-                };\n-                let mut builder = Builder::new(File::create(&output_name).unwrap());\n-                let header = Header::new(\n-                    \"rust.metadata.bin\".to_string(),\n-                    metadata.len() as u64\n-                );\n-                builder\n-                    .append(&header, Cursor::new(metadata))\n-                    .unwrap();\n-            }\n-        }\n-\n-        fn dump_incremental_data(_trans: &Self::TranslatedCrate) {}\n-    }\n-}\n-\n #[cfg(not(feature=\"llvm\"))]\n mod rustc_trans {\n     use syntax_pos::symbol::Symbol;\n     use rustc::session::Session;\n     use rustc::session::config::PrintRequest;\n-    pub use trans_metadata_only::MetadataOnlyTransCrate as LlvmTransCrate;\n+    pub use rustc_trans_traits::MetadataOnlyTransCrate as LlvmTransCrate;\n+    pub use rustc_trans_traits::TranslatedCrate as CrateTranslation;\n \n     pub fn init(_sess: &Session) {}\n     pub fn enable_llvm_debug() {}\n@@ -330,8 +172,6 @@ mod rustc_trans {\n     pub fn print(_req: PrintRequest, _sess: &Session) {}\n     pub fn target_features(_sess: &Session) -> Vec<Symbol> { vec![] }\n \n-    pub struct CrateTranslation(());\n-\n     pub mod back {\n         pub mod write {\n             pub const RELOC_MODEL_ARGS: [(&'static str, ()); 0] = [];"}, {"sha": "4ba0ed1e1c7eef0560e2e00dc86b29f6afaf0dbd", "filename": "src/librustc_trans_traits/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_trans_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_trans_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_traits%2FCargo.toml?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -10,8 +10,12 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+ar = \"0.3.0\"\n+flate2 = \"0.2\"\n owning_ref = \"0.3.3\"\n \n+syntax = { path = \"../libsyntax\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }"}, {"sha": "3f5f44eb906471c19a61ece95f4a99190b4582de", "filename": "src/librustc_trans_traits/lib.rs", "status": "modified", "additions": 133, "deletions": 3, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_trans_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60/src%2Flibrustc_trans_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_traits%2Flib.rs?ref=9eeaba18bd31e63c5ae576ea6c7b88cfd50fcb60", "patch": "@@ -21,24 +21,40 @@\n \n #![feature(box_syntax)]\n \n+extern crate ar;\n+extern crate flate2;\n extern crate owning_ref;\n \n+extern crate syntax;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_incremental;\n+extern crate rustc_trans_utils;\n \n+use std::io::prelude::*;\n+use std::io::{self, Cursor};\n+use std::fs::File;\n use std::path::Path;\n-use owning_ref::ErasedBoxRef;\n \n+use owning_ref::{ErasedBoxRef, OwningRef};\n+use ar::{Archive, Builder, Header};\n+use flate2::Compression;\n+use flate2::write::DeflateEncoder;\n+\n+use syntax::symbol::Symbol;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n-use rustc::session::config::OutputFilenames;\n-use rustc::ty::{TyCtxt, CrateAnalysis};\n+use rustc::session::config::{CrateType, OutputFilenames};\n+use rustc::ty::{CrateAnalysis, TyCtxt};\n use rustc::ty::maps::Providers;\n+use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n use rustc::dep_graph::DepGraph;\n use rustc_back::target::Target;\n use rustc_incremental::IncrementalHashesMap;\n+use rustc_trans_utils::find_exported_symbols;\n+use rustc_trans_utils::link::{build_link_meta, out_filename};\n \n pub trait TransCrate {\n     type MetadataLoader: MetadataLoaderTrait;\n@@ -114,3 +130,117 @@ impl MetadataLoaderTrait for DummyMetadataLoader {\n         bug!(\"DummyMetadataLoader::get_dylib_metadata\");\n     }\n }\n+\n+pub struct NoLlvmMetadataLoader;\n+\n+impl MetadataLoaderTrait for NoLlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        let file = File::open(filename)\n+            .map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n+        let mut archive = Archive::new(file);\n+\n+        while let Some(entry_result) = archive.next_entry() {\n+            let mut entry = entry_result\n+                .map_err(|e| format!(\"metadata section read err: {:?}\", e))?;\n+            if entry.header().identifier() == \"rust.metadata.bin\" {\n+                let mut buf = Vec::new();\n+                io::copy(&mut entry, &mut buf).unwrap();\n+                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                return Ok(buf.map_owner_box().erase_owner());\n+            }\n+        }\n+\n+        Err(\"Couldnt find metadata section\".to_string())\n+    }\n+\n+    fn get_dylib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path,\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        // FIXME: Support reading dylibs from llvm enabled rustc\n+        self.get_rlib_metadata(_target, _filename)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+pub struct MetadataOnlyTransCrate;\n+pub struct OngoingCrateTranslation {\n+    metadata: EncodedMetadata,\n+    metadata_version: Vec<u8>,\n+    crate_name: Symbol,\n+}\n+pub struct TranslatedCrate(OngoingCrateTranslation);\n+\n+impl MetadataOnlyTransCrate {\n+    #[allow(dead_code)]\n+    pub fn new() -> Self {\n+        MetadataOnlyTransCrate\n+    }\n+}\n+\n+impl TransCrate for MetadataOnlyTransCrate {\n+    type MetadataLoader = NoLlvmMetadataLoader;\n+    type OngoingCrateTranslation = OngoingCrateTranslation;\n+    type TranslatedCrate = TranslatedCrate;\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+        box NoLlvmMetadataLoader\n+    }\n+\n+    fn provide(_providers: &mut Providers) {}\n+\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        analysis: CrateAnalysis,\n+        incr_hashes_map: IncrementalHashesMap,\n+        _output_filenames: &OutputFilenames,\n+    ) -> Self::OngoingCrateTranslation {\n+        let link_meta = build_link_meta(&incr_hashes_map);\n+        let exported_symbols = find_exported_symbols(tcx, &analysis.reachable);\n+        let (metadata, _hashes) = tcx.encode_metadata(&link_meta, &exported_symbols);\n+\n+        OngoingCrateTranslation {\n+            metadata: metadata,\n+            metadata_version: tcx.metadata_encoding_version().to_vec(),\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n+        }\n+    }\n+\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        _sess: &Session,\n+        _dep_graph: &DepGraph,\n+    ) -> Self::TranslatedCrate {\n+        TranslatedCrate(trans)\n+    }\n+\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n+        for &crate_type in sess.opts.crate_types.iter() {\n+            if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n+                continue;\n+            }\n+            let output_name =\n+                out_filename(sess, crate_type, &outputs, &trans.0.crate_name.as_str());\n+            let mut compressed = trans.0.metadata_version.clone();\n+            let metadata = if crate_type == CrateType::CrateTypeDylib {\n+                DeflateEncoder::new(&mut compressed, Compression::Fast)\n+                    .write_all(&trans.0.metadata.raw_data)\n+                    .unwrap();\n+                &compressed\n+            } else {\n+                &trans.0.metadata.raw_data\n+            };\n+            let mut builder = Builder::new(File::create(&output_name).unwrap());\n+            let header = Header::new(\"rust.metadata.bin\".to_string(), metadata.len() as u64);\n+            builder.append(&header, Cursor::new(metadata)).unwrap();\n+        }\n+\n+        if !sess.opts.crate_types.contains(&CrateType::CrateTypeRlib)\n+            && !sess.opts.crate_types.contains(&CrateType::CrateTypeDylib) {\n+            sess.fatal(\"Executables are not supported by the metadata-only backend.\");\n+        }\n+    }\n+\n+    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {}\n+}"}]}