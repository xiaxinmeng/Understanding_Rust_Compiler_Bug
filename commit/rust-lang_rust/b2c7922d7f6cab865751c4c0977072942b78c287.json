{"sha": "b2c7922d7f6cab865751c4c0977072942b78c287", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYzc5MjJkN2Y2Y2FiODY1NzUxYzRjMDk3NzA3Mjk0MmI3OGMyODc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-10T19:33:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T13:03:50Z"}, "message": "move free encode fns into methods of IndexBuilder", "tree": {"sha": "94d7037a664cd7c9910709f1160965aa938ac82c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94d7037a664cd7c9910709f1160965aa938ac82c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2c7922d7f6cab865751c4c0977072942b78c287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c7922d7f6cab865751c4c0977072942b78c287", "html_url": "https://github.com/rust-lang/rust/commit/b2c7922d7f6cab865751c4c0977072942b78c287", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2c7922d7f6cab865751c4c0977072942b78c287/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92f269e665bd7fdccf83da6f545ee755b211bbb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/92f269e665bd7fdccf83da6f545ee755b211bbb9", "html_url": "https://github.com/rust-lang/rust/commit/92f269e665bd7fdccf83da6f545ee755b211bbb9"}], "stats": {"total": 1798, "additions": 902, "deletions": 896}, "files": [{"sha": "f256d1269340c6dc19c69c466a3afe816289323b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 902, "deletions": 896, "changes": 1798, "blob_url": "https://github.com/rust-lang/rust/blob/b2c7922d7f6cab865751c4c0977072942b78c287/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c7922d7f6cab865751c4c0977072942b78c287/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b2c7922d7f6cab865751c4c0977072942b78c287", "patch": "@@ -132,24 +132,23 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n-                                             ecx: &EncodeContext<'a, 'tcx>,\n-                                             index: &mut IndexBuilder<'a, 'tcx>,\n-                                             id: NodeId) {\n-    encode_bounds_and_type(rbml_w,\n-                           ecx,\n-                           index,\n-                           &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n-                           &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n-}\n-\n-fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n-                                    ecx: &EncodeContext<'a, 'tcx>,\n-                                    index: &mut IndexBuilder<'a, 'tcx>,\n-                                    scheme: &ty::TypeScheme<'tcx>,\n-                                    predicates: &ty::GenericPredicates<'tcx>) {\n-    encode_generics(rbml_w, ecx, index, &scheme.generics, &predicates);\n-    encode_type(ecx, rbml_w, scheme.ty);\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_bounds_and_type_for_item(&mut self,\n+                                       rbml_w: &mut Encoder,\n+                                       id: NodeId) {\n+        let ecx = self.ecx();\n+        self.encode_bounds_and_type(rbml_w,\n+                                    &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n+                                    &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n+    }\n+\n+    fn encode_bounds_and_type(&mut self,\n+                              rbml_w: &mut Encoder,\n+                              scheme: &ty::TypeScheme<'tcx>,\n+                              predicates: &ty::GenericPredicates<'tcx>) {\n+        self.encode_generics(rbml_w, &scheme.generics, &predicates);\n+        self.encode_type(rbml_w, scheme.ty);\n+    }\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n@@ -165,92 +164,95 @@ fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.mark_stable_position();\n }\n \n-fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                         rbml_w: &mut Encoder,\n-                         typ: Ty<'tcx>) {\n-    rbml_w.start_tag(tag_items_data_item_type);\n-    tyencode::enc_ty(rbml_w.writer, &ecx.ty_str_ctxt(), typ);\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n-}\n-\n-fn encode_disr_val(_: &EncodeContext,\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_type(&mut self,\n                    rbml_w: &mut Encoder,\n-                   disr_val: ty::Disr) {\n-    // convert to u64 so just the number is printed, without any type info\n-    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n-}\n+                   typ: Ty<'tcx>) {\n+        rbml_w.start_tag(tag_items_data_item_type);\n+        tyencode::enc_ty(rbml_w.writer, &self.ecx().ty_str_ctxt(), typ);\n+        rbml_w.mark_stable_position();\n+        rbml_w.end_tag();\n+    }\n \n-fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n-}\n+    fn encode_disr_val(&mut self,\n+                       rbml_w: &mut Encoder,\n+                       disr_val: ty::Disr) {\n+        // convert to u64 so just the number is printed, without any type info\n+        rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n+    }\n \n-fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        variant: ty::VariantDef) {\n-    for f in &variant.fields {\n-        if variant.kind == ty::VariantKind::Tuple {\n-            rbml_w.start_tag(tag_item_unnamed_field);\n-        } else {\n-            rbml_w.start_tag(tag_item_field);\n-            encode_name(rbml_w, f.name);\n-        }\n-        encode_struct_field_family(rbml_w, f.vis);\n-        encode_def_id(rbml_w, f.did);\n-        rbml_w.end_tag();\n+    fn encode_parent_item(&mut self, rbml_w: &mut Encoder, id: DefId) {\n+        rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n     }\n-}\n \n-fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                      rbml_w: &mut Encoder,\n-                                      did: DefId,\n-                                      vis: &hir::Visibility,\n-                                      index: &mut IndexBuilder<'a, 'tcx>) {\n-    debug!(\"encode_enum_variant_info(did={:?})\", did);\n-    let repr_hints = ecx.tcx.lookup_repr_hints(did);\n-    let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n-    let mut disr_val = repr_type.initial_discriminant(ecx.tcx);\n-    let def = ecx.tcx.lookup_adt_def(did);\n-    for variant in &def.variants {\n-        let vid = variant.did;\n-        let variant_node_id = ecx.local_id(vid);\n-\n-        for field in &variant.fields {\n-            encode_field(ecx, rbml_w, field, index);\n+    fn encode_struct_fields(&mut self,\n+                            rbml_w: &mut Encoder,\n+                            variant: ty::VariantDef) {\n+        for f in &variant.fields {\n+            if variant.kind == ty::VariantKind::Tuple {\n+                rbml_w.start_tag(tag_item_unnamed_field);\n+            } else {\n+                rbml_w.start_tag(tag_item_field);\n+                encode_name(rbml_w, f.name);\n+            }\n+            self.encode_struct_field_family(rbml_w, f.vis);\n+            encode_def_id(rbml_w, f.did);\n+            rbml_w.end_tag();\n         }\n+    }\n \n-        let _task = index.record(vid, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, vid);\n-        encode_family(rbml_w, match variant.kind {\n-            ty::VariantKind::Struct => 'V',\n-            ty::VariantKind::Tuple => 'v',\n-            ty::VariantKind::Unit => 'w',\n-        });\n-        encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, did);\n-        encode_visibility(rbml_w, vis);\n-\n-        let attrs = ecx.tcx.get_attrs(vid);\n-        encode_attributes(rbml_w, &attrs);\n-        encode_repr_attrs(rbml_w, ecx, &attrs);\n+    fn encode_enum_variant_info(&mut self,\n+                                rbml_w: &mut Encoder,\n+                                did: DefId,\n+                                vis: &hir::Visibility) {\n+        debug!(\"encode_enum_variant_info(did={:?})\", did);\n+        let ecx = self.ecx();\n+        let repr_hints = ecx.tcx.lookup_repr_hints(did);\n+        let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n+        let mut disr_val = repr_type.initial_discriminant(ecx.tcx);\n+        let def = ecx.tcx.lookup_adt_def(did);\n+        for variant in &def.variants {\n+            let vid = variant.did;\n+            let variant_node_id = ecx.local_id(vid);\n+\n+            for field in &variant.fields {\n+                self.encode_field(rbml_w, field);\n+            }\n \n-        let stab = ecx.tcx.lookup_stability(vid);\n-        let depr = ecx.tcx.lookup_deprecation(vid);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n+            let _task = self.record(vid, rbml_w);\n+            rbml_w.start_tag(tag_items_data_item);\n+            encode_def_id_and_key(ecx, rbml_w, vid);\n+            encode_family(rbml_w, match variant.kind {\n+                ty::VariantKind::Struct => 'V',\n+                ty::VariantKind::Tuple => 'v',\n+                ty::VariantKind::Unit => 'w',\n+            });\n+            encode_name(rbml_w, variant.name);\n+            self.encode_parent_item(rbml_w, did);\n+            self.encode_visibility(rbml_w, vis);\n+\n+            let attrs = ecx.tcx.get_attrs(vid);\n+            encode_attributes(rbml_w, &attrs);\n+            self.encode_repr_attrs(rbml_w, &attrs);\n+\n+            let stab = ecx.tcx.lookup_stability(vid);\n+            let depr = ecx.tcx.lookup_deprecation(vid);\n+            encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n-        encode_struct_fields(rbml_w, variant);\n+            self.encode_struct_fields(rbml_w, variant);\n \n-        let specified_disr_val = variant.disr_val;\n-        if specified_disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, specified_disr_val);\n-            disr_val = specified_disr_val;\n-        }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, variant_node_id);\n+            let specified_disr_val = variant.disr_val;\n+            if specified_disr_val != disr_val {\n+                self.encode_disr_val(rbml_w, specified_disr_val);\n+                disr_val = specified_disr_val;\n+            }\n+            self.encode_bounds_and_type_for_item(rbml_w, variant_node_id);\n \n-        rbml_w.end_tag();\n+            rbml_w.end_tag();\n \n-        disr_val = disr_val.wrap_incr();\n+            disr_val = disr_val.wrap_incr();\n+        }\n     }\n }\n \n@@ -300,57 +302,61 @@ fn encode_reexports(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_info_for_mod(ecx: &EncodeContext,\n-                       rbml_w: &mut Encoder,\n-                       md: &hir::Mod,\n-                       attrs: &[ast::Attribute],\n-                       id: NodeId,\n-                       name: Name,\n-                       vis: &hir::Visibility) {\n-    rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n-    encode_family(rbml_w, 'm');\n-    encode_name(rbml_w, name);\n-    debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n-\n-    // Encode info about all the module children.\n-    for item_id in &md.item_ids {\n-        rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_info_for_mod(&mut self,\n+                           rbml_w: &mut Encoder,\n+                           md: &hir::Mod,\n+                           attrs: &[ast::Attribute],\n+                           id: NodeId,\n+                           name: Name,\n+                           vis: &hir::Visibility) {\n+        let ecx = self.ecx();\n \n-        let item = ecx.tcx.map.expect_item(item_id.id);\n-        each_auxiliary_node_id(item, |auxiliary_node_id| {\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n+        encode_family(rbml_w, 'm');\n+        encode_name(rbml_w, name);\n+        debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n+\n+        // Encode info about all the module children.\n+        for item_id in &md.item_ids {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n-            true\n-        });\n-    }\n+                                 def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n+\n+            let item = ecx.tcx.map.expect_item(item_id.id);\n+            each_auxiliary_node_id(item, |auxiliary_node_id| {\n+                rbml_w.wr_tagged_u64(tag_mod_child,\n+                                     def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n+                true\n+            });\n+        }\n \n-    encode_visibility(rbml_w, vis);\n+        self.encode_visibility(rbml_w, vis);\n \n-    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n-    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n+        encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n-    // Encode the reexports of this module, if this module is public.\n-    if *vis == hir::Public {\n-        debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-        encode_reexports(ecx, rbml_w, id);\n-    }\n-    encode_attributes(rbml_w, attrs);\n+        // Encode the reexports of this module, if this module is public.\n+        if *vis == hir::Public {\n+            debug!(\"(encoding info for module) encoding reexports for {}\", id);\n+            encode_reexports(ecx, rbml_w, id);\n+        }\n+        encode_attributes(rbml_w, attrs);\n \n-    rbml_w.end_tag();\n-}\n+        rbml_w.end_tag();\n+    }\n \n-fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: ty::Visibility) {\n-    encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n-}\n+    fn encode_struct_field_family(&mut self, rbml_w: &mut Encoder,\n+                                  visibility: ty::Visibility) {\n+        encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n+    }\n \n-fn encode_visibility<T: HasVisibility>(rbml_w: &mut Encoder, visibility: T) {\n-    let ch = if visibility.is_public() { 'y' } else { 'i' };\n-    rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+    fn encode_visibility<T: HasVisibility>(&mut self, rbml_w: &mut Encoder, visibility: T) {\n+        let ch = if visibility.is_public() { 'y' } else { 'i' };\n+        rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+    }\n }\n \n trait HasVisibility: Sized {\n@@ -421,281 +427,287 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n-fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                          rbml_w: &mut Encoder,\n-                          field: ty::FieldDef<'tcx>,\n-                          index: &mut IndexBuilder<'a, 'tcx>) {\n-    let nm = field.name;\n-    let id = ecx.local_id(field.did);\n-\n-    let _task = index.record(field.did, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-    debug!(\"encode_field: encoding {} {}\", nm, id);\n-    encode_struct_field_family(rbml_w, field.vis);\n-    encode_name(rbml_w, nm);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n-    encode_def_id_and_key(ecx, rbml_w, field.did);\n-\n-    let stab = ecx.tcx.lookup_stability(field.did);\n-    let depr = ecx.tcx.lookup_deprecation(field.did);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    rbml_w.end_tag();\n-}\n-\n-fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                         rbml_w: &mut Encoder,\n-                                         name: Name,\n-                                         struct_def: &hir::VariantData,\n-                                         index: &mut IndexBuilder<'a, 'tcx>,\n-                                         struct_id: NodeId) {\n-    let ctor_id = struct_def.id();\n-    let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n-\n-    let _task = index.record(ctor_def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n-    encode_family(rbml_w, match *struct_def {\n-        hir::VariantData::Struct(..) => 'S',\n-        hir::VariantData::Tuple(..) => 's',\n-        hir::VariantData::Unit(..) => 'u',\n-    });\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n-    encode_name(rbml_w, name);\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_field(&mut self,\n+                    rbml_w: &mut Encoder,\n+                    field: ty::FieldDef<'tcx>) {\n+        let ecx = self.ecx();\n \n-    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n-    let depr= ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n+        let nm = field.name;\n+        let id = ecx.local_id(field.did);\n \n-    // indicate that this is a tuple struct ctor, because downstream users will normally want\n-    // the tuple struct definition, but without this there is no way for them to tell that\n-    // they actually have a ctor rather than a normal function\n-    rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+        let _task = self.record(field.did, rbml_w);\n+        rbml_w.start_tag(tag_items_data_item);\n+        debug!(\"encode_field: encoding {} {}\", nm, id);\n+        self.encode_struct_field_family(rbml_w, field.vis);\n+        encode_name(rbml_w, nm);\n+        self.encode_bounds_and_type_for_item(rbml_w, id);\n+        encode_def_id_and_key(ecx, rbml_w, field.did);\n+\n+        let stab = ecx.tcx.lookup_stability(field.did);\n+        let depr = ecx.tcx.lookup_deprecation(field.did);\n+        encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n-    rbml_w.end_tag();\n+        rbml_w.end_tag();\n+    }\n }\n \n-fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n-                             ecx: &EncodeContext<'a, 'tcx>,\n-                             index: &mut IndexBuilder<'a, 'tcx>,\n-                             generics: &ty::Generics<'tcx>,\n-                             predicates: &ty::GenericPredicates<'tcx>)\n-{\n-    rbml_w.start_tag(tag_item_generics);\n-    tyencode::enc_generics(rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_info_for_struct_ctor(&mut self,\n+                                   rbml_w: &mut Encoder,\n+                                   name: Name,\n+                                   struct_def: &hir::VariantData,\n+                                   struct_id: NodeId) {\n+        let ecx = self.ecx();\n+        let ctor_id = struct_def.id();\n+        let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n+\n+        let _task = self.record(ctor_def_id, rbml_w);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n+        encode_family(rbml_w, match *struct_def {\n+            hir::VariantData::Struct(..) => 'S',\n+            hir::VariantData::Tuple(..) => 's',\n+            hir::VariantData::Unit(..) => 'u',\n+        });\n+        self.encode_bounds_and_type_for_item(rbml_w, ctor_id);\n+        encode_name(rbml_w, name);\n+        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n \n-    encode_predicates(rbml_w, index, predicates, tag_item_predicates);\n-}\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n+        encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n-fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n-                              index: &mut IndexBuilder<'a, 'tcx>,\n-                              predicates: &ty::GenericPredicates<'tcx>,\n-                              tag: usize)\n-{\n-    rbml_w.start_tag(tag);\n-    if let Some(def_id) = predicates.parent {\n-        rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+        // indicate that this is a tuple struct ctor, because downstream users will normally want\n+        // the tuple struct definition, but without this there is no way for them to tell that\n+        // they actually have a ctor rather than a normal function\n+        rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+\n+        rbml_w.end_tag();\n     }\n-    for predicate in &predicates.predicates {\n-        rbml_w.wr_tagged_u32(tag_predicate,\n-            index.add_xref(XRef::Predicate(predicate.clone())));\n+\n+    fn encode_generics(&mut self,\n+                       rbml_w: &mut Encoder,\n+                       generics: &ty::Generics<'tcx>,\n+                       predicates: &ty::GenericPredicates<'tcx>)\n+    {\n+        let ecx = self.ecx();\n+        rbml_w.start_tag(tag_item_generics);\n+        tyencode::enc_generics(rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n+        rbml_w.mark_stable_position();\n+        rbml_w.end_tag();\n+        self.encode_predicates(rbml_w, predicates, tag_item_predicates);\n     }\n-    rbml_w.end_tag();\n-}\n \n-fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                     rbml_w: &mut Encoder,\n-                                     index: &mut IndexBuilder<'a, 'tcx>,\n-                                     method_ty: &ty::Method<'tcx>) {\n-    encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n-    encode_name(rbml_w, method_ty.name);\n-    encode_generics(rbml_w, ecx, index,\n-                    &method_ty.generics, &method_ty.predicates);\n-    encode_visibility(rbml_w, method_ty.vis);\n-    encode_explicit_self(rbml_w, &method_ty.explicit_self);\n-    match method_ty.explicit_self {\n-        ty::ExplicitSelfCategory::Static => {\n-            encode_family(rbml_w, STATIC_METHOD_FAMILY);\n+    fn encode_predicates(&mut self,\n+                         rbml_w: &mut Encoder,\n+                         predicates: &ty::GenericPredicates<'tcx>,\n+                         tag: usize) {\n+        rbml_w.start_tag(tag);\n+        if let Some(def_id) = predicates.parent {\n+            rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+        }\n+        for predicate in &predicates.predicates {\n+            rbml_w.wr_tagged_u32(tag_predicate,\n+                                 self.add_xref(XRef::Predicate(predicate.clone())));\n         }\n-        _ => encode_family(rbml_w, METHOD_FAMILY)\n+        rbml_w.end_tag();\n     }\n-}\n \n-fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                              rbml_w: &mut Encoder,\n-                                              index: &mut IndexBuilder<'a, 'tcx>,\n-                                              associated_const: &ty::AssociatedConst,\n-                                              parent_id: NodeId,\n-                                              impl_item_opt: Option<&hir::ImplItem>) {\n-    debug!(\"encode_info_for_associated_const({:?},{:?})\",\n-           associated_const.def_id,\n-           associated_const.name);\n-\n-    let _task = index.record(associated_const.def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-\n-    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-    encode_name(rbml_w, associated_const.name);\n-    encode_visibility(rbml_w, associated_const.vis);\n-    encode_family(rbml_w, 'C');\n-\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_item_sort(rbml_w, 'C');\n-\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                    ecx.local_id(associated_const.def_id));\n-\n-    let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n-    let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    if let Some(ii) = impl_item_opt {\n-        encode_attributes(rbml_w, &ii.attrs);\n-        encode_defaultness(rbml_w, ii.defaultness);\n-        encode_inlined_item(ecx,\n-                            rbml_w,\n-                            InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                     ii));\n-        encode_mir(ecx, rbml_w, ii.id);\n+    fn encode_method_ty_fields(&mut self,\n+                               rbml_w: &mut Encoder,\n+                               method_ty: &ty::Method<'tcx>) {\n+        let ecx = self.ecx();\n+        encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n+        encode_name(rbml_w, method_ty.name);\n+        self.encode_generics(rbml_w, &method_ty.generics, &method_ty.predicates);\n+        self.encode_visibility(rbml_w, method_ty.vis);\n+        encode_explicit_self(rbml_w, &method_ty.explicit_self);\n+        match method_ty.explicit_self {\n+            ty::ExplicitSelfCategory::Static => {\n+                encode_family(rbml_w, STATIC_METHOD_FAMILY);\n+            }\n+            _ => encode_family(rbml_w, METHOD_FAMILY)\n+        }\n     }\n \n-    rbml_w.end_tag();\n-}\n+    fn encode_info_for_associated_const(&mut self,\n+                                        rbml_w: &mut Encoder,\n+                                        associated_const: &ty::AssociatedConst,\n+                                        parent_id: NodeId,\n+                                        impl_item_opt: Option<&hir::ImplItem>) {\n+        let ecx = self.ecx();\n+        debug!(\"encode_info_for_associated_const({:?},{:?})\",\n+               associated_const.def_id,\n+               associated_const.name);\n+\n+        let _task = self.record(associated_const.def_id, rbml_w);\n+        rbml_w.start_tag(tag_items_data_item);\n \n-fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                    rbml_w: &mut Encoder,\n-                                    index: &mut IndexBuilder<'a, 'tcx>,\n-                                    m: &ty::Method<'tcx>,\n-                                    is_default_impl: bool,\n-                                    parent_id: NodeId,\n-                                    impl_item_opt: Option<&hir::ImplItem>) {\n-\n-    debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n-           m.name);\n-    let _task = index.record(m.def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-\n-    encode_method_ty_fields(ecx, rbml_w, index, m);\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_item_sort(rbml_w, 'r');\n-\n-    let stab = ecx.tcx.lookup_stability(m.def_id);\n-    let depr = ecx.tcx.lookup_deprecation(m.def_id);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    let m_node_id = ecx.local_id(m.def_id);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n-\n-    if let Some(impl_item) = impl_item_opt {\n-        if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-            encode_attributes(rbml_w, &impl_item.attrs);\n-            let generics = ecx.tcx.lookup_generics(m.def_id);\n-            let types = generics.parent_types as usize + generics.types.len();\n-            let needs_inline = types > 0 || is_default_impl ||\n-                               attr::requests_inline(&impl_item.attrs);\n-            if needs_inline || sig.constness == hir::Constness::Const {\n-                encode_inlined_item(ecx,\n-                                    rbml_w,\n-                                    InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                             impl_item));\n-                encode_mir(ecx, rbml_w, impl_item.id);\n-            }\n-            encode_constness(rbml_w, sig.constness);\n-            encode_defaultness(rbml_w, impl_item.defaultness);\n-            encode_method_argument_names(rbml_w, &sig.decl);\n+        encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n+        encode_name(rbml_w, associated_const.name);\n+        self.encode_visibility(rbml_w, associated_const.vis);\n+        encode_family(rbml_w, 'C');\n+\n+        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(rbml_w, 'C');\n+\n+        self.encode_bounds_and_type_for_item(rbml_w, ecx.local_id(associated_const.def_id));\n+\n+        let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n+        encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n+\n+        if let Some(ii) = impl_item_opt {\n+            encode_attributes(rbml_w, &ii.attrs);\n+            encode_defaultness(rbml_w, ii.defaultness);\n+            encode_inlined_item(ecx,\n+                                rbml_w,\n+                                InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                         ii));\n+            self.encode_mir(rbml_w, ii.id);\n         }\n+\n+        rbml_w.end_tag();\n     }\n \n-    rbml_w.end_tag();\n-}\n+    fn encode_info_for_method(&mut self,\n+                              rbml_w: &mut Encoder,\n+                              m: &ty::Method<'tcx>,\n+                              is_default_impl: bool,\n+                              parent_id: NodeId,\n+                              impl_item_opt: Option<&hir::ImplItem>) {\n+        let ecx = self.ecx();\n+\n+        debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n+               m.name);\n+        let _task = self.record(m.def_id, rbml_w);\n+        rbml_w.start_tag(tag_items_data_item);\n \n-fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                             rbml_w: &mut Encoder,\n-                                             index: &mut IndexBuilder<'a, 'tcx>,\n-                                             associated_type: &ty::AssociatedType<'tcx>,\n-                                             parent_id: NodeId,\n-                                             impl_item_opt: Option<&hir::ImplItem>) {\n-    debug!(\"encode_info_for_associated_type({:?},{:?})\",\n-           associated_type.def_id,\n-           associated_type.name);\n-\n-    let _task = index.record(associated_type.def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-\n-    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-    encode_name(rbml_w, associated_type.name);\n-    encode_visibility(rbml_w, associated_type.vis);\n-    encode_family(rbml_w, 'y');\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_item_sort(rbml_w, 't');\n-\n-    let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n-    let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n-    encode_stability(rbml_w, stab);\n-    encode_deprecation(rbml_w, depr);\n-\n-    if let Some(ii) = impl_item_opt {\n-        encode_attributes(rbml_w, &ii.attrs);\n-        encode_defaultness(rbml_w, ii.defaultness);\n-    } else {\n-        encode_predicates(rbml_w, index,\n-                          &ecx.tcx.lookup_predicates(associated_type.def_id),\n-                          tag_item_generics);\n-    }\n+        self.encode_method_ty_fields(rbml_w, m);\n+        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(rbml_w, 'r');\n+\n+        let stab = ecx.tcx.lookup_stability(m.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(m.def_id);\n+        encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n-    if let Some(ty) = associated_type.ty {\n-        encode_type(ecx, rbml_w, ty);\n+        let m_node_id = ecx.local_id(m.def_id);\n+        self.encode_bounds_and_type_for_item(rbml_w, m_node_id);\n+\n+        if let Some(impl_item) = impl_item_opt {\n+            if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                encode_attributes(rbml_w, &impl_item.attrs);\n+                let generics = ecx.tcx.lookup_generics(m.def_id);\n+                let types = generics.parent_types as usize + generics.types.len();\n+                let needs_inline = types > 0 || is_default_impl ||\n+                    attr::requests_inline(&impl_item.attrs);\n+                if needs_inline || sig.constness == hir::Constness::Const {\n+                    encode_inlined_item(\n+                        ecx,\n+                        rbml_w,\n+                        InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                 impl_item));\n+                    self.encode_mir(rbml_w, impl_item.id);\n+                }\n+                encode_constness(rbml_w, sig.constness);\n+                encode_defaultness(rbml_w, impl_item.defaultness);\n+                self.encode_method_argument_names(rbml_w, &sig.decl);\n+            }\n+        }\n+\n+        rbml_w.end_tag();\n     }\n \n-    rbml_w.end_tag();\n-}\n+    fn encode_info_for_associated_type(&mut self,\n+                                       rbml_w: &mut Encoder,\n+                                       associated_type: &ty::AssociatedType<'tcx>,\n+                                       parent_id: NodeId,\n+                                       impl_item_opt: Option<&hir::ImplItem>) {\n+        let ecx = self.ecx();\n+        debug!(\"encode_info_for_associated_type({:?},{:?})\",\n+               associated_type.def_id,\n+               associated_type.name);\n+\n+        let _task = self.record(associated_type.def_id, rbml_w);\n+        rbml_w.start_tag(tag_items_data_item);\n+\n+        encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n+        encode_name(rbml_w, associated_type.name);\n+        self.encode_visibility(rbml_w, associated_type.vis);\n+        encode_family(rbml_w, 'y');\n+        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(rbml_w, 't');\n+\n+        let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n+        encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n-fn encode_method_argument_names(rbml_w: &mut Encoder,\n-                                decl: &hir::FnDecl) {\n-    rbml_w.start_tag(tag_method_argument_names);\n-    for arg in &decl.inputs {\n-        let tag = tag_method_argument_name;\n-        if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n-            let name = path1.node.as_str();\n-            rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+        if let Some(ii) = impl_item_opt {\n+            encode_attributes(rbml_w, &ii.attrs);\n+            encode_defaultness(rbml_w, ii.defaultness);\n         } else {\n-            rbml_w.wr_tagged_bytes(tag, &[]);\n+            // TODO this looks bogus and unnecessary\n+            self.encode_predicates(rbml_w,\n+                                   &ecx.tcx.lookup_predicates(associated_type.def_id),\n+                                   tag_item_generics);\n         }\n+\n+        if let Some(ty) = associated_type.ty {\n+            self.encode_type(rbml_w, ty);\n+        }\n+\n+        rbml_w.end_tag();\n     }\n-    rbml_w.end_tag();\n-}\n \n-fn encode_repr_attrs(rbml_w: &mut Encoder,\n-                     ecx: &EncodeContext,\n-                     attrs: &[ast::Attribute]) {\n-    let mut repr_attrs = Vec::new();\n-    for attr in attrs {\n-        repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n-                                                attr));\n+    fn encode_method_argument_names(&mut self,\n+                                    rbml_w: &mut Encoder,\n+                                    decl: &hir::FnDecl) {\n+        rbml_w.start_tag(tag_method_argument_names);\n+        for arg in &decl.inputs {\n+            let tag = tag_method_argument_name;\n+            if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n+                let name = path1.node.as_str();\n+                rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+            } else {\n+                rbml_w.wr_tagged_bytes(tag, &[]);\n+            }\n+        }\n+        rbml_w.end_tag();\n     }\n-    rbml_w.start_tag(tag_items_data_item_repr);\n-    repr_attrs.encode(rbml_w);\n-    rbml_w.end_tag();\n-}\n \n-fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, node_id: NodeId) {\n-    let def_id = ecx.tcx.map.local_def_id(node_id);\n-    if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n-        rbml_w.start_tag(tag_mir as usize);\n-        rbml_w.emit_opaque(|opaque_encoder| {\n-            tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n-                Encodable::encode(mir, opaque_encoder)\n-            })\n-        }).unwrap();\n+    fn encode_repr_attrs(&mut self,\n+                         rbml_w: &mut Encoder,\n+                         attrs: &[ast::Attribute]) {\n+        let ecx = self.ecx();\n+        let mut repr_attrs = Vec::new();\n+        for attr in attrs {\n+            repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n+                                                    attr));\n+        }\n+        rbml_w.start_tag(tag_items_data_item_repr);\n+        repr_attrs.encode(rbml_w);\n         rbml_w.end_tag();\n     }\n+\n+    fn encode_mir(&mut self, rbml_w: &mut Encoder, node_id: NodeId) {\n+        let ecx = self.ecx();\n+        let def_id = ecx.tcx.map.local_def_id(node_id);\n+        if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n+            rbml_w.start_tag(tag_mir as usize);\n+            rbml_w.emit_opaque(|opaque_encoder| {\n+                tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n+                    Encodable::encode(mir, opaque_encoder)\n+                })\n+            }).unwrap();\n+            rbml_w.end_tag();\n+        }\n+    }\n }\n \n const FN_FAMILY: char = 'f';\n@@ -762,595 +774,590 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn encode_info_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n-                                  item: &hir::Item,\n-                                  index: &mut IndexBuilder<'a, 'tcx>) {\n-    let ecx = index.ecx();\n-    let tcx = ecx.tcx;\n-\n-    debug!(\"encoding info for item at {}\",\n-           tcx.sess.codemap().span_to_string(item.span));\n-\n-    let vis = &item.vis;\n-    let def_id = ecx.tcx.map.local_def_id(item.id);\n-\n-    let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n-        (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n-         tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n-    });\n-\n-    match item.node {\n-      hir::ItemStatic(_, m, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        if m == hir::MutMutable {\n-            encode_family(rbml_w, 'b');\n-        } else {\n-            encode_family(rbml_w, 'c');\n-        }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_attributes(rbml_w, &item.attrs);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemConst(_, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'C');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-        encode_mir(ecx, rbml_w, item.id);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, FN_FAMILY);\n-        let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-        if needs_inline || constness == hir::Constness::Const {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-            encode_mir(ecx, rbml_w, item.id);\n-        }\n-        encode_constness(rbml_w, constness);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_method_argument_names(rbml_w, &decl);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemMod(ref m) => {\n-        let _task = index.record(def_id, rbml_w);\n-        encode_info_for_mod(ecx,\n-                            rbml_w,\n-                            m,\n-                            &item.attrs,\n-                            item.id,\n-                            item.name,\n-                            &item.vis);\n-      }\n-      hir::ItemForeignMod(ref fm) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'n');\n-        encode_name(rbml_w, item.name);\n-\n-        // Encode all the items in this module.\n-        for foreign_item in &fm.items {\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n-        }\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemTy(..) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'y');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-      }\n-      hir::ItemEnum(ref enum_definition, _) => {\n-        let _task = index.record(def_id, rbml_w);\n-\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 't');\n-        encode_item_variances(rbml_w, ecx, item.id);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n-        for v in &enum_definition.variants {\n-            encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n-        }\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-        encode_mir(ecx, rbml_w, item.id);\n-\n-        // Encode inherent implementations for this enumeration.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n-\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_info_for_item(&mut self,\n+                            rbml_w: &mut Encoder,\n+                            item: &hir::Item) {\n+        let ecx = self.ecx();\n+        let tcx = ecx.tcx;\n \n-        encode_enum_variant_info(ecx,\n-                                 rbml_w,\n-                                 def_id,\n-                                 vis,\n-                                 index);\n-      }\n-      hir::ItemStruct(ref struct_def, _) => {\n-        /* Index the class*/\n-        let _task = index.record(def_id, rbml_w);\n+        debug!(\"encoding info for item at {}\",\n+               tcx.sess.codemap().span_to_string(item.span));\n \n-        let def = ecx.tcx.lookup_adt_def(def_id);\n-        let variant = def.struct_variant();\n+        let vis = &item.vis;\n+        let def_id = ecx.tcx.map.local_def_id(item.id);\n \n-        /* Now, make an item for the class itself */\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, match *struct_def {\n-            hir::VariantData::Struct(..) => 'S',\n-            hir::VariantData::Tuple(..) => 's',\n-            hir::VariantData::Unit(..) => 'u',\n+        let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n+            (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n+             tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n         });\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-\n-        encode_item_variances(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n-\n-        /* Encode def_ids for each field and method\n-         for methods, write all the stuff get_trait_method\n-        needs to know*/\n-        encode_struct_fields(rbml_w, variant);\n \n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n-        encode_mir(ecx, rbml_w, item.id);\n-\n-        // Encode inherent implementations for this structure.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n-\n-        if !struct_def.is_struct() {\n-            let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n-            rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n-                                 def_to_u64(ctor_did));\n-        }\n-\n-        rbml_w.end_tag();\n-\n-        for field in &variant.fields {\n-            encode_field(ecx, rbml_w, field, index);\n-        }\n-\n-        // If this is a tuple-like struct, encode the type of the constructor.\n-        if !struct_def.is_struct() {\n-            encode_info_for_struct_ctor(ecx, rbml_w, item.name, struct_def, index, item.id);\n-        }\n-      }\n-      hir::ItemDefaultImpl(unsafety, _) => {\n-          let _task = index.record(def_id, rbml_w);\n-          rbml_w.start_tag(tag_items_data_item);\n-          encode_def_id_and_key(ecx, rbml_w, def_id);\n-          encode_family(rbml_w, 'd');\n-          encode_name(rbml_w, item.name);\n-          encode_unsafety(rbml_w, unsafety);\n-\n-          let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n-          encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-          rbml_w.end_tag();\n-      }\n-      hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n-        let _task = index.record(def_id, rbml_w);\n-\n-        // We need to encode information about the default methods we\n-        // have inherited, so we drive this based on the impl structure.\n-        let impl_items = tcx.impl_items.borrow();\n-        let items = impl_items.get(&def_id).unwrap();\n-\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'i');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_unsafety(rbml_w, unsafety);\n-        encode_polarity(rbml_w, polarity);\n-\n-        match tcx.custom_coerce_unsized_kinds.borrow().get(&ecx.tcx.map.local_def_id(item.id)) {\n-            Some(&kind) => {\n-                rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n-                kind.encode(rbml_w);\n+        match item.node {\n+            hir::ItemStatic(_, m, _) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                if m == hir::MutMutable {\n+                    encode_family(rbml_w, 'b');\n+                } else {\n+                    encode_family(rbml_w, 'c');\n+                }\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                encode_name(rbml_w, item.name);\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                encode_attributes(rbml_w, &item.attrs);\n                 rbml_w.end_tag();\n             }\n-            None => {}\n-        }\n-\n-        for &item_def_id in items {\n-            rbml_w.start_tag(tag_item_impl_item);\n-            match item_def_id {\n-                ty::ConstTraitItemId(item_def_id) => {\n-                    encode_def_id(rbml_w, item_def_id);\n-                    encode_item_sort(rbml_w, 'C');\n+            hir::ItemConst(_, _) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'C');\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                encode_name(rbml_w, item.name);\n+                encode_attributes(rbml_w, &item.attrs);\n+                encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(rbml_w, item.id);\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                rbml_w.end_tag();\n+            }\n+            hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, FN_FAMILY);\n+                let tps_len = generics.ty_params.len();\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                encode_name(rbml_w, item.name);\n+                encode_attributes(rbml_w, &item.attrs);\n+                let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+                if needs_inline || constness == hir::Constness::Const {\n+                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                    self.encode_mir(rbml_w, item.id);\n                 }\n-                ty::MethodTraitItemId(item_def_id) => {\n-                    encode_def_id(rbml_w, item_def_id);\n-                    encode_item_sort(rbml_w, 'r');\n+                encode_constness(rbml_w, constness);\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                self.encode_method_argument_names(rbml_w, &decl);\n+                rbml_w.end_tag();\n+            }\n+            hir::ItemMod(ref m) => {\n+                let _task = self.record(def_id, rbml_w);\n+                self.encode_info_for_mod(rbml_w,\n+                                         m,\n+                                         &item.attrs,\n+                                         item.id,\n+                                         item.name,\n+                                         &item.vis);\n+            }\n+            hir::ItemForeignMod(ref fm) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'n');\n+                encode_name(rbml_w, item.name);\n+\n+                // Encode all the items in this module.\n+                for foreign_item in &fm.items {\n+                    rbml_w.wr_tagged_u64(tag_mod_child,\n+                                         def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n                 }\n-                ty::TypeTraitItemId(item_def_id) => {\n-                    encode_def_id(rbml_w, item_def_id);\n-                    encode_item_sort(rbml_w, 't');\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                rbml_w.end_tag();\n+            }\n+            hir::ItemTy(..) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'y');\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                encode_name(rbml_w, item.name);\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                rbml_w.end_tag();\n+            }\n+            hir::ItemEnum(ref enum_definition, _) => {\n+                let _task = self.record(def_id, rbml_w);\n+\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 't');\n+                encode_item_variances(rbml_w, ecx, item.id);\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                encode_name(rbml_w, item.name);\n+                encode_attributes(rbml_w, &item.attrs);\n+                self.encode_repr_attrs(rbml_w, &item.attrs);\n+                for v in &enum_definition.variants {\n+                    encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n                 }\n+                encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(rbml_w, item.id);\n+\n+                // Encode inherent implementations for this enumeration.\n+                encode_inherent_implementations(ecx, rbml_w, def_id);\n+\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                rbml_w.end_tag();\n+\n+                self.encode_enum_variant_info(rbml_w,\n+                                              def_id,\n+                                              vis);\n             }\n-            rbml_w.end_tag();\n-        }\n-        let did = ecx.tcx.map.local_def_id(item.id);\n-        if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-            encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-\n-            let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n-            let parent = trait_def.ancestors(did)\n-                .skip(1)\n-                .next()\n-                .and_then(|node| match node {\n-                    specialization_graph::Node::Impl(parent) => Some(parent),\n-                    _ => None,\n+            hir::ItemStruct(ref struct_def, _) => {\n+                /* Index the class*/\n+                let _task = self.record(def_id, rbml_w);\n+\n+                let def = ecx.tcx.lookup_adt_def(def_id);\n+                let variant = def.struct_variant();\n+\n+                /* Now, make an item for the class itself */\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, match *struct_def {\n+                    hir::VariantData::Struct(..) => 'S',\n+                    hir::VariantData::Tuple(..) => 's',\n+                    hir::VariantData::Unit(..) => 'u',\n                 });\n-            encode_parent_impl(rbml_w, parent);\n-        }\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        rbml_w.end_tag();\n-\n-        // Iterate down the trait items, emitting them. We rely on the\n-        // assumption that all of the actually implemented trait items\n-        // appear first in the impl structure, in the same order they do\n-        // in the ast. This is a little sketchy.\n-        let num_implemented_methods = ast_items.len();\n-        for (i, &trait_item_def_id) in items.iter().enumerate() {\n-            let ast_item = if i < num_implemented_methods {\n-                Some(&ast_items[i])\n-            } else {\n-                None\n-            };\n-\n-            match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n-                ty::ConstTraitItem(ref associated_const) => {\n-                    encode_info_for_associated_const(ecx,\n-                                                     rbml_w,\n-                                                     index,\n-                                                     &associated_const,\n-                                                     item.id,\n-                                                     ast_item)\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+\n+                encode_item_variances(rbml_w, ecx, item.id);\n+                encode_name(rbml_w, item.name);\n+                encode_attributes(rbml_w, &item.attrs);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                self.encode_visibility(rbml_w, vis);\n+                self.encode_repr_attrs(rbml_w, &item.attrs);\n+\n+                /* Encode def_ids for each field and method\n+                for methods, write all the stuff get_trait_method\n+                needs to know*/\n+                self.encode_struct_fields(rbml_w, variant);\n+\n+                encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(rbml_w, item.id);\n+\n+                // Encode inherent implementations for this structure.\n+                encode_inherent_implementations(ecx, rbml_w, def_id);\n+\n+                if !struct_def.is_struct() {\n+                    let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n+                    rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                         def_to_u64(ctor_did));\n                 }\n-                ty::MethodTraitItem(ref method_type) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           index,\n-                                           &method_type,\n-                                           false,\n-                                           item.id,\n-                                           ast_item)\n+\n+                rbml_w.end_tag();\n+\n+                for field in &variant.fields {\n+                    self.encode_field(rbml_w, field);\n                 }\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    encode_info_for_associated_type(ecx,\n-                                                    rbml_w,\n-                                                    index,\n-                                                    &associated_type,\n-                                                    item.id,\n-                                                    ast_item)\n+\n+                // If this is a tuple-like struct, encode the type of the constructor.\n+                if !struct_def.is_struct() {\n+                    self.encode_info_for_struct_ctor(rbml_w, item.name, struct_def, item.id);\n                 }\n             }\n-        }\n-      }\n-      hir::ItemTrait(_, _, _, ref ms) => {\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'I');\n-        encode_item_variances(rbml_w, ecx, item.id);\n-        let trait_def = tcx.lookup_trait_def(def_id);\n-        let trait_predicates = tcx.lookup_predicates(def_id);\n-        encode_unsafety(rbml_w, trait_def.unsafety);\n-        encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-        encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n-        encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-        encode_generics(rbml_w, ecx, index,\n-                        &trait_def.generics, &trait_predicates);\n-        encode_predicates(rbml_w, index,\n-                          &tcx.lookup_super_predicates(def_id),\n-                          tag_item_super_predicates);\n-        encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(rbml_w, item.name);\n-        encode_attributes(rbml_w, &item.attrs);\n-        encode_visibility(rbml_w, vis);\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-            rbml_w.start_tag(tag_item_trait_item);\n-            match method_def_id {\n-                ty::ConstTraitItemId(const_def_id) => {\n-                    encode_def_id(rbml_w, const_def_id);\n-                    encode_item_sort(rbml_w, 'C');\n+            hir::ItemDefaultImpl(unsafety, _) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'd');\n+                encode_name(rbml_w, item.name);\n+                encode_unsafety(rbml_w, unsafety);\n+\n+                let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n+                encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+                rbml_w.end_tag();\n+            }\n+            hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n+                let _task = self.record(def_id, rbml_w);\n+\n+                // We need to encode information about the default methods we\n+                // have inherited, so we drive this based on the impl structure.\n+                let impl_items = tcx.impl_items.borrow();\n+                let items = impl_items.get(&def_id).unwrap();\n+\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'i');\n+                self.encode_bounds_and_type_for_item(rbml_w, item.id);\n+                encode_name(rbml_w, item.name);\n+                encode_attributes(rbml_w, &item.attrs);\n+                encode_unsafety(rbml_w, unsafety);\n+                encode_polarity(rbml_w, polarity);\n+\n+                match tcx.custom_coerce_unsized_kinds\n+                         .borrow()\n+                         .get(&ecx.tcx.map.local_def_id(item.id)) {\n+                    Some(&kind) => {\n+                        rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                        kind.encode(rbml_w);\n+                        rbml_w.end_tag();\n+                    }\n+                    None => {}\n                 }\n-                ty::MethodTraitItemId(method_def_id) => {\n-                    encode_def_id(rbml_w, method_def_id);\n-                    encode_item_sort(rbml_w, 'r');\n+\n+                for &item_def_id in items {\n+                    rbml_w.start_tag(tag_item_impl_item);\n+                    match item_def_id {\n+                        ty::ConstTraitItemId(item_def_id) => {\n+                            encode_def_id(rbml_w, item_def_id);\n+                            encode_item_sort(rbml_w, 'C');\n+                        }\n+                        ty::MethodTraitItemId(item_def_id) => {\n+                            encode_def_id(rbml_w, item_def_id);\n+                            encode_item_sort(rbml_w, 'r');\n+                        }\n+                        ty::TypeTraitItemId(item_def_id) => {\n+                            encode_def_id(rbml_w, item_def_id);\n+                            encode_item_sort(rbml_w, 't');\n+                        }\n+                    }\n+                    rbml_w.end_tag();\n                 }\n-                ty::TypeTraitItemId(type_def_id) => {\n-                    encode_def_id(rbml_w, type_def_id);\n-                    encode_item_sort(rbml_w, 't');\n+                let did = ecx.tcx.map.local_def_id(item.id);\n+                if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n+                    encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+\n+                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+                    let parent = trait_def.ancestors(did)\n+                                          .skip(1)\n+                                          .next()\n+                                          .and_then(|node| match node {\n+                                              specialization_graph::Node::Impl(parent) =>\n+                                                  Some(parent),\n+                                              _ => None,\n+                                          });\n+                    encode_parent_impl(rbml_w, parent);\n                 }\n-            }\n-            rbml_w.end_tag();\n-\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(method_def_id.def_id()));\n-        }\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                rbml_w.end_tag();\n \n-        // Encode inherent implementations for this trait.\n-        encode_inherent_implementations(ecx, rbml_w, def_id);\n+                // Iterate down the trait items, emitting them. We rely on the\n+                // assumption that all of the actually implemented trait items\n+                // appear first in the impl structure, in the same order they do\n+                // in the ast. This is a little sketchy.\n+                let num_implemented_methods = ast_items.len();\n+                for (i, &trait_item_def_id) in items.iter().enumerate() {\n+                    let ast_item = if i < num_implemented_methods {\n+                        Some(&ast_items[i])\n+                    } else {\n+                        None\n+                    };\n+\n+                    match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n+                        ty::ConstTraitItem(ref associated_const) => {\n+                            self.encode_info_for_associated_const(rbml_w,\n+                                                             &associated_const,\n+                                                             item.id,\n+                                                             ast_item)\n+                        }\n+                        ty::MethodTraitItem(ref method_type) => {\n+                            self.encode_info_for_method(rbml_w,\n+                                                        &method_type,\n+                                                        false,\n+                                                        item.id,\n+                                                        ast_item)\n+                        }\n+                        ty::TypeTraitItem(ref associated_type) => {\n+                            self.encode_info_for_associated_type(rbml_w,\n+                                                                 &associated_type,\n+                                                                 item.id,\n+                                                                 ast_item)\n+                        }\n+                    }\n+                }\n+            }\n+            hir::ItemTrait(_, _, _, ref ms) => {\n+                let _task = self.record(def_id, rbml_w);\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_family(rbml_w, 'I');\n+                encode_item_variances(rbml_w, ecx, item.id);\n+                let trait_def = tcx.lookup_trait_def(def_id);\n+                let trait_predicates = tcx.lookup_predicates(def_id);\n+                encode_unsafety(rbml_w, trait_def.unsafety);\n+                encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n+                encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n+                encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n+                self.encode_generics(rbml_w, &trait_def.generics, &trait_predicates);\n+                self.encode_predicates(rbml_w, &tcx.lookup_super_predicates(def_id), tag_item_super_predicates);\n+                encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+                encode_name(rbml_w, item.name);\n+                encode_attributes(rbml_w, &item.attrs);\n+                self.encode_visibility(rbml_w, vis);\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n+                    rbml_w.start_tag(tag_item_trait_item);\n+                    match method_def_id {\n+                        ty::ConstTraitItemId(const_def_id) => {\n+                            encode_def_id(rbml_w, const_def_id);\n+                            encode_item_sort(rbml_w, 'C');\n+                        }\n+                        ty::MethodTraitItemId(method_def_id) => {\n+                            encode_def_id(rbml_w, method_def_id);\n+                            encode_item_sort(rbml_w, 'r');\n+                        }\n+                        ty::TypeTraitItemId(type_def_id) => {\n+                            encode_def_id(rbml_w, type_def_id);\n+                            encode_item_sort(rbml_w, 't');\n+                        }\n+                    }\n+                    rbml_w.end_tag();\n \n-        rbml_w.end_tag();\n+                    rbml_w.wr_tagged_u64(tag_mod_child,\n+                                         def_to_u64(method_def_id.def_id()));\n+                }\n \n-        // Now output the trait item info for each trait item.\n-        let r = tcx.trait_item_def_ids(def_id);\n-        for (i, &item_def_id) in r.iter().enumerate() {\n-            assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n+                // Encode inherent implementations for this trait.\n+                encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-            let _task = index.record(item_def_id.def_id(), rbml_w);\n-            rbml_w.start_tag(tag_items_data_item);\n+                rbml_w.end_tag();\n \n-            encode_parent_item(rbml_w, def_id);\n+                // Now output the trait item info for each trait item.\n+                let r = tcx.trait_item_def_ids(def_id);\n+                for (i, &item_def_id) in r.iter().enumerate() {\n+                    assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            let stab = tcx.lookup_stability(item_def_id.def_id());\n-            let depr = tcx.lookup_deprecation(item_def_id.def_id());\n-            encode_stability(rbml_w, stab);\n-            encode_deprecation(rbml_w, depr);\n+                    let _task = self.record(item_def_id.def_id(), rbml_w);\n+                    rbml_w.start_tag(tag_items_data_item);\n \n-            let trait_item_type =\n-                tcx.impl_or_trait_item(item_def_id.def_id());\n-            let is_nonstatic_method;\n-            match trait_item_type {\n-                ty::ConstTraitItem(associated_const) => {\n-                    encode_name(rbml_w, associated_const.name);\n-                    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n-                    encode_visibility(rbml_w, associated_const.vis);\n+                    self.encode_parent_item(rbml_w, def_id);\n \n-                    encode_family(rbml_w, 'C');\n+                    let stab = tcx.lookup_stability(item_def_id.def_id());\n+                    let depr = tcx.lookup_deprecation(item_def_id.def_id());\n+                    encode_stability(rbml_w, stab);\n+                    encode_deprecation(rbml_w, depr);\n \n-                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                    ecx.local_id(associated_const.def_id));\n+                    let trait_item_type =\n+                        tcx.impl_or_trait_item(item_def_id.def_id());\n+                    let is_nonstatic_method;\n+                    match trait_item_type {\n+                        ty::ConstTraitItem(associated_const) => {\n+                            encode_name(rbml_w, associated_const.name);\n+                            encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n+                            self.encode_visibility(rbml_w, associated_const.vis);\n \n-                    is_nonstatic_method = false;\n-                }\n-                ty::MethodTraitItem(method_ty) => {\n-                    let method_def_id = item_def_id.def_id();\n+                            encode_family(rbml_w, 'C');\n \n-                    encode_method_ty_fields(ecx, rbml_w, index, &method_ty);\n+                            self.encode_bounds_and_type_for_item(\n+                                rbml_w,\n+                                ecx.local_id(associated_const.def_id));\n \n-                    match method_ty.explicit_self {\n-                        ty::ExplicitSelfCategory::Static => {\n-                            encode_family(rbml_w,\n-                                          STATIC_METHOD_FAMILY);\n+                            is_nonstatic_method = false;\n                         }\n-                        _ => {\n-                            encode_family(rbml_w,\n-                                          METHOD_FAMILY);\n+                        ty::MethodTraitItem(method_ty) => {\n+                            let method_def_id = item_def_id.def_id();\n+\n+                            self.encode_method_ty_fields(rbml_w, &method_ty);\n+\n+                            match method_ty.explicit_self {\n+                                ty::ExplicitSelfCategory::Static => {\n+                                    encode_family(rbml_w,\n+                                                  STATIC_METHOD_FAMILY);\n+                                }\n+                                _ => {\n+                                    encode_family(rbml_w,\n+                                                  METHOD_FAMILY);\n+                                }\n+                            }\n+                            self.encode_bounds_and_type_for_item(rbml_w,\n+                                                                 ecx.local_id(method_def_id));\n+\n+                            is_nonstatic_method = method_ty.explicit_self !=\n+                                ty::ExplicitSelfCategory::Static;\n                         }\n-                    }\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                    ecx.local_id(method_def_id));\n-\n-                    is_nonstatic_method = method_ty.explicit_self !=\n-                        ty::ExplicitSelfCategory::Static;\n-                }\n-                ty::TypeTraitItem(associated_type) => {\n-                    encode_name(rbml_w, associated_type.name);\n-                    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n-                    encode_item_sort(rbml_w, 't');\n-                    encode_family(rbml_w, 'y');\n-\n-                    if let Some(ty) = associated_type.ty {\n-                        encode_type(ecx, rbml_w, ty);\n-                    }\n+                        ty::TypeTraitItem(associated_type) => {\n+                            encode_name(rbml_w, associated_type.name);\n+                            encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n+                            encode_item_sort(rbml_w, 't');\n+                            encode_family(rbml_w, 'y');\n \n-                    is_nonstatic_method = false;\n-                }\n-            }\n+                            if let Some(ty) = associated_type.ty {\n+                                self.encode_type(rbml_w, ty);\n+                            }\n \n-            let trait_item = &ms[i];\n-            encode_attributes(rbml_w, &trait_item.attrs);\n-            match trait_item.node {\n-                hir::ConstTraitItem(_, ref default) => {\n-                    if default.is_some() {\n-                        encode_item_sort(rbml_w, 'C');\n-                    } else {\n-                        encode_item_sort(rbml_w, 'c');\n+                            is_nonstatic_method = false;\n+                        }\n                     }\n \n-                    encode_inlined_item(ecx, rbml_w,\n-                                        InlinedItemRef::TraitItem(def_id, trait_item));\n-                    encode_mir(ecx, rbml_w, trait_item.id);\n-                }\n-                hir::MethodTraitItem(ref sig, ref body) => {\n-                    // If this is a static method, we've already\n-                    // encoded this.\n-                    if is_nonstatic_method {\n-                        // FIXME: I feel like there is something funny\n-                        // going on.\n-                        encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                        ecx.local_id(item_def_id.def_id()));\n-                    }\n+                    let trait_item = &ms[i];\n+                    encode_attributes(rbml_w, &trait_item.attrs);\n+                    match trait_item.node {\n+                        hir::ConstTraitItem(_, ref default) => {\n+                            if default.is_some() {\n+                                encode_item_sort(rbml_w, 'C');\n+                            } else {\n+                                encode_item_sort(rbml_w, 'c');\n+                            }\n+\n+                            encode_inlined_item(ecx, rbml_w,\n+                                                InlinedItemRef::TraitItem(def_id, trait_item));\n+                            self.encode_mir(rbml_w, trait_item.id);\n+                        }\n+                        hir::MethodTraitItem(ref sig, ref body) => {\n+                            // If this is a static method, we've already\n+                            // encoded this.\n+                            if is_nonstatic_method {\n+                                self.encode_bounds_and_type_for_item(\n+                                    rbml_w,\n+                                    ecx.local_id(item_def_id.def_id()));\n+                            }\n+\n+                            if body.is_some() {\n+                                encode_item_sort(rbml_w, 'p');\n+                                encode_inlined_item(ecx, rbml_w,\n+                                                    InlinedItemRef::TraitItem(def_id, trait_item));\n+                                self.encode_mir(rbml_w, trait_item.id);\n+                            } else {\n+                                encode_item_sort(rbml_w, 'r');\n+                            }\n+                            self.encode_method_argument_names(rbml_w, &sig.decl);\n+                        }\n \n-                    if body.is_some() {\n-                        encode_item_sort(rbml_w, 'p');\n-                        encode_inlined_item(ecx, rbml_w,\n-                                            InlinedItemRef::TraitItem(def_id, trait_item));\n-                        encode_mir(ecx, rbml_w, trait_item.id);\n-                    } else {\n-                        encode_item_sort(rbml_w, 'r');\n+                        hir::TypeTraitItem(..) => {}\n                     }\n-                    encode_method_argument_names(rbml_w, &sig.decl);\n-                }\n \n-                hir::TypeTraitItem(..) => {}\n+                    rbml_w.end_tag();\n+                }\n+            }\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n+                // these are encoded separately\n             }\n-\n-            rbml_w.end_tag();\n         }\n-      }\n-      hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n-        // these are encoded separately\n-      }\n     }\n }\n \n-fn encode_info_for_foreign_item<'a, 'tcx>(rbml_w: &mut Encoder,\n-                                          nitem: &hir::ForeignItem,\n-                                          index: &mut IndexBuilder<'a, 'tcx>) {\n-    let ecx = index.ecx();\n-\n-    debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n-    let def_id = ecx.tcx.map.local_def_id(nitem.id);\n-    let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n-\n-    let _task = index.record(def_id, rbml_w);\n-    rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id_and_key(ecx, rbml_w, def_id);\n-    let parent_id = ecx.tcx.map.get_parent(nitem.id);\n-    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n-    encode_visibility(rbml_w, &nitem.vis);\n-    match nitem.node {\n-      hir::ForeignItemFn(ref fndecl, _) => {\n-        encode_family(rbml_w, FN_FAMILY);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n-        encode_name(rbml_w, nitem.name);\n-        if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n-            encode_mir(ecx, rbml_w, nitem.id);\n-        }\n-        encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_method_argument_names(rbml_w, &fndecl);\n-      }\n-      hir::ForeignItemStatic(_, mutbl) => {\n-        if mutbl {\n-            encode_family(rbml_w, 'b');\n-        } else {\n-            encode_family(rbml_w, 'c');\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_info_for_foreign_item(&mut self,\n+                                    rbml_w: &mut Encoder,\n+                                    nitem: &hir::ForeignItem) {\n+        let ecx = self.ecx();\n+\n+        debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n+        let def_id = ecx.tcx.map.local_def_id(nitem.id);\n+        let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n+\n+        let _task = self.record(def_id, rbml_w);\n+        rbml_w.start_tag(tag_items_data_item);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n+        let parent_id = ecx.tcx.map.get_parent(nitem.id);\n+        self.encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n+        self.encode_visibility(rbml_w, &nitem.vis);\n+        match nitem.node {\n+            hir::ForeignItemFn(ref fndecl, _) => {\n+                encode_family(rbml_w, FN_FAMILY);\n+                self.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n+                encode_name(rbml_w, nitem.name);\n+                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                    encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n+                    self.encode_mir(rbml_w, nitem.id);\n+                }\n+                encode_attributes(rbml_w, &nitem.attrs);\n+                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                self.encode_method_argument_names(rbml_w, &fndecl);\n+            }\n+            hir::ForeignItemStatic(_, mutbl) => {\n+                if mutbl {\n+                    encode_family(rbml_w, 'b');\n+                } else {\n+                    encode_family(rbml_w, 'c');\n+                }\n+                self.encode_bounds_and_type_for_item(rbml_w, nitem.id);\n+                encode_attributes(rbml_w, &nitem.attrs);\n+                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                encode_stability(rbml_w, stab);\n+                encode_deprecation(rbml_w, depr);\n+                encode_name(rbml_w, nitem.name);\n+            }\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n-        encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-        encode_stability(rbml_w, stab);\n-        encode_deprecation(rbml_w, depr);\n-        encode_name(rbml_w, nitem.name);\n-      }\n+        rbml_w.end_tag();\n     }\n-    rbml_w.end_tag();\n }\n \n struct EncodeVisitor<'a, 'data:'a, 'ecx: 'a, 'tcx: 'ecx> {\n-    rbml_w_for_visit_item: &'a mut Encoder<'data>,\n+    rbml_w: &'a mut Encoder<'data>,\n     index: &'a mut IndexBuilder<'ecx, 'tcx>,\n }\n \n impl<'a, 'data, 'ecx, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'data, 'ecx, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n-        encode_info_for_expr(ex, self.rbml_w_for_visit_item, self.index);\n+        self.index.encode_info_for_expr(ex, self.rbml_w);\n     }\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         intravisit::walk_item(self, i);\n-        encode_info_for_item(self.rbml_w_for_visit_item, i, self.index);\n+        self.index.encode_info_for_item(self.rbml_w, i);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        encode_info_for_foreign_item(self.rbml_w_for_visit_item, ni, self.index);\n+        self.index.encode_info_for_foreign_item(self.rbml_w, ni);\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n         encode_info_for_ty(ty, self.rbml_w_for_visit_item, self.index);\n     }\n }\n \n-fn encode_info_for_ty(ty: &hir::Ty,\n-                      rbml_w: &mut Encoder,\n-                      index: &mut IndexBuilder) {\n-    let ecx = index.ecx();\n-    if let hir::TyImplTrait(_) = ty.node {\n-        let def_id = ecx.tcx.map.local_def_id(ty.id);\n-        let _task = index.record(def_id, rbml_w);\n-        rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id_and_key(ecx, rbml_w, def_id);\n-        encode_family(rbml_w, 'y');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, ty.id);\n-        rbml_w.end_tag();\n+impl<'a, 'tcx> IndexBuilder<'a, 'tcx> {\n+    fn encode_info_for_ty(&mut self,\n+                          ty: &hir::Ty,\n+                          rbml_w: &mut Encoder) {\n+        let ecx = self.ecx();\n+        if let hir::TyImplTrait(_) = ty.node {\n+            let def_id = ecx.tcx.map.local_def_id(ty.id);\n+            let _task = self.record(def_id, rbml_w);\n+            rbml_w.start_tag(tag_items_data_item);\n+            encode_def_id_and_key(ecx, rbml_w, def_id);\n+            encode_family(rbml_w, 'y');\n+            self.encode_bounds_and_type_for_item(rbml_w, ecx, ty.id);\n+            rbml_w.end_tag();\n+        }\n     }\n-}\n \n-fn encode_info_for_expr(expr: &hir::Expr,\n-                        rbml_w: &mut Encoder,\n-                        index: &mut IndexBuilder) {\n-    let ecx = index.ecx();\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr, rbml_w: &mut Encoder) {\n+        let ecx = self.ecx();\n \n-    match expr.node {\n-        hir::ExprClosure(..) => {\n-            let def_id = ecx.tcx.map.local_def_id(expr.id);\n+        match expr.node {\n+            hir::ExprClosure(..) => {\n+                let def_id = ecx.tcx.map.local_def_id(expr.id);\n \n-            let _task = index.record(def_id, rbml_w);\n+                let _task = self.record(def_id, rbml_w);\n \n-            rbml_w.start_tag(tag_items_data_item);\n-            encode_def_id_and_key(ecx, rbml_w, def_id);\n-            encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n+                rbml_w.start_tag(tag_items_data_item);\n+                encode_def_id_and_key(ecx, rbml_w, def_id);\n+                encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n \n-            rbml_w.start_tag(tag_items_closure_ty);\n-            write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n-            rbml_w.end_tag();\n+                rbml_w.start_tag(tag_items_closure_ty);\n+                write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+                rbml_w.end_tag();\n \n-            rbml_w.start_tag(tag_items_closure_kind);\n-            ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n-            rbml_w.end_tag();\n+                rbml_w.start_tag(tag_items_closure_kind);\n+                ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n+                rbml_w.end_tag();\n \n-            assert!(ecx.mir_map.map.contains_key(&def_id));\n-            encode_mir(ecx, rbml_w, expr.id);\n+                assert!(ecx.mir_map.map.contains_key(&def_id));\n+                self.encode_mir(rbml_w, expr.id);\n \n-            rbml_w.end_tag();\n+                rbml_w.end_tag();\n+            }\n+            _ => { }\n         }\n-        _ => { }\n     }\n }\n \n@@ -1364,18 +1371,17 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &'a EncodeContext<'a, 'tcx>,\n \n     {\n         let _task = index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n-        encode_info_for_mod(ecx,\n-                            rbml_w,\n-                            &krate.module,\n-                            &[],\n-                            CRATE_NODE_ID,\n-                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                            &hir::Public);\n+        index.encode_info_for_mod(rbml_w,\n+                                  &krate.module,\n+                                  &[],\n+                                  CRATE_NODE_ID,\n+                                  syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                                  &hir::Public);\n     }\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,\n-        rbml_w_for_visit_item: &mut *rbml_w,\n+        rbml_w: &mut *rbml_w,\n     });\n \n     rbml_w.end_tag();"}]}