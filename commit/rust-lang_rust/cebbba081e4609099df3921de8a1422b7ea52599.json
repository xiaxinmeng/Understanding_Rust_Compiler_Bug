{"sha": "cebbba081e4609099df3921de8a1422b7ea52599", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYmJiYTA4MWU0NjA5MDk5ZGYzOTIxZGU4YTE0MjJiN2VhNTI1OTk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-30T16:47:51Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-15T18:32:10Z"}, "message": "Only store a LocalDefId in hir::Item.\n\nItems are guaranteed to be HIR owner.", "tree": {"sha": "96784e4ada9c7d62e8890ce8bac2d4f840eba6c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96784e4ada9c7d62e8890ce8bac2d4f840eba6c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cebbba081e4609099df3921de8a1422b7ea52599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cebbba081e4609099df3921de8a1422b7ea52599", "html_url": "https://github.com/rust-lang/rust/commit/cebbba081e4609099df3921de8a1422b7ea52599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cebbba081e4609099df3921de8a1422b7ea52599/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd3cd5dbed5f56fb44a14a20dd2113e3049d2565", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd3cd5dbed5f56fb44a14a20dd2113e3049d2565", "html_url": "https://github.com/rust-lang/rust/commit/bd3cd5dbed5f56fb44a14a20dd2113e3049d2565"}], "stats": {"total": 1048, "additions": 483, "deletions": 565}, "files": [{"sha": "8750c2654c5f52b2a5a440ca8779c30b12cce612", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -197,7 +197,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         node_ids\n             .into_iter()\n-            .map(|node_id| hir::ItemId { id: self.allocate_hir_id_counter(node_id) })\n+            .map(|node_id| hir::ItemId {\n+                def_id: self.allocate_hir_id_counter(node_id).expect_owner(),\n+            })\n             .collect()\n     }\n \n@@ -250,7 +252,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n \n-        Some(hir::Item { hir_id: self.lower_node_id(i.id), ident, attrs, kind, vis, span: i.span })\n+        Some(hir::Item {\n+            def_id: self.lower_node_id(i.id).expect_owner(),\n+            ident,\n+            attrs,\n+            kind,\n+            vis,\n+            span: i.span,\n+        })\n     }\n \n     fn lower_item_kind(\n@@ -557,7 +566,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(hir::Item {\n-                            hir_id: new_id,\n+                            def_id: new_id.expect_owner(),\n                             ident,\n                             attrs,\n                             kind,\n@@ -629,7 +638,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n \n                         this.insert_item(hir::Item {\n-                            hir_id: new_hir_id,\n+                            def_id: new_hir_id.expect_owner(),\n                             ident,\n                             attrs,\n                             kind,"}, {"sha": "3cb214464c024418ef460b04b24a57cb9f4c7ba3", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -606,10 +606,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n-        let id = item.hir_id;\n-        // FIXME: Use `debug_asset-rt`.\n-        assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n-        let id = hir::ItemId { id };\n+        let id = hir::ItemId { def_id: item.def_id };\n         self.items.insert(id, item);\n         self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n         id\n@@ -1549,29 +1546,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            let opaque_ty_id =\n-                lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n+            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, lifetimes)\n+            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n         })\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n     /// returns the lowered node-ID for the opaque type.\n     fn generate_opaque_type(\n         &mut self,\n-        opaque_ty_node_id: NodeId,\n+        opaque_ty_id: LocalDefId,\n         opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n-    ) -> hir::HirId {\n+    ) {\n         let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n-        let opaque_ty_id = self.lower_node_id(opaque_ty_node_id);\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            hir_id: opaque_ty_id,\n+            def_id: opaque_ty_id,\n             ident: Ident::invalid(),\n             attrs: Default::default(),\n             kind: opaque_ty_item_kind,\n@@ -1583,7 +1578,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // automatically for all AST items. But this opaque type item\n         // does not actually exist in the AST.\n         self.insert_item(opaque_ty_item);\n-        opaque_ty_id\n     }\n \n     fn lifetimes_from_impl_trait_bounds(\n@@ -2012,7 +2006,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // grow.\n         let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n \n-        let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+        let lifetime_params = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -2063,10 +2057,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            let opaque_ty_id =\n-                this.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n+            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n-            (opaque_ty_id, lifetime_params)\n+            lifetime_params\n         });\n \n         // As documented above on the variable\n@@ -2109,7 +2102,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        let opaque_ty_ref =\n+            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n@@ -2434,7 +2428,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n-                        let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n+                        let item_id = hir::ItemId {\n+                            // All the items that `lower_local` finds are `impl Trait` types.\n+                            def_id: self.lower_node_id(item_id).expect_owner(),\n+                        };\n                         self.stmt(s.span, hir::StmtKind::Item(item_id))\n                     })\n                     .collect();"}, {"sha": "b2e201c5ff2a8c5a145df807252589eaced1be8a", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -237,7 +237,7 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::AnnNode::Name(_) => {}\n             pprust_hir::AnnNode::Item(item) => {\n                 s.s.space();\n-                s.synth_comment(format!(\"hir_id: {}\", item.hir_id));\n+                s.synth_comment(format!(\"hir_id: {}\", item.hir_id()));\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n                 s.s.space();"}, {"sha": "2abb8fb27312574ebbc5ad3641eee5bbcef8aa9e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -2543,12 +2543,13 @@ impl VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug, Hash)]\n pub struct ItemId {\n-    pub id: HirId,\n+    pub def_id: LocalDefId,\n }\n \n impl ItemId {\n     pub fn hir_id(&self) -> HirId {\n-        self.id\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n     }\n }\n \n@@ -2558,16 +2559,21 @@ impl ItemId {\n #[derive(Debug)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub attrs: &'hir [Attribute],\n     pub kind: ItemKind<'hir>,\n     pub vis: Visibility<'hir>,\n     pub span: Span,\n }\n \n impl Item<'_> {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n     pub fn item_id(&self) -> ItemId {\n-        ItemId { id: self.hir_id }\n+        ItemId { def_id: self.def_id }\n     }\n }\n \n@@ -2879,8 +2885,8 @@ impl<'hir> Node<'hir> {\n \n     pub fn hir_id(&self) -> Option<HirId> {\n         match self {\n-            Node::Item(Item { hir_id, .. })\n-            | Node::ForeignItem(ForeignItem { hir_id, .. })\n+            Node::Item(Item { def_id, .. }) => Some(HirId::make_owner(*def_id)),\n+            Node::ForeignItem(ForeignItem { hir_id, .. })\n             | Node::TraitItem(TraitItem { hir_id, .. })\n             | Node::ImplItem(ImplItem { hir_id, .. })\n             | Node::Field(StructField { hir_id, .. })\n@@ -2915,7 +2921,7 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n \n-    rustc_data_structures::static_assert_size!(super::Item<'static>, 208);\n+    rustc_data_structures::static_assert_size!(super::Item<'static>, 200);\n     rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 152);\n     rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 168);\n     rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 160);"}, {"sha": "dd5cddd8525c1bcf5a5b0d59825ae0195fdaabb8", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -18,6 +18,21 @@ pub struct HirId {\n     pub local_id: ItemLocalId,\n }\n \n+impl HirId {\n+    pub fn expect_owner(self) -> LocalDefId {\n+        assert_eq!(self.local_id.index(), 0);\n+        self.owner\n+    }\n+\n+    pub fn as_owner(self) -> Option<LocalDefId> {\n+        if self.local_id.index() == 0 { Some(self.owner) } else { None }\n+    }\n+\n+    pub fn make_owner(owner: LocalDefId) -> Self {\n+        Self { owner, local_id: ItemLocalId::from_u32(0) }\n+    }\n+}\n+\n impl fmt::Display for HirId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self)"}, {"sha": "e492cef7733aec85541f40a8498ed28ea8b7f80a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -565,16 +565,16 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     visitor.visit_ident(item.ident);\n     match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemKind::Use(ref path, _) => {\n-            visitor.visit_use(path, item.hir_id);\n+            visitor.visit_use(path, item.hir_id());\n         }\n         ItemKind::Static(ref typ, _, body) | ItemKind::Const(ref typ, body) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n@@ -583,33 +583,33 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             &sig.decl,\n             body_id,\n             item.span,\n-            item.hir_id,\n+            item.hir_id(),\n         ),\n         ItemKind::Mod(ref module) => {\n             // `visit_mod()` takes care of visiting the `Item`'s `HirId`.\n-            visitor.visit_mod(module, item.span, item.hir_id)\n+            visitor.visit_mod(module, item.span, item.hir_id())\n         }\n         ItemKind::ForeignMod { abi: _, items } => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             walk_list!(visitor, visit_foreign_item_ref, items);\n         }\n         ItemKind::GlobalAsm(_) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n         }\n         ItemKind::TyAlias(ref ty, ref generics) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n         ItemKind::OpaqueTy(OpaqueTy { ref generics, bounds, .. }) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n         ItemKind::Enum(ref enum_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             // `visit_enum_def()` takes care of visiting the `Item`'s `HirId`.\n-            visitor.visit_enum_def(enum_definition, generics, item.hir_id, item.span)\n+            visitor.visit_enum_def(enum_definition, generics, item.hir_id(), item.span)\n         }\n         ItemKind::Impl(Impl {\n             unsafety: _,\n@@ -622,7 +622,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             ref self_ty,\n             items,\n         }) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n@@ -631,23 +631,23 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_variant_data(\n                 struct_definition,\n                 item.ident.name,\n                 generics,\n-                item.hir_id,\n+                item.hir_id(),\n                 item.span,\n             );\n         }\n         ItemKind::Trait(.., ref generics, bounds, trait_item_refs) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n         ItemKind::TraitAlias(ref generics, bounds) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }"}, {"sha": "b0d332e0028f037c520fd6caa5823538473a781b", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -35,11 +35,11 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n@@ -91,7 +91,7 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n@@ -178,7 +178,7 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Item { ident, ref attrs, hir_id: _, ref kind, ref vis, span } = *self;\n+        let Item { ident, ref attrs, def_id: _, ref kind, ref vis, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);"}, {"sha": "6c0f0542e0c2cc4dcf514ddd85dd3ae28ad3fec8", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -167,7 +167,7 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id, &item.attrs);\n+        self.process_attrs(item.hir_id(), &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n "}, {"sha": "518ab78ea68b41e766584a0f6371893eddffe37a", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -450,7 +450,7 @@ impl DirtyCleanVisitor<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.hir_id(), item.span);\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem<'_>) {"}, {"sha": "d0262935c894cc8b035718092ea0169ec3352a84", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -26,7 +26,7 @@ struct Finder<'tcx> {\n impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if self.tcx.sess.contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n-            self.decls = Some(item.hir_id);\n+            self.decls = Some(item.hir_id());\n         }\n     }\n "}, {"sha": "baab339a3240f9e2731b9c1181b0041c88460b32", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -36,9 +36,9 @@ use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, Att\n use rustc_feature::{GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n-use rustc_hir::{HirId, HirIdSet, Node};\n+use rustc_hir::{HirId, Node};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -173,8 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..) => {\n-                let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-                self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.def_id))\n             }\n             _ => (),\n         }\n@@ -585,7 +584,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n-                    self.private_traits.insert(it.hir_id);\n+                    self.private_traits.insert(it.hir_id());\n                     for trait_item_ref in trait_item_refs {\n                         self.private_traits.insert(trait_item_ref.id.hir_id);\n                     }\n@@ -621,10 +620,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n+        self.check_missing_docs_attrs(cx, Some(it.hir_id()), &it.attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n@@ -732,29 +730,29 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id()) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -812,14 +810,14 @@ declare_lint! {\n \n #[derive(Default)]\n pub struct MissingDebugImplementations {\n-    impling_types: Option<HirIdSet>,\n+    impling_types: Option<LocalDefIdSet>,\n }\n \n impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id()) {\n             return;\n         }\n \n@@ -834,11 +832,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let mut impls = HirIdSet::default();\n+            let mut impls = LocalDefIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n                     if let Some(def_id) = ty_def.did.as_local() {\n-                        impls.insert(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n+                        impls.insert(def_id);\n                     }\n                 }\n             });\n@@ -847,7 +845,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.def_id) {\n             cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n                 lint.build(&format!(\n                     \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n@@ -1362,7 +1360,7 @@ impl UnreachablePub {\n \n impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n+        self.perform_lint(cx, \"item\", item.hir_id(), &item.vis, item.span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n@@ -1603,8 +1601,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            let predicates = cx.tcx.predicates_of(def_id);\n+            let predicates = cx.tcx.predicates_of(item.def_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n                     Trait(..) => \"Trait\",\n@@ -1810,7 +1807,7 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: Option<hir::HirId>, // HirId of the item under which things are not nameable\n+    boundary: Option<LocalDefId>, // Id of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n@@ -1828,7 +1825,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = Some(it.hir_id);\n+                self.boundary = Some(it.def_id);\n             }\n             return;\n         }\n@@ -1841,7 +1838,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == Some(it.hir_id) {\n+        if !self.items_nameable && self.boundary == Some(it.def_id) {\n             self.items_nameable = true;\n         }\n     }\n@@ -2125,7 +2122,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+        let def_id = item.def_id;\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n         | hir::ItemKind::Enum(_, ref hir_generics)\n         | hir::ItemKind::Union(_, ref hir_generics) = item.kind"}, {"sha": "860fa7fd8e39ca0bcc1c6581f7de01cc07df3819", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -142,8 +142,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         self.context.generics = it.kind.generics();\n         let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let old_enclosing_body = self.context.enclosing_body.take();\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n+        self.with_lint_attrs(it.hir_id(), &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 lint_callback!(cx, check_item_post, it);"}, {"sha": "18ed350e672fbc803546caa8ce5a7e87dee0e37f", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -577,7 +577,7 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }"}, {"sha": "e632f29e672c08126edec6d1eb02b4a75d8d15f6", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -47,8 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::PredicateKind::*;\n \n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-        let predicates = cx.tcx.explicit_predicates_of(def_id);\n+        let predicates = cx.tcx.explicit_predicates_of(item.def_id);\n         for &(predicate, span) in predicates.predicates {\n             let trait_predicate = match predicate.kind().skip_binder() {\n                 Trait(trait_predicate, _constness) => trait_predicate,"}, {"sha": "55ed0a7156c24d390b8ffc9890be8c7b72167e8a", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1308,8 +1308,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n-            let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-            let t = cx.tcx.type_of(item_def_id);\n+            let t = cx.tcx.type_of(it.def_id);\n             let ty = cx.tcx.erase_regions(t);\n             let layout = match cx.layout_of(ty) {\n                 Ok(layout) => layout,"}, {"sha": "f1ab8e1961adb20cc9665a6794924be4ed7dfe82", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -23,10 +23,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n \n         let foreign_items =\n             items.iter().map(|it| self.tcx.hir().local_def_id(it.id.hir_id).to_def_id()).collect();\n-        self.modules.push(ForeignModule {\n-            foreign_items,\n-            def_id: self.tcx.hir().local_def_id(it.hir_id).to_def_id(),\n-        });\n+        self.modules.push(ForeignModule { foreign_items, def_id: it.def_id.to_def_id() });\n     }\n \n     fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}"}, {"sha": "4d63b6d074af0fc581a18332882d170d2c4ae45d", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -53,7 +53,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 name: None,\n                 kind: NativeLibKind::Unspecified,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id).to_def_id()),\n+                foreign_module: Some(it.def_id.to_def_id()),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "33e6696970e5260c1ae56bcae6ddf8758cd7eaa7", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -7,7 +7,9 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{\n+    CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE,\n+};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -431,7 +433,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module);\n+        self.encode_info_for_mod(CRATE_DEF_ID, &krate.item.module);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -932,9 +934,8 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_inferred_outlives(def_id);\n     }\n \n-    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>) {\n+    fn encode_info_for_mod(&mut self, local_def_id: LocalDefId, md: &hir::Mod<'_>) {\n         let tcx = self.tcx;\n-        let local_def_id = tcx.hir().local_def_id(id);\n         let def_id = local_def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n@@ -969,7 +970,7 @@ impl EncodeContext<'a, 'tcx> {\n             record!(self.tables.children[def_id] <- &[]);\n         } else {\n             record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).local_def_index\n+                item_id.def_id.local_def_index\n             }));\n         }\n     }\n@@ -1312,7 +1313,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.hir_id, m);\n+                return self.encode_info_for_mod(item.def_id, m);\n             }\n             hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1850,10 +1851,9 @@ impl Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(def_id.to_def_id(), item),\n+            _ => self.encode_info_for_item(item.def_id.to_def_id(), item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n@@ -1920,7 +1920,6 @@ impl EncodeContext<'a, 'tcx> {\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n@@ -1936,7 +1935,7 @@ impl EncodeContext<'a, 'tcx> {\n                 // no sub-item recording needed in these cases\n             }\n             hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n \n                 for (i, variant) in def.variants.iter_enumerated() {\n@@ -1948,7 +1947,7 @@ impl EncodeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let def = self.tcx.adt_def(def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n \n                 // If the struct has a constructor, encode it.\n@@ -1958,18 +1957,19 @@ impl EncodeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n-                let def = self.tcx.adt_def(def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n             }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(def_id.to_def_id()).iter()\n+                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n                 {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(def_id.to_def_id()).iter() {\n+                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                {\n                     self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n@@ -1985,15 +1985,14 @@ struct ImplVisitor<'tcx> {\n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n-            let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id.to_def_id()) {\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id.to_def_id()) {\n                 let simplified_self_ty =\n                     ty::fast_reject::simplify_type(self.tcx, trait_ref.self_ty(), false);\n \n                 self.impls\n                     .entry(trait_ref.def_id)\n                     .or_default()\n-                    .push((impl_id.local_def_index, simplified_self_ty));\n+                    .push((item.def_id.local_def_index, simplified_self_ty));\n             }\n         }\n     }"}, {"sha": "3f323eb76c45e73511ec66e2886a009f2f12438f", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -215,7 +215,7 @@ impl<'a> FnLikeNode<'a> {\n         match self.node {\n             Node::Item(i) => match i.kind {\n                 hir::ItemKind::Fn(ref sig, ref generics, block) => item_fn(ItemFnParts {\n-                    id: i.hir_id,\n+                    id: i.hir_id(),\n                     ident: i.ident,\n                     decl: &sig.decl,\n                     body: block,"}, {"sha": "31446f4ef7d2f25f074f091afa36b947015ec3a8", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -338,13 +338,10 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n-        debug_assert_eq!(\n-            i.hir_id.owner,\n-            self.definitions.opt_hir_id_to_local_def_id(i.hir_id).unwrap()\n-        );\n-        self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n-            this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n-            this.with_parent(i.hir_id, |this| {\n+        self.with_dep_node_owner(i.def_id, i, |this, hash| {\n+            let hir_id = i.hir_id();\n+            this.insert_with_hash(i.span, hir_id, Node::Item(i), hash);\n+            this.with_parent(hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                     // If this is a tuple or unit-like struct, register the constructor.\n                     if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {"}, {"sha": "948e6e60c56d51d4fcaf02b9724cd6efea0310bf", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -301,7 +301,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        match self.find(id.id).unwrap() {\n+        match self.find(id.hir_id()).unwrap() {\n             Node::Item(item) => item,\n             _ => bug!(),\n         }"}, {"sha": "5ef70a89051eaf1764ecfef051b12e5abced0c66", "filename": "compiler/rustc_middle/src/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -55,8 +55,7 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n         let item_ids_hash = item_ids\n             .iter()\n             .map(|id| {\n-                let (def_path_hash, local_id) = id.to_stable_hash_key(hcx);\n-                debug_assert_eq!(local_id, hir::ItemLocalId::from_u32(0));\n+                let def_path_hash = id.to_stable_hash_key(hcx);\n                 def_path_hash.0\n             })\n             .fold(Fingerprint::ZERO, |a, b| a.combine_commutative(b));"}, {"sha": "6c2468b9ffe0b1c937d2a1fc53d5fb331d35668d", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -72,8 +72,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => tcx.symbol_name(Instance::mono(tcx, def_id)),\n             MonoItem::GlobalAsm(item_id) => {\n-                let def_id = tcx.hir().local_def_id(item_id.hir_id());\n-                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", def_id))\n+                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", item_id.def_id))\n             }\n         }\n     }"}, {"sha": "286041a7c548bc20670fcc72292deb0f93c819ce", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -2107,11 +2107,9 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n             continue;\n         }\n \n-        if let Some(local_def_id) = hir.definitions().opt_hir_id_to_local_def_id(item.hir_id) {\n-            let def_id = local_def_id.to_def_id();\n-            let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);\n-            collect_fn(&item.ident, ns, def_id);\n-        }\n+        let def_id = item.def_id.to_def_id();\n+        let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);\n+        collect_fn(&item.ident, ns, def_id);\n     }\n \n     // Now take care of extern crate items."}, {"sha": "b32a8c45f1a5f4c9153956f131fdff115c72e414", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1013,13 +1013,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             | hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n-                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         debug!(\n                             \"RootCollector: ADT drop-glue for {}\",\n-                            self.tcx.def_path_str(def_id.to_def_id())\n+                            self.tcx.def_path_str(item.def_id.to_def_id())\n                         );\n \n-                        let ty = Instance::new(def_id.to_def_id(), InternalSubsts::empty())\n+                        let ty = Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n                             .ty(self.tcx, ty::ParamEnv::reveal_all());\n                         visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                     }\n@@ -1028,29 +1027,28 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::GlobalAsm(..) => {\n                 debug!(\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n+                    self.tcx.def_path_str(item.def_id.to_def_id())\n                 );\n                 self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.item_id())));\n             }\n             hir::ItemKind::Static(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n-                debug!(\"RootCollector: ItemKind::Static({})\", self.tcx.def_path_str(def_id));\n-                self.output.push(dummy_spanned(MonoItem::Static(def_id)));\n+                debug!(\n+                    \"RootCollector: ItemKind::Static({})\",\n+                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                );\n+                self.output.push(dummy_spanned(MonoItem::Static(item.def_id.to_def_id())));\n             }\n             hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n-                if let Ok(val) = self.tcx.const_eval_poly(def_id.to_def_id()) {\n+                if let Ok(val) = self.tcx.const_eval_poly(item.def_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                self.push_if_root(def_id);\n+                self.push_if_root(item.def_id);\n             }\n         }\n     }\n@@ -1156,14 +1154,12 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 }\n             }\n \n-            let impl_def_id = tcx.hir().local_def_id(item.hir_id);\n-\n             debug!(\n                 \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(impl_def_id.to_def_id())\n+                tcx.def_path_str(item.def_id.to_def_id())\n             );\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+            if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> ="}, {"sha": "edd46310f20d4f3fc28f5feecdce99ba1cdbf603", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -314,7 +314,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(tcx.hir().local_def_id(item_id.hir_id()).to_def_id()),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.to_def_id()),\n     }\n }\n \n@@ -406,10 +406,9 @@ fn mono_item_visibility(\n             };\n         }\n         MonoItem::GlobalAsm(item_id) => {\n-            let def_id = tcx.hir().local_def_id(item_id.hir_id());\n-            return if tcx.is_reachable_non_generic(def_id) {\n+            return if tcx.is_reachable_non_generic(item_id.def_id) {\n                 *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), false)\n+                default_visibility(tcx, item_id.def_id.to_def_id(), false)\n             } else {\n                 Visibility::Hidden\n             };"}, {"sha": "3c12f64ed21be6f77aae34f70a66edf9c8d65e39", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1058,7 +1058,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let target = Target::from_item(item);\n         self.check_attributes(\n-            item.hir_id,\n+            item.hir_id(),\n             item.attrs,\n             &item.span,\n             target,"}, {"sha": "559fd4d6ea573c57c01d9d9aae0faa4b98ff6aa1", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -188,8 +188,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         match node {\n             Node::Item(item) => match item.kind {\n                 hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    let def = self.tcx.adt_def(def_id);\n+                    let def = self.tcx.adt_def(item.def_id);\n                     self.repr_has_repr_c = def.repr.c();\n \n                     intravisit::walk_item(self, &item);\n@@ -395,9 +394,10 @@ struct LifeSeeder<'k, 'tcx> {\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id, &item.attrs);\n+        let allow_dead_code =\n+            has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id(), &item.attrs);\n         if allow_dead_code {\n-            self.worklist.push(item.hir_id);\n+            self.worklist.push(item.hir_id());\n         }\n         match item.kind {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n@@ -413,7 +413,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             }\n             hir::ItemKind::Impl(hir::Impl { ref of_trait, items, .. }) => {\n                 if of_trait.is_some() {\n-                    self.worklist.push(item.hir_id);\n+                    self.worklist.push(item.hir_id());\n                 }\n                 for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n@@ -430,7 +430,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n                 if let Some(ctor_hir_id) = variant_data.ctor_hir_id() {\n-                    self.struct_constructors.insert(ctor_hir_id, item.hir_id);\n+                    self.struct_constructors.insert(ctor_hir_id, item.hir_id());\n                 }\n             }\n             _ => (),\n@@ -525,7 +525,7 @@ impl DeadVisitor<'tcx> {\n                 | hir::ItemKind::Struct(..)\n                 | hir::ItemKind::Union(..)\n         );\n-        should_warn && !self.symbol_is_live(item.hir_id)\n+        should_warn && !self.symbol_is_live(item.hir_id())\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField<'_>) -> bool {\n@@ -627,7 +627,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 hir::ItemKind::Struct(..) => \"constructed\", // Issue #52325\n                 _ => \"used\",\n             };\n-            self.warn_dead_code(item.hir_id, span, item.ident.name, participle);\n+            self.warn_dead_code(item.hir_id(), span, item.ident.name, participle);\n         } else {\n             // Only continue if we didn't warn\n             intravisit::walk_item(self, item);"}, {"sha": "919dc8864dcb99df21865522f3f798526f8365bb", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -27,7 +27,7 @@ struct DiagnosticItemCollector<'tcx> {\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.observe_item(&item.attrs, item.hir_id);\n+        self.observe_item(&item.attrs, item.hir_id());\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {"}, {"sha": "0d3a7ea3a8a00cbe3ee33bcb69b01a5f6c5cacdd", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -32,8 +32,7 @@ struct EntryContext<'a, 'tcx> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n-        let def_id = self.map.local_def_id(item.hir_id);\n-        let def_key = self.map.def_key(def_id);\n+        let def_key = self.map.def_key(item.def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n@@ -116,18 +115,18 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         }\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n-                ctxt.main_fn = Some((item.hir_id, item.span));\n+                ctxt.main_fn = Some((item.hir_id(), item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0136, \"multiple `main` functions\")\n                     .emit();\n             }\n         }\n         EntryPointType::OtherMain => {\n-            ctxt.non_main_fns.push((item.hir_id, item.span));\n+            ctxt.non_main_fns.push((item.hir_id(), item.span));\n         }\n         EntryPointType::MainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((item.hir_id, item.span));\n+                ctxt.attr_main_fn = Some((item.hir_id(), item.span));\n             } else {\n                 struct_span_err!(\n                     ctxt.session,\n@@ -142,7 +141,7 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         }\n         EntryPointType::Start => {\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((item.hir_id, item.span));\n+                ctxt.start_fn = Some((item.hir_id(), item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0138, \"multiple `start` functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")"}, {"sha": "4e3010777c1ef227f88058400945136cd7686940", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n impl<'a, 'hir> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id, |this| intravisit::walk_item(this, i));\n+        inner_visitor.check(i.hir_id(), |this| intravisit::walk_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {"}, {"sha": "cf29a55bee0d79604c73cf2e9a07918fc43db498", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -120,7 +120,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_item(&mut self, i: &'v hir::Item<'v>) {\n-        self.record(\"Item\", Id::Node(i.hir_id), i);\n+        self.record(\"Item\", Id::Node(i.hir_id()), i);\n         hir_visit::walk_item(self, i)\n     }\n "}, {"sha": "a81ee22e464c29add29918c7d42dde9d457a38b1", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -30,7 +30,7 @@ struct LanguageItemCollector<'tcx> {\n \n impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.check_for_lang(Target::from_item(item), item.hir_id, item.attrs);\n+        self.check_for_lang(Target::from_item(item), item.hir_id(), item.attrs);\n \n         if let hir::ItemKind::Enum(def, ..) = &item.kind {\n             for variant in def.variants {"}, {"sha": "18c1d647060b11385b25a5264d96ef6456e83263", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -21,16 +21,14 @@ struct LayoutTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n         match item.kind {\n             ItemKind::TyAlias(..)\n             | ItemKind::Enum(..)\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n-                for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n+                for attr in self.tcx.get_attrs(item.def_id.to_def_id()).iter() {\n                     if self.tcx.sess.check_name(attr, sym::rustc_layout) {\n-                        self.dump_layout_of(item_def_id, item, attr);\n+                        self.dump_layout_of(item.def_id, item, attr);\n                     }\n                 }\n             }"}, {"sha": "36d335a81df3fec4a89e99dddc6d81b371bf2300", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -31,7 +31,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: &Codege\n     match item.kind {\n         hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => true,\n         hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n+            let generics = tcx.generics_of(item.def_id);\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -218,8 +218,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+                let codegen_attrs = self.tcx.codegen_fn_attrs(item.def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal =\n                     codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n@@ -239,9 +238,11 @@ impl<'tcx> ReachableContext<'tcx> {\n             Node::Item(item) => {\n                 match item.kind {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                        if item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id))\n-                        {\n+                        if item_might_be_inlined(\n+                            self.tcx,\n+                            &item,\n+                            self.tcx.codegen_fn_attrs(item.def_id),\n+                        ) {\n                             self.visit_nested_body(body);\n                         }\n                     }\n@@ -341,19 +342,18 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+        let codegen_attrs = self.tcx.codegen_fn_attrs(item.def_id);\n         if codegen_attrs.contains_extern_indicator()\n             || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n         {\n-            self.worklist.push(def_id);\n+            self.worklist.push(item.def_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n             item.kind\n         {\n-            if !self.access_levels.is_reachable(item.hir_id) {\n+            if !self.access_levels.is_reachable(item.hir_id()) {\n                 // FIXME(#53488) remove `let`\n                 let tcx = self.tcx;\n                 self.worklist"}, {"sha": "c99784f827902432bfe6fb44d59288b902e50b97", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(\n-            i.hir_id,\n+            i.hir_id(),\n             &i.attrs,\n             i.span,\n             kind,\n@@ -556,15 +556,15 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n                 | hir::ItemKind::ForeignMod { .. }\n         ) {\n-            self.check_missing_stability(i.hir_id, i.span);\n+            self.check_missing_stability(i.hir_id(), i.span);\n         }\n \n         // Ensure `const fn` that are `stable` have one of `rustc_const_unstable` or\n         // `rustc_const_stable`.\n         if self.tcx.features().staged_api\n             && matches!(&i.kind, hir::ItemKind::Fn(sig, ..) if sig.header.is_const())\n         {\n-            self.check_missing_const_stability(i.hir_id, i.span);\n+            self.check_missing_const_stability(i.hir_id(), i.span);\n         }\n \n         intravisit::walk_item(self, i)\n@@ -712,13 +712,12 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                     return;\n                 }\n \n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n+                let cnum = match self.tcx.extern_mod_stmt_cnum(item.def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n+                self.tcx.check_stability(def_id, Some(item.hir_id()), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -744,7 +743,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                                 .map_or(item.span, |a| a.span);\n                             self.tcx.struct_span_lint_hir(\n                                 INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n-                                item.hir_id,\n+                                item.hir_id(),\n                                 span,\n                                 |lint| lint\n                                     .build(\"an `#[unstable]` annotation here has no effect\")\n@@ -775,15 +774,14 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let ty = self.tcx.type_of(def_id);\n+                let ty = self.tcx.type_of(item.def_id);\n                 let (adt_def, substs) = match ty.kind() {\n                     ty::Adt(adt_def, substs) => (adt_def, substs),\n                     _ => bug!(),\n                 };\n \n                 // Non-`Copy` fields are unstable, except for `ManuallyDrop`.\n-                let param_env = self.tcx.param_env(def_id);\n+                let param_env = self.tcx.param_env(item.def_id);\n                 for field in &adt_def.non_enum_variant().fields {\n                     let field_ty = field.ty(self.tcx, substs);\n                     if !field_ty.ty_adt_def().map_or(false, |adt_def| adt_def.is_manually_drop())"}, {"sha": "d5c287fb3bcb3b30d2ace94e9e10a81408ba11c3", "filename": "compiler/rustc_plugin_impl/src/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1,7 +1,7 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -10,14 +10,14 @@ use rustc_span::Span;\n \n struct RegistrarFinder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    registrars: Vec<(hir::HirId, Span)>,\n+    registrars: Vec<(LocalDefId, Span)>,\n }\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for RegistrarFinder<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Fn(..) = item.kind {\n             if self.tcx.sess.contains_name(&item.attrs, sym::plugin_registrar) {\n-                self.registrars.push((item.hir_id, item.span));\n+                self.registrars.push((item.def_id, item.span));\n             }\n         }\n     }\n@@ -43,8 +43,8 @@ fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     match finder.registrars.len() {\n         0 => None,\n         1 => {\n-            let (hir_id, _) = finder.registrars.pop().unwrap();\n-            Some(tcx.hir().local_def_id(hir_id).to_def_id())\n+            let (def_id, _) = finder.registrars.pop().unwrap();\n+            Some(def_id.to_def_id())\n         }\n         _ => {\n             let diagnostic = tcx.sess.diagnostic();"}, {"sha": "d79e9cf505b3645d9a627a872b899c19b8d6b90f", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -454,11 +454,9 @@ impl EmbargoVisitor<'tcx> {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n-            let hir_id = item_id.id;\n-            let item_def_id = self.tcx.hir().local_def_id(hir_id);\n-            let def_kind = self.tcx.def_kind(item_def_id);\n-            let vis = self.tcx.visibility(item_def_id);\n-            self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n+            let def_kind = self.tcx.def_kind(item_id.def_id);\n+            let vis = self.tcx.visibility(item_id.def_id);\n+            self.update_macro_reachable_def(item_id.hir_id(), def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n@@ -590,12 +588,15 @@ impl EmbargoVisitor<'tcx> {\n                 if let hir::ItemKind::Mod(m) = &item.kind {\n                     for &item_id in m.item_ids {\n                         let item = self.tcx.hir().item(item_id);\n-                        let def_id = self.tcx.hir().local_def_id(item_id.id);\n-                        if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id.to_def_id()) {\n+                        if !self.tcx.hygienic_eq(\n+                            segment.ident,\n+                            item.ident,\n+                            item_id.def_id.to_def_id(),\n+                        ) {\n                             continue;\n                         }\n                         if let hir::ItemKind::Use(..) = item.kind {\n-                            self.update(item.hir_id, Some(AccessLevel::Exported));\n+                            self.update(item.hir_id(), Some(AccessLevel::Exported));\n                         }\n                     }\n                 }\n@@ -616,7 +617,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels)\n+                Option::<AccessLevel>::of_impl(item.hir_id(), self.tcx, &self.access_levels)\n             }\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod { .. } => self.prev_level,\n@@ -644,7 +645,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         };\n \n         // Update level of the item itself.\n-        let item_level = self.update(item.hir_id, inherited_item_level);\n+        let item_level = self.update(item.hir_id(), inherited_item_level);\n \n         // Update levels of nested things.\n         match item.kind {\n@@ -727,7 +728,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n                     let exist_level =\n                         cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                    self.reach(item.hir_id, exist_level).generics().predicates().ty();\n+                    self.reach(item.hir_id(), exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -736,12 +737,12 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates().ty();\n+                    self.reach(item.hir_id(), item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let mut reach = self.reach(trait_item_ref.id.hir_id, item_level);\n@@ -759,13 +760,13 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.hir_id(), item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_.items {\n                         let impl_item_level = self.get(impl_item_ref.id.hir_id);\n@@ -782,7 +783,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(variant.id);\n@@ -792,7 +793,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.hir_id, variant_level);\n+                        self.update(item.hir_id(), variant_level);\n                     }\n                 }\n             }\n@@ -811,7 +812,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n                     for field in struct_def.fields() {\n                         let field_level = self.get(field.hir_id);\n                         if field_level.is_some() {\n@@ -1037,7 +1038,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = self.current_item.replace(item.hir_id);\n+        let orig_current_item = self.current_item.replace(item.hir_id());\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1322,8 +1323,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item =\n-            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n+        let orig_current_item = mem::replace(&mut self.current_item, item.def_id);\n         let old_maybe_typeck_results = self.maybe_typeck_results.take();\n         intravisit::walk_item(self, item);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n@@ -1463,7 +1463,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { .. } => {}\n \n             hir::ItemKind::Trait(.., ref bounds, _) => {\n-                if !self.trait_is_public(item.hir_id) {\n+                if !self.trait_is_public(item.hir_id()) {\n                     return;\n                 }\n \n@@ -1615,7 +1615,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(&item.hir_id, &item.vis) => {\n+            _ if !self.item_is_public(&item.hir_id(), &item.vis) => {\n                 return;\n             }\n \n@@ -1926,7 +1926,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-        let item_visibility = tcx.visibility(tcx.hir().local_def_id(item.hir_id).to_def_id());\n+        let item_visibility = tcx.visibility(item.def_id);\n \n         match item.kind {\n             // Crates are always public.\n@@ -1942,15 +1942,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates().ty();\n+                self.check(item.hir_id(), item_visibility).generics().predicates().ty();\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.hir_id, item_visibility).generics().bounds();\n+                self.check(item.hir_id(), item_visibility).generics().bounds();\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n                     self.check_assoc_item(\n@@ -1966,10 +1966,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n \n                 for variant in def.variants {\n                     for field in variant.data.fields() {\n@@ -1986,7 +1986,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             }\n             // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n                     let field_visibility = tcx.visibility(tcx.hir().local_def_id(field.hir_id));\n@@ -1998,8 +1998,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(ref impl_) => {\n-                let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n-                self.check(item.hir_id, impl_vis).generics().predicates();\n+                let impl_vis = ty::Visibility::of_impl(item.hir_id(), tcx, &Default::default());\n+                self.check(item.hir_id(), impl_vis).generics().predicates();\n                 for impl_item_ref in impl_.items {\n                     let impl_item_vis = if impl_.of_trait.is_none() {\n                         min("}, {"sha": "fa8af36ec211ec38e653f05027e939812e1bae27", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -632,7 +632,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-                                let parent_item_id = hir::ItemId { id: parent_id };\n+                                let parent_item_id =\n+                                    hir::ItemId { def_id: parent_id.expect_owner() };\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n                                 let krate = self.tcx.hir().krate();\n@@ -1256,7 +1257,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n                     tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n-                map.insert(item.hir_id, result);\n+                map.insert(item.hir_id(), result);\n             }\n             _ => {}\n         }"}, {"sha": "1d807dd917c57aab0584947624b9bf0ba25a50d7", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 42, "deletions": 75, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -373,14 +373,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         body: hir::BodyId,\n     ) {\n         let map = &self.tcx.hir();\n-        self.nest_typeck_results(map.local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(body.params, &fn_data.qualname);\n-                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id);\n+                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id()), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -401,10 +401,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        self.nest_typeck_results(self.tcx.hir().local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id()), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -465,10 +465,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n-        );\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n \n         let kind = match item.kind {\n             hir::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -500,10 +497,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.hir_id),\n+                &access_from!(self.save_ctxt, item, item.hir_id()),\n                 Def {\n                     kind,\n-                    id: id_from_hir_id(item.hir_id, &self.save_ctxt),\n+                    id: id_from_def_id(item.def_id.to_def_id()),\n                     span,\n                     name,\n                     qualname: qualname.clone(),\n@@ -518,13 +515,13 @@ impl<'tcx> DumpVisitor<'tcx> {\n             );\n         }\n \n-        self.nest_typeck_results(self.tcx.hir().local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             for field in def.fields() {\n-                v.process_struct_field_def(field, item.hir_id);\n+                v.process_struct_field_def(field, item.hir_id());\n                 v.visit_ty(&field.ty);\n             }\n \n-            v.process_generic_params(ty_params, &qualname, item.hir_id);\n+            v.process_generic_params(ty_params, &qualname, item.hir_id());\n         });\n     }\n \n@@ -541,7 +538,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item, item.hir_id);\n+        let access = access_from!(self.save_ctxt, item, item.hir_id());\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -556,7 +553,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_hir_id(item.hir_id, &self.save_ctxt));\n+                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -596,7 +593,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_hir_id(item.hir_id, &self.save_ctxt));\n+                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -627,7 +624,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.visit_ty(field.ty);\n             }\n         }\n-        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id);\n+        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id());\n         self.dumper.dump_def(&access, enum_data);\n     }\n \n@@ -644,17 +641,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        self.nest_typeck_results(map.local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n                 v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n-            v.process_generic_params(&impl_.generics, \"\", item.hir_id);\n+            v.process_generic_params(&impl_.generics, \"\", item.hir_id());\n             for impl_item in impl_.items {\n-                v.process_impl_item(\n-                    map.impl_item(impl_item.id),\n-                    map.local_def_id(item.hir_id).to_def_id(),\n-                );\n+                v.process_impl_item(map.impl_item(impl_item.id), item.def_id.to_def_id());\n             }\n         });\n     }\n@@ -667,10 +661,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         methods: &'tcx [hir::TraitItemRef],\n     ) {\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n-        );\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(generics.params));\n@@ -680,12 +671,12 @@ impl<'tcx> DumpVisitor<'tcx> {\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n         if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_hir_id(item.hir_id, &self.save_ctxt);\n+            let id = id_from_def_id(item.def_id.to_def_id());\n             let span = self.span_from_span(item.ident.span);\n             let children =\n                 methods.iter().map(|i| id_from_hir_id(i.id.hir_id, &self.save_ctxt)).collect();\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.hir_id),\n+                &access_from!(self.save_ctxt, item, item.hir_id()),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -729,28 +720,25 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         kind: RelationKind::SuperTrait,\n                         span,\n                         from: id_from_def_id(id),\n-                        to: id_from_hir_id(item.hir_id, &self.save_ctxt),\n+                        to: id_from_def_id(item.def_id.to_def_id()),\n                     });\n                 }\n             }\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, &qualname, item.hir_id);\n+        self.process_generic_params(generics, &qualname, item.hir_id());\n         for method in methods {\n             let map = &self.tcx.hir();\n-            self.process_trait_item(\n-                map.trait_item(method.id),\n-                map.local_def_id(item.hir_id).to_def_id(),\n-            )\n+            self.process_trait_item(map.trait_item(method.id), item.def_id.to_def_id())\n         }\n     }\n \n     // `item` is the module in question, represented as an( item.\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.hir_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.hir_id()), mod_data);\n         }\n     }\n \n@@ -1130,7 +1118,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             .module\n             .item_ids\n             .iter()\n-            .map(|i| id_from_hir_id(i.id, &self.save_ctxt))\n+            .map(|i| id_from_def_id(i.def_id.to_def_id()))\n             .collect();\n         let span = self.span_from_span(krate.item.span);\n \n@@ -1179,16 +1167,11 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item, item.hir_id);\n-                    let ref_id = self.lookup_def_id(item.hir_id).map(id_from_def_id);\n+                    let access = access_from!(self.save_ctxt, item, item.hir_id());\n+                    let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n-                    let parent = self\n-                        .save_ctxt\n-                        .tcx\n-                        .hir()\n-                        .opt_local_def_id(item.hir_id)\n-                        .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-                        .map(id_from_def_id);\n+                    let parent =\n+                        self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n                     self.dumper.import(\n                         &access,\n                         Import {\n@@ -1206,23 +1189,17 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n                 // Make a comma-separated list of names of imported modules.\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let names = self.tcx.names_imported_by_glob_use(def_id);\n+                let names = self.tcx.names_imported_by_glob_use(item.def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item, item.hir_id);\n+                        let access = access_from!(self.save_ctxt, item, item.hir_id());\n                         let span = self.span_from_span(sub_span);\n-                        let parent = self\n-                            .save_ctxt\n-                            .tcx\n-                            .hir()\n-                            .opt_local_def_id(item.hir_id)\n-                            .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-                            .map(id_from_def_id);\n+                        let parent =\n+                            self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n                         self.dumper.import(\n                             &access,\n                             Import {\n@@ -1243,13 +1220,8 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self\n-                        .save_ctxt\n-                        .tcx\n-                        .hir()\n-                        .opt_local_def_id(item.hir_id)\n-                        .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-                        .map(id_from_def_id);\n+                    let parent =\n+                        self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n                     self.dumper.import(\n                         &Access { public: false, reachable: false },\n                         Import {\n@@ -1286,20 +1258,17 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 self.process_mod(item);\n-                intravisit::walk_mod(self, m, item.hir_id);\n+                intravisit::walk_mod(self, m, item.hir_id());\n             }\n             hir::ItemKind::TyAlias(ty, ref generics) => {\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n-                );\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_hir_id(item.hir_id, &self.save_ctxt);\n+                    let id = id_from_def_id(item.def_id.to_def_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item, item.hir_id),\n+                        &access_from!(self.save_ctxt, item, item.hir_id()),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1318,7 +1287,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 }\n \n                 self.visit_ty(ty);\n-                self.process_generic_params(generics, &qualname, item.hir_id);\n+                self.process_generic_params(generics, &qualname, item.hir_id());\n             }\n             _ => intravisit::walk_item(self, item),\n         }\n@@ -1383,9 +1352,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::TyKind::OpaqueDef(item_id, _) => {\n                 let item = self.tcx.hir().item(item_id);\n-                self.nest_typeck_results(self.tcx.hir().local_def_id(item_id.id), |v| {\n-                    v.visit_item(item)\n-                });\n+                self.nest_typeck_results(item_id.def_id, |v| v.visit_item(item));\n             }\n             _ => intravisit::walk_ty(self, t),\n         }"}, {"sha": "a45406c6b046b44908736af8ba5fc47c404b5a1e", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -201,7 +201,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+        let def_id = item.def_id.to_def_id();\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n@@ -290,7 +290,11 @@ impl<'tcx> SaveContext<'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     value: filename.to_string(),\n                     parent: None,\n-                    children: m.item_ids.iter().map(|i| id_from_hir_id(i.id, self)).collect(),\n+                    children: m\n+                        .item_ids\n+                        .iter()\n+                        .map(|i| id_from_def_id(i.def_id.to_def_id()))\n+                        .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),"}, {"sha": "a1fee58629a5590712635d2902454ed07eca4356", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -318,7 +318,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n             }\n             hir::TyKind::OpaqueDef(item_id, _) => {\n                 let item = scx.tcx.hir().item(item_id);\n-                item.make(offset, Some(item_id.id), scx)\n+                item.make(offset, Some(item_id.hir_id()), scx)\n             }\n             hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n         }\n@@ -327,7 +327,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n \n impl<'hir> Sig for hir::Item<'hir> {\n     fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id);\n+        let id = Some(self.hir_id());\n \n         match self.kind {\n             hir::ItemKind::Static(ref ty, m, ref body) => {\n@@ -337,7 +337,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -359,7 +359,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"const \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -391,7 +391,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 text.push_str(\"fn \");\n \n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in decl.inputs {\n@@ -420,7 +420,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -433,7 +433,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 sig.text.push_str(\" = \");\n                 let ty = ty.make(offset + sig.text.len(), id, scx)?;\n@@ -445,21 +445,21 @@ impl<'hir> Sig for hir::Item<'hir> {\n             hir::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             hir::ItemKind::Struct(_, ref generics) => {\n                 let text = \"struct \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             hir::ItemKind::Union(_, ref generics) => {\n                 let text = \"union \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n@@ -475,7 +475,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 text.push_str(\"trait \");\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\": \");\n@@ -490,7 +490,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = String::new();\n                 text.push_str(\"trait \");\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\" = \");"}, {"sha": "70e9526f626da934f8ab49f237b5ad448d706785", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -227,6 +227,8 @@ pub struct LocalDefId {\n     pub local_def_index: DefIndex,\n }\n \n+pub const CRATE_DEF_ID: LocalDefId = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n+\n impl Idx for LocalDefId {\n     #[inline]\n     fn new(idx: usize) -> Self {\n@@ -268,6 +270,8 @@ impl<D: Decoder> Decodable<D> for LocalDefId {\n     }\n }\n \n+rustc_data_structures::define_id_collections!(LocalDefIdMap, LocalDefIdSet, LocalDefId);\n+\n impl<CTX: HashStableContext> HashStable<CTX> for DefId {\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         hcx.hash_def_id(*self, hasher)"}, {"sha": "1a3b89302bb4362495e5e1179b54f3dfffb562da", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -61,7 +61,7 @@ impl SymbolNamesTest<'tcx> {\n \n impl hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id);\n+        self.process_attrs(item.hir_id());\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {"}, {"sha": "75341a51ba4bfd2320a9704e52579ac9f11242a3", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -2211,7 +2211,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::OpaqueDef(item_id, ref lifetimes) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n-                let def_id = tcx.hir().local_def_id(item_id.id).to_def_id();\n+                let def_id = item_id.def_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {"}, {"sha": "99afaf3466210692d851b08bd2a26a38d27e3dfc", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -373,8 +373,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     (fcx, gen_ty)\n }\n \n-pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n+fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -387,8 +386,7 @@ pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def);\n }\n \n-fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n+fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -683,34 +681,32 @@ fn check_opaque_meets_bounds<'tcx>(\n \n pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     debug!(\n-        \"check_item_type(it.hir_id={}, it.name={})\",\n-        it.hir_id,\n-        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id).to_def_id())\n+        \"check_item_type(it.def_id={:?}, it.name={})\",\n+        it.def_id,\n+        tcx.def_path_str(it.def_id.to_def_id())\n     );\n     let _indenter = indenter();\n     match it.kind {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            tcx.ensure().typeck(def_id);\n-            maybe_check_static_with_link_section(tcx, def_id, it.span);\n-            check_static_inhabited(tcx, def_id, it.span);\n+            tcx.ensure().typeck(it.def_id);\n+            maybe_check_static_with_link_section(tcx, it.def_id, it.span);\n+            check_static_inhabited(tcx, it.def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n+            tcx.ensure().typeck(it.def_id);\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n-            check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n+            check_enum(tcx, it.span, &enum_definition.variants, it.def_id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n         hir::ItemKind::Impl(ref impl_) => {\n-            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n-            let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    impl_def_id,\n+                    it.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -719,8 +715,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             }\n         }\n         hir::ItemKind::Trait(_, _, _, _, ref items) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            check_on_unimplemented(tcx, def_id.to_def_id(), it);\n+            check_on_unimplemented(tcx, it.def_id.to_def_id(), it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n@@ -733,41 +728,38 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                         let item_def_id = tcx.hir().local_def_id(item.hir_id).to_def_id();\n                         let assoc_item = tcx.associated_item(item_def_id);\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorReported> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n                             item.span,\n-                            ty::TraitRef { def_id: def_id.to_def_id(), substs: trait_substs },\n+                            ty::TraitRef { def_id: it.def_id.to_def_id(), substs: trait_substs },\n                         );\n                     }\n                     _ => {}\n                 }\n             }\n         }\n         hir::ItemKind::Struct(..) => {\n-            check_struct(tcx, it.hir_id, it.span);\n+            check_struct(tcx, it.def_id, it.span);\n         }\n         hir::ItemKind::Union(..) => {\n-            check_union(tcx, it.hir_id, it.span);\n+            check_union(tcx, it.def_id, it.span);\n         }\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n             // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n             // `async-std` (and `pub async fn` in general).\n             // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n             // See https://github.com/rust-lang/rust/issues/75100\n             if !tcx.sess.opts.actually_rustdoc {\n-                let def_id = tcx.hir().local_def_id(it.hir_id);\n-\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n-                check_opaque(tcx, def_id, substs, it.span, &origin);\n+                let substs = InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n+                check_opaque(tcx, it.def_id, substs, it.span, &origin);\n             }\n         }\n         hir::ItemKind::TyAlias(..) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            let pty_ty = tcx.type_of(def_id);\n-            let generics = tcx.generics_of(def_id);\n+            let pty_ty = tcx.type_of(it.def_id);\n+            let generics = tcx.generics_of(it.def_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         hir::ItemKind::ForeignMod { abi, items } => {\n@@ -835,9 +827,8 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n }\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n-    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id.to_def_id());\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item.def_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>(\n@@ -1345,13 +1336,12 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'tcx>(\n+fn check_enum<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     vs: &'tcx [hir::Variant<'tcx>],\n-    id: hir::HirId,\n+    def_id: LocalDefId,\n ) {\n-    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n "}, {"sha": "112e7e3ac9f36dfdea557f8c9c630b7b09a1228f", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::intravisit;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::fast_reject::simplify_type;\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{\n@@ -1352,17 +1351,15 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n \n     // Crate-local:\n \n-    struct Visitor<'a, 'tcx> {\n-        map: &'a hir_map::Map<'tcx>,\n+    struct Visitor<'a> {\n         traits: &'a mut Vec<DefId>,\n     }\n \n-    impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n+    impl<'v, 'a> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a> {\n         fn visit_item(&mut self, i: &'v hir::Item<'v>) {\n             match i.kind {\n                 hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) => {\n-                    let def_id = self.map.local_def_id(i.hir_id);\n-                    self.traits.push(def_id.to_def_id());\n+                    self.traits.push(i.def_id.to_def_id());\n                 }\n                 _ => (),\n             }\n@@ -1375,7 +1372,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n         fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n     }\n \n-    tcx.hir().krate().visit_all_item_likes(&mut Visitor { map: &tcx.hir(), traits: &mut traits });\n+    tcx.hir().krate().visit_all_item_likes(&mut Visitor { traits: &mut traits });\n \n     // Cross-crate:\n "}, {"sha": "fbb5b2d42e939a4ea65bbeca36cc44bf246b85c1", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -80,8 +80,8 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n-        \"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n-        item.hir_id,\n+        \"check_item_well_formed(it.def_id={:?}, it.name={})\",\n+        item.def_id,\n         tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -105,7 +105,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         // for `T`\n         hir::ItemKind::Impl(ref impl_) => {\n             let is_auto = tcx\n-                .impl_trait_ref(tcx.hir().local_def_id(item.hir_id))\n+                .impl_trait_ref(item.def_id)\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n@@ -141,13 +141,13 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             }\n         }\n         hir::ItemKind::Fn(ref sig, ..) => {\n-            check_item_fn(tcx, item.hir_id, item.ident, item.span, sig.decl);\n+            check_item_fn(tcx, item.hir_id(), item.ident, item.span, sig.decl);\n         }\n         hir::ItemKind::Static(ref ty, ..) => {\n-            check_item_type(tcx, item.hir_id, ty.span, false);\n+            check_item_type(tcx, item.hir_id(), ty.span, false);\n         }\n         hir::ItemKind::Const(ref ty, ..) => {\n-            check_item_type(tcx, item.hir_id, ty.span, false);\n+            check_item_type(tcx, item.hir_id(), ty.span, false);\n         }\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for it in items.iter() {\n@@ -215,7 +215,7 @@ fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem<'_>) {\n     let (trait_name, trait_def_id) = match tcx.hir().get(tcx.hir().get_parent_item(item.hir_id)) {\n         hir::Node::Item(item) => match item.kind {\n-            hir::ItemKind::Trait(..) => (item.ident, tcx.hir().local_def_id(item.hir_id)),\n+            hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n             _ => return,\n         },\n         _ => return,\n@@ -432,7 +432,7 @@ fn check_associated_item(\n }\n \n fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<'tcx> {\n-    for_id(tcx, item.hir_id, item.span)\n+    for_id(tcx, item.hir_id(), item.span)\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n@@ -465,8 +465,7 @@ fn check_type_defn<'tcx, F>(\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n-        let def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n-        let packed = fcx.tcx.adt_def(def_id).repr.packed();\n+        let packed = fcx.tcx.adt_def(item.def_id).repr.packed();\n \n         for variant in &variants {\n             // For DST, or when drop needs to copy things around, all\n@@ -482,7 +481,7 @@ fn check_type_defn<'tcx, F>(\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id))\n+                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(item.def_id))\n                     }\n                 }\n             };\n@@ -541,23 +540,21 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, def_id.to_def_id(), None);\n+        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n         vec![]\n     });\n }\n \n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n-    debug!(\"check_trait: {:?}\", item.hir_id);\n+    debug!(\"check_trait: {:?}\", item.def_id);\n \n-    let trait_def_id = tcx.hir().local_def_id(item.hir_id);\n-\n-    let trait_def = tcx.trait_def(trait_def_id);\n+    let trait_def = tcx.trait_def(item.def_id);\n     if trait_def.is_marker\n         || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n     {\n-        for associated_def_id in &*tcx.associated_item_def_ids(trait_def_id) {\n+        for associated_def_id in &*tcx.associated_item_def_ids(item.def_id) {\n             struct_span_err!(\n                 tcx.sess,\n                 tcx.def_span(*associated_def_id),\n@@ -569,7 +566,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     }\n \n     for_item(tcx, item).with_fcx(|fcx, _| {\n-        check_where_clauses(tcx, fcx, item.span, trait_def_id.to_def_id(), None);\n+        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n \n         vec![]\n     });\n@@ -665,14 +662,12 @@ fn check_impl<'tcx>(\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let item_def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n-\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n+                let trait_ref = fcx.tcx.impl_trait_ref(item.def_id).unwrap();\n                 let trait_ref =\n                     fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n@@ -688,7 +683,7 @@ fn check_impl<'tcx>(\n                 }\n             }\n             None => {\n-                let self_ty = fcx.tcx.type_of(item_def_id);\n+                let self_ty = fcx.tcx.type_of(item.def_id);\n                 let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n@@ -698,9 +693,9 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item_def_id.to_def_id(), None);\n+        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n \n-        fcx.impl_implied_bounds(item_def_id.to_def_id(), item.span)\n+        fcx.impl_implied_bounds(item.def_id.to_def_id(), item.span)\n     });\n }\n \n@@ -1238,15 +1233,14 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics<'_>,\n ) {\n-    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n-    let ty = tcx.type_of(item_def_id);\n+    let ty = tcx.type_of(item.def_id);\n     if tcx.has_error_field(ty) {\n         return;\n     }\n \n-    let ty_predicates = tcx.predicates_of(item_def_id);\n+    let ty_predicates = tcx.predicates_of(item.def_id);\n     assert_eq!(ty_predicates.parent, None);\n-    let variances = tcx.variances_of(item_def_id);\n+    let variances = tcx.variances_of(item.def_id);\n \n     let mut constrained_parameters: FxHashSet<_> = variances\n         .iter()\n@@ -1354,8 +1348,7 @@ impl Visitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n \n     fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         debug!(\"visit_item: {:?}\", i);\n-        let def_id = self.tcx.hir().local_def_id(i.hir_id);\n-        self.tcx.ensure().check_item_well_formed(def_id);\n+        self.tcx.ensure().check_item_well_formed(i.def_id);\n         hir_visit::walk_item(self, i);\n     }\n "}, {"sha": "e1743a5dfc1ced6eddd9a0a6720add44d49f8aa6", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -28,7 +28,7 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n             return;\n         }\n         if let hir::ItemKind::Use(ref path, _) = item.kind {\n-            self.check_import(item.hir_id, path.span);\n+            self.check_import(item.item_id(), path.span);\n         }\n     }\n \n@@ -45,24 +45,28 @@ struct CheckVisitor<'tcx> {\n }\n \n impl CheckVisitor<'tcx> {\n-    fn check_import(&self, id: hir::HirId, span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(id);\n-        if !self.tcx.maybe_unused_trait_import(def_id) {\n+    fn check_import(&self, item_id: hir::ItemId, span: Span) {\n+        if !self.tcx.maybe_unused_trait_import(item_id.def_id) {\n             return;\n         }\n \n-        if self.used_trait_imports.contains(&def_id) {\n+        if self.used_trait_imports.contains(&item_id.def_id) {\n             return;\n         }\n \n-        self.tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, |lint| {\n-            let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                format!(\"unused import: `{}`\", snippet)\n-            } else {\n-                \"unused import\".to_owned()\n-            };\n-            lint.build(&msg).emit();\n-        });\n+        self.tcx.struct_span_lint_hir(\n+            lint::builtin::UNUSED_IMPORTS,\n+            item_id.hir_id(),\n+            span,\n+            |lint| {\n+                let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    format!(\"unused import: `{}`\", snippet)\n+                } else {\n+                    \"unused import\".to_owned()\n+                };\n+                lint.build(&msg).emit();\n+            },\n+        );\n     }\n }\n \n@@ -109,7 +113,6 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     // Collect all the extern crates (in a reliable order).\n     let mut crates_to_lint = vec![];\n     tcx.hir().krate().visit_all_item_likes(&mut CollectExternCrateVisitor {\n-        tcx,\n         crates_to_lint: &mut crates_to_lint,\n     });\n \n@@ -189,8 +192,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     }\n }\n \n-struct CollectExternCrateVisitor<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct CollectExternCrateVisitor<'a> {\n     crates_to_lint: &'a mut Vec<ExternCrateToLint>,\n }\n \n@@ -211,12 +213,11 @@ struct ExternCrateToLint {\n     warn_if_unused: bool,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n+impl<'a, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n-            let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(ExternCrateToLint {\n-                def_id: extern_crate_def_id.to_def_id(),\n+                def_id: item.def_id.to_def_id(),\n                 span: item.span,\n                 orig_name,\n                 warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "cc592c7a260f12bb946a8bb3f74416a09f5dd063", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -50,8 +50,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             _ => return,\n         };\n \n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        let self_ty = self.tcx.type_of(def_id);\n+        let self_ty = self.tcx.type_of(item.def_id);\n         let lang_items = self.tcx.lang_items();\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n@@ -65,7 +64,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Bool => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.bool_impl(),\n                     None,\n                     \"bool\",\n@@ -76,7 +75,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Char => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.char_impl(),\n                     None,\n                     \"char\",\n@@ -87,7 +86,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Str => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.str_impl(),\n                     lang_items.str_alloc_impl(),\n                     \"str\",\n@@ -98,7 +97,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Slice(slice_item) if slice_item == self.tcx.types.u8 => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.slice_u8_impl(),\n                     lang_items.slice_u8_alloc_impl(),\n                     \"slice_u8\",\n@@ -109,7 +108,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Slice(_) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.slice_impl(),\n                     lang_items.slice_alloc_impl(),\n                     \"slice\",\n@@ -120,7 +119,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Array(_, _) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.array_impl(),\n                     None,\n                     \"array\",\n@@ -133,7 +132,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                 if matches!(inner.kind(), ty::Slice(_)) =>\n             {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.const_slice_ptr_impl(),\n                     None,\n                     \"const_slice_ptr\",\n@@ -146,7 +145,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                 if matches!(inner.kind(), ty::Slice(_)) =>\n             {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.mut_slice_ptr_impl(),\n                     None,\n                     \"mut_slice_ptr\",\n@@ -157,7 +156,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.const_ptr_impl(),\n                     None,\n                     \"const_ptr\",\n@@ -168,7 +167,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.mut_ptr_impl(),\n                     None,\n                     \"mut_ptr\",\n@@ -179,7 +178,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I8) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i8_impl(),\n                     None,\n                     \"i8\",\n@@ -190,7 +189,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I16) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i16_impl(),\n                     None,\n                     \"i16\",\n@@ -201,7 +200,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I32) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i32_impl(),\n                     None,\n                     \"i32\",\n@@ -212,7 +211,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I64) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i64_impl(),\n                     None,\n                     \"i64\",\n@@ -223,7 +222,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I128) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i128_impl(),\n                     None,\n                     \"i128\",\n@@ -234,7 +233,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::Isize) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.isize_impl(),\n                     None,\n                     \"isize\",\n@@ -245,7 +244,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U8) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u8_impl(),\n                     None,\n                     \"u8\",\n@@ -256,7 +255,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U16) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u16_impl(),\n                     None,\n                     \"u16\",\n@@ -267,7 +266,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U32) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u32_impl(),\n                     None,\n                     \"u32\",\n@@ -278,7 +277,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U64) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u64_impl(),\n                     None,\n                     \"u64\",\n@@ -289,7 +288,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U128) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u128_impl(),\n                     None,\n                     \"u128\",\n@@ -300,7 +299,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::Usize) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.usize_impl(),\n                     None,\n                     \"usize\",\n@@ -311,7 +310,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Float(ty::FloatTy::F32) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.f32_impl(),\n                     lang_items.f32_runtime_impl(),\n                     \"f32\",\n@@ -322,7 +321,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Float(ty::FloatTy::F64) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.f64_impl(),\n                     lang_items.f64_runtime_impl(),\n                     \"f64\",\n@@ -369,9 +368,8 @@ impl InherentCollect<'tcx> {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n-            vec.push(impl_def_id.to_def_id());\n+            vec.push(item.def_id.to_def_id());\n         } else {\n             struct_span_err!(\n                 self.tcx.sess,"}, {"sha": "29654099992029e45ce61ca8bd4ea1286c8ee9fd", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -123,8 +123,7 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Trait(..)\n             | hir::ItemKind::Union(..) => {\n-                let ty_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let impls = self.tcx.inherent_impls(ty_def_id);\n+                let impls = self.tcx.inherent_impls(item.def_id);\n \n                 // If there is only one inherent impl block,\n                 // there is nothing to overlap check it with"}, {"sha": "05932427bcf7a4299691c027b54bcd660a187856", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -24,21 +24,20 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(hir::Impl {\n             generics, of_trait: Some(ref tr), self_ty, ..\n         }) = &item.kind\n         {\n             debug!(\n                 \"coherence2::orphan check: trait impl {}\",\n-                self.tcx.hir().node_to_string(item.hir_id)\n+                self.tcx.hir().node_to_string(item.hir_id())\n             );\n-            let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n+            let trait_ref = self.tcx.impl_trait_ref(item.def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let sm = self.tcx.sess.source_map();\n             let sp = sm.guess_head_span(item.span);\n-            match traits::orphan_check(self.tcx, def_id.to_def_id()) {\n+            match traits::orphan_check(self.tcx, item.def_id.to_def_id()) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {\n                     let mut err = struct_span_err!("}, {"sha": "6b995b9738612bbf4eea56389b1bfc19ce781e6d", "filename": "compiler/rustc_typeck/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -24,8 +24,7 @@ impl UnsafetyChecker<'tcx> {\n         unsafety: hir::Unsafety,\n         polarity: hir::ImplPolarity,\n     ) {\n-        let local_did = self.tcx.hir().local_def_id(item.hir_id);\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(local_did) {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id) {\n             let trait_def = self.tcx.trait_def(trait_ref.def_id);\n             let unsafe_attr = impl_generics.and_then(|generics| {\n                 generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")"}, {"sha": "21c0a2d79c81b2c337002bd8ba718603e440fd1d", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -247,7 +247,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        convert_item(self.tcx, item.hir_id);\n+        convert_item(self.tcx, item.item_id());\n         reject_placeholder_type_signatures_in_item(self.tcx, item);\n         intravisit::walk_item(self, item);\n     }\n@@ -714,10 +714,10 @@ fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool\n     }\n }\n \n-fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n-    let it = tcx.hir().expect_item(item_id);\n-    debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n-    let def_id = tcx.hir().local_def_id(item_id);\n+fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n+    let it = tcx.hir().item(item_id);\n+    debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n+    let def_id = item_id.def_id;\n \n     match it.kind {\n         // These don't define types.\n@@ -1122,7 +1122,7 @@ fn super_predicates_that_define_assoc_type(\n         let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n         let superbounds2 = icx.type_parameter_bounds_in_generics(\n             generics,\n-            item.hir_id,\n+            item.hir_id(),\n             self_param_ty,\n             OnlySelfBounds(!is_trait_alias),\n             assoc_name,\n@@ -1446,12 +1446,12 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     //\n                     // Something of a hack: use the node id for the trait, also as\n                     // the node id for the Self type parameter.\n-                    let param_id = item.hir_id;\n+                    let param_id = item.def_id;\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: kw::SelfUpper,\n-                        def_id: tcx.hir().local_def_id(param_id).to_def_id(),\n+                        def_id: param_id.to_def_id(),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,"}, {"sha": "ca2f6c450ea444604627f0f2383b38947ab6ade7", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -582,10 +582,9 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if def_id.to_def_id() != self.def_id {\n-                self.check(def_id);\n+            if it.def_id.to_def_id() != self.def_id {\n+                self.check(it.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }"}, {"sha": "c3606ec564aedbdcdcfc4ae0c6a644b29f3265b9", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -81,11 +81,10 @@ struct ImplWfCheck<'tcx> {\n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-            let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-            enforce_impl_params_are_constrained(self.tcx, impl_def_id, impl_.items);\n+            enforce_impl_params_are_constrained(self.tcx, item.def_id, impl_.items);\n             enforce_impl_items_are_distinct(self.tcx, impl_.items);\n             if self.min_specialization {\n-                check_min_specialization(self.tcx, impl_def_id.to_def_id(), item.span);\n+                check_min_specialization(self.tcx, item.def_id.to_def_id(), item.span);\n             }\n         }\n     }"}, {"sha": "6e6ecf6a22b51815c0976a62b36d6c467ff5901d", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -2,7 +2,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::Node;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n@@ -53,16 +52,10 @@ pub struct InferVisitor<'cx, 'tcx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let item_did = self.tcx.hir().local_def_id(item.hir_id);\n+        let item_did = item.def_id;\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_did);\n-        let item = match self.tcx.hir().get(hir_id) {\n-            Node::Item(item) => item,\n-            _ => bug!(),\n-        };\n-\n         let mut item_required_predicates = RequiredPredicates::default();\n         match item.kind {\n             hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {"}, {"sha": "d4bef0c409a8f1f9a9e7fa6a8f8d614121744111", "filename": "compiler/rustc_typeck/src/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -14,12 +14,10 @@ struct OutlivesTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_outlives) {\n-            let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n+        if self.tcx.has_attr(item.def_id.to_def_id(), sym::rustc_outlives) {\n+            let inferred_outlives_of = self.tcx.inferred_outlives_of(item.def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0640, \"{:?}\", inferred_outlives_of).emit();\n         }\n     }"}, {"sha": "d66508e5b7f1985a12d0f10a4fb709066a0f85c0", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -71,15 +71,15 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.visit_node_helper(item.hir_id);\n+                self.visit_node_helper(item.hir_id());\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.visit_node_helper(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.visit_node_helper(item.hir_id);\n+                self.visit_node_helper(item.hir_id());\n \n                 for variant in enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.data {\n@@ -89,7 +89,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.visit_node_helper(item.hir_id);\n+                self.visit_node_helper(item.hir_id());\n             }\n \n             _ => {}"}, {"sha": "acedce4d2d422a59273b51e577b7c4732e6a3cd7", "filename": "compiler/rustc_typeck/src/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -128,19 +128,19 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        debug!(\"add_inferreds for item {}\", self.tcx.hir().node_to_string(item.hir_id));\n+        debug!(\"add_inferreds for item {}\", self.tcx.hir().node_to_string(item.hir_id()));\n \n         match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.add_inferreds_for_item(item.hir_id);\n+                self.add_inferreds_for_item(item.hir_id());\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.add_inferreds_for_item(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.add_inferreds_for_item(item.hir_id);\n+                self.add_inferreds_for_item(item.hir_id());\n \n                 for variant in enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.data {\n@@ -150,7 +150,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.add_inferreds_for_item(item.hir_id);\n+                self.add_inferreds_for_item(item.hir_id());\n             }\n \n             _ => {}"}, {"sha": "2a0d950c87dabd68a2079ef64820e0e9c8d83eb5", "filename": "compiler/rustc_typeck/src/variance/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -14,12 +14,10 @@ struct VarianceTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_variance) {\n-            let variances_of = self.tcx.variances_of(item_def_id);\n+        if self.tcx.has_attr(item.def_id.to_def_id(), sym::rustc_variance) {\n+            let variances_of = self.tcx.variances_of(item.def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0208, \"{:?}\", variances_of).emit();\n         }\n     }"}, {"sha": "411287de23f50ecc7b4825edb40c4dbaf126cbde", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -135,16 +135,15 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .filter_map(|&id| {\n                     let item = cx.tcx.hir().item(id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => as_primitive(Res::Def(\n-                            DefKind::Mod,\n-                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n-                        )),\n+                        hir::ItemKind::Mod(_) => {\n+                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_primitive(path.res).map(|(_, prim)| {\n                                 // Pretend the primitive is local.\n-                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim)\n+                                (id.def_id.to_def_id(), prim)\n                             })\n                         }\n                         _ => None,\n@@ -187,16 +186,13 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .filter_map(|&id| {\n                     let item = cx.tcx.hir().item(id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => as_keyword(Res::Def(\n-                            DefKind::Mod,\n-                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n-                        )),\n+                        hir::ItemKind::Mod(_) => {\n+                            as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n-                            as_keyword(path.res).map(|(_, prim)| {\n-                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim)\n-                            })\n+                            as_keyword(path.res).map(|(_, prim)| (id.def_id.to_def_id(), prim))\n                         }\n                         _ => None,\n                     }\n@@ -912,7 +908,7 @@ fn clean_fn_or_proc_macro(\n         }\n         None => {\n             let mut func = (sig, generics, body_id).clean(cx);\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+            let def_id = item.def_id.to_def_id();\n             func.header.constness =\n                 if is_const_fn(cx.tcx, def_id) && is_unstable_const_fn(cx.tcx, def_id).is_none() {\n                     hir::Constness::Const\n@@ -1950,8 +1946,8 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n-        let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id));\n+        let def_id = item.def_id.to_def_id();\n+        let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n         cx.with_param_env(def_id, || {\n             let kind = match item.kind {\n                 ItemKind::Static(ty, mutability, body_id) => {\n@@ -1999,7 +1995,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     fields: variant_data.fields().clean(cx),\n                     fields_stripped: false,\n                 }),\n-                ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id, cx),\n+                ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n                 // proc macros can have a name set by attributes\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n@@ -2107,8 +2103,7 @@ fn clean_extern_crate(\n     cx: &DocContext<'_>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n-    let def_id = cx.tcx.hir().local_def_id(krate.hir_id);\n-    let cnum = cx.tcx.extern_mod_stmt_cnum(def_id).unwrap_or(LOCAL_CRATE);\n+    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n     // this is the ID of the crate itself\n     let crate_def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n     let please_inline = krate.vis.node.is_pub()\n@@ -2127,7 +2122,7 @@ fn clean_extern_crate(\n \n         if let Some(items) = inline::try_inline(\n             cx,\n-            cx.tcx.parent_module(krate.hir_id).to_def_id(),\n+            cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n             res,\n             name,\n             Some(krate.attrs),\n@@ -2196,7 +2191,6 @@ fn clean_use_statement(\n \n     // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n     // crate in Rust 2018+\n-    let def_id = cx.tcx.hir().local_def_id(import.hir_id).to_def_id();\n     let path = path.clean(cx);\n     let inner = if kind == hir::UseKind::Glob {\n         if !denied {\n@@ -2221,14 +2215,14 @@ fn clean_use_statement(\n \n             if let Some(mut items) = inline::try_inline(\n                 cx,\n-                cx.tcx.parent_module(import.hir_id).to_def_id(),\n+                cx.tcx.parent_module(import.hir_id()).to_def_id(),\n                 path.res,\n                 name,\n                 Some(import.attrs),\n                 &mut visited,\n             ) {\n                 items.push(Item::from_def_id_and_parts(\n-                    def_id,\n+                    import.def_id.to_def_id(),\n                     None,\n                     ImportItem(Import::new_simple(name, resolve_use_source(cx, path), false)),\n                     cx,\n@@ -2239,7 +2233,7 @@ fn clean_use_statement(\n         Import::new_simple(name, resolve_use_source(cx, path), true)\n     };\n \n-    vec![Item::from_def_id_and_parts(def_id, None, ImportItem(inner), cx)]\n+    vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {"}, {"sha": "10015afb166fd20be6bf40349e1f936f890378f2", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1050,7 +1050,7 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             item.ident.to_string()\n         };\n \n-        self.visit_testable(name, &item.attrs, item.hir_id, item.span, |this| {\n+        self.visit_testable(name, &item.attrs, item.hir_id(), item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }"}, {"sha": "73d096749f470ccd0c1da2b5569f55c42aa17ee4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -270,8 +270,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let name = renamed.unwrap_or(item.ident.name);\n \n         if item.vis.node.is_pub() {\n-            let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n-            self.store_path(def_id.to_def_id());\n+            self.store_path(item.def_id.to_def_id());\n         }\n \n         match item.kind {\n@@ -305,7 +304,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     });\n                     let ident = if is_glob { None } else { Some(name) };\n                     if self.maybe_inline_local(\n-                        item.hir_id,\n+                        item.hir_id(),\n                         path.res,\n                         ident,\n                         is_glob,\n@@ -322,7 +321,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.mods.push(self.visit_mod_contents(\n                     item.span,\n                     &item.vis,\n-                    item.hir_id,\n+                    item.hir_id(),\n                     m,\n                     Some(name),\n                 ));"}, {"sha": "004bce5f62a8f74e4e850a1ecd0ca2d0b51a4f23", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n             ..\n         }) = item.kind\n         {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n+            let ty = cx.tcx.type_of(item.def_id);\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_lint_and_note("}, {"sha": "e8510bde9adcd4fb74a505092b99b912236bfdc7", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             ..\n         }) = item.kind\n         {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n+            let ty = cx.tcx.type_of(item.def_id);\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "c12448588891abbd91e552131f0ab3a6a8f97e27", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -216,18 +216,17 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n-                if !(is_entrypoint_fn(cx, cx.tcx.hir().local_def_id(item.hir_id).to_def_id())\n+                if !(is_entrypoint_fn(cx, item.def_id.to_def_id())\n                     || in_external_macro(cx.tcx.sess, item.span))\n                 {\n                     let body = cx.tcx.hir().body(body_id);\n-                    let impl_item_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n                     let mut fpu = FindPanicUnwrap {\n                         cx,\n-                        typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                        typeck_results: cx.tcx.typeck(item.def_id),\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(&body.value);\n-                    lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+                    lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n             hir::ItemKind::Impl(ref impl_) => {"}, {"sha": "077c3b75fb8c837508fef72290b42571f59715c1", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -49,9 +49,8 @@ impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n             return;\n         }\n \n-        let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.kind {\n-            let ty = cx.tcx.type_of(did);\n+            let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n             if adt.variants.is_empty() {\n                 span_lint_and_help("}, {"sha": "ab9be3398bfa6749e3ab6e25d382776ed849a9dc", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -72,7 +72,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.access_levels.is_exported(item.hir_id);\n+            if cx.access_levels.is_exported(item.hir_id());\n             if !item.attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {"}, {"sha": "79828efc206d61c411897b1e23891a86fa8fb022", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -52,10 +52,9 @@ declare_lint_pass!(FallibleImplFrom => [FALLIBLE_IMPL_FROM]);\n impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         // check for `impl From<???> for ..`\n-        let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n             if cx.tcx.is_diagnostic_item(sym::from_trait, impl_trait_ref.def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);"}, {"sha": "b644bb079908f821a0a699506aae9cb0ad5d132a", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -60,10 +60,9 @@ impl LateLintPass<'_> for FromOverInto {\n             return;\n         }\n \n-        let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl{ .. } = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n             if match_def_path(cx, impl_trait_ref.def_id, &INTO);\n \n             then {"}, {"sha": "28d025315cfeb6f0350ef886f8f2d20c46573d04", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -283,13 +283,13 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let attr = must_use_attr(&item.attrs);\n         if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             if is_public {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n             if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n                 return;\n             }\n             if is_public && !is_proc_macro(cx.sess(), &item.attrs) && attr_by_name(&item.attrs, \"no_mangle\").is_none() {\n@@ -298,7 +298,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                     &sig.decl,\n                     cx.tcx.hir().body(*body_id),\n                     item.span,\n-                    item.hir_id,\n+                    item.hir_id(),\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this function could have a `#[must_use]` attribute\",\n                 );"}, {"sha": "005c461f105e60a7e3f4582788572d84cd81547b", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -59,20 +59,15 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n             // but filter out implementations that have generic params (type or lifetime)\n             // or are derived from a macro\n             if !in_macro(item.span) && generics.params.is_empty() {\n-                self.impls.insert(item.hir_id.owner.to_def_id(), item.span);\n+                self.impls.insert(item.def_id.to_def_id(), item.span);\n             }\n         }\n     }\n \n     fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'_>) {\n-        if let Some(item) = krate.items.values().next() {\n+        if !krate.items.is_empty() {\n             // Retrieve all inherent implementations from the crate, grouped by type\n-            for impls in cx\n-                .tcx\n-                .crate_inherent_impls(item.hir_id.owner.to_def_id().krate)\n-                .inherent_impls\n-                .values()\n-            {\n+            for impls in cx.tcx.crate_inherent_impls(def_id::LOCAL_CRATE).inherent_impls.values() {\n                 // Filter out implementations that have generic params (type or lifetime)\n                 let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n                 if let Some(initial_span) = impl_spans.next() {"}, {"sha": "ab4cb33612d380f0cddb11b0d1b5eec75bf4c253", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -62,9 +62,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         if in_external_macro(cx.tcx.sess, item.span) {\n             return;\n         }\n-        let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            let ty = cx.tcx.type_of(did);\n+            let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n \n             let mut largest_variant: Option<(_, _)> = None;"}, {"sha": "8706cf7f02b928e67e4d5988e5a10de2234575af", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -177,10 +177,9 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.hir_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    if cx.access_levels.is_exported(visited_trait.hir_id()) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n-        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.hir_id);\n-        fill_trait_set(visited_trait_def_id.to_def_id(), &mut current_and_super_traits, cx);\n+        fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n             .iter()\n@@ -230,8 +229,7 @@ fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplIte\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n         if cx.access_levels.is_exported(i.id.hir_id) {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            let ty = cx.tcx.type_of(def_id);\n+            let ty = cx.tcx.type_of(item.def_id);\n \n             span_lint(\n                 cx,"}, {"sha": "a2104b48b4ffdf69241b37635a4cd5584fe63a82", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1687,8 +1687,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let name = impl_item.ident.name.as_str();\n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n         let item = cx.tcx.hir().expect_item(parent);\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-        let self_ty = cx.tcx.type_of(def_id);\n+        let self_ty = cx.tcx.type_of(item.def_id);\n \n         // if this impl block implements a trait, lint in trait definition instead\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {"}, {"sha": "21b59fba995fc322848752a8898fec9aeb142a96", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -135,8 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n-                    let def_id = it.hir_id.owner;\n-                    let def_key = cx.tcx.hir().def_key(def_id);\n+                    let def_key = cx.tcx.hir().def_key(it.def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n                         return;\n                     }\n@@ -159,8 +158,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             | hir::ItemKind::Use(..) => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, article, desc);\n     }"}, {"sha": "5132bed590a0c734e2351c398c323ebf579625a2", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.hir_id) {\n+        if !cx.access_levels.is_exported(it.hir_id()) {\n             return;\n         }\n         match it.kind {"}, {"sha": "7b9205a99de1bb20c3014866fc504312161a4d00", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -57,7 +57,7 @@ declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id, &sig.decl);\n+            check_sig(cx, item.hir_id(), &sig.decl);\n         }\n     }\n "}, {"sha": "1453ea6e8975da8856806e7f819f2748c8fc516c", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -5,11 +5,12 @@\n use crate::utils::{is_automatically_derived, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, HirId, Item, Mutability, Pat, PatKind};\n+use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, Item, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::LocalDefId;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -35,7 +36,7 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct NeedlessBorrow {\n-    derived_item: Option<HirId>,\n+    derived_item: Option<LocalDefId>,\n }\n \n impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW]);\n@@ -117,13 +118,13 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if is_automatically_derived(item.attrs) {\n             debug_assert!(self.derived_item.is_none());\n-            self.derived_item = Some(item.hir_id);\n+            self.derived_item = Some(item.def_id);\n         }\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let Some(id) = self.derived_item {\n-            if item.hir_id == id {\n+            if item.def_id == id {\n                 self.derived_item = None;\n             }\n         }"}, {"sha": "9efeac3d82383ad71d7c2b3f090e202e7996ead0", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -124,7 +124,7 @@ declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n-            check_fn(cx, &sig.decl, item.hir_id, Some(body_id));\n+            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n "}, {"sha": "c876bae2303ad29f0252d0ec425d1b9ca17374c7", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -42,11 +42,10 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let VisibilityKind::Crate { .. } = item.vis.node {\n-            if !cx.access_levels.is_exported(item.hir_id) {\n+            if !cx.access_levels.is_exported(item.hir_id()) {\n                 if let Some(false) = self.is_exported.last() {\n                     let span = item.span.with_hi(item.ident.span.hi());\n-                    let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-                    let descr = cx.tcx.def_kind(def_id).descr(def_id.to_def_id());\n+                    let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n                     span_lint_and_then(\n                         cx,\n                         REDUNDANT_PUB_CRATE,\n@@ -66,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.access_levels.is_exported(item.hir_id));\n+            self.is_exported.push(cx.access_levels.is_exported(item.hir_id()));\n         }\n     }\n "}, {"sha": "05754503163bd275b57ec3989f38dc5d8688f84c", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -1106,7 +1106,9 @@ fn is_empty_block(expr: &Expr<'_>) -> bool {\n         expr.kind,\n         ExprKind::Block(\n             Block {\n-                stmts: &[], expr: None, ..\n+                stmts: &[],\n+                expr: None,\n+                ..\n             },\n             _,\n         )\n@@ -2565,7 +2567,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.hir_id) {\n+        if !cx.access_levels.is_exported(item.hir_id()) {\n             return;\n         }\n "}, {"sha": "f2ff8c959c2e6405691664bd6c32662d81cfe74e", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -196,8 +196,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                         item_path,\n                         cx,\n                     };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-                    let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n+                    let impl_trait_ref = cx.tcx.impl_trait_ref(item.def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {\n                         for impl_item_ref in impl_.items {"}, {"sha": "9c1d98cd707453a3b7a82486ff4cbe0939dfe1d9", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -370,7 +370,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n }\n \n fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    let did = cx.tcx.hir().local_def_id(item.hir_id);\n+    let did = item.def_id;\n     println!(\"item `{}`\", item.ident.name);\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n@@ -383,8 +383,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     }\n     match item.kind {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n+            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(did) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {\n                     println!(\"extern crate dylib source: {:?}\", src.0);"}, {"sha": "094b1a42346c23ff64444c560e087d1586fd16a3", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebbba081e4609099df3921de8a1422b7ea52599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=cebbba081e4609099df3921de8a1422b7ea52599", "patch": "@@ -113,7 +113,7 @@ impl LateLintPass<'_> for WildcardImports {\n         if_chain! {\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n             if self.warn_on_all || !self.check_exceptions(item, use_path.segments);\n-            let used_imports = cx.tcx.names_imported_by_glob_use(item.hir_id.owner);\n+            let used_imports = cx.tcx.names_imported_by_glob_use(item.def_id);\n             if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}]}