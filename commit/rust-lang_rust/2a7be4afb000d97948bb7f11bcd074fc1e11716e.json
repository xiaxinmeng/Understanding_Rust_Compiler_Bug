{"sha": "2a7be4afb000d97948bb7f11bcd074fc1e11716e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhN2JlNGFmYjAwMGQ5Nzk0OGJiN2YxMWJjZDA3NGZjMWUxMTcxNmU=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-01T23:02:15Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-07T21:41:08Z"}, "message": "Better support client completion resolve caps", "tree": {"sha": "8d8e7dadaca7a24e4a40ab3976baf19876d6a7e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d8e7dadaca7a24e4a40ab3976baf19876d6a7e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a7be4afb000d97948bb7f11bcd074fc1e11716e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a7be4afb000d97948bb7f11bcd074fc1e11716e", "html_url": "https://github.com/rust-lang/rust/commit/2a7be4afb000d97948bb7f11bcd074fc1e11716e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a7be4afb000d97948bb7f11bcd074fc1e11716e/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47464e556c160ce705c2e3c84f501ad4e8dbb123", "url": "https://api.github.com/repos/rust-lang/rust/commits/47464e556c160ce705c2e3c84f501ad4e8dbb123", "html_url": "https://github.com/rust-lang/rust/commit/47464e556c160ce705c2e3c84f501ad4e8dbb123"}], "stats": {"total": 225, "additions": 120, "deletions": 105}, "files": [{"sha": "dc67df075a923d315f28af734e7b9e026faee3e8", "filename": "crates/completion/src/item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Fcompletion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Fcompletion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fitem.rs?ref=2a7be4afb000d97948bb7f11bcd074fc1e11716e", "patch": "@@ -12,6 +12,7 @@ use crate::config::SnippetCap;\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n+#[derive(Clone)]\n pub struct CompletionItem {\n     /// Used only internally in tests, to check only specific kind of\n     /// completion (postfix, keyword, reference, etc)."}, {"sha": "516a63b4d1e7cbd63de43ef7c29dbf17d9da7d2a", "filename": "crates/completion/src/test_utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Ftest_utils.rs?ref=2a7be4afb000d97948bb7f11bcd074fc1e11716e", "patch": "@@ -97,6 +97,7 @@ pub(crate) fn check_edit_with_config(\n         .unwrap_or_else(|| panic!(\"can't find {:?} completion in {:#?}\", what, completions));\n     let mut actual = db.file_text(position.file_id).to_string();\n     completion.text_edit().apply(&mut actual);\n+    // TODO kb how to apply imports now?\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n "}, {"sha": "e12651937f2d8ed6fb055f4d0221853c9a4f0af2", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=2a7be4afb000d97948bb7f11bcd074fc1e11716e", "patch": "@@ -7,7 +7,7 @@ use std::{sync::Arc, time::Instant};\n \n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n-use ide::{Analysis, AnalysisHost, Change, FileId, ImportToAdd};\n+use ide::{Analysis, AnalysisHost, Change, CompletionItem, FileId};\n use ide_db::base_db::{CrateId, VfsPath};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n@@ -51,6 +51,11 @@ pub(crate) struct Handle<H, C> {\n pub(crate) type ReqHandler = fn(&mut GlobalState, lsp_server::Response);\n pub(crate) type ReqQueue = lsp_server::ReqQueue<(String, Instant), ReqHandler>;\n \n+pub(crate) struct CompletionResolveData {\n+    pub(crate) file_id: FileId,\n+    pub(crate) item: CompletionItem,\n+}\n+\n /// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n@@ -69,7 +74,7 @@ pub(crate) struct GlobalState {\n     pub(crate) config: Config,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n-    pub(crate) additional_imports: FxHashMap<usize, ImportToAdd>,\n+    pub(crate) completion_resolve_data: FxHashMap<usize, CompletionResolveData>,\n     pub(crate) mem_docs: FxHashMap<VfsPath, DocumentData>,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n@@ -122,7 +127,7 @@ impl GlobalState {\n             config,\n             analysis_host,\n             diagnostics: Default::default(),\n-            additional_imports: FxHashMap::default(),\n+            completion_resolve_data: FxHashMap::default(),\n             mem_docs: FxHashMap::default(),\n             semantic_tokens_cache: Arc::new(Default::default()),\n             vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),"}, {"sha": "a186d2e5d5fb82c8f0872a3bc356cf73a39ca8de", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 47, "deletions": 95, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=2a7be4afb000d97948bb7f11bcd074fc1e11716e", "patch": "@@ -5,14 +5,12 @@\n use std::{\n     io::Write as _,\n     process::{self, Stdio},\n-    sync::Arc,\n };\n \n use ide::{\n-    FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, ImportToAdd, LineIndex,\n-    NavigationTarget, Query, RangeInfo, Runnable, RunnableKind, SearchScope, TextEdit,\n+    FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, NavigationTarget, Query,\n+    RangeInfo, Runnable, RunnableKind, SearchScope, TextEdit,\n };\n-use ide_db::helpers::{insert_use, mod_path_to_ast};\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n use lsp_types::{\n@@ -36,10 +34,10 @@ use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::RustfmtConfig,\n     from_json, from_proto,\n-    global_state::{GlobalState, GlobalStateSnapshot},\n-    line_endings::LineEndings,\n+    global_state::{CompletionResolveData, GlobalState, GlobalStateSnapshot},\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n-    to_proto, LspError, Result,\n+    to_proto::{self, append_import_edits},\n+    LspError, Result,\n };\n \n pub(crate) fn handle_analyzer_status(\n@@ -538,12 +536,6 @@ pub(crate) fn handle_runnables(\n     Ok(res)\n }\n \n-#[derive(Debug, Copy, Clone, Serialize, Deserialize)]\n-pub(crate) struct ResolveCompletionData {\n-    completion_id: usize,\n-    completion_file_id: u32,\n-}\n-\n pub(crate) fn handle_completion(\n     global_state: &mut GlobalState,\n     params: lsp_types::CompletionParams,\n@@ -579,38 +571,31 @@ pub(crate) fn handle_completion(\n     };\n     let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let line_endings = snap.file_line_endings(position.file_id);\n-    let mut additional_imports = FxHashMap::default();\n+    let mut completion_resolve_data = FxHashMap::default();\n \n     let items: Vec<CompletionItem> = items\n         .into_iter()\n         .enumerate()\n         .flat_map(|(item_index, item)| {\n-            let resolve_completion_data = ResolveCompletionData {\n-                completion_id: item_index,\n-                completion_file_id: position.file_id.0,\n-            };\n-            let import_to_add = item.import_to_add().cloned();\n-            let mut new_completion_items =\n-                to_proto::completion_item(&line_index, line_endings, item);\n-\n-            if let Some(import_to_add) = import_to_add {\n-                for new_item in &mut new_completion_items {\n-                    match serde_json::to_value(&resolve_completion_data) {\n-                        Ok(resolve_value) => {\n-                            new_item.data = Some(resolve_value);\n-                            additional_imports.insert(item_index, import_to_add.clone());\n-                        }\n-                        Err(e) => {\n-                            log::error!(\"Failed to serialize completion resolve metadata: {}\", e)\n-                        }\n-                    }\n-                }\n+            let mut new_completion_items = to_proto::completion_item(\n+                &line_index,\n+                line_endings,\n+                item.clone(),\n+                &snap.config.completion.resolve_capabilities,\n+            );\n+\n+            let item_id = serde_json::to_value(&item_index)\n+                .expect(&format!(\"Should be able to serialize usize value {}\", item_index));\n+            completion_resolve_data\n+                .insert(item_index, CompletionResolveData { file_id: position.file_id, item });\n+            for new_item in &mut new_completion_items {\n+                new_item.data = Some(item_id.clone());\n             }\n             new_completion_items\n         })\n         .collect();\n \n-    global_state.additional_imports = additional_imports;\n+    global_state.completion_resolve_data = completion_resolve_data;\n \n     let completion_list = lsp_types::CompletionList { is_incomplete: true, items };\n     Ok(Some(completion_list.into()))\n@@ -622,71 +607,38 @@ pub(crate) fn handle_resolve_completion(\n ) -> Result<lsp_types::CompletionItem> {\n     let _p = profile::span(\"handle_resolve_completion\");\n \n-    match original_completion.data.as_ref() {\n-        Some(completion_data) => {\n-            match serde_json::from_value::<ResolveCompletionData>(completion_data.clone()) {\n-                Ok(resolve_completion_data) => {\n-                    if let Some(import_to_add) =\n-                        global_state.additional_imports.get(&resolve_completion_data.completion_id)\n-                    {\n-                        let snap = global_state.snapshot();\n-                        let file_id = FileId(resolve_completion_data.completion_file_id);\n-                        let line_index = snap.analysis.file_line_index(file_id)?;\n-                        let line_endings = snap.file_line_endings(file_id);\n-\n-                        let resolved_edits =\n-                            resolve_additional_edits(import_to_add, line_index, line_endings);\n-\n-                        original_completion.additional_text_edits =\n-                            match original_completion.additional_text_edits {\n-                                Some(mut original_additional_edits) => {\n-                                    if let Some(mut new_edits) = resolved_edits {\n-                                        original_additional_edits.extend(new_edits.drain(..))\n-                                    }\n-                                    Some(original_additional_edits)\n-                                }\n-                                None => resolved_edits,\n-                            };\n-                    } else {\n-                        log::error!(\n-                            \"Got no import data for completion with label {}, id {}\",\n-                            original_completion.label,\n-                            resolve_completion_data.completion_id\n-                        )\n-                    }\n+    let server_completion_data = match original_completion\n+        .data\n+        .as_ref()\n+        .map(|data| serde_json::from_value::<usize>(data.clone()))\n+        .transpose()?\n+        .and_then(|server_completion_id| {\n+            global_state.completion_resolve_data.get(&server_completion_id)\n+        }) {\n+        Some(data) => data,\n+        None => return Ok(original_completion),\n+    };\n+\n+    let snap = &global_state.snapshot();\n+    for supported_completion_resolve_cap in &snap.config.completion.resolve_capabilities {\n+        match supported_completion_resolve_cap {\n+            ide::CompletionResolveCapability::AdditionalTextEdits => {\n+                // TODO kb actually add all additional edits here?\n+                if let Some(import_to_add) = server_completion_data.item.import_to_add() {\n+                    append_import_edits(\n+                        &mut original_completion,\n+                        import_to_add,\n+                        snap.analysis.file_line_index(server_completion_data.file_id)?.as_ref(),\n+                        snap.file_line_endings(server_completion_data.file_id),\n+                    );\n                 }\n-                Err(e) => log::error!(\"Failed to deserialize completion resolve metadata: {}\", e),\n             }\n+            // TODO kb calculate the rest also?\n+            _ => {}\n         }\n-        None => (),\n     }\n-    Ok(original_completion)\n-}\n \n-// TODO kb what to do when no resolve is available on the client?\n-fn resolve_additional_edits(\n-    import_to_add: &ImportToAdd,\n-    line_index: Arc<LineIndex>,\n-    line_endings: LineEndings,\n-) -> Option<Vec<lsp_types::TextEdit>> {\n-    let _p = profile::span(\"resolve_additional_edits\");\n-\n-    let rewriter = insert_use::insert_use(\n-        &import_to_add.import_scope,\n-        mod_path_to_ast(&import_to_add.import_path),\n-        import_to_add.merge_behaviour,\n-    );\n-    let old_ast = rewriter.rewrite_root()?;\n-    let mut import_insert = TextEdit::builder();\n-    algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n-    let text_edit = import_insert.finish();\n-\n-    Some(\n-        text_edit\n-            .into_iter()\n-            .map(|indel| to_proto::text_edit(&line_index, line_endings, indel))\n-            .collect_vec(),\n-    )\n+    Ok(original_completion)\n }\n \n pub(crate) fn handle_folding_range("}, {"sha": "aa542f5d16fe379de1eefdf2e6985499e0912643", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a7be4afb000d97948bb7f11bcd074fc1e11716e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=2a7be4afb000d97948bb7f11bcd074fc1e11716e", "patch": "@@ -5,14 +5,19 @@ use std::{\n };\n \n use ide::{\n-    Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation,\n-    FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag, HighlightedRange,\n-    Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget,\n-    ReferenceAccess, ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n+    Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, CompletionResolveCapability,\n+    Documentation, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n+    HighlightedRange, ImportToAdd, Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex,\n+    Markup, NavigationTarget, ReferenceAccess, ResolvedAssist, Runnable, Severity, SourceChange,\n+    SourceFileEdit, TextEdit,\n+};\n+use ide_db::{\n+    base_db::{FileId, FileRange},\n+    helpers::{insert_use, mod_path_to_ast},\n };\n-use ide_db::base_db::{FileId, FileRange};\n use itertools::Itertools;\n-use syntax::{SyntaxKind, TextRange, TextSize};\n+use rustc_hash::FxHashSet;\n+use syntax::{algo, SyntaxKind, TextRange, TextSize};\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot,\n@@ -158,6 +163,7 @@ pub(crate) fn completion_item(\n     line_index: &LineIndex,\n     line_endings: LineEndings,\n     completion_item: CompletionItem,\n+    resolve_capabilities: &FxHashSet<CompletionResolveCapability>,\n ) -> Vec<lsp_types::CompletionItem> {\n     fn set_score(res: &mut lsp_types::CompletionItem, label: &str) {\n         res.preselect = Some(true);\n@@ -231,9 +237,17 @@ pub(crate) fn completion_item(\n         None => vec![res],\n     };\n \n+    let unapplied_import_data = completion_item.import_to_add().filter(|_| {\n+        !resolve_capabilities.contains(&CompletionResolveCapability::AdditionalTextEdits)\n+    });\n+\n     for mut r in all_results.iter_mut() {\n         r.insert_text_format = Some(insert_text_format(completion_item.insert_text_format()));\n+        if let Some(unapplied_import_data) = unapplied_import_data {\n+            append_import_edits(r, unapplied_import_data, line_index, line_endings);\n+        }\n     }\n+\n     all_results\n }\n \n@@ -817,6 +831,47 @@ pub(crate) fn markup_content(markup: Markup) -> lsp_types::MarkupContent {\n     lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value }\n }\n \n+pub(crate) fn import_into_edits(\n+    import_to_add: &ImportToAdd,\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+) -> Option<Vec<lsp_types::TextEdit>> {\n+    let _p = profile::span(\"add_import_edits\");\n+\n+    let rewriter = insert_use::insert_use(\n+        &import_to_add.import_scope,\n+        mod_path_to_ast(&import_to_add.import_path),\n+        import_to_add.merge_behaviour,\n+    );\n+    let old_ast = rewriter.rewrite_root()?;\n+    let mut import_insert = TextEdit::builder();\n+    algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n+    let import_edit = import_insert.finish();\n+\n+    Some(\n+        import_edit\n+            .into_iter()\n+            .map(|indel| text_edit(line_index, line_endings, indel))\n+            .collect_vec(),\n+    )\n+}\n+\n+pub(crate) fn append_import_edits(\n+    completion: &mut lsp_types::CompletionItem,\n+    import_to_add: &ImportToAdd,\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+) {\n+    let new_edits = import_into_edits(import_to_add, line_index, line_endings);\n+    if let Some(original_additional_edits) = completion.additional_text_edits.as_mut() {\n+        if let Some(mut new_edits) = new_edits {\n+            original_additional_edits.extend(new_edits.drain(..))\n+        }\n+    } else {\n+        completion.additional_text_edits = new_edits;\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ide::Analysis;\n@@ -836,6 +891,7 @@ mod tests {\n         let (offset, text) = test_utils::extract_offset(fixture);\n         let line_index = LineIndex::new(&text);\n         let (analysis, file_id) = Analysis::from_single_file(text);\n+        let resolve_caps = FxHashSet::default();\n         let completions: Vec<(String, Option<String>)> = analysis\n             .completions(\n                 &ide::CompletionConfig::default(),\n@@ -845,7 +901,7 @@ mod tests {\n             .unwrap()\n             .into_iter()\n             .filter(|c| c.label().ends_with(\"arg\"))\n-            .map(|c| completion_item(&line_index, LineEndings::Unix, c))\n+            .map(|c| completion_item(&line_index, LineEndings::Unix, c, &resolve_caps))\n             .flat_map(|comps| comps.into_iter().map(|c| (c.label, c.sort_text)))\n             .collect();\n         expect_test::expect![[r#\""}]}