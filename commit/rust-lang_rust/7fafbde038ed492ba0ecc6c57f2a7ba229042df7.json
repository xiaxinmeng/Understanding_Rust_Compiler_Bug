{"sha": "7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "node_id": "C_kwDOAAsO6NoAKDdmYWZiZGUwMzhlZDQ5MmJhMGVjYzZjNTdmMmE3YmEyMjkwNDJkZjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T01:20:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T01:20:40Z"}, "message": "Auto merge of #2275 - RalfJung:permissive-provenance-for-all, r=RalfJung\n\nEnable permissive provenance by default\n\nThis completes the plan laid out in https://github.com/rust-lang/miri/issues/2133:\n- We use permissive provenance with wildcard pointers by default.\n- We print a warning on int2ptr casts. `-Zmiri-permissive-provenance` suppresses the warning; `-Zmiri-strict-provenance` turns it into a hard error.\n- Raw pointer tagging is now always enabled, so we remove the `-Zmiri-tag-raw-pointers` flag and the code for untagged pointers. (Passing the flag still works, for compatibility -- but we just ignore it, with a warning.)\n\nWe also fix an intptrcast issue:\n- Only live allocations are considered when computing the AllocId from an address.\n\nSo, finally, Miri has a good story for ptr2int2ptr roundtrips *and* no weird false negatives when doing raw pointer stuff with Stacked Borrows. :-) :tada:   Thanks a lot to everyone who helped with this, in particular `@carbotaniuman` who convinced me this is even possible.\n\nFixes https://github.com/rust-lang/miri/issues/2133\nFixes https://github.com/rust-lang/miri/issues/1866\nFixes https://github.com/rust-lang/miri/issues/1993", "tree": {"sha": "e00f381c80712d4a6be1a0449b6552394625e726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e00f381c80712d4a6be1a0449b6552394625e726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "html_url": "https://github.com/rust-lang/rust/commit/7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5593de579545b4e68512718c948fbed89f21931", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5593de579545b4e68512718c948fbed89f21931", "html_url": "https://github.com/rust-lang/rust/commit/f5593de579545b4e68512718c948fbed89f21931"}, {"sha": "c1eddbc7fefe34bb0213261cb4aa18f4bc11b1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1eddbc7fefe34bb0213261cb4aa18f4bc11b1c5", "html_url": "https://github.com/rust-lang/rust/commit/c1eddbc7fefe34bb0213261cb4aa18f4bc11b1c5"}], "stats": {"total": 984, "additions": 440, "deletions": 544}, "files": [{"sha": "d7c50e9613fd02ceea62b229689cd2a315dbdf05", "filename": "README.md", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -289,6 +289,11 @@ environment variable. We first document the most relevant and most commonly used\n   `-Zmiri-disable-isolation` is set.\n * `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n   remaining threads to exist when the main thread exits.\n+* `-Zmiri-permissive-provenance` disables the warning for integer-to-pointer casts and\n+  [`ptr::from_exposed_addr`](https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html).\n+  This will necessarily miss some bugs as those operations are not efficiently and accurately\n+  implementable in a sanitizer, but it will only miss bugs that concern memory/pointers which is\n+  subject to these operations.\n * `-Zmiri-preemption-rate` configures the probability that at the end of a basic block, the active\n   thread will be preempted. The default is `0.01` (i.e., 1%). Setting this to `0` disables\n   preemption.\n@@ -306,7 +311,17 @@ environment variable. We first document the most relevant and most commonly used\n * `-Zmiri-strict-provenance` enables [strict\n   provenance](https://github.com/rust-lang/rust/issues/95228) checking in Miri. This means that\n   casting an integer to a pointer yields a result with 'invalid' provenance, i.e., with provenance\n-  that cannot be used for any memory access. Also implies `-Zmiri-tag-raw-pointers`.\n+  that cannot be used for any memory access.\n+* `-Zmiri-symbolic-alignment-check` makes the alignment check more strict.  By default, alignment is\n+  checked by casting the pointer to an integer, and making sure that is a multiple of the alignment.\n+  This can lead to cases where a program passes the alignment check by pure chance, because things\n+  \"happened to be\" sufficiently aligned -- there is no UB in this execution but there would be UB in\n+  others.  To avoid such cases, the symbolic alignment check only takes into account the requested\n+  alignment of the relevant allocation, and the offset into that allocation.  This avoids missing\n+  such bugs, but it also incurs some false positives when the code does manual integer arithmetic to\n+  ensure alignment.  (The standard library `align_to` method works fine in both modes; under\n+  symbolic alignment it only fills the middle slice when the allocation guarantees sufficient\n+  alignment.)\n \n The remaining flags are for advanced use only, and more likely to change or be removed.\n Some of these are **unsound**, which means they can lead\n@@ -321,7 +336,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n   integers via `mem::transmute` or union/pointer type punning. This has two effects: it disables the\n   check against integers storing a pointer (i.e., data with provenance), thus allowing\n   pointer-to-integer transmutation, and it treats integer-to-pointer transmutation as equivalent to\n-  a cast. Using this flag is **unsound** and\n+  a cast. Implies `-Zmiri-permissive-provenance`. Using this flag is **unsound** and\n   [deprecated](https://github.com/rust-lang/miri/issues/2188).\n * `-Zmiri-disable-abi-check` disables checking [function ABI]. Using this flag\n   is **unsound**.\n@@ -354,27 +369,6 @@ to Miri failing to detect cases of undefined behavior in a program.\n   application instead of raising an error within the context of Miri (and halting\n   execution). Note that code might not expect these operations to ever panic, so\n   this flag can lead to strange (mis)behavior.\n-* `-Zmiri-permissive-provenance` is **experimental**. This will make Miri do a\n-  best-effort attempt to implement the semantics of\n-  [`expose_addr`](https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.expose_addr)\n-  and\n-  [`ptr::from_exposed_addr`](https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html)\n-  for pointer-to-int and int-to-pointer casts, respectively. This will\n-  necessarily miss some bugs as those semantics are not efficiently\n-  implementable in a sanitizer, but it will only miss bugs that concerns\n-  memory/pointers which is subject to these operations.\n-* `-Zmiri-symbolic-alignment-check` makes the alignment check more strict.  By\n-  default, alignment is checked by casting the pointer to an integer, and making\n-  sure that is a multiple of the alignment.  This can lead to cases where a\n-  program passes the alignment check by pure chance, because things \"happened to\n-  be\" sufficiently aligned -- there is no UB in this execution but there would\n-  be UB in others.  To avoid such cases, the symbolic alignment check only takes\n-  into account the requested alignment of the relevant allocation, and the\n-  offset into that allocation.  This avoids missing such bugs, but it also\n-  incurs some false positives when the code does manual integer arithmetic to\n-  ensure alignment.  (The standard library `align_to` method works fine in both\n-  modes; under symbolic alignment it only fills the middle slice when the\n-  allocation guarantees sufficient alignment.)\n * `-Zmiri-track-alloc-id=<id1>,<id2>,...` shows a backtrace when the given allocations are\n   being allocated or freed.  This helps in debugging memory leaks and\n   use after free bugs. Specifying this argument multiple times does not overwrite the previous\n@@ -389,13 +383,6 @@ to Miri failing to detect cases of undefined behavior in a program.\n   happening and where in your code would be a good place to look for it.\n   Specifying this argument multiple times does not overwrite the previous\n   values, instead it appends its values to the list. Listing a tag multiple times has no effect.\n-* `-Zmiri-tag-raw-pointers` makes Stacked Borrows assign proper tags even for raw pointers. This can\n-  make valid code using int-to-ptr casts fail to pass the checks, but also can help identify latent\n-  aliasing issues in code that Miri accepts by default. You can recognize false positives by\n-  `<untagged>` occurring in the message -- this indicates a pointer that was cast from an integer,\n-  so Miri was unable to track this pointer. Note that it is not currently guaranteed that code that\n-  works with `-Zmiri-tag-raw-pointers` also works without `-Zmiri-tag-raw-pointers`, but for the\n-  vast majority of code, this will be the case.\n \n [function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n "}, {"sha": "1ccc54d6be1969dea950fd46207d5c1acdd8455e", "filename": "src/bin/miri.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -340,6 +340,7 @@ fn main() {\n                 Please let us know at <https://github.com/rust-lang/miri/issues/2188> if you rely on this flag.\"\n             );\n             miri_config.allow_ptr_int_transmute = true;\n+            miri_config.provenance_mode = ProvenanceMode::Permissive;\n         } else if arg == \"-Zmiri-disable-abi-check\" {\n             miri_config.check_abi = false;\n         } else if arg == \"-Zmiri-disable-isolation\" {\n@@ -374,20 +375,18 @@ fn main() {\n         } else if arg == \"-Zmiri-panic-on-unsupported\" {\n             miri_config.panic_on_unsupported = true;\n         } else if arg == \"-Zmiri-tag-raw-pointers\" {\n-            miri_config.tag_raw = true;\n+            eprintln!(\"WARNING: `-Zmiri-tag-raw-pointers` has no effect; it is enabled by default\");\n         } else if arg == \"-Zmiri-strict-provenance\" {\n             miri_config.provenance_mode = ProvenanceMode::Strict;\n-            miri_config.tag_raw = true;\n+            miri_config.allow_ptr_int_transmute = false;\n         } else if arg == \"-Zmiri-permissive-provenance\" {\n             miri_config.provenance_mode = ProvenanceMode::Permissive;\n-            miri_config.tag_raw = true;\n         } else if arg == \"-Zmiri-mute-stdout-stderr\" {\n             miri_config.mute_stdout_stderr = true;\n         } else if arg == \"-Zmiri-track-raw-pointers\" {\n             eprintln!(\n-                \"WARNING: -Zmiri-track-raw-pointers has been renamed to -Zmiri-tag-raw-pointers, the old name is deprecated.\"\n+                \"WARNING: `-Zmiri-track-raw-pointers` has no effect; it is enabled by default\"\n             );\n-            miri_config.tag_raw = true;\n         } else if let Some(param) = arg.strip_prefix(\"-Zmiri-seed=\") {\n             if miri_config.seed.is_some() {\n                 panic!(\"Cannot specify -Zmiri-seed multiple times!\");\n@@ -410,7 +409,7 @@ fn main() {\n                         err\n                     ),\n             };\n-            for id in ids.into_iter().map(miri::PtrId::new) {\n+            for id in ids.into_iter().map(miri::SbTag::new) {\n                 if let Some(id) = id {\n                     miri_config.tracked_pointer_tags.insert(id);\n                 } else {"}, {"sha": "83949a75dee05fdd87298c9e7bc0f5f227dbb713", "filename": "src/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -69,6 +69,9 @@ pub enum NonHaltingDiagnostic {\n     FreedAlloc(AllocId),\n     RejectedIsolatedOp(String),\n     ProgressReport,\n+    Int2Ptr {\n+        details: bool,\n+    },\n }\n \n /// Level of Miri specific diagnostics\n@@ -177,24 +180,6 @@ pub fn report_error<'tcx, 'mir>(\n                                 helps.push((Some(*protection_span), \"this protector is live for this call\".to_string()));\n                             }\n                         }\n-                        Some(TagHistory::Untagged{ recently_created, recently_invalidated, matching_created, protected }) => {\n-                            if let Some((range, span)) = recently_created {\n-                                let msg = format!(\"tag was most recently created at offsets {}\", HexRange(*range));\n-                                helps.push((Some(*span), msg));\n-                            }\n-                            if let Some((range, span)) = recently_invalidated {\n-                                let msg = format!(\"tag was later invalidated at offsets {}\", HexRange(*range));\n-                                helps.push((Some(*span), msg));\n-                            }\n-                            if let Some((range, span)) = matching_created {\n-                                let msg = format!(\"this tag was also created here at offsets {}\", HexRange(*range));\n-                                helps.push((Some(*span), msg));\n-                            }\n-                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n-                                helps.push((Some(*protecting_tag_span), format!(\"{:?} was protected due to a tag which was created here\", protecting_tag)));\n-                                helps.push((Some(*protection_span), \"this protector is live for this call\".to_string()));\n-                            }\n-                        }\n                         None => {}\n                     }\n                     helps\n@@ -468,15 +453,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         format!(\"{op} was made to return an error due to isolation\"),\n                     ProgressReport =>\n                         format!(\"progress report: current operation being executed is here\"),\n+                    Int2Ptr { .. } => format!(\"integer-to-pointer cast\"),\n                 };\n \n                 let (title, diag_level) = match e {\n                     RejectedIsolatedOp(_) =>\n                         (\"operation rejected by isolation\", DiagLevel::Warning),\n-                    _ => (\"tracking was triggered\", DiagLevel::Note),\n+                    Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n+                    CreatedPointerTag(..)\n+                    | PoppedPointerTag(..)\n+                    | CreatedCallId(..)\n+                    | CreatedAlloc(..)\n+                    | FreedAlloc(..)\n+                    | ProgressReport => (\"tracking was triggered\", DiagLevel::Note),\n+                };\n+\n+                let helps = match e {\n+                    Int2Ptr { details: true } =>\n+                        vec![\n+                            (None, format!(\"this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\")),\n+                            (None, format!(\"which means that Miri might miss pointer bugs in this program\")),\n+                            (None, format!(\"see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\")),\n+                            (None, format!(\"to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\")),\n+                            (None, format!(\"you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\")),\n+                            (None, format!(\"alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\")),\n+                        ],\n+                    _ => vec![],\n                 };\n \n-                report_msg(this, diag_level, title, vec![msg], vec![], &stacktrace);\n+                report_msg(this, diag_level, title, vec![msg], helps, &stacktrace);\n             }\n         });\n     }"}, {"sha": "12f1f52c78a334243be9a0f35c0e2c456708cf2d", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -96,13 +96,11 @@ pub struct MiriConfig {\n     /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n     pub seed: Option<u64>,\n     /// The stacked borrows pointer ids to report about\n-    pub tracked_pointer_tags: HashSet<PtrId>,\n+    pub tracked_pointer_tags: HashSet<SbTag>,\n     /// The stacked borrows call IDs to report about\n     pub tracked_call_ids: HashSet<CallId>,\n     /// The allocation ids to report about.\n     pub tracked_alloc_ids: HashSet<AllocId>,\n-    /// Whether to track raw pointers in stacked borrows.\n-    pub tag_raw: bool,\n     /// Determine if data race detection should be enabled\n     pub data_race_detector: bool,\n     /// Determine if weak memory emulation should be enabled. Requires data race detection to be enabled\n@@ -146,14 +144,13 @@ impl Default for MiriConfig {\n             tracked_pointer_tags: HashSet::default(),\n             tracked_call_ids: HashSet::default(),\n             tracked_alloc_ids: HashSet::default(),\n-            tag_raw: false,\n             data_race_detector: true,\n             weak_memory_emulation: true,\n             cmpxchg_weak_failure_rate: 0.8, // 80%\n             measureme_out: None,\n             panic_on_unsupported: false,\n             backtrace_style: BacktraceStyle::Short,\n-            provenance_mode: ProvenanceMode::Legacy,\n+            provenance_mode: ProvenanceMode::Default,\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,"}, {"sha": "a95b20868d2127b03f682e84d44abaff16ff1108", "filename": "src/intptrcast.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -5,22 +5,20 @@ use log::trace;\n use rand::Rng;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size};\n \n use crate::*;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ProvenanceMode {\n-    /// Int2ptr casts return pointers with \"wildcard\" provenance\n-    /// that basically matches that of all exposed pointers\n-    /// (and SB tags, if enabled).\n+    /// We support `expose_addr`/`from_exposed_addr` via \"wildcard\" provenance.\n+    /// However, we want on `from_exposed_addr` to alert the user of the precision loss.\n+    Default,\n+    /// Like `Default`, but without the warning.\n     Permissive,\n-    /// Int2ptr casts return pointers with an invalid provenance,\n-    /// i.e., not valid for any memory access.\n+    /// We error on `from_exposed_addr`, ensuring no precision loss.\n     Strict,\n-    /// Int2ptr casts determine the allocation they point to at cast time.\n-    /// All allocations are considered exposed.\n-    Legacy,\n }\n \n pub type GlobalState = RefCell<GlobalStateInner>;\n@@ -66,6 +64,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n \n         let pos = global_state.int_to_ptr_map.binary_search_by_key(&addr, |(addr, _)| *addr);\n \n+        // Determine the in-bounds provenance for this pointer.\n+        // (This is only called on an actual access, so in-bounds is the only possible kind of provenance.)\n         let alloc_id = match pos {\n             Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n             Err(0) => None,\n@@ -91,21 +91,22 @@ impl<'mir, 'tcx> GlobalStateInner {\n             }\n         }?;\n \n-        // In legacy mode, we consider all allocations exposed.\n-        if global_state.provenance_mode == ProvenanceMode::Legacy\n-            || global_state.exposed.contains(&alloc_id)\n-        {\n-            Some(alloc_id)\n-        } else {\n-            None\n+        // We only use this provenance if it has been exposed, *and* is still live.\n+        if global_state.exposed.contains(&alloc_id) {\n+            // FIXME: this catches `InterpError`, which we should not usually do.\n+            // We might need a proper fallible API from `memory.rs` to avoid this though.\n+            if ecx.get_alloc_size_and_align(alloc_id, AllocCheck::Live).is_ok() {\n+                return Some(alloc_id);\n+            }\n         }\n+\n+        None\n     }\n \n     pub fn expose_ptr(ecx: &mut MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId, sb: SbTag) {\n         let global_state = ecx.machine.intptrcast.get_mut();\n-        // In legacy and strict mode, we don't need this, so we can save some cycles\n-        // by not tracking it.\n-        if global_state.provenance_mode == ProvenanceMode::Permissive {\n+        // In strict mode, we don't need this, so we can save some cycles by not tracking it.\n+        if global_state.provenance_mode != ProvenanceMode::Strict {\n             trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n             if ecx.machine.stacked_borrows.is_some() {\n@@ -120,42 +121,49 @@ impl<'mir, 'tcx> GlobalStateInner {\n     ) -> Pointer<Option<Tag>> {\n         trace!(\"Transmuting 0x{:x} to a pointer\", addr);\n \n-        if ecx.machine.allow_ptr_int_transmute {\n-            // When we allow transmutes, treat them like casts.\n-            Self::ptr_from_addr_cast(ecx, addr)\n+        let provenance = if ecx.machine.allow_ptr_int_transmute {\n+            // When we allow transmutes, treat them like casts: generating a wildcard pointer.\n+            Some(Tag::Wildcard)\n         } else {\n-            // We consider transmuted pointers to be \"invalid\" (`None` provenance).\n-            Pointer::new(None, Size::from_bytes(addr))\n-        }\n+            // Usually, we consider transmuted pointers to be \"invalid\" (`None` provenance).\n+            None\n+        };\n+        Pointer::new(provenance, Size::from_bytes(addr))\n     }\n \n     pub fn ptr_from_addr_cast(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n-    ) -> Pointer<Option<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n         trace!(\"Casting 0x{:x} to a pointer\", addr);\n \n         let global_state = ecx.machine.intptrcast.borrow();\n \n         match global_state.provenance_mode {\n-            ProvenanceMode::Legacy => {\n-                // Determine the allocation this points to at cast time.\n-                let alloc_id = Self::alloc_id_from_addr(ecx, addr);\n-                Pointer::new(\n-                    alloc_id.map(|alloc_id| Tag::Concrete { alloc_id, sb: SbTag::Untagged }),\n-                    Size::from_bytes(addr),\n-                )\n+            ProvenanceMode::Default => {\n+                // The first time this happens at a particular location, print a warning.\n+                thread_local! {\n+                    // `Span` is non-`Send`, so we use a thread-local instead.\n+                    static PAST_WARNINGS: RefCell<FxHashSet<Span>> = RefCell::default();\n+                }\n+                PAST_WARNINGS.with_borrow_mut(|past_warnings| {\n+                    let first = past_warnings.is_empty();\n+                    if past_warnings.insert(ecx.cur_span()) {\n+                        // Newly inserted, so first time we see this span.\n+                        register_diagnostic(NonHaltingDiagnostic::Int2Ptr { details: first });\n+                    }\n+                });\n             }\n             ProvenanceMode::Strict => {\n-                // We don't support int2ptr casts in this mode (i.e., we treat them like\n-                // transmutes).\n-                Pointer::new(None, Size::from_bytes(addr))\n-            }\n-            ProvenanceMode::Permissive => {\n-                // This is how wildcard pointers are born.\n-                Pointer::new(Some(Tag::Wildcard), Size::from_bytes(addr))\n+                throw_unsup_format!(\n+                    \"integer-to-pointer casts and `from_exposed_addr` are not supported with `-Zmiri-strict-provenance`; use `with_addr` instead\"\n+                )\n             }\n+            ProvenanceMode::Permissive => {}\n         }\n+\n+        // This is how wildcard pointers are born.\n+        Ok(Pointer::new(Some(Tag::Wildcard), Size::from_bytes(addr)))\n     }\n \n     fn alloc_base_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n@@ -214,6 +222,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n         dl.overflowing_offset(base_addr, offset.bytes()).0\n     }\n \n+    /// When a pointer is used for a memory access, this computes where in which allocation the\n+    /// access is going.\n     pub fn abs_ptr_to_rel(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<Tag>,\n@@ -224,7 +234,6 @@ impl<'mir, 'tcx> GlobalStateInner {\n             alloc_id\n         } else {\n             // A wildcard pointer.\n-            assert_eq!(ecx.machine.intptrcast.borrow().provenance_mode, ProvenanceMode::Permissive);\n             GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n         };\n "}, {"sha": "e199fae31ee82dce8f3d0208b086f11d68f69606", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -8,6 +8,7 @@\n #![feature(yeet_expr)]\n #![feature(is_some_with)]\n #![feature(nonzero_ops)]\n+#![feature(local_key_cell_methods)]\n #![warn(rust_2018_idioms)]\n #![allow(\n     clippy::collapsible_else_if,\n@@ -89,8 +90,8 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, SbTagExtra,\n-    Stack, Stacks,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, SbTagExtra, Stack,\n+    Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "5b184754589756e5bb8cafba3ef5c4fec9417380", "filename": "src/machine.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -140,8 +140,9 @@ pub enum Tag {\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Pointer<Tag>, 24);\n+// FIXME: this would with in 24bytes but layout optimizations are not smart enough\n // #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-// static_assert_size!(Pointer<Option<Tag>>, 24);\n+//static_assert_size!(Pointer<Option<Tag>>, 24);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ScalarMaybeUninit<Tag>, 32);\n \n@@ -353,7 +354,6 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             Some(RefCell::new(stacked_borrows::GlobalStateInner::new(\n                 config.tracked_pointer_tags.clone(),\n                 config.tracked_call_ids.clone(),\n-                config.tag_raw,\n             )))\n         } else {\n             None\n@@ -681,9 +681,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_tag(ptr.provenance)\n+            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance)\n         } else {\n-            SbTag::Untagged\n+            // Value does not matter, SB is disabled\n+            SbTag::default()\n         };\n         Pointer::new(\n             Tag::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n@@ -696,7 +697,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Self::PointerTag>>> {\n-        Ok(intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr))\n+        intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr)\n     }\n \n     #[inline(always)]"}, {"sha": "ea1132d3e12a429c3537a6c1512c36287e18582c", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 53, "deletions": 123, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -23,42 +23,29 @@ use crate::*;\n pub mod diagnostics;\n use diagnostics::{AllocHistory, TagHistory};\n \n-pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n+\n // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n pub type AllocExtra = RefCell<Stacks>;\n \n /// Tracking pointer provenance\n-#[derive(Copy, Clone, Hash, Eq)]\n-pub enum SbTag {\n-    Tagged(PtrId),\n-    Untagged,\n-}\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct SbTag(NonZeroU64);\n \n impl SbTag {\n-    fn as_u64(self) -> u64 {\n-        match self {\n-            SbTag::Tagged(id) => id.get(),\n-            SbTag::Untagged => 0,\n-        }\n+    pub fn new(i: u64) -> Option<Self> {\n+        NonZeroU64::new(i).map(SbTag)\n     }\n-}\n \n-impl PartialEq for SbTag {\n-    fn eq(&self, other: &Self) -> bool {\n-        // The codegen for the derived Partialeq is bad here and includes a branch.\n-        // Since this code is extremely hot, this is optimized here.\n-        // https://github.com/rust-lang/rust/issues/49892\n-        self.as_u64() == other.as_u64()\n+    // The default to be used when SB is disabled\n+    pub fn default() -> Self {\n+        Self::new(1).unwrap()\n     }\n }\n \n impl fmt::Debug for SbTag {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            SbTag::Tagged(id) => write!(f, \"<{}>\", id),\n-            SbTag::Untagged => write!(f, \"<untagged>\"),\n-        }\n+        write!(f, \"<{}>\", self.0)\n     }\n }\n \n@@ -73,7 +60,7 @@ pub enum SbTagExtra {\n impl fmt::Debug for SbTagExtra {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            SbTagExtra::Concrete(tag) => write!(f, \"{tag:?}\"),\n+            SbTagExtra::Concrete(pid) => write!(f, \"{pid:?}\"),\n             SbTagExtra::Wildcard => write!(f, \"<wildcard>\"),\n         }\n     }\n@@ -82,7 +69,7 @@ impl fmt::Debug for SbTagExtra {\n impl SbTagExtra {\n     fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n         match self {\n-            SbTagExtra::Concrete(tag) => f(tag),\n+            SbTagExtra::Concrete(pid) => f(pid),\n             SbTagExtra::Wildcard => None,\n         }\n     }\n@@ -130,15 +117,15 @@ pub struct Stack {\n     /// Used *mostly* as a stack; never empty.\n     /// Invariants:\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n-    /// * Except for `Untagged`, no tag occurs in the stack more than once.\n+    /// * No tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n     /// If this is `Some(id)`, then the actual current stack is unknown. This can happen when\n     /// wildcard pointers are used to access this location. What we do know is that `borrows` are at\n-    /// the top of the stack, and below it are arbitrarily many items whose `tag` is either\n-    /// `Untagged` or strictly less than `id`.\n+    /// the top of the stack, and below it are arbitrarily many items whose `tag` is strictly less\n+    /// than `id`.\n     /// When the bottom is unknown, `borrows` always has a `SharedReadOnly` or `Unique` at the bottom;\n     /// we never have the unknown-to-known boundary in an SRW group.\n-    unknown_bottom: Option<PtrId>,\n+    unknown_bottom: Option<SbTag>,\n }\n \n /// Extra per-allocation state.\n@@ -156,21 +143,19 @@ pub struct Stacks {\n #[derive(Debug)]\n pub struct GlobalStateInner {\n     /// Next unused pointer ID (tag).\n-    next_ptr_id: PtrId,\n+    next_ptr_tag: SbTag,\n     /// Table storing the \"base\" tag for each allocation.\n     /// The base tag is the one used for the initial pointer.\n     /// We need this in a separate table to handle cyclic statics.\n-    base_ptr_ids: FxHashMap<AllocId, SbTag>,\n+    base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n     /// Those call IDs corresponding to functions that are still running.\n     active_calls: FxHashSet<CallId>,\n     /// The pointer ids to trace\n-    tracked_pointer_tags: HashSet<PtrId>,\n+    tracked_pointer_tags: HashSet<SbTag>,\n     /// The call ids to trace\n     tracked_call_ids: HashSet<CallId>,\n-    /// Whether to track raw pointers.\n-    tag_raw: bool,\n }\n \n /// We need interior mutable access to the global state.\n@@ -219,28 +204,23 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalStateInner {\n-    pub fn new(\n-        tracked_pointer_tags: HashSet<PtrId>,\n-        tracked_call_ids: HashSet<CallId>,\n-        tag_raw: bool,\n-    ) -> Self {\n+    pub fn new(tracked_pointer_tags: HashSet<SbTag>, tracked_call_ids: HashSet<CallId>) -> Self {\n         GlobalStateInner {\n-            next_ptr_id: NonZeroU64::new(1).unwrap(),\n-            base_ptr_ids: FxHashMap::default(),\n+            next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n+            base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n-            tag_raw,\n         }\n     }\n \n-    fn new_ptr(&mut self) -> PtrId {\n-        let id = self.next_ptr_id;\n+    fn new_ptr(&mut self) -> SbTag {\n+        let id = self.next_ptr_tag;\n         if self.tracked_pointer_tags.contains(&id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(id));\n+            register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(id.0));\n         }\n-        self.next_ptr_id = NonZeroU64::new(id.get() + 1).unwrap();\n+        self.next_ptr_tag = SbTag(NonZeroU64::new(id.0.get() + 1).unwrap());\n         id\n     }\n \n@@ -263,22 +243,14 @@ impl GlobalStateInner {\n         self.active_calls.contains(&id)\n     }\n \n-    pub fn base_tag(&mut self, id: AllocId) -> SbTag {\n-        self.base_ptr_ids.get(&id).copied().unwrap_or_else(|| {\n-            let tag = SbTag::Tagged(self.new_ptr());\n+    pub fn base_ptr_tag(&mut self, id: AllocId) -> SbTag {\n+        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n+            let tag = self.new_ptr();\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n-            self.base_ptr_ids.try_insert(id, tag).unwrap();\n+            self.base_ptr_tags.try_insert(id, tag).unwrap();\n             tag\n         })\n     }\n-\n-    pub fn base_tag_untagged(&mut self, id: AllocId) -> SbTag {\n-        trace!(\"New allocation {:?} has no base tag (untagged)\", id);\n-        let tag = SbTag::Untagged;\n-        // This must only be done on new allocations.\n-        self.base_ptr_ids.try_insert(id, tag).unwrap();\n-        tag\n-    }\n }\n \n /// Error reporting\n@@ -368,10 +340,7 @@ impl<'tcx> Stack {\n \n         // Couldn't find it in the stack; but if there is an unknown bottom it might be there.\n         let found = self.unknown_bottom.is_some_and(|&unknown_limit| {\n-            match tag {\n-                SbTag::Tagged(tag_id) => tag_id < unknown_limit, // unknown_limit is an upper bound for what can be in the unknown bottom.\n-                SbTag::Untagged => true,                         // yeah whatever\n-            }\n+            tag.0 < unknown_limit.0 // unknown_limit is an upper bound for what can be in the unknown bottom.\n         });\n         if found { Ok(None) } else { Err(()) }\n     }\n@@ -412,37 +381,29 @@ impl<'tcx> Stack {\n     /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n     /// the `Size` refers to the specific location in the `AllocRange` that we are\n     /// currently checking.\n-    fn check_protector(\n+    fn item_popped(\n         item: &Item,\n         provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n-        if let SbTag::Tagged(id) = item.tag {\n-            if global.tracked_pointer_tags.contains(&id) {\n-                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n-                    *item,\n-                    provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n-                ));\n-            }\n+        if global.tracked_pointer_tags.contains(&item.tag) {\n+            register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n+                *item,\n+                provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n+            ));\n         }\n+\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some((tag, alloc_range, offset, _access)) = provoking_access {\n+                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n                     Err(err_sb_ub(\n                         format!(\n                             \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                             tag, item\n                         ),\n                         None,\n-                        tag.and_then(|tag| {\n-                            alloc_history.get_logs_relevant_to(\n-                                tag,\n-                                alloc_range,\n-                                offset,\n-                                Some(item.tag),\n-                            )\n-                        }),\n+                        tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag))),\n                     ))?\n                 } else {\n                     Err(err_sb_ub(\n@@ -495,7 +456,7 @@ impl<'tcx> Stack {\n             };\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(\n+                Stack::item_popped(\n                     &item,\n                     Some((tag, alloc_range, offset, access)),\n                     global,\n@@ -524,7 +485,7 @@ impl<'tcx> Stack {\n \n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(\n+                    Stack::item_popped(\n                         item,\n                         Some((tag, alloc_range, offset, access)),\n                         global,\n@@ -544,21 +505,19 @@ impl<'tcx> Stack {\n             for item in &self.borrows {\n                 // Skip disabled items, they cannot be matched anyway.\n                 if !matches!(item.perm, Permission::Disabled) {\n-                    if let SbTag::Tagged(tag) = item.tag {\n-                        // We are looking for a strict upper bound, so add 1 to this tag.\n-                        max = cmp::max(tag.checked_add(1).unwrap(), max);\n-                    }\n+                    // We are looking for a strict upper bound, so add 1 to this tag.\n+                    max = cmp::max(item.tag.0.checked_add(1).unwrap(), max);\n                 }\n             }\n             if let Some(unk) = self.unknown_bottom {\n-                max = cmp::max(unk, max);\n+                max = cmp::max(unk.0, max);\n             }\n             // Use `max` as new strict upper bound for everything.\n             trace!(\n                 \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\"\n             );\n             self.borrows.clear();\n-            self.unknown_bottom = Some(max);\n+            self.unknown_bottom = Some(SbTag(max));\n         }\n \n         // Done.\n@@ -570,7 +529,7 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: SbTagExtra,\n-        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n+        (alloc_id, _alloc_range, _offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n@@ -582,13 +541,13 @@ impl<'tcx> Stack {\n                 tag, alloc_id,\n                 ),\n                 None,\n-                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None)),\n+                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, None)),\n             )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n-            Stack::check_protector(&item, None, global, alloc_history)?;\n+            Stack::item_popped(&item, None, global, alloc_history)?;\n         }\n         Ok(())\n     }\n@@ -636,7 +595,7 @@ impl<'tcx> Stack {\n                 // (for all we know, it might join an SRW group inside the unknown).\n                 trace!(\"reborrow: forgetting stack entirely due to SharedReadWrite reborrow from wildcard or unknown\");\n                 self.borrows.clear();\n-                self.unknown_bottom = Some(global.next_ptr_id);\n+                self.unknown_bottom = Some(global.next_ptr_tag);\n                 return Ok(());\n             };\n \n@@ -730,30 +689,9 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_tag(id), Permission::Unique),\n-            // `Global` memory can be referenced by global pointers from `tcx`.\n-            // Thus we call `global_base_ptr` such that the global pointers get the same tag\n-            // as what we use here.\n-            // `ExternStatic` is used for extern statics, so the same reasoning applies.\n-            // The others are various forms of machine-managed special global memory, and we can get\n-            // away with precise tracking there.\n-            // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n-            MemoryKind::CallerLocation\n-            | MemoryKind::Machine(\n-                MiriMemoryKind::Global\n-                | MiriMemoryKind::ExternStatic\n-                | MiriMemoryKind::Tls\n-                | MiriMemoryKind::Runtime\n-                | MiriMemoryKind::Machine,\n-            ) => (extra.base_tag(id), Permission::SharedReadWrite),\n-            // Heap allocations we only track precisely when raw pointers are tagged, for now.\n-            MemoryKind::Machine(\n-                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n-            ) => {\n-                let tag =\n-                    if extra.tag_raw { extra.base_tag(id) } else { extra.base_tag_untagged(id) };\n-                (tag, Permission::SharedReadWrite)\n-            }\n+            MemoryKind::Stack => (extra.base_ptr_tag(id), Permission::Unique),\n+            // Everything else is shared by default.\n+            _ => (extra.base_ptr_tag(id), Permission::SharedReadWrite),\n         };\n         let mut stacks = Stacks::new(size, perm, base_tag);\n         stacks.history.log_creation(\n@@ -1043,15 +981,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Compute new borrow.\n-        let new_tag = {\n-            let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n-            match kind {\n-                // Give up tracking for raw pointers.\n-                RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,\n-                // All other pointers are properly tracked.\n-                _ => SbTag::Tagged(mem_extra.new_ptr()),\n-            }\n-        };\n+        let new_tag = this.machine.stacked_borrows.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n         let alloc_id = this.reborrow(&place, size, kind, new_tag, protect)?;"}, {"sha": "b1ff864bcd5e1cd84003a8deecc4b487710005e8", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 82, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -32,7 +32,6 @@ struct Protection {\n \n #[derive(Clone, Debug)]\n struct Event {\n-    time: usize,\n     parent: Option<SbTag>,\n     tag: SbTag,\n     range: AllocRange,\n@@ -46,12 +45,6 @@ pub enum TagHistory {\n         invalidated: Option<(AllocRange, SpanData)>,\n         protected: Option<(SbTag, SpanData, SpanData)>,\n     },\n-    Untagged {\n-        recently_created: Option<(AllocRange, SpanData)>,\n-        recently_invalidated: Option<(AllocRange, SpanData)>,\n-        matching_created: Option<(AllocRange, SpanData)>,\n-        protected: Option<(SbTag, SpanData, SpanData)>,\n-    },\n }\n \n impl AllocHistory {\n@@ -72,7 +65,7 @@ impl AllocHistory {\n         current_span: &mut CurrentSpan<'_, '_, '_>,\n     ) {\n         let span = current_span.get();\n-        self.creations.push(Event { parent, tag, range, span, time: self.current_time });\n+        self.creations.push(Event { parent, tag, range, span });\n         self.current_time += 1;\n     }\n \n@@ -83,7 +76,7 @@ impl AllocHistory {\n         current_span: &mut CurrentSpan<'_, '_, '_>,\n     ) {\n         let span = current_span.get();\n-        self.invalidations.push(Event { parent: None, tag, range, span, time: self.current_time });\n+        self.invalidations.push(Event { parent: None, tag, range, span });\n         self.current_time += 1;\n     }\n \n@@ -101,8 +94,6 @@ impl AllocHistory {\n     pub fn get_logs_relevant_to(\n         &self,\n         tag: SbTag,\n-        alloc_range: AllocRange,\n-        offset: Size,\n         protector_tag: Option<SbTag>,\n     ) -> Option<TagHistory> {\n         let protected = protector_tag\n@@ -125,74 +116,17 @@ impl AllocHistory {\n                 })\n             });\n \n-        if let SbTag::Tagged(_) = tag {\n-            let get_matching = |events: &[Event]| {\n-                events.iter().rev().find_map(|event| {\n-                    if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n-                })\n-            };\n-            Some(TagHistory::Tagged {\n-                tag,\n-                created: get_matching(&self.creations)?,\n-                invalidated: get_matching(&self.invalidations),\n-                protected,\n-            })\n-        } else {\n-            let mut created_time = 0;\n-            // Find the most recently created tag that satsfies this offset\n-            let recently_created = self.creations.iter().rev().find_map(|event| {\n-                if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n-                    created_time = event.time;\n-                    Some((event.range, event.span.data()))\n-                } else {\n-                    None\n-                }\n-            });\n-\n-            // Find a different recently created tag that satisfies this whole operation, predates\n-            // the recently created tag, and has a different span.\n-            // We're trying to make a guess at which span the user wanted to provide the tag that\n-            // they're using.\n-            let matching_created = recently_created.and_then(|(_created_range, created_span)| {\n-                self.creations.iter().rev().find_map(|event| {\n-                    if event.tag == tag\n-                        && alloc_range.start >= event.range.start\n-                        && alloc_range.end() <= event.range.end()\n-                        && event.span.data() != created_span\n-                        && event.time != created_time\n-                    {\n-                        Some((event.range, event.span.data()))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            });\n-\n-            // Find the most recent invalidation of this tag which post-dates the creation\n-            let recently_invalidated = recently_created.and_then(|_| {\n-                self.invalidations\n-                    .iter()\n-                    .rev()\n-                    .take_while(|event| event.time > created_time)\n-                    .find_map(|event| {\n-                        if event.tag == tag\n-                            && offset >= event.range.start\n-                            && offset < event.range.end()\n-                        {\n-                            Some((event.range, event.span.data()))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-            });\n-\n-            Some(TagHistory::Untagged {\n-                recently_created,\n-                matching_created,\n-                recently_invalidated,\n-                protected,\n+        let get_matching = |events: &[Event]| {\n+            events.iter().rev().find_map(|event| {\n+                if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n             })\n-        }\n+        };\n+        Some(TagHistory::Tagged {\n+            tag,\n+            created: get_matching(&self.creations)?,\n+            invalidated: get_matching(&self.invalidations),\n+            protected,\n+        })\n     }\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n@@ -214,9 +148,7 @@ impl AllocHistory {\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, derived_from)),\n             Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-            derived_from.and_then(|derived_from| {\n-                self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None)\n-            }),\n+            derived_from.and_then(|derived_from| self.get_logs_relevant_to(derived_from, None)),\n         )\n     }\n \n@@ -238,7 +170,7 @@ impl AllocHistory {\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, tag)),\n             Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n-            tag.and_then(|tag| self.get_logs_relevant_to(tag, alloc_range, error_offset, None)),\n+            tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n         )\n     }\n }"}, {"sha": "a16019a05e69f0b52212005706181f7c311ba675", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -114,20 +114,16 @@ def test_cargo_miri_test():\n     default_ref = \"test.cross-target.stdout.ref\" if is_foreign else \"test.default.stdout.ref\"\n     filter_ref = \"test.filter.cross-target.stdout.ref\" if is_foreign else \"test.filter.stdout.ref\"\n \n+    # macOS needs permissive provenance inside getrandom.\n     test(\"`cargo miri test`\",\n         cargo_miri(\"test\"),\n         default_ref, \"test.stderr-empty.ref\",\n-        env={'MIRIFLAGS': \"-Zmiri-seed=feed\"},\n+        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance -Zmiri-seed=feed\"},\n     )\n     test(\"`cargo miri test` (no isolation, no doctests)\",\n         cargo_miri(\"test\") + [\"--bins\", \"--tests\"], # no `--lib`, we disabled that in `Cargo.toml`\n         \"test.cross-target.stdout.ref\", \"test.stderr-empty.ref\",\n-        env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n-    )\n-    test(\"`cargo miri test` (raw-ptr tracking)\",\n-        cargo_miri(\"test\"),\n-        default_ref, \"test.stderr-empty.ref\",\n-        env={'MIRIFLAGS': \"-Zmiri-tag-raw-pointers\"},\n+        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance -Zmiri-disable-isolation\"},\n     )\n     test(\"`cargo miri test` (with filter)\",\n         cargo_miri(\"test\") + [\"--\", \"--format=pretty\", \"le1\"],\n@@ -136,6 +132,7 @@ def test_cargo_miri_test():\n     test(\"`cargo miri test` (test target)\",\n         cargo_miri(\"test\") + [\"--test\", \"test\", \"--\", \"--format=pretty\"],\n         \"test.test-target.stdout.ref\", \"test.stderr-empty.ref\",\n+        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance\"},\n     )\n     test(\"`cargo miri test` (bin target)\",\n         cargo_miri(\"test\") + [\"--bin\", \"cargo-miri-test\", \"--\", \"--format=pretty\"],\n@@ -153,11 +150,13 @@ def test_cargo_miri_test():\n     test(\"`cargo miri test` (custom target dir)\",\n         cargo_miri(\"test\") + [\"--target-dir=custom-test\"],\n         default_ref, \"test.stderr-empty.ref\",\n+        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance\"},\n     )\n     del os.environ[\"CARGO_TARGET_DIR\"] # this overrides `build.target-dir` passed by `--config`, so unset it\n     test(\"`cargo miri test` (config-cli)\",\n         cargo_miri(\"test\") + [\"--config=build.target-dir=\\\"config-cli\\\"\", \"-Zunstable-options\"],\n         default_ref, \"test.stderr-empty.ref\",\n+        env={'MIRIFLAGS': \"-Zmiri-permissive-provenance\"},\n     )\n \n os.chdir(os.path.dirname(os.path.realpath(__file__)))"}, {"sha": "9e24d32a33310c8bfe25ae872af69e8c0505a341", "filename": "tests/fail/backtrace/bad-backtrace-flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -4,6 +4,6 @@ extern \"Rust\" {\n \n fn main() {\n     unsafe {\n-        miri_get_backtrace(2, 0 as *mut _); //~ ERROR  unsupported operation: unknown `miri_get_backtrace` flags 2\n+        miri_get_backtrace(2, std::ptr::null_mut()); //~ ERROR  unsupported operation: unknown `miri_get_backtrace` flags 2\n     }\n }"}, {"sha": "6d62ffc00e51c757d25305172d82da3c84199603", "filename": "tests/fail/backtrace/bad-backtrace-flags.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-flags.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,8 +1,8 @@\n error: unsupported operation: unknown `miri_get_backtrace` flags 2\n   --> $DIR/bad-backtrace-flags.rs:LL:CC\n    |\n-LL |         miri_get_backtrace(2, 0 as *mut _);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown `miri_get_backtrace` flags 2\n+LL |         miri_get_backtrace(2, std::ptr::null_mut());\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown `miri_get_backtrace` flags 2\n    |\n    = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n            "}, {"sha": "73d3561445d575efe2641b3f1490a6152453a654", "filename": "tests/fail/backtrace/bad-backtrace-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -4,6 +4,6 @@ extern \"Rust\" {\n \n fn main() {\n     unsafe {\n-        miri_resolve_frame(0 as *mut _, 0); //~ ERROR null pointer is not a valid pointer for this operation\n+        miri_resolve_frame(std::ptr::null_mut(), 0); //~ ERROR null pointer is not a valid pointer for this operation\n     }\n }"}, {"sha": "6911db9de02fd941ac71c12d3509620070f0f8d9", "filename": "tests/fail/backtrace/bad-backtrace-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-ptr.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: null pointer is not a valid pointer for this operation\n   --> $DIR/bad-backtrace-ptr.rs:LL:CC\n    |\n-LL |         miri_resolve_frame(0 as *mut _, 0);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ null pointer is not a valid pointer for this operation\n+LL |         miri_resolve_frame(std::ptr::null_mut(), 0);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ null pointer is not a valid pointer for this operation\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "2d4d6195029d146c6786ac7b76ad63d8f9449f02", "filename": "tests/fail/backtrace/bad-backtrace-resolve-flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-flags.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -15,7 +15,7 @@ extern \"Rust\" {\n \n fn main() {\n     unsafe {\n-        let mut buf = vec![0 as *mut _; miri_backtrace_size(0)];\n+        let mut buf = vec![std::ptr::null_mut(); miri_backtrace_size(0)];\n \n         miri_get_backtrace(1, buf.as_mut_ptr());\n "}, {"sha": "6cea1fec1b241f2ea007528763f5e582ba3d7778", "filename": "tests/fail/backtrace/bad-backtrace-resolve-names-flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -6,11 +6,11 @@ extern \"Rust\" {\n \n fn main() {\n     unsafe {\n-        let mut buf = vec![0 as *mut _; miri_backtrace_size(0)];\n+        let mut buf = vec![std::ptr::null_mut(); miri_backtrace_size(0)];\n \n         miri_get_backtrace(1, buf.as_mut_ptr());\n \n         // miri_resolve_frame_names will error from an invalid backtrace before it will from invalid flags\n-        miri_resolve_frame_names(buf[0], 2, 0 as *mut _, 0 as *mut _); //~ ERROR  unsupported operation: unknown `miri_resolve_frame_names` flags 2\n+        miri_resolve_frame_names(buf[0], 2, std::ptr::null_mut(), std::ptr::null_mut()); //~ ERROR  unsupported operation: unknown `miri_resolve_frame_names` flags 2\n     }\n }"}, {"sha": "aa470cb9de054e4b966146bdd7314fa0742b85e1", "filename": "tests/fail/backtrace/bad-backtrace-resolve-names-flags.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbacktrace%2Fbad-backtrace-resolve-names-flags.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,8 +1,8 @@\n error: unsupported operation: unknown `miri_resolve_frame_names` flags 2\n   --> $DIR/bad-backtrace-resolve-names-flags.rs:LL:CC\n    |\n-LL | ...   miri_resolve_frame_names(buf[0], 2, 0 as *mut _, 0 as *mut _);\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown `miri_resolve_frame_names` flags 2\n+LL | ...   miri_resolve_frame_names(buf[0], 2, std::ptr::null_mut(), std::ptr::null_mut());\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown `miri_resolve_frame_names` flags 2\n    |\n    = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n            "}, {"sha": "e6031b5e4c0c5c7b583065360f7cff35f8aa8cad", "filename": "tests/fail/concurrency/thread_local_static_dealloc.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -7,9 +7,12 @@\n #[thread_local]\n static mut TLS: u8 = 0;\n \n+struct SendRaw(*const u8);\n+unsafe impl Send for SendRaw {}\n+\n fn main() {\n     unsafe {\n-        let dangling_ptr = std::thread::spawn(|| &TLS as *const u8 as usize).join().unwrap();\n-        let _val = *(dangling_ptr as *const u8); //~ ERROR dereferenced after this allocation got freed\n+        let dangling_ptr = std::thread::spawn(|| SendRaw(&TLS as *const u8)).join().unwrap();\n+        let _val = *dangling_ptr.0; //~ ERROR dereferenced after this allocation got freed\n     }\n }"}, {"sha": "d54c569de36e6432c5e9f2976cbe40c080c3b817", "filename": "tests/fail/concurrency/thread_local_static_dealloc.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n   --> $DIR/thread_local_static_dealloc.rs:LL:CC\n    |\n-LL |         let _val = *(dangling_ptr as *const u8);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pointer to ALLOC was dereferenced after this allocation got freed\n+LL |         let _val = *dangling_ptr.0;\n+   |                    ^^^^^^^^^^^^^^^ pointer to ALLOC was dereferenced after this allocation got freed\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "cb2bbec8bcf01d0f0c3182ff7fda3bea71e4c101", "filename": "tests/fail/dangling_pointers/deref-invalid-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fderef-invalid-ptr.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation.\n-// compile-flags: -Zmiri-disable-validation\n+// compile-flags: -Zmiri-disable-validation -Zmiri-permissive-provenance\n \n fn main() {\n     let x = 16usize as *const u32;"}, {"sha": "370162142de975fd82b14c374a618534441ca19e", "filename": "tests/fail/dangling_pointers/storage_dead_dangling.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,5 +1,5 @@\n // This should fail even without validation, but some MIR opts mask the error\n-// compile-flags: -Zmiri-disable-validation -Zmir-opt-level=0\n+// compile-flags: -Zmiri-disable-validation -Zmir-opt-level=0 -Zmiri-permissive-provenance\n \n static mut LEAK: usize = 0;\n \n@@ -10,7 +10,7 @@ fn fill(v: &mut i32) {\n }\n \n fn evil() {\n-    unsafe { &mut *(LEAK as *mut i32) }; //~ ERROR dereferenced after this allocation got freed\n+    unsafe { &mut *(LEAK as *mut i32) }; //~ ERROR is not a valid pointer\n }\n \n fn main() {\n@@ -21,6 +21,6 @@ fn main() {\n         _y = x;\n     }\n     // Now we use a pointer to `x` which is no longer in scope, and thus dead (even though the\n-    // `main` stack frame still exists).\n+    // `main` stack frame still exists). We even try going through a `usize` for extra sneakiness!\n     evil();\n }"}, {"sha": "d6030643bfaa1f8bd55cf50ee63f3e5af2855dc4", "filename": "tests/fail/dangling_pointers/storage_dead_dangling.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fstorage_dead_dangling.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: pointer to ALLOC was dereferenced after this allocation got freed\n+error: Undefined Behavior: dereferencing pointer failed: $HEX is not a valid pointer\n   --> $DIR/storage_dead_dangling.rs:LL:CC\n    |\n LL |     unsafe { &mut *(LEAK as *mut i32) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^ pointer to ALLOC was dereferenced after this allocation got freed\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: $HEX is not a valid pointer\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "7c9f5281fbbbe349fbfe12cdb2f77893fe728270", "filename": "tests/fail/dangling_pointers/wild_pointer_deref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdangling_pointers%2Fwild_pointer_deref.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n fn main() {\n     let p = 44 as *const i32;\n     let x = unsafe { *p }; //~ ERROR is not a valid pointer"}, {"sha": "ca38f39d2515777371ab0a40dc7da5c517aa4d42", "filename": "tests/fail/intrinsics/ptr_offset_0_plus_0.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fintrinsics%2Fptr_offset_0_plus_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fintrinsics%2Fptr_offset_0_plus_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fptr_offset_0_plus_0.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,5 @@\n // error-pattern: pointer arithmetic failed: null pointer is not a valid pointer\n+// compile-flags: -Zmiri-permissive-provenance\n \n fn main() {\n     let x = 0 as *mut i32;"}, {"sha": "809938d999731fa63bc127244ccfdafdec22c263", "filename": "tests/fail/intrinsics/ptr_offset_int_plus_int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_int.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,5 @@\n // error-pattern: is not a valid pointer\n+// compile-flags: -Zmiri-permissive-provenance\n \n fn main() {\n     // Can't offset an integer pointer by non-zero offset."}, {"sha": "903f89ff70ec48301dde5c87972b55dc7819b29e", "filename": "tests/fail/intrinsics/ptr_offset_int_plus_ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fptr_offset_int_plus_ptr.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,5 @@\n // error-pattern: is not a valid pointer\n+// compile-flags: -Zmiri-permissive-provenance\n \n fn main() {\n     let ptr = Box::into_raw(Box::new(0u32));"}, {"sha": "12f3562011a81db708631f5defe29c86f9397968", "filename": "tests/fail/provenance/permissive_provenance_transmute.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.stderr?ref=f5593de579545b4e68512718c948fbed89f21931", "patch": "@@ -1,20 +0,0 @@\n-error: Undefined Behavior: dereferencing pointer failed: $HEX is not a valid pointer\n-  --> $DIR/permissive_provenance_transmute.rs:LL:CC\n-   |\n-LL |         let _val = *left_ptr;\n-   |                    ^^^^^^^^^ dereferencing pointer failed: $HEX is not a valid pointer\n-   |\n-   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n-   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-           \n-   = note: inside `deref` at $DIR/permissive_provenance_transmute.rs:LL:CC\n-note: inside `main` at $DIR/permissive_provenance_transmute.rs:LL:CC\n-  --> $DIR/permissive_provenance_transmute.rs:LL:CC\n-   |\n-LL |         deref(ptr1, ptr2.with_addr(ptr1.addr()));\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "28e6ba6230803423ef6b459f9d1e0c8d6aa22418", "filename": "tests/fail/provenance/provenance_transmute.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fprovenance_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fprovenance_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fprovenance_transmute.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "previous_filename": "tests/fail/provenance/permissive_provenance_transmute.rs"}, {"sha": "9cbec077e42c06156d8bf3dcda505b5b42887be0", "filename": "tests/fail/provenance/provenance_transmute.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fprovenance_transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fprovenance_transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fprovenance_transmute.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,15 +1,15 @@\n error: Undefined Behavior: dereferencing pointer failed: $HEX is not a valid pointer\n-  --> $DIR/strict_provenance_transmute.rs:LL:CC\n+  --> $DIR/provenance_transmute.rs:LL:CC\n    |\n LL |         let _val = *left_ptr;\n    |                    ^^^^^^^^^ dereferencing pointer failed: $HEX is not a valid pointer\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n            \n-   = note: inside `deref` at $DIR/strict_provenance_transmute.rs:LL:CC\n-note: inside `main` at $DIR/strict_provenance_transmute.rs:LL:CC\n-  --> $DIR/strict_provenance_transmute.rs:LL:CC\n+   = note: inside `deref` at $DIR/provenance_transmute.rs:LL:CC\n+note: inside `main` at $DIR/provenance_transmute.rs:LL:CC\n+  --> $DIR/provenance_transmute.rs:LL:CC\n    |\n LL |         deref(ptr1, ptr2.with_addr(ptr1.addr()));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "tests/fail/provenance/strict_provenance_transmute.stderr"}, {"sha": "538ec4484edb9282b09c5512ff2b3282f8ed1750", "filename": "tests/fail/provenance/ptr_legacy_provenance.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.rs?ref=f5593de579545b4e68512718c948fbed89f21931", "patch": "@@ -1,22 +0,0 @@\n-// compile-flags: -Zmiri-disable-stacked-borrows\n-// normalize-stderr-test: \"offset -[0-9]+\" -> \"offset -XX\"\n-#![feature(strict_provenance)]\n-\n-use std::ptr;\n-\n-// Make sure that with legacy provenance, the allocation id of\n-// a casted pointer is determined at cast-time\n-fn main() {\n-    let x: i32 = 0;\n-    let y: i32 = 1;\n-\n-    let x_ptr = &x as *const i32;\n-    let y_ptr = &y as *const i32;\n-\n-    let x_usize = x_ptr.expose_addr();\n-    let y_usize = y_ptr.expose_addr();\n-\n-    let ptr = ptr::from_exposed_addr::<i32>(y_usize);\n-    let ptr = ptr.with_addr(x_usize);\n-    assert_eq!(unsafe { *ptr }, 0); //~ ERROR is out-of-bounds\n-}"}, {"sha": "4552be08145d4a9654927238cf8572f07b310117", "filename": "tests/fail/provenance/ptr_legacy_provenance.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fptr_legacy_provenance.stderr?ref=f5593de579545b4e68512718c948fbed89f21931", "patch": "@@ -1,15 +0,0 @@\n-error: Undefined Behavior: dereferencing pointer failed: ALLOC has size 4, so pointer to 4 bytes starting at offset -XX is out-of-bounds\n-  --> $DIR/ptr_legacy_provenance.rs:LL:CC\n-   |\n-LL |     assert_eq!(unsafe { *ptr }, 0);\n-   |                         ^^^^ dereferencing pointer failed: ALLOC has size 4, so pointer to 4 bytes starting at offset -XX is out-of-bounds\n-   |\n-   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n-   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-           \n-   = note: inside `main` at $DIR/ptr_legacy_provenance.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "8b2b053bdb59140e43ca88f2cf18e3d53945dbcb", "filename": "tests/fail/provenance/strict_provenance_cast.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fstrict_provenance_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fstrict_provenance_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fstrict_provenance_cast.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: -Zmiri-strict-provenance\n+\n+fn main() {\n+    let addr = &0 as *const i32 as usize;\n+    let _ptr = addr as *const i32; //~ ERROR integer-to-pointer casts and `from_exposed_addr` are not supported\n+}"}, {"sha": "32a39b81d9d7fb054f2e43d6915618106abf6d96", "filename": "tests/fail/provenance/strict_provenance_cast.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fstrict_provenance_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fprovenance%2Fstrict_provenance_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fstrict_provenance_cast.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -0,0 +1,14 @@\n+error: unsupported operation: integer-to-pointer casts and `from_exposed_addr` are not supported with `-Zmiri-strict-provenance`; use `with_addr` instead\n+  --> $DIR/strict_provenance_cast.rs:LL:CC\n+   |\n+LL |     let _ptr = addr as *const i32;\n+   |                ^^^^^^^^^^^^^^^^^^ integer-to-pointer casts and `from_exposed_addr` are not supported with `-Zmiri-strict-provenance`; use `with_addr` instead\n+   |\n+   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n+           \n+   = note: inside `main` at $DIR/strict_provenance_cast.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "12a141e9ddfee5027093f931927e3da9c0308700", "filename": "tests/fail/provenance/strict_provenance_transmute.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fstrict_provenance_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5593de579545b4e68512718c948fbed89f21931/tests%2Ffail%2Fprovenance%2Fstrict_provenance_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fstrict_provenance_transmute.rs?ref=f5593de579545b4e68512718c948fbed89f21931", "patch": "@@ -1,27 +0,0 @@\n-// compile-flags: -Zmiri-strict-provenance\n-#![feature(strict_provenance)]\n-\n-use std::mem;\n-\n-// This is the example from\n-// <https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-1085144431>.\n-\n-unsafe fn deref(left: *const u8, right: *const u8) {\n-    let left_int: usize = mem::transmute(left);\n-    let right_int: usize = mem::transmute(right);\n-    if left_int == right_int {\n-        // The compiler is allowed to replace `left_int` by `right_int` here...\n-        let left_ptr: *const u8 = mem::transmute(left_int);\n-        // ...which however means here it could be dereferencing the wrong pointer.\n-        let _val = *left_ptr; //~ERROR dereferencing pointer failed\n-    }\n-}\n-\n-fn main() {\n-    let ptr1 = &0u8 as *const u8;\n-    let ptr2 = &1u8 as *const u8;\n-    unsafe {\n-        // Two pointers with the same address but different provenance.\n-        deref(ptr1, ptr2.with_addr(ptr1.addr()));\n-    }\n-}"}, {"sha": "66220cfbfc4d3c43363130903a895ea2cfe0ddf8", "filename": "tests/fail/stacked_borrows/aliasing_mut3.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: trying to reborrow <untagged> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: trying to reborrow <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &i32) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | |\n-   | trying to reborrow <untagged> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   | trying to reborrow <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    | this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL |     safe_raw(xraw, xshr);\n    |                    ^^^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &i32) {}"}, {"sha": "66d092d6277c8b1912f491e751f8ec6a659ee688", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -8,7 +8,7 @@ fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n     unknown_code_2();\n \n     // We know this will return 5\n-    *our //~ ERROR borrow stack\n+    *our\n }\n \n // Now comes the evil context\n@@ -24,7 +24,7 @@ fn unknown_code_1(x: &i32) {\n \n fn unknown_code_2() {\n     unsafe {\n-        *LEAK = 7;\n+        *LEAK = 7; //~ ERROR borrow stack\n     }\n }\n "}, {"sha": "06c2dc340b7bac6321fa9799a1daef01d4d903ec", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.stderr", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,31 +1,30 @@\n-error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL |     *our\n-   |     ^^^^\n-   |     |\n-   |     attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |     this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |         *LEAK = 7;\n+   |         ^^^^^^^^^\n+   |         |\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL | / fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n-LL | |     unknown_code_1(&*our);\n-LL | |\n-LL | |     // This \"re-asserts\" uniqueness of the reference: After writing, we know\n-...  |\n-LL | |     *our\n-LL | | }\n-   | |_^\n+LL |         LEAK = x as *const _ as *mut _;\n+   |                ^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL |         *LEAK = 7;\n-   |         ^^^^^^^^^\n-   = note: inside `demo_mut_advanced_unique` at $DIR/box_exclusive_violation1.rs:LL:CC\n+LL |     *our = 5;\n+   |     ^^^^^^^^\n+   = note: inside `unknown_code_2` at $DIR/box_exclusive_violation1.rs:LL:CC\n+note: inside `demo_mut_advanced_unique` at $DIR/box_exclusive_violation1.rs:LL:CC\n+  --> $DIR/box_exclusive_violation1.rs:LL:CC\n+   |\n+LL |     unknown_code_2();\n+   |     ^^^^^^^^^^^^^^^^\n note: inside `main` at $DIR/box_exclusive_violation1.rs:LL:CC\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |"}, {"sha": "0173ca14b22dad143227305bd6b7e6681ebd70ea", "filename": "tests/fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -5,7 +5,7 @@\n use std::mem;\n \n union HiddenRef {\n-    // We avoid retagging at this type, so shared vs mutable does not matter.\n+    // We avoid retagging at this type, and we only read, so shared vs mutable does not matter.\n     r: &'static i32,\n }\n "}, {"sha": "2098dbdc6a492ee8f1dee9d5ea3c5bba6df82739", "filename": "tests/fail/stacked_borrows/illegal_read6.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let _val = *raw;\n    |                    ^^^^\n    |                    |\n-   |                    attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let raw = x as *mut _;\n    |                   ^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n LL |         let x = &mut *x; // kill `raw`"}, {"sha": "58600402e4edd1558b81ce856d3edbfc1744f8f2", "filename": "tests/fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -3,7 +3,7 @@ fn main() {\n     let xref = &*target;\n     {\n         let x: *mut u32 = xref as *const _ as *mut _;\n-        unsafe { *x = 42 }; // invalidates shared ref, activates raw\n+        unsafe { *x = 42 }; //~ ERROR only grants SharedReadOnly permission\n     }\n-    let _x = *xref; //~ ERROR borrow stack\n+    let _x = *xref;\n }"}, {"sha": "b2084da862fe08082566d380714c7d320b8c0435", "filename": "tests/fail/stacked_borrows/illegal_write1.stderr", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,24 +1,19 @@\n-error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> $DIR/illegal_write1.rs:LL:CC\n    |\n-LL |     let _x = *xref;\n-   |              ^^^^^\n-   |              |\n-   |              attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |         unsafe { *x = 42 };\n+   |                  ^^^^^^^\n+   |                  |\n+   |                  attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   |                  this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write1.rs:LL:CC\n    |\n-LL |     let xref = &*target;\n-   |                ^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4]\n-  --> $DIR/illegal_write1.rs:LL:CC\n-   |\n-LL |         unsafe { *x = 42 }; // invalidates shared ref, activates raw\n-   |                  ^^^^^^^\n+LL |         let x: *mut u32 = xref as *const _ as *mut _;\n+   |                           ^^^^\n    = note: inside `main` at $DIR/illegal_write1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "09784bd79a18884b6c42e6e9f33e30f8baf5b46a", "filename": "tests/fail/stacked_borrows/illegal_write2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     unsafe { *target2 = 13 };\n    |              ^^^^^^^^^^^^^\n    |              |\n-   |              attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |              attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     let target2 = target as *mut _;\n    |                   ^^^^^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_write2.rs:LL:CC\n    |\n LL |     drop(&mut *target); // reborrow"}, {"sha": "983894dad065c68295d9fabec8652640214e381d", "filename": "tests/fail/stacked_borrows/illegal_write3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,15 +1,15 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> $DIR/illegal_write3.rs:LL:CC\n    |\n LL |     unsafe { *ptr = 42 };\n    |              ^^^^^^^^^\n    |              |\n-   |              attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   |              attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write3.rs:LL:CC\n    |\n LL |     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag"}, {"sha": "654a23d382b8d25509540d1bcc3e002125e0e6de", "filename": "tests/fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -6,8 +6,8 @@ fn main() {\n     // Even just creating it unfreezes.\n     let raw = &mut target as *mut _; // let this leak to raw\n     let reference = unsafe { &*raw }; // freeze\n-    let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n-    let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+    let _ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n+    let _mut_ref: &mut i32 = unsafe { mem::transmute(raw) }; // &mut, with raw tag\n     // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n     let _val = *reference; //~ ERROR borrow stack\n }"}, {"sha": "ac4dd68bbc7e48215bdeec50fa7c2e32871e9648", "filename": "tests/fail/stacked_borrows/illegal_write4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -17,7 +17,7 @@ LL |     let reference = unsafe { &*raw }; // freeze\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_write4.rs:LL:CC\n    |\n-LL |     let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+LL |     let _mut_ref: &mut i32 = unsafe { mem::transmute(raw) }; // &mut, with raw tag\n    |                                       ^^^^^^^^^^^^^^^^^^^\n    = note: inside `main` at $DIR/illegal_write4.rs:LL:CC\n "}, {"sha": "563397e062d59e65a3f1c539817e64af1ba3a874", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,17 +1,17 @@\n-error: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     let p = x as *mut u32;\n    |             ^\n-help: <TAG> was protected due to a tag which was created here\n+help: <TAG> was protected due to <TAG> which was created here\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     foo(x, p);"}, {"sha": "826cdc9b5f8e649832eba72a53b1f9efc5d6010e", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,17 +1,17 @@\n-error: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <untagged> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |                         ^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let xraw = &mut x as *mut _;\n    |                ^^^^^^\n-help: <TAG> was protected due to a tag which was created here\n+help: <TAG> was protected due to <TAG> which was created here\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     inner(xraw, xref);"}, {"sha": "1cf90f91db02bfe1afc4e5b3eb553807ea568774", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,17 +1,17 @@\n-error: Undefined Behavior: not granting access to tag <untagged> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <untagged> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     let xraw = &mut x as *mut _;\n    |                ^^^^^^\n-help: <TAG> was protected due to a tag which was created here\n+help: <TAG> was protected due to <TAG> which was created here\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     inner(xraw, xref);"}, {"sha": "8afb4fee18b5168aa7bbd997d4ebcbf1e0968192", "filename": "tests/fail/stacked_borrows/mut_exclusive_violation1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |         *LEAK = 7;\n    |         ^^^^^^^^^\n    |         |\n-   |         attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |         LEAK = x as *const _ as *mut _;\n    |                ^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC\n    |\n LL |     *our = 5;"}, {"sha": "c218d500cf8b84ba712e31201a92e734703a6c52", "filename": "tests/fail/stacked_borrows/outdated_local.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     assert_eq!(unsafe { *y }, 1);\n    |                         ^^\n    |                         |\n-   |                         attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                         attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |                         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     let y: *const i32 = &x;\n    |                         ^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n+help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/outdated_local.rs:LL:CC\n    |\n LL |     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local"}, {"sha": "a3ab1b9fc5e5c2282fbe56de1f12e6159277e43a", "filename": "tests/fail/stacked_borrows/pointer_smuggling.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,20 +1,20 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |     let _x = unsafe { *PTR };\n    |                       ^^^^\n    |                       |\n-   |                       attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                       attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |                       this error occurs as part of an access at ALLOC[0x0..0x1]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x1]\n+help: <TAG> was created by a retag at offsets [0x0..0x1]\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |         PTR = x;\n    |               ^\n-help: tag was later invalidated at offsets [0x0..0x1]\n+help: <TAG> was later invalidated at offsets [0x0..0x1]\n   --> $DIR/pointer_smuggling.rs:LL:CC\n    |\n LL |     *val = 2; // this invalidates any raw ptrs `fun1` might have created."}, {"sha": "49fe983125500e9fc205be93e3bfe2c9f4ab28a7", "filename": "tests/fail/stacked_borrows/raw_tracking.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fraw_tracking.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n //! This demonstrates a provenance problem that requires tracking of raw pointers to be detected.\n \n fn main() {"}, {"sha": "55872300713a291e348a5d0989f5b5a5c2f03127", "filename": "tests/fail/stacked_borrows/shr_frozen_violation1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,15 +1,15 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n   --> $DIR/shr_frozen_violation1.rs:LL:CC\n    |\n LL |         *(x as *const i32 as *mut i32) = 7;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         attempting a write access using <untagged> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n    |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n+help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/shr_frozen_violation1.rs:LL:CC\n    |\n LL |         *(x as *const i32 as *mut i32) = 7;"}, {"sha": "91c3ff9f8634a592a9c1c54187b3417cdc7a5df9", "filename": "tests/fail/stacked_borrows/transmute-is-no-escape.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,15 +1,19 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/transmute-is-no-escape.rs:LL:CC\n    |\n LL |     unsafe { *raw = 13 };\n    |              ^^^^^^^^^\n    |              |\n-   |              attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |              attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-           \n+help: <TAG> was created by a retag at offsets [0x4..0x8]\n+  --> $DIR/transmute-is-no-escape.rs:LL:CC\n+   |\n+LL |     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n+   |                ^^^^^^^^^\n    = note: inside `main` at $DIR/transmute-is-no-escape.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "c994f6c3818a975f75cc2c7c47f345802be2f69b", "filename": "tests/fail/stacked_borrows/unescaped_local.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n // Make sure we cannot use raw ptrs to access a local that\n // we took the direct address of.\n fn main() {"}, {"sha": "464296651c5e6c17cb06d76a4a18ff5e41befdfd", "filename": "tests/fail/stacked_borrows/unescaped_local.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Funescaped_local.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,24 +1,15 @@\n-error: Undefined Behavior: attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n   --> $DIR/unescaped_local.rs:LL:CC\n    |\n LL |         *raw = 13;\n    |         ^^^^^^^^^\n    |         |\n-   |         attempting a write access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags have suitable permission in the borrow stack for this location\n    |         this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: tag was most recently created at offsets [0x0..0x4]\n-  --> $DIR/unescaped_local.rs:LL:CC\n-   |\n-LL |     let raw = &mut x as *mut i32 as usize as *mut i32;\n-   |               ^^^^^^\n-help: tag was later invalidated at offsets [0x0..0x4]\n-  --> $DIR/unescaped_local.rs:LL:CC\n-   |\n-LL |     let _ptr = &mut x;\n-   |                ^^^^^^\n+           \n    = note: inside `main` at $DIR/unescaped_local.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "621e9617fdfcc68618e0f19f4de08234e76a33ec", "filename": "tests/fail/stacked_borrows/unescaped_static.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,15 +1,19 @@\n-error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n   --> $DIR/unescaped_static.rs:LL:CC\n    |\n LL |     let _val = unsafe { *ptr_to_first.add(1) };\n    |                         ^^^^^^^^^^^^^^^^^^^^\n    |                         |\n-   |                         attempting a read access using <untagged> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n+   |                         attempting a read access using <TAG> at ALLOC[0x1], but that tag does not exist in the borrow stack for this location\n    |                         this error occurs as part of an access at ALLOC[0x1..0x2]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-           \n+help: <TAG> was created by a retag at offsets [0x0..0x1]\n+  --> $DIR/unescaped_static.rs:LL:CC\n+   |\n+LL |     let ptr_to_first = &ARRAY[0] as *const u8;\n+   |                        ^^^^^^^^^\n    = note: inside `main` at $DIR/unescaped_static.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "dea9335ab751ab258b7f15e13c92fa074901d96c", "filename": "tests/fail/unaligned_pointers/intptrcast_alignment_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-symbolic-alignment-check\n+// compile-flags: -Zmiri-symbolic-alignment-check -Zmiri-permissive-provenance\n // With the symbolic alignment check, even with intptrcast and without\n // validation, we want to be *sure* to catch bugs that arise from pointers being\n // insufficiently aligned. The only way to achieve that is not not let programs"}, {"sha": "683088e78bffb517c1533d780c1c78c76e38fde7", "filename": "tests/fail/uninit_byte_read.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Funinit_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Funinit_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funinit_byte_read.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-disable-stacked-borrows\n fn main() {\n     let v: Vec<u8> = Vec::with_capacity(10);\n     let undef = unsafe { *v.get_unchecked(5) }; //~ ERROR uninitialized"}, {"sha": "eb5774fe7995680ad1d3207935e6d8ca701ea6b7", "filename": "tests/fail/validity/cast_fn_ptr1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr1.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n fn main() {\n     // Cast a function pointer such that on a call, the argument gets transmuted\n     // from raw ptr to reference. This is ABI-compatible, so it's not the call that"}, {"sha": "1cf4ca7d19d8ec8fa3934c5e41294bc130bba49c", "filename": "tests/fail/validity/cast_fn_ptr2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Fcast_fn_ptr2.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n fn main() {\n     // Cast a function pointer such that when returning, the return value gets transmuted\n     // from raw ptr to reference. This is ABI-compatible, so it's not the call that"}, {"sha": "b3483a5b43800e4bd2b87b587608bcb31ef0a586", "filename": "tests/pass/adjacent-allocs.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fadjacent-allocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fadjacent-allocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fadjacent-allocs.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,7 +1,9 @@\n-fn main() {\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn test1() {\n     // The slack between allocations is random.\n     // Loop a few times to hit the zero-slack case.\n-    for _ in 0..1024 {\n+    for _ in 0..512 {\n         let n = 0u64;\n         let ptr: *const u64 = &n;\n \n@@ -20,3 +22,26 @@ fn main() {\n         unsafe { *zst }\n     }\n }\n+\n+fn test2() {\n+    fn foo() -> u64 {\n+        0\n+    }\n+\n+    for _ in 0..512 {\n+        let n = 0u64;\n+        let ptr: *const u64 = &n;\n+        foo();\n+        let iptr = ptr as usize;\n+        unsafe {\n+            let start = &*std::ptr::slice_from_raw_parts(iptr as *const (), 1);\n+            let end = &*std::ptr::slice_from_raw_parts((iptr + 8) as *const (), 1);\n+            assert_eq!(start.len(), end.len());\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+}"}, {"sha": "f412541bde17add05ca5cfde1d144ece8a87c322", "filename": "tests/pass/align.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Falign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Falign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Falign.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n /// This manually makes sure that we have a pointer with the proper alignment.\n fn manual_alignment() {\n     let x = &mut [0u8; 3];"}, {"sha": "7bbe7be516b9a5b9e593c429a1081e3808558909", "filename": "tests/pass/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbox.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -47,7 +47,7 @@ fn boxed_pair_to_vec() {\n     struct Foo(u64);\n     fn reinterstruct(box_pair: Box<PairFoo>) -> Vec<Foo> {\n         let ref_pair = Box::leak(box_pair) as *mut PairFoo;\n-        let ptr_foo = unsafe { &mut (*ref_pair).fst as *mut Foo };\n+        let ptr_foo = unsafe { std::ptr::addr_of_mut!((*ref_pair).fst) };\n         unsafe { Vec::from_raw_parts(ptr_foo, 2, 2) }\n     }\n "}, {"sha": "d821fcd9d15134a805038194ea8bc908240cb63d", "filename": "tests/pass/box.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fbox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fbox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbox.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -0,0 +1,33 @@\n+warning: integer-to-pointer cast\n+  --> $DIR/box.rs:LL:CC\n+   |\n+LL |         let r2 = ((r as usize) + 0) as *mut i32;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `into_raw` at $DIR/box.rs:LL:CC\n+note: inside `main` at $DIR/box.rs:LL:CC\n+  --> $DIR/box.rs:LL:CC\n+   |\n+LL |     into_raw();\n+   |     ^^^^^^^^^^\n+\n+warning: integer-to-pointer cast\n+  --> $DIR/box.rs:LL:CC\n+   |\n+LL |         let r = ((u.as_ptr() as usize) + 0) as *mut i32;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n+   |\n+   = note: inside `into_unique` at $DIR/box.rs:LL:CC\n+note: inside `main` at $DIR/box.rs:LL:CC\n+  --> $DIR/box.rs:LL:CC\n+   |\n+LL |     into_unique();\n+   |     ^^^^^^^^^^^^^\n+"}, {"sha": "29c57bf49a3384af4266dc1208ccc33ec8f09608", "filename": "tests/pass/concurrency/tls_pthread_drop_order.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_pthread_drop_order.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -4,14 +4,15 @@\n extern crate libc;\n \n use std::mem;\n+use std::ptr;\n \n pub type Key = libc::pthread_key_t;\n \n static mut RECORD: usize = 0;\n static mut KEYS: [Key; 2] = [0; 2];\n static mut GLOBALS: [u64; 2] = [1, 0];\n \n-static mut CANNARY: *mut u64 = 0 as *mut _; // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n+static mut CANNARY: *mut u64 = ptr::null_mut(); // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n \n pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n@@ -30,7 +31,7 @@ pub fn record(r: usize) {\n }\n \n unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n-    assert!(CANNARY != 0 as *mut _); // make sure we do not get run too often\n+    assert!(CANNARY != ptr::null_mut()); // make sure we do not get run too often\n     let val = *ptr;\n \n     let which_key =\n@@ -48,7 +49,7 @@ unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n     // The correct sequence is: First key 0, then key 1, then key 0.\n     if RECORD == 0_1_0 {\n         drop(Box::from_raw(CANNARY));\n-        CANNARY = 0 as *mut _;\n+        CANNARY = ptr::null_mut();\n     }\n }\n "}, {"sha": "f23526b52b4e77209261467e99f508f55fcb98a9", "filename": "tests/pass/extern_types.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fextern_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fextern_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fextern_types.stderr?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -0,0 +1,15 @@\n+warning: integer-to-pointer cast\n+  --> $DIR/extern_types.rs:LL:CC\n+   |\n+LL |     let x: &Foo = unsafe { &*(16 as *const Foo) };\n+   |                              ^^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n+   |\n+   = help: this program is using integer-to-pointer casts or (equivalently) `from_exposed_addr`,\n+   = help: which means that Miri might miss pointer bugs in this program\n+   = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation\n+   = help: to ensure that Miri does not miss bugs in your program, use `with_addr` (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance) instead\n+   = help: you can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics\n+   = help: alternatively, the `-Zmiri-permissive-provenance` flag disables this warning\n+           \n+   = note: inside `main` at $DIR/extern_types.rs:LL:CC\n+"}, {"sha": "2417a83493bef7ad13e1603b6a0338971d8da949", "filename": "tests/pass/intptrcast.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintptrcast.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n // This strips provenance\n fn transmute_ptr_to_int<T>(x: *const T) -> usize {\n     unsafe { std::mem::transmute(x) }\n@@ -88,6 +90,16 @@ fn ptr_eq_integer() {\n     assert!(x != 64 as *const i32);\n }\n \n+fn zst_deref_of_dangling() {\n+    let b = Box::new(0);\n+    let addr = &*b as *const _ as usize;\n+    drop(b);\n+    // Now if we cast `addr` to a ptr it might pick up the dangling provenance.\n+    // But if we only do a ZST deref there is no UB here!\n+    let zst = addr as *const ();\n+    let _val = unsafe { *zst };\n+}\n+\n fn main() {\n     cast();\n     cast_dangling();\n@@ -99,4 +111,5 @@ fn main() {\n     ptr_eq_out_of_bounds();\n     ptr_eq_out_of_bounds_null();\n     ptr_eq_integer();\n+    zst_deref_of_dangling();\n }"}, {"sha": "0042872a3b45b9e6e04928654ccabe10164cb497", "filename": "tests/pass/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(core_intrinsics, const_raw_ptr_comparison)]\n #![feature(layout_for_ptr)]\n "}, {"sha": "56a53699477e816022ea27b2d41dc7085f153f76", "filename": "tests/pass/linux-getrandom-without-isolation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Flinux-getrandom-without-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Flinux-getrandom-without-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinux-getrandom-without-isolation.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -3,13 +3,15 @@\n #![feature(rustc_private)]\n extern crate libc;\n \n+use std::ptr;\n+\n fn main() {\n     let mut buf = [0u8; 5];\n     unsafe {\n         assert_eq!(\n             libc::syscall(\n                 libc::SYS_getrandom,\n-                0 as *mut libc::c_void,\n+                ptr::null_mut::<libc::c_void>(),\n                 0 as libc::size_t,\n                 0 as libc::c_uint,\n             ),\n@@ -26,7 +28,7 @@ fn main() {\n         );\n \n         assert_eq!(\n-            libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint),\n+            libc::getrandom(ptr::null_mut::<libc::c_void>(), 0 as libc::size_t, 0 as libc::c_uint),\n             0,\n         );\n         assert_eq!("}, {"sha": "a3596e4c7a9c02c1de452d73aca6ba9775b37081", "filename": "tests/pass/linux-getrandom.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Flinux-getrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Flinux-getrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Flinux-getrandom.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -2,13 +2,15 @@\n #![feature(rustc_private)]\n extern crate libc;\n \n+use std::ptr;\n+\n fn main() {\n     let mut buf = [0u8; 5];\n     unsafe {\n         assert_eq!(\n             libc::syscall(\n                 libc::SYS_getrandom,\n-                0 as *mut libc::c_void,\n+                ptr::null_mut::<libc::c_void>(),\n                 0 as libc::size_t,\n                 0 as libc::c_uint,\n             ),\n@@ -25,7 +27,7 @@ fn main() {\n         );\n \n         assert_eq!(\n-            libc::getrandom(0 as *mut libc::c_void, 0 as libc::size_t, 0 as libc::c_uint),\n+            libc::getrandom(ptr::null_mut::<libc::c_void>(), 0 as libc::size_t, 0 as libc::c_uint),\n             0,\n         );\n         assert_eq!("}, {"sha": "3979fb3b071465e59ec5c9f3f3e98c0a3c32fd46", "filename": "tests/pass/panic/catch_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fcatch_panic.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,5 +1,5 @@\n // We test the `align_offset` panic below, make sure we test the interpreter impl and not the \"real\" one.\n-// compile-flags: -Zmiri-symbolic-alignment-check\n+// compile-flags: -Zmiri-symbolic-alignment-check -Zmiri-permissive-provenance\n #![feature(never_type)]\n #![allow(unconditional_panic, non_fmt_panics)]\n "}, {"sha": "ffe6a114c66b367f8cc61b1020c40c2265c7ec67", "filename": "tests/pass/ptr_int_casts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_int_casts.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n use std::mem;\n use std::ptr;\n "}, {"sha": "b16a06a7260b3e45ebf09c1ee0dd3ff5ea2332e7", "filename": "tests/pass/ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_offset.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n use std::{mem, ptr};\n \n fn main() {"}, {"sha": "eb543d691e10be09d8abe09c0bebb6186ca44177", "filename": "tests/pass/stacked-borrows/2phase.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fstacked-borrows%2F2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fstacked-borrows%2F2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2F2phase.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n-\n trait S: Sized {\n     fn tpb(&mut self, _s: Self) {}\n }"}, {"sha": "79958ab5539d4340cd877f7b18ad5be3e0b4675a", "filename": "tests/pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Finterior_mutability.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n use std::cell::{Cell, RefCell, UnsafeCell};\n use std::mem::{self, MaybeUninit};\n "}, {"sha": "eb0ff167eb123a07bdee9a8332f659094522d015", "filename": "tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-tag-raw-pointers\n use std::ptr;\n \n // Test various stacked-borrows-related things."}, {"sha": "fade1e0dad88feffaae23abd57b72505d0da4b16", "filename": "tests/pass/zst.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fafbde038ed492ba0ecc6c57f2a7ba229042df7/tests%2Fpass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fzst.rs?ref=7fafbde038ed492ba0ecc6c57f2a7ba229042df7", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmiri-permissive-provenance\n #[derive(PartialEq, Debug)]\n struct A;\n "}]}