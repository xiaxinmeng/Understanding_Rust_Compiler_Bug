{"sha": "3e6b4545f92df0966c687e6a7238f07da874bb49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNmI0NTQ1ZjkyZGYwOTY2YzY4N2U2YTcyMzhmMDdkYTg3NGJiNDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-26T18:35:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-04T20:38:43Z"}, "message": "Introduce a `SwitchInt` and restructure pattern matching to collect\nintegers and characters into one master switch.", "tree": {"sha": "39977d8bef99ec586ce8f0ca1e8a18dbaeaef16f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39977d8bef99ec586ce8f0ca1e8a18dbaeaef16f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e6b4545f92df0966c687e6a7238f07da874bb49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6b4545f92df0966c687e6a7238f07da874bb49", "html_url": "https://github.com/rust-lang/rust/commit/3e6b4545f92df0966c687e6a7238f07da874bb49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e6b4545f92df0966c687e6a7238f07da874bb49/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fa8684b4c70989fefd42399d9cdce8627722e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa8684b4c70989fefd42399d9cdce8627722e3c", "html_url": "https://github.com/rust-lang/rust/commit/8fa8684b4c70989fefd42399d9cdce8627722e3c"}], "stats": {"total": 393, "additions": 319, "deletions": 74}, "files": [{"sha": "5e67abaa4739cb4fc02c75eb2a424548e73cf96f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3e6b4545f92df0966c687e6a7238f07da874bb49", "patch": "@@ -39,6 +39,7 @@ use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n+use std::hash;\n use std::mem::transmute;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64};\n use std::rc::Rc;\n@@ -257,6 +258,22 @@ pub enum ConstVal {\n     Function(DefId),\n }\n \n+impl hash::Hash for ConstVal {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        match *self {\n+            Float(a) => unsafe { transmute::<_,u64>(a) }.hash(state),\n+            Int(a) => a.hash(state),\n+            Uint(a) => a.hash(state),\n+            Str(ref a) => a.hash(state),\n+            ByteStr(ref a) => a.hash(state),\n+            Bool(a) => a.hash(state),\n+            Struct(a) => a.hash(state),\n+            Tuple(a) => a.hash(state),\n+            Function(a) => a.hash(state),\n+        }\n+    }\n+}\n+\n /// Note that equality for `ConstVal` means that the it is the same\n /// constant, not that the rust values are equal. In particular, `NaN\n /// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n@@ -278,6 +295,8 @@ impl PartialEq for ConstVal {\n     }\n }\n \n+impl Eq for ConstVal { }\n+\n impl ConstVal {\n     pub fn description(&self) -> &'static str {\n         match *self {"}, {"sha": "e72d903756a1ddfedc1ba984366beabbe0b554b5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3e6b4545f92df0966c687e6a7238f07da874bb49", "patch": "@@ -15,6 +15,8 @@\n \n use build::{BlockAnd, Builder};\n use repr::*;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::middle::const_eval::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::ty::{AdtDef, Ty};\n use hair::*;\n@@ -241,6 +243,13 @@ enum TestKind<'tcx> {\n         adt_def: AdtDef<'tcx>,\n     },\n \n+    // test the branches of enum\n+    SwitchInt {\n+        switch_ty: Ty<'tcx>,\n+        options: Vec<ConstVal>,\n+        indices: FnvHashMap<ConstVal, usize>,\n+    },\n+\n     // test for equality\n     Eq {\n         value: Literal<'tcx>,\n@@ -315,20 +324,36 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // otherwise, extract the next match pair and construct tests\n         let match_pair = &candidates.last().unwrap().match_pairs[0];\n-        let test = self.test(match_pair);\n+        let mut test = self.test(match_pair);\n+\n+        // most of the time, the test to perform is simply a function\n+        // of the main candidate; but for a test like SwitchInt, we\n+        // may want to add cases based on the candidates that are\n+        // available\n+        match test.kind {\n+            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+                for candidate in &candidates {\n+                    self.add_cases_to_switch(&match_pair.lvalue,\n+                                             candidate,\n+                                             switch_ty,\n+                                             options,\n+                                             indices);\n+                }\n+            }\n+            _ => { }\n+        }\n+\n         debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n \n-        for (outcome, mut target_block) in target_blocks.into_iter().enumerate() {\n+        for (outcome, target_block) in target_blocks.into_iter().enumerate() {\n             let applicable_candidates: Vec<Candidate<'tcx>> =\n                 candidates.iter()\n                           .filter_map(|candidate| {\n-                              unpack!(target_block =\n-                                      self.candidate_under_assumption(target_block,\n-                                                                      &match_pair.lvalue,\n-                                                                      &test.kind,\n-                                                                      outcome,\n-                                                                      candidate))\n+                              self.candidate_under_assumption(&match_pair.lvalue,\n+                                                              &test.kind,\n+                                                              outcome,\n+                                                              candidate)\n                           })\n                           .collect();\n             self.match_candidates(span, arm_blocks, applicable_candidates, target_block);"}, {"sha": "162ef135dc0101143f52460716d4ab4ee325784f", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 232, "deletions": 65, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=3e6b4545f92df0966c687e6a7238f07da874bb49", "patch": "@@ -15,10 +15,13 @@\n // identify what tests are needed, perform the tests, and then filter\n // the candidates based on the result.\n \n-use build::{BlockAnd, Builder};\n+use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use repr::*;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::ty::Ty;\n use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n@@ -34,13 +37,31 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n             }\n \n+            PatternKind::Constant { value: Literal::Value { .. } }\n+            if is_switch_ty(match_pair.pattern.ty) => {\n+                // for integers, we use a SwitchInt match, which allows\n+                // us to handle more cases\n+                Test {\n+                    span: match_pair.pattern.span,\n+                    kind: TestKind::SwitchInt {\n+                        switch_ty: match_pair.pattern.ty,\n+\n+                        // these maps are empty to start; cases are\n+                        // added below in add_cases_to_switch\n+                        options: vec![],\n+                        indices: FnvHashMap(),\n+                    }\n+                }\n+            }\n+\n             PatternKind::Constant { ref value } => {\n+                // for other types, we use an equality comparison\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n                         value: value.clone(),\n                         ty: match_pair.pattern.ty.clone(),\n-                    },\n+                    }\n                 }\n             }\n \n@@ -78,13 +99,52 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n+    pub fn add_cases_to_switch(&mut self,\n+                               test_lvalue: &Lvalue<'tcx>,\n+                               candidate: &Candidate<'tcx>,\n+                               switch_ty: Ty<'tcx>,\n+                               options: &mut Vec<ConstVal>,\n+                               indices: &mut FnvHashMap<ConstVal, usize>)\n+    {\n+        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n+            Some(match_pair) => match_pair,\n+            _ => { return; }\n+        };\n+\n+        match match_pair.pattern.kind {\n+            PatternKind::Constant { value: Literal::Value { ref value } } => {\n+                // if the lvalues match, the type should match\n+                assert_eq!(match_pair.pattern.ty, switch_ty);\n+\n+                indices.entry(value.clone())\n+                       .or_insert_with(|| {\n+                           options.push(value.clone());\n+                           options.len() - 1\n+                       });\n+            }\n+\n+            PatternKind::Range { .. } => {\n+            }\n+\n+            PatternKind::Constant { .. } |\n+            PatternKind::Variant { .. } |\n+            PatternKind::Slice { .. } |\n+            PatternKind::Array { .. } |\n+            PatternKind::Wild |\n+            PatternKind::Binding { .. } |\n+            PatternKind::Leaf { .. } |\n+            PatternKind::Deref { .. } => {\n+            }\n+        }\n+    }\n+\n     /// Generates the code to perform a test.\n     pub fn perform_test(&mut self,\n                         block: BasicBlock,\n                         lvalue: &Lvalue<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n-        match test.kind.clone() {\n+        match test.kind {\n             TestKind::Switch { adt_def } => {\n                 let num_enum_variants = self.hir.num_variants(adt_def);\n                 let target_blocks: Vec<_> =\n@@ -98,18 +158,34 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 target_blocks\n             }\n \n-            TestKind::Eq { value, ty } => {\n+            TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n+                let otherwise = self.cfg.start_new_block();\n+                let targets: Vec<_> =\n+                    options.iter()\n+                           .map(|_| self.cfg.start_new_block())\n+                           .chain(Some(otherwise))\n+                           .collect();\n+                self.cfg.terminate(block, Terminator::SwitchInt {\n+                    discr: lvalue.clone(),\n+                    switch_ty: switch_ty,\n+                    values: options.clone(),\n+                    targets: targets.clone(),\n+                });\n+                targets\n+            }\n+\n+            TestKind::Eq { ref value, ty } => {\n                 // call PartialEq::eq(discrim, constant)\n-                let constant = self.literal_operand(test.span, ty.clone(), value);\n+                let constant = self.literal_operand(test.span, ty.clone(), value.clone());\n                 let item_ref = self.hir.partial_eq(ty);\n                 self.call_comparison_fn(block, test.span, item_ref,\n                                         Operand::Consume(lvalue.clone()), constant)\n             }\n \n-            TestKind::Range { lo, hi, ty } => {\n+            TestKind::Range { ref lo, ref hi, ty } => {\n                 // Test `v` by computing `PartialOrd::le(lo, v) && PartialOrd::le(v, hi)`.\n-                let lo = self.literal_operand(test.span, ty.clone(), lo);\n-                let hi = self.literal_operand(test.span, ty.clone(), hi);\n+                let lo = self.literal_operand(test.span, ty.clone(), lo.clone());\n+                let hi = self.literal_operand(test.span, ty.clone(), hi.clone());\n                 let item_ref = self.hir.partial_le(ty);\n \n                 let lo_blocks = self.call_comparison_fn(block,\n@@ -207,34 +283,31 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// were `Ok`, we would return `Some([x.0.downcast<Ok>.0 @ P1, x.1\n     /// @ 22])`.\n     pub fn candidate_under_assumption(&mut self,\n-                                      mut block: BasicBlock,\n                                       test_lvalue: &Lvalue<'tcx>,\n                                       test_kind: &TestKind<'tcx>,\n                                       test_outcome: usize,\n                                       candidate: &Candidate<'tcx>)\n-                                      -> BlockAnd<Option<Candidate<'tcx>>> {\n+                                      -> Option<Candidate<'tcx>> {\n         let candidate = candidate.clone();\n         let match_pairs = candidate.match_pairs;\n-        let result = unpack!(block = self.match_pairs_under_assumption(block,\n-                                                                       test_lvalue,\n-                                                                       test_kind,\n-                                                                       test_outcome,\n-                                                                       match_pairs));\n-        block.and(match result {\n+        let result = self.match_pairs_under_assumption(test_lvalue,\n+                                                       test_kind,\n+                                                       test_outcome,\n+                                                       match_pairs);\n+        match result {\n             Some(match_pairs) => Some(Candidate { match_pairs: match_pairs, ..candidate }),\n             None => None,\n-        })\n+        }\n     }\n \n     /// Helper for candidate_under_assumption that does the actual\n     /// work of transforming the list of match pairs.\n     fn match_pairs_under_assumption(&mut self,\n-                                    mut block: BasicBlock,\n                                     test_lvalue: &Lvalue<'tcx>,\n                                     test_kind: &TestKind<'tcx>,\n                                     test_outcome: usize,\n                                     match_pairs: Vec<MatchPair<'tcx>>)\n-                                    -> BlockAnd<Option<Vec<MatchPair<'tcx>>>> {\n+                                    -> Option<Vec<MatchPair<'tcx>>> {\n         let mut result = vec![];\n \n         for match_pair in match_pairs {\n@@ -245,38 +318,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 continue;\n             }\n \n-            let desired_test = self.test(&match_pair);\n-\n-            if *test_kind != desired_test.kind {\n-                // if the match pair wants to (e.g.) test for\n-                // equality against some particular constant, but\n-                // we did a switch, then we can't say whether it\n-                // matches or not, so we still have to include it\n-                // as a possibility.\n-                //\n-                // For example, we have a constant `FOO:\n-                // Option<i32> = Some(22)`, and `match_pair` is `x\n-                // @ FOO`, but we did a switch on the variant\n-                // (`Some` vs `None`). (OK, in principle this\n-                // could tell us something, but we're not that\n-                // smart yet to actually dig into the constant\n-                // itself)\n+            // if this test doesn't tell us anything about this match-pair, then hang onto it.\n+            if !self.test_informs_match_pair(&match_pair, test_kind, test_outcome) {\n                 result.push(match_pair);\n                 continue;\n             }\n \n+            // otherwise, build up the consequence match pairs\n             let opt_consequent_match_pairs =\n-                unpack!(block = self.consequent_match_pairs_under_assumption(block,\n-                                                                             match_pair,\n-                                                                             test_outcome));\n+                self.consequent_match_pairs_under_assumption(match_pair,\n+                                                             test_kind,\n+                                                             test_outcome);\n             match opt_consequent_match_pairs {\n                 None => {\n                     // Right kind of test, but wrong outcome. That\n                     // means this **entire candidate** is\n                     // inapplicable, since the candidate is only\n                     // applicable if all of its match-pairs apply (and\n                     // this one doesn't).\n-                    return block.and(None);\n+                    return None;\n                 }\n \n                 Some(consequent_match_pairs) => {\n@@ -285,23 +345,122 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n             }\n         }\n-        block.and(Some(result))\n+\n+        Some(result)\n     }\n \n-    /// Identifies what test is needed to decide if `match_pair` is applicable.\n+    /// Given that we executed `test` to `match_pair.lvalue` with\n+    /// outcome `test_outcome`, does that tell us anything about\n+    /// whether `match_pair` applies?\n     ///\n-    /// It is a bug to call this with a simplifyable pattern.\n+    /// Often it does not. For example, if we are testing whether\n+    /// the discriminant equals 4, and we find that it does not,\n+    /// but the `match_pair` is testing if the discriminant equals 5,\n+    /// that does not help us.\n+    fn test_informs_match_pair(&mut self,\n+                               match_pair: &MatchPair<'tcx>,\n+                               test_kind: &TestKind<'tcx>,\n+                               _test_outcome: usize)\n+                               -> bool {\n+        match match_pair.pattern.kind {\n+            PatternKind::Variant { .. } => {\n+                match *test_kind {\n+                    TestKind::Switch { .. } => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            PatternKind::Constant { value: Literal::Value { .. } }\n+            if is_switch_ty(match_pair.pattern.ty) => {\n+                match *test_kind {\n+                    TestKind::SwitchInt { .. } => true,\n+\n+                    // Did not do an integer equality test (which is always a SwitchInt).\n+                    // So we learned nothing relevant to this match-pair.\n+                    //\n+                    // TODO we could use TestKind::Range to rule\n+                    // things out here, in some cases.\n+                    _ => false,\n+                }\n+            }\n+\n+            PatternKind::Constant { .. } |\n+            PatternKind::Range { .. } |\n+            PatternKind::Slice { .. } => {\n+                let pattern_test = self.test(&match_pair);\n+                if pattern_test.kind == *test_kind {\n+                    true\n+                } else {\n+                    // TODO in all 3 cases, we could sometimes do\n+                    // better here. For example, if we are checking\n+                    // whether the value is equal to X, and we find\n+                    // that it is, that (may) imply value is not equal\n+                    // to Y. Or, if the range tested is `3..5`, and\n+                    // our range is `4..5`, then we know that our\n+                    // range also does not apply. Similarly, if we\n+                    // test that length is >= 5, and it fails, we also\n+                    // know that length is not >= 7. etc.\n+                    false\n+                }\n+            }\n+\n+            PatternKind::Array { .. } |\n+            PatternKind::Wild |\n+            PatternKind::Binding { .. } |\n+            PatternKind::Leaf { .. } |\n+            PatternKind::Deref { .. } => {\n+                self.error_simplifyable(&match_pair)\n+            }\n+        }\n+    }\n+\n+    /// Given that we executed `test` with outcome `test_outcome`,\n+    /// what are the resulting match pairs? This can return either:\n+    ///\n+    /// - None, meaning that the test indicated that this outcome\n+    ///   means that this match-pair is not the current one for the\n+    ///   current discriminant (which rules out the enclosing\n+    ///   candidate);\n+    /// - Some(...), meaning that either the test didn't tell us whether this\n+    ///   match-pair is correct or not, or that we DID match and now have\n+    ///   subsequent matches to perform.\n+    ///\n+    /// As an example, consider:\n+    ///\n+    /// ```\n+    /// match option {\n+    ///     Ok(<pattern>) => ...,\n+    ///     Err(_) => ...,\n+    /// }\n+    /// ```\n+    ///\n+    /// Suppose that the `test` is a `Switch` and the outcome is\n+    /// `Ok`. Then in that case, the first arm will have a match-pair\n+    /// of `option @ Ok(<pattern>)`. In that case we will return\n+    /// `Some(vec![(option as Ok) @ <pattern>])`. The `Some` reuslt\n+    /// indicates that the match-pair still applies, and we now have\n+    /// to test `(option as Ok) @ <pattern>`.\n+    ///\n+    /// On the second arm, a `None` will be returned, because if we\n+    /// observed that `option` has the discriminant `Ok`, then the\n+    /// second arm cannot apply.\n     pub fn consequent_match_pairs_under_assumption(&mut self,\n-                                                   mut block: BasicBlock,\n                                                    match_pair: MatchPair<'tcx>,\n+                                                   test_kind: &TestKind<'tcx>,\n                                                    test_outcome: usize)\n-                                                   -> BlockAnd<Option<Vec<MatchPair<'tcx>>>> {\n+                                                   -> Option<Vec<MatchPair<'tcx>>> {\n         match match_pair.pattern.kind {\n             PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n+                assert!(match *test_kind { TestKind::Switch { .. } => true,\n+                                           _ => false });\n+\n                 if test_outcome != variant_index {\n-                    return block.and(None);\n+                    return None; // Tested, but found the wrong variant.\n                 }\n \n+                // Correct variant. Extract the subitems and match\n+                // those. The lvalue goes gets downcast, so\n+                // e.g. `foo.bar` becomes `foo.bar as Variant`.\n                 let elem = ProjectionElem::Downcast(adt_def, variant_index);\n                 let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n                 let consequent_match_pairs =\n@@ -313,33 +472,37 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                    self.match_pair(lvalue, subpattern.pattern)\n                                })\n                                .collect();\n-                block.and(Some(consequent_match_pairs))\n+                Some(consequent_match_pairs)\n             }\n \n-            PatternKind::Constant { .. } |\n-            PatternKind::Range { .. } => {\n-                // these are boolean tests: if we are on the 0th\n-                // successor, then they passed, and otherwise they\n-                // failed, but there are never any more tests to come.\n-                if test_outcome == 0 {\n-                    block.and(Some(vec![]))\n-                } else {\n-                    block.and(None)\n+            PatternKind::Constant { value: Literal::Value { ref value } }\n+            if is_switch_ty(match_pair.pattern.ty) => {\n+                match *test_kind {\n+                    TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n+                        let index = indices[value];\n+                        if index == test_outcome {\n+                            Some(vec![]) // this value, nothing left to test\n+                        } else {\n+                            None // some other value, candidate is inapplicable\n+                        }\n+                    }\n+\n+                    _ => {\n+                        self.hir.span_bug(\n+                            match_pair.pattern.span,\n+                            &format!(\"did a switch-int, but value {:?} not found in cases\",\n+                                     value));\n+                    }\n                 }\n             }\n \n-            PatternKind::Slice { prefix, slice, suffix } => {\n+            PatternKind::Constant { .. } |\n+            PatternKind::Range { .. } |\n+            PatternKind::Slice { .. } => {\n                 if test_outcome == 0 {\n-                    let mut consequent_match_pairs = vec![];\n-                    unpack!(block = self.prefix_suffix_slice(&mut consequent_match_pairs,\n-                                                             block,\n-                                                             match_pair.lvalue,\n-                                                             prefix,\n-                                                             slice,\n-                                                             suffix));\n-                    block.and(Some(consequent_match_pairs))\n+                    Some(vec![])\n                 } else {\n-                    block.and(None)\n+                    None\n                 }\n             }\n \n@@ -358,3 +521,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n     }\n }\n+\n+fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {\n+    ty.is_integral() || ty.is_char()\n+}"}, {"sha": "2871ebcaafc9a3f32722f9168526a9840aba739a", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=3e6b4545f92df0966c687e6a7238f07da874bb49", "patch": "@@ -251,6 +251,26 @@ pub enum Terminator<'tcx> {\n         targets: Vec<BasicBlock>,\n     },\n \n+    /// operand evaluates to an integer; jump depending on its value\n+    /// to one of the targets, and otherwise fallback to `otherwise`\n+    SwitchInt {\n+        /// discriminant value being tested\n+        discr: Lvalue<'tcx>,\n+\n+        /// type of value being tested\n+        switch_ty: Ty<'tcx>,\n+\n+        /// Possible values. The locations to branch to in each case\n+        /// are found in the corresponding indices from the `targets` vector.\n+        values: Vec<ConstVal>,\n+\n+        /// Possible branch sites. The length of this vector should be\n+        /// equal to the length of the `values` vector plus 1 -- the\n+        /// extra item is the block to branch to if none of the values\n+        /// fit.\n+        targets: Vec<BasicBlock>,\n+    },\n+\n     /// Indicates that the last statement in the block panics, aborts,\n     /// etc. No successors. This terminator appears on exactly one\n     /// basic block which we create in advance. However, during\n@@ -280,7 +300,8 @@ impl<'tcx> Terminator<'tcx> {\n             Goto { target: ref b } => slice::ref_slice(b),\n             Panic { target: ref b } => slice::ref_slice(b),\n             If { cond: _, targets: ref b } => b,\n-            Switch { discr: _, adt_def: _, targets: ref b } => b,\n+            Switch { targets: ref b, .. } => b,\n+            SwitchInt { targets: ref b, .. } => b,\n             Diverge => &[],\n             Return => &[],\n             Call { data: _, targets: ref b } => b,\n@@ -321,6 +342,8 @@ impl<'tcx> Debug for Terminator<'tcx> {\n                 write!(fmt, \"if({:?}) -> {:?}\", lv, targets),\n             Switch { discr: ref lv, adt_def: _, ref targets } =>\n                 write!(fmt, \"switch({:?}) -> {:?}\", lv, targets),\n+            SwitchInt { discr: ref lv, switch_ty: _, ref values, ref targets } =>\n+                write!(fmt, \"switchInt({:?}, {:?}) -> {:?}\", lv, values, targets),\n             Diverge =>\n                 write!(fmt, \"diverge\"),\n             Return =>"}, {"sha": "06a5c9fa9b7ae2bfd199ba3e3b88bc4273ab6562", "filename": "src/librustc_mir/visit.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_mir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fvisit.rs?ref=3e6b4545f92df0966c687e6a7238f07da874bb49", "patch": "@@ -109,6 +109,13 @@ pub trait Visitor<'tcx> {\n                 }\n             }\n \n+            Terminator::SwitchInt { ref discr, switch_ty: _, values: _, ref targets } => {\n+                self.visit_lvalue(discr, LvalueContext::Inspect);\n+                for &target in targets {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+\n             Terminator::Diverge |\n             Terminator::Return => {\n             }"}, {"sha": "b47e66ef7f55a48a9890fb514068fa12f1f0482e", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b4545f92df0966c687e6a7238f07da874bb49/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=3e6b4545f92df0966c687e6a7238f07da874bb49", "patch": "@@ -50,6 +50,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 unimplemented!()\n             }\n \n+            mir::Terminator::SwitchInt { .. } => {\n+                unimplemented!()\n+            }\n+\n             mir::Terminator::Diverge => {\n                 if let Some(llpersonalityslot) = self.llpersonalityslot {\n                     let lp = build::Load(bcx, llpersonalityslot);"}]}