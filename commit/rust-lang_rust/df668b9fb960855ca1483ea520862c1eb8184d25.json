{"sha": "df668b9fb960855ca1483ea520862c1eb8184d25", "node_id": "C_kwDOAAsO6NoAKGRmNjY4YjlmYjk2MDg1NWNhMTQ4M2VhNTIwODYyYzFlYjgxODRkMjU", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-10-03T09:14:48Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-11-05T04:36:42Z"}, "message": "simplify applying closure requirements\n\nDon't use `ConstraintCategory::ClosureBounds`!\nSet the category and the span for the promoted constraints to that of\nthe original constraint earlier than before.\nThis eliminates the need for `closure_bounds_mapping`.", "tree": {"sha": "f67439585c9bae48217da5e43f95e5b4da5e95a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f67439585c9bae48217da5e43f95e5b4da5e95a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df668b9fb960855ca1483ea520862c1eb8184d25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df668b9fb960855ca1483ea520862c1eb8184d25", "html_url": "https://github.com/rust-lang/rust/commit/df668b9fb960855ca1483ea520862c1eb8184d25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df668b9fb960855ca1483ea520862c1eb8184d25/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ff7e7385be9846f28616081e836163a36681da", "url": "https://api.github.com/repos/rust-lang/rust/commits/81ff7e7385be9846f28616081e836163a36681da", "html_url": "https://github.com/rust-lang/rust/commit/81ff7e7385be9846f28616081e836163a36681da"}], "stats": {"total": 334, "additions": 97, "deletions": 237}, "files": [{"sha": "385f153174c3c2a9170b7b41957d67682efe0e17", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -163,6 +163,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n                 span: DUMMY_SP,\n                 category: ConstraintCategory::Internal,\n                 variance_info: VarianceDiagInfo::default(),\n+                from_closure: false,\n             })\n         } else {\n             None"}, {"sha": "9d9c4abb0aa57c460961d9dca8b8478dafbd9f0c", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -96,6 +96,9 @@ pub struct OutlivesConstraint<'tcx> {\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,\n+\n+    /// If this constraint is promoted from closure requirements.\n+    pub from_closure: bool,\n }\n \n impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {"}, {"sha": "4e0205f8d43a14616d40ebb23361979b907bbd8f", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -242,7 +242,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         mut liveness_constraints,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n     } = constraints;\n@@ -264,7 +263,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n         liveness_constraints,"}, {"sha": "cc9450999525a9550be1ebdc942ec12270cdc0cd", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -74,8 +74,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort_by_key(|c| (c.sup, c.sub));\n         for constraint in &constraints {\n-            let OutlivesConstraint { sup, sub, locations, category, span, variance_info: _ } =\n-                constraint;\n+            let OutlivesConstraint { sup, sub, locations, category, span, .. } = constraint;\n             let (name, arg) = match locations {\n                 Locations::All(span) => {\n                     (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))"}, {"sha": "6782fc0665f04f01d49b0e8e2e70278088eef297", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 137, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -6,10 +6,9 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n@@ -19,9 +18,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::{\n-    self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_span::Span;\n \n use crate::{\n@@ -89,10 +86,6 @@ pub struct RegionInferenceContext<'tcx> {\n     /// `member_region_scc`.\n     member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n-    /// Map closure bounds to a `Span` that should be used for error reporting.\n-    closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n-\n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -265,10 +258,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n         outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n-        closure_bounds_mapping: FxHashMap<\n-            Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>,\n-        >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n@@ -310,7 +299,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n-            closure_bounds_mapping,\n             universe_causes,\n             scc_universes,\n             scc_representatives,\n@@ -1804,18 +1792,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    pub(crate) fn retrieve_closure_constraint_info(\n-        &self,\n-        constraint: OutlivesConstraint<'tcx>,\n-    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n-        match constraint.locations {\n-            Locations::All(_) => None,\n-            Locations::Single(loc) => {\n-                self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub)).copied()\n-            }\n-        }\n-    }\n-\n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     pub(crate) fn find_outlives_blame_span(\n         &self,\n@@ -1921,6 +1897,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span: p_c.definition_span,\n                     category: ConstraintCategory::OpaqueType,\n                     variance_info: ty::VarianceDiagInfo::default(),\n+                    from_closure: false,\n                 };\n                 handle_constraint(constraint);\n             }\n@@ -2066,31 +2043,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n-            .map(|constraint| {\n-                let (category, span, from_closure, cause_code) =\n-                    if constraint.category == ConstraintCategory::ClosureBounds {\n-                        if let Some((category, span)) =\n-                            self.retrieve_closure_constraint_info(*constraint)\n-                        {\n-                            (category, span, true, ObligationCauseCode::MiscObligation)\n-                        } else {\n-                            (\n-                                constraint.category,\n-                                constraint.span,\n-                                false,\n-                                ObligationCauseCode::MiscObligation,\n-                            )\n-                        }\n-                    } else {\n-                        (constraint.category, constraint.span, false, cause_code.clone())\n-                    };\n-                BlameConstraint {\n-                    category,\n-                    from_closure,\n-                    cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n-                    variance_info: constraint.variance_info,\n-                    outlives_constraint: *constraint,\n-                }\n+            .map(|constraint| BlameConstraint {\n+                category: constraint.category,\n+                from_closure: constraint.from_closure,\n+                cause: ObligationCause::new(constraint.span, CRATE_HIR_ID, cause_code.clone()),\n+                variance_info: constraint.variance_info,\n+                outlives_constraint: *constraint,\n             })\n             .collect();\n         debug!(\"categorized_path={:#?}\", categorized_path);\n@@ -2274,92 +2232,6 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt<'tcx> {\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n-}\n-\n-impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx> {\n-    /// Given an instance T of the closure type, this method\n-    /// instantiates the \"extra\" requirements that we computed for the\n-    /// closure into the inference context. This has the effect of\n-    /// adding new outlives obligations to existing variables.\n-    ///\n-    /// As described on `ClosureRegionRequirements`, the extra\n-    /// requirements are expressed in terms of regionvids that index\n-    /// into the free regions that appear on the closure type. So, to\n-    /// do this, we first copy those regions out from the type T into\n-    /// a vector. Then we can just index into that vector to extract\n-    /// out the corresponding region from T and apply the\n-    /// requirements.\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>> {\n-        debug!(\n-            \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n-            closure_def_id, closure_substs\n-        );\n-\n-        // Extract the values of the free regions in `closure_substs`\n-        // into a vector.  These are the regions that we will be\n-        // relating to one another.\n-        let closure_mapping = &UniversalRegions::closure_mapping(\n-            tcx,\n-            closure_substs,\n-            self.num_external_vids,\n-            closure_def_id.expect_local(),\n-        );\n-        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n-\n-        // Create the predicates.\n-        self.outlives_requirements\n-            .iter()\n-            .map(|outlives_requirement| {\n-                let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-\n-                match outlives_requirement.subject {\n-                    ClosureOutlivesSubject::Region(region) => {\n-                        let region = closure_mapping[region];\n-                        debug!(\n-                            \"apply_requirements: region={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            region, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(\n-                                region.into(),\n-                                outlived_region,\n-                            )),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-\n-                    ClosureOutlivesSubject::Ty(ty) => {\n-                        debug!(\n-                            \"apply_requirements: ty={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            ty, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n     pub category: ConstraintCategory<'tcx>,"}, {"sha": "88be80c0b558d016e509736295a9b0bcc498f547", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -1,10 +1,10 @@\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, ConstraintCategory};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -38,6 +38,7 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     locations: Locations,\n     span: Span,\n     category: ConstraintCategory<'tcx>,\n+    from_closure: bool,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n@@ -64,6 +65,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             span,\n             category,\n             constraints,\n+            from_closure: false,\n         }\n     }\n \n@@ -81,30 +83,70 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n         self.constraints.member_constraints = tmp;\n \n-        for query_constraint in outlives {\n-            self.convert(query_constraint);\n+        for (predicate, constraint_category) in outlives {\n+            // At the moment, we never generate any \"higher-ranked\"\n+            // region constraints like `for<'a> 'a: 'b`. At some point\n+            // when we move to universes, we will, and this assertion\n+            // will start to fail.\n+            let predicate = predicate.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", predicate,);\n+            });\n+\n+            self.convert(predicate, *constraint_category);\n+        }\n+    }\n+\n+    /// Given an instance of the closure type, this method instantiates the \"extra\" requirements\n+    /// that we computed for the closure. This has the effect of adding new outlives obligations\n+    /// to existing region variables in `closure_substs`.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn apply_closure_requirements(\n+        &mut self,\n+        closure_requirements: &ClosureRegionRequirements<'tcx>,\n+        closure_def_id: DefId,\n+        closure_substs: ty::SubstsRef<'tcx>,\n+    ) {\n+        // Extract the values of the free regions in `closure_substs`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping = &UniversalRegions::closure_mapping(\n+            self.tcx,\n+            closure_substs,\n+            closure_requirements.num_external_vids,\n+            closure_def_id.expect_local(),\n+        );\n+        debug!(?closure_mapping);\n+\n+        // Create the predicates.\n+        let backup = (self.category, self.span, self.from_closure);\n+        self.from_closure = true;\n+        for outlives_requirement in &closure_requirements.outlives_requirements {\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            let subject = match outlives_requirement.subject {\n+                ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n+                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+            };\n+\n+            self.category = outlives_requirement.category;\n+            self.span = outlives_requirement.blame_span;\n+            self.convert(ty::OutlivesPredicate(subject, outlived_region), self.category);\n         }\n+        (self.category, self.span, self.from_closure) = backup;\n     }\n \n-    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    fn convert(\n+        &mut self,\n+        predicate: ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>,\n+        constraint_category: ConstraintCategory<'tcx>,\n+    ) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n         let ConstraintConversion {\n             tcx, region_bound_pairs, implicit_region_bound, param_env, ..\n         } = *self;\n \n-        // At the moment, we never generate any \"higher-ranked\"\n-        // region constraints like `for<'a> 'a: 'b`. At some point\n-        // when we move to universes, we will, and this assertion\n-        // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-            });\n-\n-        let constraint_category = query_constraint.1;\n-\n+        let ty::OutlivesPredicate(k1, r2) = predicate;\n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n@@ -188,6 +230,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             sub,\n             sup,\n             variance_info: ty::VarianceDiagInfo::default(),\n+            from_closure: self.from_closure,\n         });\n     }\n "}, {"sha": "3d9e08b4ca7ba467af7f50a0d9e60c4887b51c6d", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 18, "deletions": 78, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef, UserSubsts};\n+use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, Binder, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, Dynamic,\n@@ -61,7 +61,7 @@ use crate::{\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n-    region_infer::{ClosureRegionRequirementsExt, TypeTest},\n+    region_infer::TypeTest,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n     Upvar,\n@@ -144,7 +144,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: OutlivesConstraintSet::default(),\n         member_constraints: MemberConstraintSet::default(),\n-        closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n         universe_causes: FxHashMap::default(),\n     };\n@@ -585,7 +584,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut type_tests = Default::default();\n-        let mut closure_bounds = Default::default();\n         let mut liveness_constraints =\n             LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n         // Don't try to add borrow_region facts for the promoted MIR\n@@ -597,10 +595,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 &mut constraints,\n             );\n             mem::swap(&mut this.cx.borrowck_context.constraints.type_tests, &mut type_tests);\n-            mem::swap(\n-                &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n-                &mut closure_bounds,\n-            );\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.liveness_constraints,\n                 &mut liveness_constraints,\n@@ -653,18 +647,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     .add_element(region, location);\n             }\n         }\n-\n-        if !closure_bounds.is_empty() {\n-            let combined_bounds_mapping =\n-                closure_bounds.into_iter().flat_map(|(_, value)| value).collect();\n-            let existing = self\n-                .cx\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, combined_bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple promoteds/closures at the same location.\");\n-        }\n     }\n \n     fn sanitize_projection(\n@@ -941,9 +923,6 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n-\n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n@@ -2562,6 +2541,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 span: location.to_locations().span(body),\n                                 category,\n                                 variance_info: ty::VarianceDiagInfo::default(),\n+                                from_closure: false,\n                             });\n \n                             match mutbl {\n@@ -2679,62 +2659,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements\n-        {\n-            let closure_constraints = QueryRegionConstraints {\n-                outlives: closure_region_requirements.apply_requirements(\n-                    tcx,\n-                    def_id.to_def_id(),\n-                    substs,\n-                ),\n-\n-                // Presently, closures never propagate member\n-                // constraints to their parents -- they are enforced\n-                // locally.  This is largely a non-issue as member\n-                // constraints only come from `-> impl Trait` and\n-                // friends which don't appear (thus far...) in\n-                // closures.\n-                member_constraints: vec![],\n-            };\n-\n-            let bounds_mapping = closure_constraints\n-                .outlives\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(idx, constraint)| {\n-                    let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                            bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n-                        });\n-\n-                    match k1.unpack() {\n-                        GenericArgKind::Lifetime(r1) => {\n-                            // constraint is r1: r2\n-                            let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n-                            let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n-                            let outlives_requirements =\n-                                &closure_region_requirements.outlives_requirements[idx];\n-                            Some((\n-                                (r1_vid, r2_vid),\n-                                (outlives_requirements.category, outlives_requirements.blame_span),\n-                            ))\n-                        }\n-                        GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n-                    }\n-                })\n-                .collect();\n-\n-            let existing = self\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple closures at the same location.\");\n-\n-            self.push_region_constraints(\n+        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.infcx,\n+                self.borrowck_context.universal_regions,\n+                self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n                 location.to_locations(),\n-                ConstraintCategory::ClosureBounds,\n-                &closure_constraints,\n+                DUMMY_SP,                   // irrelevant; will be overrided.\n+                ConstraintCategory::Boring, // same as above.\n+                &mut self.borrowck_context.constraints,\n+            )\n+            .apply_closure_requirements(\n+                &closure_requirements,\n+                def_id.to_def_id(),\n+                substs,\n             );\n         }\n "}, {"sha": "94d51032866098954d19b99b974014e9b6189625", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -136,6 +136,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 span: self.locations.span(self.type_checker.body),\n                 category: self.category,\n                 variance_info: info,\n+                from_closure: false,\n             },\n         );\n     }"}, {"sha": "1260a656c98f2147cbe6547015db58b648e29beb", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df668b9fb960855ca1483ea520862c1eb8184d25/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df668b9fb960855ca1483ea520862c1eb8184d25/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=df668b9fb960855ca1483ea520862c1eb8184d25", "patch": "@@ -167,17 +167,20 @@ LL | |     T: Anything<'b, 'b>,\n    = note: defining type: two_regions::<'_#1r, T>\n \n error: lifetime may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:87:29\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:87:5\n    |\n LL | fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of the type `Cell<&'_#8r ()>`, which makes the generic argument `&'_#8r ()` invariant\n+   = note: the struct `Cell<T>` is invariant over the parameter `T`\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n note: external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:97:29"}]}