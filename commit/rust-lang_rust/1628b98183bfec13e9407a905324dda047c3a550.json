{"sha": "1628b98183bfec13e9407a905324dda047c3a550", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MjhiOTgxODNiZmVjMTNlOTQwN2E5MDUzMjRkZGEwNDdjM2E1NTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T21:56:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T21:56:58Z"}, "message": "auto merge of #18870 : barosl/rust/os-ioresult, r=alexcrichton\n\nMake old-fashioned functions in the `std::os` module utilize `IoResult`.\r\n\r\nI'm still investigating the possibility to include more functions in this pull request. Currently, it covers `getcwd()`, `make_absolute()`, and `change_dir()`. The issues covered by this PR are #16946 and #16315.\r\n\r\nA few concerns:\r\n\r\n- Should we provide `OsError` in distinction from `IoError`? I'm saying this because in Python, those two are distinguished. One advantage that we keep using `IoError` is that we can make the error cascade down other functions whose return type also includes `IoError`. An example of such functions is `std::io::TempDir::new_in()`, which uses `os::make_absolute()` as well as returns `IoResult<TempDir>`.\r\n- `os::getcwd()` uses an internal buffer whose size is 2048 bytes, which is passed to `getcwd(3)`. There is no upper limitation of file paths in the POSIX standard, but typically it is set to 4096 bytes such as in Linux. Should we increase the buffer size? One thing that makes me nervous is that the size of 2048 bytes already seems a bit excessive, thinking that in normal cases, there would be no filenames that even exceeds 512 bytes.\r\n\r\nFixes #16946.\r\nFixes #16315.\r\n\r\nAny ideas are welcomed. Thanks!", "tree": {"sha": "5ee54e294253ede9ded10057e7d85f49142f259f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ee54e294253ede9ded10057e7d85f49142f259f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1628b98183bfec13e9407a905324dda047c3a550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1628b98183bfec13e9407a905324dda047c3a550", "html_url": "https://github.com/rust-lang/rust/commit/1628b98183bfec13e9407a905324dda047c3a550", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1628b98183bfec13e9407a905324dda047c3a550/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8d6e3b2c2a780eff92299da5d1c02e081617088", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8d6e3b2c2a780eff92299da5d1c02e081617088", "html_url": "https://github.com/rust-lang/rust/commit/c8d6e3b2c2a780eff92299da5d1c02e081617088"}, {"sha": "b5286af703e33bd36744fe4cd5bb24f71dbb524e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5286af703e33bd36744fe4cd5bb24f71dbb524e", "html_url": "https://github.com/rust-lang/rust/commit/b5286af703e33bd36744fe4cd5bb24f71dbb524e"}], "stats": {"total": 149, "additions": 86, "deletions": 63}, "files": [{"sha": "fee289df3e4e4c745aff749de45f7d5578af9031", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -219,7 +219,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         None => Vec::new()\n     };\n-    let mut cwd = os::getcwd();\n+    let mut cwd = os::getcwd().unwrap();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {"}, {"sha": "5c2fe0854ee77fa07444adb0043f60faf73ca611", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -134,7 +134,7 @@ impl<'a> PluginLoader<'a> {\n     // Dynamically link a registrar function into the compiler process.\n     fn dylink_registrar(&mut self, vi: &ast::ViewItem, path: Path, symbol: String) {\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = os::make_absolute(&path);\n+        let path = os::make_absolute(&path).unwrap();\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "72a9f23aa1f945f0474861000291889d694d136e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -231,7 +231,7 @@ pub fn build_session_(sopts: config::Options,\n         if path.is_absolute() {\n             path.clone()\n         } else {\n-            os::getcwd().join(&path)\n+            os::getcwd().unwrap().join(&path)\n         }\n     );\n \n@@ -246,7 +246,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: os::getcwd(),\n+        working_dir: os::getcwd().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap::new()),\n         crate_types: RefCell::new(Vec::new()),"}, {"sha": "a88bcafaa64b389aba7a7a9c8a8093994f21e47f", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -229,7 +229,7 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = os::getcwd().join(&self.archive.dst);\n+        let abs_dst = os::getcwd().unwrap().join(&self.archive.dst);\n         assert!(!abs_dst.is_relative());\n         let mut args = vec![&abs_dst];\n         let mut total_len = abs_dst.as_vec().len();\n@@ -286,7 +286,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // First, extract the contents of the archive to a temporary directory.\n         // We don't unpack directly into `self.work_dir` due to the possibility\n         // of filename collisions.\n-        let archive = os::make_absolute(archive);\n+        let archive = os::make_absolute(archive).unwrap();\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n                \"x\", Some(loc.path()), &[&archive]);\n "}, {"sha": "d9bf8044039553b2d72c33f54b98f3379ebca7ff", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -16,7 +16,7 @@ use std::os;\n /// returned path does not contain any symlinks in its hierarchy.\n pub fn realpath(original: &Path) -> io::IoResult<Path> {\n     static MAX_LINKS_FOLLOWED: uint = 256;\n-    let original = os::make_absolute(original);\n+    let original = os::make_absolute(original).unwrap();\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "26cc859434f2c3a11bf8a5b90bd02616fc60f4e5", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -102,9 +102,9 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig,\n         \"$ORIGIN\"\n     };\n \n-    let mut lib = (config.realpath)(&os::make_absolute(lib)).unwrap();\n+    let mut lib = (config.realpath)(&os::make_absolute(lib).unwrap()).unwrap();\n     lib.pop();\n-    let mut output = (config.realpath)(&os::make_absolute(&config.out_filename)).unwrap();\n+    let mut output = (config.realpath)(&os::make_absolute(&config.out_filename).unwrap()).unwrap();\n     output.pop();\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n@@ -116,7 +116,7 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig,\n \n fn get_install_prefix_rpath(config: RPathConfig) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n-    let path = os::make_absolute(&path);\n+    let path = os::make_absolute(&path).unwrap();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n }"}, {"sha": "592ec0681a96a01facc8cfc75a714766c7258359", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -974,7 +974,7 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let parent_dir = os::getcwd();\n+        let parent_dir = os::getcwd().unwrap();\n         let child_dir = Path::new(output.as_slice().trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -989,7 +989,7 @@ mod tests {\n         use os;\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().dir_path();\n+        let parent_dir = os::getcwd().unwrap().dir_path();\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();"}, {"sha": "a232231733d8bacd58efddb620f8b89a78c3c647", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -35,7 +35,8 @@ impl TempDir {\n     /// If no directory can be created, `Err` is returned.\n     pub fn new_in(tmpdir: &Path, suffix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            return TempDir::new_in(&os::make_absolute(tmpdir), suffix);\n+            let abs_tmpdir = try!(os::make_absolute(tmpdir));\n+            return TempDir::new_in(&abs_tmpdir, suffix);\n         }\n \n         static CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;"}, {"sha": "a153ead2a3843b77f8b94bc9b0ed4038a845d753", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -75,7 +75,7 @@ fn base_port() -> u16 {\n     ];\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = os::getcwd();\n+    let path = os::getcwd().unwrap();\n     let path_s = path.as_str().unwrap();\n \n     let mut final_base = base;"}, {"sha": "b898b9a2df43ecf6fa536494960d8895b86c3e7e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -38,7 +38,7 @@ pub use self::MapError::*;\n use clone::Clone;\n use error::{FromError, Error};\n use fmt;\n-use io::IoResult;\n+use io::{IoResult, IoError};\n use iter::Iterator;\n use libc::{c_void, c_int};\n use libc;\n@@ -76,72 +76,83 @@ pub fn num_cpus() -> uint {\n pub const TMPBUF_SZ : uint = 1000u;\n const BUF_BYTES : uint = 2048u;\n \n-/// Returns the current working directory as a Path.\n+/// Returns the current working directory as a `Path`.\n ///\n-/// # Failure\n+/// # Errors\n ///\n-/// Fails if the current working directory value is invalid:\n+/// Returns an `Err` if the current working directory value is invalid.\n /// Possible cases:\n ///\n /// * Current directory does not exist.\n /// * There are insufficient permissions to access the current directory.\n+/// * The internal buffer is not large enough to hold the path.\n ///\n /// # Example\n ///\n /// ```rust\n /// use std::os;\n ///\n /// // We assume that we are in a valid directory like \"/home\".\n-/// let current_working_directory = os::getcwd();\n+/// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {}\", current_working_directory.display());\n /// // /home\n /// ```\n #[cfg(unix)]\n-pub fn getcwd() -> Path {\n+pub fn getcwd() -> IoResult<Path> {\n     use c_str::CString;\n \n     let mut buf = [0 as c_char, ..BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n-            panic!()\n+            Err(IoError::last_error())\n+        } else {\n+            Ok(Path::new(CString::new(buf.as_ptr(), false)))\n         }\n-        Path::new(CString::new(buf.as_ptr(), false))\n     }\n }\n \n-/// Returns the current working directory as a Path.\n+/// Returns the current working directory as a `Path`.\n ///\n-/// # Failure\n+/// # Errors\n ///\n-/// Fails if the current working directory value is invalid.\n-/// Possibles cases:\n+/// Returns an `Err` if the current working directory value is invalid.\n+/// Possible cases:\n ///\n /// * Current directory does not exist.\n /// * There are insufficient permissions to access the current directory.\n+/// * The internal buffer is not large enough to hold the path.\n ///\n /// # Example\n ///\n /// ```rust\n /// use std::os;\n ///\n /// // We assume that we are in a valid directory like \"C:\\\\Windows\".\n-/// let current_working_directory = os::getcwd();\n+/// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {}\", current_working_directory.display());\n /// // C:\\\\Windows\n /// ```\n #[cfg(windows)]\n-pub fn getcwd() -> Path {\n+pub fn getcwd() -> IoResult<Path> {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n+    use io::OtherIoError;\n \n     let mut buf = [0 as u16, ..BUF_BYTES];\n     unsafe {\n         if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n-            panic!();\n+            return Err(IoError::last_error());\n         }\n     }\n-    Path::new(String::from_utf16(::str::truncate_utf16_at_nul(&buf))\n-              .expect(\"GetCurrentDirectoryW returned invalid UTF-16\"))\n+\n+    match String::from_utf16(::str::truncate_utf16_at_nul(&buf)) {\n+        Some(ref cwd) => Ok(Path::new(cwd)),\n+        None => Err(IoError {\n+            kind: OtherIoError,\n+            desc: \"GetCurrentDirectoryW returned invalid UTF-16\",\n+            detail: None,\n+        }),\n+    }\n }\n \n #[cfg(windows)]\n@@ -411,7 +422,9 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n             with_env_lock(|| {\n                 n.with_c_str(|nbuf| {\n                     v.with_c_str(|vbuf| {\n-                        libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n+                        if libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1) != 0 {\n+                            panic!(IoError::last_error());\n+                        }\n                     })\n                 })\n             })\n@@ -427,7 +440,9 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n \n         unsafe {\n             with_env_lock(|| {\n-                libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr());\n+                if libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr()) == 0 {\n+                    panic!(IoError::last_error());\n+                }\n             })\n         }\n     }\n@@ -442,7 +457,9 @@ pub fn unsetenv(n: &str) {\n         unsafe {\n             with_env_lock(|| {\n                 n.with_c_str(|nbuf| {\n-                    libc::funcs::posix01::unistd::unsetenv(nbuf);\n+                    if libc::funcs::posix01::unistd::unsetenv(nbuf) != 0 {\n+                        panic!(IoError::last_error());\n+                    }\n                 })\n             })\n         }\n@@ -454,11 +471,14 @@ pub fn unsetenv(n: &str) {\n         n.push(0);\n         unsafe {\n             with_env_lock(|| {\n-                libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null());\n+                if libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null()) == 0 {\n+                    panic!(IoError::last_error());\n+                }\n             })\n         }\n     }\n-    _unsetenv(n);\n+\n+    _unsetenv(n)\n }\n \n /// Parses input according to platform conventions for the `PATH`\n@@ -829,20 +849,21 @@ pub fn tmpdir() -> Path {\n ///\n /// // Assume we're in a path like /home/someuser\n /// let rel_path = Path::new(\"..\");\n-/// let abs_path = os::make_absolute(&rel_path);\n+/// let abs_path = os::make_absolute(&rel_path).unwrap();\n /// println!(\"The absolute path is {}\", abs_path.display());\n /// // Prints \"The absolute path is /home\"\n /// ```\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n-pub fn make_absolute(p: &Path) -> Path {\n+pub fn make_absolute(p: &Path) -> IoResult<Path> {\n     if p.is_absolute() {\n-        p.clone()\n+        Ok(p.clone())\n     } else {\n-        let mut ret = getcwd();\n-        ret.push(p);\n-        ret\n+        getcwd().map(|mut cwd| {\n+            cwd.push(p);\n+            cwd\n+        })\n     }\n }\n \n@@ -855,32 +876,33 @@ pub fn make_absolute(p: &Path) -> Path {\n /// use std::path::Path;\n ///\n /// let root = Path::new(\"/\");\n-/// assert!(os::change_dir(&root));\n+/// assert!(os::change_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n-pub fn change_dir(p: &Path) -> bool {\n+pub fn change_dir(p: &Path) -> IoResult<()> {\n     return chdir(p);\n \n     #[cfg(windows)]\n-    fn chdir(p: &Path) -> bool {\n-        let p = match p.as_str() {\n-            Some(s) => {\n-                let mut p = s.utf16_units().collect::<Vec<u16>>();\n-                p.push(0);\n-                p\n-            }\n-            None => return false,\n-        };\n+    fn chdir(p: &Path) -> IoResult<()> {\n+        let mut p = p.as_str().unwrap().utf16_units().collect::<Vec<u16>>();\n+        p.push(0);\n+\n         unsafe {\n-            libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL)\n+            match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n+                true => Ok(()),\n+                false => Err(IoError::last_error()),\n+            }\n         }\n     }\n \n     #[cfg(unix)]\n-    fn chdir(p: &Path) -> bool {\n+    fn chdir(p: &Path) -> IoResult<()> {\n         p.with_c_str(|buf| {\n             unsafe {\n-                libc::chdir(buf) == (0 as c_int)\n+                match libc::chdir(buf) == (0 as c_int) {\n+                    true => Ok(()),\n+                    false => Err(IoError::last_error()),\n+                }\n             }\n         })\n     }\n@@ -1881,11 +1903,11 @@ mod tests {\n     fn test() {\n         assert!((!Path::new(\"test-path\").is_absolute()));\n \n-        let cwd = getcwd();\n+        let cwd = getcwd().unwrap();\n         debug!(\"Current working directory: {}\", cwd.display());\n \n-        debug!(\"{}\", make_absolute(&Path::new(\"test-path\")).display());\n-        debug!(\"{}\", make_absolute(&Path::new(\"/usr/bin\")).display());\n+        debug!(\"{}\", make_absolute(&Path::new(\"test-path\")).unwrap().display());\n+        debug!(\"{}\", make_absolute(&Path::new(\"/usr/bin\")).unwrap().display());\n     }\n \n     #[test]"}, {"sha": "1c24210d6cd98f789fc60cc7d7842350097aacf4", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -26,7 +26,7 @@ use std::path::Path;\n \n fn main() {\n     let my_args = os::args();\n-    let my_cwd  = os::getcwd();\n+    let my_cwd  = os::getcwd().unwrap();\n     let my_env  = os::env();\n     let my_path = Path::new(os::self_exe_name().unwrap());\n     let my_dir  = my_path.dir_path();"}, {"sha": "7400c52a73b4abf4d7d61bf074a63f398b3aa2b0", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1628b98183bfec13e9407a905324dda047c3a550/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1628b98183bfec13e9407a905324dda047c3a550/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=1628b98183bfec13e9407a905324dda047c3a550", "patch": "@@ -123,7 +123,7 @@ fn test_rm_tempdir_close() {\n // to depend on std\n fn recursive_mkdir_rel() {\n     let path = Path::new(\"frob\");\n-    let cwd = os::getcwd();\n+    let cwd = os::getcwd().unwrap();\n     println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, io::USER_RWX);\n@@ -141,7 +141,7 @@ fn recursive_mkdir_dot() {\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n-    let cwd = os::getcwd();\n+    let cwd = os::getcwd().unwrap();\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, io::USER_RWX);\n@@ -190,7 +190,7 @@ pub fn dont_double_panic() {\n \n fn in_tmpdir(f: ||) {\n     let tmpdir = TempDir::new(\"test\").ok().expect(\"can't make tmpdir\");\n-    assert!(os::change_dir(tmpdir.path()));\n+    assert!(os::change_dir(tmpdir.path()).is_ok());\n \n     f();\n }"}]}