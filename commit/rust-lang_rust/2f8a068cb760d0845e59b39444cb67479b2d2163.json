{"sha": "2f8a068cb760d0845e59b39444cb67479b2d2163", "node_id": "C_kwDOAAsO6NoAKDJmOGEwNjhjYjc2MGQwODQ1ZTU5YjM5NDQ0Y2I2NzQ3OWIyZDIxNjM", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-10-27T19:48:28Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-02T20:05:09Z"}, "message": "Add `Tracker` to track matching operations\n\nThis should allow us to collect detailed information without slowing\ndown the inital hot path.", "tree": {"sha": "634035eadd250e121442f275503316cd9f7baa49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/634035eadd250e121442f275503316cd9f7baa49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f8a068cb760d0845e59b39444cb67479b2d2163", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQMsIVe+KG5/MVSEt1ZoZkjrrma7QHn7Hfbd2qTJsjO3xbTuH7ThQ+BBf/JTULs4ulO\nETBeYqWKsk5c+rE9+hlwY=\n-----END SSH SIGNATURE-----", "payload": "tree 634035eadd250e121442f275503316cd9f7baa49\nparent 6c47848c2553ea2703ef12e1e767cf583ff390c6\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1666900108 +0200\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667419509 +0100\n\nAdd `Tracker` to track matching operations\n\nThis should allow us to collect detailed information without slowing\ndown the inital hot path.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8a068cb760d0845e59b39444cb67479b2d2163", "html_url": "https://github.com/rust-lang/rust/commit/2f8a068cb760d0845e59b39444cb67479b2d2163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f8a068cb760d0845e59b39444cb67479b2d2163/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c47848c2553ea2703ef12e1e767cf583ff390c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c47848c2553ea2703ef12e1e767cf583ff390c6", "html_url": "https://github.com/rust-lang/rust/commit/6c47848c2553ea2703ef12e1e767cf583ff390c6"}], "stats": {"total": 65, "additions": 48, "deletions": 17}, "files": [{"sha": "63bafd7b046fb173275548d333b098ddfd4ab06a", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f8a068cb760d0845e59b39444cb67479b2d2163/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8a068cb760d0845e59b39444cb67479b2d2163/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=2f8a068cb760d0845e59b39444cb67479b2d2163", "patch": "@@ -52,7 +52,7 @@ impl KleeneToken {\n /// A Kleene-style [repetition operator](https://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-enum KleeneOp {\n+pub(crate) enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions"}, {"sha": "0402c51247af0f07bee959571b901d51afb0e0e8", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f8a068cb760d0845e59b39444cb67479b2d2163/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8a068cb760d0845e59b39444cb67479b2d2163/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=2f8a068cb760d0845e59b39444cb67479b2d2163", "patch": "@@ -70,21 +70,20 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n+use rustc_errors::ErrorGuaranteed;\n pub(crate) use NamedMatch::*;\n pub(crate) use ParseResult::*;\n-use rustc_errors::ErrorGuaranteed;\n \n-use crate::mbe::{KleeneOp, TokenTree};\n+use crate::mbe::{macro_rules::Tracker, KleeneOp, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n use rustc_lint_defs::pluralize;\n use rustc_parse::parser::{NtOrTt, Parser};\n+use rustc_span::symbol::Ident;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n@@ -97,7 +96,8 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n ///\n /// This means a matcher can be represented by `&[MatcherLoc]`, and traversal mostly involves\n /// simply incrementing the current matcher position index by one.\n-pub(super) enum MatcherLoc {\n+#[derive(Debug, Clone, PartialEq)]\n+pub(crate) enum MatcherLoc {\n     Token {\n         token: Token,\n     },\n@@ -401,17 +401,21 @@ impl TtParser {\n     ///\n     /// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept\n     /// track of through the mps generated.\n-    fn parse_tt_inner(\n+    fn parse_tt_inner<'matcher, T: Tracker<'matcher>>(\n         &mut self,\n-        matcher: &[MatcherLoc],\n+        matcher: &'matcher [MatcherLoc],\n         token: &Token,\n+        track: &mut T,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            match &matcher[mp.idx] {\n+            let matcher_loc = &matcher[mp.idx];\n+            track.before_match_loc(self, matcher_loc);\n+\n+            match matcher_loc {\n                 MatcherLoc::Token { token: t } => {\n                     // If it's a doc comment, we just ignore it and move on to the next tt in the\n                     // matcher. This is a bug, but #95267 showed that existing programs rely on\n@@ -553,10 +557,11 @@ impl TtParser {\n     }\n \n     /// Match the token stream from `parser` against `matcher`.\n-    pub(super) fn parse_tt(\n+    pub(super) fn parse_tt<'matcher, T: Tracker<'matcher>>(\n         &mut self,\n         parser: &mut Cow<'_, Parser<'_>>,\n-        matcher: &[MatcherLoc],\n+        matcher: &'matcher [MatcherLoc],\n+        track: &mut T,\n     ) -> NamedParseResult {\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n@@ -572,7 +577,8 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(res) = self.parse_tt_inner(matcher, &parser.token) {\n+            let res = self.parse_tt_inner(matcher, &parser.token, track);\n+            if let Some(res) = res {\n                 return res;\n             }\n "}, {"sha": "9c676a41f3a88e202f7edc014c1677a92d750621", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f8a068cb760d0845e59b39444cb67479b2d2163/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8a068cb760d0845e59b39444cb67479b2d2163/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=2f8a068cb760d0845e59b39444cb67479b2d2163", "patch": "@@ -33,6 +33,8 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n+use super::macro_parser::NamedParseResult;\n+\n pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -205,6 +207,29 @@ fn trace_macros_note(cx_expansions: &mut FxIndexMap<Span, Vec<String>>, sp: Span\n     cx_expansions.entry(sp).or_default().push(message);\n }\n \n+pub(super) trait Tracker<'matcher> {\n+    /// This is called before trying to match next MatcherLoc on the current token\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc);\n+\n+    /// This is called after an arm has been parsed, either successfully or unsuccessfully. When this is called,\n+    /// `before_match_loc` was called at least once (with a `MatcherLoc::Eof`)\n+    fn after_arm(&mut self, result: &NamedParseResult);\n+\n+    /// For tracing\n+    fn description() -> &'static str;\n+}\n+\n+/// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization\n+struct NoopTracker;\n+\n+impl<'matcher> Tracker<'matcher> for NoopTracker {\n+    fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n+    fn after_arm(&mut self, _: &NamedParseResult) {}\n+    fn description() -> &'static str {\n+        \"none\"\n+    }\n+}\n+\n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n /// input `arg`.\n fn expand_macro<'cx>(\n@@ -262,7 +287,7 @@ fn expand_macro<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n+        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -354,7 +379,7 @@ fn expand_macro<'cx>(\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {\n             let parser = parser_from_cx(sess, arg.clone());\n-            if let Success(_) = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n+            if let Success(_) = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker) {\n                 if comma_span.is_dummy() {\n                     err.note(\"you might be missing a comma\");\n                 } else {\n@@ -452,7 +477,7 @@ pub fn compile_declarative_macro(\n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n-    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n+    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, &mut NoopTracker) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);"}]}