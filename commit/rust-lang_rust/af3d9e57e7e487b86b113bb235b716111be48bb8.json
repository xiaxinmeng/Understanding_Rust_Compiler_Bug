{"sha": "af3d9e57e7e487b86b113bb235b716111be48bb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmM2Q5ZTU3ZTdlNDg3Yjg2YjExM2JiMjM1YjcxNjExMWJlNDhiYjg=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-15T23:07:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-15T23:07:41Z"}, "message": "Rollup merge of #64623 - matthewjasper:underscore-imports, r=petrochenkov\n\nRemove last uses of gensyms\n\nUnderscore bindings now use unique `SyntaxContext`s to avoid collisions. This was the last use of gensyms in the compiler, so this PR also removes them.\n\ncloses #49300\ncc #60869\n\nr? @petrochenkov", "tree": {"sha": "f3ed9b710d09056b6eb983060d71011050d0833c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3ed9b710d09056b6eb983060d71011050d0833c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3d9e57e7e487b86b113bb235b716111be48bb8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdplE9CRBK7hj4Ov3rIwAAdHIIAGrxmutwHnKXjEW1Ctyyq1a7\naDRIsvFnzwHmztsmrWHikhdGaIauHeI2jJadNVqFilWILXOqrjd6Tacb8pHFvwZh\nfXwNUtNNYCUDRp4+3CZsKfOPUEf6XYMTih87GQn4WoTdTKqh3NTJWkssgse9/7oD\nE8w8Dkiae+/+MyFCUq3QpUx2t62zp5fL1GTZME2xSjsnirGSezxuJPhXqCQs/OoD\nBn0/QTdrYl7MaBm2d1ltBeESvp3E2oWlf19X2y4KlYaogZd1ZpqeVwaC8i56nPjZ\nDufE5ZziG7Nuktur0nJtuv3RrklGgZj+lafJZQFSU40JM9UGLKy01vcqwWBp95U=\n=fPGg\n-----END PGP SIGNATURE-----\n", "payload": "tree f3ed9b710d09056b6eb983060d71011050d0833c\nparent fcef4b1aef27d37b8fb5e308766636de1a6e99b2\nparent 4198df1f4be969747bc92254185ae4983e8f3c5c\nauthor Tyler Mandry <tmandry@gmail.com> 1571180861 -0700\ncommitter GitHub <noreply@github.com> 1571180861 -0700\n\nRollup merge of #64623 - matthewjasper:underscore-imports, r=petrochenkov\n\nRemove last uses of gensyms\n\nUnderscore bindings now use unique `SyntaxContext`s to avoid collisions. This was the last use of gensyms in the compiler, so this PR also removes them.\n\ncloses #49300\ncc #60869\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3d9e57e7e487b86b113bb235b716111be48bb8", "html_url": "https://github.com/rust-lang/rust/commit/af3d9e57e7e487b86b113bb235b716111be48bb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3d9e57e7e487b86b113bb235b716111be48bb8/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcef4b1aef27d37b8fb5e308766636de1a6e99b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcef4b1aef27d37b8fb5e308766636de1a6e99b2", "html_url": "https://github.com/rust-lang/rust/commit/fcef4b1aef27d37b8fb5e308766636de1a6e99b2"}, {"sha": "4198df1f4be969747bc92254185ae4983e8f3c5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4198df1f4be969747bc92254185ae4983e8f3c5c", "html_url": "https://github.com/rust-lang/rust/commit/4198df1f4be969747bc92254185ae4983e8f3c5c"}], "stats": {"total": 401, "additions": 247, "deletions": 154}, "files": [{"sha": "363109a0582df603c46fcea2c271505dabd1cfe6", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -1483,7 +1483,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         }\n \n         // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n+        // variants, using new unique identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give."}, {"sha": "0d5361fe8d84b599283ccec09dee95acf0bb6db3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -94,7 +94,8 @@ impl<'a> Resolver<'a> {\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n-        if let Err(old_binding) = self.try_define(parent, ident, ns, binding) {\n+        let key = self.new_key(ident, ns);\n+        if let Err(old_binding) = self.try_define(parent, key, binding) {\n             self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n@@ -349,9 +350,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         self.r.indeterminate_imports.push(directive);\n         match directive.subclass {\n+            // Don't add unresolved underscore imports to modules\n+            SingleImport { target: Ident { name: kw::Underscore, .. }, .. } => {}\n             SingleImport { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n+                    let key = this.new_key(target, ns);\n+                    let mut resolution = this.resolution(current_module, key).borrow_mut();\n                     resolution.add_single_import(directive);\n                 });\n             }\n@@ -407,7 +411,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n-                let mut ident = use_tree.ident().gensym_if_underscore();\n+                let mut ident = use_tree.ident();\n                 let mut module_path = prefix;\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n@@ -585,7 +589,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n-        let ident = item.ident.gensym_if_underscore();\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -851,10 +855,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n-        // FIXME: We shouldn't create the gensym here, it should come from metadata,\n-        // but metadata cannot encode gensyms currently, so we create it here.\n-        // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n-        let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n         // Record primary definitions.\n         match res {"}, {"sha": "de8758086709f16111abc78acae82dd618502330", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -80,11 +80,11 @@ impl<'a> Resolver<'a> {\n         names: &mut Vec<TypoSuggestion>,\n         filter_fn: &impl Fn(Res) -> bool,\n     ) {\n-        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+        for (key, resolution) in self.resolutions(module).borrow().iter() {\n             if let Some(binding) = resolution.borrow().binding {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                    names.push(TypoSuggestion::from_res(key.ident.name, res));\n                 }\n             }\n         }\n@@ -849,7 +849,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         let resolutions = self.r.resolutions(crate_module).borrow();\n-        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let resolution = resolutions.get(&self.r.new_key(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();"}, {"sha": "e5b0ef89a417f042ac06a7e1ded6438ece4c3f91", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -432,7 +432,22 @@ impl ModuleKind {\n     }\n }\n \n-type Resolutions<'a> = RefCell<FxIndexMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+/// A key that identifies a binding in a given `Module`.\n+///\n+/// Multiple bindings in the same module can have the same key (in a valid\n+/// program) if all but one of them come from glob imports.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct BindingKey {\n+    /// The identifier for the binding, aways the `modern` version of the\n+    /// identifier.\n+    ident: Ident,\n+    ns: Namespace,\n+    /// 0 if ident is not `_`, otherwise a value that's unique to the specific\n+    /// `_` in the expanded AST that introduced this binding.\n+    disambiguator: u32,\n+}\n+\n+type Resolutions<'a> = RefCell<FxIndexMap<BindingKey, &'a RefCell<NameResolution<'a>>>>;\n \n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n@@ -492,8 +507,8 @@ impl<'a> ModuleData<'a> {\n     fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n         where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n     {\n-        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n+        for (key, name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, key.ident, key.ns, binding));\n         }\n     }\n \n@@ -882,6 +897,7 @@ pub struct Resolver<'a> {\n     module_map: FxHashMap<DefId, Module<'a>>,\n     extern_module_map: FxHashMap<DefId, Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n+    underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n     pub glob_map: GlobMap,\n@@ -1160,6 +1176,7 @@ impl<'a> Resolver<'a> {\n             extern_crate_map: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n+            underscore_disambiguator: 0,\n             empty_module,\n             module_map,\n             block_map: Default::default(),\n@@ -1284,6 +1301,17 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n+        let ident = ident.modern();\n+        let disambiguator = if ident.name == kw::Underscore {\n+            self.underscore_disambiguator += 1;\n+            self.underscore_disambiguator\n+        } else {\n+            0\n+        };\n+        BindingKey { ident, ns, disambiguator }\n+    }\n+\n     fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n         if module.populate_on_access.get() {\n             module.populate_on_access.set(false);\n@@ -1292,9 +1320,9 @@ impl<'a> Resolver<'a> {\n         &module.lazy_resolutions\n     }\n \n-    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+    fn resolution(&mut self, module: Module<'a>, key: BindingKey)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+        *self.resolutions(module).borrow_mut().entry(key)\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n "}, {"sha": "56fd2da2576fbf8c68745cf0c7b5068816fb7bb7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -7,7 +7,7 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n+use crate::{Resolver, ResolutionError, BindingKey, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n use crate::diagnostics::Suggestion;\n \n@@ -235,7 +235,8 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let resolution = self.resolution(module, ident, ns)\n+        let key = self.new_key(ident, ns);\n+        let resolution = self.resolution(module, key)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n@@ -447,17 +448,16 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define(\n+    crate fn try_define(\n         &mut self,\n         module: Module<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n+        key: BindingKey,\n         binding: &'a NameBinding<'a>,\n     ) -> Result<(), &'a NameBinding<'a>> {\n         let res = binding.res();\n-        self.check_reserved_macro_name(ident, res);\n+        self.check_reserved_macro_name(key.ident, res);\n         self.set_binding_parent_module(binding, module);\n-        self.update_resolution(module, ident, ns, |this, resolution| {\n+        self.update_resolution(module, key, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if res == Res::Err {\n                     // Do not override real bindings with `Res::Err`s from error recovery.\n@@ -479,8 +479,9 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             (binding, old_binding)\n                         };\n-                        if glob_binding.res() != nonglob_binding.res() &&\n-                           ns == MacroNS && nonglob_binding.expansion != ExpnId::root() {\n+                        if glob_binding.res() != nonglob_binding.res()\n+                            && key.ns == MacroNS && nonglob_binding.expansion != ExpnId::root()\n+                        {\n                             resolution.binding = Some(this.ambiguity(\n                                 AmbiguityKind::GlobVsExpanded,\n                                 nonglob_binding,\n@@ -499,9 +500,9 @@ impl<'a> Resolver<'a> {\n                                 DUPLICATE_MACRO_EXPORTS,\n                                 CRATE_NODE_ID,\n                                 binding.span,\n-                                &format!(\"a macro named `{}` has already been exported\", ident),\n+                                &format!(\"a macro named `{}` has already been exported\", key.ident),\n                                 BuiltinLintDiagnostics::DuplicatedMacroExports(\n-                                    ident, old_binding.span, binding.span));\n+                                    key.ident, old_binding.span, binding.span));\n \n                             resolution.binding = Some(binding);\n                         } else {\n@@ -531,17 +532,17 @@ impl<'a> Resolver<'a> {\n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(\n-        &mut self, module: Module<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n+        &mut self,\n+        module: Module<'a>,\n+        key: BindingKey,\n         f: F,\n     ) -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n+            let resolution = &mut *self.resolution(module, key).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -558,15 +559,16 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            let mut ident = ident.modern();\n+            let mut ident = key.ident;\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+                let key = BindingKey { ident, ..key };\n+                let _ = self.try_define(directive.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -580,7 +582,8 @@ impl<'a> Resolver<'a> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent_scope.module, target, ns, dummy_binding);\n+                let key = this.new_key(target, ns);\n+                let _ = this.try_define(directive.parent_scope.module, key, dummy_binding);\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n                 this.record_use(target, ns, dummy_binding, false);\n             });\n@@ -820,8 +823,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let parent = directive.parent_scope.module;\n             match source_bindings[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n+                // Don't update the resolution, because it was never added.\n+                Err(Determined) if target.name == kw::Underscore => {}\n                 Err(Determined) => {\n-                    this.update_resolution(parent, target, ns, |_, resolution| {\n+                    let key = this.new_key(target, ns);\n+                    this.update_resolution(parent, key, |_, resolution| {\n                         resolution.single_imports.remove(&PtrKey(directive));\n                     });\n                 }\n@@ -1052,7 +1058,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n-                let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n+                let names = resolutions.filter_map(|(BindingKey { ident: i, .. }, resolution)| {\n                     if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n                         NameResolution { binding: Some(name_binding), .. } => {\n@@ -1301,19 +1307,18 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(key, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*key, binding))\n         }).collect::<Vec<_>>();\n-        for ((mut ident, ns), binding) in bindings {\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+        for (mut key, binding) in bindings {\n+            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.r.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.r.import(binding, directive);\n-                let _ =\n-                    self.r.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+                let _ = self.r.try_define(directive.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -1329,29 +1334,23 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n-            let resolution = &mut *resolution.borrow_mut();\n-            let binding = match resolution.binding {\n-                Some(binding) => binding,\n-                None => continue,\n-            };\n-\n+        module.for_each_child(self.r, |this, ident, ns, binding| {\n             // Filter away ambiguous imports and anything that has def-site\n             // hygiene.\n             // FIXME: Implement actual cross-crate hygiene.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity()\n-                && !ident.span.modern().from_expansion();\n+                && !ident.span.from_expansion();\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            self.r.cstore.export_macros_untracked(def_id.krate);\n+                            this.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {\n-                        ident: ident.modern(),\n-                        res: res,\n+                        ident,\n+                        res,\n                         span: binding.span,\n                         vis: binding.vis,\n                     });\n@@ -1360,7 +1359,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                    !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                    !orig_binding.vis.is_at_least(binding.vis, &*this) {\n                         let msg = match directive.subclass {\n                             ImportDirectiveSubclass::SingleImport { .. } => {\n                                 format!(\"variant `{}` is private and cannot be re-exported\",\n@@ -1372,41 +1371,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n                                                 Some(binding.span),\n                                                 msg.clone());\n-                                let fresh = self.r.session.one_time_diagnostics\n+                                let fresh = this.session.one_time_diagnostics\n                                     .borrow_mut().insert(error_id);\n                                 if !fresh {\n-                                    continue;\n+                                    return;\n                                 }\n                                 msg\n                             },\n                             ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n                         };\n-                        let mut err = self.r.session.struct_span_err(binding.span, &msg);\n+                        let mut err = this.session.struct_span_err(binding.span, &msg);\n \n                         let imported_module = match directive.imported_module.get() {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n                         let parent_module = imported_module.parent.expect(\"parent should exist\");\n-                        let resolutions = self.r.resolutions(parent_module).borrow();\n+                        let resolutions = this.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n \n-                        let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                        let key = this.new_key(enum_ident, TypeNS);\n+                        let enum_resolution = resolutions.get(&key)\n                             .expect(\"resolution should exist\");\n                         let enum_span = enum_resolution.borrow()\n                             .binding.expect(\"binding should exist\")\n                             .span;\n-                        let enum_def_span = self.r.session.source_map().def_span(enum_span);\n-                        let enum_def_snippet = self.r.session.source_map()\n+                        let enum_def_span = this.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = this.session.source_map()\n                             .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                         // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                         let after_vis_index = enum_def_snippet.find(\"enum\")\n                             .expect(\"`enum` keyword should exist in snippet\");\n                         let suggestion = format!(\"pub {}\",\n                                                  &enum_def_snippet[after_vis_index..]);\n \n-                        self.r.session\n+                        this.session\n                             .diag_span_suggestion_once(&mut err,\n                                                        DiagnosticMessageId::ErrorId(0),\n                                                        enum_def_span,\n@@ -1415,7 +1415,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         err.emit();\n                 }\n             }\n-        }\n+        });\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {"}, {"sha": "e0e1a1c468c90f3a1291c92a9d6569e93552ccf8", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -334,8 +334,7 @@ impl Ident {\n         if !Self::is_valid(&string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        // Get rid of gensyms to conservatively check rawness on the string contents only.\n-        if is_raw && !sym.as_interned_str().as_symbol().can_be_raw() {\n+        if is_raw && !sym.can_be_raw() {\n             panic!(\"`{}` cannot be a raw identifier\", string);\n         }\n         Ident { sym, is_raw, span }"}, {"sha": "8845b66a7cefd8cf5342c26e5f39d4d17e6b3e41", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 81, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -808,25 +808,13 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n-    /// Transforms an underscore identifier into one with the same name, but\n-    /// gensymed. Leaves non-underscore identifiers unchanged.\n-    pub fn gensym_if_underscore(self) -> Ident {\n-        if self.name == kw::Underscore {\n-            let name = with_interner(|interner| interner.gensymed(self.name));\n-            Ident::new(name, self.span)\n-        } else {\n-            self\n-        }\n-    }\n-\n     /// Convert the name to a `LocalInternedString`. This is a slowish\n     /// operation because it requires locking the symbol interner.\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n \n-    /// Convert the name to an `InternedString`. This is a slowish operation\n-    /// because it requires locking the symbol interner.\n+    /// Convert the name to an `InternedString`.\n     pub fn as_interned_str(self) -> InternedString {\n         self.name.as_interned_str()\n     }\n@@ -881,26 +869,9 @@ impl UseSpecializedDecodable for Ident {\n     }\n }\n \n-/// A symbol is an interned or gensymed string. A gensym is a symbol that is\n-/// never equal to any other symbol.\n+/// An interned string.\n ///\n-/// Conceptually, a gensym can be thought of as a normal symbol with an\n-/// invisible unique suffix. Gensyms are useful when creating new identifiers\n-/// that must not match any existing identifiers, e.g. during macro expansion\n-/// and syntax desugaring. Because gensyms should always be identifiers, all\n-/// gensym operations are on `Ident` rather than `Symbol`. (Indeed, in the\n-/// future the gensym-ness may be moved from `Symbol` to hygiene data.)\n-///\n-/// Examples:\n-/// ```\n-/// assert_eq!(Ident::from_str(\"_\"), Ident::from_str(\"_\"))\n-/// assert_ne!(Ident::from_str(\"_\").gensym_if_underscore(), Ident::from_str(\"_\"))\n-/// assert_ne!(\n-///     Ident::from_str(\"_\").gensym_if_underscore(),\n-///     Ident::from_str(\"_\").gensym_if_underscore(),\n-/// )\n-/// ```\n-/// Internally, a symbol is implemented as an index, and all operations\n+/// Internally, a `Symbol` is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use\n /// of `rustc_index::newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,\n /// because `rustc_index::newtype_index!` reserves the last 256 values for tagging purposes.\n@@ -951,12 +922,9 @@ impl Symbol {\n         })\n     }\n \n-    /// Convert to an `InternedString`. This is a slowish operation because it\n-    /// requires locking the symbol interner.\n+    /// Convert to an `InternedString`.\n     pub fn as_interned_str(self) -> InternedString {\n-        with_interner(|interner| InternedString {\n-            symbol: interner.interned(self)\n-        })\n+        InternedString { symbol: self }\n     }\n \n     pub fn as_u32(self) -> u32 {\n@@ -966,12 +934,7 @@ impl Symbol {\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));\n-        if is_gensymed {\n-            write!(f, \"{}({:?})\", self, self.0)\n-        } else {\n-            write!(f, \"{}\", self)\n-        }\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n@@ -994,15 +957,11 @@ impl Decodable for Symbol {\n }\n \n // The `&'static str`s in this type actually point into the arena.\n-//\n-// Note that normal symbols are indexed upward from 0, and gensyms are indexed\n-// downward from SymbolIndex::MAX_AS_U32.\n #[derive(Default)]\n pub struct Interner {\n     arena: DroplessArena,\n     names: FxHashMap<&'static str, Symbol>,\n     strings: Vec<&'static str>,\n-    gensyms: Vec<Symbol>,\n }\n \n impl Interner {\n@@ -1035,34 +994,10 @@ impl Interner {\n         self.names.insert(string, name);\n         name\n     }\n-\n-    fn interned(&self, symbol: Symbol) -> Symbol {\n-        if (symbol.0.as_usize()) < self.strings.len() {\n-            symbol\n-        } else {\n-            self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize]\n-        }\n-    }\n-\n-    fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n-        self.gensyms.push(symbol);\n-        Symbol::new(SymbolIndex::MAX_AS_U32 - self.gensyms.len() as u32 + 1)\n-    }\n-\n-    fn is_gensymed(&mut self, symbol: Symbol) -> bool {\n-        symbol.0.as_usize() >= self.strings.len()\n-    }\n-\n     // Get the symbol as a string. `Symbol::as_str()` should be used in\n     // preference to this function.\n     pub fn get(&self, symbol: Symbol) -> &str {\n-        match self.strings.get(symbol.0.as_usize()) {\n-            Some(string) => string,\n-            None => {\n-                let symbol = self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize];\n-                self.strings[symbol.0.as_usize()]\n-            }\n-        }\n+        self.strings[symbol.0.as_usize()]\n     }\n }\n \n@@ -1223,19 +1158,12 @@ impl fmt::Display for LocalInternedString {\n     }\n }\n \n-/// An alternative to `Symbol` that is focused on string contents. It has two\n-/// main differences to `Symbol`.\n+/// An alternative to `Symbol` that is focused on string contents.\n ///\n-/// First, its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n+/// Its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n /// string chars rather than the symbol integer. This is useful when hash\n /// stability is required across compile sessions, or a guaranteed sort\n /// ordering is required.\n-///\n-/// Second, gensym-ness is irrelevant. E.g.:\n-/// ```\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n-/// assert_eq!(Symbol::gensym(\"x\").as_interned_str(), Symbol::gensym(\"x\").as_interned_str())\n-/// ```\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub struct InternedString {\n     symbol: Symbol,"}, {"sha": "f74b9a0cd1d1df0213739c04d1d389c9825ebe71", "filename": "src/libsyntax_pos/symbol/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -14,13 +14,6 @@ fn interner_tests() {\n     assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n     // dog is still at zero\n     assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-    let z = i.intern(\"zebra\");\n-    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n-    // gensym of same string gets new number:\n-    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n-    // gensym of *existing* string gets new number:\n-    let d = i.intern(\"dog\");\n-    assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n }\n \n #[test]"}, {"sha": "bea61eae6b51a38e64bd8ff92e4069177ff7b342", "filename": "src/test/ui/underscore-imports/hygiene-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -0,0 +1,33 @@\n+// Make sure that underscore imports with different contexts can exist in the\n+// same scope.\n+\n+// check-pass\n+\n+#![feature(decl_macro)]\n+\n+mod x {\n+    pub use std::ops::Deref as _;\n+}\n+\n+macro n() {\n+    pub use crate::x::*;\n+}\n+\n+#[macro_export]\n+macro_rules! p {\n+    () => { pub use crate::x::*; }\n+}\n+\n+macro m($y:ident) {\n+    mod $y {\n+        crate::n!(); // Reexport of `Deref` should not be imported in `main`\n+        crate::p!(); // Reexport of `Deref` should be imported into `main`\n+    }\n+}\n+\n+m!(y);\n+\n+fn main() {\n+    use crate::y::*;\n+    (&()).deref();\n+}"}, {"sha": "a254f6eaa59807ea0a2721f9698b918a0d58851a", "filename": "src/test/ui/underscore-imports/hygiene.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -0,0 +1,40 @@\n+// Make sure that underscore imports have the same hygiene considerations as\n+// other imports.\n+\n+#![feature(decl_macro)]\n+\n+mod x {\n+    pub use std::ops::Deref as _;\n+}\n+\n+\n+macro glob_import() {\n+    pub use crate::x::*;\n+}\n+\n+macro underscore_import() {\n+    use std::ops::DerefMut as _;\n+}\n+\n+mod y {\n+    crate::glob_import!();\n+    crate::underscore_import!();\n+}\n+\n+macro create_module($y:ident) {\n+    mod $y {\n+        crate::glob_import!();\n+        crate::underscore_import!();\n+    }\n+}\n+\n+create_module!(z);\n+\n+fn main() {\n+    use crate::y::*;\n+    use crate::z::*;\n+    glob_import!();\n+    underscore_import!();\n+    (&()).deref();              //~ ERROR no method named `deref`\n+    (&mut ()).deref_mut();      //~ ERROR no method named `deref_mut`\n+}"}, {"sha": "44cfc5cc5d22e21cbb17df7860b34e732f38c667", "filename": "src/test/ui/underscore-imports/hygiene.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `deref` found for type `&()` in the current scope\n+  --> $DIR/hygiene.rs:38:11\n+   |\n+LL |     (&()).deref();\n+   |           ^^^^^ method not found in `&()`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use std::ops::Deref;\n+   |\n+\n+error[E0599]: no method named `deref_mut` found for type `&mut ()` in the current scope\n+  --> $DIR/hygiene.rs:39:15\n+   |\n+LL |     (&mut ()).deref_mut();\n+   |               ^^^^^^^^^ method not found in `&mut ()`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use std::ops::DerefMut;\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "43f527bc9a4087866163a38a59b61c10ba088d76", "filename": "src/test/ui/underscore-imports/macro-expanded.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fmacro-expanded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3d9e57e7e487b86b113bb235b716111be48bb8/src%2Ftest%2Fui%2Funderscore-imports%2Fmacro-expanded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fmacro-expanded.rs?ref=af3d9e57e7e487b86b113bb235b716111be48bb8", "patch": "@@ -0,0 +1,45 @@\n+// Check that macro expanded underscore imports behave as expected\n+\n+// check-pass\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+mod x {\n+    pub use std::ops::Not as _;\n+}\n+\n+macro m() {\n+    mod w {\n+        mod y {\n+            pub use std::ops::Deref as _;\n+        }\n+        use crate::x::*;\n+        use self::y::*;\n+        use std::ops::DerefMut as _;\n+        fn f() {\n+            false.not();\n+            (&()).deref();\n+            (&mut ()).deref_mut();\n+        }\n+    }\n+}\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro n() {\n+    mod z {\n+        pub use std::ops::Deref as _;\n+    }\n+    use crate::x::*;\n+    use crate::z::*;\n+    use std::ops::DerefMut as _;\n+    fn f() {\n+        false.not();\n+        (&()).deref();\n+        (&mut ()).deref_mut();\n+    }\n+}\n+\n+m!();\n+n!();\n+\n+fn main() {}"}]}