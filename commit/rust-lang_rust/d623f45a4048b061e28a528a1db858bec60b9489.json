{"sha": "d623f45a4048b061e28a528a1db858bec60b9489", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjNmNDVhNDA0OGIwNjFlMjhhNTI4YTFkYjg1OGJlYzYwYjk0ODk=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-05-16T15:22:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-16T15:22:45Z"}, "message": "Rollup merge of #50638 - tbu-:pr_open_cloexec_once, r=nagisa\n\nDon't unconditionally set CLOEXEC twice on every fd we open on Linux\n\nPreviously, every `open64` was accompanied by a `ioctl(\u2026, FIOCLEX)`,\nbecause some old Linux version would ignore the `O_CLOEXEC` flag we pass\nto the `open64` function.\n\nNow, we check whether the `CLOEXEC` flag is set on the first file we\nopen \u2013 if it is, we won't do extra syscalls for every opened file. If it\nis not set, we fall back to the old behavior of unconditionally calling\n`ioctl(\u2026, FIOCLEX)` on newly opened files.\n\nOn old Linuxes, this amounts to one extra syscall per process, namely\nthe `fcntl(\u2026, F_GETFD)` call to check the `CLOEXEC` flag.\n\nOn new Linuxes, this reduces the number of syscalls per opened file by\none, except for the first file, where it does the same number of\nsyscalls as before (`fcntl(\u2026, F_GETFD)` to check the flag instead of\n`ioctl(\u2026, FIOCLEX)` to set it).", "tree": {"sha": "0e988cccbbbe0249bbf2d7e0af8c9854ed811712", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e988cccbbbe0249bbf2d7e0af8c9854ed811712"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d623f45a4048b061e28a528a1db858bec60b9489", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa/EzFCRBK7hj4Ov3rIwAAdHIIAJIN1Fddk9tdtBKyMRV2PIcb\nGk53NwE+bfD2O8DsQZuW2fOkGiQ4HpJ92Lewt0yc9IZPe9MGosXY8So3SlEBncC6\nCkwG8ZTUzj+ymC8rs/egbBaEMd+pbRPZWoudvQVp73/nS19uUP4Ni5+MqWW85iSS\n4tEuwqqG8kxhA0QlRh0RQzfHTqiIr0hl+ULXToeM5SdaWvBxGhmUS96yB0imJvYa\nIzqR3+80RQbqZbNE5eM6yqJWSh7TeY4KWlAHr54CCylqvwQHMq9f4k16dFUiPz0C\ne21G9nLWvC42CyZ3BUHy5+Axb/wXbFP9Cmg46ag6hJyrvD7MJLDyajvDczoMpT4=\n=lWkF\n-----END PGP SIGNATURE-----\n", "payload": "tree 0e988cccbbbe0249bbf2d7e0af8c9854ed811712\nparent 2a3f5367a23a769a068c37460db336de427c4b48\nparent 6d1da8232997af4b785486329f01995440818920\nauthor kennytm <kennytm@gmail.com> 1526484165 +0800\ncommitter GitHub <noreply@github.com> 1526484165 +0800\n\nRollup merge of #50638 - tbu-:pr_open_cloexec_once, r=nagisa\n\nDon't unconditionally set CLOEXEC twice on every fd we open on Linux\n\nPreviously, every `open64` was accompanied by a `ioctl(\u2026, FIOCLEX)`,\nbecause some old Linux version would ignore the `O_CLOEXEC` flag we pass\nto the `open64` function.\n\nNow, we check whether the `CLOEXEC` flag is set on the first file we\nopen \u2013 if it is, we won't do extra syscalls for every opened file. If it\nis not set, we fall back to the old behavior of unconditionally calling\n`ioctl(\u2026, FIOCLEX)` on newly opened files.\n\nOn old Linuxes, this amounts to one extra syscall per process, namely\nthe `fcntl(\u2026, F_GETFD)` call to check the `CLOEXEC` flag.\n\nOn new Linuxes, this reduces the number of syscalls per opened file by\none, except for the first file, where it does the same number of\nsyscalls as before (`fcntl(\u2026, F_GETFD)` to check the flag instead of\n`ioctl(\u2026, FIOCLEX)` to set it).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d623f45a4048b061e28a528a1db858bec60b9489", "html_url": "https://github.com/rust-lang/rust/commit/d623f45a4048b061e28a528a1db858bec60b9489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d623f45a4048b061e28a528a1db858bec60b9489/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a3f5367a23a769a068c37460db336de427c4b48", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3f5367a23a769a068c37460db336de427c4b48", "html_url": "https://github.com/rust-lang/rust/commit/2a3f5367a23a769a068c37460db336de427c4b48"}, {"sha": "6d1da8232997af4b785486329f01995440818920", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d1da8232997af4b785486329f01995440818920", "html_url": "https://github.com/rust-lang/rust/commit/6d1da8232997af4b785486329f01995440818920"}], "stats": {"total": 48, "additions": 44, "deletions": 4}, "files": [{"sha": "4830e38d6a92fd8c4c2b337e54b97c1af0a848cc", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d623f45a4048b061e28a528a1db858bec60b9489/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d623f45a4048b061e28a528a1db858bec60b9489/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=d623f45a4048b061e28a528a1db858bec60b9489", "patch": "@@ -154,6 +154,13 @@ impl FileDesc {\n         }\n     }\n \n+    #[cfg(target_os = \"linux\")]\n+    pub fn get_cloexec(&self) -> io::Result<bool> {\n+        unsafe {\n+            Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0)\n+        }\n+    }\n+\n     #[cfg(not(any(target_env = \"newlib\",\n                   target_os = \"solaris\",\n                   target_os = \"emscripten\","}, {"sha": "77968ffdedf37a8afe888477f8d7206f57666e91", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d623f45a4048b061e28a528a1db858bec60b9489/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d623f45a4048b061e28a528a1db858bec60b9489/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=d623f45a4048b061e28a528a1db858bec60b9489", "patch": "@@ -441,15 +441,48 @@ impl File {\n \n         // Currently the standard library supports Linux 2.6.18 which did not\n         // have the O_CLOEXEC flag (passed above). If we're running on an older\n-        // Linux kernel then the flag is just ignored by the OS, so we continue\n-        // to explicitly ask for a CLOEXEC fd here.\n+        // Linux kernel then the flag is just ignored by the OS. After we open\n+        // the first file, we check whether it has CLOEXEC set. If it doesn't,\n+        // we will explicitly ask for a CLOEXEC fd for every further file we\n+        // open, if it does, we will skip that step.\n         //\n         // The CLOEXEC flag, however, is supported on versions of macOS/BSD/etc\n         // that we support, so we only do this on Linux currently.\n-        if cfg!(target_os = \"linux\") {\n-            fd.set_cloexec()?;\n+        #[cfg(target_os = \"linux\")]\n+        fn ensure_cloexec(fd: &FileDesc) -> io::Result<()> {\n+            use sync::atomic::{AtomicUsize, Ordering};\n+\n+            const OPEN_CLOEXEC_UNKNOWN: usize = 0;\n+            const OPEN_CLOEXEC_SUPPORTED: usize = 1;\n+            const OPEN_CLOEXEC_NOTSUPPORTED: usize = 2;\n+            static OPEN_CLOEXEC: AtomicUsize = AtomicUsize::new(OPEN_CLOEXEC_UNKNOWN);\n+\n+            let need_to_set;\n+            match OPEN_CLOEXEC.load(Ordering::Relaxed) {\n+                OPEN_CLOEXEC_UNKNOWN => {\n+                    need_to_set = !fd.get_cloexec()?;\n+                    OPEN_CLOEXEC.store(if need_to_set {\n+                        OPEN_CLOEXEC_NOTSUPPORTED\n+                    } else {\n+                        OPEN_CLOEXEC_SUPPORTED\n+                    }, Ordering::Relaxed);\n+                },\n+                OPEN_CLOEXEC_SUPPORTED => need_to_set = false,\n+                OPEN_CLOEXEC_NOTSUPPORTED => need_to_set = true,\n+                _ => unreachable!(),\n+            }\n+            if need_to_set {\n+                fd.set_cloexec()?;\n+            }\n+            Ok(())\n+        }\n+\n+        #[cfg(not(target_os = \"linux\"))]\n+        fn ensure_cloexec(_: &FileDesc) -> io::Result<()> {\n+            Ok(())\n         }\n \n+        ensure_cloexec(&fd)?;\n         Ok(File(fd))\n     }\n "}]}