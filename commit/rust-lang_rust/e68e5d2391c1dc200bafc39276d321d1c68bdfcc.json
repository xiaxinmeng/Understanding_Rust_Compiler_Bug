{"sha": "e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "node_id": "C_kwDOAAsO6NoAKGU2OGU1ZDIzOTFjMWRjMjAwYmFmYzM5Mjc2ZDMyMWQxYzY4YmRmY2M", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-01T09:50:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-01T09:50:18Z"}, "message": "Rollup merge of #87160 - estebank:colon-recovery, r=nagisa\n\nWhen recovering from a `:` in a pattern, use adequate AST pattern\n\nIf the suggestion to use `::` instead of `:` in the pattern isn't correct, a second resolution error will be emitted.", "tree": {"sha": "2d2fa3ed29af93b67ba718a41da7510958a1b2b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d2fa3ed29af93b67ba718a41da7510958a1b2b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhp0VaCRBK7hj4Ov3rIwAAUUYIAJX4fnuDaW7HNzG5u7mVSMr+\nq0+KvmUA3OfhRO2uxWj8wb01goAxokVaXY+TssCL1TjRURkA0lA3mNmX52HMteiC\nEz05UfIoL2JIYLRQfKMRdZv52ax3vjaBMVJhrZtTNcvxuS4hdhJ+45zZ+rWYSgoZ\nAppKN/Z5eCLKKT4kcTPMu1/IJ5oFuQQoBfKqeJrcbgTJtvMYPqEv/wKHka1H6mae\nelrA5FQCwkUeEtpv8kB7Rvznq3p1/vXhiVceLRTDYPST3A6CBG8mh0UT7fHSjhou\nM2tmoBQPUt014SLDYTG5mBKFbycNMx9qbcE0OXFnyJqgvGfazj2l+704Um61GqQ=\n=WNi1\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d2fa3ed29af93b67ba718a41da7510958a1b2b3\nparent 2446a215954a99f9d33019fad7d415ef9c083502\nparent c02710530c0005a30759e170be023cc167c6cd67\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638352218 +0100\ncommitter GitHub <noreply@github.com> 1638352218 +0100\n\nRollup merge of #87160 - estebank:colon-recovery, r=nagisa\n\nWhen recovering from a `:` in a pattern, use adequate AST pattern\n\nIf the suggestion to use `::` instead of `:` in the pattern isn't correct, a second resolution error will be emitted.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "html_url": "https://github.com/rust-lang/rust/commit/e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2446a215954a99f9d33019fad7d415ef9c083502", "url": "https://api.github.com/repos/rust-lang/rust/commits/2446a215954a99f9d33019fad7d415ef9c083502", "html_url": "https://github.com/rust-lang/rust/commit/2446a215954a99f9d33019fad7d415ef9c083502"}, {"sha": "c02710530c0005a30759e170be023cc167c6cd67", "url": "https://api.github.com/repos/rust-lang/rust/commits/c02710530c0005a30759e170be023cc167c6cd67", "html_url": "https://github.com/rust-lang/rust/commit/c02710530c0005a30759e170be023cc167c6cd67"}], "stats": {"total": 386, "additions": 252, "deletions": 134}, "files": [{"sha": "55af2c9ddd32f1cb9a5455e443a0e76b364d530a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 180, "deletions": 2, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "patch": "@@ -1,6 +1,9 @@\n+use super::pat::Expected;\n use super::ty::AllowPlus;\n-use super::TokenType;\n-use super::{BlockMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep, TokenExpectType};\n+use super::{\n+    BlockMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions, SemiColonMode, SeqSep,\n+    TokenExpectType, TokenType,\n+};\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n@@ -19,6 +22,8 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n+use std::mem::take;\n+\n use tracing::{debug, trace};\n \n const TURBOFISH_SUGGESTION_STR: &str =\n@@ -2075,4 +2080,177 @@ impl<'a> Parser<'a> {\n         );\n         err\n     }\n+\n+    /// Some special error handling for the \"top-level\" patterns in a match arm,\n+    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n+    crate fn maybe_recover_colon_colon_in_pat_typo(\n+        &mut self,\n+        mut first_pat: P<Pat>,\n+        ra: RecoverColon,\n+        expected: Expected,\n+    ) -> P<Pat> {\n+        if RecoverColon::Yes != ra || token::Colon != self.token.kind {\n+            return first_pat;\n+        }\n+        if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n+            || !self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+        {\n+            return first_pat;\n+        }\n+        // The pattern looks like it might be a path with a `::` -> `:` typo:\n+        // `match foo { bar:baz => {} }`\n+        let span = self.token.span;\n+        // We only emit \"unexpected `:`\" error here if we can successfully parse the\n+        // whole pattern correctly in that case.\n+        let snapshot = self.clone();\n+\n+        // Create error for \"unexpected `:`\".\n+        match self.expected_one_of_not_found(&[], &[]) {\n+            Err(mut err) => {\n+                self.bump(); // Skip the `:`.\n+                match self.parse_pat_no_top_alt(expected) {\n+                    Err(mut inner_err) => {\n+                        // Carry on as if we had not done anything, callers will emit a\n+                        // reasonable error.\n+                        inner_err.cancel();\n+                        err.cancel();\n+                        *self = snapshot;\n+                    }\n+                    Ok(mut pat) => {\n+                        // We've parsed the rest of the pattern.\n+                        let new_span = first_pat.span.to(pat.span);\n+                        let mut show_sugg = false;\n+                        // Try to construct a recovered pattern.\n+                        match &mut pat.kind {\n+                            PatKind::Struct(qself @ None, path, ..)\n+                            | PatKind::TupleStruct(qself @ None, path, _)\n+                            | PatKind::Path(qself @ None, path) => match &first_pat.kind {\n+                                PatKind::Ident(_, ident, _) => {\n+                                    path.segments.insert(0, PathSegment::from_ident(ident.clone()));\n+                                    path.span = new_span;\n+                                    show_sugg = true;\n+                                    first_pat = pat;\n+                                }\n+                                PatKind::Path(old_qself, old_path) => {\n+                                    path.segments = old_path\n+                                        .segments\n+                                        .iter()\n+                                        .cloned()\n+                                        .chain(take(&mut path.segments))\n+                                        .collect();\n+                                    path.span = new_span;\n+                                    *qself = old_qself.clone();\n+                                    first_pat = pat;\n+                                    show_sugg = true;\n+                                }\n+                                _ => {}\n+                            },\n+                            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+                                match &first_pat.kind {\n+                                    PatKind::Ident(_, old_ident, _) => {\n+                                        let path = PatKind::Path(\n+                                            None,\n+                                            Path {\n+                                                span: new_span,\n+                                                segments: vec![\n+                                                    PathSegment::from_ident(old_ident.clone()),\n+                                                    PathSegment::from_ident(ident.clone()),\n+                                                ],\n+                                                tokens: None,\n+                                            },\n+                                        );\n+                                        first_pat = self.mk_pat(new_span, path);\n+                                        show_sugg = true;\n+                                    }\n+                                    PatKind::Path(old_qself, old_path) => {\n+                                        let mut segments = old_path.segments.clone();\n+                                        segments.push(PathSegment::from_ident(ident.clone()));\n+                                        let path = PatKind::Path(\n+                                            old_qself.clone(),\n+                                            Path { span: new_span, segments, tokens: None },\n+                                        );\n+                                        first_pat = self.mk_pat(new_span, path);\n+                                        show_sugg = true;\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                        if show_sugg {\n+                            err.span_suggestion(\n+                                span,\n+                                \"maybe write a path separator here\",\n+                                \"::\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            first_pat = self.mk_pat(new_span, PatKind::Wild);\n+                        }\n+                        err.emit();\n+                    }\n+                }\n+            }\n+            _ => {\n+                // Carry on as if we had not done anything. This should be unreachable.\n+                *self = snapshot;\n+            }\n+        };\n+        first_pat\n+    }\n+\n+    /// Some special error handling for the \"top-level\" patterns in a match arm,\n+    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n+    crate fn maybe_recover_unexpected_comma(\n+        &mut self,\n+        lo: Span,\n+        rc: RecoverComma,\n+    ) -> PResult<'a, ()> {\n+        if rc == RecoverComma::No || self.token != token::Comma {\n+            return Ok(());\n+        }\n+\n+        // An unexpected comma after a top-level pattern is a clue that the\n+        // user (perhaps more accustomed to some other language) forgot the\n+        // parentheses in what should have been a tuple pattern; return a\n+        // suggestion-enhanced error here rather than choking on the comma later.\n+        let comma_span = self.token.span;\n+        self.bump();\n+        if let Err(mut err) = self.skip_pat_list() {\n+            // We didn't expect this to work anyway; we just wanted to advance to the\n+            // end of the comma-sequence so we know the span to suggest parenthesizing.\n+            err.cancel();\n+        }\n+        let seq_span = lo.to(self.prev_token.span);\n+        let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n+        if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n+            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n+\n+            err.span_suggestion(\n+                seq_span,\n+                MSG,\n+                format!(\"({})\", seq_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.span_suggestion(\n+                seq_span,\n+                \"...or a vertical bar to match on multiple alternatives\",\n+                seq_snippet.replace(\",\", \" |\"),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        Err(err)\n+    }\n+\n+    /// Parse and throw away a parenthesized comma separated\n+    /// sequence of patterns until `)` is reached.\n+    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat_no_top_alt(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(());\n+            }\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "ac3123c40e3d96d78190fccbb073386a8ffe31d4", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 9, "deletions": 104, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "patch": "@@ -3,14 +3,16 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::{self as ast, AttrVec, Attribute, MacCall, Pat, PatField, PatKind, RangeEnd};\n-use rustc_ast::{BindingMode, Expr, ExprKind, Mutability, Path, QSelf, RangeSyntax};\n+use rustc_ast::{\n+    self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n+    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n+};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n-type Expected = Option<&'static str>;\n+pub(super) type Expected = Option<&'static str>;\n \n /// `Expected` for function and lambda parameter patterns.\n pub(super) const PARAM_EXPECTED: Expected = Some(\"parameter name\");\n@@ -98,55 +100,9 @@ impl<'a> Parser<'a> {\n             // If we parsed a leading `|` which should be gated,\n             // then we should really gate the leading `|`.\n             // This complicated procedure is done purely for diagnostics UX.\n-            let mut first_pat = first_pat;\n-\n-            if let (RecoverColon::Yes, token::Colon) = (ra, &self.token.kind) {\n-                if matches!(\n-                    first_pat.kind,\n-                    PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None)\n-                        | PatKind::Path(..)\n-                ) && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n-                {\n-                    // The pattern looks like it might be a path with a `::` -> `:` typo:\n-                    // `match foo { bar:baz => {} }`\n-                    let span = self.token.span;\n-                    // We only emit \"unexpected `:`\" error here if we can successfully parse the\n-                    // whole pattern correctly in that case.\n-                    let snapshot = self.clone();\n-\n-                    // Create error for \"unexpected `:`\".\n-                    match self.expected_one_of_not_found(&[], &[]) {\n-                        Err(mut err) => {\n-                            self.bump(); // Skip the `:`.\n-                            match self.parse_pat_no_top_alt(expected) {\n-                                Err(mut inner_err) => {\n-                                    // Carry on as if we had not done anything, callers will emit a\n-                                    // reasonable error.\n-                                    inner_err.cancel();\n-                                    err.cancel();\n-                                    *self = snapshot;\n-                                }\n-                                Ok(pat) => {\n-                                    // We've parsed the rest of the pattern.\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"maybe write a path separator here\",\n-                                        \"::\".to_string(),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                    err.emit();\n-                                    first_pat =\n-                                        self.mk_pat(first_pat.span.to(pat.span), PatKind::Wild);\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            // Carry on as if we had not done anything. This should be unreachable.\n-                            *self = snapshot;\n-                        }\n-                    };\n-                }\n-            }\n+\n+            // Check if the user wrote `foo:bar` instead of `foo::bar`.\n+            let first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, ra, expected);\n \n             if let Some(leading_vert_span) = leading_vert_span {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n@@ -321,57 +277,6 @@ impl<'a> Parser<'a> {\n         err.emit();\n     }\n \n-    /// Some special error handling for the \"top-level\" patterns in a match arm,\n-    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    fn maybe_recover_unexpected_comma(&mut self, lo: Span, rc: RecoverComma) -> PResult<'a, ()> {\n-        if rc == RecoverComma::No || self.token != token::Comma {\n-            return Ok(());\n-        }\n-\n-        // An unexpected comma after a top-level pattern is a clue that the\n-        // user (perhaps more accustomed to some other language) forgot the\n-        // parentheses in what should have been a tuple pattern; return a\n-        // suggestion-enhanced error here rather than choking on the comma later.\n-        let comma_span = self.token.span;\n-        self.bump();\n-        if let Err(mut err) = self.skip_pat_list() {\n-            // We didn't expect this to work anyway; we just wanted to advance to the\n-            // end of the comma-sequence so we know the span to suggest parenthesizing.\n-            err.cancel();\n-        }\n-        let seq_span = lo.to(self.prev_token.span);\n-        let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n-        if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n-            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n-\n-            err.span_suggestion(\n-                seq_span,\n-                MSG,\n-                format!(\"({})\", seq_snippet),\n-                Applicability::MachineApplicable,\n-            );\n-            err.span_suggestion(\n-                seq_span,\n-                \"...or a vertical bar to match on multiple alternatives\",\n-                seq_snippet.replace(\",\", \" |\"),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        Err(err)\n-    }\n-\n-    /// Parse and throw away a parenthesized comma separated\n-    /// sequence of patterns until `)` is reached.\n-    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            self.parse_pat_no_top_alt(None)?;\n-            if !self.eat(&token::Comma) {\n-                return Ok(());\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     /// A `|` or possibly `||` token shouldn't be here. Ban it.\n     fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n         let span = self.token.span;\n@@ -1168,7 +1073,7 @@ impl<'a> Parser<'a> {\n         self.mk_pat(span, PatKind::Ident(bm, ident, None))\n     }\n \n-    fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n+    pub(super) fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n         P(Pat { kind, span, id: ast::DUMMY_NODE_ID, tokens: None })\n     }\n }"}, {"sha": "0b7b67496d6f32df39107feb43e1c957a029ae21", "filename": "src/test/ui/parser/issues/issue-87086-colon-path-sep.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs?ref=e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "patch": "@@ -1,11 +1,15 @@\n // Tests that a suggestion is issued if the user wrote a colon instead of\n // a path separator in a match arm.\n \n-enum Foo {\n-    Bar,\n-    Baz,\n+mod qux {\n+    pub enum Foo {\n+        Bar,\n+        Baz,\n+    }\n }\n \n+use qux::Foo;\n+\n fn f() -> Foo { Foo::Bar }\n \n fn g1() {\n@@ -16,41 +20,43 @@ fn g1() {\n         _ => {}\n     }\n     match f() {\n-        Foo::Bar:Baz => {}\n+        qux::Foo:Bar => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n     match f() {\n-        Foo:Bar::Baz => {}\n+        qux:Foo::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n     match f() {\n-        Foo: Bar::Baz if true => {}\n+        qux: Foo::Baz if true => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n-    if let Bar:Baz = f() {\n+    if let Foo:Bar = f() {\n     //~^ ERROR: expected one of\n     //~| HELP: maybe write a path separator here\n     }\n }\n \n fn g1_neg() {\n     match f() {\n-        ref Foo: Bar::Baz => {}\n+        ref qux: Foo::Baz => {}\n         //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n }\n \n fn g2_neg() {\n     match f() {\n-        mut Foo: Bar::Baz => {}\n+        mut qux: Foo::Baz => {}\n         //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n         _ => {}\n     }\n }\n@@ -62,5 +68,12 @@ fn main() {\n         Foo:Bar::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n+        //~| ERROR: failed to resolve: `Bar` is a variant, not a module\n+    }\n+    match myfoo {\n+        Foo::Bar => {}\n+        Foo:Bar => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n     }\n }"}, {"sha": "2050a16beb34983c63e96f847a82c1d23f3f16d5", "filename": "src/test/ui/parser/issues/issue-87086-colon-path-sep.stderr", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e68e5d2391c1dc200bafc39276d321d1c68bdfcc/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr?ref=e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "patch": "@@ -1,5 +1,5 @@\n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:13:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:17:12\n    |\n LL |         Foo:Bar => {}\n    |            ^\n@@ -8,61 +8,83 @@ LL |         Foo:Bar => {}\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:19:17\n+  --> $DIR/issue-87086-colon-path-sep.rs:23:17\n    |\n-LL |         Foo::Bar:Baz => {}\n+LL |         qux::Foo:Bar => {}\n    |                 ^\n    |                 |\n    |                 expected one of 8 possible tokens\n    |                 help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:25:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:29:12\n    |\n-LL |         Foo:Bar::Baz => {}\n+LL |         qux:Foo::Baz => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:31:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:35:12\n    |\n-LL |         Foo: Bar::Baz if true => {}\n+LL |         qux: Foo::Baz if true => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:36:15\n+  --> $DIR/issue-87086-colon-path-sep.rs:40:15\n    |\n-LL |     if let Bar:Baz = f() {\n+LL |     if let Foo:Bar = f() {\n    |               ^\n    |               |\n    |               expected one of `@` or `|`\n    |               help: maybe write a path separator here: `::`\n \n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:44:16\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:48:16\n    |\n-LL |         ref Foo: Bar::Baz => {}\n-   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+LL |         ref qux: Foo::Baz => {}\n+   |                ^\n+   |                |\n+   |                expected one of `@` or `|`\n+   |                help: maybe write a path separator here: `::`\n \n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:52:16\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:57:16\n    |\n-LL |         mut Foo: Bar::Baz => {}\n-   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+LL |         mut qux: Foo::Baz => {}\n+   |                ^\n+   |                |\n+   |                expected one of `@` or `|`\n+   |                help: maybe write a path separator here: `::`\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:62:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:12\n    |\n LL |         Foo:Bar::Baz => {}\n    |            ^\n    |            |\n    |            expected one of `@` or `|`\n    |            help: maybe write a path separator here: `::`\n \n-error: aborting due to 8 previous errors\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:75:12\n+   |\n+LL |         Foo:Bar => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error[E0433]: failed to resolve: `Bar` is a variant, not a module\n+  --> $DIR/issue-87086-colon-path-sep.rs:68:13\n+   |\n+LL |         Foo:Bar::Baz => {}\n+   |             ^^^ `Bar` is a variant, not a module\n+\n+error: aborting due to 10 previous errors\n \n+For more information about this error, try `rustc --explain E0433`."}]}