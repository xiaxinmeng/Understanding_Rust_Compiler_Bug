{"sha": "a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "node_id": "C_kwDOAAsO6NoAKGE2YTI3YTdmZjg0Y2QyM2JiYjlhZDY1YWUyYzA2YzI3MTUyNDdjYTI", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-06-02T13:59:17Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-06-02T13:59:17Z"}, "message": "Support floating point intrinsics in const eval", "tree": {"sha": "b46733cb2301260a1eb70f8a0f1cbf7a2056897f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b46733cb2301260a1eb70f8a0f1cbf7a2056897f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "html_url": "https://github.com/rust-lang/rust/commit/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9e3b180b7cbee429c465408bbe0e8dbfc104cd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e3b180b7cbee429c465408bbe0e8dbfc104cd7", "html_url": "https://github.com/rust-lang/rust/commit/f9e3b180b7cbee429c465408bbe0e8dbfc104cd7"}], "stats": {"total": 401, "additions": 294, "deletions": 107}, "files": [{"sha": "e05d824dbacfc430bf8c933f1b01680101dfce10", "filename": "crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "patch": "@@ -174,6 +174,40 @@ fn likely() {\n     );\n }\n \n+#[test]\n+fn floating_point() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn sqrtf32(x: f32) -> f32;\n+            pub fn powf32(a: f32, x: f32) -> f32;\n+            pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n+        }\n+\n+        const GOAL: f32 = sqrtf32(1.2) + powf32(3.4, 5.6) + fmaf32(-7.8, 1.3, 2.4);\n+        \"#,\n+        i128::from_le_bytes(pad16(\n+            &f32::to_le_bytes(1.2f32.sqrt() + 3.4f32.powf(5.6) + (-7.8f32).mul_add(1.3, 2.4)),\n+            true,\n+        )),\n+    );\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn powif64(a: f64, x: i32) -> f64;\n+            pub fn sinf64(x: f64) -> f64;\n+            pub fn minnumf64(x: f64, y: f64) -> f64;\n+        }\n+\n+        const GOAL: f64 = powif64(1.2, 5) + sinf64(3.4) + minnumf64(-7.8, 1.3);\n+        \"#,\n+        i128::from_le_bytes(pad16(\n+            &f64::to_le_bytes(1.2f64.powi(5) + 3.4f64.sin() + (-7.8f64).min(1.3)),\n+            true,\n+        )),\n+    );\n+}\n+\n #[test]\n fn atomic() {\n     check_number("}, {"sha": "6d7701c9e8d4b83cff225582dc49034e6aaa503a", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "patch": "@@ -870,7 +870,7 @@ impl Evaluator<'_> {\n                             Owned(c.to_le_bytes().into())\n                         }\n                         chalk_ir::FloatTy::F64 => {\n-                            let c = -from_bytes!(f32, c);\n+                            let c = -from_bytes!(f64, c);\n                             Owned(c.to_le_bytes().into())\n                         }\n                     }"}, {"sha": "77ee7b6b6e2a84611224bdfe2335ce457e205d24", "filename": "crates/hir-ty/src/mir/eval/shim.rs", "status": "modified", "additions": 235, "deletions": 106, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs?ref=a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "patch": "@@ -316,119 +316,145 @@ impl Evaluator<'_> {\n \n     fn exec_intrinsic(\n         &mut self,\n-        as_str: &str,\n+        name: &str,\n         args: &[IntervalAndTy],\n         generic_args: &Substitution,\n         destination: Interval,\n         locals: &Locals<'_>,\n         span: MirSpan,\n     ) -> Result<()> {\n-        // We are a single threaded runtime with no UB checking and no optimization, so\n-        // we can implement these as normal functions.\n-        if let Some(name) = as_str.strip_prefix(\"atomic_\") {\n-            let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n-                return Err(MirEvalError::TypeError(\"atomic intrinsic generic arg is not provided\"));\n-            };\n-            let Some(arg0) = args.get(0) else {\n-                return Err(MirEvalError::TypeError(\"atomic intrinsic arg0 is not provided\"));\n-            };\n-            let arg0_addr = Address::from_bytes(arg0.get(self)?)?;\n-            let arg0_interval = Interval::new(\n-                arg0_addr,\n-                self.size_of_sized(ty, locals, \"atomic intrinsic type arg\")?,\n-            );\n-            if name.starts_with(\"load_\") {\n-                return destination.write_from_interval(self, arg0_interval);\n-            }\n-            let Some(arg1) = args.get(1) else {\n-                return Err(MirEvalError::TypeError(\"atomic intrinsic arg1 is not provided\"));\n+        if let Some(name) = name.strip_prefix(\"atomic_\") {\n+            return self.exec_atomic_intrinsic(name, args, generic_args, destination, locals, span);\n+        }\n+        if let Some(name) = name.strip_suffix(\"f64\") {\n+            let result = match name {\n+                \"sqrt\" | \"sin\" | \"cos\" | \"exp\" | \"exp2\" | \"log\" | \"log10\" | \"log2\" | \"fabs\"\n+                | \"floor\" | \"ceil\" | \"trunc\" | \"rint\" | \"nearbyint\" | \"round\" | \"roundeven\" => {\n+                    let [arg] = args else {\n+                        return Err(MirEvalError::TypeError(\"f64 intrinsic signature doesn't match fn (f64) -> f64\"));\n+                    };\n+                    let arg = from_bytes!(f64, arg.get(self)?);\n+                    match name {\n+                        \"sqrt\" => arg.sqrt(),\n+                        \"sin\" => arg.sin(),\n+                        \"cos\" => arg.cos(),\n+                        \"exp\" => arg.exp(),\n+                        \"exp2\" => arg.exp2(),\n+                        \"log\" => arg.ln(),\n+                        \"log10\" => arg.log10(),\n+                        \"log2\" => arg.log2(),\n+                        \"fabs\" => arg.abs(),\n+                        \"floor\" => arg.floor(),\n+                        \"ceil\" => arg.ceil(),\n+                        \"trunc\" => arg.trunc(),\n+                        // FIXME: these rounds should be different, but only `.round()` is stable now.\n+                        \"rint\" => arg.round(),\n+                        \"nearbyint\" => arg.round(),\n+                        \"round\" => arg.round(),\n+                        \"roundeven\" => arg.round(),\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                \"pow\" | \"minnum\" | \"maxnum\" | \"copysign\" => {\n+                    let [arg1, arg2] = args else {\n+                        return Err(MirEvalError::TypeError(\"f64 intrinsic signature doesn't match fn (f64, f64) -> f64\"));\n+                    };\n+                    let arg1 = from_bytes!(f64, arg1.get(self)?);\n+                    let arg2 = from_bytes!(f64, arg2.get(self)?);\n+                    match name {\n+                        \"pow\" => arg1.powf(arg2),\n+                        \"minnum\" => arg1.min(arg2),\n+                        \"maxnum\" => arg1.max(arg2),\n+                        \"copysign\" => arg1.copysign(arg2),\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                \"powi\" => {\n+                    let [arg1, arg2] = args else {\n+                        return Err(MirEvalError::TypeError(\"powif64 signature doesn't match fn (f64, i32) -> f64\"));\n+                    };\n+                    let arg1 = from_bytes!(f64, arg1.get(self)?);\n+                    let arg2 = from_bytes!(i32, arg2.get(self)?);\n+                    arg1.powi(arg2)\n+                }\n+                \"fma\" => {\n+                    let [arg1, arg2, arg3] = args else {\n+                        return Err(MirEvalError::TypeError(\"fmaf64 signature doesn't match fn (f64, f64, f64) -> f64\"));\n+                    };\n+                    let arg1 = from_bytes!(f64, arg1.get(self)?);\n+                    let arg2 = from_bytes!(f64, arg2.get(self)?);\n+                    let arg3 = from_bytes!(f64, arg3.get(self)?);\n+                    arg1.mul_add(arg2, arg3)\n+                }\n+                _ => not_supported!(\"unknown f64 intrinsic {name}\"),\n             };\n-            if name.starts_with(\"store_\") {\n-                return arg0_interval.write_from_interval(self, arg1.interval);\n-            }\n-            if name.starts_with(\"xchg_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                return arg0_interval.write_from_interval(self, arg1.interval);\n-            }\n-            if name.starts_with(\"xadd_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n-                let ans = lhs.wrapping_add(rhs);\n-                return arg0_interval\n-                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n-            }\n-            if name.starts_with(\"xsub_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n-                let ans = lhs.wrapping_sub(rhs);\n-                return arg0_interval\n-                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n-            }\n-            if name.starts_with(\"and_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n-                let ans = lhs & rhs;\n-                return arg0_interval\n-                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n-            }\n-            if name.starts_with(\"or_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n-                let ans = lhs | rhs;\n-                return arg0_interval\n-                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n-            }\n-            if name.starts_with(\"xor_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n-                let ans = lhs ^ rhs;\n-                return arg0_interval\n-                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n-            }\n-            if name.starts_with(\"nand_\") {\n-                destination.write_from_interval(self, arg0_interval)?;\n-                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n-                let ans = !(lhs & rhs);\n-                return arg0_interval\n-                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n-            }\n-            let Some(arg2) = args.get(2) else {\n-                return Err(MirEvalError::TypeError(\"atomic intrinsic arg2 is not provided\"));\n+            return destination.write_from_bytes(self, &result.to_le_bytes());\n+        }\n+        if let Some(name) = name.strip_suffix(\"f32\") {\n+            let result = match name {\n+                \"sqrt\" | \"sin\" | \"cos\" | \"exp\" | \"exp2\" | \"log\" | \"log10\" | \"log2\" | \"fabs\"\n+                | \"floor\" | \"ceil\" | \"trunc\" | \"rint\" | \"nearbyint\" | \"round\" | \"roundeven\" => {\n+                    let [arg] = args else {\n+                        return Err(MirEvalError::TypeError(\"f32 intrinsic signature doesn't match fn (f32) -> f32\"));\n+                    };\n+                    let arg = from_bytes!(f32, arg.get(self)?);\n+                    match name {\n+                        \"sqrt\" => arg.sqrt(),\n+                        \"sin\" => arg.sin(),\n+                        \"cos\" => arg.cos(),\n+                        \"exp\" => arg.exp(),\n+                        \"exp2\" => arg.exp2(),\n+                        \"log\" => arg.ln(),\n+                        \"log10\" => arg.log10(),\n+                        \"log2\" => arg.log2(),\n+                        \"fabs\" => arg.abs(),\n+                        \"floor\" => arg.floor(),\n+                        \"ceil\" => arg.ceil(),\n+                        \"trunc\" => arg.trunc(),\n+                        // FIXME: these rounds should be different, but only `.round()` is stable now.\n+                        \"rint\" => arg.round(),\n+                        \"nearbyint\" => arg.round(),\n+                        \"round\" => arg.round(),\n+                        \"roundeven\" => arg.round(),\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                \"pow\" | \"minnum\" | \"maxnum\" | \"copysign\" => {\n+                    let [arg1, arg2] = args else {\n+                        return Err(MirEvalError::TypeError(\"f32 intrinsic signature doesn't match fn (f32, f32) -> f32\"));\n+                    };\n+                    let arg1 = from_bytes!(f32, arg1.get(self)?);\n+                    let arg2 = from_bytes!(f32, arg2.get(self)?);\n+                    match name {\n+                        \"pow\" => arg1.powf(arg2),\n+                        \"minnum\" => arg1.min(arg2),\n+                        \"maxnum\" => arg1.max(arg2),\n+                        \"copysign\" => arg1.copysign(arg2),\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                \"powi\" => {\n+                    let [arg1, arg2] = args else {\n+                        return Err(MirEvalError::TypeError(\"powif32 signature doesn't match fn (f32, i32) -> f32\"));\n+                    };\n+                    let arg1 = from_bytes!(f32, arg1.get(self)?);\n+                    let arg2 = from_bytes!(i32, arg2.get(self)?);\n+                    arg1.powi(arg2)\n+                }\n+                \"fma\" => {\n+                    let [arg1, arg2, arg3] = args else {\n+                        return Err(MirEvalError::TypeError(\"fmaf32 signature doesn't match fn (f32, f32, f32) -> f32\"));\n+                    };\n+                    let arg1 = from_bytes!(f32, arg1.get(self)?);\n+                    let arg2 = from_bytes!(f32, arg2.get(self)?);\n+                    let arg3 = from_bytes!(f32, arg3.get(self)?);\n+                    arg1.mul_add(arg2, arg3)\n+                }\n+                _ => not_supported!(\"unknown f32 intrinsic {name}\"),\n             };\n-            if name.starts_with(\"cxchg_\") || name.starts_with(\"cxchgweak_\") {\n-                let dest = if arg1.get(self)? == arg0_interval.get(self)? {\n-                    arg0_interval.write_from_interval(self, arg2.interval)?;\n-                    (arg1.interval, true)\n-                } else {\n-                    (arg0_interval, false)\n-                };\n-                let result_ty = TyKind::Tuple(\n-                    2,\n-                    Substitution::from_iter(Interner, [ty.clone(), TyBuilder::bool()]),\n-                )\n-                .intern(Interner);\n-                let layout = self.layout(&result_ty)?;\n-                let result = self.make_by_layout(\n-                    layout.size.bytes_usize(),\n-                    &layout,\n-                    None,\n-                    [\n-                        IntervalOrOwned::Borrowed(dest.0),\n-                        IntervalOrOwned::Owned(vec![u8::from(dest.1)]),\n-                    ]\n-                    .into_iter(),\n-                )?;\n-                return destination.write_from_bytes(self, &result);\n-            }\n-            not_supported!(\"unknown atomic intrinsic {name}\");\n+            return destination.write_from_bytes(self, &result.to_le_bytes());\n         }\n-        match as_str {\n+        match name {\n             \"size_of\" => {\n                 let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n                     return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n@@ -539,7 +565,7 @@ impl Evaluator<'_> {\n                     self.size_of_sized(&lhs.ty, locals, \"operand of add_with_overflow\")?;\n                 let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n-                let (ans, u128overflow) = match as_str {\n+                let (ans, u128overflow) = match name {\n                     \"add_with_overflow\" => lhs.overflowing_add(rhs),\n                     \"sub_with_overflow\" => lhs.overflowing_sub(rhs),\n                     \"mul_with_overflow\" => lhs.overflowing_mul(rhs),\n@@ -641,7 +667,110 @@ impl Evaluator<'_> {\n                 }\n                 self.exec_fn_trait(&args, destination, locals, span)\n             }\n-            _ => not_supported!(\"unknown intrinsic {as_str}\"),\n+            _ => not_supported!(\"unknown intrinsic {name}\"),\n+        }\n+    }\n+\n+    fn exec_atomic_intrinsic(\n+        &mut self,\n+        name: &str,\n+        args: &[IntervalAndTy],\n+        generic_args: &Substitution,\n+        destination: Interval,\n+        locals: &Locals<'_>,\n+        _span: MirSpan,\n+    ) -> Result<()> {\n+        // We are a single threaded runtime with no UB checking and no optimization, so\n+        // we can implement these as normal functions.\n+        let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+            return Err(MirEvalError::TypeError(\"atomic intrinsic generic arg is not provided\"));\n+        };\n+        let Some(arg0) = args.get(0) else {\n+            return Err(MirEvalError::TypeError(\"atomic intrinsic arg0 is not provided\"));\n+        };\n+        let arg0_addr = Address::from_bytes(arg0.get(self)?)?;\n+        let arg0_interval =\n+            Interval::new(arg0_addr, self.size_of_sized(ty, locals, \"atomic intrinsic type arg\")?);\n+        if name.starts_with(\"load_\") {\n+            return destination.write_from_interval(self, arg0_interval);\n+        }\n+        let Some(arg1) = args.get(1) else {\n+            return Err(MirEvalError::TypeError(\"atomic intrinsic arg1 is not provided\"));\n+        };\n+        if name.starts_with(\"store_\") {\n+            return arg0_interval.write_from_interval(self, arg1.interval);\n+        }\n+        if name.starts_with(\"xchg_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            return arg0_interval.write_from_interval(self, arg1.interval);\n+        }\n+        if name.starts_with(\"xadd_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+            let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+            let ans = lhs.wrapping_add(rhs);\n+            return arg0_interval.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+        }\n+        if name.starts_with(\"xsub_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+            let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+            let ans = lhs.wrapping_sub(rhs);\n+            return arg0_interval.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+        }\n+        if name.starts_with(\"and_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+            let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+            let ans = lhs & rhs;\n+            return arg0_interval.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+        }\n+        if name.starts_with(\"or_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+            let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+            let ans = lhs | rhs;\n+            return arg0_interval.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+        }\n+        if name.starts_with(\"xor_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+            let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+            let ans = lhs ^ rhs;\n+            return arg0_interval.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+        }\n+        if name.starts_with(\"nand_\") {\n+            destination.write_from_interval(self, arg0_interval)?;\n+            let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+            let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+            let ans = !(lhs & rhs);\n+            return arg0_interval.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+        }\n+        let Some(arg2) = args.get(2) else {\n+            return Err(MirEvalError::TypeError(\"atomic intrinsic arg2 is not provided\"));\n+        };\n+        if name.starts_with(\"cxchg_\") || name.starts_with(\"cxchgweak_\") {\n+            let dest = if arg1.get(self)? == arg0_interval.get(self)? {\n+                arg0_interval.write_from_interval(self, arg2.interval)?;\n+                (arg1.interval, true)\n+            } else {\n+                (arg0_interval, false)\n+            };\n+            let result_ty = TyKind::Tuple(\n+                2,\n+                Substitution::from_iter(Interner, [ty.clone(), TyBuilder::bool()]),\n+            )\n+            .intern(Interner);\n+            let layout = self.layout(&result_ty)?;\n+            let result = self.make_by_layout(\n+                layout.size.bytes_usize(),\n+                &layout,\n+                None,\n+                [IntervalOrOwned::Borrowed(dest.0), IntervalOrOwned::Owned(vec![u8::from(dest.1)])]\n+                    .into_iter(),\n+            )?;\n+            return destination.write_from_bytes(self, &result);\n         }\n+        not_supported!(\"unknown atomic intrinsic {name}\");\n     }\n }"}, {"sha": "a2f96977581c203f66abf4e0fbfb30d026d5d0aa", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=a6a27a7ff84cd23bbb9ad65ae2c06c2715247ca2", "patch": "@@ -4337,6 +4337,30 @@ const FOO$0: f64 = 1.0f64;\n     );\n }\n \n+#[test]\n+fn hover_const_eval_floating_point() {\n+    check(\n+        r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn expf64(x: f64) -> f64;\n+}\n+\n+const FOO$0: f64 = expf64(1.2);\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: f64 = 3.3201169227365472\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_eval_enum() {\n     check("}]}