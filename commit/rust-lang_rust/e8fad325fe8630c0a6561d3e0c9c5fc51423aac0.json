{"sha": "e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZmFkMzI1ZmU4NjMwYzBhNjU2MWQzZTBjOWM1ZmM1MTQyM2FhYzA=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-05T03:28:34Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-05T03:28:34Z"}, "message": "Make [u8]::reverse() 5x faster\n\nSince LLVM doesn't vectorize the loop for us, do unaligned reads\nof a larger type and use LLVM's bswap intrinsic to do the\nreversing of the actual bytes.  cfg!-restricted to x86 and\nx86_64, as I assume it wouldn't help on things like ARMv5.\n\nAlso makes [u16]::reverse() a more modest 1.5x faster by\nloading/storing u32 and swapping the u16s with ROT16.\n\nThank you ptr::*_unaligned for making this easy :)", "tree": {"sha": "802ce2c90817ccfbe44a3a680a685f83902e3643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802ce2c90817ccfbe44a3a680a685f83902e3643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "html_url": "https://github.com/rust-lang/rust/commit/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06fb4d25642a3f223db1441972dd5962085cfba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/06fb4d25642a3f223db1441972dd5962085cfba1", "html_url": "https://github.com/rust-lang/rust/commit/06fb4d25642a3f223db1441972dd5962085cfba1"}], "stats": {"total": 69, "additions": 69, "deletions": 0}, "files": [{"sha": "db523681bc7c549662b6f4e83563c077cf5ec2a8", "filename": "src/libcollections/benches/slice.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/src%2Flibcollections%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/src%2Flibcollections%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fslice.rs?ref=e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "patch": "@@ -290,3 +290,24 @@ sort!(sort_unstable, sort_unstable_large_random, gen_random, 10000);\n sort!(sort_unstable, sort_unstable_large_big_random, gen_big_random, 10000);\n sort!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n sort_expensive!(sort_unstable_by, sort_unstable_large_random_expensive, gen_random, 10000);\n+\n+macro_rules! reverse {\n+    ($name:ident, $ty:ident) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            // odd length and offset by 1 to be as unaligned as possible\n+            let n = 0xFFFFF;\n+            let mut v: Vec<_> =\n+                (0..1+(n / mem::size_of::<$ty>() as u64))\n+                .map(|x| x as $ty)\n+                .collect();\n+            b.iter(|| black_box(&mut v[1..]).reverse());\n+            b.bytes = n;\n+        }\n+    }\n+}\n+\n+reverse!(reverse_u8, u8);\n+reverse!(reverse_u16, u16);\n+reverse!(reverse_u32, u32);\n+reverse!(reverse_u64, u64);"}, {"sha": "1708f98b7ee47c2ab40ff0807fec183e09de2eea", "filename": "src/libcollections/tests/slice.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/src%2Flibcollections%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/src%2Flibcollections%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fslice.rs?ref=e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "patch": "@@ -379,6 +379,16 @@ fn test_reverse() {\n     let mut v3 = Vec::<i32>::new();\n     v3.reverse();\n     assert!(v3.is_empty());\n+\n+    // check the 1-byte-types path\n+    let mut v = (-50..51i8).collect::<Vec<_>>();\n+    v.reverse();\n+    assert_eq!(v, (-50..51i8).rev().collect::<Vec<_>>());\n+\n+    // check the 2-byte-types path\n+    let mut v = (-50..51i16).collect::<Vec<_>>();\n+    v.reverse();\n+    assert_eq!(v, (-50..51i16).rev().collect::<Vec<_>>());\n }\n \n #[test]"}, {"sha": "bf637af0639d90485764d9d28deba8b62396e570", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "patch": "@@ -539,6 +539,44 @@ impl<T> SliceExt for [T] {\n     fn reverse(&mut self) {\n         let mut i: usize = 0;\n         let ln = self.len();\n+\n+        let fast_unaligned =\n+            cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n+\n+        if fast_unaligned && mem::size_of::<T>() == 1 {\n+            // Single-byte read & write are comparatively slow. Instead,\n+            // work in usize chunks and get bswap to do the hard work.\n+            let chunk = mem::size_of::<usize>();\n+            while i + chunk - 1 < ln / 2 {\n+                unsafe {\n+                    let pa: *mut T = self.get_unchecked_mut(i);\n+                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n+                    let va = ptr::read_unaligned(pa as *mut usize);\n+                    let vb = ptr::read_unaligned(pb as *mut usize);\n+                    ptr::write_unaligned(pa as *mut usize, vb.swap_bytes());\n+                    ptr::write_unaligned(pb as *mut usize, va.swap_bytes());\n+                }\n+                i += chunk;\n+            }\n+        }\n+\n+        if fast_unaligned && mem::size_of::<T>() == 2 {\n+            // Not quite as good as the above, but still helpful.\n+            // Same general idea, read bigger and do the swap in a register.\n+            let chunk = mem::size_of::<u32>() / 2;\n+            while i + chunk - 1 < ln / 2 {\n+                unsafe {\n+                    let pa: *mut T = self.get_unchecked_mut(i);\n+                    let pb: *mut T = self.get_unchecked_mut(ln - i - chunk);\n+                    let va = ptr::read_unaligned(pa as *mut u32);\n+                    let vb = ptr::read_unaligned(pb as *mut u32);\n+                    ptr::write_unaligned(pa as *mut u32, vb.rotate_left(16));\n+                    ptr::write_unaligned(pb as *mut u32, va.rotate_left(16));\n+                }\n+                i += chunk;\n+            }\n+        }\n+\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n             unsafe {"}]}