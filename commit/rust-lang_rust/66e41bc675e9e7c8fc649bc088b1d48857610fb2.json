{"sha": "66e41bc675e9e7c8fc649bc088b1d48857610fb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTQxYmM2NzVlOWU3YzhmYzY0OWJjMDg4YjFkNDg4NTc2MTBmYjI=", "commit": {"author": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2019-03-11T18:46:20Z"}, "committer": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2019-04-25T15:42:59Z"}, "message": "Improved error message when type must be bound due to generator.\n\nError now mentions type var name and span is highlighted.", "tree": {"sha": "4385ecb3a6d347f59c17c6a94e46514264bc33dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4385ecb3a6d347f59c17c6a94e46514264bc33dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e41bc675e9e7c8fc649bc088b1d48857610fb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e41bc675e9e7c8fc649bc088b1d48857610fb2", "html_url": "https://github.com/rust-lang/rust/commit/66e41bc675e9e7c8fc649bc088b1d48857610fb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e41bc675e9e7c8fc649bc088b1d48857610fb2/comments", "author": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bee49f42b6dfb039d2a8e59e5181e26531c3c11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bee49f42b6dfb039d2a8e59e5181e26531c3c11", "html_url": "https://github.com/rust-lang/rust/commit/3bee49f42b6dfb039d2a8e59e5181e26531c3c11"}], "stats": {"total": 170, "additions": 135, "deletions": 35}, "files": [{"sha": "f6917c45d57e8a1d78639dfa863159d39834a1b6", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -2043,6 +2043,36 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0698: r##\"\n+When using generators (or async) all type variables must be bound so a\n+generator can be constructed.\n+\n+Erroneous code example:\n+\n+```edition2018,compile-fail,E0698\n+#![feature(futures_api, async_await, await_macro)]\n+async fn bar<T>() -> () {}\n+\n+async fn foo() {\n+  await!(bar());  // error: cannot infer type for `T`\n+}\n+```\n+\n+In the above example `T` is unknowable by the compiler.\n+To fix this you must bind `T` to a concrete type such as `String`\n+so that a generator can then be constructed:\n+\n+```edition2018\n+#![feature(futures_api, async_await, await_macro)]\n+async fn bar<T>() -> () {}\n+\n+async fn foo() {\n+  await!(bar::<String>());\n+  //          ^^^^^^^^ specify type explicitly\n+}\n+```\n+\"##,\n+\n E0700: r##\"\n The `impl Trait` return type captures lifetime parameters that do not\n appear within the `impl Trait` itself."}, {"sha": "2c01e1c0de3e515fd6748dd2a637182645b6d5d9", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -88,23 +88,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         s\n     }\n \n-    pub fn need_type_info_err(&self,\n-                            body_id: Option<hir::BodyId>,\n-                            span: Span,\n-                            ty: Ty<'tcx>)\n-                            -> DiagnosticBuilder<'gcx> {\n+    pub fn need_type_info_err(\n+        &self,\n+        body_id: Option<hir::BodyId>,\n+        span: Span,\n+        ty: Ty<'tcx>\n+    ) -> DiagnosticBuilder<'gcx> {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n-        let mut labels = vec![(\n-            span,\n-            if &name == \"_\" {\n-                \"cannot infer type\".to_owned()\n-            } else {\n-                format!(\"cannot infer type for `{}`\", name)\n-            },\n-        )];\n+        let mut labels = vec![(span, InferCtxt::missing_type_msg(&name))];\n \n         let mut local_visitor = FindLocalByTypeVisitor {\n             infcx: &self,\n@@ -166,4 +160,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         err\n     }\n+\n+    pub fn need_type_info_err_in_generator(\n+        &self,\n+        span: Span,\n+        ty: Ty<'tcx>\n+    ) -> DiagnosticBuilder<'gcx> {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let name = self.extract_type_name(&ty, None);\n+\n+        let mut err = struct_span_err!(self.tcx.sess,\n+                       span,\n+                       E0698,\n+                       \"type inside generator must be known in this context\");\n+        err.span_label(span, InferCtxt::missing_type_msg(&name));\n+        err\n+    }\n+\n+    fn missing_type_msg(type_name: &str) -> String {\n+        if type_name == \"_\" {\n+            \"cannot infer type\".to_owned()\n+        } else {\n+            format!(\"cannot infer type for `{}`\", type_name)\n+        }\n+    }\n }"}, {"sha": "f2ccffd9c92558bbd6d9ade2124cd61dd496955b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -1312,17 +1312,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns `true` if `T` contains unresolved type variables. In the\n+    /// Returns first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n     /// `resolve_type_vars_if_possible()`.\n-    pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n+    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::UnresolvedTypeFinder::new(self);\n-        value.visit_with(&mut r)\n+        value.visit_with(&mut r);\n+        r.first_unresolved\n     }\n \n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {"}, {"sha": "6adbf2bcef866931c2a1f65f41396030564029ed", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -1,4 +1,4 @@\n-use super::{InferCtxt, FixupError, FixupResult};\n+use super::{InferCtxt, FixupError, FixupResult, Span, type_variable::TypeVariableOrigin};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n@@ -77,40 +77,58 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n ///////////////////////////////////////////////////////////////////////////\n // UNRESOLVED TYPE FINDER\n \n-/// The unresolved type **finder** walks your type and searches for\n-/// type variables that don't yet have a value. They get pushed into a\n-/// vector. It does not construct the fully resolved type (which might\n+/// The unresolved type **finder** walks a type searching for\n+/// type variables that don't yet have a value. The first unresolved type is stored.\n+/// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n pub struct UnresolvedTypeFinder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+\n+    /// Used to find the type parameter name and location for error reporting.\n+    pub first_unresolved: Option<(Ty<'tcx>,Option<Span>)>,\n }\n \n impl<'a, 'gcx, 'tcx> UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        UnresolvedTypeFinder { infcx }\n+        UnresolvedTypeFinder { infcx, first_unresolved: None }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n-            if let ty::Infer(_) = t.sty {\n+            if let ty::Infer(infer_ty) = t.sty {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n-                true\n+                let ty_var_span =\n+                if let ty::TyVar(ty_vid) = infer_ty {\n+                    let ty_vars = self.infcx.type_variables.borrow();\n+                    if let TypeVariableOrigin::TypeParameterDefinition(span, _name)\n+                        = *ty_vars.var_origin(ty_vid)\n+                    {\n+                        Some(span)\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                };\n+                self.first_unresolved = Some((t, ty_var_span));\n+                true  // Halt visiting.\n             } else {\n                 // Otherwise, visit its contents.\n                 t.super_visit_with(self)\n             }\n         } else {\n-            // Micro-optimize: no inference types at all Can't have unresolved type\n-            // variables, no need to visit the contents.\n+            // All type variables in inference types must already be resolved,\n+            // - no need to visit the contents, continue visiting.\n             false\n         }\n     }\n }\n \n+\n ///////////////////////////////////////////////////////////////////////////\n // FULL TYPE RESOLUTION\n "}, {"sha": "882635e21f57c899aebf9e4045a148179378da89", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -594,7 +594,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n-            if !infcx.any_unresolved_type_vars(&ty.value) {\n+            if infcx.unresolved_type_vars(&ty.value).is_none() {\n                 infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n                 // No need to extend `obligations`.\n             } else {\n@@ -704,7 +704,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                                                  result: &NormalizedTy<'tcx>)\n                                                  -> NormalizedTy<'tcx> {\n-    if !infcx.any_unresolved_type_vars(&result.value) {\n+    if infcx.unresolved_type_vars(&result.value).is_none() {\n         return NormalizedTy { value: result.value, obligations: vec![] };\n     }\n \n@@ -722,7 +722,7 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n                   // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                   // ?0>`).\n                   ty::Predicate::Projection(ref data) =>\n-                      infcx.any_unresolved_type_vars(&data.ty()),\n+                      infcx.unresolved_type_vars(&data.ty()).is_some(),\n \n                   // We are only interested in `T: Foo<X = U>` predicates, whre\n                   // `U` references one of `unresolved_type_vars`. =)"}, {"sha": "0866c57616e07687f20e955ecbfb50c690f54cfe", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -54,12 +54,16 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                    expr, scope, ty, self.expr_count, yield_span);\n \n-            if self.fcx.any_unresolved_type_vars(&ty) {\n-                let mut err = struct_span_err!(self.fcx.tcx.sess, source_span, E0698,\n-                    \"type inside generator must be known in this context\");\n-                err.span_note(yield_span,\n-                              \"the type is part of the generator because of this `yield`\");\n-                err.emit();\n+            if let Some((unresolved_type, unresolved_type_span)) =\n+                self.fcx.unresolved_type_vars(&ty)\n+            {\n+                // If unresolved type isn't a ty_var then unresolved_type_span is None\n+                self.fcx.need_type_info_err_in_generator(\n+                    unresolved_type_span.unwrap_or(yield_span),\n+                    unresolved_type)\n+                    .span_note(yield_span,\n+                               \"the type is part of the generator because of this `yield`\")\n+                    .emit();\n             } else {\n                 // Map the type to the number of types added before it\n                 let entries = self.types.len();"}, {"sha": "0b435be7bfc8ad2010971e8c9a7a5e08d7a3a8dd", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -4728,7 +4728,6 @@ register_diagnostics! {\n     E0640, // infer outlives requirements\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n-    E0698, // type inside generator must be known in this context\n     E0719, // duplicate values for associated type binding\n     E0722, // Malformed #[optimize] attribute\n     E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions"}, {"sha": "f49369b125f6fa5dcd72bea3f8a099c54b2ff465", "filename": "src/test/ui/generator/unresolved_type_param.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.rs?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -0,0 +1,14 @@\n+// Provoke an unresolved type error (T).\n+// Error message should pinpoint the type parameter T as needing to be bound\n+// (rather than give a general error message)\n+// edition:2018\n+#![feature(futures_api, async_await, await_macro)]\n+async fn bar<T>() -> () {}\n+\n+async fn foo() {\n+        await!(bar());\n+        //~^ ERROR type inside generator must be known in this context\n+        //~| NOTE cannot infer type for `T`\n+        //~| NOTE the type is part of the generator because of this `yield`\n+}\n+fn main() {}"}, {"sha": "57ccdda3f43a19b07718ea56c31ec07c3642d8df", "filename": "src/test/ui/generator/unresolved_type_param.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66e41bc675e9e7c8fc649bc088b1d48857610fb2/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.stderr?ref=66e41bc675e9e7c8fc649bc088b1d48857610fb2", "patch": "@@ -0,0 +1,16 @@\n+error[E0698]: type inside generator must be known in this context\n+  --> $DIR/unresolved_type_param.rs:9:16\n+   |\n+LL |         await!(bar());\n+   |                ^^^ cannot infer type for `T`\n+   |\n+note: the type is part of the generator because of this `yield`\n+  --> $DIR/unresolved_type_param.rs:9:9\n+   |\n+LL |         await!(bar());\n+   |         ^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0698`."}]}