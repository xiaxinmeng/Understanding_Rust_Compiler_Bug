{"sha": "659f164167221ccd9a686dab4fe22bddca471606", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1OWYxNjQxNjcyMjFjY2Q5YTY4NmRhYjRmZTIyYmRkY2E0NzE2MDY=", "commit": {"author": {"name": "iancormac84", "email": "wilnathan@gmail.com", "date": "2018-05-08T13:23:36Z"}, "committer": {"name": "iancormac84", "email": "wilnathan@gmail.com", "date": "2018-05-17T20:41:27Z"}, "message": "Removed TypeIdHasher.", "tree": {"sha": "43b48975458efa41e967e498b6575abcd0d96fbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43b48975458efa41e967e498b6575abcd0d96fbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/659f164167221ccd9a686dab4fe22bddca471606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/659f164167221ccd9a686dab4fe22bddca471606", "html_url": "https://github.com/rust-lang/rust/commit/659f164167221ccd9a686dab4fe22bddca471606", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/659f164167221ccd9a686dab4fe22bddca471606/comments", "author": {"login": "iancormac84", "id": 7167225, "node_id": "MDQ6VXNlcjcxNjcyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7167225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iancormac84", "html_url": "https://github.com/iancormac84", "followers_url": "https://api.github.com/users/iancormac84/followers", "following_url": "https://api.github.com/users/iancormac84/following{/other_user}", "gists_url": "https://api.github.com/users/iancormac84/gists{/gist_id}", "starred_url": "https://api.github.com/users/iancormac84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iancormac84/subscriptions", "organizations_url": "https://api.github.com/users/iancormac84/orgs", "repos_url": "https://api.github.com/users/iancormac84/repos", "events_url": "https://api.github.com/users/iancormac84/events{/privacy}", "received_events_url": "https://api.github.com/users/iancormac84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iancormac84", "id": 7167225, "node_id": "MDQ6VXNlcjcxNjcyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7167225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iancormac84", "html_url": "https://github.com/iancormac84", "followers_url": "https://api.github.com/users/iancormac84/followers", "following_url": "https://api.github.com/users/iancormac84/following{/other_user}", "gists_url": "https://api.github.com/users/iancormac84/gists{/gist_id}", "starred_url": "https://api.github.com/users/iancormac84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iancormac84/subscriptions", "organizations_url": "https://api.github.com/users/iancormac84/orgs", "repos_url": "https://api.github.com/users/iancormac84/repos", "events_url": "https://api.github.com/users/iancormac84/events{/privacy}", "received_events_url": "https://api.github.com/users/iancormac84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a746d5c1dad836c615e879b443dbf7ed73123e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a746d5c1dad836c615e879b443dbf7ed73123e1", "html_url": "https://github.com/rust-lang/rust/commit/9a746d5c1dad836c615e879b443dbf7ed73123e1"}], "stats": {"total": 144, "additions": 0, "deletions": 144}, "files": [{"sha": "551825cc3545cf01bac8544f82b32c6c768b2133", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/659f164167221ccd9a686dab4fe22bddca471606/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659f164167221ccd9a686dab4fe22bddca471606/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=659f164167221ccd9a686dab4fe22bddca471606", "patch": "@@ -615,150 +615,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: StableHasher<W>,\n-}\n-\n-impl<'a, 'gcx, 'tcx, W> TypeIdHasher<'a, 'gcx, 'tcx, W>\n-    where W: StableHasherResult\n-{\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        TypeIdHasher { tcx: tcx, state: StableHasher::new() }\n-    }\n-\n-    pub fn finish(self) -> W {\n-        self.state.finish()\n-    }\n-\n-    pub fn hash<T: Hash>(&mut self, x: T) {\n-        x.hash(&mut self.state);\n-    }\n-\n-    fn hash_discriminant_u8<T>(&mut self, x: &T) {\n-        let v = unsafe {\n-            intrinsics::discriminant_value(x)\n-        };\n-        let b = v as u8;\n-        assert_eq!(v, b as u64);\n-        self.hash(b)\n-    }\n-\n-    fn def_id(&mut self, did: DefId) {\n-        // Hash the DefPath corresponding to the DefId, which is independent\n-        // of compiler internal state. We already have a stable hash value of\n-        // all DefPaths available via tcx.def_path_hash(), so we just feed that\n-        // into the hasher.\n-        let hash = self.tcx.def_path_hash(did);\n-        self.hash(hash);\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n-    where W: StableHasherResult\n-{\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        // Distinguish between the Ty variants uniformly.\n-        self.hash_discriminant_u8(&ty.sty);\n-\n-        match ty.sty {\n-            TyInt(i) => self.hash(i),\n-            TyUint(u) => self.hash(u),\n-            TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => {\n-                self.hash_discriminant_u8(&n.val);\n-                match n.val {\n-                    ConstVal::Value(alloc) => self.hash(alloc),\n-                    ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n-                }\n-            }\n-            TyRawPtr(m) => self.hash(m.mutbl),\n-            TyRef(_, _, mutbl) => self.hash(mutbl),\n-            TyClosure(def_id, _) |\n-            TyGenerator(def_id, _, _) |\n-            TyAnon(def_id, _) |\n-            TyFnDef(def_id, _) => self.def_id(def_id),\n-            TyAdt(d, _) => self.def_id(d.did),\n-            TyForeign(def_id) => self.def_id(def_id),\n-            TyFnPtr(f) => {\n-                self.hash(f.unsafety());\n-                self.hash(f.abi());\n-                self.hash(f.variadic());\n-                self.hash(f.inputs().skip_binder().len());\n-            }\n-            TyDynamic(ref data, ..) => {\n-                if let Some(p) = data.principal() {\n-                    self.def_id(p.def_id());\n-                }\n-                for d in data.auto_traits() {\n-                    self.def_id(d);\n-                }\n-            }\n-            TyGeneratorWitness(tys) => {\n-                self.hash(tys.skip_binder().len());\n-            }\n-            TyTuple(tys) => {\n-                self.hash(tys.len());\n-            }\n-            TyParam(p) => {\n-                self.hash(p.idx);\n-                self.hash(p.name);\n-            }\n-            TyProjection(ref data) => {\n-                self.def_id(data.item_def_id);\n-            }\n-            TyNever |\n-            TyBool |\n-            TyChar |\n-            TyStr |\n-            TySlice(_) => {}\n-\n-            TyError |\n-            TyInfer(_) => bug!(\"TypeIdHasher: unexpected type {}\", ty)\n-        }\n-\n-        ty.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        self.hash_discriminant_u8(r);\n-        match *r {\n-            ty::ReErased |\n-            ty::ReStatic |\n-            ty::ReEmpty => {\n-                // No variant fields to hash for these ...\n-            }\n-            ty::ReCanonical(c) => {\n-                self.hash(c);\n-            }\n-            ty::ReLateBound(db, ty::BrAnon(i)) => {\n-                self.hash(db.depth);\n-                self.hash(i);\n-            }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, .. }) => {\n-                self.def_id(def_id);\n-            }\n-\n-            ty::ReClosureBound(..) |\n-            ty::ReLateBound(..) |\n-            ty::ReFree(..) |\n-            ty::ReScope(..) |\n-            ty::ReVar(..) |\n-            ty::ReSkolemized(..) => {\n-                bug!(\"TypeIdHasher: unexpected region {:?}\", r)\n-            }\n-        }\n-        false\n-    }\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, x: &ty::Binder<T>) -> bool {\n-        // Anonymize late-bound regions so that, for example:\n-        // `for<'a, b> fn(&'a &'b T)` and `for<'a, b> fn(&'b &'a T)`\n-        // result in the same TypeId (the two types are equivalent).\n-        self.tcx.anonymize_late_bound_regions(x).super_visit_with(self)\n-    }\n-}\n-\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn moves_by_default(&'tcx self,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>,"}]}