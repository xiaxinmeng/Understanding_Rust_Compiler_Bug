{"sha": "b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NjUxOTZjZTBiYjBiNDg0MzM2ZjFmMmJhM2E2YTcyY2JmYjRmNzY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-29T19:58:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T19:58:32Z"}, "message": "Rollup merge of #72413 - CAD97:char-range, r=dtolnay\n\nimpl Step for char (make Range*<char> iterable)\n\n[[irlo thread]](https://internals.rust-lang.org/t/mini-rfc-make-range-char-work/12392?u=cad97) [[godbolt asm example]](https://rust.godbolt.org/z/fdveKo)\n\nAdd an implementation of the `Step` trait for `char`, which has the effect of making `RangeInclusive<char>` (and the other range types) iterable.\n\nI've used the surrogate range magic numbers as magic numbers here rather than e.g. a `const SURROGATE_RANGE = 0xD800..0xE000` because these numbers appear to be used as magic numbers elsewhere and there doesn't exist constants for them yet. These files definitely aren't where surrogate range constants should live.\n\n`ExactSizeIterator` is not implemented because `0x10FFFF` is bigger than fits in a `usize == u16`. However, given we already provide some `ExactSizeIterator` that are not correct on 16 bit targets, we might still want to consider providing it for `Range`[`Inclusive`]`<char>`, as it is definitely _very_ convenient. (At the very least, we want to make sure `.count()` doesn't bother iterating the range.)\n\nThe second commit in this PR changes a call to `Step::forward` to use `Step::forward_unchecked` in `RangeInclusive::next`. This is because without this patch, iteration over all codepoints (`'\\0'..=char::MAX`) does not successfully optimize out the panicking branch. This was mentioned in the PR that updated `Step` to its current design, but was deemed not yet necessary as it did not impact codegen for integral types.\n\nMore of `Range*`'s implementations' calls to `Step` methods will probably want to see if they can use the `_unchecked` version as (if) we open up `Step` to being implemented on more types.\n\n---\n\ncc @rust-lang/libs, this is insta-stable and a fairly significant addition to `Range*`'s capabilities; this is the first instance of a noncontinuous domain being iterable with `Range` (or, well, anything other than primitive integers). I don't think this needs a full RFC, but it should definitely get some decent eyes on it.", "tree": {"sha": "bb77385894d39b2154c8c6732e95c82d6f17900d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb77385894d39b2154c8c6732e95c82d6f17900d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0WloCRBK7hj4Ov3rIwAAdHIIAIY9pRQod0HBVjQzmDPoTDll\nFqCBymc/jL/iYxaWd3J2MVMr17MtiMj3IvnRIx07Le1B304/yEZR9NJnZONZic3W\nXJ0U64T3YA8Bp8956NKCb3fGwCa/xK0IX1Aa4PRqRsrRWfWWIAXjfDndIji800fq\nmcAW7MHUO8MHnCaJrS629qwPyZhRBEjG2mYLq551s8mdN3YSQSum3nz3bSy9aFko\npl29yTMlEO8HnPnGxF6x7U39J5HflAdFEBvkOgGt4UAY8nYagIu6Gni4fsXgiKHK\nJoUt9rNXw75jvLN8yfHIm+EFHP68xsBqdUDfT2ZDRh3knQqsdh21sK2tia3T8Fg=\n=5zIW\n-----END PGP SIGNATURE-----\n", "payload": "tree bb77385894d39b2154c8c6732e95c82d6f17900d\nparent de561a9d3d8d06969abc4f6851fd532f584ff52c\nparent cd6a8cae2aa07bd456a1816196e3c9aa2fcb72d6\nauthor Ralf Jung <post@ralfj.de> 1590782312 +0200\ncommitter GitHub <noreply@github.com> 1590782312 +0200\n\nRollup merge of #72413 - CAD97:char-range, r=dtolnay\n\nimpl Step for char (make Range*<char> iterable)\n\n[[irlo thread]](https://internals.rust-lang.org/t/mini-rfc-make-range-char-work/12392?u=cad97) [[godbolt asm example]](https://rust.godbolt.org/z/fdveKo)\n\nAdd an implementation of the `Step` trait for `char`, which has the effect of making `RangeInclusive<char>` (and the other range types) iterable.\n\nI've used the surrogate range magic numbers as magic numbers here rather than e.g. a `const SURROGATE_RANGE = 0xD800..0xE000` because these numbers appear to be used as magic numbers elsewhere and there doesn't exist constants for them yet. These files definitely aren't where surrogate range constants should live.\n\n`ExactSizeIterator` is not implemented because `0x10FFFF` is bigger than fits in a `usize == u16`. However, given we already provide some `ExactSizeIterator` that are not correct on 16 bit targets, we might still want to consider providing it for `Range`[`Inclusive`]`<char>`, as it is definitely _very_ convenient. (At the very least, we want to make sure `.count()` doesn't bother iterating the range.)\n\nThe second commit in this PR changes a call to `Step::forward` to use `Step::forward_unchecked` in `RangeInclusive::next`. This is because without this patch, iteration over all codepoints (`'\\0'..=char::MAX`) does not successfully optimize out the panicking branch. This was mentioned in the PR that updated `Step` to its current design, but was deemed not yet necessary as it did not impact codegen for integral types.\n\nMore of `Range*`'s implementations' calls to `Step` methods will probably want to see if they can use the `_unchecked` version as (if) we open up `Step` to being implemented on more types.\n\n---\n\ncc @rust-lang/libs, this is insta-stable and a fairly significant addition to `Range*`'s capabilities; this is the first instance of a noncontinuous domain being iterable with `Range` (or, well, anything other than primitive integers). I don't think this needs a full RFC, but it should definitely get some decent eyes on it.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "html_url": "https://github.com/rust-lang/rust/commit/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de561a9d3d8d06969abc4f6851fd532f584ff52c", "url": "https://api.github.com/repos/rust-lang/rust/commits/de561a9d3d8d06969abc4f6851fd532f584ff52c", "html_url": "https://github.com/rust-lang/rust/commit/de561a9d3d8d06969abc4f6851fd532f584ff52c"}, {"sha": "cd6a8cae2aa07bd456a1816196e3c9aa2fcb72d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6a8cae2aa07bd456a1816196e3c9aa2fcb72d6", "html_url": "https://github.com/rust-lang/rust/commit/cd6a8cae2aa07bd456a1816196e3c9aa2fcb72d6"}], "stats": {"total": 86, "additions": 85, "deletions": 1}, "files": [{"sha": "57e3e8084dd9f3c03b89729c459550cd8e86e390", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "patch": "@@ -1,3 +1,4 @@\n+use crate::char;\n use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Add, Sub, Try};\n@@ -400,6 +401,73 @@ step_integer_impls! {\n     wider than usize: [u32 i32], [u64 i64], [u128 i128];\n }\n \n+#[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+unsafe impl Step for char {\n+    #[inline]\n+    fn steps_between(&start: &char, &end: &char) -> Option<usize> {\n+        let start = start as u32;\n+        let end = end as u32;\n+        if start <= end {\n+            let count = end - start;\n+            if start < 0xD800 && 0xE000 <= end {\n+                usize::try_from(count - 0x800).ok()\n+            } else {\n+                usize::try_from(count).ok()\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn forward_checked(start: char, count: usize) -> Option<char> {\n+        let start = start as u32;\n+        let mut res = Step::forward_checked(start, count)?;\n+        if start < 0xD800 && 0xD800 <= res {\n+            res = Step::forward_checked(res, 0x800)?;\n+        }\n+        if res <= char::MAX as u32 {\n+            // SAFETY: res is a valid unicode scalar\n+            // (below 0x110000 and not in 0xD800..0xE000)\n+            Some(unsafe { char::from_u32_unchecked(res) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn backward_checked(start: char, count: usize) -> Option<char> {\n+        let start = start as u32;\n+        let mut res = Step::backward_checked(start, count)?;\n+        if start >= 0xE000 && 0xE000 > res {\n+            res = Step::backward_checked(res, 0x800)?;\n+        }\n+        // SAFETY: res is a valid unicode scalar\n+        // (below 0x110000 and not in 0xD800..0xE000)\n+        Some(unsafe { char::from_u32_unchecked(res) })\n+    }\n+\n+    #[inline]\n+    unsafe fn forward_unchecked(start: char, count: usize) -> char {\n+        let start = start as u32;\n+        let mut res = Step::forward_unchecked(start, count);\n+        if start < 0xD800 && 0xD800 <= res {\n+            res = Step::forward_unchecked(res, 0x800);\n+        }\n+        char::from_u32_unchecked(res)\n+    }\n+\n+    #[inline]\n+    unsafe fn backward_unchecked(start: char, count: usize) -> char {\n+        let start = start as u32;\n+        let mut res = Step::backward_unchecked(start, count);\n+        if start >= 0xE000 && 0xE000 > res {\n+            res = Step::backward_unchecked(res, 0x800);\n+        }\n+        char::from_u32_unchecked(res)\n+    }\n+}\n+\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -582,7 +650,11 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = Step::forward(self.start.clone(), 1);\n+            // SAFETY: just checked precondition\n+            // We use the unchecked version here, because\n+            // otherwise `for _ in '\\0'..=char::MAX`\n+            // does not successfully remove panicking code.\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n             mem::replace(&mut self.start, n)\n         } else {\n             self.exhausted = true;"}, {"sha": "c5d636ac8da55b7aea703421a0ecebfe7dd0208d", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "patch": "@@ -1932,6 +1932,18 @@ fn test_range() {\n     );\n }\n \n+#[test]\n+fn test_char_range() {\n+    use std::char;\n+    assert!(('\\0'..=char::MAX).eq((0..=char::MAX as u32).filter_map(char::from_u32)));\n+    assert!(('\\0'..=char::MAX).rev().eq((0..=char::MAX as u32).filter_map(char::from_u32).rev()));\n+\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').count(), 2);\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').size_hint(), (2, Some(2)));\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').count(), 1);\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').size_hint(), (1, Some(1)));\n+}\n+\n #[test]\n fn test_range_exhaustion() {\n     let mut r = 10..10;"}]}