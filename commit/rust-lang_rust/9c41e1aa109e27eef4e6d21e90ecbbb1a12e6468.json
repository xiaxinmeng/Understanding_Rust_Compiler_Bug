{"sha": "9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNDFlMWFhMTA5ZTI3ZWVmNGU2ZDIxZTkwZWNiYmIxYTEyZTY0Njg=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-22T15:48:32Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:34Z"}, "message": "Removed genericity over Value in various functions\nPrelude to using associated types in traits rather than type parameters", "tree": {"sha": "f80386a91a7d17ecf0dbb6298e1ab4d4ce69b6a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f80386a91a7d17ecf0dbb6298e1ab4d4ce69b6a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "html_url": "https://github.com/rust-lang/rust/commit/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ca750683ef1fc6db178c2fff8c0d0fb713690ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca750683ef1fc6db178c2fff8c0d0fb713690ab", "html_url": "https://github.com/rust-lang/rust/commit/1ca750683ef1fc6db178c2fff8c0d0fb713690ab"}], "stats": {"total": 359, "additions": 165, "deletions": 194}, "files": [{"sha": "f59fa2f1591a1e796c437030870a1ebbdbe4bd76", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -121,7 +121,7 @@ impl LlvmType for Reg {\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector::<Value>(Type::i8(cx), self.size.bytes())\n+                Type::vector(Type::i8(cx), self.size.bytes())\n             }\n         }\n     }\n@@ -145,7 +145,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return Type::array::<Value>(rest_ll_unit, rest_count);\n+                return Type::array(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -675,9 +675,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n \n         if self.variadic {\n-            Type::variadic_func::<Value>(&llargument_tys, llreturn_ty)\n+            Type::variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n-            Type::func::<Value>(&llargument_tys, llreturn_ty)\n+            Type::func(&llargument_tys, llreturn_ty)\n         }\n     }\n "}, {"sha": "f45b3728bc1b074aae9d7018d9f978656eb13b1d", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -127,7 +127,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n         .filter(|l| !l.is_empty())\n }\n \n-pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_, &'ll Value>, llfn: &'ll Value) {\n+pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let cpu = llvm_util::target_cpu(cx.tcx.sess);\n     let target_cpu = CString::new(cpu).unwrap();\n     llvm::AddFunctionAttrStringValue("}, {"sha": "8973852caa86b351d594d5ae1e730198ade33fe6", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -49,7 +49,6 @@ use context::{is_pie_binary, get_reloc_model};\n use common::{C_bytes_in_context, val_ty};\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n-use value::Value;\n \n use std::any::Any;\n use std::ffi::{CString, CStr};\n@@ -2575,7 +2574,7 @@ fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::M\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        let i8p_ty = Type::i8p_llcx::<Value>(llcx);\n+        let i8p_ty = Type::i8p_llcx(llcx);\n         let globals = base::iter_globals(llmod)\n             .filter(|&val| {\n                 llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&"}, {"sha": "31a19439c84c1ef76e044c5e087a1d1c1c1c94db", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -89,7 +89,7 @@ use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use rustc::hir::{self, CodegenFnAttrs};\n \n-use value::{Value, ValueTrait};\n+use value::Value;\n \n use mir::operand::OperandValue;\n \n@@ -391,11 +391,10 @@ pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n }\n \n pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll,\n-    Value : ?Sized,\n     Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n     bx: &Builder,\n     val: &'ll Value\n-) -> &'ll Value where Value : ValueTrait {\n+) -> &'ll Value {\n     if val_ty(val) == Type::i1(bx.cx()) {\n         bx.zext(val, Type::i8(bx.cx()))\n     } else {\n@@ -426,7 +425,6 @@ pub fn to_immediate_scalar(\n }\n \n pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll,\n-    Value : ?Sized,\n     Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n     bx: &Builder,\n     dst: &'ll Value,\n@@ -435,7 +433,7 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll,\n     src_align: Align,\n     n_bytes: &'ll Value,\n     flags: MemFlags,\n-) where Value : ValueTrait {\n+) {\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, src_align);\n@@ -452,7 +450,6 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll,\n }\n \n pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll,\n-    Value : ?Sized,\n     Builder: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>>(\n     bx: &Builder,\n     dst: &'ll Value,\n@@ -461,7 +458,7 @@ pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll,\n     src_align: Align,\n     layout: TyLayout<'tcx>,\n     flags: MemFlags,\n-) where Value : ValueTrait {\n+) {\n     let size = layout.size.bytes();\n     if size == 0 {\n         return;\n@@ -558,7 +555,7 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         use_start_lang_item: bool,\n     ) {\n         let llfty =\n-            Type::func::<Value>(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n+            Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,"}, {"sha": "583954cb8b0de7e29f1289585c22ba7131348a2d", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -200,7 +200,8 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n                args);\n \n         let args = self.check_call(\"invoke\", llfn, args);\n-        let bundle = bundle.map(|b| &*(OperandBundleDef::from_generic(b)).raw);\n+        let bundle = bundle.map(OperandBundleDef::from_generic);\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(self.llbuilder,\n@@ -757,7 +758,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = Type::func::<Value>(&argtys[..], output);\n+        let fty = Type::func(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n@@ -853,9 +854,9 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n     fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(Type::vector::<Value>(elt_ty, num_elts as u64));\n+            let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n-            let vec_i32_ty = Type::vector::<Value>(Type::i32(self.cx), num_elts as u64);\n+            let vec_i32_ty = Type::vector(Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n@@ -1232,7 +1233,8 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n                args);\n \n         let args = self.check_call(\"call\", llfn, args);\n-        let bundle = bundle.map(|b| &*(OperandBundleDef::from_generic(b)).raw);\n+        let bundle = bundle.map(OperandBundleDef::from_generic);\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n         unsafe {\n             llvm::LLVMRustBuildCall(\n@@ -1260,7 +1262,7 @@ impl BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n         }\n     }\n \n-    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx, &'ll Value> {\n+    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx> {\n         &self.cx\n     }\n }"}, {"sha": "9611c0e54b9810d0484fe173f280bd75bd623d49", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -23,7 +23,7 @@ use consts;\n use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use value::{Value, ValueTrait};\n+use value::Value;\n \n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n@@ -111,9 +111,9 @@ impl Funclet<'ll> {\n     }\n }\n \n-pub fn val_ty<Value : ?Sized>(v: &'ll Value) -> &'ll Type where Value : ValueTrait {\n+pub fn val_ty(v: &'ll Value) -> &'ll Type {\n     unsafe {\n-        llvm::LLVMTypeOf(v.to_llvm())\n+        llvm::LLVMTypeOf(v)\n     }\n }\n \n@@ -124,21 +124,21 @@ pub fn C_null(t: &'ll Type) -> &'ll Value {\n     }\n }\n \n-pub fn C_undef<Value : ?Sized>(t: &'ll Type) -> &'ll Value where Value : ValueTrait {\n+pub fn C_undef(t: &'ll Type) -> &'ll Value {\n     unsafe {\n-        Value::of_llvm(llvm::LLVMGetUndef(t))\n+        llvm::LLVMGetUndef(t)\n     }\n }\n \n-pub fn C_int<Value : ?Sized>(t: &'ll Type, i: i64) -> &'ll Value where Value : ValueTrait {\n+pub fn C_int(t: &'ll Type, i: i64) -> &'ll Value {\n     unsafe {\n-        Value::of_llvm(llvm::LLVMConstInt(t, i as u64, True))\n+        llvm::LLVMConstInt(t, i as u64, True)\n     }\n }\n \n-pub fn C_uint<Value : ?Sized>(t: &'ll Type, i: u64) -> &'ll Value where Value : ValueTrait {\n+pub fn C_uint(t: &'ll Type, i: u64) -> &'ll Value {\n     unsafe {\n-        Value::of_llvm(llvm::LLVMConstInt(t, i, False))\n+        llvm::LLVMConstInt(t, i, False)\n     }\n }\n \n@@ -149,17 +149,11 @@ pub fn C_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n     }\n }\n \n-pub fn C_bool<Value : ?Sized>(\n-    cx: &CodegenCx<'ll, '_, &'ll Value>,\n-    val: bool\n-) -> &'ll Value where Value : ValueTrait {\n+pub fn C_bool(cx: &CodegenCx<'ll, '_>, val: bool) -> &'ll Value {\n     C_uint(Type::i1(cx), val as u64)\n }\n \n-pub fn C_i32<Value : ?Sized>(\n-    cx: &CodegenCx<'ll, '_, &'ll Value>,\n-    i: i32\n-) -> &'ll Value where Value : ValueTrait {\n+pub fn C_i32(cx: &CodegenCx<'ll, '_>, i: i32) -> &'ll Value {\n     C_int(Type::i32(cx), i as i64)\n }\n \n@@ -171,10 +165,7 @@ pub fn C_u64(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     C_uint(Type::i64(cx), i)\n }\n \n-pub fn C_usize<Value : ?Sized>(\n-    cx: &CodegenCx<'ll, '_, &'ll Value>,\n-    i: u64\n-) -> &'ll Value where Value : ValueTrait {\n+pub fn C_usize(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n     let bit_size = cx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow"}, {"sha": "a3c88d35a81ef9dc7f484328a32f4c88055b5b71", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -18,7 +18,7 @@ use callee;\n use base;\n use declare;\n use monomorphize::Instance;\n-use value::{Value, ValueTrait};\n+use value::Value;\n \n use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n             None\n         };\n \n-        let isize_ty = Type::ix_llcx::<Value>(llcx, tcx.data_layout.pointer_size.bits());\n+        let isize_ty = Type::ix_llcx(llcx, tcx.data_layout.pointer_size.bits());\n \n         CodegenCx {\n             tcx,\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx, Value : ?Sized> CodegenCx<'b, 'tcx, &'b Value> where Value : ValueTrait {\n+impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.tcx.sess\n     }\n@@ -329,7 +329,7 @@ impl<'b, 'tcx, Value : ?Sized> CodegenCx<'b, 'tcx, &'b Value> where Value : Valu\n     }\n }\n \n-impl<'b, 'tcx> CodegenCx<'b, 'tcx, &'b Value> {\n+impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n@@ -379,7 +379,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx, &'b Value> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = Type::variadic_func::<Value>(&[], Type::i32(self));\n+                let fty = Type::variadic_func(&[], Type::i32(self));\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n@@ -480,31 +480,31 @@ impl LayoutOf for CodegenCx<'ll, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic<Value : ?Sized>(\n-    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+fn declare_intrinsic(\n+    cx: &CodegenCx<'ll, '_>,\n     key: &str\n-) -> Option<&'ll Value> where Value : ValueTrait {\n+) -> Option<&'ll Value> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func::<Value>(&[], $ret));\n-                llvm::SetUnnamedAddr(f.to_llvm(), false);\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[], $ret));\n+                llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::variadic_func::<Value>(&[], $ret));\n-                llvm::SetUnnamedAddr(f.to_llvm(), false);\n+                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], $ret));\n+                llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func::<Value>(&[$($arg),*], $ret));\n-                llvm::SetUnnamedAddr(f.to_llvm(), false);\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], $ret));\n+                llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -525,14 +525,14 @@ fn declare_intrinsic<Value : ?Sized>(\n     let t_f32 = Type::f32(cx);\n     let t_f64 = Type::f64(cx);\n \n-    let t_v2f32 = Type::vector::<Value>(t_f32, 2);\n-    let t_v4f32 = Type::vector::<Value>(t_f32, 4);\n-    let t_v8f32 = Type::vector::<Value>(t_f32, 8);\n-    let t_v16f32 = Type::vector::<Value>(t_f32, 16);\n+    let t_v2f32 = Type::vector(t_f32, 2);\n+    let t_v4f32 = Type::vector(t_f32, 4);\n+    let t_v8f32 = Type::vector(t_f32, 8);\n+    let t_v16f32 = Type::vector(t_f32, 16);\n \n-    let t_v2f64 = Type::vector::<Value>(t_f64, 2);\n-    let t_v4f64 = Type::vector::<Value>(t_f64, 4);\n-    let t_v8f64 = Type::vector::<Value>(t_f64, 8);\n+    let t_v2f64 = Type::vector(t_f64, 2);\n+    let t_v4f64 = Type::vector(t_f64, 4);\n+    let t_v8f64 = Type::vector(t_f64, 8);\n \n     ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);"}, {"sha": "02d3b66c613892d51f9fb7b3899dabb1b0dd40d8", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -56,7 +56,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array::<Value>(Type::i8(cx),\n+            let llvm_type = Type::array(Type::i8(cx),\n                                         section_contents.len() as u64);\n \n             let section_var = declare::define_global(cx, section_var_name,"}, {"sha": "973a322fcb1e8309c1db22ea3f020a538b0da612", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -31,7 +31,7 @@ use abi::{Abi, FnType, FnTypeExt};\n use attributes;\n use context::CodegenCx;\n use type_::Type;\n-use value::{Value, ValueTrait};\n+use value::Value;\n \n \n /// Declare a global value.\n@@ -51,12 +51,12 @@ pub fn declare_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> &'l\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing Value instead.\n-fn declare_raw_fn<Value : ?Sized>(\n-    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+fn declare_raw_fn(\n+    cx: &CodegenCx<'ll, '_>,\n     name: &str,\n     callconv: llvm::CallConv,\n     ty: &'ll Type,\n-) -> &'ll Value where Value : ValueTrait {\n+) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = SmallCStr::new(name);\n     let llfn = unsafe {\n@@ -105,7 +105,7 @@ fn declare_raw_fn<Value : ?Sized>(\n \n     attributes::non_lazy_bind(cx.sess(), llfn);\n \n-    Value::of_llvm(llfn)\n+    llfn\n }\n \n \n@@ -116,11 +116,11 @@ fn declare_raw_fn<Value : ?Sized>(\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing Value instead.\n-pub fn declare_cfn<Value : ?Sized>(\n-    cx: &CodegenCx<'ll, '_, &'ll Value>,\n+pub fn declare_cfn(\n+    cx: &CodegenCx<'ll, '_>,\n     name: &str,\n     fn_type: &'ll Type\n-) -> &'ll Value where Value : ValueTrait {\n+) -> &'ll Value {\n     declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n@@ -172,7 +172,7 @@ pub fn define_global(cx: &CodegenCx<'ll, '_>, name: &str, ty: &'ll Type) -> Opti\n /// Declare a private global\n ///\n /// Use this function when you intend to define a global without a name.\n-pub fn define_private_global(cx: &CodegenCx<'ll, '_, &'ll Value>, ty: &'ll Type) -> &'ll Value {\n+pub fn define_private_global(cx: &CodegenCx<'ll, '_>, ty: &'ll Type) -> &'ll Value {\n     unsafe {\n         llvm::LLVMRustInsertPrivateGlobal(cx.llmod, ty)\n     }"}, {"sha": "4eb810cf2c00c1e47c3876d90f67fb240b4829f2", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -593,7 +593,7 @@ pub fn codegen_intrinsic_call(\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![Type::vector::<Value>(elem, length as u64)]\n+                        vec![Type::vector(elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n@@ -644,7 +644,7 @@ pub fn codegen_intrinsic_call(\n                         let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n                         vec![\n                             bx.bitcast(arg.immediate(),\n-                            Type::vector::<Value>(llvm_elem, length as u64))\n+                            Type::vector(llvm_elem, length as u64))\n                         ]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n@@ -673,7 +673,7 @@ pub fn codegen_intrinsic_call(\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(cx,\n                                                  name,\n-                                                 Type::func::<Value>(&inputs, outputs));\n+                                                 Type::func(&inputs, outputs));\n                     bx.call(f, &llargs, None)\n                 }\n             };\n@@ -1160,7 +1160,7 @@ fn generic_simd_intrinsic(\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector::<Value>(i1, m_len as u64);\n+        let i1xn = Type::vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1301,7 +1301,7 @@ fn generic_simd_intrinsic(\n             elem_ty = elem_ty.ptr_to();\n             no_pointers -= 1;\n         }\n-        Type::vector::<Value>(elem_ty, vec_len as u64)\n+        Type::vector(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1384,7 +1384,7 @@ fn generic_simd_intrinsic(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector::<Value>(i1, in_len as u64);\n+            let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1399,7 +1399,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n-                                     Type::func::<Value>(&[\n+                                     Type::func(&[\n                                          llvm_pointer_vec_ty,\n                                          alignment_ty,\n                                          mask_ty,\n@@ -1484,7 +1484,7 @@ fn generic_simd_intrinsic(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector::<Value>(i1, in_len as u64);\n+            let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1501,7 +1501,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n-                                     Type::func::<Value>(&[llvm_elem_vec_ty,\n+                                     Type::func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n                                                   mask_ty], ret_t));\n@@ -1636,7 +1636,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n                     // boolean reductions operate on vectors of i1s:\n                     let i1 = Type::i1(bx.cx);\n-                    let i1xn = Type::vector::<Value>(i1, in_len as u64);\n+                    let i1xn = Type::vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {"}, {"sha": "e3dbbda3aa48687e4aa20f143ac512fbe3744677", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> VirtualIndex {\n \n     pub fn get_usize(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         llvtable: &'ll Value\n     ) -> &'ll Value {\n         // Load the data pointer from the object."}, {"sha": "61f8c453a6f76dcb991655e7ad739858259d15ea", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -101,7 +101,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         };\n \n         let funclet_br =\n-            |this: &mut Self, bx: Builder<'_, 'll, '_, &'ll Value>, target: mir::BasicBlock| {\n+            |this: &mut Self, bx: Builder<'_, 'll, '_>, target: mir::BasicBlock| {\n                 let (lltarget, is_cleanupret) = lltarget(this, target);\n                 if is_cleanupret {\n                     // micro-optimization: generate a `ret` rather than a jump\n@@ -848,7 +848,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     fn get_personality_slot(\n         &mut self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>\n+        bx: &Builder<'a, 'll, 'tcx>\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {"}, {"sha": "b844b6e14581794a920410dcdb395dc2afac9c10", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -122,7 +122,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     pub fn set_debug_loc(\n         &mut self,\n-        bx: &Builder<'_, 'll, '_, &'ll Value>,\n+        bx: &Builder<'_, 'll, '_>,\n         source_info: mir::SourceInfo\n     ) {\n         let (scope, span) = self.debug_loc(source_info);"}, {"sha": "2b4a9b400dced9cc719a8b2b48f2e3a0301e8fd6", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use base;\n use common::{CodegenCx, C_undef, C_usize};\n use builder::{Builder, MemFlags};\n-use value::{Value, ValueTrait};\n+use value::Value;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use glue;\n@@ -63,7 +63,7 @@ pub struct OperandRef<'tcx, V> {\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<Value: ?Sized> fmt::Debug for OperandRef<'tcx, &'ll Value> where Value: ValueTrait {\n+impl fmt::Debug for OperandRef<'tcx, &'ll Value> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n@@ -265,7 +265,7 @@ impl OperandValue<&'ll Value> {\n \n     pub fn volatile_store(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         dest: PlaceRef<'tcx, &'ll Value>\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n@@ -280,14 +280,12 @@ impl OperandValue<&'ll Value> {\n     }\n }\n \n-impl<'a, 'll: 'a, 'tcx: 'll, Value : ?Sized> OperandValue<&'ll Value> where\n-    Value : ValueTrait,\n-    Builder<'a, 'll, 'tcx, &'ll Value>:\n-        BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n+impl<'a, 'll: 'a, 'tcx: 'll> OperandValue<&'ll Value> where\n+    Builder<'a, 'll, 'tcx>: BuilderMethods<'a, 'll, 'tcx, Value, BasicBlock>\n {\n     pub fn nontemporal_store(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         dest: PlaceRef<'tcx, &'ll Value>\n     ) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n@@ -331,7 +329,7 @@ impl<'a, 'll: 'a, 'tcx: 'll, Value : ?Sized> OperandValue<&'ll Value> where\n impl OperandValue<&'ll Value> {\n     pub fn store_unsized(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         indirect_dest: PlaceRef<'tcx, &'ll Value>\n     ) {\n         debug!(\"OperandRef::store_unsized: operand={:?}, indirect_dest={:?}\", self, indirect_dest);"}, {"sha": "25d24486d6328a16fd2fa042fa14b6ece39275db", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -284,7 +284,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n     /// Obtain the actual discriminant of a value.\n     pub fn codegen_get_discr(\n         self,\n-        bx: &Builder<'a, 'll, 'tcx, &'ll Value>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         cast_to: Ty<'tcx>\n     ) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);"}, {"sha": "25af25b8ed67da55f7e05b32da8b5073d3edfe56", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -180,10 +180,10 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n     }\n \n     pub fn codegen_rvalue_unsized(&mut self,\n-                        bx: Builder<'a, 'll, 'tcx, &'ll Value>,\n+                        bx: Builder<'a, 'll, 'tcx>,\n                         indirect_dest: PlaceRef<'tcx, &'ll Value>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> Builder<'a, 'll, 'tcx, &'ll Value>\n+                        -> Builder<'a, 'll, 'tcx>\n     {\n         debug!(\"codegen_rvalue_unsized(indirect_dest.llval={:?}, rvalue={:?})\",\n                indirect_dest.llval, rvalue);\n@@ -201,9 +201,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     pub fn codegen_rvalue_operand(\n         &mut self,\n-        bx: Builder<'a, 'll, 'tcx, &'ll Value>,\n+        bx: Builder<'a, 'll, 'tcx>,\n         rvalue: &mir::Rvalue<'tcx>\n-    ) -> (Builder<'a, 'll, 'tcx, &'ll Value>, OperandRef<'tcx, &'ll Value>) {\n+    ) -> (Builder<'a, 'll, 'tcx>, OperandRef<'tcx, &'ll Value>) {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n         match *rvalue {\n@@ -753,7 +753,7 @@ enum OverflowOp {\n \n fn get_overflow_intrinsic(\n     oop: OverflowOp,\n-    bx: &Builder<'_, 'll, '_, &'ll Value>,\n+    bx: &Builder<'_, 'll, '_>,\n     ty: Ty\n ) -> &'ll Value {\n     use syntax::ast::IntTy::*;"}, {"sha": "946d054155728632dc6083fea8fa2c062a4682f4", "filename": "src/librustc_codegen_llvm/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftraits.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -109,14 +109,14 @@ pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll,\n     > {\n \n     fn new_block<'b>(\n-        cx: &'a CodegenCx<'ll, 'tcx, &'ll Value>,\n+        cx: &'a CodegenCx<'ll, 'tcx>,\n         llfn: &'ll Value,\n         name: &'b str\n     ) -> Self;\n-    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx, &'ll Value>) -> Self;\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self;\n     fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n     fn sess(&self) -> &Session;\n-    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx, &'ll Value>;\n+    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx>;\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n     fn llfn(&self) -> &'ll Value;\n     fn llbb(&self) -> &'ll BasicBlock;"}, {"sha": "07a537a343a9996dbe1080e99a7c42b0b0f9c7c6", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 71, "deletions": 72, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -16,7 +16,6 @@ use llvm;\n use llvm::{Bool, False, True, TypeKind};\n \n use context::CodegenCx;\n-use value::{Value, ValueTrait};\n \n use syntax::ast;\n use rustc::ty::layout::{self, Align, Size};\n@@ -41,143 +40,143 @@ impl fmt::Debug for Type {\n }\n \n impl Type {\n-    pub fn void<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn void(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVoidTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn metadata<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn metadata(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustMetadataTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i1<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn i1(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt1TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i8<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn i8(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt8TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i8_llcx<Value : ?Sized>(llcx: &llvm::Context) -> &Type where Value : ValueTrait {\n+    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n         unsafe {\n             llvm::LLVMInt8TypeInContext(llcx)\n         }\n     }\n \n-    pub fn i16<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>) -> &'ll Type where Value : ValueTrait {\n+    pub fn i16(\n+        cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         unsafe {\n \n             llvm::LLVMInt16TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i32<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn i32(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt32TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i64<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn i64(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt64TypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn i128<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn i128(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMIntTypeInContext(cx.llcx, 128)\n         }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    pub fn ix(\n+        cx: &CodegenCx<'ll, '_>,\n         num_bits: u64\n-    ) -> &'ll Type where Value : ValueTrait {\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint)\n         }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix_llcx<Value : ?Sized>(\n+    pub fn ix_llcx(\n         llcx: &llvm::Context,\n         num_bits: u64\n-    ) -> &Type where Value : ValueTrait {\n+    ) -> &Type {\n         unsafe {\n             llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n         }\n     }\n \n-    pub fn f32<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn f32(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFloatTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn f64<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn f64(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMDoubleTypeInContext(cx.llcx)\n         }\n     }\n \n-    pub fn bool<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn bool(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         Type::i8(cx)\n     }\n \n-    pub fn char<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn char(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         Type::i32(cx)\n     }\n \n-    pub fn i8p<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait {\n+    pub fn i8p(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         Type::i8(cx).ptr_to()\n     }\n \n-    pub fn i8p_llcx<Value : ?Sized>(llcx: &llvm::Context) -> &Type where Value : ValueTrait  {\n-        Type::i8_llcx::<Value>(llcx).ptr_to()\n+    pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n+        Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn isize<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    pub fn isize(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         cx.isize_ty\n     }\n \n-    pub fn c_int<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    pub fn c_int(\n+        cx: &CodegenCx<'ll, '_>\n+    ) -> &'ll Type {\n         match &cx.tcx.sess.target.target.target_c_int_width[..] {\n             \"16\" => Type::i16(cx),\n             \"32\" => Type::i32(cx),\n@@ -186,10 +185,10 @@ impl Type {\n         }\n     }\n \n-    pub fn int_from_ty<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    pub fn int_from_ty(\n+        cx: &CodegenCx<'ll, '_>,\n         t: ast::IntTy\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    ) -> &'ll Type {\n         match t {\n             ast::IntTy::Isize => cx.isize_ty,\n             ast::IntTy::I8 => Type::i8(cx),\n@@ -200,10 +199,10 @@ impl Type {\n         }\n     }\n \n-    pub fn uint_from_ty<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    pub fn uint_from_ty(\n+        cx: &CodegenCx<'ll, '_>,\n         t: ast::UintTy\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    ) -> &'ll Type {\n         match t {\n             ast::UintTy::Usize => cx.isize_ty,\n             ast::UintTy::U8 => Type::i8(cx),\n@@ -214,41 +213,41 @@ impl Type {\n         }\n     }\n \n-    pub fn float_from_ty<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    pub fn float_from_ty(\n+        cx: &CodegenCx<'ll, '_>,\n         t: ast::FloatTy\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    ) -> &'ll Type {\n         match t {\n             ast::FloatTy::F32 => Type::f32(cx),\n             ast::FloatTy::F64 => Type::f64(cx),\n         }\n     }\n \n-    pub fn func<Value : ?Sized>(\n+    pub fn func(\n         args: &[&'ll Type],\n         ret: &'ll Type\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFunctionType(ret, args.as_ptr(),\n                                    args.len() as c_uint, False)\n         }\n     }\n \n-    pub fn variadic_func<Value : ?Sized>(\n+    pub fn variadic_func(\n         args: &[&'ll Type],\n         ret: &'ll Type\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFunctionType(ret, args.as_ptr(),\n                                    args.len() as c_uint, True)\n         }\n     }\n \n-    pub fn struct_<Value : ?Sized>(\n-        cx: &CodegenCx<'ll, '_, &'ll Value>,\n+    pub fn struct_(\n+        cx: &CodegenCx<'ll, '_>,\n         els: &[&'ll Type],\n         packed: bool\n-    ) -> &'ll Type where Value : ValueTrait  {\n+    ) -> &'ll Type {\n         unsafe {\n             llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n@@ -264,13 +263,13 @@ impl Type {\n     }\n \n \n-    pub fn array<Value : ?Sized>(ty: &Type, len: u64) -> &Type where Value : ValueTrait  {\n+    pub fn array(ty: &Type, len: u64) -> &Type {\n         unsafe {\n             llvm::LLVMRustArrayType(ty, len)\n         }\n     }\n \n-    pub fn vector<Value : ?Sized>(ty: &Type, len: u64) -> &Type where Value : ValueTrait  {\n+    pub fn vector(ty: &Type, len: u64) -> &Type {\n         unsafe {\n             llvm::LLVMVectorType(ty, len as c_uint)\n         }\n@@ -363,7 +362,7 @@ impl Type {\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array::<Value>(Type::from_integer(cx, unit), size / unit_size)\n+        Type::array(Type::from_integer(cx, unit), size / unit_size)\n     }\n \n     pub fn x86_mmx(cx: &CodegenCx<'ll, '_>) -> &'ll Type {"}, {"sha": "fea02edf7be01b70748d68f73f53285515b6e5d2", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -16,7 +16,6 @@ use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use type_::Type;\n-use value::Value;\n \n use std::fmt::Write;\n \n@@ -41,7 +40,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 return Type::x86_mmx(cx)\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return Type::vector::<Value>(element, count);\n+                return Type::vector(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n@@ -94,7 +93,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array::<Value>(layout.field(cx, 0).llvm_type(cx), count)\n+            Type::array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {"}, {"sha": "4bf5b09baa6294ffbfd022bdb4bc8e5646f3cdfa", "filename": "src/librustc_codegen_llvm/value.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=9c41e1aa109e27eef4e6d21e90ecbbb1a12e6468", "patch": "@@ -15,26 +15,12 @@ use llvm;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n-pub trait ValueTrait: fmt::Debug {\n-    fn to_llvm(&self) -> &llvm::Value;\n-    fn of_llvm(&llvm::Value) -> &Self;\n-}\n-\n impl PartialEq for Value {\n     fn eq(&self, other: &Self) -> bool {\n         self as *const _ == other as *const _\n     }\n }\n \n-impl ValueTrait for Value {\n-    fn to_llvm(&self) -> &llvm::Value {\n-        &self\n-    }\n-    fn of_llvm(v: &llvm::Value) -> &Self {\n-        &v\n-    }\n-}\n-\n impl Eq for Value {}\n \n impl Hash for Value {"}]}