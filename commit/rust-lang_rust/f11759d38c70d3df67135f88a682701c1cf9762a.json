{"sha": "f11759d38c70d3df67135f88a682701c1cf9762a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTc1OWQzOGM3MGQzZGY2NzEzNWY4OGE2ODI3MDFjMWNmOTc2MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-21T21:01:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-21T21:01:14Z"}, "message": "Auto merge of #66610 - alexreg:trait-upcasting-cosmetic, r=Centril\n\nAggregation of drive-by cosmetic changes for trait-upcasting PR\n\nCherry-picked from #60900.\n\nAs requested by @Centril (and @nikomatsakis, I believe).\n\nr? @Centril", "tree": {"sha": "cd5d0c21d0f0a5205f2d037ddb14d2a46faad206", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd5d0c21d0f0a5205f2d037ddb14d2a46faad206"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f11759d38c70d3df67135f88a682701c1cf9762a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f11759d38c70d3df67135f88a682701c1cf9762a", "html_url": "https://github.com/rust-lang/rust/commit/f11759d38c70d3df67135f88a682701c1cf9762a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f11759d38c70d3df67135f88a682701c1cf9762a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53712f8637dbe326df569a90814aae1cc5429710", "url": "https://api.github.com/repos/rust-lang/rust/commits/53712f8637dbe326df569a90814aae1cc5429710", "html_url": "https://github.com/rust-lang/rust/commit/53712f8637dbe326df569a90814aae1cc5429710"}, {"sha": "1b2de17647c46dddf590bd6735344641af4f7de4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b2de17647c46dddf590bd6735344641af4f7de4", "html_url": "https://github.com/rust-lang/rust/commit/1b2de17647c46dddf590bd6735344641af4f7de4"}], "stats": {"total": 1284, "additions": 646, "deletions": 638}, "files": [{"sha": "a2c4bdc5633d868ece42f3356957ecc15ddeb3b8", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1919,8 +1919,9 @@ pub enum ImplItemKind {\n /// Bindings like `A: Debug` are represented as a special type `A =\n /// $::Debug` that is understood by the astconv code.\n ///\n-/// FIXME(alexreg) -- why have a separate type for the binding case,\n-/// wouldn't it be better to make the `ty` field an enum like:\n+/// FIXME(alexreg): why have a separate type for the binding case,\n+/// wouldn't it be better to make the `ty` field an enum like the\n+/// following?\n ///\n /// ```\n /// enum TypeBindingKind {"}, {"sha": "1fa814dc14efb52702a778007b3f6305946f5862", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -306,7 +306,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         match *r {\n             ty::ReLateBound(index, ..) => {\n                 if index >= self.binder_index {\n-                    bug!(\"escaping late bound region during canonicalization\")\n+                    bug!(\"escaping late-bound region during canonicalization\");\n                 } else {\n                     r\n                 }\n@@ -336,7 +336,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 .canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) => {\n-                bug!(\"closure bound region encountered during canonicalization\")\n+                bug!(\"closure bound region encountered during canonicalization\");\n             }\n         }\n     }\n@@ -346,14 +346,14 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::Infer(ty::TyVar(vid)) => {\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.unwrap().probe_ty_var(vid) {\n-                    // `t` could be a float / int variable: canonicalize that instead\n+                    // `t` could be a float / int variable; canonicalize that instead.\n                     Ok(t) => {\n                         debug!(\"(resolved to {:?})\", t);\n                         self.fold_ty(t)\n                     }\n \n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n-                    // result\n+                    // result.\n                     Err(mut ui) => {\n                         if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n                             // FIXME: perf problem described in #55921."}, {"sha": "0f93ef6b1a9e457a4c6b2f3679f0dfe7d286d7de", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -48,22 +48,24 @@\n use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n-use crate::infer::{self, SuppressRegionErrors};\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::Node;\n+use crate::infer::{self, SuppressRegionErrors};\n use crate::infer::opaque_types;\n use crate::middle::region;\n-use crate::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n-use crate::traits::{ObligationCauseCode};\n+use crate::traits::{\n+    IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+};\n use crate::ty::error::TypeError;\n use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TypeFoldable};\n+\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n-use std::{cmp, fmt};\n+use rustc_error_codes::*;\n use syntax_pos::{Pos, Span};\n \n-use rustc_error_codes::*;\n+use std::{cmp, fmt};\n \n mod note;\n \n@@ -1270,7 +1272,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n-    /// suggest it.\n+    /// suggests it.\n     fn suggest_as_ref_where_appropriate(\n         &self,\n         span: Span,"}, {"sha": "f9443376a935ac6bef69f64c604c18802f790ced", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -221,7 +221,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n }\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n-/// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n+/// obligation into a series of `'a: 'b` constraints and \"verify\"s, as\n /// described on the module comment. The final constraints are emitted\n /// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n /// accrues them into the `region_obligations` code, but for NLL we"}, {"sha": "78320c769f680f388550b61cd11ce0730b58e113", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,11 +1,12 @@\n-use std::fmt::{self, Display};\n-use std::convert::TryFrom;\n+use super::{AllocId, InterpResult};\n \n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n+\n use rustc_macros::HashStable;\n \n-use super::{AllocId, InterpResult};\n+use std::convert::TryFrom;\n+use std::fmt::{self, Display};\n \n /// Used by `check_in_alloc` to indicate context of check\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n@@ -74,8 +75,8 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n-            // Trickery to ensure that i64::min_value() works fine: compute n = -i.\n-            // This formula only works for true negative values, it overflows for zero!\n+            // Trickery to ensure that `i64::min_value()` works fine: compute `n = -i`.\n+            // This formula only works for true negative values; it overflows for zero!\n             let n = u64::max_value() - (i as u64) + 1;\n             let res = val.overflowing_sub(n);\n             self.truncate_to_ptr(res)\n@@ -105,7 +106,7 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n ///\n /// Defaults to the index based and loosely coupled `AllocId`.\n ///\n-/// Pointer is also generic over the `Tag` associated with each pointer,\n+/// `Pointer` is also generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n@@ -129,7 +130,7 @@ impl<Id: fmt::Debug> fmt::Debug for Pointer<(), Id> {\n     }\n }\n \n-/// Produces a `Pointer` which points to the beginning of the `Allocation`.\n+/// Produces a `Pointer` that points to the beginning of the `Allocation`.\n impl From<AllocId> for Pointer {\n     #[inline(always)]\n     fn from(alloc_id: AllocId) -> Self {"}, {"sha": "50752bac30f570e5ec1d53b7902b04a24f320964", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1203,7 +1203,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"force use of the frame pointers\"),\n     debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"explicitly enable the cfg(debug_assertions) directive\"),\n+        \"explicitly enable the `cfg(debug_assertions)` directive\"),\n     inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"set the threshold for inlining a function (default: 225)\"),\n     panic: Option<PanicStrategy> = (None, parse_panic_strategy,"}, {"sha": "479bffc3ea00d6f0a802e7279abdbe105e8b6804", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 86, "deletions": 84, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,18 +1,18 @@\n-//! Support code for rustdoc and external tools . You really don't\n-//! want to be using this unless you need to.\n+//! Support code for rustdoc and external tools.\n+//! You really don't want to be using this unless you need to.\n \n use super::*;\n \n-use std::collections::hash_map::Entry;\n-use std::collections::VecDeque;\n-\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-\n use crate::ty::fold::TypeFolder;\n use crate::ty::{Region, RegionVid};\n \n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+\n+use std::collections::hash_map::Entry;\n+use std::collections::VecDeque;\n+\n // FIXME(twk): this is obviously not nice to duplicate like that\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n pub enum RegionTarget<'tcx> {\n@@ -233,43 +233,45 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n }\n \n impl AutoTraitFinder<'tcx> {\n-    // The core logic responsible for computing the bounds for our synthesized impl.\n-    //\n-    // To calculate the bounds, we call SelectionContext.select in a loop. Like FulfillmentContext,\n-    // we recursively select the nested obligations of predicates we encounter. However, whenever we\n-    // encounter an UnimplementedError involving a type parameter, we add it to our ParamEnv. Since\n-    // our goal is to determine when a particular type implements an auto trait, Unimplemented\n-    // errors tell us what conditions need to be met.\n-    //\n-    // This method ends up working somewhat similarly to FulfillmentContext, but with a few key\n-    // differences. FulfillmentContext works under the assumption that it's dealing with concrete\n-    // user code. According, it considers all possible ways that a Predicate could be met - which\n-    // isn't always what we want for a synthesized impl. For example, given the predicate 'T:\n-    // Iterator', FulfillmentContext can end up reporting an Unimplemented error for T:\n-    // IntoIterator - since there's an implementation of Iteratpr where T: IntoIterator,\n-    // FulfillmentContext will drive SelectionContext to consider that impl before giving up. If we\n-    // were to rely on FulfillmentContext's decision, we might end up synthesizing an impl like\n-    // this:\n-    // 'impl<T> Send for Foo<T> where T: IntoIterator'\n-    //\n-    // While it might be technically true that Foo implements Send where T: IntoIterator,\n-    // the bound is overly restrictive - it's really only necessary that T: Iterator.\n-    //\n-    // For this reason, evaluate_predicates handles predicates with type variables specially. When\n-    // we encounter an Unimplemented error for a bound such as 'T: Iterator', we immediately add it\n-    // to our ParamEnv, and add it to our stack for recursive evaluation. When we later select it,\n-    // we'll pick up any nested bounds, without ever inferring that 'T: IntoIterator' needs to\n-    // hold.\n-    //\n-    // One additional consideration is supertrait bounds. Normally, a ParamEnv is only ever\n-    // constructed once for a given type. As part of the construction process, the ParamEnv will\n-    // have any supertrait bounds normalized - e.g., if we have a type 'struct Foo<T: Copy>', the\n-    // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n-    // own ParamEnv, we need to do this ourselves, through traits::elaborate_predicates, or else\n-    // SelectionContext will choke on the missing predicates. However, this should never show up in\n-    // the final synthesized generics: we don't want our generated docs page to contain something\n-    // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n-    // 'user_env', which only holds the predicates that will actually be displayed to the user.\n+    /// The core logic responsible for computing the bounds for our synthesized impl.\n+    ///\n+    /// To calculate the bounds, we call `SelectionContext.select` in a loop. Like\n+    /// `FulfillmentContext`, we recursively select the nested obligations of predicates we\n+    /// encounter. However, whenever we encounter an `UnimplementedError` involving a type\n+    /// parameter, we add it to our `ParamEnv`. Since our goal is to determine when a particular\n+    /// type implements an auto trait, Unimplemented errors tell us what conditions need to be met.\n+    ///\n+    /// This method ends up working somewhat similarly to `FulfillmentContext`, but with a few key\n+    /// differences. `FulfillmentContext` works under the assumption that it's dealing with concrete\n+    /// user code. According, it considers all possible ways that a `Predicate` could be met, which\n+    /// isn't always what we want for a synthesized impl. For example, given the predicate `T:\n+    /// Iterator`, `FulfillmentContext` can end up reporting an Unimplemented error for `T:\n+    /// IntoIterator` -- since there's an implementation of `Iterator` where `T: IntoIterator`,\n+    /// `FulfillmentContext` will drive `SelectionContext` to consider that impl before giving up.\n+    /// If we were to rely on `FulfillmentContext`s decision, we might end up synthesizing an impl\n+    /// like this:\n+    ///\n+    ///     impl<T> Send for Foo<T> where T: IntoIterator\n+    ///\n+    /// While it might be technically true that Foo implements Send where `T: IntoIterator`,\n+    /// the bound is overly restrictive - it's really only necessary that `T: Iterator`.\n+    ///\n+    /// For this reason, `evaluate_predicates` handles predicates with type variables specially.\n+    /// When we encounter an `Unimplemented` error for a bound such as `T: Iterator`, we immediately\n+    /// add it to our `ParamEnv`, and add it to our stack for recursive evaluation. When we later\n+    /// select it, we'll pick up any nested bounds, without ever inferring that `T: IntoIterator`\n+    /// needs to hold.\n+    ///\n+    /// One additional consideration is supertrait bounds. Normally, a `ParamEnv` is only ever\n+    /// constructed once for a given type. As part of the construction process, the `ParamEnv` will\n+    /// have any supertrait bounds normalized -- e.g., if we have a type `struct Foo<T: Copy>`, the\n+    /// `ParamEnv` will contain `T: Copy` and `T: Clone`, since `Copy: Clone`. When we construct our\n+    /// own `ParamEnv`, we need to do this ourselves, through `traits::elaborate_predicates`, or\n+    /// else `SelectionContext` will choke on the missing predicates. However, this should never\n+    /// show up in the final synthesized generics: we don't want our generated docs page to contain\n+    /// something like `T: Copy + Clone`, as that's redundant. Therefore, we keep track of a\n+    /// separate `user_env`, which only holds the predicates that will actually be displayed to the\n+    /// user.\n     fn evaluate_predicates(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -307,7 +309,7 @@ impl AutoTraitFinder<'tcx> {\n                 continue;\n             }\n \n-            // Call infcx.resolve_vars_if_possible to see if we can\n+            // Call `infcx.resolve_vars_if_possible` to see if we can\n             // get rid of any inference variables.\n             let obligation = infcx.resolve_vars_if_possible(\n                 &Obligation::new(dummy_cause.clone(), new_env, pred)\n@@ -316,14 +318,14 @@ impl AutoTraitFinder<'tcx> {\n \n             match &result {\n                 &Ok(Some(ref vtable)) => {\n-                    // If we see an explicit negative impl (e.g., 'impl !Send for MyStruct'),\n+                    // If we see an explicit negative impl (e.g., `impl !Send for MyStruct`),\n                     // we immediately bail out, since it's impossible for us to continue.\n                     match vtable {\n                         Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) => {\n-                            // Blame tidy for the weird bracket placement\n+                            // Blame 'tidy' for the weird bracket placement.\n                             if infcx.tcx.impl_polarity(*impl_def_id) == ty::ImplPolarity::Negative\n                             {\n-                                debug!(\"evaluate_nested_obligations: Found explicit negative impl\\\n+                                debug!(\"evaluate_nested_obligations: found explicit negative impl\\\n                                         {:?}, bailing out\", impl_def_id);\n                                 return None;\n                             }\n@@ -356,7 +358,7 @@ impl AutoTraitFinder<'tcx> {\n                         predicates.push_back(pred);\n                     } else {\n                         debug!(\n-                            \"evaluate_nested_obligations: Unimplemented found, bailing: \\\n+                            \"evaluate_nested_obligations: `Unimplemented` found, bailing: \\\n                              {:?} {:?} {:?}\",\n                             ty,\n                             pred,\n@@ -392,29 +394,29 @@ impl AutoTraitFinder<'tcx> {\n         return Some((new_env, final_user_env));\n     }\n \n-    // This method is designed to work around the following issue:\n-    // When we compute auto trait bounds, we repeatedly call SelectionContext.select,\n-    // progressively building a ParamEnv based on the results we get.\n-    // However, our usage of SelectionContext differs from its normal use within the compiler,\n-    // in that we capture and re-reprocess predicates from Unimplemented errors.\n-    //\n-    // This can lead to a corner case when dealing with region parameters.\n-    // During our selection loop in evaluate_predicates, we might end up with\n-    // two trait predicates that differ only in their region parameters:\n-    // one containing a HRTB lifetime parameter, and one containing a 'normal'\n-    // lifetime parameter. For example:\n-    //\n-    // T as MyTrait<'a>\n-    // T as MyTrait<'static>\n-    //\n-    // If we put both of these predicates in our computed ParamEnv, we'll\n-    // confuse SelectionContext, since it will (correctly) view both as being applicable.\n-    //\n-    // To solve this, we pick the 'more strict' lifetime bound - i.e., the HRTB\n-    // Our end goal is to generate a user-visible description of the conditions\n-    // under which a type implements an auto trait. A trait predicate involving\n-    // a HRTB means that the type needs to work with any choice of lifetime,\n-    // not just one specific lifetime (e.g., 'static).\n+    /// This method is designed to work around the following issue:\n+    /// When we compute auto trait bounds, we repeatedly call `SelectionContext.select`,\n+    /// progressively building a `ParamEnv` based on the results we get.\n+    /// However, our usage of `SelectionContext` differs from its normal use within the compiler,\n+    /// in that we capture and re-reprocess predicates from `Unimplemented` errors.\n+    ///\n+    /// This can lead to a corner case when dealing with region parameters.\n+    /// During our selection loop in `evaluate_predicates`, we might end up with\n+    /// two trait predicates that differ only in their region parameters:\n+    /// one containing a HRTB lifetime parameter, and one containing a 'normal'\n+    /// lifetime parameter. For example:\n+    ///\n+    ///     T as MyTrait<'a>\n+    ///     T as MyTrait<'static>\n+    ///\n+    /// If we put both of these predicates in our computed `ParamEnv`, we'll\n+    /// confuse `SelectionContext`, since it will (correctly) view both as being applicable.\n+    ///\n+    /// To solve this, we pick the 'more strict' lifetime bound -- i.e., the HRTB\n+    /// Our end goal is to generate a user-visible description of the conditions\n+    /// under which a type implements an auto trait. A trait predicate involving\n+    /// a HRTB means that the type needs to work with any choice of lifetime,\n+    /// not just one specific lifetime (e.g., `'static`).\n     fn add_user_pred<'c>(\n         &self,\n         user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n@@ -430,16 +432,16 @@ impl AutoTraitFinder<'tcx> {\n \n                         if !new_substs.types().eq(old_substs.types()) {\n                             // We can't compare lifetimes if the types are different,\n-                            // so skip checking old_pred\n+                            // so skip checking `old_pred`.\n                             return true;\n                         }\n \n                         for (new_region, old_region) in\n                             new_substs.regions().zip(old_substs.regions())\n                         {\n                             match (new_region, old_region) {\n-                                // If both predicates have an 'ReLateBound' (a HRTB) in the\n-                                // same spot, we do nothing\n+                                // If both predicates have an `ReLateBound` (a HRTB) in the\n+                                // same spot, we do nothing.\n                                 (\n                                     ty::RegionKind::ReLateBound(_, _),\n                                     ty::RegionKind::ReLateBound(_, _),\n@@ -463,13 +465,13 @@ impl AutoTraitFinder<'tcx> {\n                                     // varaible).\n                                     //\n                                     // In both cases, we want to remove the old predicate,\n-                                    // from user_computed_preds, and replace it with the new\n+                                    // from `user_computed_preds`, and replace it with the new\n                                     // one. Having both the old and the new\n-                                    // predicate in a ParamEnv would confuse SelectionContext\n+                                    // predicate in a `ParamEnv` would confuse `SelectionContext`.\n                                     //\n                                     // We're currently in the predicate passed to 'retain',\n-                                    // so we return 'false' to remove the old predicate from\n-                                    // user_computed_preds\n+                                    // so we return `false` to remove the old predicate from\n+                                    // `user_computed_preds`.\n                                     return false;\n                                 }\n                                 (_, ty::RegionKind::ReLateBound(_, _)) |\n@@ -486,8 +488,8 @@ impl AutoTraitFinder<'tcx> {\n                                     // predicate has some other type of region.\n                                     //\n                                     // We want to leave the old\n-                                    // predicate in user_computed_preds, and skip adding\n-                                    // new_pred to user_computed_params.\n+                                    // predicate in `user_computed_preds`, and skip adding\n+                                    // new_pred to `user_computed_params`.\n                                     should_add_new = false\n                                 },\n                                 _ => {}\n@@ -505,8 +507,8 @@ impl AutoTraitFinder<'tcx> {\n         }\n     }\n \n-    // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n-    // to each other, we match ty::RegionVid's to ty::Region's\n+    /// This is very similar to `handle_lifetimes`. However, instead of matching `ty::Region`s\n+    /// to each other, we match `ty::RegionVid`s to `ty::Region`s.\n     fn map_vid_to_region<'cx>(\n         &self,\n         regions: &RegionConstraintData<'cx>,\n@@ -573,7 +575,7 @@ impl AutoTraitFinder<'tcx> {\n                             finished_map.insert(v1, r1);\n                         }\n                         (&RegionTarget::Region(_), &RegionTarget::RegionVid(_)) => {\n-                            // Do nothing - we don't care about regions that are smaller than vids\n+                            // Do nothing; we don't care about regions that are smaller than vids.\n                         }\n                         (&RegionTarget::RegionVid(_), &RegionTarget::RegionVid(_)) => {\n                             if let Entry::Occupied(v) = vid_map.entry(*smaller) {"}, {"sha": "d94e004db29789ae02a6b1c56d72e688ced9ba60", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -191,23 +191,23 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Obligation incurred due to a coercion.\n     Coercion { source: Ty<'tcx>, target: Ty<'tcx> },\n \n-    // Various cases where expressions must be sized/copy/etc:\n-    /// L = X implies that L is Sized\n+    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n+    /// `L = X` implies that `L` is `Sized`.\n     AssignmentLhsSized,\n-    /// (x1, .., xn) must be Sized\n+    /// `(x1, .., xn)` must be `Sized`.\n     TupleInitializerSized,\n-    /// S { ... } must be Sized\n+    /// `S { ... }` must be `Sized`.\n     StructInitializerSized,\n-    /// Type of each variable must be Sized\n+    /// Type of each variable must be `Sized`.\n     VariableType(hir::HirId),\n-    /// Argument type must be Sized\n+    /// Argument type must be `Sized`.\n     SizedArgumentType,\n-    /// Return type must be Sized\n+    /// Return type must be `Sized`.\n     SizedReturnType,\n-    /// Yield type must be Sized\n+    /// Yield type must be `Sized`.\n     SizedYieldType,\n-    /// [T,..n] --> T must be Copy. If `true`, suggest `const_in_array_repeat_expressions` feature\n-    /// flag.\n+    /// `[T, ..n]` implies that `T` must be `Copy`.\n+    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n     RepeatVec(bool),\n \n     /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n@@ -216,7 +216,7 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Constant expressions must be sized.\n     ConstSized,\n \n-    /// Static items must have `Sync` type\n+    /// `static` items must have `Sync` type.\n     SharedStatic,\n \n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n@@ -602,7 +602,7 @@ pub enum Vtable<'tcx, N> {\n /// the impl's type parameters.\n ///\n /// The type parameter `N` indicates the type used for \"nested\n-/// obligations\" that are required by the impl. During type check, this\n+/// obligations\" that are required by the impl. During type-check, this\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n@@ -1046,8 +1046,7 @@ fn vtable_methods<'tcx>(\n                     return None;\n                 }\n \n-                // the method may have some early-bound lifetimes, add\n-                // regions for those\n+                // The method may have some early-bound lifetimes; add regions for those.\n                 let substs = trait_ref.map_bound(|trait_ref|\n                     InternalSubsts::for_item(tcx, def_id, |param, _|\n                         match param.kind {\n@@ -1060,15 +1059,15 @@ fn vtable_methods<'tcx>(\n                     )\n                 );\n \n-                // the trait type may have higher-ranked lifetimes in it;\n-                // so erase them if they appear, so that we get the type\n-                // at some particular call site\n+                // The trait type may have higher-ranked lifetimes in it;\n+                // erase them if they appear, so that we get the type\n+                // at some particular call site.\n                 let substs = tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n                     &substs\n                 );\n \n-                // It's possible that the method relies on where clauses that\n+                // It's possible that the method relies on where-clauses that\n                 // do not hold for this particular set of type parameters.\n                 // Note that this method could then never be called, so we\n                 // do not want to try and codegen it, in that case (see #23435)."}, {"sha": "283fa56d11f4f05a805ded364d7f7362c91b3bf1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 150, "deletions": 154, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -157,7 +157,7 @@ impl IntercrateAmbiguityCause {\n struct TraitObligationStack<'prev, 'tcx> {\n     obligation: &'prev TraitObligation<'tcx>,\n \n-    /// Trait ref from `obligation` but \"freshened\" with the\n+    /// The trait ref from `obligation` but \"freshened\" with the\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n@@ -193,11 +193,11 @@ struct TraitObligationStack<'prev, 'tcx> {\n \n     previous: TraitObligationStackList<'prev, 'tcx>,\n \n-    /// Number of parent frames plus one -- so the topmost frame has depth 1.\n+    /// The number of parent frames plus one (thus, the topmost frame has depth 1).\n     depth: usize,\n \n-    /// Depth-first number of this node in the search graph -- a\n-    /// pre-order index.  Basically a freshly incremented counter.\n+    /// The depth-first number of this node in the search graph -- a\n+    /// pre-order index. Basically, a freshly incremented counter.\n     dfn: usize,\n }\n \n@@ -239,9 +239,9 @@ pub struct SelectionCache<'tcx> {\n ///    }\n ///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n ///\n-/// we can't just use the impl to resolve the <T as AsDebug> obligation\n-/// - a type from another crate (that doesn't implement fmt::Debug) could\n-/// implement AsDebug.\n+/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n+/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n+/// implement `AsDebug`.\n ///\n /// Because where-clauses match the type exactly, multiple clauses can\n /// only match if there are unresolved variables, and we can mostly just\n@@ -266,10 +266,10 @@ pub struct SelectionCache<'tcx> {\n ///    }\n ///    fn main() { foo(false); }\n ///\n-/// Here the obligation <T as Foo<$0>> can be matched by both the blanket\n-/// impl and the where-clause. We select the where-clause and unify $0=bool,\n+/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n+/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n /// so the program prints \"false\". However, if the where-clause is omitted,\n-/// the blanket impl is selected, we unify $0=(), and the program prints\n+/// the blanket impl is selected, we unify `$0=()`, and the program prints\n /// \"()\".\n ///\n /// Exactly the same issues apply to projection and object candidates, except\n@@ -282,8 +282,8 @@ pub struct SelectionCache<'tcx> {\n /// parameter environment.\n #[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n enum SelectionCandidate<'tcx> {\n-    /// If has_nested is false, there are no *further* obligations\n     BuiltinCandidate {\n+        /// `false` if there are no *further* obligations.\n         has_nested: bool,\n     },\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n@@ -303,7 +303,7 @@ enum SelectionCandidate<'tcx> {\n     GeneratorCandidate,\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n-    /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n+    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n     FnPointerCandidate,\n \n     TraitAliasCandidate(DefId),\n@@ -339,11 +339,11 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n }\n \n struct SelectionCandidateSet<'tcx> {\n-    // a list of candidates that definitely apply to the current\n+    // A list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n     vec: Vec<SelectionCandidate<'tcx>>,\n \n-    // if this is true, then there were candidates that might or might\n+    // If `true`, then there were candidates that might or might\n     // not have applied, but we couldn't tell. This occurs when some\n     // of the input types are type variables, in which case there are\n     // various \"builtin\" rules that might or might not trigger.\n@@ -358,7 +358,7 @@ struct EvaluatedCandidate<'tcx> {\n \n /// When does the builtin impl for `T: Trait` apply?\n enum BuiltinImplConditions<'tcx> {\n-    /// The impl is conditional on T1,T2,.. : Trait\n+    /// The impl is conditional on `T1, T2, ...: Trait`.\n     Where(ty::Binder<Vec<Ty<'tcx>>>),\n     /// There is no built-in impl. There may be some other\n     /// candidate (a where-clause or user-defined impl).\n@@ -381,15 +381,15 @@ enum BuiltinImplConditions<'tcx> {\n ///     the categories it's easy to see that the unions are correct.\n #[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n pub enum EvaluationResult {\n-    /// Evaluation successful\n+    /// Evaluation successful.\n     EvaluatedToOk,\n-    /// Evaluation successful, but there were unevaluated region obligations\n+    /// Evaluation successful, but there were unevaluated region obligations.\n     EvaluatedToOkModuloRegions,\n-    /// Evaluation is known to be ambiguous - it *might* hold for some\n+    /// Evaluation is known to be ambiguous -- it *might* hold for some\n     /// assignment of inference variables, but it might not.\n     ///\n-    /// While this has the same meaning as `EvaluatedToUnknown` - we can't\n-    /// know whether this obligation holds or not - it is the result we\n+    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n+    /// know whether this obligation holds or not -- it is the result we\n     /// would get with an empty stack, and therefore is cacheable.\n     EvaluatedToAmbig,\n     /// Evaluation failed because of recursion involving inference\n@@ -404,29 +404,29 @@ pub enum EvaluationResult {\n     /// We know this branch can't be a part of a minimal proof-tree for\n     /// the \"root\" of our cycle, because then we could cut out the recursion\n     /// and maintain a valid proof tree. However, this does not mean\n-    /// that all the obligations on this branch do not hold - it's possible\n+    /// that all the obligations on this branch do not hold -- it's possible\n     /// that we entered this branch \"speculatively\", and that there\n     /// might be some other way to prove this obligation that does not\n-    /// go through this cycle - so we can't cache this as a failure.\n+    /// go through this cycle -- so we can't cache this as a failure.\n     ///\n     /// For example, suppose we have this:\n     ///\n     /// ```rust,ignore (pseudo-Rust)\n-    ///     pub trait Trait { fn xyz(); }\n-    ///     // This impl is \"useless\", but we can still have\n-    ///     // an `impl Trait for SomeUnsizedType` somewhere.\n-    ///     impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n+    /// pub trait Trait { fn xyz(); }\n+    /// // This impl is \"useless\", but we can still have\n+    /// // an `impl Trait for SomeUnsizedType` somewhere.\n+    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n     ///\n-    ///     pub fn foo<T: Trait + ?Sized>() {\n-    ///         <T as Trait>::xyz();\n-    ///     }\n+    /// pub fn foo<T: Trait + ?Sized>() {\n+    ///     <T as Trait>::xyz();\n+    /// }\n     /// ```\n     ///\n     /// When checking `foo`, we have to prove `T: Trait`. This basically\n     /// translates into this:\n     ///\n     /// ```plain,ignore\n-    ///     (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n     /// ```\n     ///\n     /// When we try to prove it, we first go the first option, which\n@@ -594,7 +594,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // 1. If no applicable impl or parameter bound can be found.\n     // 2. If the output type parameters in the obligation do not match\n     //    those specified by the impl/bound. For example, if the obligation\n-    //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n+    //    is `Vec<Foo>: Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n     /// Attempts to satisfy the obligation. If successful, this will affect the surrounding\n@@ -723,10 +723,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively(previous_stack={:?}, obligation={:?})\",\n             previous_stack.head(), obligation);\n \n-        // Previous_stack stores a TraitObligatiom, while 'obligation' is\n-        // a PredicateObligation. These are distinct types, so we can't\n-        // use any Option combinator method that would force them to be\n-        // the same\n+        // `previous_stack` stores a `TraitObligatiom`, while `obligation` is\n+        // a `PredicateObligation`. These are distinct types, so we can't\n+        // use any `Option` combinator method that would force them to be\n+        // the same.\n         match previous_stack.head() {\n             Some(h) => self.check_recursion_limit(&obligation, h.obligation)?,\n             None => self.check_recursion_limit(&obligation, &obligation)?\n@@ -740,7 +740,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::Subtype(ref p) => {\n-                // does this code ever run?\n+                // Does this code ever run?\n                 match self.infcx\n                     .subtype_predicate(&obligation.cause, obligation.param_env, p)\n                 {\n@@ -768,8 +768,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             },\n \n             ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n-                // we do not consider region relationships when\n-                // evaluating trait matches\n+                // We do not consider region relationships when evaluating trait matches.\n                 Ok(EvaluatedToOkModuloRegions)\n             }\n \n@@ -953,7 +952,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         stack: &TraitObligationStack<'_, 'tcx>,\n     ) -> Option<EvaluationResult> {\n         if let Some(cycle_depth) = stack.iter()\n-            .skip(1) // skip top-most frame\n+            .skip(1) // Skip top-most frame.\n             .find(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n                   stack.fresh_trait_ref == prev.fresh_trait_ref)\n             .map(|stack| stack.depth)\n@@ -1030,8 +1029,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip_binder()\n             .input_types()\n             .any(|ty| ty.is_fresh());\n-        // this check was an imperfect workaround for a bug n the old\n-        // intercrate mode, it should be removed when that goes away.\n+        // This check was an imperfect workaround for a bug in the old\n+        // intercrate mode; it should be removed when that goes away.\n         if unbound_input_types && self.intercrate == Some(IntercrateMode::Issue43355) {\n             debug!(\n                 \"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n@@ -1083,7 +1082,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     /// For defaulted traits, we use a co-inductive strategy to solve, so\n-    /// that recursion is ok. This routine returns true if the top of the\n+    /// that recursion is ok. This routine returns `true` if the top of the\n     /// stack (`cycle[0]`):\n     ///\n     /// - is a defaulted trait,\n@@ -1107,7 +1106,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n-    /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n+    /// Further evaluates `candidate` to decide whether all type parameters match and whether nested\n     /// obligations are met. Returns whether `candidate` remains viable after this further\n     /// scrutiny.\n     fn evaluate_candidate<'o>(\n@@ -1199,26 +1198,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n-    // For various reasons, it's possible for a subobligation\n-    // to have a *lower* recursion_depth than the obligation used to create it.\n-    // Projection sub-obligations may be returned from the projection cache,\n-    // which results in obligations with an 'old' recursion_depth.\n-    // Additionally, methods like ty::wf::obligations and\n-    // InferCtxt.subtype_predicate produce subobligations without\n-    // taking in a 'parent' depth, causing the generated subobligations\n-    // to have a recursion_depth of 0\n-    //\n-    // To ensure that obligation_depth never decreasees, we force all subobligations\n-    // to have at least the depth of the original obligation.\n+    /// For various reasons, it's possible for a subobligation\n+    /// to have a *lower* recursion_depth than the obligation used to create it.\n+    /// Projection sub-obligations may be returned from the projection cache,\n+    /// which results in obligations with an 'old' `recursion_depth`.\n+    /// Additionally, methods like `ty::wf::obligations` and\n+    /// `InferCtxt.subtype_predicate` produce subobligations without\n+    /// taking in a 'parent' depth, causing the generated subobligations\n+    /// to have a `recursion_depth` of `0`.\n+    ///\n+    /// To ensure that obligation_depth never decreasees, we force all subobligations\n+    /// to have at least the depth of the original obligation.\n     fn add_depth<T: 'cx, I: Iterator<Item = &'cx mut Obligation<'tcx, T>>>(&self, it: I,\n                                                                            min_depth: usize) {\n         it.for_each(|o| o.recursion_depth = cmp::max(min_depth, o.recursion_depth) + 1);\n     }\n \n-    // Check that the recursion limit has not been exceeded.\n-    //\n-    // The weird return type of this function allows it to be used with the 'try' (?)\n-    // operator within certain functions\n+    /// Checks that the recursion limit has not been exceeded.\n+    ///\n+    /// The weird return type of this function allows it to be used with the `try` (`?`)\n+    /// operator within certain functions.\n     fn check_recursion_limit<T: Display + TypeFoldable<'tcx>, V: Display + TypeFoldable<'tcx>>(\n         &self,\n         obligation: &Obligation<'tcx, T>,\n@@ -1256,7 +1255,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n \n-\n         // Check the cache. Note that we freshen the trait-ref\n         // separately rather than using `stack.fresh_trait_ref` --\n         // this is because we want the unbound variables to be\n@@ -1436,10 +1434,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // candidate set is *individually* applicable. Now we have to\n         // figure out if they contain mutual incompatibilities. This\n         // frequently arises if we have an unconstrained input type --\n-        // for example, we are looking for $0:Eq where $0 is some\n+        // for example, we are looking for `$0: Eq` where `$0` is some\n         // unconstrained type variable. In that case, we'll get a\n-        // candidate which assumes $0 == int, one that assumes $0 ==\n-        // usize, etc. This spells an ambiguity.\n+        // candidate which assumes $0 == int, one that assumes `$0 ==\n+        // usize`, etc. This spells an ambiguity.\n \n         // If there is more than one candidate, first winnow them down\n         // by considering extra conditions (nested obligations and so\n@@ -1453,8 +1451,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // and we were to see some code `foo.push_clone()` where `boo`\n         // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n         // we were to winnow, we'd wind up with zero candidates.\n-        // Instead, we select the right impl now but report `Bar does\n-        // not implement Clone`.\n+        // Instead, we select the right impl now but report \"`Bar` does\n+        // not implement `Clone`\".\n         if candidates.len() == 1 {\n             return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n         }\n@@ -1586,7 +1584,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // avoid us having to fear that coherence results \"pollute\"\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n-        // hit-rate I don't think.\n+        // hit-rate, I don't think.\n         if self.intercrate.is_some() {\n             return false;\n         }\n@@ -1617,21 +1615,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     /// Determines whether can we safely cache the result\n-    /// of selecting an obligation. This is almost always 'true',\n-    /// except when dealing with certain ParamCandidates.\n+    /// of selecting an obligation. This is almost always `true`,\n+    /// except when dealing with certain `ParamCandidate`s.\n     ///\n-    /// Ordinarily, a ParamCandidate will contain no inference variables,\n-    /// since it was usually produced directly from a DefId. However,\n+    /// Ordinarily, a `ParamCandidate` will contain no inference variables,\n+    /// since it was usually produced directly from a `DefId`. However,\n     /// certain cases (currently only librustdoc's blanket impl finder),\n-    /// a ParamEnv may be explicitly constructed with inference types.\n+    /// a `ParamEnv` may be explicitly constructed with inference types.\n     /// When this is the case, we do *not* want to cache the resulting selection\n     /// candidate. This is due to the fact that it might not always be possible\n     /// to equate the obligation's trait ref and the candidate's trait ref,\n     /// if more constraints end up getting added to an inference variable.\n     ///\n     /// Because of this, we always want to re-run the full selection\n     /// process for our obligation the next time we see it, since\n-    /// we might end up picking a different SelectionCandidate (or none at all)\n+    /// we might end up picking a different `SelectionCandidate` (or none at all).\n     fn can_cache_candidate(&self,\n         result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>\n      ) -> bool {\n@@ -1662,15 +1660,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         if self.can_use_global_caches(param_env) {\n             if let Err(Overflow) = candidate {\n-                // Don't cache overflow globally; we only produce this\n-                // in certain modes.\n+                // Don't cache overflow globally; we only produce this in certain modes.\n             } else if !trait_ref.has_local_value() {\n                 if !candidate.has_local_value() {\n                     debug!(\n                         \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) global\",\n                         trait_ref, candidate,\n                     );\n-                    // This may overwrite the cache with the same value\n+                    // This may overwrite the cache with the same value.\n                     tcx.selection_cache\n                         .hashmap\n                         .borrow_mut()\n@@ -1755,7 +1752,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         } else {\n             if lang_items.clone_trait() == Some(def_id) {\n                 // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n-                // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n+                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n                 // types have builtin support for `Clone`.\n                 let clone_conditions = self.copy_clone_conditions(obligation);\n                 self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n@@ -1786,7 +1783,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) {\n         debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n \n-        // before we go into the whole placeholder thing, just\n+        // Before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n             ty::Projection(_) | ty::Opaque(..) => {}\n@@ -1907,10 +1904,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.infcx.leak_check(false, placeholder_map, snapshot).is_ok()\n     }\n \n-    /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n+    /// Given an obligation like `<SomeTrait for T>`, searches the obligations that the caller\n     /// supplied to find out whether it is listed among them.\n     ///\n-    /// Never affects inference environment.\n+    /// Never affects the inference environment.\n     fn assemble_candidates_from_caller_bounds<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -2052,7 +2049,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n-    /// Implement one of the `Fn()` family for a fn pointer.\n+    /// Implements one of the `Fn()` family for a fn pointer.\n     fn assemble_fn_pointer_candidates(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2067,14 +2064,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(());\n         }\n \n-        // Okay to skip binder because what we are inspecting doesn't involve bound regions\n+        // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.kind {\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n-                candidates.ambiguous = true; // could wind up being a fn() type\n+                candidates.ambiguous = true; // Could wind up being a fn() type.\n             }\n-            // provide an impl, but only for suitable `fn` pointers\n+            // Provide an impl, but only for suitable `fn` pointers.\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n@@ -2092,7 +2089,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n-    /// Search for impls that might apply to `obligation`.\n+    /// Searches for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2160,7 +2157,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // this path.\n                 }\n                 ty::Infer(ty::TyVar(_)) => {\n-                    // the auto impl might apply, we don't know\n+                    // The auto impl might apply; we don't know.\n                     candidates.ambiguous = true;\n                 }\n                 ty::Generator(_, _, movability)\n@@ -2188,7 +2185,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n-    /// Search for impls that might apply to `obligation`.\n+    /// Searches for impls that might apply to `obligation`.\n     fn assemble_candidates_from_object_ty(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2226,7 +2223,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             return;\n                         }\n                     } else {\n-                        // Only auto-trait bounds exist.\n+                        // Only auto trait bounds exist.\n                         return;\n                     }\n                 }\n@@ -2247,7 +2244,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // we are looking for. Specifically, do not only check for the\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n-            // but `Foo` is declared as `trait Foo : Bar<u32>`.\n+            // but `Foo` is declared as `trait Foo: Bar<u32>`.\n             let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n                 .filter(|upcast_trait_ref| {\n                     self.infcx.probe(|_| {\n@@ -2267,7 +2264,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    /// Search for unsizing that might apply to `obligation`.\n+    /// Searches for unsizing that might apply to `obligation`.\n     fn assemble_candidates_for_unsizing(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -2311,11 +2308,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n-                // 1. Dropping builtin bounds, e.g., `Foo+Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n                 //\n                 // Note that neither of these changes requires any\n-                // change at runtime.  Eventually this will be\n+                // change at runtime. Eventually this will be\n                 // generalized.\n                 //\n                 // We always upcast when we can because of reason\n@@ -2326,27 +2323,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .all(|b| data_a.auto_traits().any(|a| a == b))\n             }\n \n-            // T -> Trait.\n+            // `T` -> `Trait`\n             (_, &ty::Dynamic(..)) => true,\n \n-            // Ambiguous handling is below T -> Trait, because inference\n-            // variables can still implement Unsize<Trait> and nested\n+            // Ambiguous handling is below `T` -> `Trait`, because inference\n+            // variables can still implement `Unsize<Trait>` and nested\n             // obligations will have the final say (likely deferred).\n             (&ty::Infer(ty::TyVar(_)), _) | (_, &ty::Infer(ty::TyVar(_))) => {\n                 debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n                 candidates.ambiguous = true;\n                 false\n             }\n \n-            // [T; n] -> [T].\n+            // `[T; n]` -> `[T]`\n             (&ty::Array(..), &ty::Slice(_)) => true,\n \n-            // Struct<T> -> Struct<U>.\n+            // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n                 def_id_a == def_id_b\n             }\n \n-            // (.., T) -> (.., U).\n+            // `(.., T)` -> `(.., U)`\n             (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => tys_a.len() == tys_b.len(),\n \n             _ => false,\n@@ -2404,7 +2401,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             |cand: &ty::PolyTraitRef<'_>| cand.is_global() && !cand.has_late_bound_regions();\n \n         match other.candidate {\n-            // Prefer BuiltinCandidate { has_nested: false } to anything else.\n+            // Prefer `BuiltinCandidate { has_nested: false }` to anything else.\n             // This is a fix for #53123 and prevents winnowing from accidentally extending the\n             // lifetime of a variable.\n             BuiltinCandidate { has_nested: false } => true,\n@@ -2415,7 +2412,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          when there are other valid candidates\"\n                     );\n                 }\n-                // Prefer BuiltinCandidate { has_nested: false } to anything else.\n+                // Prefer `BuiltinCandidate { has_nested: false }` to anything else.\n                 // This is a fix for #53123 and prevents winnowing from accidentally extending the\n                 // lifetime of a variable.\n                 BuiltinCandidate { has_nested: false } => false,\n@@ -2446,7 +2443,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          when there are other valid candidates\"\n                     );\n                 }\n-                // Prefer BuiltinCandidate { has_nested: false } to anything else.\n+                // Prefer `BuiltinCandidate { has_nested: false }` to anything else.\n                 // This is a fix for #53123 and prevents winnowing from accidentally extending the\n                 // lifetime of a variable.\n                 BuiltinCandidate { has_nested: false } => false,\n@@ -2468,7 +2465,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ImplCandidate(other_def) => {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n-                // i.e., EvaluatedToOk:\n+                // i.e., `EvaluatedToOk`.\n                 if other.evaluation.must_apply_modulo_regions() {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n@@ -2496,7 +2493,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match victim.candidate {\n                     ParamCandidate(ref cand) => {\n                         // Prefer these to a global where-clause bound\n-                        // (see issue #50825)\n+                        // (see issue #50825).\n                         is_global(cand) && other.evaluation.must_apply_modulo_regions()\n                     }\n                     _ => false,\n@@ -2754,7 +2751,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 types.skip_binder().to_vec()\n             }\n \n-            // for `PhantomData<T>`, we pass `T`\n+            // For `PhantomData<T>`, we pass `T`.\n             ty::Adt(def, substs) if def.is_phantom_data() => substs.types().collect(),\n \n             ty::Adt(def, substs) => def.all_fields().map(|f| f.ty(self.tcx(), substs)).collect(),\n@@ -2894,11 +2891,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             BuiltinObjectCandidate => {\n-                // This indicates something like `(Trait+Send) :\n-                // Send`. In this case, we know that this holds\n-                // because that's what the object type is telling us,\n-                // and there's really no additional obligations to\n-                // prove and no types in particular to unify etc.\n+                // This indicates something like `Trait + Send: Send`. In this case, we know that\n+                // this holds because that's what the object type is telling us, and there's really\n+                // no additional obligations to prove and no types in particular to unify, etc.\n                 Ok(VtableParam(Vec::new()))\n             }\n \n@@ -3152,7 +3147,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // We want to find the first supertrait in the list of\n             // supertraits that we can unify with, and do that\n             // unification. We know that there is exactly one in the list\n-            // where we can unify because otherwise select would have\n+            // where we can unify, because otherwise select would have\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n             let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(\n@@ -3166,7 +3161,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 },\n             );\n \n-            // Additionally, for each of the nonmatching predicates that\n+            // Additionally, for each of the non-matching predicates that\n             // we pass over, we sum up the set of number of vtable\n             // entries, so that we can compute the offset for the selected\n             // trait.\n@@ -3354,7 +3349,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             trait_ref,\n         )?);\n \n-        // FIXME: chalk\n+        // FIXME: Chalk\n \n         if !self.tcx().sess.opts.debugging_opts.chalk {\n             obligations.push(Obligation::new(\n@@ -3421,7 +3416,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n \n-        // assemble_candidates_for_unsizing should ensure there are no late bound\n+        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx\n             .shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n@@ -3442,41 +3437,40 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match (&source.kind, &target.kind) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // See assemble_candidates_for_unsizing for more info.\n+                // See `assemble_candidates_for_unsizing` for more info.\n                 let existential_predicates = data_a.map_bound(|data_a| {\n                     let iter =\n                         data_a.principal().map(|x| ty::ExistentialPredicate::Trait(x))\n-                        .into_iter().chain(\n-                            data_a\n-                                .projection_bounds()\n-                                .map(|x| ty::ExistentialPredicate::Projection(x)),\n-                        )\n-                        .chain(\n-                            data_b\n-                                .auto_traits()\n-                                .map(ty::ExistentialPredicate::AutoTrait),\n-                        );\n+                            .into_iter().chain(\n+                                data_a\n+                                    .projection_bounds()\n+                                    .map(|x| ty::ExistentialPredicate::Projection(x)),\n+                            )\n+                            .chain(\n+                                data_b\n+                                    .auto_traits()\n+                                    .map(ty::ExistentialPredicate::AutoTrait),\n+                            );\n                     tcx.mk_existential_predicates(iter)\n                 });\n                 let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n \n                 // Require that the traits involved in this upcast are **equal**;\n                 // only the **lifetime bound** is changed.\n                 //\n-                // FIXME: This condition is arguably too strong -- it\n-                // would suffice for the source trait to be a\n-                // *subtype* of the target trait. In particular\n-                // changing from something like `for<'a, 'b> Foo<'a,\n-                // 'b>` to `for<'a> Foo<'a, 'a>` should be\n+                // FIXME: This condition is arguably too strong -- it would\n+                // suffice for the source trait to be a *subtype* of the target\n+                // trait. In particular, changing from something like\n+                // `for<'a, 'b> Foo<'a, 'b>` to `for<'a> Foo<'a, 'a>` should be\n                 // permitted. And, indeed, in the in commit\n                 // 904a0bde93f0348f69914ee90b1f8b6e4e0d7cbc, this\n-                // condition was loosened. However, when the leak check was added\n-                // back, using subtype here actually guies the coercion code in\n-                // such a way that it accepts `old-lub-glb-object.rs`. This is probably\n-                // a good thing, but I've modified this to `.eq` because I want\n-                // to continue rejecting that test (as we have done for quite some time)\n-                // before we are firmly comfortable with what our behavior\n-                // should be there. -nikomatsakis\n+                // condition was loosened. However, when the leak check was\n+                // added back, using subtype here actually guides the coercion\n+                // code in such a way that it accepts `old-lub-glb-object.rs`.\n+                // This is probably a good thing, but I've modified this to `.eq`\n+                // because I want to continue rejecting that test (as we have\n+                // done for quite some time) before we are firmly comfortable\n+                // with what our behavior should be there. -nikomatsakis\n                 let InferOk { obligations, .. } = self.infcx\n                     .at(&obligation.cause, obligation.param_env)\n                     .eq(target, source_trait) // FIXME -- see below\n@@ -3498,7 +3492,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ));\n             }\n \n-            // T -> Trait.\n+            // `T` -> `Trait`\n             (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids = data.auto_traits()\n                     .chain(data.principal_def_id());\n@@ -3522,32 +3516,34 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 };\n \n                 // Create obligations:\n-                //  - Casting T to Trait\n+                //  - Casting `T` to `Trait`\n                 //  - For all the various builtin bounds attached to the object cast. (In other\n-                //  words, if the object type is Foo+Send, this would create an obligation for the\n-                //  Send check.)\n+                //  words, if the object type is `Foo + Send`, this would create an obligation for\n+                //  the `Send` check.)\n                 //  - Projection predicates\n                 nested.extend(\n                     data.iter()\n-                        .map(|d| predicate_to_obligation(d.with_self_ty(tcx, source))),\n+                        .map(|predicate|\n+                            predicate_to_obligation(predicate.with_self_ty(tcx, source))\n+                        ),\n                 );\n \n                 // We can only make objects from sized types.\n-                let tr = ty::TraitRef {\n-                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n-                    substs: tcx.mk_substs_trait(source, &[]),\n-                };\n+                let tr = ty::TraitRef::new(\n+                    tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n+                    tcx.mk_substs_trait(source, &[]),\n+                );\n                 nested.push(predicate_to_obligation(tr.to_predicate()));\n \n-                // If the type is `Foo+'a`, ensures that the type\n-                // being cast to `Foo+'a` outlives `'a`:\n+                // If the type is `Foo + 'a`, ensure that the type\n+                // being cast to `Foo + 'a` outlives `'a`:\n                 let outlives = ty::OutlivesPredicate(source, r);\n                 nested.push(predicate_to_obligation(\n                     ty::Binder::dummy(outlives).to_predicate(),\n                 ));\n             }\n \n-            // [T; n] -> [T].\n+            // `[T; n]` -> `[T]`\n             (&ty::Array(a, _), &ty::Slice(b)) => {\n                 let InferOk { obligations, .. } = self.infcx\n                     .at(&obligation.cause, obligation.param_env)\n@@ -3556,10 +3552,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n             }\n \n-            // Struct<T> -> Struct<U>.\n+            // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n                 let fields = def.all_fields()\n-                    .map(|f| tcx.type_of(f.did))\n+                    .map(|field| tcx.type_of(field.did))\n                     .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n@@ -3598,7 +3594,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                // Extract Field<T> and Field<U> from Struct<T> and Struct<U>.\n+                // Extract `Field<T>` and `Field<U>` from `Struct<T>` and `Struct<U>`.\n                 let inner_source = field.subst(tcx, substs_a);\n                 let inner_target = field.subst(tcx, substs_b);\n \n@@ -3618,7 +3614,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n-                // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n+                // Construct the nested `Field<T>: Unsize<Field<U>>` predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n                     obligation.param_env,\n                     obligation.cause.clone(),\n@@ -3629,7 +3625,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ));\n             }\n \n-            // (.., T) -> (.., U).\n+            // `(.., T)` -> `(.., U)`\n             (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n                 assert_eq!(tys_a.len(), tys_b.len());\n \n@@ -3652,7 +3648,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n-                // Construct the nested T: Unsize<U> predicate.\n+                // Construct the nested `T: Unsize<U>` predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n                     obligation.param_env,\n                     obligation.cause.clone(),\n@@ -3969,7 +3965,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //\n         // This code is hot enough that it's worth avoiding the allocation\n         // required for the FxHashSet when possible. Special-casing lengths 0,\n-        // 1 and 2 covers roughly 75--80% of the cases.\n+        // 1 and 2 covers roughly 75-80% of the cases.\n         if predicates.len() <= 1 {\n             // No possibility of duplicates.\n         } else if predicates.len() == 2 {"}, {"sha": "c15915a9d561fb572807605afba6511dc1c5bc5e", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -80,7 +80,7 @@ impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n /// \"Elaboration\" is the process of identifying all the predicates that\n-/// are implied by a source predicate. Currently this basically means\n+/// are implied by a source predicate. Currently, this basically means\n /// walking the \"supertraits\" and other similar assumptions. For example,\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that"}, {"sha": "be6d21564a0f1bd939feba5ac2ba062bab561532", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,14 +1,15 @@\n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, BoundRegion, Region, Ty, TyCtxt};\n-use std::borrow::Cow;\n-use std::fmt;\n+\n+use errors::{Applicability, DiagnosticBuilder};\n use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::errors::pluralize;\n-use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n \n-use crate::hir;\n+use std::borrow::Cow;\n+use std::fmt;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable)]\n pub struct ExpectedFound<T> {"}, {"sha": "777db38850fec87b4c4c1673ff5a41ec805d282e", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -36,10 +36,10 @@ pub enum InstanceDef<'tcx> {\n     ReifyShim(DefId),\n \n     /// `<fn() as FnTrait>::call_*`\n-    /// `DefId` is `FnTrait::call_*`\n+    /// `DefId` is `FnTrait::call_*`.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n-    /// `<Trait as Trait>::fn`\n+    /// `<dyn Trait as Trait>::fn`\n     Virtual(DefId, usize),\n \n     /// `<[mut closure] as FnOnce>::call_once`\n@@ -115,7 +115,7 @@ impl<'tcx> Instance<'tcx> {\n     pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         let mut fn_sig = self.fn_sig_noadjust(tcx);\n         if let InstanceDef::VtableShim(..) = self.def {\n-            // Modify fn(self, ...) to fn(self: *mut Self, ...)\n+            // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n             fn_sig = fn_sig.map_bound(|mut fn_sig| {\n                 let mut inputs_and_output = fn_sig.inputs_and_output.to_vec();\n                 inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);"}, {"sha": "37d1e8e3340b63195ff9c1f708d39a93bae7512a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -2103,8 +2103,8 @@ where\n             ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 assert!(i < this.fields.count());\n \n-                // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g., DST struct pointees\n+                // Reuse the fat `*T` type as its own thin pointer data field.\n+                // This provides information about, e.g., DST struct pointees\n                 // (which may have no non-DST form), and will work as long\n                 // as the `Abi` or `FieldPlacement` is checked by users.\n                 if i == 0 {"}, {"sha": "8ccfc467f4a0b08b8e1ea88b700cfa7acaaed031", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1923,17 +1923,17 @@ pub struct FieldDef {\n ///\n /// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n ///\n-/// The initialism *\"Adt\"* stands for an [*algebraic data type (ADT)*][adt].\n+/// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n /// This is slightly wrong because `union`s are not ADTs.\n /// Moreover, Rust only allows recursive data types through indirection.\n ///\n /// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n pub struct AdtDef {\n-    /// `DefId` of the struct, enum or union item.\n+    /// The `DefId` of the struct, enum or union item.\n     pub did: DefId,\n     /// Variants of the ADT. If this is a struct or union, then there will be a single variant.\n     pub variants: IndexVec<self::layout::VariantIdx, VariantDef>,\n-    /// Flags of the ADT (e.g. is this a struct? is this non-exhaustive?)\n+    /// Flags of the ADT (e.g., is this a struct? is this non-exhaustive?).\n     flags: AdtFlags,\n     /// Repr options provided by the user.\n     pub repr: ReprOptions,\n@@ -1954,7 +1954,7 @@ impl Ord for AdtDef {\n }\n \n impl PartialEq for AdtDef {\n-    // AdtDef are always interned and this is part of TyS equality\n+    // `AdtDef`s are always interned, and this is part of `TyS` equality.\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { ptr::eq(self, other) }\n }\n@@ -1976,7 +1976,6 @@ impl<'tcx> rustc_serialize::UseSpecializedEncodable for &'tcx AdtDef {\n \n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n-\n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {"}, {"sha": "efdf40fd6b8a46c1342d7dd60074079d753efaae", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -281,7 +281,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n         a: &ty::TraitRef<'tcx>,\n         b: &ty::TraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {\n-        // Different traits cannot be related\n+        // Different traits cannot be related.\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n@@ -297,7 +297,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n         a: &ty::ExistentialTraitRef<'tcx>,\n         b: &ty::ExistentialTraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {\n-        // Different traits cannot be related\n+        // Different traits cannot be related.\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {"}, {"sha": "a0e66d340ae9d3af16d1a0b23fbad25306c05aa3", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -4,12 +4,13 @@\n \n use crate::hir::def::Namespace;\n use crate::mir::ProjectionKind;\n+use crate::mir::interpret;\n use crate::ty::{self, Lift, Ty, TyCtxt, InferConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n+\n use rustc_index::vec::{IndexVec, Idx};\n use smallvec::SmallVec;\n-use crate::mir::interpret;\n \n use std::fmt;\n use std::rc::Rc;"}, {"sha": "b72468a6ff98bfc9b73a7de171a8b7093fd3941f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -2,51 +2,55 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n+use self::InferTy::*;\n+use self::TyKind::*;\n+\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n use crate::mir::interpret::ConstValue;\n use crate::middle::region;\n-use polonius_engine::Atom;\n-use rustc_index::vec::Idx;\n-use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, GenericArg, GenericArgKind};\n use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, GlobalId};\n \n+use polonius_engine::Atom;\n+use rustc_index::vec::Idx;\n+use rustc_macros::HashStable;\n+use rustc_target::spec::abi;\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::ops::Range;\n-use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n use syntax::symbol::{kw, Symbol};\n \n-use self::InferTy::*;\n-use self::TyKind::*;\n-\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n+#[derive(\n+    Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable,\n+    HashStable, TypeFoldable, Lift,\n+)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(\n+    Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable, RustcDecodable, Copy, HashStable,\n+)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n     pub scope: DefId,\n     pub bound_region: BoundRegion,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(\n+    Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable, RustcDecodable, Copy, HashStable,\n+)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -471,26 +475,26 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n-    /// Generator have not been resumed yet\n+    /// Generator has not been resumed yet.\n     pub const UNRESUMED: usize = 0;\n-    /// Generator has returned / is completed\n+    /// Generator has returned or is completed.\n     pub const RETURNED: usize = 1;\n-    /// Generator has been poisoned\n+    /// Generator has been poisoned.\n     pub const POISONED: usize = 2;\n \n     const UNRESUMED_NAME: &'static str = \"Unresumed\";\n     const RETURNED_NAME: &'static str = \"Returned\";\n     const POISONED_NAME: &'static str = \"Panicked\";\n \n-    /// The valid variant indices of this Generator.\n+    /// The valid variant indices of this generator.\n     #[inline]\n     pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'tcx>) -> Range<VariantIdx> {\n         // FIXME requires optimized MIR\n         let num_variants = tcx.generator_layout(def_id).variant_fields.len();\n         (VariantIdx::new(0)..VariantIdx::new(num_variants))\n     }\n \n-    /// The discriminant for the given variant. Panics if the variant_index is\n+    /// The discriminant for the given variant. Panics if the `variant_index` is\n     /// out of range.\n     #[inline]\n     pub fn discriminant_for_variant(\n@@ -505,7 +509,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         Discr { val: variant_index.as_usize() as u128, ty: self.discr_ty(tcx) }\n     }\n \n-    /// The set of all discriminants for the Generator, enumerated with their\n+    /// The set of all discriminants for the generator, enumerated with their\n     /// variant indices.\n     #[inline]\n     pub fn discriminants(\n@@ -670,12 +674,12 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n         match self[0] {\n             ExistentialPredicate::Trait(tr) => Some(tr),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n     pub fn principal_def_id(&self) -> Option<DefId> {\n-        self.principal().map(|d| d.def_id)\n+        self.principal().map(|trait_ref| trait_ref.def_id)\n     }\n \n     #[inline]\n@@ -684,7 +688,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     {\n         self.iter().filter_map(|predicate| {\n             match *predicate {\n-                ExistentialPredicate::Projection(p) => Some(p),\n+                ExistentialPredicate::Projection(projection) => Some(projection),\n                 _ => None,\n             }\n         })\n@@ -694,8 +698,8 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n         self.iter().filter_map(|predicate| {\n             match *predicate {\n-                ExistentialPredicate::AutoTrait(d) => Some(d),\n-                _ => None\n+                ExistentialPredicate::AutoTrait(did) => Some(did),\n+                _ => None,\n             }\n         })\n     }\n@@ -722,7 +726,8 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     }\n \n     pub fn iter<'a>(&'a self)\n-        -> impl DoubleEndedIterator<Item = Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n+        -> impl DoubleEndedIterator<Item = Binder<ExistentialPredicate<'tcx>>> + 'tcx\n+    {\n         self.skip_binder().iter().cloned().map(Binder::bind)\n     }\n }\n@@ -751,7 +756,7 @@ pub struct TraitRef<'tcx> {\n \n impl<'tcx> TraitRef<'tcx> {\n     pub fn new(def_id: DefId, substs: SubstsRef<'tcx>) -> TraitRef<'tcx> {\n-        TraitRef { def_id: def_id, substs: substs }\n+        TraitRef { def_id, substs }\n     }\n \n     /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`\n@@ -822,7 +827,7 @@ pub struct ExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'b {\n+    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'b {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -1296,7 +1301,7 @@ pub enum RegionKind {\n     /// A region variable. Should not exist after typeck.\n     ReVar(RegionVid),\n \n-    /// A placeholder region - basically the higher-ranked version of ReFree.\n+    /// A placeholder region -- basically, the higher-ranked version of `ReFree`.\n     /// Should not exist after typeck.\n     RePlaceholder(ty::PlaceholderRegion),\n \n@@ -1807,14 +1812,14 @@ impl<'tcx> TyS<'tcx> {\n         match self.kind {\n             Array(ty, _) | Slice(ty) => ty,\n             Str => tcx.mk_mach_uint(ast::UintTy::U8),\n-            _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n+            _ => bug!(\"`sequence_element_type` called on non-sequence value: {}\", self),\n         }\n     }\n \n     pub fn simd_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind {\n             Adt(def, substs) => def.non_enum_variant().fields[0].ty(tcx, substs),\n-            _ => bug!(\"simd_type called on invalid type\")\n+            _ => bug!(\"`simd_type` called on invalid type\"),\n         }\n     }\n \n@@ -1823,7 +1828,7 @@ impl<'tcx> TyS<'tcx> {\n         // allow `#[repr(simd)] struct Simd<T, const N: usize>([T; N]);`.\n         match self.kind {\n             Adt(def, _) => def.non_enum_variant().fields.len() as u64,\n-            _ => bug!(\"simd_size called on invalid type\")\n+            _ => bug!(\"`simd_size` called on invalid type\"),\n         }\n     }\n \n@@ -1833,7 +1838,7 @@ impl<'tcx> TyS<'tcx> {\n                 let variant = def.non_enum_variant();\n                 (variant.fields.len() as u64, variant.fields[0].ty(tcx, substs))\n             }\n-            _ => bug!(\"simd_size_and_type called on invalid type\")\n+            _ => bug!(\"`simd_size_and_type` called on invalid type\"),\n         }\n     }\n \n@@ -1894,7 +1899,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// panics if called on any type other than `Box<T>`\n+    /// Panics if called on any type other than `Box<T>`.\n     pub fn boxed_ty(&self) -> Ty<'tcx> {\n         match self.kind {\n             Adt(def, substs) if def.is_box() => substs.type_at(0),\n@@ -2114,7 +2119,8 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     /// If the type contains variants, returns the valid range of variant indices.\n-    /// FIXME This requires the optimized MIR in the case of generators.\n+    //\n+    // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n     pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n         match self.kind {\n@@ -2127,7 +2133,8 @@ impl<'tcx> TyS<'tcx> {\n \n     /// If the type contains variants, returns the variant for `variant_index`.\n     /// Panics if `variant_index` is out of range.\n-    /// FIXME This requires the optimized MIR in the case of generators.\n+    //\n+    // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n     pub fn discriminant_for_variant(\n         &self,\n@@ -2142,7 +2149,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Push onto `out` the regions directly referenced from this type (but not\n+    /// Pushes onto `out` the regions directly referenced from this type (but not\n     /// types reachable from this type via `walk_tys`). This ignores late-bound\n     /// regions binders.\n     pub fn push_regions(&self, out: &mut SmallVec<[ty::Region<'tcx>; 4]>) {\n@@ -2255,7 +2262,7 @@ impl<'tcx> TyS<'tcx> {\n             ty::Infer(ty::FreshTy(_)) |\n             ty::Infer(ty::FreshIntTy(_)) |\n             ty::Infer(ty::FreshFloatTy(_)) =>\n-                bug!(\"is_trivially_sized applied to unexpected type: {:?}\", self),\n+                bug!(\"`is_trivially_sized` applied to unexpected type: {:?}\", self),\n         }\n     }\n }"}, {"sha": "0c9fbfe6641897da94c4a5640657cdc43185d8bc", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -333,14 +333,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty\n     }\n \n-    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// Same as applying `struct_tail` on `source` and `target`, but only\n     /// keeps going as long as the two types are instances of the same\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n     ///\n     /// Should only be called if the types have no inference variables and do\n-    /// not need their lifetimes preserved (e.g. as part of codegen); otherwise\n+    /// not need their lifetimes preserved (e.g., as part of codegen); otherwise,\n     /// normalization attempt may cause compiler bugs.\n     pub fn struct_lockstep_tails_erasing_lifetimes(self,\n                                                    source: Ty<'tcx>,\n@@ -353,7 +353,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             source, target, |ty| tcx.normalize_erasing_regions(param_env, ty))\n     }\n \n-    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// Same as applying `struct_tail` on `source` and `target`, but only\n     /// keeps going as long as the two types are instances of the same\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,"}, {"sha": "804a7af41f39a8f814959f482cf5eedf9a168a3d", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,16 +1,15 @@\n-use crate::llvm::{self, AttributePlace};\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n+use crate::llvm::{self, AttributePlace};\n use crate::type_::Type;\n+use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n-use crate::type_of::{LayoutLlvmExt};\n+\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n-use rustc_target::abi::call::ArgAbi;\n-\n use rustc_codegen_ssa::traits::*;\n-\n+use rustc_target::abi::call::ArgAbi;\n use rustc_target::abi::{HasDataLayout, LayoutOf};\n use rustc::ty::{Ty};\n use rustc::ty::layout::{self};\n@@ -202,7 +201,7 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         if self.is_sized_indirect() {\n             OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n-            bug!(\"unsized ArgAbi must be handled through store_fn_arg\");\n+            bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n@@ -232,10 +231,10 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 let llscratch = bx.alloca(cast.llvm_type(bx), scratch_align);\n                 bx.lifetime_start(llscratch, scratch_size);\n \n-                // ...where we first store the value...\n+                // ... where we first store the value...\n                 bx.store(val, llscratch, scratch_align);\n \n-                // ...and then memcpy it to the intended destination.\n+                // ... and then memcpy it to the intended destination.\n                 bx.memcpy(\n                     dst.llval,\n                     self.layout.align.abi,"}, {"sha": "b3a8fa2988785da9ed8f028f46fcab63ebda7c0e", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -140,7 +140,7 @@\n //! In order for link-time optimization to work properly, LLVM needs a unique\n //! type identifier that tells it across compilation units which types are the\n //! same as others. This type identifier is created by\n-//! TypeMap::get_unique_type_id_of_type() using the following algorithm:\n+//! `TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n //!\n //! (1) Primitive types have their name as ID\n //! (2) Structs, enums and traits have a multipart identifier"}, {"sha": "2e16ae4c73f88283ee492ecfbe8ce65e40d9048b", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 126, "deletions": 129, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -7,16 +7,16 @@ use super::utils::{debug_context, DIB, span_start,\n use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::CrateDebugContext;\n-use crate::abi;\n-use crate::value::Value;\n-use rustc_codegen_ssa::traits::*;\n \n+use crate::abi;\n+use crate::common::CodegenCx;\n use crate::llvm;\n use crate::llvm::debuginfo::{DIArray, DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags, DebugEmissionKind};\n use crate::llvm_util;\n+use crate::value::Value;\n \n-use crate::common::CodegenCx;\n+use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def::CtorKind;\n@@ -36,6 +36,9 @@ use rustc::util::nodemap::FxHashMap;\n use rustc_fs_util::path_to_c_string;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::abi::HasDataLayout;\n+use syntax::ast;\n+use syntax::symbol::{Interner, Symbol};\n+use syntax_pos::{self, Span, FileName};\n \n use libc::{c_uint, c_longlong};\n use std::collections::hash_map::Entry;\n@@ -45,9 +48,6 @@ use std::hash::{Hash, Hasher};\n use std::iter;\n use std::ptr;\n use std::path::{Path, PathBuf};\n-use syntax::ast;\n-use syntax::symbol::{Interner, Symbol};\n-use syntax_pos::{self, Span, FileName};\n \n impl PartialEq for llvm::Metadata {\n     fn eq(&self, other: &Self) -> bool {\n@@ -70,7 +70,7 @@ impl fmt::Debug for llvm::Metadata {\n }\n \n // From DWARF 5.\n-// See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n+// See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1.\n const DW_LANG_RUST: c_uint = 0x1c;\n #[allow(non_upper_case_globals)]\n const DW_ATE_boolean: c_uint = 0x02;\n@@ -91,70 +91,70 @@ pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n #[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n pub struct UniqueTypeId(ast::Name);\n \n-// The TypeMap is where the CrateDebugContext holds the type metadata nodes\n-// created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n-// faster lookup, also by Ty. The TypeMap is responsible for creating\n-// UniqueTypeIds.\n+/// The `TypeMap` is where the `CrateDebugContext` holds the type metadata nodes\n+/// created so far. The metadata nodes are indexed by `UniqueTypeId`, and, for\n+/// faster lookup, also by `Ty`. The `TypeMap` is responsible for creating\n+/// `UniqueTypeId`s.\n #[derive(Default)]\n pub struct TypeMap<'ll, 'tcx> {\n-    // The UniqueTypeIds created so far\n+    /// The `UniqueTypeId`s created so far.\n     unique_id_interner: Interner,\n-    // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n+    /// A map from `UniqueTypeId` to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FxHashMap<UniqueTypeId, &'ll DIType>,\n-    // A map from types to debuginfo metadata. This is a N:1 mapping.\n+    /// A map from types to debuginfo metadata. This is an N:1 mapping.\n     type_to_metadata: FxHashMap<Ty<'tcx>, &'ll DIType>,\n-    // A map from types to UniqueTypeId. This is a N:1 mapping.\n+    /// A map from types to `UniqueTypeId`. This is an N:1 mapping.\n     type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n impl TypeMap<'ll, 'tcx> {\n-    // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n-    // the mapping already exists.\n+    /// Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n+    /// the mapping already exists.\n     fn register_type_with_metadata(\n         &mut self,\n         type_: Ty<'tcx>,\n         metadata: &'ll DIType,\n     ) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            bug!(\"Type metadata for Ty '{}' is already in the TypeMap!\", type_);\n+            bug!(\"type metadata for `Ty` '{}' is already in the `TypeMap`!\", type_);\n         }\n     }\n \n-    // Removes a Ty to metadata mapping\n-    // This is useful when computing the metadata for a potentially\n-    // recursive type (e.g. a function ptr of the form:\n-    //\n-    // fn foo() -> impl Copy { foo }\n-    //\n-    // This kind of type cannot be properly represented\n-    // via LLVM debuginfo. As a workaround,\n-    // we register a temporary Ty to metadata mapping\n-    // for the function before we compute its actual metadata.\n-    // If the metadata computation ends up recursing back to the\n-    // original function, it will use the temporary mapping\n-    // for the inner self-reference, preventing us from\n-    // recursing forever.\n-    //\n-    // This function is used to remove the temporary metadata\n-    // mapping after we've computed the actual metadata\n+    /// Removes a `Ty`-to-metadata mapping.\n+    /// This is useful when computing the metadata for a potentially\n+    /// recursive type (e.g., a function pointer of the form:\n+    ///\n+    ///     fn foo() -> impl Copy { foo }\n+    ///\n+    /// This kind of type cannot be properly represented\n+    /// via LLVM debuginfo. As a workaround,\n+    /// we register a temporary Ty to metadata mapping\n+    /// for the function before we compute its actual metadata.\n+    /// If the metadata computation ends up recursing back to the\n+    /// original function, it will use the temporary mapping\n+    /// for the inner self-reference, preventing us from\n+    /// recursing forever.\n+    ///\n+    /// This function is used to remove the temporary metadata\n+    /// mapping after we've computed the actual metadata.\n     fn remove_type(\n         &mut self,\n         type_: Ty<'tcx>,\n     ) {\n         if self.type_to_metadata.remove(type_).is_none() {\n-            bug!(\"Type metadata Ty '{}' is not in the TypeMap!\", type_);\n+            bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", type_);\n         }\n     }\n \n-    // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n-    // fail if the mapping already exists.\n+    /// Adds a `UniqueTypeId` to metadata mapping to the `TypeMap`. The method will\n+    /// fail if the mapping already exists.\n     fn register_unique_id_with_metadata(\n         &mut self,\n         unique_type_id: UniqueTypeId,\n         metadata: &'ll DIType,\n     ) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+            bug!(\"type metadata for unique ID '{}' is already in the `TypeMap`!\",\n                  self.get_unique_type_id_as_string(unique_type_id));\n         }\n     }\n@@ -167,23 +167,23 @@ impl TypeMap<'ll, 'tcx> {\n         self.unique_id_to_metadata.get(&unique_type_id).cloned()\n     }\n \n-    // Get the string representation of a UniqueTypeId. This method will fail if\n-    // the id is unknown.\n+    /// Gets the string representation of a `UniqueTypeId`. This method will fail if\n+    /// the ID is unknown.\n     fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> &str {\n         let UniqueTypeId(interner_key) = unique_type_id;\n         self.unique_id_interner.get(interner_key)\n     }\n \n-    // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n-    // type has been requested before, this is just a table lookup. Otherwise an\n-    // ID will be generated and stored for later lookup.\n+    /// Gets the `UniqueTypeId` for the given type. If the `UniqueTypeId` for the given\n+    /// type has been requested before, this is just a table lookup. Otherwise, an\n+    /// ID will be generated and stored for later lookup.\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CodegenCx<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n-        // Let's see if we already have something in the cache\n+        // Let's see if we already have something in the cache.\n         if let Some(unique_type_id) = self.type_to_unique_id.get(&type_).cloned() {\n             return unique_type_id;\n         }\n-        // if not, generate one\n+        // If not, generate one.\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n@@ -203,9 +203,9 @@ impl TypeMap<'ll, 'tcx> {\n         return UniqueTypeId(key);\n     }\n \n-    // Get the UniqueTypeId for an enum variant. Enum variants are not really\n-    // types of their own, so they need special handling. We still need a\n-    // UniqueTypeId for them, since to debuginfo they *are* real types.\n+    /// Gets the `UniqueTypeId` for an enum variant. Enum variants are not really\n+    /// types of their own, so they need special handling. We still need a\n+    /// `UniqueTypeId` for them, since to debuginfo they *are* real types.\n     fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n                                               cx: &CodegenCx<'a, 'tcx>,\n                                               enum_type: Ty<'tcx>,\n@@ -219,9 +219,9 @@ impl TypeMap<'ll, 'tcx> {\n         UniqueTypeId(interner_key)\n     }\n \n-    // Get the unique type id string for an enum variant part.\n-    // Variant parts are not types and shouldn't really have their own id,\n-    // but it makes set_members_of_composite_type() simpler.\n+    /// Gets the unique type ID string for an enum variant part.\n+    /// Variant parts are not types and shouldn't really have their own ID,\n+    /// but it makes `set_members_of_composite_type()` simpler.\n     fn get_unique_type_id_str_of_enum_variant_part(&mut self, enum_type_id: UniqueTypeId) -> &str {\n         let variant_part_type_id = format!(\"{}_variant_part\",\n                                            self.get_unique_type_id_as_string(enum_type_id));\n@@ -230,11 +230,11 @@ impl TypeMap<'ll, 'tcx> {\n     }\n }\n \n-// A description of some recursive type. It can either be already finished (as\n-// with FinalMetadata) or it is not yet finished, but contains all information\n-// needed to generate the missing parts of the description. See the\n-// documentation section on Recursive Types at the top of this file for more\n-// information.\n+/// A description of some recursive type. It can either be already finished (as\n+/// with `FinalMetadata`) or it is not yet finished, but contains all information\n+/// needed to generate the missing parts of the description. See the\n+/// documentation section on Recursive Types at the top of this file for more\n+/// information.\n enum RecursiveTypeDescription<'ll, 'tcx> {\n     UnfinishedMetadata {\n         unfinished_type: Ty<'tcx>,\n@@ -255,7 +255,7 @@ fn create_and_register_recursive_type_forward_declaration(\n     member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n \n-    // Insert the stub into the TypeMap in order to allow for recursive references\n+    // Insert the stub into the `TypeMap` in order to allow for recursive references.\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n     type_map.register_unique_id_with_metadata(unique_type_id, metadata_stub);\n     type_map.register_type_with_metadata(unfinished_type, metadata_stub);\n@@ -270,9 +270,9 @@ fn create_and_register_recursive_type_forward_declaration(\n }\n \n impl RecursiveTypeDescription<'ll, 'tcx> {\n-    // Finishes up the description of the type in question (mostly by providing\n-    // descriptions of the fields of the given type) and returns the final type\n-    // metadata.\n+    /// Finishes up the description of the type in question (mostly by providing\n+    /// descriptions of the fields of the given type) and returns the final type\n+    /// metadata.\n     fn finalize(&self, cx: &CodegenCx<'ll, 'tcx>) -> MetadataCreationResult<'ll> {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n@@ -287,7 +287,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                 // the TypeMap so that recursive references are possible. This\n                 // will always be the case if the RecursiveTypeDescription has\n                 // been properly created through the\n-                // create_and_register_recursive_type_forward_declaration()\n+                // `create_and_register_recursive_type_forward_declaration()`\n                 // function.\n                 {\n                     let type_map = debug_context(cx).type_map.borrow();\n@@ -314,8 +314,8 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n     }\n }\n \n-// Returns from the enclosing function if the type metadata with the given\n-// unique id can be found in the type map\n+/// Returns from the enclosing function if the type metadata with the given\n+/// unique ID can be found in the type map.\n macro_rules! return_if_metadata_created_in_meantime {\n     ($cx: expr, $unique_type_id: expr) => (\n         if let Some(metadata) = debug_context($cx).type_map\n@@ -527,19 +527,19 @@ pub fn type_metadata(\n     t: Ty<'tcx>,\n     usage_site_span: Span,\n ) -> &'ll DIType {\n-    // Get the unique type id of this type.\n+    // Get the unique type ID of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n-        // First, try to find the type in TypeMap. If we have seen it before, we\n+        // First, try to find the type in `TypeMap`. If we have seen it before, we\n         // can exit early here.\n         match type_map.find_metadata_for_type(t) {\n             Some(metadata) => {\n                 return metadata;\n             },\n             None => {\n-                // The Ty is not in the TypeMap but maybe we have already seen\n+                // The Ty is not in the `TypeMap` but maybe we have already seen\n                 // an equivalent type (e.g., only differing in region arguments).\n-                // In order to find out, generate the unique type id and look\n+                // In order to find out, generate the unique type ID and look\n                 // that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n                 match type_map.find_metadata_for_unique_id(unique_type_id) {\n@@ -647,15 +647,15 @@ pub fn type_metadata(\n             //\n             // fn foo() -> impl Copy { foo }\n             //\n-            // See TypeMap::remove_type for more detals\n-            // about the workaround\n+            // See `TypeMap::remove_type` for more detals\n+            // about the workaround.\n \n             let temp_type = {\n                 unsafe {\n                     // The choice of type here is pretty arbitrary -\n                     // anything reading the debuginfo for a recursive\n                     // type is going to see *somthing* weird - the only\n-                    // question is what exactly it will see\n+                    // question is what exactly it will see.\n                     let (size, align) = cx.size_and_align_of(t);\n                     llvm::LLVMRustDIBuilderCreateBasicType(\n                         DIB(cx),\n@@ -677,7 +677,7 @@ pub fn type_metadata(\n             type_map.borrow_mut().remove_type(t);\n \n \n-            // This is actually a function pointer, so wrap it in pointer DI\n+            // This is actually a function pointer, so wrap it in pointer DI.\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n@@ -743,14 +743,14 @@ pub fn type_metadata(\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n \n         if already_stored_in_typemap {\n-            // Also make sure that we already have a TypeMap entry for the unique type id.\n+            // Also make sure that we already have a `TypeMap` entry for the unique type ID.\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n                     span_bug!(usage_site_span,\n-                              \"Expected type metadata for unique \\\n-                               type id '{}' to already be in \\\n-                               the debuginfo::TypeMap but it \\\n+                              \"expected type metadata for unique \\\n+                               type ID '{}' to already be in \\\n+                               the `debuginfo::TypeMap` but it \\\n                                was not. (Ty = {})\",\n                               type_map.get_unique_type_id_as_string(unique_type_id),\n                               t);\n@@ -761,9 +761,9 @@ pub fn type_metadata(\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n                         span_bug!(usage_site_span,\n-                                  \"Mismatch between Ty and \\\n-                                   UniqueTypeId maps in \\\n-                                   debuginfo::TypeMap. \\\n+                                  \"mismatch between `Ty` and \\\n+                                   `UniqueTypeId` maps in \\\n+                                   `debuginfo::TypeMap`. \\\n                                    UniqueTypeId={}, Ty={}\",\n                                   type_map.get_unique_type_id_as_string(unique_type_id),\n                                   t);\n@@ -851,7 +851,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n         ty::Float(float_ty) => {\n             (float_ty.name_str(), DW_ATE_float)\n         },\n-        _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n+        _ => bug!(\"debuginfo::basic_type_metadata - `t` is invalid type\")\n     };\n \n     let (size, align) = cx.size_and_align_of(t);\n@@ -908,7 +908,7 @@ pub fn compile_unit_metadata(\n     };\n \n     // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n-    // if multiple object files with the same DW_AT_name are linked together.\n+    // if multiple object files with the same `DW_AT_name` are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n     // not correspond to an actual source file but that should be harmless.\n     if tcx.sess.target.target.options.is_like_osx {\n@@ -935,11 +935,9 @@ pub fn compile_unit_metadata(\n     //\n     //    This should actually be\n     //\n-    //    ```\n-    //      let kind = DebugEmissionKind::from_generic(tcx.sess.opts.debuginfo);\n-    //    ```\n+    //        let kind = DebugEmissionKind::from_generic(tcx.sess.opts.debuginfo);\n     //\n-    //    that is, we should set LLVM's emission kind to `LineTablesOnly` if\n+    //    That is, we should set LLVM's emission kind to `LineTablesOnly` if\n     //    we are compiling with \"limited\" debuginfo. However, some of the\n     //    existing tools relied on slightly more debuginfo being generated than\n     //    would be the case with `LineTablesOnly`, and we did not want to break\n@@ -1029,8 +1027,8 @@ impl MetadataCreationResult<'ll> {\n     }\n }\n \n-// Description of a type member, which can either be a regular field (as in\n-// structs or tuples) or an enum variant.\n+/// Description of a type member, which can either be a regular field (as in\n+/// structs or tuples) or an enum variant.\n #[derive(Debug)]\n struct MemberDescription<'ll> {\n     name: String,\n@@ -1067,10 +1065,10 @@ impl<'ll> MemberDescription<'ll> {\n     }\n }\n \n-// A factory for MemberDescriptions. It produces a list of member descriptions\n-// for some record-like type. MemberDescriptionFactories are used to defer the\n-// creation of type member descriptions in order to break cycles arising from\n-// recursive type definitions.\n+/// A factory for `MemberDescription`s. It produces a list of member descriptions\n+/// for some record-like type. `MemberDescriptionFactory`s are used to defer the\n+/// creation of type member descriptions in order to break cycles arising from\n+/// recursive type definitions.\n enum MemberDescriptionFactory<'ll, 'tcx> {\n     StructMDF(StructMemberDescriptionFactory<'tcx>),\n     TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n@@ -1106,7 +1104,7 @@ impl MemberDescriptionFactory<'ll, 'tcx> {\n // Structs\n //=-----------------------------------------------------------------------------\n \n-// Creates MemberDescriptions for the fields of a struct\n+/// Creates `MemberDescription`s for the fields of a struct.\n struct StructMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n@@ -1177,7 +1175,7 @@ fn prepare_struct_metadata(\n // Tuples\n //=-----------------------------------------------------------------------------\n \n-// Creates MemberDescriptions for the fields of a tuple\n+/// Creates `MemberDescription`s for the fields of a tuple.\n struct TupleMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     component_types: Vec<Ty<'tcx>>,\n@@ -1300,14 +1298,14 @@ fn prepare_union_metadata(\n // Enums\n //=-----------------------------------------------------------------------------\n \n-// DWARF variant support is only available starting in LLVM 8.\n-// Although the earlier enum debug info output did not work properly\n-// in all situations, it is better for the time being to continue to\n-// sometimes emit the old style rather than emit something completely\n-// useless when rust is compiled against LLVM 6 or older. LLVM 7\n-// contains an early version of the DWARF variant support, and will\n-// crash when handling the new debug info format. This function\n-// decides which representation will be emitted.\n+/// DWARF variant support is only available starting in LLVM 8.\n+/// Although the earlier enum debug info output did not work properly\n+/// in all situations, it is better for the time being to continue to\n+/// sometimes emit the old style rather than emit something completely\n+/// useless when rust is compiled against LLVM 6 or older. LLVM 7\n+/// contains an early version of the DWARF variant support, and will\n+/// crash when handling the new debug info format. This function\n+/// decides which representation will be emitted.\n fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n     // On MSVC we have to use the fallback mode, because LLVM doesn't\n     // lower variant parts to PDB.\n@@ -1318,11 +1316,11 @@ fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n         || llvm_util::get_major_version() < 8;\n }\n \n-// Describes the members of an enum value: An enum is described as a union of\n-// structs in DWARF. This MemberDescriptionFactory provides the description for\n-// the members of this union; so for every variant of the given enum, this\n-// factory will produce one MemberDescription (all with no name and a fixed\n-// offset of zero bytes).\n+/// Describes the members of an enum value; an enum is described as a union of\n+/// structs in DWARF. This `MemberDescriptionFactory` provides the description for\n+/// the members of this union; so for every variant of the given enum, this\n+/// factory will produce one `MemberDescription` (all with no name and a fixed\n+/// offset of zero bytes).\n struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyLayout<'tcx>,\n@@ -1456,7 +1454,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n-                    // Create a description of the non-null variant\n+                    // Create a description of the non-null variant.\n                     let (variant_type_metadata, member_description_factory) =\n                         describe_enum_variant(cx,\n                                               variant,\n@@ -1566,9 +1564,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     }\n }\n \n-// Creates MemberDescriptions for the fields of a single enum variant.\n+// Creates `MemberDescription`s for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n-    // Cloned from the layout::Struct describing the variant.\n+    /// Cloned from the `layout::Struct` describing the variant.\n     offsets: Vec<layout::Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<&'ll DIType>,\n@@ -1652,10 +1650,10 @@ impl<'tcx> VariantInfo<'tcx> {\n     }\n }\n \n-// Returns a tuple of (1) type_metadata_stub of the variant, (2) a\n-// MemberDescriptionFactory for producing the descriptions of the\n-// fields of the variant. This is a rudimentary version of a full\n-// RecursiveTypeDescription.\n+/// Returns a tuple of (1) `type_metadata_stub` of the variant, (2) a\n+/// `MemberDescriptionFactory` for producing the descriptions of the\n+/// fields of the variant. This is a rudimentary version of a full\n+/// `RecursiveTypeDescription`.\n fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyLayout<'tcx>,\n@@ -2088,8 +2086,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, 'tcx>,\n     }\n }\n \n-// Compute the type parameters for a type, if any, for the given\n-// metadata.\n+/// Computes the type parameters for a type, if any, for the given metadata.\n fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'ll DIArray> {\n     if let ty::Adt(def, substs) = ty.kind {\n         if !substs.types().next().is_none() {\n@@ -2134,9 +2131,9 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n     }\n }\n \n-// A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n-// any caching, does not add any fields to the struct. This can be done later\n-// with set_members_of_composite_type().\n+/// A convenience wrapper around `LLVMRustDIBuilderCreateStructType()`. Does not do\n+/// any caching, does not add any fields to the struct. This can be done later\n+/// with `set_members_of_composite_type()`.\n fn create_struct_stub(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n@@ -2151,9 +2148,9 @@ fn create_struct_stub(\n         debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n     );\n     let metadata_stub = unsafe {\n-        // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n+        // `LLVMRustDIBuilderCreateStructType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n-        // later on in llvm/lib/IR/Value.cpp.\n+        // later on in `llvm/lib/IR/Value.cpp`.\n         let empty_array = create_DIArray(DIB(cx), &[]);\n \n         llvm::LLVMRustDIBuilderCreateStructType(\n@@ -2189,9 +2186,9 @@ fn create_union_stub(\n         debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id)\n     );\n     let metadata_stub = unsafe {\n-        // LLVMRustDIBuilderCreateUnionType() wants an empty array. A null\n+        // `LLVMRustDIBuilderCreateUnionType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n-        // later on in llvm/lib/IR/Value.cpp.\n+        // later on in `llvm/lib/IR/Value.cpp`.\n         let empty_array = create_DIArray(DIB(cx), &[]);\n \n         llvm::LLVMRustDIBuilderCreateUnionType(\n@@ -2231,8 +2228,8 @@ pub fn create_global_var_metadata(\n     }\n \n     let no_mangle = attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE);\n-    // We may want to remove the namespace scope if we're in an extern block, see:\n-    // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952\n+    // We may want to remove the namespace scope if we're in an extern block (see\n+    // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952).\n     let var_scope = get_namespace_for_item(cx, def_id);\n     let span = tcx.def_span(def_id);\n \n@@ -2287,14 +2284,14 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n     let type_metadata = type_metadata(cx, ty, syntax_pos::DUMMY_SP);\n \n     unsafe {\n-        // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n+        // `LLVMRustDIBuilderCreateStructType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n-        // later on in llvm/lib/IR/Value.cpp.\n+        // later on in `llvm/lib/IR/Value.cpp`.\n         let empty_array = create_DIArray(DIB(cx), &[]);\n \n         let name = const_cstr!(\"vtable\");\n \n-        // Create a new one each time.  We don't want metadata caching\n+        // Create a new one each time. We don't want metadata caching\n         // here, because each vtable will refer to a unique containing\n         // type.\n         let vtable_type = llvm::LLVMRustDIBuilderCreateStructType(\n@@ -2327,7 +2324,7 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n     }\n }\n \n-// Creates an \"extension\" of an existing DIScope into another file.\n+/// Creates an \"extension\" of an existing `DIScope` into another file.\n pub fn extend_scope_to_file(\n     cx: &CodegenCx<'ll, '_>,\n     scope_metadata: &'ll DIScope,"}, {"sha": "12ec4e107487405bcae9deeb2732cc9ceba4882b", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -152,7 +152,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                         match scalar.value {\n                             Primitive::Int(..) => {\n                                 if self.cx().size_of(ret_ty).bytes() < 4 {\n-                                    // va_arg should not be called on a integer type\n+                                    // `va_arg` should not be called on a integer type\n                                     // less than 4 bytes in length. If it is, promote\n                                     // the integer to a `i32` and truncate the result\n                                     // back to the smaller type."}, {"sha": "22693beb855d2143fee2f6a4262756bd3310bc7e", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,28 +1,40 @@\n //! Codegen the completed AST to the LLVM IR.\n //!\n-//! Some functions here, such as codegen_block and codegen_expr, return a value --\n-//! the result of the codegen to LLVM -- while others, such as codegen_fn\n-//! and mono_item, are called only for the side effect of adding a\n+//! Some functions here, such as `codegen_block` and `codegen_expr`, return a value --\n+//! the result of the codegen to LLVM -- while others, such as `codegen_fn`\n+//! and `mono_item`, are called only for the side effect of adding a\n //! particular definition to the LLVM IR output we're producing.\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//! * There's no way to find out the `Ty` type of a Value. Doing so\n+//! * There's no way to find out the `Ty` type of a `Value`. Doing so\n //!   would be \"trying to get the eggs out of an omelette\" (credit:\n //!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n //!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n-use crate::{ModuleCodegen, ModuleKind, CachedModuleCodegen};\n+use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n+use crate::back::write::{\n+    OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n+    submit_post_lto_module_to_llvm,\n+};\n+use crate::common::{RealPredicate, TypeKind, IntPredicate};\n+use crate::meth;\n+use crate::mir;\n+use crate::mir::operand::OperandValue;\n+use crate::mir::place::PlaceRef;\n+use crate::traits::*;\n \n use rustc::dep_graph::cgu_reuse_tracker::CguReuse;\n+use rustc::hir;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit, MonoItem};\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry, set_time_depth, time_depth};\n@@ -31,25 +43,12 @@ use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use rustc_index::vec::Idx;\n use rustc_codegen_utils::{symbol_names_test, check_for_rustc_errors_attr};\n-use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n-use crate::mir::place::PlaceRef;\n-use crate::back::write::{OngoingCodegen, start_async_codegen, submit_pre_lto_module_to_llvm,\n-    submit_post_lto_module_to_llvm};\n-use crate::{MemFlags, CrateInfo};\n-use crate::common::{RealPredicate, TypeKind, IntPredicate};\n-use crate::meth;\n-use crate::mir;\n-\n-use crate::traits::*;\n+use syntax::attr;\n+use syntax_pos::Span;\n \n use std::cmp;\n use std::ops::{Deref, DerefMut};\n use std::time::{Instant, Duration};\n-use syntax_pos::Span;\n-use syntax::attr;\n-use rustc::hir;\n-\n-use crate::mir::operand::OperandValue;\n \n pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n                                 signed: bool)\n@@ -116,9 +115,8 @@ pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n /// Retrieves the information we are losing (making dynamic) in an unsizing\n /// adjustment.\n ///\n-/// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be derived\n-/// from the old one.\n+/// The `old_info` argument is a bit odd. It is intended for use in an upcast,\n+/// where the new vtable for an object will be derived from the old one.\n pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n     cx: &Cx,\n     source: Ty<'tcx>,\n@@ -140,16 +138,19 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n         (_, &ty::Dynamic(ref data, ..)) => {\n             let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target))\n                 .field(cx, FAT_PTR_EXTRA);\n-            cx.const_ptrcast(meth::get_vtable(cx, source, data.principal()),\n-                            cx.backend_type(vtable_ptr))\n+            cx.const_ptrcast(\n+                meth::get_vtable(cx, source, data.principal()),\n+                cx.backend_type(vtable_ptr),\n+            )\n         }\n-        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n-                  source,\n-                  target),\n+        _ => bug!(\n+            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n+            source, target\n+        ),\n     }\n }\n \n-/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+/// Coerces `src` to `dst_ty`. `src_ty` must be a thin pointer.\n pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     src: Bx::Value,\n@@ -199,8 +200,8 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-/// Coerce `src`, which is a reference to a value of type `src_ty`,\n-/// to a value of type `dst_ty` and store the result in `dst`\n+/// Coerces `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty`, and stores the result in `dst`.\n pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     src: PlaceRef<'tcx, Bx::Value>,\n@@ -244,15 +245,17 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n                     memcpy_ty(bx, dst_f.llval, dst_f.align, src_f.llval, src_f.align,\n-                              src_f.layout, MemFlags::empty());\n+                        src_f.layout, MemFlags::empty());\n                 } else {\n                     coerce_unsized_into(bx, src_f, dst_f);\n                 }\n             }\n         }\n-        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-                  src_ty,\n-                  dst_ty),\n+        _ => bug!(\n+            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+            src_ty,\n+            dst_ty,\n+        ),\n     }\n }\n "}, {"sha": "c14618a15eaebf8f4133333209402d110ecb7751", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,8 +1,7 @@\n-use rustc_target::abi::call::FnAbi;\n-\n use crate::traits::*;\n \n use rustc::ty::{self, Ty, Instance};\n+use rustc_target::abi::call::FnAbi;\n \n #[derive(Copy, Clone, Debug)]\n pub struct VirtualIndex(u64);\n@@ -20,7 +19,7 @@ impl<'a, 'tcx> VirtualIndex {\n         self,\n         bx: &mut Bx,\n         llvtable: Bx::Value,\n-        fn_abi: &FnAbi<'tcx, Ty<'tcx>>\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n     ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n@@ -33,15 +32,15 @@ impl<'a, 'tcx> VirtualIndex {\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);\n         let ptr = bx.load(gep, ptr_align);\n         bx.nonnull_metadata(ptr);\n-        // Vtable loads are invariant\n+        // Vtable loads are invariant.\n         bx.set_invariant_load(ptr);\n         ptr\n     }\n \n     pub fn get_usize<Bx: BuilderMethods<'a, 'tcx>>(\n         self,\n         bx: &mut Bx,\n-        llvtable: Bx::Value\n+        llvtable: Bx::Value,\n     ) -> Bx::Value {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n@@ -50,7 +49,7 @@ impl<'a, 'tcx> VirtualIndex {\n         let usize_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);\n         let ptr = bx.load(gep, usize_align);\n-        // Vtable loads are invariant\n+        // Vtable loads are invariant.\n         bx.set_invariant_load(ptr);\n         ptr\n     }\n@@ -63,7 +62,7 @@ impl<'a, 'tcx> VirtualIndex {\n ///\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<dyn Trait>` from a value of type `Foo<T>`, then\n-/// `trait_ref` would map `T:Trait`.\n+/// `trait_ref` would map `T: Trait`.\n pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     cx: &Cx,\n     ty: Ty<'tcx>,\n@@ -78,7 +77,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         return val;\n     }\n \n-    // Not in the cache. Build it.\n+    // Not in the cache; build it.\n     let nullptr = cx.const_null(cx.type_i8p());\n \n     let methods_root;\n@@ -105,7 +104,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     let layout = cx.layout_of(ty);\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     // If you touch this code, be sure to also make the corresponding changes to\n-    // `get_vtable` in rust_mir/interpret/traits.rs\n+    // `get_vtable` in `rust_mir/interpret/traits.rs`.\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n         cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty)),"}, {"sha": "1fa3da29999b03ad2d0a45acabe0aa50aee2125b", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,18 +1,17 @@\n-use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n-use rustc::mir;\n-use rustc::ty;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n+use super::{FunctionCx, LocalRef};\n+use super::place::PlaceRef;\n \n-use crate::base;\n use crate::MemFlags;\n+use crate::base;\n use crate::glue;\n-\n use crate::traits::*;\n \n-use std::fmt;\n+use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n+use rustc::mir;\n+use rustc::ty;\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, Size};\n \n-use super::{FunctionCx, LocalRef};\n-use super::place::PlaceRef;\n+use std::fmt;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -343,6 +342,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n             }\n         }\n     }\n+\n     pub fn store_unsized<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,"}, {"sha": "4df5bce95377bce8780415d5925e8d7e5aa0f8ff", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,28 +1,28 @@\n-use rustc::ty::{self, Instance, Ty};\n-use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n-use rustc::mir;\n-use rustc::mir::tcx::PlaceTy;\n+use super::{FunctionCx, LocalRef};\n+use super::operand::OperandValue;\n+\n use crate::MemFlags;\n use crate::common::IntPredicate;\n use crate::glue;\n-\n use crate::traits::*;\n \n-use super::{FunctionCx, LocalRef};\n-use super::operand::OperandValue;\n+use rustc::ty::{self, Instance, Ty};\n+use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n+use rustc::mir;\n+use rustc::mir::tcx::PlaceTy;\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx, V> {\n-    /// Pointer to the contents of the place.\n+    /// A pointer to the contents of the place.\n     pub llval: V,\n \n-    /// This place's extra data if it is unsized, or null.\n+    /// This place's extra data if it is unsized, or `None` if null.\n     pub llextra: Option<V>,\n \n-    /// Monomorphized type of this place, including variant information.\n+    /// The monomorphized type of this place, including variant information.\n     pub layout: TyLayout<'tcx>,\n \n-    /// What alignment we know for this place.\n+    /// The alignment we know for this place.\n     pub align: Align,\n }\n \n@@ -107,7 +107,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n         }\n     }\n-\n }\n \n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {"}, {"sha": "f7fb4a571401cf29f3f8c46b41175892d9f3f714", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,22 +1,22 @@\n+use super::{FunctionCx, LocalRef};\n+use super::operand::{OperandRef, OperandValue};\n+use super::place::PlaceRef;\n+\n+use crate::base;\n+use crate::MemFlags;\n+use crate::common::{self, RealPredicate, IntPredicate};\n+use crate::traits::*;\n+\n use rustc::ty::{self, Ty, adjustment::{PointerCast}, Instance};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n-use std::{u128, i128};\n use syntax::symbol::sym;\n use syntax::source_map::{DUMMY_SP, Span};\n \n-use crate::base;\n-use crate::MemFlags;\n-use crate::common::{self, RealPredicate, IntPredicate};\n-\n-use crate::traits::*;\n-\n-use super::{FunctionCx, LocalRef};\n-use super::operand::{OperandRef, OperandValue};\n-use super::place::PlaceRef;\n+use std::{u128, i128};\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_rvalue(\n@@ -31,8 +31,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n                let cg_operand = self.codegen_operand(&mut bx, operand);\n-               // FIXME: consider not copying constants through stack. (fixable by codegenning\n-               // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n+               // FIXME: consider not copying constants through stack. (Fixable by codegen'ing\n+               // constants into `OperandValue::Ref`; why don\u2019t we do that yet if we don\u2019t?)\n                cg_operand.val.store(&mut bx, dest);\n                bx\n            }\n@@ -41,7 +41,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // The destination necessarily contains a fat pointer, so if\n                 // it's a scalar pair, it's a fat pointer or newtype thereof.\n                 if bx.cx().is_backend_scalar_pair(dest.layout) {\n-                    // into-coerce of a thin pointer to a fat pointer - just\n+                    // Into-coerce of a thin pointer to a fat pointer -- just\n                     // use the operand path.\n                     let (mut bx, temp) = self.codegen_rvalue_operand(bx, rvalue);\n                     temp.val.store(&mut bx, dest);\n@@ -56,10 +56,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 match operand.val {\n                     OperandValue::Pair(..) |\n                     OperandValue::Immediate(_) => {\n-                        // unsize from an immediate structure. We don't\n+                        // Unsize from an immediate structure. We don't\n                         // really need a temporary alloca here, but\n                         // avoiding it would require us to have\n-                        // `coerce_unsized_into` use extractvalue to\n+                        // `coerce_unsized_into` use `extractvalue` to\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n@@ -74,7 +74,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         base::coerce_unsized_into(&mut bx, source, dest);\n                     }\n                     OperandValue::Ref(_, Some(_), _) => {\n-                        bug!(\"unsized coercion on an unsized rvalue\")\n+                        bug!(\"unsized coercion on an unsized rvalue\");\n                     }\n                 }\n                 bx\n@@ -160,7 +160,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx\n             }\n \n-            _ => bug!(\"unsized assignment other than Rvalue::Use\"),\n+            _ => bug!(\"unsized assignment other than `Rvalue::Use`\"),\n         }\n     }\n \n@@ -220,17 +220,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        // this is a no-op at the LLVM level\n+                        // This is a no-op at the LLVM level.\n                         operand.val\n                     }\n                     mir::CastKind::Pointer(PointerCast::Unsize) => {\n                         assert!(bx.cx().is_backend_scalar_pair(cast));\n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n-                                // unsize from a fat pointer - this is a\n+                                // unsize from a fat pointer -- this is a\n                                 // \"trait-object-to-supertrait\" coercion, for\n-                                // example,\n-                                //   &'a fmt::Debug+Send => &'a fmt::Debug,\n+                                // example, `&'a fmt::Debug + Send => &'a fmt::Debug`.\n \n                                 // HACK(eddyb) have to bitcast pointers\n                                 // until LLVM removes pointee types.\n@@ -245,13 +244,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Ref(..) => {\n-                                bug!(\"by-ref operand {:?} in codegen_rvalue_operand\",\n+                                bug!(\"by-ref operand {:?} in `codegen_rvalue_operand`\",\n                                      operand);\n                             }\n                         }\n                     }\n-                    mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n-                    | mir::CastKind::Misc if bx.cx().is_backend_scalar_pair(operand.layout) => {\n+                    mir::CastKind::Pointer(PointerCast::MutToConstPointer) |\n+                    mir::CastKind::Misc if bx.cx().is_backend_scalar_pair(operand.layout) => {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if bx.cx().is_backend_scalar_pair(cast) {\n                                 let data_cast = bx.pointercast(data_ptr,\n@@ -265,12 +264,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n-                            bug!(\"Unexpected non-Pair operand\")\n+                            bug!(\"unexpected non-pair operand\");\n                         }\n                     }\n-                    mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n-                    | mir::CastKind::Pointer(PointerCast::ArrayToPointer)\n-                    | mir::CastKind::Misc => {\n+                    mir::CastKind::Pointer(PointerCast::MutToConstPointer) |\n+                    mir::CastKind::Pointer(PointerCast::ArrayToPointer) |\n+                    mir::CastKind::Misc => {\n                         assert!(bx.cx().is_backend_immediate(cast));\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {"}, {"sha": "cfaa6756261e4bb372db8949c35ff2a2072d4c2d", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,17 +1,18 @@\n-use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyLayout};\n-use rustc::ty::Ty;\n-\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n+\n+use rustc::ty::layout::{HasTyCtxt, LayoutOf, TyLayout};\n+use rustc::ty::Ty;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::{Session, config};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use std::sync::Arc;\n-use std::sync::mpsc;\n use syntax::expand::allocator::AllocatorKind;\n use syntax_pos::symbol::Symbol;\n \n+use std::sync::Arc;\n+use std::sync::mpsc;\n+\n pub trait BackendTypes {\n     type Value: CodegenObject;\n     type Function: CodegenObject;"}, {"sha": "31044d4eb4f275452137fbf49a82f1b4f35c5e78", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -4,14 +4,17 @@ use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgAbiMethods;\n use super::{HasCodegen, StaticBuilderMethods};\n+\n use crate::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate,\n     SynchronizationScope};\n use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n+\n use rustc::ty::Ty;\n use rustc::ty::layout::{Align, Size, HasParamEnv};\n-use rustc_target::spec::{HasTargetSpec};\n+use rustc_target::spec::HasTargetSpec;\n+\n use std::ops::Range;\n use std::iter::TrustedLen;\n "}, {"sha": "9b673de8b078820776e96885ea1aa0db11082af7", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -41,9 +41,9 @@ pub use self::type_::{\n     ArgAbiMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n-use rustc::ty::layout::{HasParamEnv, HasTyCtxt};\n-use rustc_target::spec::{HasTargetSpec};\n \n+use rustc::ty::layout::{HasParamEnv, HasTyCtxt};\n+use rustc_target::spec::HasTargetSpec;\n \n use std::fmt;\n "}, {"sha": "27ea0039354e7163e35153fa1a646f81172743bd", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -224,7 +224,7 @@ impl Diagnostic {\n             }));\n         msg.push((format!(\"`{}\", found_extra), Style::NoStyle));\n \n-        // For now, just attach these as notes\n+        // For now, just attach these as notes.\n         self.highlighted_note(msg);\n         self\n     }"}, {"sha": "8dda51cd7717249cb4b7c3f84685baf3b8e33890", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,6 +1,7 @@\n use crate::hair::{self, *};\n use crate::hair::cx::Cx;\n use crate::hair::cx::to_ref::ToRef;\n+\n use rustc::middle::region;\n use rustc::hir;\n use rustc::ty;"}, {"sha": "4f03b1320903a48f2eeee8fe52c0be58435514ba", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -136,7 +136,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    op: Operand<Tag>, // Keep this private, it helps enforce invariants\n+    op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -203,7 +203,7 @@ pub(super) fn from_known_layout<'tcx>(\n             if cfg!(debug_assertions) {\n                 let layout2 = compute()?;\n                 assert_eq!(layout.details, layout2.details,\n-                    \"Mismatch in layout of supposedly equal-layout types {:?} and {:?}\",\n+                    \"mismatch in layout of supposedly equal-layout types {:?} and {:?}\",\n                     layout.ty, layout2.ty);\n             }\n             Ok(layout)"}, {"sha": "5b263f768013186ebab2d718c8c2159be6394600", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -48,7 +48,7 @@ pub enum Place<Tag=(), Id=AllocId> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag=()> {\n-    place: Place<Tag>, // Keep this private, it helps enforce invariants\n+    place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyLayout<'tcx>,\n }\n "}, {"sha": "3a7f47a2aaca915f66977ed206701d5c087b9361", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,16 +1,16 @@\n+use super::{InterpCx, Machine, MemoryKind, FnVal};\n+\n use rustc::ty::{self, Ty, Instance, TypeFoldable};\n use rustc::ty::layout::{Size, Align, LayoutOf, HasDataLayout};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n-use super::{InterpCx, Machine, MemoryKind, FnVal};\n-\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///\n-    /// The `trait_ref` encodes the erased self type. Hence if we are\n+    /// The `trait_ref` encodes the erased self type. Hence, if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n-    /// `trait_ref` would map `T:Trait`.\n+    /// `trait_ref` would map `T: Trait`.\n     pub fn get_vtable(\n         &mut self,\n         ty: Ty<'tcx>,\n@@ -51,7 +51,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let ptr_align = self.tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         // If you touch this code, be sure to also make the corresponding changes to\n-        // `get_vtable` in rust_codegen_llvm/meth.rs\n+        // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n@@ -97,16 +97,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(vtable)\n     }\n \n-    /// Resolve the function at the specified slot in the provided\n+    /// Resolves the function at the specified slot in the provided\n     /// vtable. An index of '0' corresponds to the first method\n-    /// declared in the trait of the provided vtable\n+    /// declared in the trait of the provided vtable.\n     pub fn get_vtable_slot(\n         &self,\n         vtable: Scalar<M::PointerTag>,\n         idx: usize\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n-        // Skip over the 'drop_ptr', 'size', and 'align' fields\n+        // Skip over the 'drop_ptr', 'size', and 'align' fields.\n         let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n         let vtable_slot = self.memory.check_ptr_access(\n             vtable_slot,\n@@ -118,12 +118,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(self.memory.get_fn(fn_ptr)?)\n     }\n \n-    /// Returns the drop fn instance as well as the actual dynamic type\n+    /// Returns the drop fn instance as well as the actual dynamic type.\n     pub fn read_drop_type_from_vtable(\n         &self,\n         vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n-        // we don't care about the pointee type, we just want a pointer\n+        // We don't care about the pointee type; we just want a pointer.\n         let vtable = self.memory.check_ptr_access(\n             vtable,\n             self.tcx.data_layout.pointer_size,\n@@ -149,7 +149,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n-        // We check for size = 3*ptr_size, that covers the drop fn (unused here),\n+        // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n         // the size, and the align (which we read below).\n         let vtable = self.memory.check_ptr_access(\n             vtable,"}, {"sha": "a4c4c7ff616d9865ef3718ae228d8912bbb1ade1", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,5 +1,5 @@\n //! Mono Item Collection\n-//! ===========================\n+//! ====================\n //!\n //! This module is responsible for discovering all items that will contribute to\n //! to code generation of the crate. The important part here is that it not only\n@@ -174,9 +174,10 @@\n //! this is not implemented however: a mono item will be produced\n //! regardless of whether it is actually needed or not.\n \n+use crate::monomorphize;\n+\n use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -189,8 +190,6 @@ use rustc::mir::{self, Location, PlaceBase, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::{MonoItem, InstantiationMode};\n use rustc::mir::interpret::{Scalar, GlobalId, GlobalAlloc, ErrorHandled};\n-\n-use crate::monomorphize;\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n use rustc::util::common::time;\n \n@@ -530,7 +529,6 @@ struct MirNeighborCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n-\n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n@@ -698,7 +696,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 }\n             }\n             PlaceBase::Local(_) => {\n-                // Locals have no relevance for collector\n+                // Locals have no relevance for collector.\n             }\n         }\n     }\n@@ -752,7 +750,7 @@ fn visit_instance_use<'tcx>(\n         ty::InstanceDef::ReifyShim(..) |\n         ty::InstanceDef::Virtual(..) |\n         ty::InstanceDef::DropGlue(_, None) => {\n-            // don't need to emit shim if we are calling directly.\n+            // Don't need to emit shim if we are calling directly.\n             if !is_direct_call {\n                 output.push(create_fn_mono_item(instance));\n             }\n@@ -769,8 +767,8 @@ fn visit_instance_use<'tcx>(\n     }\n }\n \n-// Returns true if we should codegen an instance in the local crate.\n-// Returns false if we can just link to the upstream crate and therefore don't\n+// Returns `true` if we should codegen an instance in the local crate.\n+// Returns `false` if we can just link to the upstream crate and therefore don't\n // need a mono item.\n fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) -> bool {\n     let def_id = match instance.def {\n@@ -786,24 +784,24 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n     };\n \n     if tcx.is_foreign_item(def_id) {\n-        // We can always link to foreign items\n+        // We can always link to foreign items.\n         return false;\n     }\n \n     if def_id.is_local() {\n-        // local items cannot be referred to locally without monomorphizing them locally\n+        // Local items cannot be referred to locally without monomorphizing them locally.\n         return true;\n     }\n \n     if tcx.is_reachable_non_generic(def_id) ||\n        is_available_upstream_generic(tcx, def_id, instance.substs) {\n         // We can link to the item in question, no instance needed\n-        // in this crate\n+        // in this crate.\n         return false;\n     }\n \n     if !tcx.is_mir_available(def_id) {\n-        bug!(\"Cannot create local mono-item for {:?}\", def_id)\n+        bug!(\"cannot create local mono-item for {:?}\", def_id)\n     }\n     return true;\n \n@@ -823,7 +821,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n \n         // If this instance has non-erasable parameters, it cannot be a shared\n         // monomorphization. Non-generic instances are already handled above\n-        // by `is_reachable_non_generic()`\n+        // by `is_reachable_non_generic()`.\n         if substs.non_erasable_generics().next().is_none() {\n             return false\n         }\n@@ -836,7 +834,7 @@ fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx\n     }\n }\n \n-/// For given pair of source and target type that occur in an unsizing coercion,\n+/// For a given pair of source and target type that occur in an unsizing coercion,\n /// this function finds the pair of types that determines the vtable linking\n /// them.\n ///\n@@ -930,10 +928,9 @@ fn find_vtable_types_for_unsizing<'tcx>(\n                     source_fields.len() == target_fields.len());\n \n             find_vtable_types_for_unsizing(tcx,\n-                                           source_fields[coerce_index].ty(tcx,\n-                                                                          source_substs),\n-                                           target_fields[coerce_index].ty(tcx,\n-                                                                          target_substs))\n+                source_fields[coerce_index].ty(tcx, source_substs),\n+                target_fields[coerce_index].ty(tcx, target_substs)\n+            )\n         }\n         _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n                   source_ty,\n@@ -975,7 +972,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n             output.extend(methods);\n         }\n \n-        // Also add the destructor\n+        // Also add the destructor.\n         visit_drop_use(tcx, impl_ty, false, output);\n     }\n }\n@@ -995,14 +992,14 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.kind {\n             hir::ItemKind::ExternCrate(..) |\n-            hir::ItemKind::Use(..)         |\n-            hir::ItemKind::ForeignMod(..)  |\n-            hir::ItemKind::TyAlias(..)          |\n-            hir::ItemKind::Trait(..)       |\n-            hir::ItemKind::TraitAlias(..)  |\n+            hir::ItemKind::Use(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::TyAlias(..) |\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) |\n             hir::ItemKind::OpaqueTy(..) |\n-            hir::ItemKind::Mod(..)         => {\n-                // Nothing to do, just keep recursing...\n+            hir::ItemKind::Mod(..) => {\n+                // Nothing to do, just keep recursing.\n             }\n \n             hir::ItemKind::Impl(..) => {\n@@ -1075,7 +1072,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n                 self.push_if_root(def_id);\n             }\n-            _ => { /* Nothing to do here */ }\n+            _ => { /* nothing to do here */ }\n         }\n     }\n }\n@@ -1095,7 +1092,7 @@ impl RootCollector<'_, 'v> {\n         }\n     }\n \n-    /// If `def_id` represents a root, then push it onto the list of\n+    /// If `def_id` represents a root, pushes it onto the list of\n     /// outputs. (Note that all roots must be monomorphic.)\n     fn push_if_root(&mut self, def_id: DefId) {\n         if self.is_root(def_id) {\n@@ -1217,7 +1214,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n     }\n }\n \n-/// Scan the miri alloc in order to find function calls, closures, and drop-glue\n+/// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n     let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n     match alloc_kind {\n@@ -1244,7 +1241,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n     }\n }\n \n-/// Scan the MIR in order to find function calls, closures, and drop-glue\n+/// Scans the MIR in order to find function calls, closures, and drop-glue.\n fn collect_neighbours<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,"}, {"sha": "db8caed629c171670d2a683b20a42824ba5af6d6", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -22,7 +22,7 @@ pub fn custom_coerce_unsize_info<'tcx>(\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n         vtable => {\n-            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n+            bug!(\"invalid `CoerceUnsized` vtable: {:?}\", vtable);\n         }\n     }\n }"}, {"sha": "3113e9b241daa3f03225dc775bb2310e1af3cc22", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -3,6 +3,7 @@\n // substitutions.\n \n use crate::check::FnCtxt;\n+\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -12,10 +13,11 @@ use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n-use std::mem;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n+use std::mem;\n+\n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n \n@@ -481,8 +483,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.kind {\n                 if let hir::OpaqueTyOrigin::TypeAlias = opaque_defn.origin {\n                     if def_id == defin_ty_def_id {\n-                        debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n-                               opaque_defn, defin_ty_def_id);\n+                        debug!(\n+                            \"skipping adding concrete definition for opaque type {:?} {:?}\",\n+                            opaque_defn, defin_ty_def_id\n+                        );\n                         skip_add = true;\n                     }\n                 }\n@@ -507,8 +511,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n                             span_bug!(\n                                 span,\n-                                \"visit_opaque_types tried to write different types for the same \\\n-                                opaque type: {:?}, {:?}, {:?}, {:?}\",\n+                                \"`visit_opaque_types` tried to write different types for the same \\\n+                                 opaque type: {:?}, {:?}, {:?}, {:?}\",\n                                 def_id,\n                                 definition_ty,\n                                 opaque_defn,"}, {"sha": "721890db4fbd7f73b41b7bd482463fb6cd886f56", "filename": "src/test/ui/rfc-2027-object-safe-for-dispatch/manual-self-impl-for-unsafe-obj.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fmanual-self-impl-for-unsafe-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fmanual-self-impl-for-unsafe-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2027-object-safe-for-dispatch%2Fmanual-self-impl-for-unsafe-obj.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,6 +1,5 @@\n-// Check that we can manually implement an object\n-// unsafe trait for its trait object\n-//\n+// Check that we can manually implement an object-unsafe trait for its trait object.\n+\n // run-pass\n \n #![feature(object_safe_for_dispatch)]\n@@ -46,7 +45,7 @@ fn main() {\n \n     let mut res = String::new();\n \n-    // Directly call static\n+    // Directly call static.\n     res.push(Struct::stat()); // \"A\"\n     res.push(<dyn Bad>::stat()); // \"AC\"\n \n@@ -55,15 +54,13 @@ fn main() {\n     // These look similar enough...\n     let bad = unsafe { std::mem::transmute::<&dyn Good, &dyn Bad>(good) };\n \n-    // Call virtual\n+    // Call virtual.\n     res.push(s.virt()); // \"ACB\"\n     res.push(bad.virt()); // \"ACBD\"\n \n-    // Indirectly call static\n+    // Indirectly call static.\n     res.push(s.indirect()); // \"ACBDA\"\n     res.push(bad.indirect()); // \"ACBDAC\"\n \n-    if &res != \"ACBDAC\" {\n-        panic!();\n-    }\n+    assert_eq!(&res, \"ACBDAC\");\n }"}, {"sha": "82c76eb693a0d65efb5d29e00eff0357db9b0f73", "filename": "src/test/ui/traits/principal-less-trait-objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Ftest%2Fui%2Ftraits%2Fprincipal-less-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f11759d38c70d3df67135f88a682701c1cf9762a/src%2Ftest%2Fui%2Ftraits%2Fprincipal-less-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fprincipal-less-trait-objects.rs?ref=f11759d38c70d3df67135f88a682701c1cf9762a", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// Check that trait-objects without a principal codegen properly.\n+// Check that trait objects without a principal codegen properly.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::mem;\n@@ -10,7 +10,7 @@ use std::mem;\n struct SetOnDrop<'a>(&'a AtomicUsize, [u8; 64]);\n impl<'a> Drop for SetOnDrop<'a> {\n     fn drop(&mut self) {\n-        self.0.store(self.0.load(Ordering::Relaxed)+1, Ordering::Relaxed);\n+        self.0.store(self.0.load(Ordering::Relaxed) + 1, Ordering::Relaxed);\n     }\n }\n "}]}