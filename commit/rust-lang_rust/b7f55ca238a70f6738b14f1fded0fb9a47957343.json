{"sha": "b7f55ca238a70f6738b14f1fded0fb9a47957343", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZjU1Y2EyMzhhNzBmNjczOGIxNGYxZmRlZDBmYjlhNDc5NTczNDM=", "commit": {"author": {"name": "Alexey Shmalko", "email": "rasen.dubi@gmail.com", "date": "2019-04-29T17:39:55Z"}, "committer": {"name": "Alexey Shmalko", "email": "rasen.dubi@gmail.com", "date": "2019-05-02T13:38:29Z"}, "message": "Assign group and parse since for Feature", "tree": {"sha": "1fb52717f10be98257c93038e480532c486d8271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fb52717f10be98257c93038e480532c486d8271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7f55ca238a70f6738b14f1fded0fb9a47957343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f55ca238a70f6738b14f1fded0fb9a47957343", "html_url": "https://github.com/rust-lang/rust/commit/b7f55ca238a70f6738b14f1fded0fb9a47957343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7f55ca238a70f6738b14f1fded0fb9a47957343/comments", "author": {"login": "rasendubi", "id": 1366419, "node_id": "MDQ6VXNlcjEzNjY0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1366419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasendubi", "html_url": "https://github.com/rasendubi", "followers_url": "https://api.github.com/users/rasendubi/followers", "following_url": "https://api.github.com/users/rasendubi/following{/other_user}", "gists_url": "https://api.github.com/users/rasendubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasendubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasendubi/subscriptions", "organizations_url": "https://api.github.com/users/rasendubi/orgs", "repos_url": "https://api.github.com/users/rasendubi/repos", "events_url": "https://api.github.com/users/rasendubi/events{/privacy}", "received_events_url": "https://api.github.com/users/rasendubi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasendubi", "id": 1366419, "node_id": "MDQ6VXNlcjEzNjY0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1366419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasendubi", "html_url": "https://github.com/rasendubi", "followers_url": "https://api.github.com/users/rasendubi/followers", "following_url": "https://api.github.com/users/rasendubi/following{/other_user}", "gists_url": "https://api.github.com/users/rasendubi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasendubi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasendubi/subscriptions", "organizations_url": "https://api.github.com/users/rasendubi/orgs", "repos_url": "https://api.github.com/users/rasendubi/repos", "events_url": "https://api.github.com/users/rasendubi/events{/privacy}", "received_events_url": "https://api.github.com/users/rasendubi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b82f685a57d6a1a3567c2ca6e77efedbedefac2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b82f685a57d6a1a3567c2ca6e77efedbedefac2", "html_url": "https://github.com/rust-lang/rust/commit/8b82f685a57d6a1a3567c2ca6e77efedbedefac2"}], "stats": {"total": 128, "additions": 117, "deletions": 11}, "files": [{"sha": "fe2aa0fd70fe35b445948df7b99aaedbb5d60394", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b7f55ca238a70f6738b14f1fded0fb9a47957343/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f55ca238a70f6738b14f1fded0fb9a47957343/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=b7f55ca238a70f6738b14f1fded0fb9a47957343", "patch": "@@ -16,6 +16,12 @@ use std::path::Path;\n \n use regex::{Regex, escape};\n \n+mod version;\n+use self::version::Version;\n+\n+const FEATURE_GROUP_START_PREFIX: &str = \"// feature group start:\";\n+const FEATURE_GROUP_END_PREFIX: &str = \"// feature group end\";\n+\n #[derive(Debug, PartialEq, Clone)]\n pub enum Status {\n     Stable,\n@@ -37,9 +43,10 @@ impl fmt::Display for Status {\n #[derive(Debug, Clone)]\n pub struct Feature {\n     pub level: Status,\n-    pub since: String,\n+    pub since: Option<Version>,\n     pub has_gate_test: bool,\n     pub tracking_issue: Option<u32>,\n+    pub group: Option<String>,\n }\n \n pub type Features = HashMap<String, Feature>;\n@@ -136,14 +143,16 @@ pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n                            name,\n                            \"lang\",\n                            feature.level,\n-                           feature.since));\n+                           feature.since.as_ref().map_or(\"None\".to_owned(),\n+                                                         |since| since.to_string())));\n     }\n     for (name, feature) in lib_features {\n         lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n                            name,\n                            \"lib\",\n                            feature.level,\n-                           feature.since));\n+                           feature.since.as_ref().map_or(\"None\".to_owned(),\n+                                                         |since| since.to_string())));\n     }\n \n     lines.sort();\n@@ -188,6 +197,8 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n     // without one inside `// no tracking issue START` and `// no tracking issue END`.\n     let mut next_feature_omits_tracking_issue = false;\n \n+    let mut next_feature_group = None;\n+\n     contents.lines().zip(1..)\n         .filter_map(|(line, line_number)| {\n             let line = line.trim();\n@@ -205,6 +216,15 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                 _ => {}\n             }\n \n+            if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+                let group = line.trim_start_matches(FEATURE_GROUP_START_PREFIX).trim();\n+                next_feature_group = Some(group.to_owned());\n+                return None;\n+            } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n+                next_feature_group = None;\n+                return None;\n+            }\n+\n             let mut parts = line.split(',');\n             let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n                 Some(\"active\") => Status::Unstable,\n@@ -213,7 +233,20 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                 _ => return None,\n             };\n             let name = parts.next().unwrap().trim();\n-            let since = parts.next().unwrap().trim().trim_matches('\"');\n+            let since_str = parts.next().unwrap().trim().trim_matches('\"');\n+            let since = match since_str.parse() {\n+                Ok(since) => Some(since),\n+                Err(err) => {\n+                    tidy_error!(\n+                        bad,\n+                        \"libsyntax/feature_gate.rs:{}: failed to parse since: {} ({})\",\n+                        line_number,\n+                        since_str,\n+                        err,\n+                    );\n+                    None\n+                }\n+            };\n             let issue_str = parts.next().unwrap().trim();\n             let tracking_issue = if issue_str.starts_with(\"None\") {\n                 if level == Status::Unstable && !next_feature_omits_tracking_issue {\n@@ -233,9 +266,10 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n             Some((name.to_owned(),\n                 Feature {\n                     level,\n-                    since: since.to_owned(),\n+                    since,\n                     has_gate_test: false,\n                     tracking_issue,\n+                    group: next_feature_group.clone(),\n                 }))\n         })\n         .collect()\n@@ -250,9 +284,10 @@ pub fn collect_lib_features(base_src_path: &Path) -> Features {\n     // add it to the set of known library features so we can still generate docs.\n     lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n         level: Status::Unstable,\n-        since: String::new(),\n+        since: None,\n         has_gate_test: false,\n         tracking_issue: None,\n+        group: None,\n     });\n \n     map_lib_features(base_src_path,\n@@ -351,12 +386,13 @@ fn map_lib_features(base_src_path: &Path,\n                 };\n                 let feature = Feature {\n                     level: Status::Unstable,\n-                    since: \"None\".to_owned(),\n+                    since: None,\n                     has_gate_test: false,\n                     // FIXME(#57563): #57563 is now used as a common tracking issue,\n                     // although we would like to have specific tracking issues for each\n                     // `rustc_const_unstable` in the future.\n                     tracking_issue: Some(57563),\n+                    group: None,\n                 };\n                 mf(Ok((feature_name, feature)), file, i + 1);\n                 continue;\n@@ -372,20 +408,24 @@ fn map_lib_features(base_src_path: &Path,\n                 Some(name) => name,\n                 None => err!(\"malformed stability attribute\"),\n             };\n-            let since = match find_attr_val(line, \"since\") {\n-                Some(name) => name,\n+            let since = match find_attr_val(line, \"since\").map(|x| x.parse()) {\n+                Some(Ok(since)) => Some(since),\n+                Some(Err(_err)) => {\n+                    err!(\"malformed since attribute\");\n+                },\n                 None if level == Status::Stable => {\n                     err!(\"malformed stability attribute\");\n                 }\n-                None => \"None\",\n+                None => None,\n             };\n             let tracking_issue = find_attr_val(line, \"issue\").map(|s| s.parse().unwrap());\n \n             let feature = Feature {\n                 level,\n-                since: since.to_owned(),\n+                since,\n                 has_gate_test: false,\n                 tracking_issue,\n+                group: None,\n             };\n             if line.contains(']') {\n                 mf(Ok((feature_name, feature)), file, i + 1);"}, {"sha": "0bab1427be84981d56f0f59b016315c95d156016", "filename": "src/tools/tidy/src/features/version.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b7f55ca238a70f6738b14f1fded0fb9a47957343/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7f55ca238a70f6738b14f1fded0fb9a47957343/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs?ref=b7f55ca238a70f6738b14f1fded0fb9a47957343", "patch": "@@ -0,0 +1,66 @@\n+use std::str::FromStr;\n+use std::num::ParseIntError;\n+use std::fmt;\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Version {\n+    parts: Vec<u32>,\n+}\n+\n+impl fmt::Display for Version {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let x = self.parts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(\".\");\n+        f.pad(&x)\n+    }\n+}\n+\n+impl FromStr for Version {\n+    type Err = ParseIntError;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let parts = s.split('.').map(|part| part.parse()).collect::<Result<_, _>>()?;\n+        Ok(Version { parts })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Version;\n+\n+    #[test]\n+    fn test_try_from_invalid_version() {\n+        assert!(\"\".parse::<Version>().is_err());\n+        assert!(\"hello\".parse::<Version>().is_err());\n+        assert!(\"1.32.hi\".parse::<Version>().is_err());\n+        assert!(\"1.32..1\".parse::<Version>().is_err());\n+    }\n+\n+    #[test]\n+    fn test_try_from_single() {\n+        assert_eq!(\"1.32.0\".parse(), Ok(Version { parts: vec![1, 32, 0] }));\n+        assert_eq!(\"1.0.0\".parse(), Ok(Version { parts: vec![1, 0, 0] }));\n+    }\n+\n+    #[test]\n+    fn test_compare() {\n+        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+        let v_1_32 = \"1.32\".parse::<Version>().unwrap();\n+        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+        assert!(v_1_0_0 < v_1_32_1);\n+        assert!(v_1_0_0 < v_1_32);\n+        assert!(v_1_32 < v_1_32_1);\n+    }\n+\n+    #[test]\n+    fn test_to_string() {\n+        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+        let v_1_32 = \"1.32\".parse::<Version>().unwrap();\n+        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+\n+        assert_eq!(v_1_0_0.to_string(), \"1.0.0\");\n+        assert_eq!(v_1_32.to_string(), \"1.32\");\n+        assert_eq!(v_1_32_1.to_string(), \"1.32.1\");\n+        assert_eq!(format!(\"{:<8}\", v_1_32_1), \"1.32.1  \");\n+        assert_eq!(format!(\"{:>8}\", v_1_32_1), \"  1.32.1\");\n+    }\n+}"}]}