{"sha": "36b1d20c1661877c0c5a55ccd07522bc97bfc254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YjFkMjBjMTY2MTg3N2MwYzVhNTVjY2QwNzUyMmJjOTdiZmMyNTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-27T22:19:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-27T22:19:55Z"}, "message": "rename ModuleDescriptor -> Module", "tree": {"sha": "df84b92b2a05fa9cf1306b3a26bb4f5969fd0784", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df84b92b2a05fa9cf1306b3a26bb4f5969fd0784"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36b1d20c1661877c0c5a55ccd07522bc97bfc254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36b1d20c1661877c0c5a55ccd07522bc97bfc254", "html_url": "https://github.com/rust-lang/rust/commit/36b1d20c1661877c0c5a55ccd07522bc97bfc254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36b1d20c1661877c0c5a55ccd07522bc97bfc254/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16f67ee384d5b49358de167069535af727b87dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/16f67ee384d5b49358de167069535af727b87dba", "html_url": "https://github.com/rust-lang/rust/commit/16f67ee384d5b49358de167069535af727b87dba"}], "stats": {"total": 69, "additions": 34, "deletions": 35}, "files": [{"sha": "67ec9a735e3c4484be482f4c0ae556e300f4a61c", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=36b1d20c1661877c0c5a55ccd07522bc97bfc254", "patch": "@@ -11,9 +11,7 @@ use rustc_hash::{FxHashMap};\n \n use crate::{\n     db::{self, SyntaxDatabase},\n-    hir::\n-        ModuleDescriptor\n-    ,\n+    hir,\n     Cancelable, FilePosition\n };\n \n@@ -38,7 +36,7 @@ pub(crate) fn completions(\n         original_file.reparse(&edit)\n     };\n \n-    let module = ctry!(ModuleDescriptor::guess_from_position(db, position)?);\n+    let module = ctry!(hir::Module::guess_from_position(db, position)?);\n \n     let mut res = Vec::new();\n     let mut has_completions = false;"}, {"sha": "881d29916d45e7d5006dd153a10dc853f836e453", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=36b1d20c1661877c0c5a55ccd07522bc97bfc254", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     db::RootDatabase,\n     completion::CompletionItem,\n     hir::{\n-        ModuleDescriptor,\n+        self,\n         FnScopes,\n         Def,\n         Path,\n@@ -22,7 +22,7 @@ use crate::{\n pub(super) fn completions(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    module: &ModuleDescriptor,\n+    module: &hir::Module,\n     file: &SourceFileNode,\n     name_ref: ast::NameRef,\n ) -> Cancelable<()> {\n@@ -150,7 +150,7 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n fn complete_path(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    module: &ModuleDescriptor,\n+    module: &hir::Module,\n     mut path: Path,\n ) -> Cancelable<()> {\n     if path.segments.is_empty() {"}, {"sha": "1de8fadcfba085c2745f97cf4e410b64a17f5b5a", "filename": "crates/ra_analysis/src/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs?ref=36b1d20c1661877c0c5a55ccd07522bc97bfc254", "patch": "@@ -19,14 +19,14 @@ use crate::{\n \n pub(crate) use self::{\n     path::{Path, PathKind},\n-    module::{ModuleDescriptor, ModuleId, Problem, nameres::FileItemId},\n+    module::{Module, ModuleId, Problem, nameres::FileItemId},\n     function::{FunctionDescriptor, FnScopes},\n };\n \n pub use self::function::FnSignatureInfo;\n \n pub(crate) enum Def {\n-    Module(ModuleDescriptor),\n+    Module(Module),\n     Item,\n }\n \n@@ -35,7 +35,7 @@ impl DefId {\n         let loc = db.id_maps().def_loc(self);\n         let res = match loc {\n             DefLoc::Module { id, source_root } => {\n-                let descr = ModuleDescriptor::new(db, source_root, id)?;\n+                let descr = Module::new(db, source_root, id)?;\n                 Def::Module(descr)\n             }\n             DefLoc::Item { .. } => Def::Item,"}, {"sha": "33d2b95ab025a9eca159728eead1b3d46b72f702", "filename": "crates/ra_analysis/src/hir/module/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs?ref=36b1d20c1661877c0c5a55ccd07522bc97bfc254", "patch": "@@ -22,53 +22,53 @@ use crate::{\n \n pub(crate) use self::nameres::ModuleScope;\n \n-/// `ModuleDescriptor` is API entry point to get all the information\n+/// `Module` is API entry point to get all the information\n /// about a particular module.\n #[derive(Debug, Clone)]\n-pub(crate) struct ModuleDescriptor {\n+pub(crate) struct Module {\n     tree: Arc<ModuleTree>,\n     source_root_id: SourceRootId,\n     module_id: ModuleId,\n }\n \n-impl ModuleDescriptor {\n-    /// Lookup `ModuleDescriptor` by `FileId`. Note that this is inherently\n+impl Module {\n+    /// Lookup `Module` by `FileId`. Note that this is inherently\n     /// lossy transformation: in general, a single source might correspond to\n     /// several modules.\n     pub fn guess_from_file_id(\n         db: &impl HirDatabase,\n         file_id: FileId,\n-    ) -> Cancelable<Option<ModuleDescriptor>> {\n-        ModuleDescriptor::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n+    ) -> Cancelable<Option<Module>> {\n+        Module::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n     }\n \n-    /// Lookup `ModuleDescriptor` by position in the source code. Note that this\n+    /// Lookup `Module` by position in the source code. Note that this\n     /// is inherently lossy transformation: in general, a single source might\n     /// correspond to several modules.\n     pub fn guess_from_position(\n         db: &impl HirDatabase,\n         position: FilePosition,\n-    ) -> Cancelable<Option<ModuleDescriptor>> {\n+    ) -> Cancelable<Option<Module>> {\n         let file = db.file_syntax(position.file_id);\n         let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n         {\n             Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n             _ => ModuleSource::SourceFile(position.file_id),\n         };\n-        ModuleDescriptor::guess_from_source(db, position.file_id, module_source)\n+        Module::guess_from_source(db, position.file_id, module_source)\n     }\n \n     fn guess_from_source(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         module_source: ModuleSource,\n-    ) -> Cancelable<Option<ModuleDescriptor>> {\n+    ) -> Cancelable<Option<Module>> {\n         let source_root_id = db.file_source_root(file_id);\n         let module_tree = db.module_tree(source_root_id)?;\n \n         let res = match module_tree.any_module_for_source(module_source) {\n             None => None,\n-            Some(module_id) => Some(ModuleDescriptor {\n+            Some(module_id) => Some(Module {\n                 tree: module_tree,\n                 source_root_id,\n                 module_id,\n@@ -81,9 +81,9 @@ impl ModuleDescriptor {\n         db: &impl HirDatabase,\n         source_root_id: SourceRootId,\n         module_id: ModuleId,\n-    ) -> Cancelable<ModuleDescriptor> {\n+    ) -> Cancelable<Module> {\n         let module_tree = db.module_tree(source_root_id)?;\n-        let res = ModuleDescriptor {\n+        let res = Module {\n             tree: module_tree,\n             source_root_id,\n             module_id,\n@@ -105,18 +105,18 @@ impl ModuleDescriptor {\n     }\n \n     /// Parent module. Returns `None` if this is a root module.\n-    pub fn parent(&self) -> Option<ModuleDescriptor> {\n+    pub fn parent(&self) -> Option<Module> {\n         let parent_id = self.module_id.parent(&self.tree)?;\n-        Some(ModuleDescriptor {\n+        Some(Module {\n             module_id: parent_id,\n             ..self.clone()\n         })\n     }\n \n     /// The root of the tree this module is part of\n-    pub fn crate_root(&self) -> ModuleDescriptor {\n+    pub fn crate_root(&self) -> Module {\n         let root_id = self.module_id.crate_root(&self.tree);\n-        ModuleDescriptor {\n+        Module {\n             module_id: root_id,\n             ..self.clone()\n         }\n@@ -138,9 +138,9 @@ impl ModuleDescriptor {\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &str) -> Option<ModuleDescriptor> {\n+    pub fn child(&self, name: &str) -> Option<Module> {\n         let child_id = self.module_id.child(&self.tree, name)?;\n-        Some(ModuleDescriptor {\n+        Some(Module {\n             module_id: child_id,\n             ..self.clone()\n         })\n@@ -168,7 +168,7 @@ impl ModuleDescriptor {\n         let segments = path.segments;\n         for name in segments.iter() {\n             let module = match db.id_maps().def_loc(curr) {\n-                DefLoc::Module { id, source_root } => ModuleDescriptor::new(db, source_root, id)?,\n+                DefLoc::Module { id, source_root } => Module::new(db, source_root, id)?,\n                 _ => return Ok(None),\n             };\n             let scope = module.scope(db)?;"}, {"sha": "9118ed7d45de3336253be1ff7ba0af2e5b61d1f9", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36b1d20c1661877c0c5a55ccd07522bc97bfc254/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=36b1d20c1661877c0c5a55ccd07522bc97bfc254", "patch": "@@ -20,7 +20,8 @@ use crate::{\n     completion::{completions, CompletionItem},\n     db::{self, FileSyntaxQuery, SyntaxDatabase},\n     hir::{\n-        FunctionDescriptor, FnSignatureInfo, ModuleDescriptor,\n+        self,\n+        FunctionDescriptor, FnSignatureInfo,\n         Problem,\n     },\n     input::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE},\n@@ -226,7 +227,7 @@ impl AnalysisImpl {\n     /// This return `Vec`: a module may be included from several places. We\n     /// don't handle this case yet though, so the Vec has length at most one.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let descr = match ModuleDescriptor::guess_from_position(&*self.db, position)? {\n+        let descr = match hir::Module::guess_from_position(&*self.db, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -245,7 +246,7 @@ impl AnalysisImpl {\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let descr = match ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+        let descr = match hir::Module::guess_from_file_id(&*self.db, file_id)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -298,7 +299,7 @@ impl AnalysisImpl {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n                     let parent_module =\n-                        ModuleDescriptor::guess_from_file_id(&*self.db, position.file_id)?;\n+                        hir::Module::guess_from_file_id(&*self.db, position.file_id)?;\n                     let child_name = module.name();\n                     match (parent_module, child_name) {\n                         (Some(parent_module), Some(child_name)) => {\n@@ -380,7 +381,7 @@ impl AnalysisImpl {\n                 fix: None,\n             })\n             .collect::<Vec<_>>();\n-        if let Some(m) = ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+        if let Some(m) = hir::Module::guess_from_file_id(&*self.db, file_id)? {\n             for (name_node, problem) in m.problems(&*self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {"}]}