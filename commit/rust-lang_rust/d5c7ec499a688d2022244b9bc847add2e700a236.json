{"sha": "d5c7ec499a688d2022244b9bc847add2e700a236", "node_id": "C_kwDOAAsO6NoAKGQ1YzdlYzQ5OWE2ODhkMjAyMjI0NGI5YmM4NDdhZGQyZTcwMGEyMzY", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-28T12:15:35Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-28T12:15:35Z"}, "message": "fix stack overflow in `is_ty_uninhabited_from`", "tree": {"sha": "57f88d55420f203132525300f5c23660283d0282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57f88d55420f203132525300f5c23660283d0282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5c7ec499a688d2022244b9bc847add2e700a236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c7ec499a688d2022244b9bc847add2e700a236", "html_url": "https://github.com/rust-lang/rust/commit/d5c7ec499a688d2022244b9bc847add2e700a236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5c7ec499a688d2022244b9bc847add2e700a236/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a375ad668cde817d5ee18a5f96cbc7f3044b812e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a375ad668cde817d5ee18a5f96cbc7f3044b812e", "html_url": "https://github.com/rust-lang/rust/commit/a375ad668cde817d5ee18a5f96cbc7f3044b812e"}], "stats": {"total": 64, "additions": 59, "deletions": 5}, "files": [{"sha": "505f80f324f666e857aa271c8bb6bea46ce4ce68", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d5c7ec499a688d2022244b9bc847add2e700a236/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c7ec499a688d2022244b9bc847add2e700a236/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=d5c7ec499a688d2022244b9bc847add2e700a236", "patch": "@@ -1,5 +1,8 @@\n //! Type inhabitedness logic.\n-use std::ops::ControlFlow::{self, Break, Continue};\n+use std::{\n+    collections::HashMap,\n+    ops::ControlFlow::{self, Break, Continue},\n+};\n \n use chalk_ir::{\n     visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n@@ -9,14 +12,16 @@ use hir_def::{\n     adt::VariantData, attr::Attrs, visibility::Visibility, AdtId, EnumVariantId, HasModule, Lookup,\n     ModuleId, VariantId,\n };\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     consteval::try_const_usize, db::HirDatabase, Binders, Interner, Substitution, Ty, TyKind,\n };\n \n /// Checks whether a type is visibly uninhabited from a particular module.\n pub(crate) fn is_ty_uninhabited_from(ty: &Ty, target_mod: ModuleId, db: &dyn HirDatabase) -> bool {\n-    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let mut uninhabited_from =\n+        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: HashMap::default() };\n     let inhabitedness = ty.visit_with(&mut uninhabited_from, DebruijnIndex::INNERMOST);\n     inhabitedness == BREAK_VISIBLY_UNINHABITED\n }\n@@ -32,7 +37,8 @@ pub(crate) fn is_enum_variant_uninhabited_from(\n     let vars_attrs = db.variants_attrs(variant.parent);\n     let is_local = variant.parent.lookup(db.upcast()).container.krate() == target_mod.krate();\n \n-    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let mut uninhabited_from =\n+        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: HashMap::default() };\n     let inhabitedness = uninhabited_from.visit_variant(\n         variant.into(),\n         &enum_data.variants[variant.local_id].variant_data,\n@@ -45,6 +51,9 @@ pub(crate) fn is_enum_variant_uninhabited_from(\n \n struct UninhabitedFrom<'a> {\n     target_mod: ModuleId,\n+    recursive_ty: FxHashMap<Ty, ()>,\n+    // guard for preventing stack overflow in non trivial non terminating types\n+    max_depth: usize,\n     db: &'a dyn HirDatabase,\n }\n \n@@ -65,7 +74,14 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n         ty: &Ty,\n         outer_binder: DebruijnIndex,\n     ) -> ControlFlow<VisiblyUninhabited> {\n-        match ty.kind(Interner) {\n+        if self.recursive_ty.contains_key(ty) || self.max_depth == 0 {\n+            // rustc considers recursive types always inhabited. I think it is valid to consider\n+            // recursive types as always uninhabited, but we should do what rustc is doing.\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+        self.recursive_ty.insert(ty.clone(), ());\n+        self.max_depth -= 1;\n+        let r = match ty.kind(Interner) {\n             TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n             TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n             TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n@@ -75,7 +91,10 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n             },\n \n             TyKind::Ref(..) | _ => CONTINUE_OPAQUELY_INHABITED,\n-        }\n+        };\n+        self.recursive_ty.remove(ty);\n+        self.max_depth += 1;\n+        r\n     }\n \n     fn interner(&self) -> Interner {"}, {"sha": "0b66350894ae564c4365a45e669d5a2ffaffbd71", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d5c7ec499a688d2022244b9bc847add2e700a236/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c7ec499a688d2022244b9bc847add2e700a236/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=d5c7ec499a688d2022244b9bc847add2e700a236", "patch": "@@ -692,6 +692,41 @@ fn f(inp: (Foo, Foo, Foo, Foo)) {\n         );\n     }\n \n+    #[test]\n+    // FIXME: We should have tests for `is_ty_uninhabited_from`\n+    fn regression_14421() {\n+        check_diagnostics(\n+            r#\"\n+pub enum Tree {\n+    Node(TreeNode),\n+    Leaf(TreeLeaf),\n+}\n+\n+struct Box<T>(&T);\n+\n+pub struct TreeNode {\n+    pub depth: usize,\n+    pub children: [Box<Tree>; 8]\n+}\n+\n+pub struct TreeLeaf {\n+    pub depth: usize,\n+    pub data: u8\n+}\n+\n+pub fn test() {\n+    let mut tree = Tree::Leaf(\n+      //^^^^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        TreeLeaf {\n+            depth: 0,\n+            data: 0\n+        }\n+    );\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn fn_traits() {\n         check_diagnostics("}]}