{"sha": "252b5444daf83a9f1b18e2dfe4b46830d2be4447", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MmI1NDQ0ZGFmODNhOWYxYjE4ZTJkZmU0YjQ2ODMwZDJiZTQ0NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-05T23:05:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-05T23:05:04Z"}, "message": "Auto merge of #25129 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #24782, #25080, #25112, #25114, #25127\n- Failed merges:", "tree": {"sha": "b8d1a97b5f6db5f6a2048dfb71e8540287aec160", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8d1a97b5f6db5f6a2048dfb71e8540287aec160"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/252b5444daf83a9f1b18e2dfe4b46830d2be4447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/252b5444daf83a9f1b18e2dfe4b46830d2be4447", "html_url": "https://github.com/rust-lang/rust/commit/252b5444daf83a9f1b18e2dfe4b46830d2be4447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/252b5444daf83a9f1b18e2dfe4b46830d2be4447/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eae692e375cec222803efb7175c79fedc228eea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae692e375cec222803efb7175c79fedc228eea9", "html_url": "https://github.com/rust-lang/rust/commit/eae692e375cec222803efb7175c79fedc228eea9"}, {"sha": "d507c38e00977856e163276a9a501403237f10de", "url": "https://api.github.com/repos/rust-lang/rust/commits/d507c38e00977856e163276a9a501403237f10de", "html_url": "https://github.com/rust-lang/rust/commit/d507c38e00977856e163276a9a501403237f10de"}], "stats": {"total": 2373, "additions": 1778, "deletions": 595}, "files": [{"sha": "de7ded76280f6f103350a2105f2492d86eec7700", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -5,6 +5,7 @@\n     * [Hello, world!](hello-world.md)\n     * [Hello, Cargo!](hello-cargo.md)\n * [Learn Rust](learn-rust.md)\n+    * [Guessing Game](guessing-game.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)\n@@ -26,7 +27,6 @@\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n     * [Mutability](mutability.md)\n-    * [Move semantics](move-semantics.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n     * [Structs](structs.md)"}, {"sha": "431b7dc50a29983fa471b8e1490a892290f36a34", "filename": "src/doc/trpl/guessing-game.md", "status": "added", "additions": 999, "deletions": 0, "changes": 999, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -0,0 +1,999 @@\n+% Guessing Game\n+\n+For our first project, we\u2019ll implement a classic beginner programming problem:\n+the guessing game. Here\u2019s how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we\u2019re too low or too high. Once we\n+guess correctly, it will congratulate us. Sounds good?\n+\n+# Set up\n+\n+Let\u2019s set up a new project. Go to your projects directory. Remember how we had\n+to create our directory structure and a `Cargo.toml` for `hello_world`? Cargo\n+has a command that does that for us. Let\u2019s give it a shot:\n+\n+```bash\n+$ cd ~/projects\n+$ cargo new guessing_game --bin\n+$ cd guessing_game\n+```\n+\n+We pass the name of our project to `cargo new`, and then the `--bin` flag,\n+since we\u2019re making a binary, rather than a library.\n+\n+Check out the generated `Cargo.toml`:\n+\n+```toml\n+[package]\n+\n+name = \"guessing_game\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <you@example.com>\"]\n+```\n+\n+Cargo gets this information from your environment. If it\u2019s not correct, go ahead\n+and fix that.\n+\n+Finally, Cargo generated a \u2018Hello, world!\u2019 for us. Check out `src/main.rs`:\n+\n+```rust\n+fn main() {\n+    println!(\"Hello, world!\")\n+}\n+```\n+\n+Let\u2019s try compiling what Cargo gave us:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+```\n+\n+Excellent! Open up your `src/main.rs` again. We\u2019ll be writing all of\n+our code in this file.\n+\n+Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n+is kind of like `cargo build`, but it also then runs the produced executable.\n+Try it out:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Hello, world!\n+```\n+\n+Great! The `run` command comes in handy when you need to rapidly iterate on a\n+project. Our game is just such a project, we need to quickly test each\n+iteration before moving on to the next one.\n+\n+# Processing a Guess\n+\n+Let\u2019s get to it! The first thing we need to do for our guessing game is\n+allow our player to input a guess. Put this in your `src/main.rs`:\n+\n+```rust,no_run\n+use std::io;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    let input = io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"Failed to read line\");\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+There\u2019s a lot here! Let\u2019s go over it, bit by bit.\n+\n+```rust,ignore\n+use std::io;\n+```\n+\n+We\u2019ll need to take user input, and then print the result as output. As such, we\n+need the `io` library from the standard library. Rust only imports a few things\n+into every program, [the \u2018prelude\u2019][prelude]. If it\u2019s not in the prelude,\n+you\u2019ll have to `use` it directly.\n+\n+[prelude]: ../std/prelude/index.html\n+\n+```rust,ignore\n+fn main() {\n+```\n+\n+As you\u2019ve seen before, the `main()` function is the entry point into your\n+program. The `fn` syntax declares a new function, the `()`s indicate that\n+there are no arguments, and `{` starts the body of the function. Because\n+we didn\u2019t include a return type, it\u2019s assumed to be `()`, an empty\n+[tuple][tuples].\n+\n+[tuples]: primitive-types.html#tuples\n+\n+```rust,ignore\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+```\n+\n+We previously learned that `println!()` is a [macro][macros] that\n+prints a [string][strings] to the screen.\n+\n+[macros]: macros.html\n+[strings]: strings.html\n+\n+```rust,ignore\n+    let mut guess = String::new();\n+```\n+\n+Now we\u2019re getting interesting! There\u2019s a lot going on in this little line. The first thing to notice is that this is a [let statement][let], which is used to create \u2018variable bindings\u2019. They take this form:\n+\n+```rust,ignore\n+let foo = bar;\n+```\n+\n+[let]: variable-bindings.html\n+\n+This will create a new binding named `foo`, and bind it to the value `bar`. In\n+many languages, this is called a \u2018variable\u2019, but Rust\u2019s variable bindings have\n+a few tricks up their sleeves.\n+\n+For example, they\u2019re [immutable][immutable] by default. That\u2019s why our example\n+uses `mut`: it makes a binding mutable, rather than immutable. `let` doesn\u2019t\n+take a name on the left hand side, it actually accepts a\n+\u2018[pattern][patterns]\u2019. We\u2019ll use patterns more later. It\u2019s easy enough\n+to use for now:\n+\n+```\n+let foo = 5; // immutable.\n+let mut bar = 5; // mutable\n+```\n+\n+[immutable]: mutability.html\n+[patterns]: patterns.html\n+\n+Oh, and `//` will start a comment, until the end of the line. Rust ignores\n+everything in [comments][comments].\n+\n+[comments]: comments.html\n+\n+So now we know that `let mut guess` will introduce a mutable binding named\n+`guess`, but we have to look at the other side of the `=` for what it\u2019s\n+bound to: `String::new()`.\n+\n+`String` is a string type, provided by the standard library. A\n+[`String`][string] is a growable, UTF-8 encoded bit of text.\n+\n+[string]: ../std/string/struct.String.html\n+\n+The `::new()` syntax is uses `::` because this is an \u2018associated function\u2019 of\n+a particular type. That is to say, it\u2019s associated with `String` itself,\n+rather than a particular instance of a `String`. Some languages call this a\n+\u2018static method\u2019.\n+\n+This function is named `new()`, because it creates a new, empty `String`.\n+You\u2019ll find a `new()` function on many types, as it\u2019s a common name for making\n+a new value of some kind.\n+\n+Let\u2019s move forward:\n+\n+```rust,ignore\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"Failed to read line\");\n+```\n+\n+That\u2019s a lot more! Let\u2019s go bit-by-bit. The first line has two parts. Here\u2019s\n+the first:\n+\n+```rust,ignore\n+io::stdin()\n+```\n+\n+Remember how we `use`d `std::io` on the first line of the program? We\u2019re now\n+calling an associated function on it. If we didn\u2019t `use std::io`, we could\n+have written this line as `std::io::stdin()`.\n+\n+This particular function returns a handle to the standard input for your\n+terminal. More specifically, a [std::io::Stdin][iostdin].\n+\n+[iostdin]: ../std/io/struct.Stdin.html\n+\n+The next part will use this handle to get input from the user:\n+\n+```rust,ignore\n+.read_line(&mut guess)\n+```\n+\n+Here, we call the [`read_line()`][read_line] method on our handle.\n+[Method][method]s are like associated functions, but are only available on a\n+particular instance of a type, rather than the type itself. We\u2019re also passing\n+one argument to `read_line()`: `&mut guess`.\n+\n+[read_line]: ../std/io/struct.Stdin.html#method.read_line\n+[method]: methods.html\n+\n+Remember how we bound `guess` above? We said it was mutable. However,\n+`read_line` doesn\u2019t take a `String` as an argument: it takes a `&mut String`.\n+Rust has a feature called \u2018[references][references]\u2019, which allows you to have\n+multiple references to one piece of data, which can reduce copying. References\n+are a complex feature, as one of Rust\u2019s major selling points is how safe and\n+easy it is to use references. We don\u2019t need to know a lot of those details to\n+finish our program right now, though. For now, all we need to know is that\n+like `let` bindings, references are immutable by default. Hence, we need to\n+write `&mut guess`, rather than `&guess`.\n+\n+Why does `read_line()` take a mutable reference to a string? Its job is\n+to take what the user types into standard input, and place that into a\n+string. So it takes that string as an argument, and in order to add\n+the input, it needs to be mutable.\n+\n+[references]: references-and-borrowing.html\n+\n+But we\u2019re not quite done with this line of code, though. While it\u2019s\n+a single line of text, it\u2019s only the first part of the single logical line of\n+code:\n+\n+```rust,ignore\n+        .ok()\n+        .expect(\"Failed to read line\");\n+```\n+\n+When you call a method with the `.foo()` syntax, you may introduce a newline\n+and other whitespace. This helps you split up long lines. We _could_ have\n+done:\n+\n+```rust,ignore\n+    io::stdin().read_line(&mut guess).ok().expect(\"failed to read line\");\n+```\n+\n+But that gets hard to read. So we\u2019ve split it up, three lines for three\n+method calls. We already talked about `read_line()`, but what about `ok()`\n+and `expect()`? Well, we already mentioned that `read_line()` puts what\n+the user types into the `&mut String` we pass it. But it also returns\n+a value: in this case, an [`io::Result`][ioresult]. Rust has a number of\n+types named `Result` in its standard library: a generic [`Result`][result],\n+and then specific versions for sub-libraries, like `io::Result`.\n+\n+[ioresult]: ../std/io/type.Result.html\n+[result]: ../std/result/enum.Result.html\n+\n+The purpose of these `Result` types is to encode error handling information.\n+Values of the `Result` type, like any type, have methods defined on them. In\n+this case, `io::Result` has an `ok()` method, which says \u2018we want to assume\n+this value is a successful one. If not, just throw away the error\n+information\u2019. Why throw it away? Well, for a basic program, we just want to\n+print a generic error, as basically any issue means we can\u2019t continue. The\n+[`ok()` method][ok] returns a value which has another method defined on it:\n+`expect()`. The [`expect()` method][expect] takes a value it\u2019s called on, and\n+if it isn\u2019t a successful one, [`panic!`][panic]s with a message you passed you\n+passed it. A `panic!` like this will cause our program to crash, displaying\n+the message.\n+\n+[ok]: ../std/result/enum.Result.html#method.ok\n+[expect]: ../std/option/enum.Option.html#method.expect\n+[panic]: error-handling.html\n+\n+If we leave off calling these two methods, our program will compile, but\n+we\u2019ll get a warning:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+src/main.rs:10:5: 10:39 warning: unused result which must be used,\n+#[warn(unused_must_use)] on by default\n+src/main.rs:10     io::stdin().read_line(&mut guess);\n+                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+Rust warns us that we haven\u2019t used the `Result` value. This warning comes from\n+a special annotation that `io::Result` has. Rust is trying to tell you that\n+you haven\u2019t handled a possible error. The right way to suppress the error is\n+to actually write error handling. Luckily, if we just want to crash if there\u2019s\n+a problem, we can use these two little methods. If we can recover from the\n+error somehow, we\u2019d do something else, but we\u2019ll save that for a future\n+project.\n+\n+There\u2019s just one line of this first example left:\n+\n+```rust,ignore\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+This prints out the string we saved our input in. The `{}`s are a placeholder,\n+and so we pass it `input` as an argument. If we had multiple `{}`s, we would\n+pass multiple arguments:\n+\n+```rust\n+let x = 5;\n+let y = 10;\n+\n+println!(\"x and y: {} and {}\", x, y);\n+```\n+\n+Easy.\n+\n+Anyway, that\u2019s the tour. We can run what we have with `cargo run`:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+Please input your guess.\n+6\n+You guessed: 6\n+```\n+\n+All right! Our first part is done: we can get input from the keyboard,\n+and then print it back out.\n+\n+# Generating a secret number\n+\n+Next, we need to generate a secret number. Rust does not yet include random\n+number functionality in its standard library. The Rust team does, however,\n+provide a [`rand` crate][randcrate]. A \u2018crate\u2019 is a package of Rust code.\n+We\u2019ve been building a \u2018binary crate\u2019, which is an executable. `rand` is a\n+\u2018library crate\u2019, which contains code that\u2019s intended to be used with other\n+programs.\n+\n+[randcrate]: https://crates.io/crates/rand\n+\n+Using external crates is where Cargo really shines. Before we can write\n+the code using `rand`, we need to modify our `Cargo.toml`. Open it up, and\n+add these few lines at the bottom:\n+\n+```toml\n+[dependencies]\n+\n+rand=\"0.3.0\"\n+```\n+\n+The `[dependencies]` section of `Cargo.toml` is like the `[package]` section:\n+everything that follows it is part of it, until the next section starts.\n+Cargo uses the dependencies section to know what dependencies on external\n+crates you have, and what versions you require. In this case, we\u2019ve used `*`,\n+which means that we\u2019ll use the latest version of `rand`. Cargo understands\n+[Semantic Versioning][semver], which is a standard for writing version\n+numbers. If we wanted a specific version or range of versions, we could be\n+more specific here. [Cargo\u2019s documentation][cargodoc] contains more details.\n+\n+[semver]: http://semver.org\n+[cargodoc]: http://doc.crates.io/crates-io.html\n+\n+Now, without changing any of our code, let\u2019s build our project:\n+\n+```bash\n+$ cargo build\n+    Updating registry `https://github.com/rust-lang/crates.io-index`\n+ Downloading rand v0.3.8\n+ Downloading libc v0.1.6\n+   Compiling libc v0.1.6\n+   Compiling rand v0.3.8\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+```\n+\n+(You may see different versions, of course.)\n+\n+Lots of new output! Now that we have an external dependency, Cargo fetches the\n+latest versions of everything from the registry, which is a copy of data from\n+[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem\n+post their open source Rust projects for others to use.\n+\n+[cratesio]: https://crates.io\n+\n+After updating the registry, Cargo checks our `[dependencies]` and downloads\n+any we don\u2019t have yet. In this case, while we only said we wanted to depend on\n+`rand`, we\u2019ve also grabbed a copy of `libc`. This is because `rand` depends on\n+`libc` to work. After downloading them, it compiles them, and then compiles\n+our project.\n+\n+If we run `cargo build` again, we\u2019ll get different output:\n+\n+```bash\n+$ cargo build\n+```\n+\n+That\u2019s right, no output! Cargo knows that our project has been built, and that\n+all of its dependencies are built, and so there\u2019s no reason to do all that\n+stuff. With nothing to do, it simply exits. If we open up `src/main.rs` again,\n+make a trivial change, and then save it again, we\u2019ll just see one line:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+```\n+\n+So, we told Cargo we wanted any version of `rand`, and so it fetched the\n+latest version at the time this was written, `v0.3.8`. But what happens\n+when next week, version `v0.4.0` comes out, which changes something with\n+`rand`, and it includes a breaking change? After all, a `v0.y.z` version\n+in SemVer can change every release.\n+\n+The answer to this problem is the `Cargo.lock` file you\u2019ll now find in your\n+project directory. When you build your project for the first time, Cargo\n+figures out all of the versions that fit your criteria, and then writes them\n+to the `Cargo.lock` file. When you build your project in the future, Cargo\n+will see that the `Cargo.lock` file exists, and then use that specific version\n+rather than do all the work of figuring out versions again. This lets you\n+have a repeatable build automatically.\n+\n+What about when we _do_ want to use `v0.4.0`? Cargo has another command,\n+`update`, which says \u2018ignore the lock, figure out all the latest versions that\n+fit what we\u2019ve specified. If that works, write those versions out to the lock\n+file\u2019.\n+\n+There\u2019s a lot more to say about [Cargo][doccargo] and [its\n+ecosystem][doccratesio], but for now, that\u2019s all we need to know. Cargo makes\n+it really easy to re-use libraries, and so Rustaceans tend to write smaller\n+projects which are assembled out of a number of sub-packages.\n+\n+[doccargo]: http://doc.crates.io\n+[doccratesio]: http://doc.crates.io/crates-io.html\n+\n+Let\u2019s get on to actually _using_ `rand`. Here\u2019s our next step:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+}\n+```\n+\n+The first thing we\u2019ve done is change the first line. It now says\n+`extern crate rand`. Because we declared `rand` in our `[dependencies]`, we\n+can use `extern crate` to let Rust know we\u2019ll be making use of it. This also\n+does the equivalent of a `use rand;` as well, so we can make use of anything\n+in the `rand` crate by prefixing it with `rand::`.\n+\n+Next, we added another `use` line: `use rand::Rng`. We\u2019re going to use a\n+method in a moment, and it requires that `Rng` be in scope to work. The basic\n+idea is this: methods are defined on something called \u2018traits\u2019, and for the\n+method to work, it needs the trait to be in scope. For more about the\n+details, read the [traits][traits] section.\n+\n+[traits]: traits.html\n+\n+There are two other lines we added, in the middle:\n+\n+```rust,ignore\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+```\n+\n+We use the `rand::thread_rng()` function to get a copy of the random number\n+generator, which is local to the particular [thread][concurrency] of execution\n+we\u2019re in. Because we `use rand::Rng`\u2019d above, it has a `gen_range()` method\n+available. This method takes two arguments, and generates a number between\n+them. It\u2019s inclusive on the lower bound, but exclusive on the upper bound,\n+so we need `1` and `101` to get a number between one and a hundred.\n+\n+[concurrency]: concurrency.html\n+\n+The second line just prints out the secret number. This is useful while\n+we\u2019re developing our program, so we can easily test it out. But we\u2019ll be\n+deleting it for the final version. It\u2019s not much of a game if it prints out\n+the answer when you start it up!\n+\n+Try running our new program a few times:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+The secret number is: 7\n+Please input your guess.\n+4\n+You guessed: 4\n+$ cargo run\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+The secret number is: 83\n+Please input your guess.\n+5\n+You guessed: 5\n+```\n+\n+Great! Next up: let\u2019s compare our guess to the secret guess.\n+\n+# Comparing guesses\n+\n+Now that we\u2019ve got user input, let\u2019s compare our guess to the random guess.\n+Here\u2019s our next step, though it doesn\u2019t quite work yet:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+\n+    match guess.cmp(&secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+```\n+\n+A few new bits here. The first is another `use`. We bring a type called\n+`std::cmp::Ordering` into scope. Then, five new lines at the bottom that use\n+it:\n+\n+```rust,ignore\n+match guess.cmp(&secret_number) {\n+    Ordering::Less    => println!(\"Too small!\"),\n+    Ordering::Greater => println!(\"Too big!\"),\n+    Ordering::Equal   => println!(\"You win!\"),\n+}\n+```\n+\n+The `cmp()` method can be called on anything that can be compared, and it\n+takes a reference to the thing you want to compare it to. It returns the\n+`Ordering` type we `use`d earlier. We use a [`match`][match] statement to\n+determine exactly what kind of `Ordering` it is. `Ordering` is an\n+[`enum`][enum], short for \u2018enumeration\u2019, which looks like this:\n+\n+```rust\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+```\n+\n+[match]: match.html\n+[enum]: enums.html\n+\n+With this definition, anything of type `Foo` can be either a\n+`Foo::Bar` or a `Foo::Baz`. We use the `::` to indicate the\n+namespace for a particular `enum` variant.\n+\n+The [`Ordering`][ordering] enum has three possible variants: `Less`, `Equal`,\n+and `Greater`. The `match` statement takes a value of a type, and lets you\n+create an \u2018arm\u2019 for each possible value. Since we have three types of\n+`Ordering`, we have three arms:\n+\n+```rust,ignore\n+match guess.cmp(&secret_number) {\n+    Ordering::Less    => println!(\"Too small!\"),\n+    Ordering::Greater => println!(\"Too big!\"),\n+    Ordering::Equal   => println!(\"You win!\"),\n+}\n+```\n+\n+[ordering]: ../std/cmp/enum.Ordering.html\n+\n+If it\u2019s `Less`, we print `Too small!`, if it\u2019s `Greater`, `Too big!`, and if\n+`Equal`, `You win!`. `match` is really useful, and is used often in Rust.\n+\n+I did mention that this won\u2019t quite work yet, though. Let\u2019s try it:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+src/main.rs:28:21: 28:35 error: mismatched types:\n+ expected `&collections::string::String`,\n+    found `&_`\n+(expected struct `collections::string::String`,\n+    found integral variable) [E0308]\n+src/main.rs:28     match guess.cmp(&secret_number) {\n+                                   ^~~~~~~~~~~~~~\n+error: aborting due to previous error\n+Could not compile `guessing_game`.\n+```\n+\n+Whew! This is a big error. The core of it is that we have \u2018mismatched types\u2019.\n+Rust has a strong, static type system. However, it also has type inference.\n+When we wrote `let guess = String::new()`, Rust was able to infer that `guess`\n+should be a `String`, and so it doesn\u2019t make us write out the type. And with\n+our `secret_number`, there are a number of types which can have a value\n+between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an\n+unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number. Or others.\n+So far, that hasn\u2019t mattered, and so Rust defaults to an `i32`. However, here,\n+Rust doesn\u2019t know how to compare the `guess` and the `secret_number`. They\n+need to be the same type. Ultimately, we want to convert the `String` we\n+read as input into a real number type, for comparison. We can do that\n+with three more lines. Here\u2019s our new program:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    let guess: u32 = guess.trim().parse()\n+        .ok()\n+        .expect(\"Please type a number!\");\n+\n+    println!(\"You guessed: {}\", guess);\n+\n+    match guess.cmp(&secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+```\n+\n+The new three lines:\n+\n+```rust,ignore\n+    let guess: u32 = guess.trim().parse()\n+        .ok()\n+        .expect(\"Please type a number!\");\n+```\n+\n+Wait a minute, I thought we already had a `guess`? We do, but Rust allows us\n+to \u2018shadow\u2019 the previous `guess` with a new one. This is often used in this\n+exact situation, where `guess` starts as a `String`, but we want to convert it\n+to an `u32`. Shadowing lets us re-use the `guess` name, rather than forcing us\n+to come up with two unique names like `guess_str` and `guess`, or something\n+else.\n+\n+We bind `guess` to an expression that looks like something we wrote earlier:\n+\n+```rust,ignore\n+guess.trim().parse()\n+```\n+\n+Followed by an `ok().expect()` invocation. Here, `guess` refers to the old\n+`guess`, the one that was a `String` with our input in it. The `trim()`\n+method on `String`s will eliminate any white space at the beginning and end of\n+our string. This is important, as we had to press the \u2018return\u2019 key to satisfy\n+`read_line()`. This means that if we type `5` and hit return, `guess` looks\n+like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the enter key. `trim()` gets\n+rid of this, leaving our string with just the `5`. The [`parse()` method on\n+strings][parse] parses a string into some kind of number. Since it can parse a\n+variety of numbers, we need to give Rust a hint as to the exact type of number\n+we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust\n+we\u2019re going to annotate its type. `u32` is an unsigned, thirty-two bit\n+integer. Rust has [a number of built-in number types][number], but we\u2019ve\n+chosen `u32`. It\u2019s a good default choice for a small positive numer.\n+\n+[parse]: ../std/primitive.str.html#method.parse\n+[number]: primitive-types.html#numeric-types\n+\n+Just like `read_line()`, our call to `parse()` could cause an error. What if\n+our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As\n+such, we\u2019ll do the same thing we did with `read_line()`: use the `ok()` and\n+`expect()` methods to crash if there\u2019s an error.\n+\n+Let\u2019s try our program out!\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 58\n+Please input your guess.\n+  76\n+You guessed: 76\n+Too big!\n+```\n+\n+Nice! You can see I even added spaces before my guess, and it still figured\n+out that I guessed 76. Run the program a few times, and verify that guessing\n+the number works, as well as guessing a number too small.\n+\n+Now we\u2019ve got most of the game working, but we can only make one guess. Let\u2019s\n+change that by adding loops!\n+\n+# Looping\n+\n+The `loop` keyword gives us an infinite loop. Let\u2019s add that in:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = guess.trim().parse()\n+            .ok()\n+            .expect(\"Please type a number!\");\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => println!(\"You win!\"),\n+        }\n+    }\n+}\n+```\n+\n+And try it out. But wait, didn\u2019t we just add an infinite loop? Yup. Remember\n+our discussion about `parse()`? If we give a non-number answer, we\u2019ll `return`\n+and quit. Observe:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 59\n+Please input your guess.\n+45\n+You guessed: 45\n+Too small!\n+Please input your guess.\n+60\n+You guessed: 60\n+Too big!\n+Please input your guess.\n+59\n+You guessed: 59\n+You win!\n+Please input your guess.\n+quit\n+thread '<main>' panicked at 'Please type a number!'\n+```\n+\n+Ha! `quit` actually quits. As does any other non-number input. Well, this is\n+suboptimal to say the least. First, let\u2019s actually quit when you win the game:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = guess.trim().parse()\n+            .ok()\n+            .expect(\"Please type a number!\");\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\"),\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+By adding the `break` line after the `You win!`, we\u2019ll exit the loop when we\n+win. Exiting the loop also means exiting the program, since it\u2019s the last\n+thing in `main()`. We have just one more tweak to make: when someone inputs a\n+non-number, we don\u2019t want to quit, we just want to ignore it. We can do that\n+like this:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = match guess.trim().parse() {\n+            Ok(num) => num,\n+            Err(_) => continue,\n+        };\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+These are the lines that changed:\n+\n+```rust,ignore\n+let guess: u32 = match guess.trim().parse() {\n+    Ok(num) => num,\n+    Err(_) => continue,\n+};\n+```\n+\n+This is how you generally move from \u2018crash on error\u2019 to \u2018actually handle the\n+error\u2019, by switching from `ok().expect()` to a `match` statement. The `Result`\n+returned by `parse()` is an enum just like `Ordering`, but in this case, each\n+variant has some data associated with it: `Ok` is a success, and `Err` is a\n+failure. Each contains more information: the successful parsed integer, or an\n+error type. In this case, we `match` on `Ok(num)`, which sets the inner value\n+of the `Ok` to the name `num`, and then we just return it on the right-hand\n+side. In the `Err` case, we don\u2019t care what kind of error it is, so we just\n+use `_` intead of a name. This ignores the error, and `continue` causes us\n+to go to the next iteration of the `loop`.\n+\n+Now we should be good! Let\u2019s try:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 61\n+Please input your guess.\n+10\n+You guessed: 10\n+Too small!\n+Please input your guess.\n+99\n+You guessed: 99\n+Too big!\n+Please input your guess.\n+foo\n+Please input your guess.\n+61\n+You guessed: 61\n+You win!\n+```\n+\n+Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n+think of what it is? That\u2019s right, we don\u2019t want to print out the secret\n+number. It was good for testing, but it kind of ruins the game. Here\u2019s our\n+final source:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = match guess.trim().parse() {\n+            Ok(num) => num,\n+            Err(_) => continue,\n+        };\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+# Complete!\n+\n+At this point, you have successfully built the Guessing Game! Congratulations!\n+\n+This first project showed you a lot: `let`, `match`, methods, associated\n+functions, using external crates, and more. Our next project will show off\n+even more."}, {"sha": "4872ed6a773472a8412e115fd4c1302dd2f7e5e8", "filename": "src/doc/trpl/if-let.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -65,7 +65,7 @@ loop as long as a value matches a certain pattern. It turns code like this:\n loop {\n     match option {\n         Some(x) => println!(\"{}\", x),\n-\t_ => break,\n+        _ => break,\n     }\n }\n ```"}, {"sha": "1a02bc95e9d9c84247ff01c674415697457a0b04", "filename": "src/doc/trpl/learn-rust.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flearn-rust.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -1,4 +1,9 @@\n % Learn Rust\n \n-This section is coming soon! It will eventually have a few tutorials with\n-building real Rust projects, but they are under development.\n+Welcome! This section has a few tutorials that teach you Rust through building\n+projects. You\u2019ll get a high-level overview, but we\u2019ll skim over the details.\n+\n+If you\u2019d prefer a more \u2018from the ground up\u2019-style experience, check\n+out [Syntax and Semantics][ss].\n+\n+[ss]: syntax-and-semantics.html"}, {"sha": "981286c82d7988ee2ba6a2c53b2dc879fe601611", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 295, "deletions": 1, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -1,3 +1,297 @@\n % Lifetimes\n \n-Coming Soon! Until then, check out the [ownership](ownership.html) chapter.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. There are a few distinct concepts, each with its own chapter:\n+\n+* [ownership][ownership], ownership, the key concept\n+* [borrowing][borrowing], and their associated feature \u2018references\u2019\n+* lifetimes, which you\u2019re reading now\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[ownership]: ownership.html\n+[borrowing]: references-and-borrowing.html\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero-cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let\u2019s learn about lifetimes.\n+\n+# Lifetimes\n+\n+Lending out a reference to a resource that someone else owns can be\n+complicated, however. For example, imagine this set of operations:\n+\n+- I acquire a handle to some kind of resource.\n+- I lend you a reference to the resource.\n+- I decide I\u2019m done with the resource, and deallocate it, while you still have\n+  your reference.\n+- You decide to use the resource.\n+\n+Uh oh! Your reference is pointing to an invalid resource. This is called a\n+dangling pointer or \u2018use after free\u2019, when the resource is memory.\n+\n+To fix this, we have to make sure that step four never happens after step\n+three. The ownership system in Rust does this through a concept called\n+lifetimes, which describe the scope that a reference is valid for.\n+\n+When we have a function that takes a reference by argument, we can be implicit\n+or explicit about the lifetime of the reference:\n+\n+```rust\n+// implicit\n+fn foo(x: &i32) {\n+}\n+\n+// explicit\n+fn bar<'a>(x: &'a i32) {\n+}\n+```\n+\n+The `'a` reads \u2018the lifetime a\u2019. Technically, every reference has some lifetime\n+associated with it, but the compiler lets you elide them in common cases.\n+Before we get to that, though, let\u2019s break the explicit example down:\n+\n+```rust,ignore\n+fn bar<'a>(...)\n+```\n+\n+This part declares our lifetimes. This says that `bar` has one lifetime, `'a`.\n+If we had two reference parameters, it would look like this:\n+\n+```rust,ignore\n+fn bar<'a, 'b>(...)\n+```\n+\n+Then in our parameter list, we use the lifetimes we\u2019ve named:\n+\n+```rust,ignore\n+...(x: &'a i32)\n+```\n+\n+If we wanted an `&mut` reference, we\u2019d do this:\n+\n+```rust,ignore\n+...(x: &'a mut i32)\n+```\n+\n+If you compare `&mut i32` to `&'a mut i32`, they\u2019re the same, it\u2019s just that\n+the lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut\n+i32` as \u2018a mutable reference to an i32\u2019 and `&'a mut i32` as \u2018a mutable\n+reference to an `i32` with the lifetime `'a`\u2019.\n+\n+You\u2019ll also need explicit lifetimes when working with [`struct`][structs]s:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let f = Foo { x: y };\n+\n+    println!(\"{}\", f.x);\n+}\n+```\n+\n+[struct]: structs.html\n+\n+As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n+\n+```rust\n+struct Foo<'a> {\n+# x: &'a i32,\n+# }\n+```\n+\n+declares a lifetime, and\n+\n+```rust\n+# struct Foo<'a> {\n+x: &'a i32,\n+# }\n+```\n+\n+uses it. So why do we need a lifetime here? We need to ensure that any reference\n+to a `Foo` cannot outlive the reference to an `i32` it contains.\n+\n+## Thinking in scopes\n+\n+A way to think about lifetimes is to visualize the scope that a reference is\n+valid for. For example:\n+\n+```rust\n+fn main() {\n+    let y = &5;     // -+ y goes into scope\n+                    //  |\n+    // stuff        //  |\n+                    //  |\n+}                   // -+ y goes out of scope\n+```\n+\n+Adding in our `Foo`:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let y = &5;           // -+ y goes into scope\n+    let f = Foo { x: y }; // -+ f goes into scope\n+    // stuff              //  |\n+                          //  |\n+}                         // -+ f and y go out of scope\n+```\n+\n+Our `f` lives within the scope of `y`, so everything works. What if it didn\u2019t?\n+This code won\u2019t work:\n+\n+```rust,ignore\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let x;                    // -+ x goes into scope\n+                              //  |\n+    {                         //  |\n+        let y = &5;           // ---+ y goes into scope\n+        let f = Foo { x: y }; // ---+ f goes into scope\n+        x = &f.x;             //  | | error here\n+    }                         // ---+ f and y go out of scope\n+                              //  |\n+    println!(\"{}\", x);        //  |\n+}                             // -+ x goes out of scope\n+```\n+\n+Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n+of `x`. But when we do `x = &f.x`, we make `x` a reference to something that\u2019s\n+about to go out of scope.\n+\n+Named lifetimes are a way of giving these scopes a name. Giving something a\n+name is the first step towards being able to talk about it.\n+\n+## 'static\n+\n+The lifetime named \u2018static\u2019 is a special lifetime. It signals that something\n+has the lifetime of the entire program. Most Rust programmers first come across\n+`'static` when dealing with strings:\n+\n+```rust\n+let x: &'static str = \"Hello, world.\";\n+```\n+\n+String literals have the type `&'static str` because the reference is always\n+alive: they are baked into the data segment of the final binary. Another\n+example are globals:\n+\n+```rust\n+static FOO: i32 = 5;\n+let x: &'static i32 = &FOO;\n+```\n+\n+This adds an `i32` to the data segment of the binary, and `x` is a reference\n+to it.\n+\n+## Lifetime Elision\n+\n+Rust supports powerful local type inference in function bodies, but it\u2019s\n+forbidden in item signatures to allow reasoning about the types just based in\n+the item signature alone. However, for ergonomic reasons a very restricted\n+secondary inference algorithm called \u201clifetime elision\u201d applies in function\n+signatures. It infers only based on the signature components themselves and not\n+based on the body of the function, only infers lifetime parameters, and does\n+this with only three easily memorizable and unambiguous rules. This makes\n+lifetime elision a shorthand for writing an item signature, while not hiding\n+away the actual types involved as full local inference would if applied to it.\n+\n+When talking about lifetime elision, we use the term *input lifetime* and\n+*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n+of a function, and an *output lifetime* is a lifetime associated with the return\n+value of a function. For example, this function has an input lifetime:\n+\n+```rust,ignore\n+fn foo<'a>(bar: &'a str)\n+```\n+\n+This one has an output lifetime:\n+\n+```rust,ignore\n+fn foo<'a>() -> &'a str\n+```\n+\n+This one has a lifetime in both positions:\n+\n+```rust,ignore\n+fn foo<'a>(bar: &'a str) -> &'a str\n+```\n+\n+Here are the three rules:\n+\n+* Each elided lifetime in a function\u2019s arguments becomes a distinct lifetime\n+  parameter.\n+\n+* If there is exactly one input lifetime, elided or not, that lifetime is\n+  assigned to all elided lifetimes in the return values of that function.\n+\n+* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n+  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n+\n+Otherwise, it is an error to elide an output lifetime.\n+\n+### Examples\n+\n+Here are some examples of functions with elided lifetimes.  We\u2019ve paired each\n+example of an elided lifetime with its expanded form.\n+\n+```rust,ignore\n+fn print(s: &str); // elided\n+fn print<'a>(s: &'a str); // expanded\n+\n+fn debug(lvl: u32, s: &str); // elided\n+fn debug<'a>(lvl: u32, s: &'a str); // expanded\n+\n+// In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n+// reference (`&`). Only things relating to references (such as a `struct`\n+// which contains a reference) need lifetimes.\n+\n+fn substr(s: &str, until: u32) -> &str; // elided\n+fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n+\n+fn get_str() -> &str; // ILLEGAL, no inputs\n+\n+fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n+fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n+\n+fn get_mut(&mut self) -> &mut T; // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n+\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n+fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n+\n+fn new(buf: &mut [u8]) -> BufWriter; // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n+```"}, {"sha": "ed4e9dd359b6d048159437bab7f4dfa466ca0111", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -154,9 +154,10 @@ fn main() {\n }\n ```\n \n-This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n-are called with the `Struct::method()` syntax, rather than the `ref.method()`\n-syntax.\n+This \u2018associated function\u2019 builds a new `Circle` for us. Note that associated\n+functions are called with the `Struct::function()` syntax, rather than the\n+`ref.method()` syntax. Some other langauges call associated functions \u2018static\n+methods\u2019.\n \n # Builder Pattern\n "}, {"sha": "b5bd53e1d75a14bc6ad23ddc81756403916a1fa1", "filename": "src/doc/trpl/move-semantics.md", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/eae692e375cec222803efb7175c79fedc228eea9/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/eae692e375cec222803efb7175c79fedc228eea9/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=eae692e375cec222803efb7175c79fedc228eea9", "patch": "@@ -1,105 +0,0 @@\n-% Move Semantics\n-\n-An important aspect of [ownership][ownership] is \u2018move semantics\u2019. Move\n-semantics control how and when ownership is transferred between bindings.\n-\n-[ownership]: ownership.html\n-\n-For example, consider a type like `Vec<T>`, which owns its contents:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-```\n-\n-I can assign this vector to another binding:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-```\n-\n-But, if we try to use `v` afterwards, we get an error:\n-\n-```rust,ignore\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-\n-println!(\"v[0] is: {}\", v[0]);\n-```\n-\n-It looks like this:\n-\n-```text\n-error: use of moved value: `v`\n-println!(\"v[0] is: {}\", v[0]);\n-                        ^\n-```\n-\n-A similar thing happens if we define a function which takes ownership, and\n-try to use something after we\u2019ve passed it as an argument:\n-\n-```rust,ignore\n-fn take(v: Vec<i32>) {\n-    // what happens here isn\u2019t important.\n-}\n-\n-let v = vec![1, 2, 3];\n-\n-take(v);\n-\n-println!(\"v[0] is: {}\", v[0]);\n-```\n-\n-Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n-we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n-special annotation here, it\u2019s the default thing that Rust does.\n-\n-# The details\n-\n-The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n-important. When we write code like this:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-```\n-\n-The first line creates some data for the vector on the stack, `v`. The vector\u2019s\n-data, however, is stored on the heap, and so it contains a pointer to that\n-data. When we move `v` to `v2`, it creates a copy of that data, for `v2`. Which\n-would mean two pointers to the contents of the vector on the heap. That would\n-be a problem: it would violate Rust\u2019s safety guarantees by introducing a data\n-race. Therefore, Rust forbids using `v` after we\u2019ve done the move.\n-\n-It\u2019s also important to note that optimizations may remove the actual copy of\n-the bytes, depending on circumstances. So it may not be as inefficient as it\n-initially seems.\n-\n-# `Copy` types\n-\n-We\u2019ve established that when ownership is transferred to another binding, you\n-cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n-behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n-you can think of them as an annotation to a particular type that adds extra\n-behavior. For example:\n-\n-```rust\n-let v = 1;\n-\n-let v2 = v;\n-\n-println!(\"v is: {}\", v);\n-```\n-\n-In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n-that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n-But, unlike a move, we can still use `v` afterward. This is because an `i32`\n-has no pointers to data somewhere else, copying it is a full copy.\n-\n-We will discuss how to make your own types `Copy` in the [traits][traits]\n-section.\n-\n-[traits]: traits.html"}, {"sha": "3003156f875aaf1cfd7c198996c656d367fdfc30", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 111, "deletions": 459, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -1,555 +1,207 @@\n % Ownership\n \n-This guide presents Rust's ownership system. This is one of Rust's most unique\n-and compelling features, with which Rust developers should become quite\n-acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n-The ownership system has a few distinct concepts: *ownership*, *borrowing*,\n-and *lifetimes*. We'll talk about each one in turn.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. The there are a few distinct concepts, each with its own\n+chapter:\n+\n+* ownership, which you\u2019re reading now.\n+* [borrowing][borrowing], and their associated feature \u2018references\u2019\n+* [lifetimes][lifetimes], an advanced concept of borrowing\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[borrowing]: references-and-borrowing.html\n+[lifetimes]: lifetimes.html\n \n # Meta\n \n Before we get to the details, two important notes about the ownership system.\n \n Rust has a focus on safety and speed. It accomplishes these goals through many\n-*zero-cost abstractions*, which means that in Rust, abstractions cost as little\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we'll talk about in this guide\n+of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n features.\n \n However, this system does have a certain cost: learning curve. Many new users\n-to Rust experience something we like to call \"fighting with the borrow\n-checker,\" where the Rust compiler refuses to compile a program that the author\n-thinks is valid. This often happens because the programmer's mental model of\n-how ownership should work doesn't match the actual rules that Rust implements.\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n You probably will experience similar things at first. There is good news,\n however: more experienced Rust developers report that once they work with the\n rules of the ownership system for a period of time, they fight the borrow\n checker less and less.\n \n-With that in mind, let's learn about ownership.\n+With that in mind, let\u2019s learn about ownership.\n \n # Ownership\n \n-At its core, ownership is about *resources*. For the purposes of the vast\n-majority of this guide, we will talk about a specific resource: memory. The\n-concept generalizes to any kind of resource, like a file handle, but to make it\n-more concrete, we'll focus on memory.\n-\n-When your program allocates some memory, it needs some way to deallocate that\n-memory. Imagine a function `foo` that allocates four bytes of memory, and then\n-never deallocates that memory. We call this problem *leaking* memory, because\n-each time we call `foo`, we're allocating another four bytes. Eventually, with\n-enough calls to `foo`, we will run our system out of memory. That's no good. So\n-we need some way for `foo` to deallocate those four bytes. It's also important\n-that we don't deallocate too many times, either. Without getting into the\n-details, attempting to deallocate memory multiple times can lead to problems.\n-In other words, any time some memory is allocated, we need to make sure that we\n-deallocate that memory once and only once. Too many times is bad, not enough\n-times is bad. The counts must match.\n-\n-There's one other important detail with regards to allocating memory. Whenever\n-we request some amount of memory, what we are given is a handle to that memory.\n-This handle (often called a *pointer*, when we're referring to memory) is how\n-we interact with the allocated memory. As long as we have that handle, we can\n-do something with the memory. Once we're done with the handle, we're also done\n-with the memory, as we can't do anything useful without a handle to it.\n-\n-Historically, systems programming languages require you to track these\n-allocations, deallocations, and handles yourself. For example, if we want some\n-memory from the heap in a language like C, we do this:\n-\n-```c\n-{\n-    int *x = malloc(sizeof(int));\n-\n-    // we can now do stuff with our handle x\n-    *x = 5;\n-\n-    free(x);\n-}\n-```\n-\n-The call to `malloc` allocates some memory. The call to `free` deallocates the\n-memory. There's also bookkeeping about allocating the correct amount of memory.\n-\n-Rust combines these two aspects of allocating memory (and other resources) into\n-a concept called *ownership*. Whenever we request some memory, that handle we\n-receive is called the *owning handle*. Whenever that handle goes out of scope,\n-Rust knows that you cannot do anything with the memory anymore, and so\n-therefore deallocates the memory for you. Here's the equivalent example in\n-Rust:\n+[`Variable bindings`][bindings] have a property in Rust: they \u2018have ownership\u2019\n+of what they\u2019re bound to. This means that when a binding goes out of scope, the\n+resource that they\u2019re bound to are freed. For example:\n \n ```rust\n-{\n-    let x = Box::new(5);\n-}\n-```\n-\n-The `Box::new` function creates a `Box<T>` (specifically `Box<i32>` in this\n-case) by allocating a small segment of memory on the heap with enough space to\n-fit an `i32`. But where in the code is the box deallocated? We said before that\n-we must have a deallocation for each allocation. Rust handles this for you. It\n-knows that our handle, `x`, is the owning reference to our box. Rust knows that\n-`x` will go out of scope at the end of the block, and so it inserts a call to\n-deallocate the memory at the end of the scope. Because the compiler does this\n-for us, it's impossible to forget. We always have exactly one deallocation\n-  paired with each of our allocations.\n-\n-This is pretty straightforward, but what happens when we want to pass our box\n-to a function? Let's look at some code:\n-\n-```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    add_one(x);\n-}\n-\n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n+fn foo() {\n+    let v = vec![1, 2, 3];\n }\n ```\n \n-This code works, but it's not ideal. For example, let's add one more line of\n-code, where we print out the value of `x`:\n-\n-```{rust,ignore}\n-fn main() {\n-    let x = Box::new(5);\n+When `v` comes into scope, a new [`Vec<T>`][vect] is created. In this case, the\n+vector also allocates space on [the heap][heap], for the three elements. When\n+`v` goes out of scope at the end of `foo()`, Rust will clean up everything\n+related to the vector, even the heap-allocated memory. This happens\n+deterministically, at the end of the scope.\n \n-    add_one(x);\n-\n-    println!(\"{}\", x);\n-}\n+[vect]: ../std/vec/struct.Vec.html\n+[heap]: the-stack-and-the-heap.html\n \n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n-}\n-```\n+# Move semantics\n \n-This does not compile, and gives us an error:\n-\n-```text\n-error: use of moved value: `x`\n-   println!(\"{}\", x);\n-                  ^\n-```\n-\n-Remember, we need one deallocation for every allocation. When we try to pass\n-our box to `add_one`, we would have two handles to the memory: `x` in `main`,\n-and `num` in `add_one`. If we deallocated the memory when each handle went out\n-of scope, we would have two deallocations and one allocation, and that's wrong.\n-So when we call `add_one`, Rust defines `num` as the owner of the handle. And\n-so, now that we've given ownership to `num`, `x` is invalid. `x`'s value has\n-\"moved\" from `x` to `num`. Hence the error: use of moved value `x`.\n-\n-To fix this, we can have `add_one` give ownership back when it's done with the\n-box:\n+There\u2019s some more subtlety here, though: Rust ensures that there is _exactly\n+one_ binding to any given resource. For example, if we have a vector, we can\n+assign it to another binding:\n \n ```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    let y = add_one(x);\n-\n-    println!(\"{}\", y);\n-}\n-\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n+let v = vec![1, 2, 3];\n \n-    num\n-}\n+let v2 = v;\n ```\n \n-This code will compile and run just fine. Now, we return a `box`, and so the\n-ownership is transferred back to `y` in `main`. We only have ownership for the\n-duration of our function before giving it back. This pattern is very common,\n-and so Rust introduces a concept to describe a handle which temporarily refers\n-to something another handle owns. It's called *borrowing*, and it's done with\n-*references*, designated by the `&` symbol.\n-\n-# Borrowing\n+But, if we try to use `v` afterwards, we get an error:\n \n-Here's the current state of our `add_one` function:\n+```rust,ignore\n+let v = vec![1, 2, 3];\n \n-```rust\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n+let v2 = v;\n \n-    num\n-}\n+println!(\"v[0] is: {}\", v[0]);\n ```\n \n-This function takes ownership, because it takes a `Box`, which owns its\n-contents. But then we give ownership right back.\n-\n-In the physical world, you can give one of your possessions to someone for a\n-short period of time. You still own your possession, you're just letting someone\n-else use it for a while. We call that *lending* something to someone, and that\n-person is said to be *borrowing* that something from you.\n-\n-Rust's ownership system also allows an owner to lend out a handle for a limited\n-period. This is also called *borrowing*. Here's a version of `add_one` which\n-borrows its argument rather than taking ownership:\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-This function borrows an `i32` from its caller, and then increments it. When\n-the function is over, and `num` goes out of scope, the borrow is over.\n-\n-We have to change our `main` a bit too:\n-\n-```rust\n-fn main() {\n-    let mut x = 5;\n-\n-    add_one(&mut x);\n+It looks like this:\n \n-    println!(\"{}\", x);\n-}\n-\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-We don't need to assign the result of `add_one()` anymore, because it doesn't\n-return anything anymore. This is because we're not passing ownership back,\n-since we just borrow, not take ownership.\n-\n-# Lifetimes\n-\n-Lending out a reference to a resource that someone else owns can be\n-complicated, however. For example, imagine this set of operations:\n-\n-1. I acquire a handle to some kind of resource.\n-2. I lend you a reference to the resource.\n-3. I decide I'm done with the resource, and deallocate it, while you still have\n-   your reference.\n-4. You decide to use the resource.\n-\n-Uh oh! Your reference is pointing to an invalid resource. This is called a\n-*dangling pointer* or \"use after free,\" when the resource is memory.\n-\n-To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-*lifetimes*, which describe the scope that a reference is valid for.\n-\n-Remember the function that borrowed an `i32`? Let's look at it again.\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n+```text\n+error: use of moved value: `v`\n+println!(\"v[0] is: {}\", v[0]);\n+                        ^\n ```\n \n-Rust has a feature called *lifetime elision*, which allows you to not write\n-lifetime annotations in certain circumstances. This is one of them. We will\n-cover the others later. Without eliding the lifetimes, `add_one` looks like\n-this:\n+A similar thing happens if we define a function which takes ownership, and\n+try to use something after we\u2019ve passed it as an argument:\n \n-```rust\n-fn add_one<'a>(num: &'a mut i32) {\n-    *num += 1;\n+```rust,ignore\n+fn take(v: Vec<i32>) {\n+    // what happens here isn\u2019t important.\n }\n-```\n-\n-The `'a` is called a *lifetime*. Most lifetimes are used in places where\n-short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n-have more descriptive names. Let's dig into the syntax in a bit more detail:\n \n-```{rust,ignore}\n-fn add_one<'a>(...)\n-```\n+let v = vec![1, 2, 3];\n \n-This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n-`'a`. If we had two, it would look like this:\n+take(v);\n \n-```{rust,ignore}\n-fn add_two<'a, 'b>(...)\n+println!(\"v[0] is: {}\", v[0]);\n ```\n \n-Then in our parameter list, we use the lifetimes we've named:\n-\n-```{rust,ignore}\n-...(num: &'a mut i32)\n-```\n+Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+special annotation here, it\u2019s the default thing that Rust does.\n \n-If you compare `&mut i32` to `&'a mut i32`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut i32` as \"a\n-mutable reference to an i32\" and `&'a mut i32` as \"a mutable reference to an i32 with the lifetime 'a.'\"\n+## The details\n \n-Why do lifetimes matter? Well, for example, here's some code:\n+The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n+important. When we write code like this:\n \n ```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n+let v = vec![1, 2, 3];\n \n-fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n-    let f = Foo { x: y };\n-\n-    println!(\"{}\", f.x);\n-}\n+let v2 = v;\n ```\n \n-As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n-\n-```{rust}\n-struct Foo<'a> {\n-# x: &'a i32,\n-# }\n-```\n+The first line creates some data for the vector on the [stack][sh], `v`. The\n+vector\u2019s data, however, is stored on the [heap][sh], and so it contains a\n+pointer to that data. When we move `v` to `v2`, it creates a copy of that data,\n+for `v2`. Which would mean two pointers to the contents of the vector on the\n+heap. That would be a problem: it would violate Rust\u2019s safety guarantees by\n+introducing a data race. Therefore, Rust forbids using `v` after we\u2019ve done the\n+move.\n \n-declares a lifetime, and\n-\n-```rust\n-# struct Foo<'a> {\n-x: &'a i32,\n-# }\n-```\n+[sh]: the-stack-and-the-heap.html\n \n-uses it. So why do we need a lifetime here? We need to ensure that any reference\n-to a `Foo` cannot outlive the reference to an `i32` it contains.\n+It\u2019s also important to note that optimizations may remove the actual copy of\n+the bytes, depending on circumstances. So it may not be as inefficient as it\n+initially seems.\n \n-## Thinking in scopes\n+## `Copy` types\n \n-A way to think about lifetimes is to visualize the scope that a reference is\n-valid for. For example:\n+We\u2019ve established that when ownership is transferred to another binding, you\n+cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n+behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n+you can think of them as an annotation to a particular type that adds extra\n+behavior. For example:\n \n ```rust\n-fn main() {\n-    let y = &5;     // -+ y goes into scope\n-                    //  |\n-    // stuff        //  |\n-                    //  |\n-}                   // -+ y goes out of scope\n-```\n-\n-Adding in our `Foo`:\n-\n-```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let y = &5;           // -+ y goes into scope\n-    let f = Foo { x: y }; // -+ f goes into scope\n-    // stuff              //  |\n-                          //  |\n-}                         // -+ f and y go out of scope\n-```\n+let v = 1;\n \n-Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n-This code won't work:\n+let v2 = v;\n \n-```{rust,ignore}\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let x;                    // -+ x goes into scope\n-                              //  |\n-    {                         //  |\n-        let y = &5;           // ---+ y goes into scope\n-        let f = Foo { x: y }; // ---+ f goes into scope\n-        x = &f.x;             //  | | error here\n-    }                         // ---+ f and y go out of scope\n-                              //  |\n-    println!(\"{}\", x);        //  |\n-}                             // -+ x goes out of scope\n+println!(\"v is: {}\", v);\n ```\n \n-Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n-of `x`. But when we do `x = &f.x`, we make `x` a reference to something that's\n-about to go out of scope.\n+In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n+that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n+But, unlike a move, we can still use `v` afterward. This is because an `i32`\n+has no pointers to data somewhere else, copying it is a full copy.\n \n-Named lifetimes are a way of giving these scopes a name. Giving something a\n-name is the first step towards being able to talk about it.\n+We will discuss how to make your own types `Copy` in the [traits][traits]\n+section.\n \n-## 'static\n+[traits]: traits.html\n \n-The lifetime named *static* is a special lifetime. It signals that something\n-has the lifetime of the entire program. Most Rust programmers first come across\n-`'static` when dealing with strings:\n+# More than ownership\n \n-```rust\n-let x: &'static str = \"Hello, world.\";\n-```\n-\n-String literals have the type `&'static str` because the reference is always\n-alive: they are baked into the data segment of the final binary. Another\n-example are globals:\n+Of course, if we had to hand ownership back with every function we wrote:\n \n ```rust\n-static FOO: i32 = 5;\n-let x: &'static i32 = &FOO;\n-```\n-\n-This adds an `i32` to the data segment of the binary, and `x` is a reference\n-to it.\n+fn foo(v: Vec<i32>) -> Vec<i32> {\n+    // do stuff with v\n \n-# Shared Ownership\n-\n-In all the examples we've considered so far, we've assumed that each handle has\n-a singular owner. But sometimes, this doesn't work. Consider a car. Cars have\n-four wheels. We would want a wheel to know which car it was attached to. But\n-this won't work:\n-\n-```{rust,ignore}\n-struct Car {\n-    name: String,\n-}\n-\n-struct Wheel {\n-    size: i32,\n-    owner: Car,\n-}\n-\n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car };\n-    }\n+    // hand back ownership\n+    v\n }\n ```\n \n-We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n-compiler knows that on the second iteration of the loop, there's a problem:\n-\n-```text\n-error: use of moved value: `car`\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-note: `car` moved here because it has type `Car`, which is non-copyable\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-```\n-\n-We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n-`Box<T>`, because it has a single owner. We can do it with `Rc<T>` instead:\n+This would get very tedius. It gets worse the more things we want to take ownership of:\n \n ```rust\n-use std::rc::Rc;\n+fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n+    // do stuff with v1 and v2\n \n-struct Car {\n-    name: String,\n+    // hand back ownership, and the result of our function\n+    (v1, v2, 42)\n }\n \n-struct Wheel {\n-    size: i32,\n-    owner: Rc<Car>,\n-}\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n \n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    let car_owner = Rc::new(car);\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car_owner.clone() };\n-    }\n-}\n+let (v1, v2, answer) = foo(v1, v2);\n ```\n \n-We wrap our `Car` in an `Rc<T>`, getting an `Rc<Car>`, and then use the\n-`clone()` method to make new references. We've also changed our `Wheel` to have\n-an `Rc<Car>` rather than just a `Car`.\n-\n-This is the simplest kind of multiple ownership possible. For example, there's\n-also `Arc<T>`, which uses more expensive atomic instructions to be the\n-thread-safe counterpart of `Rc<T>`.\n-\n-## Lifetime Elision\n-\n-Rust supports powerful local type inference in function bodies, but it\u2019s\n-forbidden in item signatures to allow reasoning about the types just based in\n-the item signature alone. However, for ergonomic reasons a very restricted\n-secondary inference algorithm called \u201clifetime elision\u201d applies in function\n-signatures. It infers only based on the signature components themselves and not\n-based on the body of the function, only infers lifetime parameters, and does\n-this with only three easily memorizable and unambiguous rules. This makes\n-lifetime elision a shorthand for writing an item signature, while not hiding\n-away the actual types involved as full local inference would if applied to it.\n-\n-When talking about lifetime elision, we use the term *input lifetime* and\n-*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n-of a function, and an *output lifetime* is a lifetime associated with the return\n-value of a function. For example, this function has an input lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str)\n-```\n-\n-This one has an output lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>() -> &'a str\n-```\n-\n-This one has a lifetime in both positions:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str) -> &'a str\n-```\n+Ugh! The return type, return line, and calling the function gets way more\n+complicated.\n \n-Here are the three rules:\n+Luckily, Rust offers a feature, borrowing, which helps us solve this problem.\n+It\u2019s the topic of the next section!\n \n-* Each elided lifetime in a function's arguments becomes a distinct lifetime\n-  parameter.\n \n-* If there is exactly one input lifetime, elided or not, that lifetime is\n-  assigned to all elided lifetimes in the return values of that function.\n \n-* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n-  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n \n-Otherwise, it is an error to elide an output lifetime.\n \n-### Examples\n \n-Here are some examples of functions with elided lifetimes.  We've paired each\n-example of an elided lifetime with its expanded form.\n \n-```{rust,ignore}\n-fn print(s: &str); // elided\n-fn print<'a>(s: &'a str); // expanded\n \n-fn debug(lvl: u32, s: &str); // elided\n-fn debug<'a>(lvl: u32, s: &'a str); // expanded\n \n-// In the preceding example, `lvl` doesn't need a lifetime because it's not a\n-// reference (`&`). Only things relating to references (such as a `struct`\n-// which contains a reference) need lifetimes.\n-\n-fn substr(s: &str, until: u32) -> &str; // elided\n-fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n-\n-fn get_str() -> &str; // ILLEGAL, no inputs\n-\n-fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n-fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n-\n-fn get_mut(&mut self) -> &mut T; // elided\n-fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n-\n-fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n-fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n-\n-fn new(buf: &mut [u8]) -> BufWriter; // elided\n-fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n-```\n \n-# Related Resources\n \n-Coming Soon."}, {"sha": "21feff73342ce0db1a83a52a7ea98cf70627c6be", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 334, "deletions": 1, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -1,3 +1,336 @@\n % References and Borrowing\n \n-Coming Soon! Until then, check out the [ownership](ownership.html) chapter.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. The there are a few distinct concepts, each with its own\n+chapter:\n+\n+* [ownership][ownership], ownership, the key concept\n+* borrowing, which you\u2019re reading now\n+* [lifetimes][lifetimes], an advanced concept of borrowing\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[ownership]: ownership.html\n+[lifetimes]: lifetimes.html\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let\u2019s learn about borrowing.\n+\n+# Borrowing\n+\n+At the end of the [ownership][ownership] section, we had a nasty function that looked\n+like this:\n+\n+```rust\n+fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n+    // do stuff with v1 and v2\n+\n+    // hand back ownership, and the result of our function\n+    (v1, v2, 42)\n+}\n+\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n+\n+let (v1, v2, answer) = foo(v1, v2);\n+```\n+\n+This is not idiomatic Rust, however, as it doesn\u2019t take advantage of borrowing. Here\u2019s\n+the first step:\n+\n+```rust\n+fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n+    // do stuff with v1 and v2\n+\n+    // return the answer\n+    42\n+}\n+\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n+\n+let answer = foo(&v1, &v2);\n+\n+// we can use v1 and v2 here!\n+```\n+\n+Instead of taking `Vec<i32>`s as our arguments, we take a reference:\n+`&Vec<i32>`. And instead of passing `v1` and `v2` directly, we pass `&v1` and\n+`&v2`. We call the `&T` type a \u2018reference\u2019, and rather than owning the resource,\n+it borrows ownership. A binding that borrows something does not deallocate the\n+resource when it goes out of scope. This means that after the call to `foo()`,\n+we can use our original bindings again.\n+\n+References are immutable, just like bindings. This means that inside of `foo()`,\n+the vectors can\u2019t be changed at all:\n+\n+```rust,ignore\n+fn foo(v: &Vec<i32>) {\n+     v.push(5);\n+}\n+\n+let v = vec![];\n+\n+foo(&v);\n+```\n+\n+errors with:\n+\n+```text\n+error: cannot borrow immutable borrowed content `*v` as mutable\n+v.push(5);\n+^\n+```\n+\n+Pushing a value mutates the vector, and so we aren\u2019t allowed to do it.\n+\n+# &mut references\n+\n+There\u2019s a second kind of reference: `&mut T`. A \u2018mutable reference\u2019 allows you\n+to mutate the resource you\u2019re borrowing. For example:\n+\n+```rust\n+let mut x = 5;\n+{\n+    let y = &mut x;\n+    *y += 1;\n+}\n+println!(\"{}\", x);\n+```\n+\n+This will print `6`. We make `y` a mutable reference to `x`, then add one to\n+the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well,\n+if it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n+\n+Otherwise, `&mut` references are just like references. There _is_ a large\n+difference between the two, and how they interact, though. You can tell\n+something is fishy in the above example, because we need that extra scope, with\n+the `{` and `}`. If we remove them, we get an error:\n+\n+```text\n+error: cannot borrow `x` as immutable because it is also borrowed as mutable\n+    println!(\"{}\", x);\n+                   ^\n+note: previous borrow of `x` occurs here; the mutable borrow prevents\n+subsequent moves, borrows, or modification of `x` until the borrow ends\n+        let y = &mut x;\n+                     ^\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+As it turns out, there are rules.\n+\n+# The Rules\n+\n+Here\u2019s the rules about borrowing in Rust:\n+\n+First, any borrow must last for a smaller scope than the owner. Second, you may\n+have one or the other of these two kinds of borrows, but not both at the same\n+time:\n+\n+* 0 to N references (`&T`) to a resource.\n+* exactly one mutable reference (`&mut T`)\n+\n+\n+You may notice that this is very similar, though not exactly the same as,\n+to the definition of a data race:\n+\n+> There is a \u2018data race\u2019 when two or more pointers access the same memory\n+> location at the same time, where at least one of them is writing, and the\n+> operations are not synchronized.\n+\n+With references, you may have as many as you\u2019d like, since none of them are\n+writing. If you are writing, you need two or more pointers to the same memory,\n+and you can only have one `&mut` at a time. This is how Rust prevents data\n+races at compile time: we\u2019ll get errors if we break the rules.\n+\n+With this in mind, let\u2019s consider our example again.\n+\n+## Thinking in scopes\n+\n+Here\u2019s the code:\n+\n+```rust,ignore\n+let mut x = 5;\n+let y = &mut x;\n+\n+*y += 1;\n+\n+println!(\"{}\", x);\n+```\n+\n+This code gives us this error:\n+\n+```text\n+error: cannot borrow `x` as immutable because it is also borrowed as mutable\n+    println!(\"{}\", x);\n+                   ^\n+```\n+\n+This is because we\u2019ve violated the rules: we have a `&mut T` pointing to `x`,\n+and so we aren\u2019t allowed to create any `&T`s. One or the other. The note\n+hints at how to think about this problem:\n+\n+```text\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+In other words, the mutable borow is held through the rest of our example. What\n+we want is for the mutable borrow to end _before_ we try to call `println!` and\n+make an immutable borrow. In Rust, borrowing is tied to the scope that the\n+borrow is valid for. And our scopes look like this:\n+\n+```rust,ignore\n+let mut x = 5;\n+\n+let y = &mut x;    // -+ &mut borrow of x starts here\n+                   //  |\n+*y += 1;           //  |\n+                   //  |\n+println!(\"{}\", x); // -+ - try to borrow x here\n+                   // -+ &mut borrow of x ends here\n+```\n+\n+The scopes conflict: we can\u2019t make an `&x` while `y` is in scope.\n+\n+So when we add the curly braces:\n+\n+```rust\n+let mut x = 5;\n+\n+{                   \n+    let y = &mut x; // -+ &mut borrow starts here\n+    *y += 1;        //  |\n+}                   // -+ ... and ends here\n+\n+println!(\"{}\", x);  // <- try to borrow x here\n+```\n+\n+There\u2019s no problem. Our mutable borrow goes out of scope before we create an\n+immutable one. But scope is the key to seeing how long a borrow lasts for.\n+\n+## Issues borrowing prevents\n+\n+Why have these restrictive rules? Well, as we noted, these rules prevent data\n+races. What kinds of issues do data races cause? Here\u2019s a few.\n+\n+### Iterator invalidation\n+\n+One example is \u2018iterator invalidation\u2019, which happens when you try to mutate a\n+collection that you\u2019re iterating over. Rust\u2019s borrow checker prevents this from\n+happening:\n+\n+```rust\n+let mut v = vec![1, 2, 3];\n+\n+for i in &v {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This prints out one through three. As we iterate through the vectors, we\u2019re\n+only given references to the elements. And `v` is itself borrowed as immutable,\n+which means we can\u2019t change it while we\u2019re iterating:\n+\n+```rust,ignore\n+let mut v = vec![1, 2, 3];\n+\n+for i in &v {\n+    println!(\"{}\", i);\n+    v.push(34);\n+}\n+```\n+\n+Here\u2019s the error:\n+\n+```text\n+error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    v.push(34);\n+    ^\n+note: previous borrow of `v` occurs here; the immutable borrow prevents\n+subsequent moves or mutable borrows of `v` until the borrow ends\n+for i in &v {\n+          ^\n+note: previous borrow ends here\n+for i in &v {\n+    println!(\u201c{}\u201d, i);\n+    v.push(34);\n+}\n+^\n+```\n+\n+We can\u2019t modify `v` because it\u2019s borrowed by the loop.\n+\n+### use after free\n+\n+References must live as long as the resource they refer to. Rust will check the\n+scopes of your references to ensure that this is true.\n+\n+If Rust didn\u2019t check that this property, we could accidentally use a reference\n+which was invalid. For example:\n+\n+```rust,ignore\n+let y: &i32;\n+{ \n+    let x = 5;\n+    y = &x;\n+}\n+\n+println!(\"{}\", y);\n+```\n+\n+We get this error:\n+\n+error: `x` does not live long enough\n+    y = &x;\n+         ^\n+note: reference must be valid for the block suffix following statement 0 at\n+2:16...\n+let y: &i32;\n+{ \n+    let x = 5;\n+    y = &x;\n+}\n+\n+note: ...but borrowed value is only valid for the block suffix following\n+statement 0 at 4:18\n+    let x = 5;\n+    y = &x;\n+}\n+```\n+\n+In other words, `y` is only valid for the scope where `x` exists. As soon as\n+`x` goes away, it becomes invalid to refer to it. As such, the error says that\n+the borrow \u2018doesn\u2019t live long enough\u2019 because it\u2019s not valid for the right\n+amount of time."}, {"sha": "19d2df0b486cf8acb440e6cd790e1aaaf63140ce", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252b5444daf83a9f1b18e2dfe4b46830d2be4447/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=252b5444daf83a9f1b18e2dfe4b46830d2be4447", "patch": "@@ -37,7 +37,7 @@ An example of an empty type is `enum Empty { }`.\n E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. To match against NaN values, you should\n-instead use the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+instead use the `is_nan` method in a guard, as in: `x if x.is_nan() => ...`\n \"##,\n \n E0004: r##\"\n@@ -71,7 +71,7 @@ failure.\n E0007: r##\"\n This error indicates that the bindings in a match arm would require a value to\n be moved into more than one location, thus violating unique ownership. Code like\n-the following is invalid as it requires the entire Option<String> to be moved\n+the following is invalid as it requires the entire `Option<String>` to be moved\n into a variable called `op_string` while simultaneously requiring the inner\n String to be moved into a variable called `s`.\n \n@@ -99,10 +99,10 @@ match Some(\"hi\".to_string()) {\n }\n ```\n \n-The variable `s` has type String, and its use in the guard is as a variable of\n-type String. The guard code effectively executes in a separate scope to the body\n-of the arm, so the value would be moved into this anonymous scope and therefore\n-become unavailable in the body of the arm. Although this example seems\n+The variable `s` has type `String`, and its use in the guard is as a variable of\n+type `String`. The guard code effectively executes in a separate scope to the\n+body of the arm, so the value would be moved into this anonymous scope and\n+therefore become unavailable in the body of the arm. Although this example seems\n innocuous, the problem is most clear when considering functions that take their\n argument by value.\n \n@@ -140,7 +140,8 @@ match x {\n ```\n \n You have two solutions:\n-1. Bind the pattern's values the same way:\n+\n+Solution #1: Bind the pattern's values the same way.\n \n ```\n struct X { x: (), }\n@@ -153,8 +154,9 @@ match x {\n }\n ```\n \n-2. Implement the `Copy` trait for the X structure (however, please\n-keep in mind that the first solution should be preferred!):\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n \n ```\n #[derive(Clone, Copy)]\n@@ -258,11 +260,13 @@ functions via FFI or marked as unsafe, is potentially dangerous and disallowed\n by safety checks. As such, those safety checks can be temporarily relaxed by\n wrapping the unsafe instructions inside an `unsafe` block. For instance:\n \n+```\n unsafe fn f() { return; }\n \n fn main() {\n     unsafe { f(); }\n }\n+```\n \n See also http://doc.rust-lang.org/book/unsafe.html\n \"##,\n@@ -313,8 +317,8 @@ it around as usual.\n \n E0162: r##\"\n An if-let pattern attempts to match the pattern, and enters the body if the\n-match was succesful. If the match is irrefutable (when it cannot fail to match),\n-use a regular `let`-binding instead. For instance:\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n \n ```\n struct Irrefutable(i32);\n@@ -334,8 +338,8 @@ foo(x);\n \n E0165: r##\"\n A while-let pattern attempts to match the pattern, and enters the body if the\n-match was succesful. If the match is irrefutable (when it cannot fail to match),\n-use a regular `let`-binding inside a `loop` instead. For instance:\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n \n ```\n struct Irrefutable(i32);\n@@ -374,7 +378,7 @@ match m {\n ```\n \n If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so rustc warns when\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n that happens.\n \n Qualified names are good practice, and most code works well with them. But if\n@@ -403,16 +407,16 @@ const Y: u32 = X;\n \"##,\n \n E0267: r##\"\n-This error indicates the use of loop keyword (break or continue) inside a\n-closure but outside of any loop. Break and continue can be used as normal\n-inside closures as long as they are also contained within a loop. To halt the\n-execution of a closure you should instead use a return statement.\n+This error indicates the use of a loop keyword (`break` or `continue`) inside a\n+closure but outside of any loop. Break and continue can be used as normal inside\n+closures as long as they are also contained within a loop. To halt the execution\n+of a closure you should instead use a return statement.\n \"##,\n \n E0268: r##\"\n-This error indicates the use of loop keyword (break or continue) outside of a\n-loop. Without a loop to break out of or continue in, no sensible action can be\n-taken.\n+This error indicates the use of a loop keyword (`break` or `continue`) outside\n+of a loop. Without a loop to break out of or continue in, no sensible action can\n+be taken.\n \"##,\n \n E0296: r##\"\n@@ -507,7 +511,7 @@ match Some(\"hi\".to_string()) {\n }\n ```\n \n-The `op_string_ref` binding has type &Option<&String> in both cases.\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n \n See also https://github.com/rust-lang/rust/issues/14587\n \"##,"}]}