{"sha": "dff7e74b27f8b450c7a084f04ec54a198c0f016f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZjdlNzRiMjdmOGI0NTBjN2EwODRmMDRlYzU0YTE5OGMwZjAxNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T17:08:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T17:08:45Z"}, "message": "Auto merge of #5903 - jrqc:needless_return, r=ebroto,flip1995\n\nNeedless return\n\nFixes #5858\nchangelog: fix false positive [`needless_return`]", "tree": {"sha": "18522921a1272d985b5230a8a20c8651d9b42930", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18522921a1272d985b5230a8a20c8651d9b42930"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dff7e74b27f8b450c7a084f04ec54a198c0f016f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dff7e74b27f8b450c7a084f04ec54a198c0f016f", "html_url": "https://github.com/rust-lang/rust/commit/dff7e74b27f8b450c7a084f04ec54a198c0f016f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dff7e74b27f8b450c7a084f04ec54a198c0f016f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e05fc1c61987682ca42fc65bde0d7c11affc65", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e05fc1c61987682ca42fc65bde0d7c11affc65", "html_url": "https://github.com/rust-lang/rust/commit/c8e05fc1c61987682ca42fc65bde0d7c11affc65"}, {"sha": "baa4cb1cddc3a8ce1f47c4006e236edf082ee858", "url": "https://api.github.com/repos/rust-lang/rust/commits/baa4cb1cddc3a8ce1f47c4006e236edf082ee858", "html_url": "https://github.com/rust-lang/rust/commit/baa4cb1cddc3a8ce1f47c4006e236edf082ee858"}], "stats": {"total": 755, "additions": 412, "deletions": 343}, "files": [{"sha": "fa560ffb980c82407d748018b6b12717c7572267", "filename": "clippy_lints/src/let_and_return.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c8e05fc1c61987682ca42fc65bde0d7c11affc65/clippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e05fc1c61987682ca42fc65bde0d7c11affc65/clippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_and_return.rs?ref=c8e05fc1c61987682ca42fc65bde0d7c11affc65", "patch": "@@ -1,124 +0,0 @@\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_then};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `let`-bindings, which are subsequently\n-    /// returned.\n-    ///\n-    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo() -> String {\n-    ///     let x = String::new();\n-    ///     x\n-    /// }\n-    /// ```\n-    /// instead, use\n-    /// ```\n-    /// fn foo() -> String {\n-    ///     String::new()\n-    /// }\n-    /// ```\n-    pub LET_AND_RETURN,\n-    style,\n-    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n-}\n-\n-declare_lint_pass!(LetReturn => [LET_AND_RETURN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LetReturn {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        // we need both a let-binding stmt and an expr\n-        if_chain! {\n-            if let Some(retexpr) = block.expr;\n-            if let Some(stmt) = block.stmts.iter().last();\n-            if let StmtKind::Local(local) = &stmt.kind;\n-            if local.ty.is_none();\n-            if local.attrs.is_empty();\n-            if let Some(initexpr) = &local.init;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            if let ExprKind::Path(qpath) = &retexpr.kind;\n-            if match_qpath(qpath, &[&*ident.name.as_str()]);\n-            if !last_statement_borrows(cx, initexpr);\n-            if !in_external_macro(cx.sess(), initexpr.span);\n-            if !in_external_macro(cx.sess(), retexpr.span);\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    LET_AND_RETURN,\n-                    retexpr.span,\n-                    \"returning the result of a `let` binding from a block\",\n-                    |err| {\n-                        err.span_label(local.span, \"unnecessary `let` binding\");\n-\n-                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n-                            err.multipart_suggestion(\n-                                \"return the expression directly\",\n-                                vec![\n-                                    (local.span, String::new()),\n-                                    (retexpr.span, snippet),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n-                .tcx\n-                .fn_sig(def_id)\n-                .output()\n-                .skip_binder()\n-                .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "f28d281a49762f3378b3df1776b37861e53d9976", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -218,7 +218,6 @@ mod large_const_arrays;\n mod large_enum_variant;\n mod large_stack_arrays;\n mod len_zero;\n-mod let_and_return;\n mod let_if_seq;\n mod let_underscore;\n mod lifetimes;\n@@ -311,6 +310,7 @@ mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n+mod unused_unit;\n mod unwrap;\n mod use_self;\n mod useless_conversion;\n@@ -587,7 +587,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &large_stack_arrays::LARGE_STACK_ARRAYS,\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n-        &let_and_return::LET_AND_RETURN,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n         &let_underscore::LET_UNDERSCORE_LOCK,\n         &let_underscore::LET_UNDERSCORE_MUST_USE,\n@@ -771,8 +770,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &regex::INVALID_REGEX,\n         &regex::TRIVIAL_REGEX,\n         &repeat_once::REPEAT_ONCE,\n+        &returns::LET_AND_RETURN,\n         &returns::NEEDLESS_RETURN,\n-        &returns::UNUSED_UNIT,\n         &serde_api::SERDE_API_MISUSE,\n         &shadow::SHADOW_REUSE,\n         &shadow::SHADOW_SAME,\n@@ -843,6 +842,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n         &unused_io_amount::UNUSED_IO_AMOUNT,\n         &unused_self::UNUSED_SELF,\n+        &unused_unit::UNUSED_UNIT,\n         &unwrap::PANICKING_UNWRAP,\n         &unwrap::UNNECESSARY_UNWRAP,\n         &use_self::USE_SELF,\n@@ -1029,8 +1029,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box misc_early::MiscEarlyLints);\n     store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n     store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_early_pass(|| box returns::Return);\n-    store.register_late_pass(|| box let_and_return::LetReturn);\n+    store.register_early_pass(|| box unused_unit::UnusedUnit);\n+    store.register_late_pass(|| box returns::Return);\n     store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n@@ -1288,7 +1288,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n@@ -1418,8 +1417,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n-        LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n@@ -1466,6 +1465,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n@@ -1506,7 +1506,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1561,8 +1560,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n-        LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n@@ -1571,6 +1570,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::FN_TO_NUMERIC_CAST),\n         LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n         LintId::of(&write::PRINT_WITH_NEWLINE),"}, {"sha": "3c5541e64b4d44f5d920b8f46b25c2f8252c76f2", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 210, "deletions": 207, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -1,60 +1,67 @@\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_ast::visit::FnKind;\n+use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n \n-use crate::utils::{snippet_opt, span_lint_and_sugg, span_lint_and_then};\n+use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for return statements at the end of a block.\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n     ///\n-    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n     /// more rusty.\n     ///\n-    /// **Known problems:** If the computation returning the value borrows a local\n-    /// variable, removing the `return` may run afoul of the borrow checker.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     return x;\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n     /// }\n     /// ```\n-    /// simplify to\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     x\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n     /// }\n     /// ```\n-    pub NEEDLESS_RETURN,\n+    pub LET_AND_RETURN,\n     style,\n-    \"using a return statement like `return expr;` where an expression would suffice\"\n+    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    /// **What it does:** Checks for return statements at the end of a block.\n     ///\n-    /// **Why is this bad?** Such expressions add no value, but can make the code\n-    /// less readable. Depending on formatting they can make a `break` or `return`\n-    /// statement look like a function call.\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n     ///\n-    /// **Known problems:** The lint currently misses unit return types in types,\n-    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn return_unit() -> () {\n-    ///     ()\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n     /// }\n     /// ```\n-    pub UNUSED_UNIT,\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RETURN,\n     style,\n-    \"needless unit expression\"\n+    \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n #[derive(PartialEq, Eq, Copy, Clone)]\n@@ -63,221 +70,217 @@ enum RetReplacement {\n     Block,\n }\n \n-declare_lint_pass!(Return => [NEEDLESS_RETURN, UNUSED_UNIT]);\n+declare_lint_pass!(Return => [LET_AND_RETURN, NEEDLESS_RETURN]);\n \n-impl Return {\n-    // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if let Some(stmt) = block.stmts.last() {\n-            match stmt.kind {\n-                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n-                    self.check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-                },\n-                _ => (),\n+impl<'tcx> LateLintPass<'tcx> for Return {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        // we need both a let-binding stmt and an expr\n+        if_chain! {\n+            if let Some(retexpr) = block.expr;\n+            if let Some(stmt) = block.stmts.iter().last();\n+            if let StmtKind::Local(local) = &stmt.kind;\n+            if local.ty.is_none();\n+            if local.attrs.is_empty();\n+            if let Some(initexpr) = &local.init;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            if let ExprKind::Path(qpath) = &retexpr.kind;\n+            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if !last_statement_borrows(cx, initexpr);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n+            if !in_external_macro(cx.sess(), retexpr.span);\n+            if !in_external_macro(cx.sess(), local.span);\n+            if !in_macro(local.span);\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    LET_AND_RETURN,\n+                    retexpr.span,\n+                    \"returning the result of a `let` binding from a block\",\n+                    |err| {\n+                        err.span_label(local.span, \"unnecessary `let` binding\");\n+\n+                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n+                            err.multipart_suggestion(\n+                                \"return the expression directly\",\n+                                vec![\n+                                    (local.span, String::new()),\n+                                    (retexpr.span, snippet),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n+                        }\n+                    },\n+                );\n             }\n         }\n     }\n \n-    // Check the final expression in a block if it's a return.\n-    fn check_final_expr(\n+    fn check_fn(\n         &mut self,\n-        cx: &EarlyContext<'_>,\n-        expr: &ast::Expr,\n-        span: Option<Span>,\n-        replacement: RetReplacement,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        _: &'tcx FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        _: HirId,\n     ) {\n-        match expr.kind {\n-            // simple return is always \"bad\"\n-            ast::ExprKind::Ret(ref inner) => {\n-                // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-                if !expr.attrs.iter().any(attr_is_cfg) {\n-                    Self::emit_return_lint(\n-                        cx,\n-                        span.expect(\"`else return` is not possible\"),\n-                        inner.as_ref().map(|i| i.span),\n-                        replacement,\n-                    );\n-                }\n-            },\n-            // a whole block? check it!\n-            ast::ExprKind::Block(ref block, _) => {\n-                self.check_block_return(cx, block);\n-            },\n-            // an if/if let expr, check both exprs\n-            // note, if without else is going to be a type checking error anyways\n-            // (except for unit type functions) so we don't match it\n-            ast::ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n-                self.check_block_return(cx, ifblock);\n-                self.check_final_expr(cx, elsexpr, None, RetReplacement::Empty);\n-            },\n-            // a match expr, check all arms\n-            ast::ExprKind::Match(_, ref arms) => {\n-                for arm in arms {\n-                    self.check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+        match kind {\n+            FnKind::Closure(_) => check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty),\n+            FnKind::ItemFn(..) | FnKind::Method(..) => {\n+                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                    check_block_return(cx, block);\n                 }\n             },\n-            _ => (),\n         }\n     }\n+}\n \n-    fn emit_return_lint(cx: &EarlyContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n-        match inner_span {\n-            Some(inner_span) => {\n-                if in_external_macro(cx.sess(), inner_span) || inner_span.from_expansion() {\n-                    return;\n-                }\n+fn attr_is_cfg(attr: &Attribute) -> bool {\n+    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+}\n \n-                span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n-                    if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                        diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n-                    }\n-                })\n+fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+    if let Some(expr) = block.expr {\n+        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n+    } else if let Some(stmt) = block.stmts.iter().last() {\n+        match stmt.kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n             },\n-            None => match replacement {\n-                RetReplacement::Empty => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"remove `return`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                RetReplacement::Block => {\n-                    span_lint_and_sugg(\n+            _ => (),\n+        }\n+    }\n+}\n+\n+fn check_final_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    span: Option<Span>,\n+    replacement: RetReplacement,\n+) {\n+    match expr.kind {\n+        // simple return is always \"bad\"\n+        ExprKind::Ret(ref inner) => {\n+            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n+            if !expr.attrs.iter().any(attr_is_cfg) {\n+                let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n+                if !borrows {\n+                    emit_return_lint(\n                         cx,\n-                        NEEDLESS_RETURN,\n-                        ret_span,\n-                        \"unneeded `return` statement\",\n-                        \"replace `return` with an empty block\",\n-                        \"{}\".to_string(),\n-                        Applicability::MachineApplicable,\n+                        span.expect(\"`else return` is not possible\"),\n+                        inner.as_ref().map(|i| i.span),\n+                        replacement,\n                     );\n-                },\n+                }\n+            }\n+        },\n+        // a whole block? check it!\n+        ExprKind::Block(ref block, _) => {\n+            check_block_return(cx, block);\n+        },\n+        // a match expr, check all arms\n+        // an if/if let expr, check both exprs\n+        // note, if without else is going to be a type checking error anyways\n+        // (except for unit type functions) so we don't match it\n+        ExprKind::Match(_, ref arms, source) => match source {\n+            MatchSource::Normal => {\n+                for arm in arms.iter() {\n+                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                }\n             },\n-        }\n+            MatchSource::IfDesugar {\n+                contains_else_clause: true,\n+            }\n+            | MatchSource::IfLetDesugar {\n+                contains_else_clause: true,\n+            } => {\n+                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                    check_block_return(cx, ifblock);\n+                }\n+                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n+            },\n+            _ => (),\n+        },\n+        _ => (),\n     }\n }\n \n-impl EarlyLintPass for Return {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n-        match kind {\n-            FnKind::Fn(.., Some(block)) => self.check_block_return(cx, block),\n-            FnKind::Closure(_, body) => self.check_final_expr(cx, body, Some(body.span), RetReplacement::Empty),\n-            FnKind::Fn(.., None) => {},\n-        }\n-        if_chain! {\n-            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n-            if let ast::TyKind::Tup(ref vals) = ty.kind;\n-            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n-            then {\n-                lint_unneeded_unit_return(cx, ty, span);\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    match inner_span {\n+        Some(inner_span) => {\n+            if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {\n+                return;\n             }\n-        }\n-    }\n \n-    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        if_chain! {\n-            if let Some(ref stmt) = block.stmts.last();\n-            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n-            if is_unit_expr(expr) && !stmt.span.from_expansion();\n-            then {\n-                let sp = expr.span;\n+            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n+                if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n+                }\n+            })\n+        },\n+        None => match replacement {\n+            RetReplacement::Empty => {\n                 span_lint_and_sugg(\n                     cx,\n-                    UNUSED_UNIT,\n-                    sp,\n-                    \"unneeded unit expression\",\n-                    \"remove the final `()`\",\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"remove `return`\",\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 );\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        match e.kind {\n-            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n-                if is_unit_expr(expr) && !expr.span.from_expansion() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNUSED_UNIT,\n-                        expr.span,\n-                        \"unneeded `()`\",\n-                        \"remove the `()`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n             },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n-        let segments = &poly.trait_ref.path.segments;\n-\n-        if_chain! {\n-            if segments.len() == 1;\n-            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n-            if let Some(args) = &segments[0].args;\n-            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n-            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n-            if ty.kind.is_unit();\n-            then {\n-                lint_unneeded_unit_return(cx, ty, generic_args.span);\n-            }\n-        }\n+            RetReplacement::Block => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"replace `return` with an empty block\",\n+                    \"{}\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        },\n     }\n }\n \n-fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    let mut visitor = BorrowVisitor { cx, borrows: false };\n+    walk_expr(&mut visitor, expr);\n+    visitor.borrows\n }\n \n-// get the def site\n-#[must_use]\n-fn get_def(span: Span) -> Option<Span> {\n-    if span.from_expansion() {\n-        Some(span.ctxt().outer_expn_data().def_site)\n-    } else {\n-        None\n-    }\n+struct BorrowVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    borrows: bool,\n }\n \n-// is this expr a `()` unit?\n-fn is_unit_expr(expr: &ast::Expr) -> bool {\n-    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n-        vals.is_empty()\n-    } else {\n-        false\n+impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.borrows {\n+            return;\n+        }\n+\n+        if let Some(def_id) = fn_def_id(self.cx, expr) {\n+            self.borrows = self\n+                .cx\n+                .tcx\n+                .fn_sig(def_id)\n+                .output()\n+                .skip_binder()\n+                .walk()\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+        }\n+\n+        walk_expr(self, expr);\n     }\n-}\n \n-fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n-    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        fn_source\n-            .rfind(\"->\")\n-            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n-                (\n-                    #[allow(clippy::cast_possible_truncation)]\n-                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                    Applicability::MachineApplicable,\n-                )\n-            })\n-    } else {\n-        (ty.span, Applicability::MaybeIncorrect)\n-    };\n-    span_lint_and_sugg(\n-        cx,\n-        UNUSED_UNIT,\n-        ret_span,\n-        \"unneeded unit return type\",\n-        \"remove the `-> ()`\",\n-        String::new(),\n-        appl,\n-    );\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n }"}, {"sha": "7548c6afa973afec4838369bb06ed8b6bd5efd3c", "filename": "clippy_lints/src/unused_unit.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -0,0 +1,144 @@\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_ast::visit::FnKind;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::BytePos;\n+\n+use crate::utils::span_lint_and_sugg;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    ///\n+    /// **Why is this bad?** Such expressions add no value, but can make the code\n+    /// less readable. Depending on formatting they can make a `break` or `return`\n+    /// statement look like a function call.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn return_unit() -> () {\n+    ///     ()\n+    /// }\n+    /// ```\n+    pub UNUSED_UNIT,\n+    style,\n+    \"needless unit expression\"\n+}\n+\n+declare_lint_pass!(UnusedUnit => [UNUSED_UNIT]);\n+\n+impl EarlyLintPass for UnusedUnit {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n+        if_chain! {\n+            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n+            if let ast::TyKind::Tup(ref vals) = ty.kind;\n+            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n+            then {\n+                lint_unneeded_unit_return(cx, ty, span);\n+            }\n+        }\n+    }\n+\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+        if_chain! {\n+            if let Some(ref stmt) = block.stmts.last();\n+            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n+            if is_unit_expr(expr) && !stmt.span.from_expansion();\n+            then {\n+                let sp = expr.span;\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNUSED_UNIT,\n+                    sp,\n+                    \"unneeded unit expression\",\n+                    \"remove the final `()`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        match e.kind {\n+            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n+                if is_unit_expr(expr) && !expr.span.from_expansion() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNUSED_UNIT,\n+                        expr.span,\n+                        \"unneeded `()`\",\n+                        \"remove the `()`\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n+        let segments = &poly.trait_ref.path.segments;\n+\n+        if_chain! {\n+            if segments.len() == 1;\n+            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n+            if let Some(args) = &segments[0].args;\n+            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n+            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n+            if ty.kind.is_unit();\n+            then {\n+                lint_unneeded_unit_return(cx, ty, generic_args.span);\n+            }\n+        }\n+    }\n+}\n+\n+// get the def site\n+#[must_use]\n+fn get_def(span: Span) -> Option<Span> {\n+    if span.from_expansion() {\n+        Some(span.ctxt().outer_expn_data().def_site)\n+    } else {\n+        None\n+    }\n+}\n+\n+// is this expr a `()` unit?\n+fn is_unit_expr(expr: &ast::Expr) -> bool {\n+    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n+        vals.is_empty()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n+    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n+    } else {\n+        (ty.span, Applicability::MaybeIncorrect)\n+    };\n+    span_lint_and_sugg(\n+        cx,\n+        UNUSED_UNIT,\n+        ret_span,\n+        \"unneeded unit return type\",\n+        \"remove the `-> ()`\",\n+        String::new(),\n+        appl,\n+    );\n+}"}, {"sha": "233f95deeddc4e9c4546b03842579fff5ec48dd9", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -1037,7 +1037,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n         deprecation: None,\n-        module: \"let_and_return\",\n+        module: \"returns\",\n     },\n     Lint {\n         name: \"let_underscore_lock\",\n@@ -2493,7 +2493,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"needless unit expression\",\n         deprecation: None,\n-        module: \"returns\",\n+        module: \"unused_unit\",\n     },\n     Lint {\n         name: \"unwrap_used\","}, {"sha": "d849e093da7bb821a765122d0d966ba78adf4a39", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -69,6 +69,23 @@ fn test_void_match(x: u32) {\n     }\n }\n \n+fn read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n+}\n+\n+fn borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        String::from(\"test\")\n+    } else {\n+        String::new()\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "29f2bd1852af00e9f1df68916f1f7624046e4c93", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -69,6 +69,23 @@ fn test_void_match(x: u32) {\n     }\n }\n \n+fn read_line() -> String {\n+    use std::io::BufRead;\n+    let stdin = ::std::io::stdin();\n+    return stdin.lock().lines().next().unwrap().unwrap();\n+}\n+\n+fn borrows_but_not_last(value: bool) -> String {\n+    if value {\n+        use std::io::BufRead;\n+        let stdin = ::std::io::stdin();\n+        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        return String::from(\"test\");\n+    } else {\n+        return String::new();\n+    }\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_no_semicolon();"}, {"sha": "f73c833a801f3dc143bb92545a5e7ad41b566916", "filename": "tests/ui/needless_return.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dff7e74b27f8b450c7a084f04ec54a198c0f016f/tests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dff7e74b27f8b450c7a084f04ec54a198c0f016f/tests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.stderr?ref=dff7e74b27f8b450c7a084f04ec54a198c0f016f", "patch": "@@ -72,5 +72,17 @@ error: unneeded `return` statement\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with an empty block: `{}`\n \n-error: aborting due to 12 previous errors\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:83:9\n+   |\n+LL |         return String::from(\"test\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n+\n+error: unneeded `return` statement\n+  --> $DIR/needless_return.rs:85:9\n+   |\n+LL |         return String::new();\n+   |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n+\n+error: aborting due to 14 previous errors\n "}]}