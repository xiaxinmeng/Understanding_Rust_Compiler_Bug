{"sha": "8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NjFmNzk0ODVmMTFlZjAzZWI2Y2I1NjljY2I5ZjRjNzNlNjhmMTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-20T03:18:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-24T08:15:17Z"}, "message": "Remove deriving(ToStr)\n\nThis has been superseded by deriving(Show).\n\ncc #9806", "tree": {"sha": "411eefd07ab744efb0d4934e12900a40912b44d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411eefd07ab744efb0d4934e12900a40912b44d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "html_url": "https://github.com/rust-lang/rust/commit/8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b78b749810f4ed53e8287adfb284f9f32f16b73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b78b749810f4ed53e8287adfb284f9f32f16b73c", "html_url": "https://github.com/rust-lang/rust/commit/b78b749810f4ed53e8287adfb284f9f32f16b73c"}], "stats": {"total": 186, "additions": 27, "deletions": 159}, "files": [{"sha": "171203b00b806c7e35f47f5a339a20be559a9d7e", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -405,8 +405,8 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n     ///Returns a string representation of a Leaf.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { if_ok!(write!(f.buf, \" // \")) }\n-            if_ok!(write!(f.buf, \"{}\", *s))\n+            if i != 0 { try!(write!(f.buf, \" // \")) }\n+            try!(write!(f.buf, \"{}\", *s))\n         }\n         Ok(())\n     }\n@@ -626,8 +626,8 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Branch<K, V> {\n     ///Returns a string representation of a Branch.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { if_ok!(write!(f.buf, \" // \")) }\n-            if_ok!(write!(f.buf, \"{}\", *s))\n+            if i != 0 { try!(write!(f.buf, \" // \")) }\n+            try!(write!(f.buf, \"{}\", *s))\n         }\n         write!(f.buf, \" // rightmost child: ({}) \", *self.rightmost_child)\n     }"}, {"sha": "68bc5f1b6c4ff60c7818b604b1ebfd475d29e4f1", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -222,24 +222,24 @@ impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f.buf, r\"\\{\"));\n         let mut cur = self.head;\n         for i in range(0, self.len()) {\n-            if i > 0 { if_ok!(write!(f.buf, \", \")) }\n+            if i > 0 { try!(write!(f.buf, \", \")) }\n             unsafe {\n                 cur = (*cur).next;\n                 match (*cur).key {\n                     // should never print nil\n-                    None => if_ok!(write!(f.buf, \"nil\")),\n-                    Some(ref k) => if_ok!(write!(f.buf, \"{}\", *k)),\n+                    None => try!(write!(f.buf, \"nil\")),\n+                    Some(ref k) => try!(write!(f.buf, \"{}\", *k)),\n                 }\n             }\n-            if_ok!(write!(f.buf, \": \"));\n+            try!(write!(f.buf, \": \"));\n             unsafe {\n                 match (*cur).value {\n                     // should never print nil\n-                    None => if_ok!(write!(f.buf, \"nil\")),\n-                    Some(ref value) => if_ok!(write!(f.buf, \"{}\", *value)),\n+                    None => try!(write!(f.buf, \"nil\")),\n+                    Some(ref value) => try!(write!(f.buf, \"{}\", *value)),\n                 }\n             }\n         }"}, {"sha": "0292a18817ccd8bf457bb56d60b66a18b0effdfd", "filename": "src/libextra/url.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -803,25 +803,25 @@ impl fmt::Show for Url {\n      * result in just \"http://somehost.com\".\n      */\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"{}:\", self.scheme));\n+        try!(write!(f.buf, \"{}:\", self.scheme));\n \n         if !self.host.is_empty() {\n-            if_ok!(write!(f.buf, \"//\"));\n+            try!(write!(f.buf, \"//\"));\n             match self.user {\n-                Some(ref user) => if_ok!(write!(f.buf, \"{}\", *user)),\n+                Some(ref user) => try!(write!(f.buf, \"{}\", *user)),\n                 None => {}\n             }\n             match self.port {\n-                Some(ref port) => if_ok!(write!(f.buf, \"{}:{}\", self.host,\n+                Some(ref port) => try!(write!(f.buf, \"{}:{}\", self.host,\n                                                 *port)),\n-                None => if_ok!(write!(f.buf, \"{}\", self.host)),\n+                None => try!(write!(f.buf, \"{}\", self.host)),\n             }\n         }\n \n-        if_ok!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f.buf, \"{}\", self.path));\n \n         if !self.query.is_empty() {\n-            if_ok!(write!(f.buf, \"?{}\", query_to_str(&self.query)));\n+            try!(write!(f.buf, \"?{}\", query_to_str(&self.query)));\n         }\n \n         match self.fragment {\n@@ -834,9 +834,9 @@ impl fmt::Show for Url {\n \n impl fmt::Show for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f.buf, \"{}\", self.path));\n         if !self.query.is_empty() {\n-            if_ok!(write!(f.buf, \"?{}\", self.query))\n+            try!(write!(f.buf, \"?{}\", self.query))\n         }\n \n         match self.fragment {"}, {"sha": "9349e5c8e98d67c13d42a4c1d7ce5b39d51f4245", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -281,7 +281,7 @@ impl fmt::Show for Abi {\n \n impl fmt::Show for AbiSet {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"\\\"\"));\n+        try!(write!(f.buf, \"\\\"\"));\n         let mut first = true;\n         self.each(|abi| {\n             if first { first = false; }"}, {"sha": "2417a6fa1bacf9063081c0d0deb3021e8321f5e6", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -30,7 +30,7 @@ pub struct CrateId {\n \n impl fmt::Show for CrateId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if_ok!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f.buf, \"{}\", self.path));\n         let version = match self.version {\n             None => \"0.0\",\n             Some(ref version) => version.as_slice(),"}, {"sha": "9c823449d2141590f5e89c917bbdd1efaa60b093", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -27,7 +27,6 @@ pub mod encodable;\n pub mod decodable;\n pub mod hash;\n pub mod rand;\n-pub mod to_str;\n pub mod show;\n pub mod zero;\n pub mod default;\n@@ -85,7 +84,6 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n \n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n-                            \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n                             \"Show\" => expand!(show::expand_deriving_show),\n \n                             \"Zero\" => expand!(zero::expand_deriving_zero),"}, {"sha": "5cb81d9e762ae7074db533a274f5edb7c100e666", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b78b749810f4ed53e8287adfb284f9f32f16b73c/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b78b749810f4ed53e8287adfb284f9f32f16b73c/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=b78b749810f4ed53e8287adfb284f9f32f16b73c", "patch": "@@ -1,132 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use parse::token::InternedString;\n-use parse::token;\n-\n-pub fn expand_deriving_to_str(cx: &mut ExtCtxt,\n-                              span: Span,\n-                              mitem: @MetaItem,\n-                              item: @Item,\n-                              push: |@Item|) {\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"to_str\", \"ToStr\"]),\n-        additional_bounds: ~[],\n-        generics: LifetimeBounds::empty(),\n-        methods: ~[\n-            MethodDef {\n-                name: \"to_str\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: ~[],\n-                ret_ty: Ptr(~Literal(Path::new_local(\"str\")), Send),\n-                inline: false,\n-                const_nonmatching: false,\n-                combine_substructure: to_str_substructure\n-            }\n-        ]\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-// It used to be the case that this deriving implementation invoked\n-// std::repr::repr_to_str, but this isn't sufficient because it\n-// doesn't invoke the to_str() method on each field. Hence we mirror\n-// the logic of the repr_to_str() method, but with tweaks to call to_str()\n-// on sub-fields.\n-fn to_str_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure)\n-                       -> @Expr {\n-    let to_str = cx.ident_of(\"to_str\");\n-\n-    let doit = |start: &str,\n-                end: InternedString,\n-                name: ast::Ident,\n-                fields: &[FieldInfo]| {\n-        if fields.len() == 0 {\n-            cx.expr_str_uniq(span, token::get_ident(name))\n-        } else {\n-            let buf = cx.ident_of(\"buf\");\n-            let interned_str = token::get_ident(name);\n-            let start =\n-                token::intern_and_get_ident(interned_str.get() + start);\n-            let init = cx.expr_str_uniq(span, start);\n-            let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n-            let push_str = cx.ident_of(\"push_str\");\n-\n-            {\n-                let push = |s: @Expr| {\n-                    let ebuf = cx.expr_ident(span, buf);\n-                    let call = cx.expr_method_call(span, ebuf, push_str, ~[s]);\n-                    stmts.push(cx.stmt_expr(call));\n-                };\n-\n-                for (i, &FieldInfo {name, span, self_, .. }) in fields.iter().enumerate() {\n-                    if i > 0 {\n-                        push(cx.expr_str(span, InternedString::new(\", \")));\n-                    }\n-                    match name {\n-                        None => {}\n-                        Some(id) => {\n-                            let interned_id = token::get_ident(id);\n-                            let name = interned_id.get() + \": \";\n-                            push(cx.expr_str(span,\n-                                             token::intern_and_get_ident(name)));\n-                        }\n-                    }\n-                    push(cx.expr_method_call(span, self_, to_str, ~[]));\n-                }\n-                push(cx.expr_str(span, end));\n-            }\n-\n-            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span, buf))))\n-        }\n-    };\n-\n-    return match *substr.fields {\n-        Struct(ref fields) => {\n-            if fields.len() == 0 || fields[0].name.is_none() {\n-                doit(\"(\",\n-                     InternedString::new(\")\"),\n-                     substr.type_ident,\n-                     *fields)\n-            } else {\n-                doit(\"{\",\n-                     InternedString::new(\"}\"),\n-                     substr.type_ident,\n-                     *fields)\n-            }\n-        }\n-\n-        EnumMatching(_, variant, ref fields) => {\n-            match variant.node.kind {\n-                ast::TupleVariantKind(..) =>\n-                    doit(\"(\",\n-                         InternedString::new(\")\"),\n-                         variant.node.name,\n-                         *fields),\n-                ast::StructVariantKind(..) =>\n-                    doit(\"{\",\n-                         InternedString::new(\"}\"),\n-                         variant.node.name,\n-                         *fields),\n-            }\n-        }\n-\n-        _ => cx.bug(\"expected Struct or EnumMatching in deriving(ToStr)\")\n-    };\n-}"}, {"sha": "7a3ed09a492d710ce3c4583ef29f247fef8d3c9a", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -64,15 +64,15 @@ Examples of string representations:\n extern crate test;\n extern crate serialize;\n \n-use std::cast::{transmute,transmute_copy};\n use std::cast::{transmute,transmute_copy};\n use std::char::Char;\n-use std::cmp::Eq;\n-use std::cmp::Eq;\n use std::fmt;\n use std::hash::{Hash, sip};\n use std::num::FromStrRadix;\n use std::rand::Rng;\n+use std::rand;\n+use std::str;\n+use std::vec;\n \n use serialize::{Encoder, Encodable, Decoder, Decodable};\n "}, {"sha": "70c7200bee9aeb4433866b5bcb5707e2285bdf15", "filename": "src/test/run-pass/super-fast-paren-parsing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8761f79485f11ef03eb6cb569ccb9f4c73e68f11/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs?ref=8761f79485f11ef03eb6cb569ccb9f4c73e68f11", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty\n+\n static a: int =\n (((((((((((((((((((((((((((((((((((((((((((((((((((\n ((((((((((((((((((((((((((((((((((((((((((((((((((("}]}