{"sha": "c02710530c0005a30759e170be023cc167c6cd67", "node_id": "C_kwDOAAsO6NoAKGMwMjcxMDUzMGMwMDA1YTMwNzU5ZTE3MGJlMDIzY2MxNjdjNmNkNjc", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-21T04:56:32Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-29T18:39:08Z"}, "message": "review comments: clean up", "tree": {"sha": "5febd6d86c1fd02a017657fc40a5e6981cda9b47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5febd6d86c1fd02a017657fc40a5e6981cda9b47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c02710530c0005a30759e170be023cc167c6cd67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c02710530c0005a30759e170be023cc167c6cd67", "html_url": "https://github.com/rust-lang/rust/commit/c02710530c0005a30759e170be023cc167c6cd67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c02710530c0005a30759e170be023cc167c6cd67/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6e34ad108dc998e9f9d872e807e221c0df4f24b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e34ad108dc998e9f9d872e807e221c0df4f24b", "html_url": "https://github.com/rust-lang/rust/commit/d6e34ad108dc998e9f9d872e807e221c0df4f24b"}], "stats": {"total": 358, "additions": 185, "deletions": 173}, "files": [{"sha": "55af2c9ddd32f1cb9a5455e443a0e76b364d530a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 180, "deletions": 2, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/c02710530c0005a30759e170be023cc167c6cd67/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02710530c0005a30759e170be023cc167c6cd67/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c02710530c0005a30759e170be023cc167c6cd67", "patch": "@@ -1,6 +1,9 @@\n+use super::pat::Expected;\n use super::ty::AllowPlus;\n-use super::TokenType;\n-use super::{BlockMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep, TokenExpectType};\n+use super::{\n+    BlockMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions, SemiColonMode, SeqSep,\n+    TokenExpectType, TokenType,\n+};\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n@@ -19,6 +22,8 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n+use std::mem::take;\n+\n use tracing::{debug, trace};\n \n const TURBOFISH_SUGGESTION_STR: &str =\n@@ -2075,4 +2080,177 @@ impl<'a> Parser<'a> {\n         );\n         err\n     }\n+\n+    /// Some special error handling for the \"top-level\" patterns in a match arm,\n+    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n+    crate fn maybe_recover_colon_colon_in_pat_typo(\n+        &mut self,\n+        mut first_pat: P<Pat>,\n+        ra: RecoverColon,\n+        expected: Expected,\n+    ) -> P<Pat> {\n+        if RecoverColon::Yes != ra || token::Colon != self.token.kind {\n+            return first_pat;\n+        }\n+        if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n+            || !self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+        {\n+            return first_pat;\n+        }\n+        // The pattern looks like it might be a path with a `::` -> `:` typo:\n+        // `match foo { bar:baz => {} }`\n+        let span = self.token.span;\n+        // We only emit \"unexpected `:`\" error here if we can successfully parse the\n+        // whole pattern correctly in that case.\n+        let snapshot = self.clone();\n+\n+        // Create error for \"unexpected `:`\".\n+        match self.expected_one_of_not_found(&[], &[]) {\n+            Err(mut err) => {\n+                self.bump(); // Skip the `:`.\n+                match self.parse_pat_no_top_alt(expected) {\n+                    Err(mut inner_err) => {\n+                        // Carry on as if we had not done anything, callers will emit a\n+                        // reasonable error.\n+                        inner_err.cancel();\n+                        err.cancel();\n+                        *self = snapshot;\n+                    }\n+                    Ok(mut pat) => {\n+                        // We've parsed the rest of the pattern.\n+                        let new_span = first_pat.span.to(pat.span);\n+                        let mut show_sugg = false;\n+                        // Try to construct a recovered pattern.\n+                        match &mut pat.kind {\n+                            PatKind::Struct(qself @ None, path, ..)\n+                            | PatKind::TupleStruct(qself @ None, path, _)\n+                            | PatKind::Path(qself @ None, path) => match &first_pat.kind {\n+                                PatKind::Ident(_, ident, _) => {\n+                                    path.segments.insert(0, PathSegment::from_ident(ident.clone()));\n+                                    path.span = new_span;\n+                                    show_sugg = true;\n+                                    first_pat = pat;\n+                                }\n+                                PatKind::Path(old_qself, old_path) => {\n+                                    path.segments = old_path\n+                                        .segments\n+                                        .iter()\n+                                        .cloned()\n+                                        .chain(take(&mut path.segments))\n+                                        .collect();\n+                                    path.span = new_span;\n+                                    *qself = old_qself.clone();\n+                                    first_pat = pat;\n+                                    show_sugg = true;\n+                                }\n+                                _ => {}\n+                            },\n+                            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+                                match &first_pat.kind {\n+                                    PatKind::Ident(_, old_ident, _) => {\n+                                        let path = PatKind::Path(\n+                                            None,\n+                                            Path {\n+                                                span: new_span,\n+                                                segments: vec![\n+                                                    PathSegment::from_ident(old_ident.clone()),\n+                                                    PathSegment::from_ident(ident.clone()),\n+                                                ],\n+                                                tokens: None,\n+                                            },\n+                                        );\n+                                        first_pat = self.mk_pat(new_span, path);\n+                                        show_sugg = true;\n+                                    }\n+                                    PatKind::Path(old_qself, old_path) => {\n+                                        let mut segments = old_path.segments.clone();\n+                                        segments.push(PathSegment::from_ident(ident.clone()));\n+                                        let path = PatKind::Path(\n+                                            old_qself.clone(),\n+                                            Path { span: new_span, segments, tokens: None },\n+                                        );\n+                                        first_pat = self.mk_pat(new_span, path);\n+                                        show_sugg = true;\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                        if show_sugg {\n+                            err.span_suggestion(\n+                                span,\n+                                \"maybe write a path separator here\",\n+                                \"::\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            first_pat = self.mk_pat(new_span, PatKind::Wild);\n+                        }\n+                        err.emit();\n+                    }\n+                }\n+            }\n+            _ => {\n+                // Carry on as if we had not done anything. This should be unreachable.\n+                *self = snapshot;\n+            }\n+        };\n+        first_pat\n+    }\n+\n+    /// Some special error handling for the \"top-level\" patterns in a match arm,\n+    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n+    crate fn maybe_recover_unexpected_comma(\n+        &mut self,\n+        lo: Span,\n+        rc: RecoverComma,\n+    ) -> PResult<'a, ()> {\n+        if rc == RecoverComma::No || self.token != token::Comma {\n+            return Ok(());\n+        }\n+\n+        // An unexpected comma after a top-level pattern is a clue that the\n+        // user (perhaps more accustomed to some other language) forgot the\n+        // parentheses in what should have been a tuple pattern; return a\n+        // suggestion-enhanced error here rather than choking on the comma later.\n+        let comma_span = self.token.span;\n+        self.bump();\n+        if let Err(mut err) = self.skip_pat_list() {\n+            // We didn't expect this to work anyway; we just wanted to advance to the\n+            // end of the comma-sequence so we know the span to suggest parenthesizing.\n+            err.cancel();\n+        }\n+        let seq_span = lo.to(self.prev_token.span);\n+        let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n+        if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n+            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n+\n+            err.span_suggestion(\n+                seq_span,\n+                MSG,\n+                format!(\"({})\", seq_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.span_suggestion(\n+                seq_span,\n+                \"...or a vertical bar to match on multiple alternatives\",\n+                seq_snippet.replace(\",\", \" |\"),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        Err(err)\n+    }\n+\n+    /// Parse and throw away a parenthesized comma separated\n+    /// sequence of patterns until `)` is reached.\n+    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat_no_top_alt(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(());\n+            }\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "ac3123c40e3d96d78190fccbb073386a8ffe31d4", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 5, "deletions": 171, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/c02710530c0005a30759e170be023cc167c6cd67/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02710530c0005a30759e170be023cc167c6cd67/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=c02710530c0005a30759e170be023cc167c6cd67", "patch": "@@ -5,16 +5,14 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::{\n     self as ast, AttrVec, Attribute, BindingMode, Expr, ExprKind, MacCall, Mutability, Pat,\n-    PatField, PatKind, Path, PathSegment, QSelf, RangeEnd, RangeSyntax,\n+    PatField, PatKind, Path, QSelf, RangeEnd, RangeSyntax,\n };\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n \n-use std::mem::take;\n-\n-type Expected = Option<&'static str>;\n+pub(super) type Expected = Option<&'static str>;\n \n /// `Expected` for function and lambda parameter patterns.\n pub(super) const PARAM_EXPECTED: Expected = Some(\"parameter name\");\n@@ -102,122 +100,9 @@ impl<'a> Parser<'a> {\n             // If we parsed a leading `|` which should be gated,\n             // then we should really gate the leading `|`.\n             // This complicated procedure is done purely for diagnostics UX.\n-            let mut first_pat = first_pat;\n \n-            if let (RecoverColon::Yes, token::Colon) = (ra, &self.token.kind) {\n-                if matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n-                    && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n-                {\n-                    // The pattern looks like it might be a path with a `::` -> `:` typo:\n-                    // `match foo { bar:baz => {} }`\n-                    let span = self.token.span;\n-                    // We only emit \"unexpected `:`\" error here if we can successfully parse the\n-                    // whole pattern correctly in that case.\n-                    let snapshot = self.clone();\n-\n-                    // Create error for \"unexpected `:`\".\n-                    match self.expected_one_of_not_found(&[], &[]) {\n-                        Err(mut err) => {\n-                            self.bump(); // Skip the `:`.\n-                            match self.parse_pat_no_top_alt(expected) {\n-                                Err(mut inner_err) => {\n-                                    // Carry on as if we had not done anything, callers will emit a\n-                                    // reasonable error.\n-                                    inner_err.cancel();\n-                                    err.cancel();\n-                                    *self = snapshot;\n-                                }\n-                                Ok(mut pat) => {\n-                                    // We've parsed the rest of the pattern.\n-                                    let new_span = first_pat.span.to(pat.span);\n-                                    let mut show_sugg = false;\n-                                    match &mut pat.kind {\n-                                        PatKind::Struct(qself @ None, path, ..)\n-                                        | PatKind::TupleStruct(qself @ None, path, _)\n-                                        | PatKind::Path(qself @ None, path) => {\n-                                            match &first_pat.kind {\n-                                                PatKind::Ident(_, ident, _) => {\n-                                                    path.segments.insert(\n-                                                        0,\n-                                                        PathSegment::from_ident(ident.clone()),\n-                                                    );\n-                                                    path.span = new_span;\n-                                                    show_sugg = true;\n-                                                    first_pat = pat;\n-                                                }\n-                                                PatKind::Path(old_qself, old_path) => {\n-                                                    path.segments = old_path\n-                                                        .segments\n-                                                        .iter()\n-                                                        .cloned()\n-                                                        .chain(take(&mut path.segments))\n-                                                        .collect();\n-                                                    path.span = new_span;\n-                                                    *qself = old_qself.clone();\n-                                                    first_pat = pat;\n-                                                    show_sugg = true;\n-                                                }\n-                                                _ => {}\n-                                            }\n-                                        }\n-                                        PatKind::Ident(\n-                                            BindingMode::ByValue(Mutability::Not),\n-                                            ident,\n-                                            None,\n-                                        ) => match &first_pat.kind {\n-                                            PatKind::Ident(_, old_ident, _) => {\n-                                                let path = PatKind::Path(\n-                                                    None,\n-                                                    Path {\n-                                                        span: new_span,\n-                                                        segments: vec![\n-                                                            PathSegment::from_ident(\n-                                                                old_ident.clone(),\n-                                                            ),\n-                                                            PathSegment::from_ident(ident.clone()),\n-                                                        ],\n-                                                        tokens: None,\n-                                                    },\n-                                                );\n-                                                first_pat = self.mk_pat(new_span, path);\n-                                                show_sugg = true;\n-                                            }\n-                                            PatKind::Path(old_qself, old_path) => {\n-                                                let mut segments = old_path.segments.clone();\n-                                                segments\n-                                                    .push(PathSegment::from_ident(ident.clone()));\n-                                                let path = PatKind::Path(\n-                                                    old_qself.clone(),\n-                                                    Path { span: new_span, segments, tokens: None },\n-                                                );\n-                                                first_pat = self.mk_pat(new_span, path);\n-                                                show_sugg = true;\n-                                            }\n-                                            _ => {}\n-                                        },\n-                                        _ => {}\n-                                    }\n-                                    if show_sugg {\n-                                        err.span_suggestion(\n-                                            span,\n-                                            \"maybe write a path separator here\",\n-                                            \"::\".to_string(),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    } else {\n-                                        first_pat = self.mk_pat(new_span, PatKind::Wild);\n-                                    }\n-                                    err.emit();\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            // Carry on as if we had not done anything. This should be unreachable.\n-                            *self = snapshot;\n-                        }\n-                    };\n-                }\n-            }\n+            // Check if the user wrote `foo:bar` instead of `foo::bar`.\n+            let first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, ra, expected);\n \n             if let Some(leading_vert_span) = leading_vert_span {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n@@ -392,57 +277,6 @@ impl<'a> Parser<'a> {\n         err.emit();\n     }\n \n-    /// Some special error handling for the \"top-level\" patterns in a match arm,\n-    /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    fn maybe_recover_unexpected_comma(&mut self, lo: Span, rc: RecoverComma) -> PResult<'a, ()> {\n-        if rc == RecoverComma::No || self.token != token::Comma {\n-            return Ok(());\n-        }\n-\n-        // An unexpected comma after a top-level pattern is a clue that the\n-        // user (perhaps more accustomed to some other language) forgot the\n-        // parentheses in what should have been a tuple pattern; return a\n-        // suggestion-enhanced error here rather than choking on the comma later.\n-        let comma_span = self.token.span;\n-        self.bump();\n-        if let Err(mut err) = self.skip_pat_list() {\n-            // We didn't expect this to work anyway; we just wanted to advance to the\n-            // end of the comma-sequence so we know the span to suggest parenthesizing.\n-            err.cancel();\n-        }\n-        let seq_span = lo.to(self.prev_token.span);\n-        let mut err = self.struct_span_err(comma_span, \"unexpected `,` in pattern\");\n-        if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n-            const MSG: &str = \"try adding parentheses to match on a tuple...\";\n-\n-            err.span_suggestion(\n-                seq_span,\n-                MSG,\n-                format!(\"({})\", seq_snippet),\n-                Applicability::MachineApplicable,\n-            );\n-            err.span_suggestion(\n-                seq_span,\n-                \"...or a vertical bar to match on multiple alternatives\",\n-                seq_snippet.replace(\",\", \" |\"),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        Err(err)\n-    }\n-\n-    /// Parse and throw away a parenthesized comma separated\n-    /// sequence of patterns until `)` is reached.\n-    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            self.parse_pat_no_top_alt(None)?;\n-            if !self.eat(&token::Comma) {\n-                return Ok(());\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     /// A `|` or possibly `||` token shouldn't be here. Ban it.\n     fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n         let span = self.token.span;\n@@ -1239,7 +1073,7 @@ impl<'a> Parser<'a> {\n         self.mk_pat(span, PatKind::Ident(bm, ident, None))\n     }\n \n-    fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n+    pub(super) fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n         P(Pat { kind, span, id: ast::DUMMY_NODE_ID, tokens: None })\n     }\n }"}]}