{"sha": "eb1d018c01f70bcfc38bc8365a3de71c1564f694", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMWQwMThjMDFmNzBiY2ZjMzhiYzgzNjVhM2RlNzFjMTU2NGY2OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-01T19:47:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-01T19:47:38Z"}, "message": "Auto merge of #25570 - oli-obk:const_indexing, r=nikomatsakis\n\nThis PR allows the constant evaluation of index operations on constant arrays and repeat expressions. This allows index expressions to appear in the expression path of the length expression of a repeat expression or an array type.\n\nAn example is\n\n```rust\nconst ARR: [usize; 5] = [1, 2, 3, 4, 5];\nconst ARR2: [usize; ARR[1]] = [42, 99];\n```\n\nIn most other locations llvm's const evaluator figures it out already. This is not specific to index expressions and could be remedied in the future.", "tree": {"sha": "7a51d7797a6208287abeafe16f3e53b0ba26ab11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a51d7797a6208287abeafe16f3e53b0ba26ab11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb1d018c01f70bcfc38bc8365a3de71c1564f694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1d018c01f70bcfc38bc8365a3de71c1564f694", "html_url": "https://github.com/rust-lang/rust/commit/eb1d018c01f70bcfc38bc8365a3de71c1564f694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb1d018c01f70bcfc38bc8365a3de71c1564f694/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfe88bf1e5a87861ccaf57ea45f3ebe0e8c2de7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe88bf1e5a87861ccaf57ea45f3ebe0e8c2de7d", "html_url": "https://github.com/rust-lang/rust/commit/dfe88bf1e5a87861ccaf57ea45f3ebe0e8c2de7d"}, {"sha": "64051221b624ef35a449213bc54dc631ffa8a65b", "url": "https://api.github.com/repos/rust-lang/rust/commits/64051221b624ef35a449213bc54dc631ffa8a65b", "html_url": "https://github.com/rust-lang/rust/commit/64051221b624ef35a449213bc54dc631ffa8a65b"}], "stats": {"total": 240, "additions": 212, "deletions": 28}, "files": [{"sha": "1f2636ca1ad4eb99f8b779e589f5514dcb6299fd", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -253,6 +253,8 @@ pub enum ConstVal {\n     Struct(ast::NodeId),\n     Tuple(ast::NodeId),\n     Function(DefId),\n+    Array(ast::NodeId, u64),\n+    Repeat(ast::NodeId, u64),\n }\n \n impl hash::Hash for ConstVal {\n@@ -267,6 +269,8 @@ impl hash::Hash for ConstVal {\n             Struct(a) => a.hash(state),\n             Tuple(a) => a.hash(state),\n             Function(a) => a.hash(state),\n+            Array(a, n) => { a.hash(state); n.hash(state) },\n+            Repeat(a, n) => { a.hash(state); n.hash(state) },\n         }\n     }\n }\n@@ -287,6 +291,8 @@ impl PartialEq for ConstVal {\n             (&Struct(a), &Struct(b)) => a == b,\n             (&Tuple(a), &Tuple(b)) => a == b,\n             (&Function(a), &Function(b)) => a == b,\n+            (&Array(a, an), &Array(b, bn)) => (a == b) && (an == bn),\n+            (&Repeat(a, an), &Repeat(b, bn)) => (a == b) && (an == bn),\n             _ => false,\n         }\n     }\n@@ -307,6 +313,8 @@ impl ConstVal {\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n             Function(_) => \"function definition\",\n+            Array(..) => \"array\",\n+            Repeat(..) => \"repeat\",\n         }\n     }\n }\n@@ -415,6 +423,12 @@ pub enum ErrKind {\n     ExpectedConstTuple,\n     ExpectedConstStruct,\n     TupleIndexOutOfBounds,\n+    IndexedNonVec,\n+    IndexNegative,\n+    IndexNotInt,\n+    IndexOutOfBounds,\n+    RepeatCountNotNatural,\n+    RepeatCountNotInt,\n \n     MiscBinaryOp,\n     MiscCatchAll,\n@@ -455,6 +469,12 @@ impl ConstEvalErr {\n             ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n             ExpectedConstStruct => \"expected constant struct\".into_cow(),\n             TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n+            IndexedNonVec => \"indexing is only supported for arrays\".into_cow(),\n+            IndexNegative => \"indices must be non-negative integers\".into_cow(),\n+            IndexNotInt => \"indices must be integers\".into_cow(),\n+            IndexOutOfBounds => \"array index out of bounds\".into_cow(),\n+            RepeatCountNotNatural => \"repeat count must be a natural number\".into_cow(),\n+            RepeatCountNotInt => \"repeat count must be integers\".into_cow(),\n \n             MiscBinaryOp => \"bad operands for binary\".into_cow(),\n             MiscCatchAll => \"unsupported constant expr\".into_cow(),\n@@ -1111,11 +1131,83 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint, fn_args)),\n-            None => Int(0)\n+            None => unreachable!(),\n         }\n       }\n       hir::ExprTup(_) => Tuple(e.id),\n       hir::ExprStruct(..) => Struct(e.id),\n+      hir::ExprIndex(ref arr, ref idx) => {\n+        if !tcx.sess.features.borrow().const_indexing {\n+            tcx.sess.span_err(\n+                e.span,\n+                \"const indexing is an unstable feature\");\n+            fileline_help!(\n+                tcx.sess,\n+                e.span,\n+                \"in Nightly builds, add `#![feature(const_indexing)]` to the crate \\\n+                 attributes to enable\");\n+            signal!(e, NonConstPath)\n+        }\n+        let arr_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            UncheckedExprNoHint\n+        };\n+        let arr = try!(eval_const_expr_partial(tcx, arr, arr_hint, fn_args));\n+        let idx_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            UncheckedExprHint(tcx.types.usize)\n+        };\n+        let idx = match try!(eval_const_expr_partial(tcx, idx, idx_hint, fn_args)) {\n+            Int(i) if i >= 0 => i as u64,\n+            Int(_) => signal!(idx, IndexNegative),\n+            Uint(i) => i,\n+            _ => signal!(idx, IndexNotInt),\n+        };\n+        match arr {\n+            Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n+            Array(v, _) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n+                try!(eval_const_expr_partial(tcx, &*v[idx as usize], ty_hint, fn_args))\n+            } else {\n+                unreachable!()\n+            },\n+\n+            Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n+            Repeat(elem, _) => try!(eval_const_expr_partial(\n+                tcx,\n+                &*tcx.map.expect_expr(elem),\n+                ty_hint,\n+                fn_args,\n+            )),\n+\n+            ByteStr(ref data) if idx as usize >= data.len()\n+                => signal!(e, IndexOutOfBounds),\n+            ByteStr(data) => Uint(data[idx as usize] as u64),\n+\n+            Str(ref s) if idx as usize >= s.len()\n+                => signal!(e, IndexOutOfBounds),\n+            Str(_) => unimplemented!(), // there's no const_char type\n+            _ => signal!(e, IndexedNonVec),\n+        }\n+      }\n+      hir::ExprVec(ref v) => Array(e.id, v.len() as u64),\n+      hir::ExprRepeat(_, ref n) => {\n+          let len_hint = if let ExprTypeChecked = ty_hint {\n+              ExprTypeChecked\n+          } else {\n+              UncheckedExprHint(tcx.types.usize)\n+          };\n+          Repeat(\n+              e.id,\n+              match try!(eval_const_expr_partial(tcx, &**n, len_hint, fn_args)) {\n+                  Int(i) if i >= 0 => i as u64,\n+                  Int(_) => signal!(e, RepeatCountNotNatural),\n+                  Uint(i) => i,\n+                  _ => signal!(e, RepeatCountNotInt),\n+              },\n+          )\n+      },\n       hir::ExprTupField(ref base, index) => {\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked"}, {"sha": "4de586543e9df6893ba65467d236994f2b53f108", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -62,6 +62,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ConstVal::Function(_) => {\n                 unimplemented!()\n             }\n+            ConstVal::Array(..) => {\n+                unimplemented!()\n+            }\n+            ConstVal::Repeat(..) => {\n+                unimplemented!()\n+            }\n         };\n \n         assert!(!ty.has_erasable_regions());"}, {"sha": "8fc739946b46c0fb42cf3ac6e54b8573d83711d4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -179,6 +179,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     // Allows the definition of `const fn` functions.\n     (\"const_fn\", \"1.2.0\", Some(24111), Active),\n \n+    // Allows indexing into constant arrays.\n+    (\"const_indexing\", \"1.4.0\", Some(29947), Active),\n+\n     // Allows using #[prelude_import] on glob `use` items.\n     //\n     // rustc internal\n@@ -492,6 +495,7 @@ pub struct Features {\n     /// #![feature] attrs for non-language (library) features\n     pub declared_lib_features: Vec<(InternedString, Span)>,\n     pub const_fn: bool,\n+    pub const_indexing: bool,\n     pub static_recursion: bool,\n     pub default_type_parameter_fallback: bool,\n     pub type_macros: bool,\n@@ -524,6 +528,7 @@ impl Features {\n             declared_stable_lang_features: Vec::new(),\n             declared_lib_features: Vec::new(),\n             const_fn: false,\n+            const_indexing: false,\n             static_recursion: false,\n             default_type_parameter_fallback: false,\n             type_macros: false,\n@@ -1097,6 +1102,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         declared_stable_lang_features: accepted_features,\n         declared_lib_features: unknown_features,\n         const_fn: cx.has_feature(\"const_fn\"),\n+        const_indexing: cx.has_feature(\"const_indexing\"),\n         static_recursion: cx.has_feature(\"static_recursion\"),\n         default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n         type_macros: cx.has_feature(\"type_macros\"),"}, {"sha": "63a5cf65e36747d93a341897005faff706fd1192", "filename": "src/test/compile-fail/array_const_index-0.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static A: &'static [i32] = &[];\n+static B: i32 = (&A)[1]; //~ ERROR: const index-expr is out of bounds\n+\n+fn main() {\n+    let _ = B;\n+}"}, {"sha": "1f56cd8e875120d42894d62069b30cfb30919494", "filename": "src/test/compile-fail/array_const_index-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const A: [i32; 0] = [];\n+const B: i32 = A[1]; //~ ERROR: const index-expr is out of bounds\n+\n+fn main() {\n+    let _ = B;\n+}"}, {"sha": "9c07abdc36df7b6447576487ffd4156b2c424f8f", "filename": "src/test/compile-fail/const-array-oob-arith.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Fconst-array-oob-arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Fconst-array-oob-arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob-arith.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_indexing)]\n+\n+const ARR: [i32; 6] = [42, 43, 44, 45, 46, 47];\n+const IDX: usize = 3;\n+const VAL: i32 = ARR[IDX];\n+const BONG: [i32; (ARR[0] - 41) as usize] = [5];\n+const BLUB: [i32; (ARR[0] - 40) as usize] = [5]; //~ ERROR: mismatched types\n+const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99]; //~ ERROR: mismatched types\n+\n+fn main() {\n+    let _ = VAL;\n+}"}, {"sha": "15426febbcdd7aa4ae75651c6f1489b4f15b4cae", "filename": "src/test/compile-fail/const-array-oob.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(const_indexing)]\n+\n const FOO: [u32; 3] = [1, 2, 3];\n-const BAR: u32 = FOO[5]; //~ ERROR const index-expr is out of bounds\n+const BAR: u32 = FOO[5]; // no error, because the error below occurs before regular const eval\n+\n+const BLUB: [u32; FOO[4]] = [5, 6];\n+//~^ ERROR array length constant evaluation error: array index out of bounds [E0250]\n \n fn main() {\n     let _ = BAR;"}, {"sha": "3e4504eb19575738ae0669f1c8532b2a543ae666", "filename": "src/test/run-pass/array_const_index-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farray_const_index-1.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_indexing)]\n+\n+fn main() {\n+    const ARR: [i32; 6] = [42, 43, 44, 45, 46, 47];\n+    const IDX: usize = 3;\n+    const VAL: i32 = ARR[IDX];\n+    const BLUB: [i32; (ARR[0] - 41) as usize] = [5];\n+}"}, {"sha": "b5f2bea5a38812a6c9d7b23534224ed1f3722b24", "filename": "src/test/run-pass/check-static-slice.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -12,30 +12,33 @@\n // and unsized) work properly.\n \n \n-const aa: [isize; 3] = [1, 2, 3];\n-const ab: &'static [isize; 3] = &aa;\n-const ac: &'static [isize] = ab;\n-const ad: &'static [isize] = &aa;\n-const ae: &'static [isize; 3] = &[1, 2, 3];\n-const af: &'static [isize] = &[1, 2, 3];\n+const AA: [isize; 3] = [1, 2, 3];\n+const AB: &'static [isize; 3] = &AA;\n+const AC: &'static [isize] = AB;\n+const AD: &'static [isize] = &AA;\n+const AE: &'static [isize; 3] = &[1, 2, 3];\n+const AF: &'static [isize] = &[1, 2, 3];\n \n-static ca: isize = aa[0];\n-static cb: isize = ab[1];\n-static cc: isize = ac[2];\n-static cd: isize = ad[0];\n-static ce: isize = ae[1];\n-static cf: isize = af[2];\n+static CA: isize = AA[0];\n+static CB: isize = AB[1];\n+static CC: isize = AC[2];\n+static CD: isize = AD[0];\n+static CE: isize = AE[1];\n+static CF: isize = AF[2];\n+\n+static AG: &'static isize = &AA[2];\n \n fn main () {\n     let b: &[isize] = &[1, 2, 3];\n-    assert_eq!(ac, b);\n-    assert_eq!(ad, b);\n-    assert_eq!(af, b);\n+    assert_eq!(AC, b);\n+    assert_eq!(AD, b);\n+    assert_eq!(AF, b);\n+    assert_eq!(*AG, 3);\n \n-    assert_eq!(ca, 1);\n-    assert_eq!(cb, 2);\n-    assert_eq!(cc, 3);\n-    assert_eq!(cd, 1);\n-    assert_eq!(ce, 2);\n-    assert_eq!(cf, 3);\n+    assert_eq!(CA, 1);\n+    assert_eq!(CB, 2);\n+    assert_eq!(CC, 3);\n+    assert_eq!(CD, 1);\n+    assert_eq!(CE, 2);\n+    assert_eq!(CF, 3);\n }"}, {"sha": "4af6a6d10d5bf8b7dba954cd6ca690552c5b029f", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n enum E { V1(isize), V0 }\n const C: &'static [E] = &[E::V0, E::V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];\n-const D: &'static [E; 2] = &[E::V0, E::V1(0xDEADBEE)];\n-static D0: E = C[0];\n-static D1: E = C[1];\n+const D: &'static [E; 2] = &[E::V0, E::V1(0xDEAFBEE)];\n+static D0: E = D[0];\n+static D1: E = D[1];\n \n pub fn main() {\n     match C0 {\n@@ -32,7 +31,7 @@ pub fn main() {\n         _ => panic!()\n     }\n     match D1 {\n-        E::V1(n) => assert_eq!(n, 0xDEADBEE),\n+        E::V1(n) => assert_eq!(n, 0xDEAFBEE),\n         _ => panic!()\n     }\n }"}, {"sha": "4c5152ff90ffdfccfd131fce2832045db974741e", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1d018c01f70bcfc38bc8365a3de71c1564f694/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=eb1d018c01f70bcfc38bc8365a3de71c1564f694", "patch": "@@ -18,6 +18,7 @@ const C: *const u8 = B as *const u8;\n pub fn main() {\n     unsafe {\n         let foo = &A as *const u8;\n+        assert_eq!(foo, C);\n         assert_eq!(str::from_utf8_unchecked(&A), \"hi\");\n         assert_eq!(*C, A[0]);\n         assert_eq!(*(&B[0] as *const u8), A[0]);"}]}