{"sha": "d186986af23cb42b19d4058ca67b5da9e73d2cb0", "node_id": "C_kwDOAAsO6NoAKGQxODY5ODZhZjIzY2I0MmIxOWQ0MDU4Y2E2N2I1ZGE5ZTczZDJjYjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T16:23:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T16:23:54Z"}, "message": "Auto merge of #12986 - Veykril:completions, r=Veykril\n\nFix pattern field completions not working for unions", "tree": {"sha": "dbbe5108cff435d141cd3b7cca9eea69c4c07333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbbe5108cff435d141cd3b7cca9eea69c4c07333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d186986af23cb42b19d4058ca67b5da9e73d2cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d186986af23cb42b19d4058ca67b5da9e73d2cb0", "html_url": "https://github.com/rust-lang/rust/commit/d186986af23cb42b19d4058ca67b5da9e73d2cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d186986af23cb42b19d4058ca67b5da9e73d2cb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1e93c44389d822514e89ab4f2f31be30a7126d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1e93c44389d822514e89ab4f2f31be30a7126d6", "html_url": "https://github.com/rust-lang/rust/commit/e1e93c44389d822514e89ab4f2f31be30a7126d6"}, {"sha": "b3ac58dfb80e6dad9fc777f23247fd379424b65e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ac58dfb80e6dad9fc777f23247fd379424b65e", "html_url": "https://github.com/rust-lang/rust/commit/b3ac58dfb80e6dad9fc777f23247fd379424b65e"}], "stats": {"total": 227, "additions": 129, "deletions": 98}, "files": [{"sha": "55c3e28392a4d8c0bc8acbe182b8644d33ccce22", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=d186986af23cb42b19d4058ca67b5da9e73d2cb0", "patch": "@@ -617,7 +617,6 @@ pub(super) fn complete_name_ref(\n \n                     dot::complete_undotted_self(acc, ctx, path_ctx, expr_ctx);\n                     item_list::complete_item_list_in_expr(acc, ctx, path_ctx, expr_ctx);\n-                    record::complete_record_expr_func_update(acc, ctx, path_ctx, expr_ctx);\n                     snippet::complete_expr_snippet(acc, ctx, path_ctx, expr_ctx);\n                 }\n                 PathKind::Type { location } => {"}, {"sha": "4d66af9e8d5b8b0933b785d685d55114caf91bfe", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=d186986af23cb42b19d4058ca67b5da9e73d2cb0", "patch": "@@ -1,8 +1,10 @@\n //! Completion of names from the current scope in expression position.\n \n use hir::ScopeDef;\n+use syntax::ast;\n \n use crate::{\n+    completions::record::add_default_update,\n     context::{ExprCtx, PathCompletionCtx, Qualified},\n     CompletionContext, Completions,\n };\n@@ -219,60 +221,78 @@ pub(crate) fn complete_expr_path(\n                 _ => (),\n             });\n \n-            if is_func_update.is_none() {\n-                let mut add_keyword =\n-                    |kw, snippet| acc.add_keyword_snippet_expr(ctx, incomplete_let, kw, snippet);\n+            match is_func_update {\n+                Some(record_expr) => {\n+                    let ty = ctx.sema.type_of_expr(&ast::Expr::RecordExpr(record_expr.clone()));\n \n-                if !in_block_expr {\n-                    add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n-                }\n-                add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n-                add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n-                add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n-                add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n-                if in_match_guard {\n-                    add_keyword(\"if\", \"if $0\");\n-                } else {\n-                    add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+                    match ty.as_ref().and_then(|t| t.original.as_adt()) {\n+                        Some(hir::Adt::Union(_)) => (),\n+                        _ => {\n+                            cov_mark::hit!(functional_update);\n+                            let missing_fields =\n+                                ctx.sema.record_literal_missing_fields(record_expr);\n+                            if !missing_fields.is_empty() {\n+                                add_default_update(acc, ctx, ty);\n+                            }\n+                        }\n+                    };\n                 }\n-                add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n-                add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n-                add_keyword(\"true\", \"true\");\n-                add_keyword(\"false\", \"false\");\n+                None => {\n+                    let mut add_keyword = |kw, snippet| {\n+                        acc.add_keyword_snippet_expr(ctx, incomplete_let, kw, snippet)\n+                    };\n \n-                if in_condition || in_block_expr {\n-                    add_keyword(\"let\", \"let\");\n-                }\n+                    if !in_block_expr {\n+                        add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n+                    }\n+                    add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n+                    add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n+                    add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n+                    add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n+                    if in_match_guard {\n+                        add_keyword(\"if\", \"if $0\");\n+                    } else {\n+                        add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+                    }\n+                    add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n+                    add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n+                    add_keyword(\"true\", \"true\");\n+                    add_keyword(\"false\", \"false\");\n \n-                if after_if_expr {\n-                    add_keyword(\"else\", \"else {\\n    $0\\n}\");\n-                    add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n-                }\n+                    if in_condition || in_block_expr {\n+                        add_keyword(\"let\", \"let\");\n+                    }\n \n-                if wants_mut_token {\n-                    add_keyword(\"mut\", \"mut \");\n-                }\n+                    if after_if_expr {\n+                        add_keyword(\"else\", \"else {\\n    $0\\n}\");\n+                        add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n+                    }\n \n-                if in_loop_body {\n-                    if in_block_expr {\n-                        add_keyword(\"continue\", \"continue;\");\n-                        add_keyword(\"break\", \"break;\");\n-                    } else {\n-                        add_keyword(\"continue\", \"continue\");\n-                        add_keyword(\"break\", \"break\");\n+                    if wants_mut_token {\n+                        add_keyword(\"mut\", \"mut \");\n+                    }\n+\n+                    if in_loop_body {\n+                        if in_block_expr {\n+                            add_keyword(\"continue\", \"continue;\");\n+                            add_keyword(\"break\", \"break;\");\n+                        } else {\n+                            add_keyword(\"continue\", \"continue\");\n+                            add_keyword(\"break\", \"break\");\n+                        }\n                     }\n-                }\n \n-                if let Some(ty) = innermost_ret_ty {\n-                    add_keyword(\n-                        \"return\",\n-                        match (in_block_expr, ty.is_unit()) {\n-                            (true, true) => \"return ;\",\n-                            (true, false) => \"return;\",\n-                            (false, true) => \"return $0\",\n-                            (false, false) => \"return\",\n-                        },\n-                    );\n+                    if let Some(ty) = innermost_ret_ty {\n+                        add_keyword(\n+                            \"return\",\n+                            match (in_block_expr, ty.is_unit()) {\n+                                (true, true) => \"return ;\",\n+                                (true, false) => \"return;\",\n+                                (false, true) => \"return $0\",\n+                                (false, false) => \"return\",\n+                            },\n+                        );\n+                    }\n                 }\n             }\n         }"}, {"sha": "bfb98b9f2777fbfecaba4208c7be17a3ff7a4008", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=d186986af23cb42b19d4058ca67b5da9e73d2cb0", "patch": "@@ -3,7 +3,7 @@ use ide_db::SymbolKind;\n use syntax::ast::{self, Expr};\n \n use crate::{\n-    context::{DotAccess, DotAccessKind, ExprCtx, PathCompletionCtx, PatternContext, Qualified},\n+    context::{DotAccess, DotAccessKind, PatternContext},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n     CompletionRelevancePostfixMatch, Completions,\n };\n@@ -14,7 +14,24 @@ pub(crate) fn complete_record_pattern_fields(\n     pattern_ctx: &PatternContext,\n ) {\n     if let PatternContext { record_pat: Some(record_pat), .. } = pattern_ctx {\n-        complete_fields(acc, ctx, ctx.sema.record_pattern_missing_fields(record_pat));\n+        let ty = ctx.sema.type_of_pat(&ast::Pat::RecordPat(record_pat.clone()));\n+        let missing_fields = match ty.as_ref().and_then(|t| t.original.as_adt()) {\n+            Some(hir::Adt::Union(un)) => {\n+                // ctx.sema.record_pat_missing_fields will always return\n+                // an empty Vec on a union literal. This is normally\n+                // reasonable, but here we'd like to present the full list\n+                // of fields if the literal is empty.\n+                let were_fields_specified =\n+                    record_pat.record_pat_field_list().and_then(|fl| fl.fields().next()).is_some();\n+\n+                match were_fields_specified {\n+                    false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n+                    true => return,\n+                }\n+            }\n+            _ => ctx.sema.record_pattern_missing_fields(record_pat),\n+        };\n+        complete_fields(acc, ctx, missing_fields);\n     }\n }\n \n@@ -42,8 +59,13 @@ pub(crate) fn complete_record_expr_fields(\n         }\n         _ => {\n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-            add_default_update(acc, ctx, ty, &missing_fields);\n+\n+            if !missing_fields.is_empty() {\n+                cov_mark::hit!(functional_update_field);\n+                add_default_update(acc, ctx, ty);\n+            }\n             if dot_prefix {\n+                cov_mark::hit!(functional_update_one_dot);\n                 let mut item =\n                     CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n                 item.insert_text(\".\");\n@@ -56,41 +78,18 @@ pub(crate) fn complete_record_expr_fields(\n     complete_fields(acc, ctx, missing_fields);\n }\n \n-// FIXME: This should probably be part of complete_path_expr\n-pub(crate) fn complete_record_expr_func_update(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext<'_>,\n-    path_ctx: &PathCompletionCtx,\n-    expr_ctx: &ExprCtx,\n-) {\n-    if !matches!(path_ctx.qualified, Qualified::No) {\n-        return;\n-    }\n-    if let ExprCtx { is_func_update: Some(record_expr), .. } = expr_ctx {\n-        let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n-\n-        match ty.as_ref().and_then(|t| t.original.as_adt()) {\n-            Some(hir::Adt::Union(_)) => (),\n-            _ => {\n-                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-                add_default_update(acc, ctx, ty, &missing_fields);\n-            }\n-        };\n-    }\n-}\n-\n-fn add_default_update(\n+pub(crate) fn add_default_update(\n     acc: &mut Completions,\n     ctx: &CompletionContext<'_>,\n     ty: Option<hir::TypeInfo>,\n-    missing_fields: &[(hir::Field, hir::Type)],\n ) {\n     let default_trait = ctx.famous_defs().core_default_Default();\n-    let impl_default_trait = default_trait\n+    let impls_default_trait = default_trait\n         .zip(ty.as_ref())\n         .map_or(false, |(default_trait, ty)| ty.original.impls_trait(ctx.db, default_trait, &[]));\n-    if impl_default_trait && !missing_fields.is_empty() {\n+    if impls_default_trait {\n         // FIXME: This should make use of scope_def like completions so we get all the other goodies\n+        // that is we should handle this like actually completing the default function\n         let completion_text = \"..Default::default()\";\n         let mut item = CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n         let completion_text ="}, {"sha": "759742d347237520b0de7d09410ac5b92916f5b9", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=d186986af23cb42b19d4058ca67b5da9e73d2cb0", "patch": "@@ -134,6 +134,7 @@ pub(crate) struct ExprCtx {\n     pub(crate) in_condition: bool,\n     pub(crate) incomplete_let: bool,\n     pub(crate) ref_expr_parent: Option<ast::RefExpr>,\n+    /// The surrounding RecordExpression we are completing a functional update\n     pub(crate) is_func_update: Option<ast::RecordExpr>,\n     pub(crate) self_param: Option<hir::SelfParam>,\n     pub(crate) innermost_ret_ty: Option<hir::Type>,"}, {"sha": "328faaa060f04a6825a658a418f111f2cd9c8858", "filename": "crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d186986af23cb42b19d4058ca67b5da9e73d2cb0/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=d186986af23cb42b19d4058ca67b5da9e73d2cb0", "patch": "@@ -103,8 +103,9 @@ fn foo(f: Struct) {\n }\n \n #[test]\n-fn functional_update() {\n-    // FIXME: This should filter out all completions that do not have the type `Foo`\n+fn in_functional_update() {\n+    cov_mark::check!(functional_update);\n+\n     check(\n         r#\"\n //- minicore:default\n@@ -116,13 +117,21 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, $0 }\n+    let foo2 = Foo { thing, ..$0 }\n }\n \"#,\n         expect![[r#\"\n             fd ..Default::default()\n-            fd foo1                 u32\n-            fd foo2                 u32\n+            fn main()               fn()\n+            lc foo                  Foo\n+            lc thing                i32\n+            md core\n+            st Foo\n+            st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n+            tt Default\n+            bt u32\n+            kw crate::\n+            kw self::\n         \"#]],\n     );\n     check(\n@@ -136,14 +145,19 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, .$0 }\n+    let foo2 = Foo { thing, ..Default::$0 }\n }\n \"#,\n         expect![[r#\"\n-            fd ..Default::default()\n-            sn ..\n+            fn default() (as Default) fn() -> Self\n         \"#]],\n     );\n+}\n+\n+#[test]\n+fn functional_update_no_dot() {\n+    cov_mark::check!(functional_update_field);\n+    // FIXME: This should filter out all completions that do not have the type `Foo`\n     check(\n         r#\"\n //- minicore:default\n@@ -155,23 +169,20 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, ..$0 }\n+    let foo2 = Foo { thing, $0 }\n }\n \"#,\n         expect![[r#\"\n             fd ..Default::default()\n-            fn main()               fn()\n-            lc foo                  Foo\n-            lc thing                i32\n-            md core\n-            st Foo\n-            st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n-            tt Default\n-            bt u32\n-            kw crate::\n-            kw self::\n+            fd foo1                 u32\n+            fd foo2                 u32\n         \"#]],\n     );\n+}\n+\n+#[test]\n+fn functional_update_one_dot() {\n+    cov_mark::check!(functional_update_one_dot);\n     check(\n         r#\"\n //- minicore:default\n@@ -183,11 +194,12 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, ..Default::$0 }\n+    let foo2 = Foo { thing, .$0 }\n }\n \"#,\n         expect![[r#\"\n-            fn default() (as Default) fn() -> Self\n+            fd ..Default::default()\n+            sn ..\n         \"#]],\n     );\n }"}]}