{"sha": "ed447a744717faf1ef83869851003ccb93a1591b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDQ3YTc0NDcxN2ZhZjFlZjgzODY5ODUxMDAzY2NiOTNhMTU5MWI=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2012-10-23T01:47:14Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2012-10-23T04:03:56Z"}, "message": "Fix compare_and_swap to not break tests.", "tree": {"sha": "615cfc7cec2ccd2ce38263f7f72dbdd834ba4108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/615cfc7cec2ccd2ce38263f7f72dbdd834ba4108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed447a744717faf1ef83869851003ccb93a1591b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed447a744717faf1ef83869851003ccb93a1591b", "html_url": "https://github.com/rust-lang/rust/commit/ed447a744717faf1ef83869851003ccb93a1591b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed447a744717faf1ef83869851003ccb93a1591b/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48582b360c784a536bd502f9611cfe66c753ce64", "url": "https://api.github.com/repos/rust-lang/rust/commits/48582b360c784a536bd502f9611cfe66c753ce64", "html_url": "https://github.com/rust-lang/rust/commit/48582b360c784a536bd502f9611cfe66c753ce64"}], "stats": {"total": 149, "additions": 16, "deletions": 133}, "files": [{"sha": "6addb106de39034da8a2a68a49256c668dbb7231", "filename": "src/libcore/private.rs", "status": "modified", "additions": 16, "deletions": 133, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ed447a744717faf1ef83869851003ccb93a1591b/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed447a744717faf1ef83869851003ccb93a1591b/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=ed447a744717faf1ef83869851003ccb93a1591b", "patch": "@@ -5,7 +5,6 @@\n \n #[doc(hidden)];\n \n-use compare_and_swap = rustrt::rust_compare_and_swap_ptr;\n use task::TaskBuilder;\n use task::atomically;\n \n@@ -39,12 +38,27 @@ type rust_port_id = uint;\n \n type GlobalPtr = *libc::uintptr_t;\n \n+// TODO: Remove once snapshots have atomic_cxchg\n+#[cfg(stage0)]\n+fn compare_and_swap(address: &mut libc::uintptr_t,\n+                    oldval: libc::uintptr_t,\n+                    newval: libc::uintptr_t) -> bool {\n+    rustrt::rust_compare_and_swap_ptr(address, oldval, newval)\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n+    let old = rusti::atomic_cxchg(address, oldval, newval);\n+    old == oldval\n+}\n+\n /**\n  * Atomically gets a channel from a pointer to a pointer-sized memory location\n  * or, if no channel exists creates and installs a new channel and sets up a\n  * new task to receive from it.\n  */\n-#[cfg(stage0)]\n pub unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n@@ -86,70 +100,8 @@ pub unsafe fn chan_from_global_ptr<T: Send>(\n         // Install the channel\n         log(debug,~\"BEFORE COMPARE AND SWAP\");\n         let swapped = compare_and_swap(\n-            cast::reinterpret_cast(&global),\n-            0u, cast::reinterpret_cast(&ch));\n-        log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n-\n-        if swapped {\n-            // Success!\n-            comm::send(setup_ch, Proceed);\n-            ch\n-        } else {\n-            // Somebody else got in before we did\n-            comm::send(setup_ch, Abort);\n-            cast::reinterpret_cast(&*global)\n-        }\n-    } else {\n-        log(debug, ~\"global != 0\");\n-        cast::reinterpret_cast(&*global)\n-    }\n-}\n-\n-#[cfg(stage1)] #[cfg(stage2)] #[cfg(stage3)]    \n-pub unsafe fn chan_from_global_ptr<T: Send>(\n-    global: GlobalPtr,\n-    task_fn: fn() -> task::TaskBuilder,\n-    f: fn~(comm::Port<T>)\n-) -> comm::Chan<T> {\n-\n-    enum Msg {\n-        Proceed,\n-        Abort\n-    }\n-\n-    log(debug,~\"ENTERING chan_from_global_ptr, before is_prob_zero check\");\n-    let is_probably_zero = *global == 0u;\n-    log(debug,~\"after is_prob_zero check\");\n-    if is_probably_zero {\n-        log(debug,~\"is probably zero...\");\n-        // There's no global channel. We must make it\n-\n-        let (setup_po, setup_ch) = do task_fn().spawn_conversation\n-            |move f, setup_po, setup_ch| {\n-            let po = comm::Port::<T>();\n-            let ch = comm::Chan(&po);\n-            comm::send(setup_ch, ch);\n-\n-            // Wait to hear if we are the official instance of\n-            // this global task\n-            match comm::recv::<Msg>(setup_po) {\n-              Proceed => f(move po),\n-              Abort => ()\n-            }\n-        };\n-\n-        log(debug,~\"before setup recv..\");\n-        // This is the proposed global channel\n-        let ch = comm::recv(setup_po);\n-        // 0 is our sentinal value. It is not a valid channel\n-        assert *ch != 0;\n-\n-        // Install the channel\n-        log(debug,~\"BEFORE COMPARE AND SWAP\");\n-        rusti::atomic_cxchg(\n             cast::reinterpret_cast(&global),\n             0, cast::reinterpret_cast(&ch));\n-        let swapped = *global != 0;\n         log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n \n         if swapped {\n@@ -405,7 +357,6 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-#[cfg(stage0)]\n pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n@@ -471,74 +422,6 @@ pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n     }\n }\n \n-#[cfg(stage1)] #[cfg(stage2)] #[cfg(stage3)]    \n-pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n-        -> T {\n-    struct DeathThroes<T> {\n-        mut ptr:      Option<~ArcData<T>>,\n-        mut response: Option<pipes::ChanOne<bool>>,\n-        drop unsafe {\n-            let response = option::swap_unwrap(&mut self.response);\n-            // In case we get killed early, we need to tell the person who\n-            // tried to wake us whether they should hand-off the data to us.\n-            if task::failing() {\n-                pipes::send_one(move response, false);\n-                // Either this swap_unwrap or the one below (at \"Got here\")\n-                // ought to run.\n-                cast::forget(option::swap_unwrap(&mut self.ptr));\n-            } else {\n-                assert self.ptr.is_none();\n-                pipes::send_one(move response, true);\n-            }\n-        }\n-    }\n-\n-    do task::unkillable {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n-        let (c1,p1) = pipes::oneshot(); // ()\n-        let (c2,p2) = pipes::oneshot(); // bool\n-        let server: UnwrapProto = ~mut Some((move c1,move p2));\n-        let serverp: libc::uintptr_t = cast::transmute(move server);\n-        // Try to put our server end in the unwrapper slot.\n-        rusti::atomic_cxchg(cast::reinterpret_cast(&ptr.unwrapper),\n-                            0, serverp as int);\n-        if ptr.unwrapper != 0 {\n-            // Got in. Step 0: Tell destructor not to run. We are now it.\n-            rc.data = ptr::null();\n-            // Step 1 - drop our own reference.\n-            let new_count = rusti::atomic_xsub(&mut ptr.count, 1) - 1;\n-            //assert new_count >= 0;\n-            if new_count == 0 {\n-                // We were the last owner. Can unwrap immediately.\n-                // Also we have to free the server endpoints.\n-                let _server: UnwrapProto = cast::transmute(move serverp);\n-                option::swap_unwrap(&mut ptr.data)\n-                // drop glue takes over.\n-            } else {\n-                // The *next* person who sees the refcount hit 0 will wake us.\n-                let end_result =\n-                    DeathThroes { ptr: Some(move ptr),\n-                                  response: Some(move c2) };\n-                let mut p1 = Some(move p1); // argh\n-                do task::rekillable {\n-                    pipes::recv_one(option::swap_unwrap(&mut p1));\n-                }\n-                // Got here. Back in the 'unkillable' without getting killed.\n-                // Recover ownership of ptr, then take the data out.\n-                let ptr = option::swap_unwrap(&mut end_result.ptr);\n-                option::swap_unwrap(&mut ptr.data)\n-                // drop glue takes over.\n-            }\n-        } else {\n-            // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n-            cast::forget(move ptr);\n-            // Also we have to free the (rejected) server endpoints.\n-            let _server: UnwrapProto = cast::transmute(move serverp);\n-            fail ~\"Another task is already unwrapping this ARC!\";\n-        }\n-    }\n-}\n-\n /**\n  * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n  *"}]}