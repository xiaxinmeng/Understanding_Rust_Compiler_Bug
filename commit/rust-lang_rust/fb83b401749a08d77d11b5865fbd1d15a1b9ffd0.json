{"sha": "fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiODNiNDAxNzQ5YTA4ZDc3ZDExYjU4NjVmYmQxZDE1YTFiOWZmZDA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-03T20:36:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-03T20:36:39Z"}, "message": "De-export std::{ebml, ebml2}. Part of #3583.", "tree": {"sha": "5166c1a69262e1019b9ab37b4c81fac381a60052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5166c1a69262e1019b9ab37b4c81fac381a60052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "html_url": "https://github.com/rust-lang/rust/commit/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "009a38044c4c425aff3cd9112f64565aa26a77ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/009a38044c4c425aff3cd9112f64565aa26a77ea", "html_url": "https://github.com/rust-lang/rust/commit/009a38044c4c425aff3cd9112f64565aa26a77ea"}], "stats": {"total": 130, "additions": 41, "deletions": 89}, "files": [{"sha": "238e9d77a771ed83a9937783f2acd63438113803", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 22, "deletions": 47, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "patch": "@@ -4,31 +4,6 @@\n use core::Option;\n use option::{Some, None};\n \n-export Doc;\n-export doc_at;\n-export maybe_get_doc;\n-export get_doc;\n-export docs;\n-export tagged_docs;\n-export doc_data;\n-export doc_as_str;\n-export doc_as_u8;\n-export doc_as_u16;\n-export doc_as_u32;\n-export doc_as_u64;\n-export doc_as_i8;\n-export doc_as_i16;\n-export doc_as_i32;\n-export doc_as_i64;\n-export Writer;\n-export serializer;\n-export ebml_deserializer;\n-export EbmlDeserializer;\n-export deserializer;\n-export with_doc_data;\n-export get_doc;\n-export extensions;\n-\n type EbmlTag = {id: uint, size: uint};\n \n type EbmlState = {ebml_tag: EbmlTag, tag_pos: uint, data_pos: uint};\n@@ -37,7 +12,7 @@ type EbmlState = {ebml_tag: EbmlTag, tag_pos: uint, data_pos: uint};\n // separate modules within this file.\n \n // ebml reading\n-type Doc = {data: @~[u8], start: uint, end: uint};\n+pub type Doc = {data: @~[u8], start: uint, end: uint};\n \n type TaggedDoc = {tag: uint, doc: Doc};\n \n@@ -72,19 +47,19 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     } else { error!(\"vint too big\"); fail; }\n }\n \n-fn Doc(data: @~[u8]) -> Doc {\n+pub fn Doc(data: @~[u8]) -> Doc {\n     return {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n-fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n+pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n     return {tag: elt_tag.val,\n          doc: {data: data, start: elt_size.next, end: end}};\n }\n \n-fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n+pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -101,7 +76,7 @@ fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n     return None::<Doc>;\n }\n \n-fn get_doc(d: Doc, tg: uint) -> Doc {\n+pub fn get_doc(d: Doc, tg: uint) -> Doc {\n     match maybe_get_doc(d, tg) {\n       Some(d) => return d,\n       None => {\n@@ -111,7 +86,7 @@ fn get_doc(d: Doc, tg: uint) -> Doc {\n     }\n }\n \n-fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n+pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -123,7 +98,7 @@ fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n     }\n }\n \n-fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n+pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -137,43 +112,43 @@ fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n     }\n }\n \n-fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n+pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n-fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n+pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n     return f(vec::view(*d.data, d.start, d.end));\n }\n \n-fn doc_as_str(d: Doc) -> ~str { return str::from_bytes(doc_data(d)); }\n+pub fn doc_as_str(d: Doc) -> ~str { return str::from_bytes(doc_data(d)); }\n \n-fn doc_as_u8(d: Doc) -> u8 {\n+pub fn doc_as_u8(d: Doc) -> u8 {\n     assert d.end == d.start + 1u;\n     return (*d.data)[d.start];\n }\n \n-fn doc_as_u16(d: Doc) -> u16 {\n+pub fn doc_as_u16(d: Doc) -> u16 {\n     assert d.end == d.start + 2u;\n     return io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n }\n \n-fn doc_as_u32(d: Doc) -> u32 {\n+pub fn doc_as_u32(d: Doc) -> u32 {\n     assert d.end == d.start + 4u;\n     return io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n }\n \n-fn doc_as_u64(d: Doc) -> u64 {\n+pub fn doc_as_u64(d: Doc) -> u64 {\n     assert d.end == d.start + 8u;\n     return io::u64_from_be_bytes(*d.data, d.start, 8u);\n }\n \n-fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n type Writer_ = {writer: io::Writer, mut size_positions: ~[uint]};\n \n-enum Writer {\n+pub enum Writer {\n     Writer_(Writer_)\n }\n \n@@ -197,7 +172,7 @@ fn write_vuint(w: io::Writer, n: uint) {\n     fail fmt!(\"vint to write too big: %?\", n);\n }\n \n-fn Writer(w: io::Writer) -> Writer {\n+pub fn Writer(w: io::Writer) -> Writer {\n     let size_positions: ~[uint] = ~[];\n     return Writer_({writer: w, mut size_positions: size_positions});\n }\n@@ -409,11 +384,11 @@ impl ebml::Writer: serialization::Serializer {\n type EbmlDeserializer_ = {mut parent: ebml::Doc,\n                           mut pos: uint};\n \n-enum EbmlDeserializer {\n+pub enum EbmlDeserializer {\n     EbmlDeserializer_(EbmlDeserializer_)\n }\n \n-fn ebml_deserializer(d: ebml::Doc) -> EbmlDeserializer {\n+pub fn ebml_deserializer(d: ebml::Doc) -> EbmlDeserializer {\n     EbmlDeserializer_({mut parent: d, mut pos: d.start})\n }\n "}, {"sha": "30d68da06f56ff07458fc5b74d98fd46235a9866", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "patch": "@@ -3,27 +3,6 @@ use serialization2;\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n-export Doc;\n-export doc_at;\n-export maybe_get_doc;\n-export get_doc;\n-export docs;\n-export tagged_docs;\n-export doc_data;\n-export doc_as_str;\n-export doc_as_u8;\n-export doc_as_u16;\n-export doc_as_u32;\n-export doc_as_u64;\n-export doc_as_i8;\n-export doc_as_i16;\n-export doc_as_i32;\n-export doc_as_i64;\n-export Serializer;\n-export Deserializer;\n-export with_doc_data;\n-export get_doc;\n-export extensions;\n \n struct EbmlTag {\n     id: uint,\n@@ -82,11 +61,11 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     } else { error!(\"vint too big\"); fail; }\n }\n \n-fn Doc(data: @~[u8]) -> Doc {\n+pub fn Doc(data: @~[u8]) -> Doc {\n     Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n }\n \n-fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n+pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n@@ -96,7 +75,7 @@ fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n     }\n }\n \n-fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n+pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -109,7 +88,7 @@ fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n     None\n }\n \n-fn get_doc(d: Doc, tg: uint) -> Doc {\n+pub fn get_doc(d: Doc, tg: uint) -> Doc {\n     match maybe_get_doc(d, tg) {\n       Some(d) => d,\n       None => {\n@@ -119,7 +98,7 @@ fn get_doc(d: Doc, tg: uint) -> Doc {\n     }\n }\n \n-fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n+pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -132,7 +111,7 @@ fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n     }\n }\n \n-fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n+pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -147,38 +126,38 @@ fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n     }\n }\n \n-fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n+pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n-fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n+pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n     f(vec::view(*d.data, d.start, d.end))\n }\n \n-fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n+pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n-fn doc_as_u8(d: Doc) -> u8 {\n+pub fn doc_as_u8(d: Doc) -> u8 {\n     assert d.end == d.start + 1u;\n     (*d.data)[d.start]\n }\n \n-fn doc_as_u16(d: Doc) -> u16 {\n+pub fn doc_as_u16(d: Doc) -> u16 {\n     assert d.end == d.start + 2u;\n     io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n }\n \n-fn doc_as_u32(d: Doc) -> u32 {\n+pub fn doc_as_u32(d: Doc) -> u32 {\n     assert d.end == d.start + 4u;\n     io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n }\n \n-fn doc_as_u64(d: Doc) -> u64 {\n+pub fn doc_as_u64(d: Doc) -> u64 {\n     assert d.end == d.start + 8u;\n     io::u64_from_be_bytes(*d.data, d.start, 8u)\n }\n \n-fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n struct Serializer {\n@@ -206,7 +185,7 @@ fn write_vuint(w: io::Writer, n: uint) {\n     fail fmt!(\"vint to write too big: %?\", n);\n }\n \n-fn Serializer(w: io::Writer) -> Serializer {\n+pub fn Serializer(w: io::Writer) -> Serializer {\n     let size_positions: ~[uint] = ~[];\n     Serializer { writer: w, mut size_positions: size_positions }\n }\n@@ -450,7 +429,7 @@ struct Deserializer {\n     priv mut pos: uint,\n }\n \n-fn Deserializer(d: Doc) -> Deserializer {\n+pub fn Deserializer(d: Doc) -> Deserializer {\n     Deserializer { mut parent: d, mut pos: d.start }\n }\n "}, {"sha": "251a492bb5b18cf2e8122ee0feabe82af24f2783", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fb83b401749a08d77d11b5865fbd1d15a1b9ffd0/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=fb83b401749a08d77d11b5865fbd1d15a1b9ffd0", "patch": "@@ -89,9 +89,7 @@ mod treemap;\n \n // And ... other stuff\n \n-#[legacy_exports]\n mod ebml;\n-#[legacy_exports]\n mod ebml2;\n mod dbg;\n #[legacy_exports]"}]}