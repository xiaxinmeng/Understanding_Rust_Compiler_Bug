{"sha": "6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNzA4MDNlN2UzZmE0MWE4ZmY4MGE1ZTlkMDY2ZTBmMmRkYWRiY2Q=", "commit": {"author": {"name": "Janusz Marcinkiewicz", "email": "virrages@gmail.com", "date": "2019-11-24T13:31:19Z"}, "committer": {"name": "Janusz Marcinkiewicz", "email": "virrages@gmail.com", "date": "2019-11-24T14:26:09Z"}, "message": "Fix pointing at arg for fulfillment errors in function calls", "tree": {"sha": "e5a14f0fba5cde77c0d25dfd894fd47286624d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5a14f0fba5cde77c0d25dfd894fd47286624d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "html_url": "https://github.com/rust-lang/rust/commit/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/comments", "author": {"login": "VirrageS", "id": 3855799, "node_id": "MDQ6VXNlcjM4NTU3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3855799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VirrageS", "html_url": "https://github.com/VirrageS", "followers_url": "https://api.github.com/users/VirrageS/followers", "following_url": "https://api.github.com/users/VirrageS/following{/other_user}", "gists_url": "https://api.github.com/users/VirrageS/gists{/gist_id}", "starred_url": "https://api.github.com/users/VirrageS/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VirrageS/subscriptions", "organizations_url": "https://api.github.com/users/VirrageS/orgs", "repos_url": "https://api.github.com/users/VirrageS/repos", "events_url": "https://api.github.com/users/VirrageS/events{/privacy}", "received_events_url": "https://api.github.com/users/VirrageS/received_events", "type": "User", "site_admin": false}, "committer": {"login": "VirrageS", "id": 3855799, "node_id": "MDQ6VXNlcjM4NTU3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3855799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VirrageS", "html_url": "https://github.com/VirrageS", "followers_url": "https://api.github.com/users/VirrageS/followers", "following_url": "https://api.github.com/users/VirrageS/following{/other_user}", "gists_url": "https://api.github.com/users/VirrageS/gists{/gist_id}", "starred_url": "https://api.github.com/users/VirrageS/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VirrageS/subscriptions", "organizations_url": "https://api.github.com/users/VirrageS/orgs", "repos_url": "https://api.github.com/users/VirrageS/repos", "events_url": "https://api.github.com/users/VirrageS/events{/privacy}", "received_events_url": "https://api.github.com/users/VirrageS/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d761fe0462ba0f671a237d0bb35e3579b8ba0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8", "html_url": "https://github.com/rust-lang/rust/commit/7d761fe0462ba0f671a237d0bb35e3579b8ba0e8"}], "stats": {"total": 103, "additions": 88, "deletions": 15}, "files": [{"sha": "96d42dd73b1f593c27634d95b3c4ef74f6f8cdf6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         body_id: Option<hir::BodyId>,\n         fallback_has_occurred: bool,\n     ) {\n-        debug!(\"report_fulfillment_errors({:?})\", error);\n+        debug!(\"report_fulfillment_error({:?})\", error);\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error("}, {"sha": "9107e993311259326a4ca12f2ee041b43015e766", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "patch": "@@ -3641,7 +3641,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             formal_tys.clone()\n         };\n \n-        let mut final_arg_types: Vec<(usize, Ty<'_>)> = vec![];\n+        let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we type-check any arguments\n@@ -3709,7 +3709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n                 self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n-                final_arg_types.push((i, coerce_ty));\n+                final_arg_types.push((i, checked_ty, coerce_ty));\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n@@ -3756,14 +3756,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         vec![self.tcx.types.err; len]\n     }\n \n-    /// Given a vec of evaluated `FullfillmentError`s and an `fn` call argument expressions, we\n-    /// walk the resolved types for each argument to see if any of the `FullfillmentError`s\n-    /// reference a type argument. If they do, and there's only *one* argument that does, we point\n-    /// at the corresponding argument's expression span instead of the `fn` call path span.\n+    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n+    /// the checked and coerced types for each argument to see if any of the `FulfillmentError`s\n+    /// reference a type argument. The reason to walk also the checked type is that the coerced type\n+    /// can be not easily comparable with predicate type (because of coercion). If the types match\n+    /// for either checked or coerced type, and there's only *one* argument that does, we point at\n+    /// the corresponding argument's expression span instead of the `fn` call path span.\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n-        final_arg_types: &[(usize, Ty<'tcx>)],\n+        final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n         call_sp: Span,\n         args: &'tcx [hir::Expr],\n     ) {\n@@ -3773,19 +3775,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             for error in errors {\n                 if let ty::Predicate::Trait(predicate) = error.obligation.predicate {\n                     // Collect the argument position for all arguments that could have caused this\n-                    // `FullfillmentError`.\n+                    // `FulfillmentError`.\n                     let mut referenced_in = final_arg_types.iter()\n+                        .map(|(i, checked_ty, _)| (i, checked_ty))\n+                        .chain(final_arg_types.iter().map(|(i, _, coerced_ty)| (i, coerced_ty)))\n                         .flat_map(|(i, ty)| {\n                             let ty = self.resolve_vars_if_possible(ty);\n                             // We walk the argument type because the argument's type could have\n-                            // been `Option<T>`, but the `FullfillmentError` references `T`.\n+                            // been `Option<T>`, but the `FulfillmentError` references `T`.\n                             ty.walk()\n                                 .filter(|&ty| ty == predicate.skip_binder().self_ty())\n                                 .map(move |_| *i)\n-                        });\n-                    if let (Some(ref_in), None) = (referenced_in.next(), referenced_in.next()) {\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    // Both checked and coerced types could have matched, thus we need to remove\n+                    // duplicates.\n+                    referenced_in.dedup();\n+\n+                    if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n                         // We make sure that only *one* argument matches the obligation failure\n-                        // and thet the obligation's span to its expression's.\n+                        // and we assign the obligation's span to its expression's.\n                         error.obligation.cause.span = args[ref_in].span;\n                         error.points_at_arg_span = true;\n                     }\n@@ -3794,8 +3804,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Given a vec of evaluated `FullfillmentError`s and an `fn` call expression, we walk the\n-    /// `PathSegment`s and resolve their type parameters to see if any of the `FullfillmentError`s\n+    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call expression, we walk the\n+    /// `PathSegment`s and resolve their type parameters to see if any of the `FulfillmentError`s\n     /// were caused by them. If they were, we point at the corresponding type argument's span\n     /// instead of the `fn` call path span.\n     fn point_at_type_arg_instead_of_call_if_possible("}, {"sha": "32efc7e17ad7e39d6e1de622777059f806158564", "filename": "src/test/ui/unsized/unsized-fn-param.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.rs?ref=6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "patch": "@@ -0,0 +1,20 @@\n+use std::convert::AsRef;\n+use std::path::Path;\n+\n+fn foo11(_bar: &dyn AsRef<Path>, _baz: &str) {}\n+fn foo12(_bar: &str, _baz: &dyn AsRef<Path>) {}\n+\n+fn foo21(_bar: &dyn AsRef<str>, _baz: &str) {}\n+fn foo22(_bar: &str, _baz: &dyn AsRef<str>) {}\n+\n+fn main() {\n+    foo11(\"bar\", &\"baz\"); //~ ERROR the size for values of type\n+    foo11(&\"bar\", &\"baz\");\n+    foo12(&\"bar\", \"baz\"); //~ ERROR the size for values of type\n+    foo12(&\"bar\", &\"baz\");\n+\n+    foo21(\"bar\", &\"baz\"); //~ ERROR the size for values of type\n+    foo21(&\"bar\", &\"baz\");\n+    foo22(&\"bar\", \"baz\"); //~ ERROR the size for values of type\n+    foo22(&\"bar\", &\"baz\");\n+}"}, {"sha": "ed2c2e75cbd441f88666ffe1d93d7441ad55a87f", "filename": "src/test/ui/unsized/unsized-fn-param.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr?ref=6f70803e7e3fa41a8ff80a5e9d066e0f2ddadbcd", "patch": "@@ -0,0 +1,43 @@\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/unsized-fn-param.rs:11:11\n+   |\n+LL |     foo11(\"bar\", &\"baz\");\n+   |           ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required for the cast to the object type `dyn std::convert::AsRef<std::path::Path>`\n+\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/unsized-fn-param.rs:13:19\n+   |\n+LL |     foo12(&\"bar\", \"baz\");\n+   |                   ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required for the cast to the object type `dyn std::convert::AsRef<std::path::Path>`\n+\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/unsized-fn-param.rs:16:11\n+   |\n+LL |     foo21(\"bar\", &\"baz\");\n+   |           ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required for the cast to the object type `dyn std::convert::AsRef<str>`\n+\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/unsized-fn-param.rs:18:19\n+   |\n+LL |     foo22(&\"bar\", \"baz\");\n+   |                   ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required for the cast to the object type `dyn std::convert::AsRef<str>`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}