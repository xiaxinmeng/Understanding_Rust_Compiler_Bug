{"sha": "3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "node_id": "C_kwDOAAsO6NoAKDNjMDZlMGIxY2UwMDM5MTJmOGZlMDUzNmQzYTdmZTIyNTU4ZTM4Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-10T09:38:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-10T09:38:18Z"}, "message": "Auto merge of #10275 - Alexendoo:format-args-ast, r=flip1995\n\nMigrate `write.rs` to `rustc_ast::FormatArgs`\n\nchangelog: none\n\nPart 1 of #10233\n\nThe additions to `clippy_utils` are the main novelty of this PR, there's no removals yet since other parts still rely on `FormatArgsExpn`\n\nThe changes to `write.rs` itself are relatively straightforward this time around, as there's no lints in it that rely on type checking format params\n\nr? `@flip1995`", "tree": {"sha": "ec6d79b5f7c811929a9699c55989cfcdff6e0e8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec6d79b5f7c811929a9699c55989cfcdff6e0e8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "html_url": "https://github.com/rust-lang/rust/commit/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "991610a9ecb6a9f905238d13ac45613ffe7b7daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/991610a9ecb6a9f905238d13ac45613ffe7b7daf", "html_url": "https://github.com/rust-lang/rust/commit/991610a9ecb6a9f905238d13ac45613ffe7b7daf"}, {"sha": "fa0c3cce516ad39d7ca36efe50b9d02de3b269d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0c3cce516ad39d7ca36efe50b9d02de3b269d6", "html_url": "https://github.com/rust-lang/rust/commit/fa0c3cce516ad39d7ca36efe50b9d02de3b269d6"}], "stats": {"total": 311, "additions": 221, "deletions": 90}, "files": [{"sha": "491732be2087f3f677621ed15f7fba08de5233a1", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -537,6 +537,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n                 .collect(),\n         ))\n     });\n+    store.register_early_pass(|| Box::new(utils::format_args_collector::FormatArgsCollector));\n     store.register_late_pass(|_| Box::new(utils::dump_hir::DumpHir));\n     store.register_late_pass(|_| Box::new(utils::author::Author));\n     let await_holding_invalid_types = conf.await_holding_invalid_types.clone();"}, {"sha": "be56b842b98c63b75e1de07153e3085dcc457011", "filename": "clippy_lints/src/utils/format_args_collector.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -0,0 +1,23 @@\n+use clippy_utils::macros::collect_ast_format_args;\n+use rustc_ast::{Expr, ExprKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Collects [`rustc_ast::FormatArgs`] so that future late passes can call\n+    /// [`clippy_utils::macros::find_format_args`]\n+    pub FORMAT_ARGS_COLLECTOR,\n+    internal_warn,\n+    \"collects `format_args` AST nodes for use in later lints\"\n+}\n+\n+declare_lint_pass!(FormatArgsCollector => [FORMAT_ARGS_COLLECTOR]);\n+\n+impl EarlyLintPass for FormatArgsCollector {\n+    fn check_expr(&mut self, _: &EarlyContext<'_>, expr: &Expr) {\n+        if let ExprKind::FormatArgs(args) = &expr.kind {\n+            collect_ast_format_args(expr.span, args);\n+        }\n+    }\n+}"}, {"sha": "dc647af264c15893057d44bc26137b46f1151d4c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -1,5 +1,6 @@\n pub mod author;\n pub mod conf;\n pub mod dump_hir;\n+pub mod format_args_collector;\n #[cfg(feature = \"internal\")]\n pub mod internal_lints;"}, {"sha": "8114a8463faad28fea39b722805bb60d36da73e6", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn, MacroCall};\n+use clippy_utils::macros::{find_format_args, format_arg_removal_span, root_macro_call_first_node, MacroCall};\n use clippy_utils::source::{expand_past_previous_comma, snippet_opt};\n use clippy_utils::{is_in_cfg_test, is_in_test_function};\n-use rustc_ast::LitKind;\n+use rustc_ast::token::LitKind;\n+use rustc_ast::{FormatArgPosition, FormatArgs, FormatArgsPiece, FormatOptions, FormatPlaceholder, FormatTrait};\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirIdMap, Impl, Item, ItemKind};\n+use rustc_hir::{Expr, Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, BytePos};\n@@ -297,34 +298,40 @@ impl<'tcx> LateLintPass<'tcx> for Write {\n             _ => return,\n         }\n \n-        let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn) else { return };\n-\n-        // ignore `writeln!(w)` and `write!(v, some_macro!())`\n-        if format_args.format_string.span.from_expansion() {\n-            return;\n-        }\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            // ignore `writeln!(w)` and `write!(v, some_macro!())`\n+            if format_args.span.from_expansion() {\n+                return;\n+            }\n \n-        match diag_name {\n-            sym::print_macro | sym::eprint_macro | sym::write_macro => {\n-                check_newline(cx, &format_args, &macro_call, name);\n-            },\n-            sym::println_macro | sym::eprintln_macro | sym::writeln_macro => {\n-                check_empty_string(cx, &format_args, &macro_call, name);\n-            },\n-            _ => {},\n-        }\n+            match diag_name {\n+                sym::print_macro | sym::eprint_macro | sym::write_macro => {\n+                    check_newline(cx, format_args, &macro_call, name);\n+                },\n+                sym::println_macro | sym::eprintln_macro | sym::writeln_macro => {\n+                    check_empty_string(cx, format_args, &macro_call, name);\n+                },\n+                _ => {},\n+            }\n \n-        check_literal(cx, &format_args, name);\n+            check_literal(cx, format_args, name);\n \n-        if !self.in_debug_impl {\n-            for arg in &format_args.args {\n-                if arg.format.r#trait == sym::Debug {\n-                    span_lint(cx, USE_DEBUG, arg.span, \"use of `Debug`-based formatting\");\n+            if !self.in_debug_impl {\n+                for piece in &format_args.template {\n+                    if let &FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                        span: Some(span),\n+                        format_trait: FormatTrait::Debug,\n+                        ..\n+                    }) = piece\n+                    {\n+                        span_lint(cx, USE_DEBUG, span, \"use of `Debug`-based formatting\");\n+                    }\n                 }\n             }\n-        }\n+        });\n     }\n }\n+\n fn is_debug_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind\n         && let Some(trait_id) = trait_ref.trait_def_id()\n@@ -335,27 +342,28 @@ fn is_debug_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     }\n }\n \n-fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_call: &MacroCall, name: &str) {\n-    let format_string_parts = &format_args.format_string.parts;\n-    let mut format_string_span = format_args.format_string.span;\n-\n-    let Some(last) = format_string_parts.last() else { return };\n+fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgs, macro_call: &MacroCall, name: &str) {\n+    let Some(FormatArgsPiece::Literal(last)) = format_args.template.last() else { return };\n \n     let count_vertical_whitespace = || {\n-        format_string_parts\n+        format_args\n+            .template\n             .iter()\n-            .flat_map(|part| part.as_str().chars())\n+            .filter_map(|piece| match piece {\n+                FormatArgsPiece::Literal(literal) => Some(literal),\n+                FormatArgsPiece::Placeholder(_) => None,\n+            })\n+            .flat_map(|literal| literal.as_str().chars())\n             .filter(|ch| matches!(ch, '\\r' | '\\n'))\n             .count()\n     };\n \n     if last.as_str().ends_with('\\n')\n         // ignore format strings with other internal vertical whitespace\n         && count_vertical_whitespace() == 1\n-\n-        // ignore trailing arguments: `print!(\"Issue\\n{}\", 1265);`\n-        && format_string_parts.len() > format_args.args.len()\n     {\n+        let mut format_string_span = format_args.span;\n+\n         let lint = if name == \"write\" {\n             format_string_span = expand_past_previous_comma(cx, format_string_span);\n \n@@ -373,7 +381,7 @@ fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_c\n                 let name_span = cx.sess().source_map().span_until_char(macro_call.span, '!');\n                 let Some(format_snippet) = snippet_opt(cx, format_string_span) else { return };\n \n-                if format_string_parts.len() == 1 && last.as_str() == \"\\n\" {\n+                if format_args.template.len() == 1 && last.as_str() == \"\\n\" {\n                     // print!(\"\\n\"), write!(f, \"\\n\")\n \n                     diag.multipart_suggestion(\n@@ -398,11 +406,12 @@ fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_c\n     }\n }\n \n-fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_call: &MacroCall, name: &str) {\n-    if let [part] = &format_args.format_string.parts[..]\n-        && let mut span = format_args.format_string.span\n-        && part.as_str() == \"\\n\"\n+fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgs, macro_call: &MacroCall, name: &str) {\n+    if let [FormatArgsPiece::Literal(literal)] = &format_args.template[..]\n+        && literal.as_str() == \"\\n\"\n     {\n+        let mut span = format_args.span;\n+\n         let lint = if name == \"writeln\" {\n             span = expand_past_previous_comma(cx, span);\n \n@@ -428,33 +437,43 @@ fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, ma\n     }\n }\n \n-fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &str) {\n-    let mut counts = HirIdMap::<usize>::default();\n-    for param in format_args.params() {\n-        *counts.entry(param.value.hir_id).or_default() += 1;\n+fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgs, name: &str) {\n+    let arg_index = |argument: &FormatArgPosition| argument.index.unwrap_or_else(|pos| pos);\n+\n+    let mut counts = vec![0u32; format_args.arguments.all_args().len()];\n+    for piece in &format_args.template {\n+        if let FormatArgsPiece::Placeholder(placeholder) = piece {\n+            counts[arg_index(&placeholder.argument)] += 1;\n+        }\n     }\n \n-    for arg in &format_args.args {\n-        let value = arg.param.value;\n-\n-        if counts[&value.hir_id] == 1\n-            && arg.format.is_default()\n-            && let ExprKind::Lit(lit) = &value.kind\n-            && !value.span.from_expansion()\n-            && let Some(value_string) = snippet_opt(cx, value.span)\n-        {\n-            let (replacement, replace_raw) = match lit.node {\n-                LitKind::Str(..) => extract_str_literal(&value_string),\n-                LitKind::Char(ch) => (\n-                    match ch {\n-                        '\"' => \"\\\\\\\"\",\n-                        '\\'' => \"'\",\n+    for piece in &format_args.template {\n+        if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+            argument,\n+            span: Some(placeholder_span),\n+            format_trait: FormatTrait::Display,\n+            format_options,\n+        }) = piece\n+            && *format_options == FormatOptions::default()\n+            && let index = arg_index(argument)\n+            && counts[index] == 1\n+            && let Some(arg) = format_args.arguments.by_index(index)\n+            && let rustc_ast::ExprKind::Lit(lit) = &arg.expr.kind\n+            && !arg.expr.span.from_expansion()\n+            && let Some(value_string) = snippet_opt(cx, arg.expr.span)\n+    {\n+            let (replacement, replace_raw) = match lit.kind {\n+                LitKind::Str | LitKind::StrRaw(_)  => extract_str_literal(&value_string),\n+                LitKind::Char => (\n+                    match lit.symbol.as_str() {\n+                        \"\\\"\" => \"\\\\\\\"\",\n+                        \"\\\\'\" => \"'\",\n                         _ => &value_string[1..value_string.len() - 1],\n                     }\n                     .to_string(),\n                     false,\n                 ),\n-                LitKind::Bool(b) => (b.to_string(), false),\n+                LitKind::Bool => (lit.symbol.to_string(), false),\n                 _ => continue,\n             };\n \n@@ -464,7 +483,9 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &\n                 PRINT_LITERAL\n             };\n \n-            let format_string_is_raw = format_args.format_string.style.is_some();\n+            let Some(format_string_snippet) = snippet_opt(cx, format_args.span) else { continue };\n+            let format_string_is_raw = format_string_snippet.starts_with('r');\n+\n             let replacement = match (format_string_is_raw, replace_raw) {\n                 (false, false) => Some(replacement),\n                 (false, true) => Some(replacement.replace('\"', \"\\\\\\\"\").replace('\\\\', \"\\\\\\\\\")),\n@@ -485,23 +506,24 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &\n             span_lint_and_then(\n                 cx,\n                 lint,\n-                value.span,\n+                arg.expr.span,\n                 \"literal with an empty format string\",\n                 |diag| {\n                     if let Some(replacement) = replacement\n                         // `format!(\"{}\", \"a\")`, `format!(\"{named}\", named = \"b\")\n                         //              ~~~~~                      ~~~~~~~~~~~~~\n-                        && let Some(value_span) = format_args.value_with_prev_comma_span(value.hir_id)\n+                        && let Some(removal_span) = format_arg_removal_span(format_args, index)\n                     {\n                         let replacement = replacement.replace('{', \"{{\").replace('}', \"}}\");\n                         diag.multipart_suggestion(\n                             \"try this\",\n-                            vec![(arg.span, replacement), (value_span, String::new())],\n+                            vec![(*placeholder_span, replacement), (removal_span, String::new())],\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                 },\n             );\n+\n         }\n     }\n }"}, {"sha": "e135bd9feee543077ceb53ad2de636c23cd01b3b", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -6,6 +6,8 @@ use crate::visitors::{for_each_expr, Descend};\n use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n+use rustc_ast::FormatArgs;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n use rustc_lexer::unescape::unescape_literal;\n@@ -15,8 +17,10 @@ use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n+use std::cell::RefCell;\n use std::iter::{once, zip};\n use std::ops::ControlFlow;\n+use std::sync::atomic::{AtomicBool, Ordering};\n \n const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[\n     sym::assert_eq_macro,\n@@ -361,6 +365,77 @@ fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) ->\n     }\n }\n \n+thread_local! {\n+    /// We preserve the [`FormatArgs`] structs from the early pass for use in the late pass to be\n+    /// able to access the many features of a [`LateContext`].\n+    ///\n+    /// A thread local is used because [`FormatArgs`] is `!Send` and `!Sync`, we are making an\n+    /// assumption that the early pass the populates the map and the later late passes will all be\n+    /// running on the same thread.\n+    static AST_FORMAT_ARGS: RefCell<FxHashMap<Span, FormatArgs>> = {\n+        static CALLED: AtomicBool = AtomicBool::new(false);\n+        debug_assert!(\n+            !CALLED.swap(true, Ordering::SeqCst),\n+            \"incorrect assumption: `AST_FORMAT_ARGS` should only be accessed by a single thread\",\n+        );\n+\n+        RefCell::default()\n+    };\n+}\n+\n+/// Record [`rustc_ast::FormatArgs`] for use in late lint passes, this should only be called by\n+/// `FormatArgsCollector`\n+pub fn collect_ast_format_args(span: Span, format_args: &FormatArgs) {\n+    AST_FORMAT_ARGS.with(|ast_format_args| {\n+        ast_format_args.borrow_mut().insert(span, format_args.clone());\n+    });\n+}\n+\n+/// Calls `callback` with an AST [`FormatArgs`] node if one is found\n+pub fn find_format_args(cx: &LateContext<'_>, start: &Expr<'_>, expn_id: ExpnId, callback: impl FnOnce(&FormatArgs)) {\n+    let format_args_expr = for_each_expr(start, |expr| {\n+        let ctxt = expr.span.ctxt();\n+        if ctxt == start.span.ctxt() {\n+            ControlFlow::Continue(Descend::Yes)\n+        } else if ctxt.outer_expn().is_descendant_of(expn_id)\n+            && macro_backtrace(expr.span)\n+                .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n+                .any(|name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))\n+        {\n+            ControlFlow::Break(expr)\n+        } else {\n+            ControlFlow::Continue(Descend::No)\n+        }\n+    });\n+\n+    if let Some(format_args_expr) = format_args_expr {\n+        AST_FORMAT_ARGS.with(|ast_format_args| {\n+            ast_format_args.borrow().get(&format_args_expr.span).map(callback);\n+        });\n+    }\n+}\n+\n+/// Returns the [`Span`] of the value at `index` extended to the previous comma, e.g. for the value\n+/// `10`\n+///\n+/// ```ignore\n+/// format(\"{}.{}\", 10, 11)\n+/// //            ^^^^\n+/// ```\n+pub fn format_arg_removal_span(format_args: &FormatArgs, index: usize) -> Option<Span> {\n+    let ctxt = format_args.span.ctxt();\n+\n+    let current = hygiene::walk_chain(format_args.arguments.by_index(index)?.expr.span, ctxt);\n+\n+    let prev = if index == 0 {\n+        format_args.span\n+    } else {\n+        hygiene::walk_chain(format_args.arguments.by_index(index - 1)?.expr.span, ctxt)\n+    };\n+\n+    Some(current.with_lo(prev.hi()))\n+}\n+\n /// The format string doesn't exist in the HIR, so we reassemble it from source code\n #[derive(Debug)]\n pub struct FormatString {"}, {"sha": "af33b10c69388fca78d7f9d3840eaf62193f7b1f", "filename": "tests/ui/crashes/ice-10148.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fcrashes%2Fice-10148.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fcrashes%2Fice-10148.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-10148.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -0,0 +1,9 @@\n+// aux-build:../../auxiliary/proc_macro_with_span.rs\n+\n+extern crate proc_macro_with_span;\n+\n+use proc_macro_with_span::with_span;\n+\n+fn main() {\n+    println!(with_span!(\"\"something \"\"));\n+}"}, {"sha": "f23e4433f95ed1bd48a6999b725d1bcb0431ea38", "filename": "tests/ui/crashes/ice-10148.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fcrashes%2Fice-10148.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fcrashes%2Fice-10148.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-10148.stderr?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -0,0 +1,12 @@\n+error: empty string literal in `println!`\n+  --> $DIR/ice-10148.rs:8:5\n+   |\n+LL |     println!(with_span!(\"\"something \"\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^-----------^^^^^\n+   |                         |\n+   |                         help: remove the empty string\n+   |\n+   = note: `-D clippy::println-empty-string` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "beedf2c1db292bf15364c86ca10947781493ba10", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -1,5 +1,4 @@\n // run-rustfix\n-// aux-build: proc_macro_with_span.rs\n #![warn(clippy::useless_format)]\n #![allow(\n     unused_tuple_struct_fields,\n@@ -10,8 +9,6 @@\n     clippy::uninlined_format_args\n )]\n \n-extern crate proc_macro_with_span;\n-\n struct Foo(pub String);\n \n macro_rules! foo {\n@@ -90,7 +87,4 @@ fn main() {\n     let _ = abc.to_string();\n     let xx = \"xx\";\n     let _ = xx.to_string();\n-\n-    // Issue #10148\n-    println!(proc_macro_with_span::with_span!(\"\"something \"\"));\n }"}, {"sha": "e805f18188989167cf0b7ed0aab8c7613c8e3fae", "filename": "tests/ui/format.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -1,5 +1,4 @@\n // run-rustfix\n-// aux-build: proc_macro_with_span.rs\n #![warn(clippy::useless_format)]\n #![allow(\n     unused_tuple_struct_fields,\n@@ -10,8 +9,6 @@\n     clippy::uninlined_format_args\n )]\n \n-extern crate proc_macro_with_span;\n-\n struct Foo(pub String);\n \n macro_rules! foo {\n@@ -92,7 +89,4 @@ fn main() {\n     let _ = format!(\"{abc}\");\n     let xx = \"xx\";\n     let _ = format!(\"{xx}\");\n-\n-    // Issue #10148\n-    println!(proc_macro_with_span::with_span!(\"\"something \"\"));\n }"}, {"sha": "0ef0ac655d3946a1ced143f01dbe9266f5627068", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c06e0b1ce003912f8fe0536d3a7fe22558e38cf/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=3c06e0b1ce003912f8fe0536d3a7fe22558e38cf", "patch": "@@ -1,25 +1,25 @@\n error: useless use of `format!`\n-  --> $DIR/format.rs:22:5\n+  --> $DIR/format.rs:19:5\n    |\n LL |     format!(\"foo\");\n    |     ^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n    |\n    = note: `-D clippy::useless-format` implied by `-D warnings`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:23:5\n+  --> $DIR/format.rs:20:5\n    |\n LL |     format!(\"{{}}\");\n    |     ^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"{}\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:24:5\n+  --> $DIR/format.rs:21:5\n    |\n LL |     format!(\"{{}} abc {{}}\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"{} abc {}\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:25:5\n+  --> $DIR/format.rs:22:5\n    |\n LL | /     format!(\n LL | |         r##\"foo {{}}\n@@ -34,67 +34,67 @@ LL ~ \" bar\"##.to_string();\n    |\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:30:13\n+  --> $DIR/format.rs:27:13\n    |\n LL |     let _ = format!(\"\");\n    |             ^^^^^^^^^^^ help: consider using `String::new()`: `String::new()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:32:5\n+  --> $DIR/format.rs:29:5\n    |\n LL |     format!(\"{}\", \"foo\");\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:40:5\n+  --> $DIR/format.rs:37:5\n    |\n LL |     format!(\"{}\", arg);\n    |     ^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:70:5\n+  --> $DIR/format.rs:67:5\n    |\n LL |     format!(\"{}\", 42.to_string());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `42.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:72:5\n+  --> $DIR/format.rs:69:5\n    |\n LL |     format!(\"{}\", x.display().to_string());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.display().to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:76:18\n+  --> $DIR/format.rs:73:18\n    |\n LL |     let _ = Some(format!(\"{}\", a + \"bar\"));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `a + \"bar\"`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:80:22\n+  --> $DIR/format.rs:77:22\n    |\n LL |     let _s: String = format!(\"{}\", &*v.join(\"/n\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `(&*v.join(\"/n\")).to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:86:13\n+  --> $DIR/format.rs:83:13\n    |\n LL |     let _ = format!(\"{x}\");\n    |             ^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:88:13\n+  --> $DIR/format.rs:85:13\n    |\n LL |     let _ = format!(\"{y}\", y = x);\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:92:13\n+  --> $DIR/format.rs:89:13\n    |\n LL |     let _ = format!(\"{abc}\");\n    |             ^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `abc.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:94:13\n+  --> $DIR/format.rs:91:13\n    |\n LL |     let _ = format!(\"{xx}\");\n    |             ^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `xx.to_string()`"}]}