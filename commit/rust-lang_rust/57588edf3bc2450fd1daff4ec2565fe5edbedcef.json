{"sha": "57588edf3bc2450fd1daff4ec2565fe5edbedcef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTg4ZWRmM2JjMjQ1MGZkMWRhZmY0ZWMyNTY1ZmU1ZWRiZWRjZWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-21T02:27:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-21T18:27:34Z"}, "message": "libsyntax: Implement deriving via a syntax extension for the `IterBytes` trait. r=brson", "tree": {"sha": "d9b8fede85d1d85f31731d1c83131ed4400362d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9b8fede85d1d85f31731d1c83131ed4400362d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57588edf3bc2450fd1daff4ec2565fe5edbedcef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57588edf3bc2450fd1daff4ec2565fe5edbedcef", "html_url": "https://github.com/rust-lang/rust/commit/57588edf3bc2450fd1daff4ec2565fe5edbedcef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57588edf3bc2450fd1daff4ec2565fe5edbedcef/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b053f0b5e68233f664d087f06fc5ebaec2f19f97", "url": "https://api.github.com/repos/rust-lang/rust/commits/b053f0b5e68233f664d087f06fc5ebaec2f19f97", "html_url": "https://github.com/rust-lang/rust/commit/b053f0b5e68233f664d087f06fc5ebaec2f19f97"}], "stats": {"total": 565, "additions": 442, "deletions": 123}, "files": [{"sha": "480cbfe0060a5d04b4880b51989436fce588fd55", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=57588edf3bc2450fd1daff4ec2565fe5edbedcef", "patch": "@@ -100,6 +100,9 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(~\"deriving_eq\",\n                             item_decorator(\n                                 ext::deriving::expand_deriving_eq));\n+    syntax_expanders.insert(~\"deriving_iter_bytes\",\n+                            item_decorator(\n+                                ext::deriving::expand_deriving_iter_bytes));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(~\"quote_tokens\","}, {"sha": "6656007b50e031e3063d0a927d9cf8b0c794a905", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=57588edf3bc2450fd1daff4ec2565fe5edbedcef", "patch": "@@ -141,6 +141,18 @@ fn mk_block(cx: ext_ctxt, sp: span,\n                span: sp };\n     mk_expr(cx, sp, ast::expr_block(blk))\n }\n+fn mk_block_(cx: ext_ctxt, sp: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n+    {\n+        node: {\n+            view_items: ~[],\n+            stmts: move stmts,\n+            expr: None,\n+            id: cx.next_id(),\n+            rules: ast::default_blk\n+        },\n+        span: sp\n+    }\n+}\n fn mk_simple_block(cx: ext_ctxt, span: span, expr: @ast::expr) -> ast::blk {\n     let block = {\n         view_items: ~[],\n@@ -177,4 +189,39 @@ fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@{ node: ast::lit_bool(value), span: span });\n     build::mk_expr(cx, span, move lit_expr)\n }\n+fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n+    let stmt_ = ast::stmt_semi(expr, cx.next_id());\n+    @{ node: move stmt_, span: span }\n+}\n+fn mk_ty_path(cx: ext_ctxt,\n+              span: span,\n+              idents: ~[ ast::ident ])\n+           -> @ast::Ty {\n+    let ty = build::mk_raw_path(span, idents);\n+    let ty = ast::ty_path(ty, cx.next_id());\n+    let ty = @{ id: cx.next_id(), node: move ty, span: span };\n+    ty\n+}\n+fn mk_simple_ty_path(cx: ext_ctxt,\n+                     span: span,\n+                     ident: ast::ident)\n+                  -> @ast::Ty {\n+    mk_ty_path(cx, span, ~[ ident ])\n+}\n+fn mk_arg(cx: ext_ctxt,\n+          span: span,\n+          ident: ast::ident,\n+          ty: @ast::Ty)\n+       -> ast::arg {\n+    let arg_pat = mk_pat_ident(cx, span, ident);\n+    {\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty,\n+        pat: arg_pat,\n+        id: cx.next_id()\n+    }\n+}\n+fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+    { inputs: move inputs, output: output, cf: ast::return_val }\n+}\n "}, {"sha": "cf8aa764eea2279a3cee351c1532e51dcbfda6c9", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 366, "deletions": 123, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=57588edf3bc2450fd1daff4ec2565fe5edbedcef", "patch": "@@ -1,15 +1,15 @@\n /// The compiler code necessary to implement the #[deriving_eq] and\n-/// #[deriving_ord] extensions.\n+/// #[deriving_iter_bytes] extensions.\n \n use ast::{and, bind_by_ref, binop, blk, default_blk, deref, enum_def};\n use ast::{enum_variant_kind, expr};\n use ast::{expr_, expr_addr_of, expr_binary, expr_call, expr_field, expr_lit};\n use ast::{expr_match, expr_path, expr_unary, ident, infer, item, item_};\n use ast::{item_class, item_enum, item_impl, lit_bool, m_imm, meta_item};\n use ast::{method, named_field, or, pat, pat_ident, pat_wild, path, public};\n-use ast::{pure_fn, re_anon, return_val, struct_def, struct_variant_kind};\n-use ast::{sty_region, tuple_variant_kind, ty_path};\n-use ast::{ty_rptr, unnamed_field, variant};\n+use ast::{pure_fn, re_anon, return_val, stmt, struct_def};\n+use ast::{struct_variant_kind, sty_by_ref, sty_region, tuple_variant_kind};\n+use ast::{ty_nil, ty_path, ty_rptr, unnamed_field, variant};\n use base::ext_ctxt;\n use codemap::span;\n use parse::token::special_idents::clownshoes_extensions;\n@@ -28,11 +28,47 @@ impl Junction {\n     }\n }\n \n+type ExpandDerivingStructDefFn = &fn(ext_ctxt,\n+                                     span,\n+                                     x: &struct_def,\n+                                     ident)\n+                                  -> @item;\n+type ExpandDerivingEnumDefFn   = &fn(ext_ctxt,\n+                                     span,\n+                                     x: &enum_def,\n+                                     ident)\n+                                  -> @item;\n+\n pub fn expand_deriving_eq(cx: ext_ctxt,\n                           span: span,\n                           _mitem: meta_item,\n                           in_items: ~[@item])\n                        -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_eq_struct_def,\n+                    expand_deriving_eq_enum_def)\n+}\n+\n+pub fn expand_deriving_iter_bytes(cx: ext_ctxt,\n+                                  span: span,\n+                                  _mitem: meta_item,\n+                                  in_items: ~[@item])\n+                               -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_iter_bytes_struct_def,\n+                    expand_deriving_iter_bytes_enum_def)\n+}\n+\n+fn expand_deriving(cx: ext_ctxt,\n+                   span: span,\n+                   in_items: ~[@item],\n+                   expand_deriving_struct_def: ExpandDerivingStructDefFn,\n+                   expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n+                -> ~[@item] {\n     let result = dvec::DVec();\n     for in_items.each |item| {\n         result.push(copy *item);\n@@ -68,33 +104,21 @@ fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n \n /// Creates a method from the given expression, the signature of which\n /// conforms to the `eq` or `ne` method.\n-fn create_method(cx: ext_ctxt,\n-                 span: span,\n-                 method_ident: ident,\n-                 type_ident: ident,\n-                 body: @expr)\n-              -> @method {\n+fn create_eq_method(cx: ext_ctxt,\n+                    span: span,\n+                    method_ident: ident,\n+                    type_ident: ident,\n+                    body: @expr)\n+                 -> @method {\n     // Create the type of the `other` parameter.\n-    let arg_path_type = build::mk_raw_path(span, ~[ type_ident ]);\n-    let arg_path_type = ty_path(arg_path_type, cx.next_id());\n-    let arg_path_type = @{\n-        id: cx.next_id(),\n-        node: move arg_path_type,\n-        span: span\n-    };\n+    let arg_path_type = build::mk_simple_ty_path(cx, span, type_ident);\n     let arg_region = @{ id: cx.next_id(), node: re_anon };\n     let arg_type = ty_rptr(arg_region, { ty: arg_path_type, mutbl: m_imm });\n     let arg_type = @{ id: cx.next_id(), node: move arg_type, span: span };\n \n     // Create the `other` parameter.\n     let other_ident = cx.ident_of(~\"__other\");\n-    let arg_pat = build::mk_pat_ident(cx, span, other_ident);\n-    let arg = {\n-        mode: infer(cx.next_id()),\n-        ty: arg_type,\n-        pat: arg_pat,\n-        id: cx.next_id()\n-    };\n+    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n \n     // Create the type of the return value.\n     let bool_ident = cx.ident_of(~\"bool\");\n@@ -107,11 +131,7 @@ fn create_method(cx: ext_ctxt,\n     };\n \n     // Create the function declaration.\n-    let fn_decl = {\n-        inputs: ~[ move arg ],\n-        output: output_type,\n-        cf: return_val\n-    };\n+    let fn_decl = build::mk_fn_decl(~[ move arg ], output_type);\n \n     // Create the body block.\n     let body_block = build::mk_simple_block(cx, span, body);\n@@ -136,28 +156,20 @@ fn create_method(cx: ext_ctxt,\n fn create_derived_impl(cx: ext_ctxt,\n                        span: span,\n                        type_ident: ident,\n-                       eq_method: @method,\n-                       ne_method: @method)\n+                       methods: &[@method],\n+                       trait_path: &[ast::ident])\n                     -> @item {\n-    // Create the reference to the `core::cmp::Eq` trait.\n-    let core_ident = cx.ident_of(~\"core\");\n-    let cmp_ident = cx.ident_of(~\"cmp\");\n-    let eq_ident = cx.ident_of(~\"Eq\");\n-    let core_cmp_eq_idents = ~[\n-        move core_ident,\n-        move cmp_ident,\n-        move eq_ident\n-    ];\n-    let core_cmp_eq_path = {\n+    // Create the reference to the trait.\n+    let trait_path = {\n         span: span,\n         global: false,\n-        idents: move core_cmp_eq_idents,\n+        idents: trait_path.map(|x| *x),\n         rp: None,\n         types: ~[]\n     };\n-    let core_cmp_eq_path = @move core_cmp_eq_path;\n+    let trait_path = @move trait_path;\n     let trait_ref = {\n-        path: core_cmp_eq_path,\n+        path: trait_path,\n         ref_id: cx.next_id(),\n         impl_id: cx.next_id(),\n     };\n@@ -172,10 +184,87 @@ fn create_derived_impl(cx: ext_ctxt,\n     let impl_item = item_impl(~[],\n                               Some(trait_ref),\n                               self_type,\n-                              ~[ eq_method, ne_method ]);\n+                              methods.map(|x| *x));\n     return create_impl_item(cx, span, move impl_item);\n }\n \n+fn create_derived_eq_impl(cx: ext_ctxt,\n+                          span: span,\n+                          type_ident: ident,\n+                          eq_method: @method,\n+                          ne_method: @method)\n+                       -> @item {\n+    let methods = [ eq_method, ne_method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"cmp\"),\n+        cx.ident_of(~\"Eq\")\n+    ];\n+    create_derived_impl(cx, span, type_ident, methods, trait_path)\n+}\n+\n+fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n+                                  span: span,\n+                                  type_ident: ident,\n+                                  method: @method)\n+                               -> @item {\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"to_bytes\"),\n+        cx.ident_of(~\"IterBytes\")\n+    ];\n+    create_derived_impl(cx, span, type_ident, [ method ], trait_path)\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `iter_bytes` method.\n+fn create_iter_bytes_method(cx: ext_ctxt,\n+                            span: span,\n+                            +statements: ~[@stmt])\n+                         -> @method {\n+    // Create the `lsb0` parameter.\n+    let bool_ident = cx.ident_of(~\"bool\");\n+    let lsb0_arg_type = build::mk_simple_ty_path(cx, span, bool_ident);\n+    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n+    let lsb0_arg = build::mk_arg(cx, span, lsb0_ident, lsb0_arg_type);\n+\n+    // Create the `f` parameter.\n+    let core_ident = cx.ident_of(~\"core\");\n+    let to_bytes_ident = cx.ident_of(~\"to_bytes\");\n+    let cb_ident = cx.ident_of(~\"Cb\");\n+    let core_to_bytes_cb_ident = ~[ core_ident, to_bytes_ident, cb_ident ];\n+    let f_arg_type = build::mk_ty_path(cx, span, core_to_bytes_cb_ident);\n+    let f_ident = cx.ident_of(~\"__f\");\n+    let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = @{ id: cx.next_id(), node: ty_nil, span: span };\n+\n+    // Create the function declaration.\n+    let inputs = ~[ move lsb0_arg, move f_arg ];\n+    let fn_decl = build::mk_fn_decl(move inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_block_(cx, span, move statements);\n+\n+    // Create the method.\n+    let self_ty = { node: sty_by_ref, span: span };\n+    let method_ident = cx.ident_of(~\"iter_bytes\");\n+    return @{\n+        ident: method_ident,\n+        attrs: ~[],\n+        tps: ~[],\n+        self_ty: self_ty,\n+        purity: pure_fn,\n+        decl: move fn_decl,\n+        body: move body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n fn create_enum_variant_pattern(cx: ext_ctxt,\n                                span: span,\n                                variant: &ast::variant,\n@@ -214,13 +303,13 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n     }\n }\n \n-fn call_substructure_method(cx: ext_ctxt,\n-                            span: span,\n-                            self_field: @expr,\n-                            other_field_ref: @expr,\n-                            method_ident: ident,\n-                            junction: Junction,\n-                            chain_expr: &mut Option<@expr>) {\n+fn call_substructure_eq_method(cx: ext_ctxt,\n+                               span: span,\n+                               self_field: @expr,\n+                               other_field_ref: @expr,\n+                               method_ident: ident,\n+                               junction: Junction,\n+                               chain_expr: &mut Option<@expr>) {\n     // Call the substructure method.\n     let self_method = build::mk_access_(cx, span, self_field, method_ident);\n     let self_call = build::mk_call_(cx,\n@@ -243,11 +332,11 @@ fn call_substructure_method(cx: ext_ctxt,\n     };\n }\n \n-fn finish_chain_expr(cx: ext_ctxt,\n-                     span: span,\n-                     chain_expr: Option<@expr>,\n-                     junction: Junction)\n-                  -> @expr {\n+fn finish_eq_chain_expr(cx: ext_ctxt,\n+                        span: span,\n+                        chain_expr: Option<@expr>,\n+                        junction: Junction)\n+                     -> @expr {\n     match chain_expr {\n         None => {\n             match junction {\n@@ -259,6 +348,31 @@ fn finish_chain_expr(cx: ext_ctxt,\n     }\n }\n \n+fn call_substructure_iter_bytes_method(cx: ext_ctxt,\n+                                       span: span,\n+                                       self_field: @expr)\n+                                    -> @stmt {\n+    // Gather up the parameters we want to chain along.\n+    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n+    let f_ident = cx.ident_of(~\"__f\");\n+    let lsb0_expr = build::mk_path(cx, span, ~[ lsb0_ident ]);\n+    let f_expr = build::mk_path(cx, span, ~[ f_ident ]);\n+\n+    // Call the substructure method.\n+    let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n+    let self_method = build::mk_access_(cx,\n+                                        span,\n+                                        self_field,\n+                                        iter_bytes_ident);\n+    let self_call = build::mk_call_(cx,\n+                                    span,\n+                                    self_method,\n+                                    ~[ lsb0_expr, f_expr ]);\n+\n+    // Create a statement out of this expression.\n+    build::mk_stmt(cx, span, self_call)\n+}\n+\n fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n     match variant.node.kind {\n         tuple_variant_kind(args) => args.len(),\n@@ -269,38 +383,66 @@ fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n     }\n }\n \n-fn expand_deriving_struct_def(cx: ext_ctxt,\n-                              span: span,\n-                              struct_def: &struct_def,\n-                              type_ident: ident)\n-                           -> @item {\n+fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n+                                 span: span,\n+                                 struct_def: &struct_def,\n+                                 type_ident: ident)\n+                              -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n     let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_struct_method(cx,\n-                                                  span,\n-                                                  struct_def,\n-                                                  eq_ident,\n-                                                  type_ident,\n-                                                  Conjunction);\n-    let ne_method = expand_deriving_struct_method(cx,\n-                                                  span,\n-                                                  struct_def,\n-                                                  ne_ident,\n-                                                  type_ident,\n-                                                  Disjunction);\n+    let eq_method = expand_deriving_eq_struct_method(cx,\n+                                                     span,\n+                                                     struct_def,\n+                                                     eq_ident,\n+                                                     type_ident,\n+                                                     Conjunction);\n+    let ne_method = expand_deriving_eq_struct_method(cx,\n+                                                     span,\n+                                                     struct_def,\n+                                                     ne_ident,\n+                                                     type_ident,\n+                                                     Disjunction);\n \n     // Create the implementation.\n-    return create_derived_impl(cx, span, type_ident, eq_method, ne_method);\n+    return create_derived_eq_impl(cx, span, type_ident, eq_method, ne_method);\n }\n \n-fn expand_deriving_struct_method(cx: ext_ctxt,\n-                                 span: span,\n-                                 struct_def: &struct_def,\n-                                 method_ident: ident,\n-                                 type_ident: ident,\n-                                 junction: Junction)\n-                              -> @method {\n+fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n+                                         span: span,\n+                                         struct_def: &struct_def,\n+                                         type_ident: ident)\n+                                      -> @item {\n+    // Create the method.\n+    let method = expand_deriving_iter_bytes_struct_method(cx,\n+                                                          span,\n+                                                          struct_def);\n+\n+    // Create the implementation.\n+    return create_derived_iter_bytes_impl(cx, span, type_ident, method);\n+}\n+\n+fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n+                                       span: span,\n+                                       enum_definition: &enum_def,\n+                                       type_ident: ident)\n+                                    -> @item {\n+    // Create the method.\n+    let method = expand_deriving_iter_bytes_enum_method(cx,\n+                                                        span,\n+                                                        enum_definition);\n+\n+    // Create the implementation.\n+    return create_derived_iter_bytes_impl(cx, span, type_ident, method);\n+}\n+\n+fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n+                                    span: span,\n+                                    struct_def: &struct_def,\n+                                    method_ident: ident,\n+                                    type_ident: ident,\n+                                    junction: Junction)\n+                                 -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n     let other_ident = cx.ident_of(~\"__other\");\n \n@@ -325,13 +467,13 @@ fn expand_deriving_struct_method(cx: ext_ctxt,\n                                                   ident);\n \n                 // Call the substructure method.\n-                call_substructure_method(cx,\n-                                         span,\n-                                         self_field,\n-                                         other_field_ref,\n-                                         method_ident,\n-                                         junction,\n-                                         &mut outer_expr);\n+                call_substructure_eq_method(cx,\n+                                            span,\n+                                            self_field,\n+                                            other_field_ref,\n+                                            method_ident,\n+                                            junction,\n+                                            &mut outer_expr);\n             }\n             unnamed_field => {\n                 cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n@@ -340,42 +482,77 @@ fn expand_deriving_struct_method(cx: ext_ctxt,\n     }\n \n     // Create the method itself.\n-    let body = finish_chain_expr(cx, span, outer_expr, junction);\n-    return create_method(cx, span, method_ident, type_ident, body);\n+    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n+    return create_eq_method(cx, span, method_ident, type_ident, body);\n }\n \n-fn expand_deriving_enum_def(cx: ext_ctxt,\n-                            span: span,\n-                            enum_definition: &enum_def,\n-                            type_ident: ident)\n-                         -> @item {\n+fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n+                                            span: span,\n+                                            struct_def: &struct_def)\n+                                         -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the body of the method.\n+    let statements = dvec::DVec();\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let stmt = call_substructure_iter_bytes_method(cx,\n+                                                               span,\n+                                                               self_field);\n+                statements.push(stmt);\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(span,\n+                               ~\"unnamed fields with `deriving_iter_bytes`\");\n+            }\n+        }\n+    }\n+\n+    // Create the method itself.\n+    let statements = dvec::unwrap(move statements);\n+    return create_iter_bytes_method(cx, span, move statements);\n+}\n+\n+fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n+                               span: span,\n+                               enum_definition: &enum_def,\n+                               type_ident: ident)\n+                            -> @item {\n     // Create the methods.\n     let eq_ident = cx.ident_of(~\"eq\");\n     let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_enum_method(cx,\n+    let eq_method = expand_deriving_eq_enum_method(cx,\n                                                 span,\n                                                 enum_definition,\n                                                 eq_ident,\n                                                 type_ident,\n                                                 Conjunction);\n-    let ne_method = expand_deriving_enum_method(cx,\n-                                                span,\n-                                                enum_definition,\n-                                                ne_ident,\n-                                                type_ident,\n-                                                Disjunction);\n+    let ne_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   ne_ident,\n+                                                   type_ident,\n+                                                   Disjunction);\n \n     // Create the implementation.\n-    return create_derived_impl(cx, span, type_ident, eq_method, ne_method);\n+    return create_derived_eq_impl(cx, span, type_ident, eq_method, ne_method);\n }\n \n-fn expand_deriving_enum_method(cx: ext_ctxt,\n-                               span: span,\n-                               enum_definition: &enum_def,\n-                               method_ident: ident,\n-                               type_ident: ident,\n-                               junction: Junction)\n-                            -> @method {\n+fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n+                                  span: span,\n+                                  enum_definition: &enum_def,\n+                                  method_ident: ident,\n+                                  type_ident: ident,\n+                                  junction: Junction)\n+                               -> @method {\n     let self_ident = cx.ident_of(~\"self\");\n     let other_ident = cx.ident_of(~\"__other\");\n \n@@ -410,19 +587,19 @@ fn expand_deriving_enum_method(cx: ext_ctxt,\n             let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n \n             // Call the substructure method.\n-            call_substructure_method(cx,\n-                                     span,\n-                                     self_field,\n-                                     other_field,\n-                                     method_ident,\n-                                     junction,\n-                                     &mut matching_body_expr);\n+            call_substructure_eq_method(cx,\n+                                        span,\n+                                        self_field,\n+                                        other_field,\n+                                        method_ident,\n+                                        junction,\n+                                        &mut matching_body_expr);\n         }\n \n-        let matching_body_expr = finish_chain_expr(cx,\n-                                                   span,\n-                                                   matching_body_expr,\n-                                                   junction);\n+        let matching_body_expr = finish_eq_chain_expr(cx,\n+                                                      span,\n+                                                      matching_body_expr,\n+                                                      junction);\n         let matching_body_block = build::mk_simple_block(cx,\n                                                          span,\n                                                          matching_body_expr);\n@@ -491,6 +668,72 @@ fn expand_deriving_enum_method(cx: ext_ctxt,\n     let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n \n     // Create the method.\n-    return create_method(cx, span, method_ident, type_ident, self_match_expr);\n+    return create_eq_method(cx,\n+                            span,\n+                            method_ident,\n+                            type_ident,\n+                            self_match_expr);\n+}\n+\n+fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n+                                          span: span,\n+                                          enum_definition: &enum_def)\n+                                       -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = dvec::DVec();\n+    for enum_definition.variants.eachi |i, variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Determine the discriminant. We will feed this value to the byte\n+        // iteration function.\n+        let discriminant;\n+        match variant.node.disr_expr {\n+            Some(copy disr_expr) => discriminant = disr_expr,\n+            None => discriminant = build::mk_uint(cx, span, i),\n+        }\n+\n+        // Feed the discriminant to the byte iteration function.\n+        let stmts = dvec::DVec();\n+        let discrim_stmt = call_substructure_iter_bytes_method(cx,\n+                                                               span,\n+                                                               discriminant);\n+        stmts.push(discrim_stmt);\n+\n+        // Feed each argument in this variant to the byte iteration function\n+        // as well.\n+        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let stmt = call_substructure_iter_bytes_method(cx, span, field);\n+            stmts.push(stmt);\n+        }\n+\n+        // Create the pattern body.\n+        let stmts = dvec::unwrap(move stmts);\n+        let match_body_block = build::mk_block_(cx, span, move stmts);\n+\n+        // Create the arm.\n+        let arm = {\n+            pats: ~[ pat ],\n+            guard: None,\n+            body: move match_body_block\n+        };\n+        arms.push(move arm);\n+    }\n+\n+    // Create the method body.\n+    let self_ident = cx.ident_of(~\"self\");\n+    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let arms = dvec::unwrap(move arms);\n+    let self_match_expr = expr_match(self_expr, move arms);\n+    let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n+    let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n+\n+    // Create the method.\n+    return create_iter_bytes_method(cx, span, ~[ self_match_stmt ]);\n }\n "}, {"sha": "c6023bfcbb226aab917b1dc26110d3f612eca9a2", "filename": "src/test/run-pass/deriving-via-extension-iter-bytes-enum.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Ftest%2Frun-pass%2Fderiving-via-extension-iter-bytes-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Ftest%2Frun-pass%2Fderiving-via-extension-iter-bytes-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-iter-bytes-enum.rs?ref=57588edf3bc2450fd1daff4ec2565fe5edbedcef", "patch": "@@ -0,0 +1,16 @@\n+#[deriving_iter_bytes]\n+enum Foo {\n+    Bar(int, char),\n+    Baz(char, int)\n+}\n+\n+#[deriving_iter_bytes]\n+enum A {\n+    B,\n+    C,\n+    D,\n+    E\n+}\n+\n+fn main(){}\n+"}, {"sha": "f5116b4e0e816102033e51587d7d533dc3db9fcc", "filename": "src/test/run-pass/deriving-via-extension-iter-bytes-struct.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Ftest%2Frun-pass%2Fderiving-via-extension-iter-bytes-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57588edf3bc2450fd1daff4ec2565fe5edbedcef/src%2Ftest%2Frun-pass%2Fderiving-via-extension-iter-bytes-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-iter-bytes-struct.rs?ref=57588edf3bc2450fd1daff4ec2565fe5edbedcef", "patch": "@@ -0,0 +1,10 @@\n+#[deriving_iter_bytes]\n+struct Foo {\n+    x: int,\n+    y: int,\n+    z: int\n+}\n+\n+fn main() {}\n+\n+"}]}