{"sha": "8b15045224ff1a0a051e513bc35561abee7a6f65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMTUwNDUyMjRmZjFhMGEwNTFlNTEzYmMzNTU2MWFiZWU3YTZmNjU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-04T23:20:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-09T22:53:26Z"}, "message": "Port the compiler to the ivec type [T] syntax.", "tree": {"sha": "479c5d9d920a548a7333744120fc68e1430ecd9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/479c5d9d920a548a7333744120fc68e1430ecd9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b15045224ff1a0a051e513bc35561abee7a6f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b15045224ff1a0a051e513bc35561abee7a6f65", "html_url": "https://github.com/rust-lang/rust/commit/8b15045224ff1a0a051e513bc35561abee7a6f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b15045224ff1a0a051e513bc35561abee7a6f65/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f97cb368954937662f17b8bddab81206e4ab07", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f97cb368954937662f17b8bddab81206e4ab07", "html_url": "https://github.com/rust-lang/rust/commit/50f97cb368954937662f17b8bddab81206e4ab07"}], "stats": {"total": 1663, "additions": 832, "deletions": 831}, "files": [{"sha": "1fb3bfd039f0a9e01b13d260fb9c0c88be230b73", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -272,13 +272,13 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n     type provided_metas =\n         {name: option::t[str],\n          vers: option::t[str],\n-         cmh_items: (@ast::meta_item)[]};\n+         cmh_items: [@ast::meta_item]};\n \n     fn provided_link_metas(sess: &session::session, c: &ast::crate) ->\n        provided_metas {\n         let name: option::t[str] = none;\n         let vers: option::t[str] = none;\n-        let cmh_items: (@ast::meta_item)[] = ~[];\n+        let cmh_items: [@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n         for meta: @ast::meta_item  in linkage_metas {\n@@ -412,7 +412,7 @@ fn get_symbol_hash(ccx: &@crate_ctxt, t: &ty::t) -> str {\n     ret hash;\n }\n \n-fn mangle(ss: &str[]) -> str {\n+fn mangle(ss: &[str]) -> str {\n     // Follow C++ namespace-mangling style\n \n     let n = \"_ZN\"; // Begin name-sequence.\n@@ -423,14 +423,14 @@ fn mangle(ss: &str[]) -> str {\n     ret n;\n }\n \n-fn exported_name(path: &str[], hash: &str, vers: &str) -> str {\n+fn exported_name(path: &[str], hash: &str, vers: &str) -> str {\n     // FIXME: versioning isn't working yet\n \n     ret mangle(path + ~[hash]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(ccx: &@crate_ctxt, path: &str[], t: &ty::t) -> str {\n+fn mangle_exported_name(ccx: &@crate_ctxt, path: &[str], t: &ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n@@ -442,12 +442,12 @@ fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: &ty::t, name: &str)\n     ret mangle(~[name, s, hash]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &str[],\n+fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],\n                                         flav: &str) -> str {\n     ret mangle(path + ~[ccx.names.next(flav)]);\n }\n \n-fn mangle_internal_name_by_path(ccx: &@crate_ctxt, path: &str[]) -> str {\n+fn mangle_internal_name_by_path(ccx: &@crate_ctxt, path: &[str]) -> str {\n     ret mangle(path);\n }\n "}, {"sha": "cc080682fd472de5139c381468e0c230aeeb46e6", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -71,9 +71,9 @@ type upcalls =\n \n fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n                    taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n-    fn decl(tn: type_names, llmod: ModuleRef, name: str, tys: TypeRef[],\n+    fn decl(tn: type_names, llmod: ModuleRef, name: str, tys: [TypeRef],\n           rv: TypeRef) -> ValueRef {\n-        let arg_tys: TypeRef[] = ~[];\n+        let arg_tys: [TypeRef] = ~[];\n         for t: TypeRef  in tys { arg_tys += ~[t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n@@ -87,7 +87,7 @@ fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n     let d = bind decl_with_taskptr(taskptr_type, tn, llmod, _, _, _);\n     let dr = bind decl(tn, llmod, _, _, _);\n \n-    let empty_vec: TypeRef[] = ~[];\n+    let empty_vec: [TypeRef] = ~[];\n     ret @{grow_task: dv(\"grow_task\", ~[T_size_t()]),\n           log_int: dv(\"log_int\", ~[T_i32(), T_i32()]),\n           log_float: dv(\"log_float\", ~[T_i32(), T_f32()]),"}, {"sha": "ebb9672374cbff50a4677c18b67cbc6b8ac47f33", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -37,7 +37,7 @@ type options =\n      time_passes: bool,\n      time_llvm_passes: bool,\n      output_type: back::link::output_type,\n-     library_search_paths: str[],\n+     library_search_paths: [str],\n      sysroot: str,\n      cfg: ast::crate_cfg,\n      test: bool,\n@@ -46,7 +46,7 @@ type options =\n      no_trans: bool\n      };\n \n-type crate_metadata = {name: str, data: u8[]};\n+type crate_metadata = {name: str, data: [u8]};\n \n obj session(targ_cfg: @config,\n             opts: @options,"}, {"sha": "061193022cbdc3e8c4b4df753b11a05f49554263", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -29,8 +29,8 @@ export mk_attr;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n-fn find_linkage_metas(attrs: &ast::attribute[]) -> (@ast::meta_item)[] {\n-    let metas: (@ast::meta_item)[] = ~[];\n+fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n+    let metas: [@ast::meta_item] = ~[];\n     for attr: ast::attribute  in find_attrs_by_name(attrs, \"link\") {\n         alt attr.node.value.node {\n           ast::meta_list(_, items) { metas += items; }\n@@ -41,8 +41,8 @@ fn find_linkage_metas(attrs: &ast::attribute[]) -> (@ast::meta_item)[] {\n }\n \n // Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: &ast::attribute[], name: ast::ident) ->\n-   ast::attribute[] {\n+fn find_attrs_by_name(attrs: &[ast::attribute], name: ast::ident) ->\n+   [ast::attribute] {\n     let filter =\n         bind fn (a: &ast::attribute, name: ast::ident) ->\n                 option::t[ast::attribute] {\n@@ -57,8 +57,8 @@ fn get_attr_name(attr: &ast::attribute) -> ast::ident {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn find_meta_items_by_name(metas: &(@ast::meta_item)[], name: ast::ident) ->\n-   (@ast::meta_item)[] {\n+fn find_meta_items_by_name(metas: &[@ast::meta_item], name: ast::ident) ->\n+   [@ast::meta_item] {\n     let filter =\n         bind fn (m: &@ast::meta_item, name: ast::ident) ->\n                 option::t[@ast::meta_item] {\n@@ -94,7 +94,7 @@ fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t[str] {\n fn attr_meta(attr: &ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(attrs: &ast::attribute[]) -> (@ast::meta_item)[] {\n+fn attr_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n     let mitems = ~[];\n     for a: ast::attribute  in attrs { mitems += ~[attr_meta(a)]; }\n     ret mitems;\n@@ -121,7 +121,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains(haystack: &(@ast::meta_item)[], needle: @ast::meta_item) -> bool {\n+fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     log #fmt(\"looking for %s\",\n              syntax::print::pprust::meta_item_to_str(*needle));\n     for item: @ast::meta_item  in haystack {\n@@ -133,13 +133,13 @@ fn contains(haystack: &(@ast::meta_item)[], needle: @ast::meta_item) -> bool {\n     ret false;\n }\n \n-fn contains_name(metas: &(@ast::meta_item)[], name: ast::ident) -> bool {\n+fn contains_name(metas: &[@ast::meta_item], name: ast::ident) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret ivec::len(matches) > 0u;\n }\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n-fn sort_meta_items(items: &(@ast::meta_item)[]) -> (@ast::meta_item)[] {\n+fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n     fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n         fn key(m: &@ast::meta_item) -> ast::ident {\n             alt m.node {\n@@ -152,18 +152,18 @@ fn sort_meta_items(items: &(@ast::meta_item)[]) -> (@ast::meta_item)[] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: (@ast::meta_item)[mutable ] = ~[mutable ];\n+    let v: [mutable @ast::meta_item] = ~[mutable];\n     for mi: @ast::meta_item  in items { v += ~[mutable mi]; }\n \n     std::sort::ivector::quick_sort(lteq, v);\n \n-    let v2: (@ast::meta_item)[] = ~[];\n+    let v2: [@ast::meta_item] = ~[];\n     for mi: @ast::meta_item  in v { v2 += ~[mi]; }\n     ret v2;\n }\n \n-fn remove_meta_items_by_name(items: &(@ast::meta_item)[], name: str) ->\n-   (@ast::meta_item)[] {\n+fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n+   [@ast::meta_item] {\n \n     let filter =\n         bind fn (item: &@ast::meta_item, name: str) ->\n@@ -177,7 +177,7 @@ fn remove_meta_items_by_name(items: &(@ast::meta_item)[], name: str) ->\n }\n \n fn require_unique_names(sess: &session::session,\n-                        metas: &(@ast::meta_item)[]) {\n+                        metas: &[@ast::meta_item]) {\n     let map = map::mk_hashmap[str, ()](str::hash, str::eq);\n     for meta: @ast::meta_item  in metas {\n         let name = get_meta_item_name(meta);\n@@ -202,7 +202,7 @@ fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n     ret @span(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(name: ast::ident, items: &(@ast::meta_item)[]) ->\n+fn mk_list_item(name: ast::ident, items: &[@ast::meta_item]) ->\n    @ast::meta_item {\n     ret @span(ast::meta_list(name, items));\n }"}, {"sha": "fb5222b0c57502791d71f48908f67fa84fb54559", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -91,7 +91,7 @@ fn native_item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &ast::crate_cfg, attrs: &ast::attribute[]) -> bool {\n+fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n \n     // The \"cfg\" attributes on the item\n     let item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n@@ -103,9 +103,9 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &ast::attribute[]) -> bool {\n     // which the item is valid\n     let item_cfg_metas =\n         {\n-            fn extract_metas(inner_items: &(@ast::meta_item)[],\n+            fn extract_metas(inner_items: &[@ast::meta_item],\n                              cfg_item: &@ast::meta_item) ->\n-               (@ast::meta_item)[] {\n+               [@ast::meta_item] {\n                 alt cfg_item.node {\n                   ast::meta_list(name, items) {\n                     assert (name == \"cfg\");"}, {"sha": "8604b64880876e2facaf953c8f646636a6085d3e", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -11,12 +11,12 @@ export modify_for_testing;\n \n type node_id_gen = @fn() -> ast::node_id ;\n \n-type test = {path: ast::ident[], ignore: bool};\n+type test = {path: [ast::ident], ignore: bool};\n \n type test_ctxt =\n     @{next_node_id: node_id_gen,\n-      mutable path: ast::ident[],\n-      mutable testfns: test[]};\n+      mutable path: [ast::ident],\n+      mutable testfns: [test]};\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n@@ -139,7 +139,7 @@ mod __test {\n     std::test::test_main(args, tests())\n   }\n \n-  fn tests() -> std::test::test_desc[] {\n+  fn tests() -> [std::test::test_desc] {\n     ... the list of tests in the crate ...\n   }\n }\n@@ -211,7 +211,7 @@ fn empty_fn_ty() -> ast::ty {\n     ret nospan(ast::ty_fn(proto, input_ty, ret_ty, cf, constrs));\n }\n \n-// The ast::ty of std::test::test_desc[]\n+// The ast::ty of [std::test::test_desc]\n fn mk_test_desc_ivec_ty(cx: &test_ctxt) -> @ast::ty {\n     let test_desc_ty_path: ast::path =\n         nospan({global: false,"}, {"sha": "62ad92ac380f7c5c92f84bb932bcddaf3cf89d3b", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -909,7 +909,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         ret llvm::LLVMBuildRet(B, V);\n     }\n \n-    fn AggregateRet(RetVals: &ValueRef[]) -> ValueRef {\n+    fn AggregateRet(RetVals: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n         ret llvm::LLVMBuildAggregateRet(B, ivec::to_ptr(RetVals),\n@@ -941,7 +941,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         ret llvm::LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n \n-    fn Invoke(Fn: ValueRef, Args: &ValueRef[], Then: BasicBlockRef,\n+    fn Invoke(Fn: ValueRef, Args: &[ValueRef], Then: BasicBlockRef,\n               Catch: BasicBlockRef) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n@@ -1151,13 +1151,13 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         ret llvm::LLVMBuildStore(B, Val, Ptr);\n     }\n \n-    fn GEP(Pointer: ValueRef, Indices: &ValueRef[]) -> ValueRef {\n+    fn GEP(Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildGEP(B, Pointer, ivec::to_ptr(Indices),\n                                ivec::len(Indices), str::buf(\"\"));\n     }\n \n-    fn InBoundsGEP(Pointer: ValueRef, Indices: &ValueRef[]) -> ValueRef {\n+    fn InBoundsGEP(Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildInBoundsGEP(B, Pointer, ivec::to_ptr(Indices),\n                                        ivec::len(Indices), str::buf(\"\"));\n@@ -1289,7 +1289,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n \n \n     /* Miscellaneous instructions */\n-    fn Phi(Ty: TypeRef, vals: &ValueRef[], bbs: &BasicBlockRef[]) ->\n+    fn Phi(Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) ->\n        ValueRef {\n         assert (!*terminated);\n         let phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n@@ -1299,20 +1299,20 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         ret phi;\n     }\n \n-    fn AddIncomingToPhi(phi: ValueRef, vals: &ValueRef[],\n-                        bbs: &BasicBlockRef[]) {\n+    fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef],\n+                        bbs: &[BasicBlockRef]) {\n         assert (ivec::len[ValueRef](vals) == ivec::len[BasicBlockRef](bbs));\n         llvm::LLVMAddIncoming(phi, ivec::to_ptr(vals), ivec::to_ptr(bbs),\n                               ivec::len(vals));\n     }\n \n-    fn Call(Fn: ValueRef, Args: &ValueRef[]) -> ValueRef {\n+    fn Call(Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n                                 str::buf(\"\"));\n     }\n \n-    fn FastCall(Fn: ValueRef, Args: &ValueRef[]) -> ValueRef {\n+    fn FastCall(Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         let v =\n             llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n@@ -1321,7 +1321,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         ret v;\n     }\n \n-    fn CallWithConv(Fn: ValueRef, Args: &ValueRef[], Conv: uint) -> ValueRef {\n+    fn CallWithConv(Fn: ValueRef, Args: &[ValueRef], Conv: uint) -> ValueRef {\n         assert (!*terminated);\n         let v =\n             llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n@@ -1392,7 +1392,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         let T: ValueRef =\n             llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n-        let Args: ValueRef[] = ~[];\n+        let Args: [ValueRef] = ~[];\n         ret llvm::LLVMBuildCall(B, T, ivec::to_ptr(Args), ivec::len(Args),\n                                 str::buf(\"\"));\n     }\n@@ -1447,7 +1447,7 @@ fn type_to_str(names: type_names, ty: TypeRef) -> str {\n     ret type_to_str_inner(names, ~[], ty);\n }\n \n-fn type_to_str_inner(names: type_names, outer0: &TypeRef[], ty: TypeRef) ->\n+fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n    str {\n \n     if names.type_has_name(ty) { ret names.get_name(ty); }\n@@ -1456,7 +1456,7 @@ fn type_to_str_inner(names: type_names, outer0: &TypeRef[], ty: TypeRef) ->\n \n     let kind: int = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(names: type_names, outer: &TypeRef[], tys: &TypeRef[]) -> str {\n+    fn tys_str(names: type_names, outer: &[TypeRef], tys: &[TypeRef]) -> str {\n         let s: str = \"\";\n         let first: bool = true;\n         for t: TypeRef  in tys {\n@@ -1493,7 +1493,7 @@ fn type_to_str_inner(names: type_names, outer0: &TypeRef[], ty: TypeRef) ->\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args: uint = llvm::LLVMCountParamTypes(ty);\n-        let args: TypeRef[] = ivec::init_elt[TypeRef](0 as TypeRef, n_args);\n+        let args: [TypeRef] = ivec::init_elt[TypeRef](0 as TypeRef, n_args);\n         llvm::LLVMGetParamTypes(ty, ivec::to_ptr(args));\n         s += tys_str(names, outer, args);\n         s += \") -> \";\n@@ -1505,7 +1505,7 @@ fn type_to_str_inner(names: type_names, outer0: &TypeRef[], ty: TypeRef) ->\n       9 {\n         let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n-        let elts: TypeRef[] = ivec::init_elt[TypeRef](0 as TypeRef, n_elts);\n+        let elts: [TypeRef] = ivec::init_elt[TypeRef](0 as TypeRef, n_elts);\n         llvm::LLVMGetStructElementTypes(ty, ivec::to_ptr(elts));\n         s += tys_str(names, outer, elts);\n         s += \"}\";\n@@ -1552,7 +1552,7 @@ fn float_width(llt: TypeRef) -> uint {\n         };\n }\n \n-fn fn_ty_param_tys(fn_ty: TypeRef) -> TypeRef[] {\n+fn fn_ty_param_tys(fn_ty: TypeRef) -> [TypeRef] {\n     let args = ivec::init_elt(0 as TypeRef, llvm::LLVMCountParamTypes(fn_ty));\n     llvm::LLVMGetParamTypes(fn_ty, ivec::to_ptr(args));\n     ret args;"}, {"sha": "0bca7e600e3251e019d7a3c5910eb495e16c4763", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -46,7 +46,7 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n type env =\n     @{sess: session::session,\n       crate_cache: @hashmap[str, int],\n-      library_search_paths: str[],\n+      library_search_paths: [str],\n       mutable next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: &@ast::view_item) {\n@@ -89,7 +89,7 @@ fn list_file_metadata(path: str, out: ioivec::writer) {\n     }\n }\n \n-fn metadata_matches(crate_data: &@u8[], metas: &(@ast::meta_item)[]) -> bool {\n+fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n \n@@ -116,9 +116,9 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n }\n \n fn find_library_crate(sess: &session::session, ident: &ast::ident,\n-                      metas: &(@ast::meta_item)[],\n-                      library_search_paths: &str[]) ->\n-   option::t[{ident: str, data: @u8[]}] {\n+                      metas: &[@ast::meta_item],\n+                      library_search_paths: &[str]) ->\n+   option::t[{ident: str, data: @[u8]}] {\n \n     attr::require_unique_names(sess, metas);\n \n@@ -146,9 +146,9 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n }\n \n fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n-                          metas: &(@ast::meta_item)[],\n-                          library_search_paths: &str[]) ->\n-   option::t[{ident: str, data: @u8[]}] {\n+                          metas: &[@ast::meta_item],\n+                          library_search_paths: &[str]) ->\n+   option::t[{ident: str, data: @[u8]}] {\n     let prefix: str = nn.prefix + crate_name;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n@@ -183,10 +183,10 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n     ret none;\n }\n \n-fn get_metadata_section(filename: str) -> option::t[@u8[]] {\n+fn get_metadata_section(filename: str) -> option::t[@[u8]] {\n     let b = str::buf(filename);\n     let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n-    if mb as int == 0 { ret option::none[@u8[]]; }\n+    if mb as int == 0 { ret option::none[@[u8]]; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -196,17 +196,17 @@ fn get_metadata_section(filename: str) -> option::t[@u8[]] {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);\n             let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);\n-            ret option::some[@u8[]](@ivec::unsafe::from_buf(cvbuf, csz));\n+            ret option::some[@[u8]](@ivec::unsafe::from_buf(cvbuf, csz));\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    ret option::none[@u8[]];\n+    ret option::none[@[u8]];\n }\n \n fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n-                      metas: &(@ast::meta_item)[],\n-                      library_search_paths: &str[]) ->\n-   {ident: str, data: @u8[]} {\n+                      metas: &[@ast::meta_item],\n+                      library_search_paths: &[str]) ->\n+   {ident: str, data: @[u8]} {\n \n \n     alt find_library_crate(sess, ident, metas, library_search_paths) {\n@@ -217,7 +217,7 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n     }\n }\n \n-fn resolve_crate(e: env, ident: ast::ident, metas: (@ast::meta_item)[],\n+fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n                  span: span) -> ast::crate_num {\n     if !e.crate_cache.contains_key(ident) {\n         let cinfo =\n@@ -245,7 +245,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: (@ast::meta_item)[],\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: env, cdata: &@u8[]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     log \"resolving deps of external crate\";\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "d526ee05247b2f8a9a4f0254279b7c0d49047c25", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -22,12 +22,12 @@ fn get_type_param_count(cstore: &cstore::cstore, def: &ast::def_id) -> uint {\n }\n \n fn lookup_defs(cstore: &cstore::cstore, cnum: ast::crate_num,\n-               path: &ast::ident[]) -> ast::def[] {\n+               path: &[ast::ident]) -> [ast::def] {\n     let cdata = cstore::get_crate_data(cstore, cnum).data;\n     ret decoder::lookup_defs(cdata, cnum, path);\n }\n \n-fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> ty::variant_info[] {\n+fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n     let cstore = tcx.sess.get_cstore();\n     let cnum = def.crate;\n     let cdata = cstore::get_crate_data(cstore, cnum).data;"}, {"sha": "bebd695fda15e07228ba58447b2b2d55df1b29bc", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -29,7 +29,7 @@ export get_use_stmt_cnum;\n // own crate numbers.\n type cnum_map = map::hashmap[ast::crate_num, ast::crate_num];\n \n-type crate_metadata = {name: str, data: @u8[], cnum_map: cnum_map};\n+type crate_metadata = {name: str, data: @[u8], cnum_map: cnum_map};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported tag variant, it's impossible for\n@@ -41,9 +41,9 @@ tag cstore { private(cstore_private); }\n type cstore_private =\n     @{metas: map::hashmap[ast::crate_num, crate_metadata],\n       use_crate_map: use_crate_map,\n-      mutable used_crate_files: str[],\n-      mutable used_libraries: str[],\n-      mutable used_link_args: str[]};\n+      mutable used_crate_files: [str],\n+      mutable used_libraries: [str],\n+      mutable used_link_args: [str]};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap[ast::node_id, ast::crate_num];\n@@ -88,7 +88,7 @@ fn add_used_crate_file(cstore: &cstore, lib: &str) {\n     }\n }\n \n-fn get_used_crate_files(cstore: &cstore) -> str[] {\n+fn get_used_crate_files(cstore: &cstore) -> [str] {\n     ret p(cstore).used_crate_files;\n }\n \n@@ -101,7 +101,7 @@ fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n     ret true;\n }\n \n-fn get_used_libraries(cstore: &cstore) -> str[] {\n+fn get_used_libraries(cstore: &cstore) -> [str] {\n     ret p(cstore).used_libraries;\n }\n \n@@ -114,7 +114,7 @@ fn add_used_link_args(cstore: &cstore, args: &str) {\n     }\n }\n \n-fn get_used_link_args(cstore: &cstore) -> str[] {\n+fn get_used_link_args(cstore: &cstore) -> [str] {\n     ret p(cstore).used_link_args;\n }\n "}, {"sha": "56bd7754290a64e8a78e964364059f9e3e416d03", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -35,16 +35,16 @@ export external_resolver;\n // build.\n type external_resolver = fn(&ast::def_id) -> ast::def_id ;\n \n-fn lookup_hash(d: &ebmlivec::doc, eq_fn: fn(&u8[]) -> bool , hash: uint) ->\n-   ebmlivec::doc[] {\n+fn lookup_hash(d: &ebmlivec::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n+   [ebmlivec::doc] {\n     let index = ebmlivec::get_doc(d, tag_index);\n     let table = ebmlivec::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = ebmlivec::be_uint_from_bytes(d.data, hash_pos, 4u);\n     let bucket = ebmlivec::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let result: ebmlivec::doc[] = ~[];\n+    let result: [ebmlivec::doc] = ~[];\n     let belt = tag_index_buckets_bucket_elt;\n     for each elt: ebmlivec::doc  in ebmlivec::tagged_docs(bucket, belt) {\n         let pos = ebmlivec::be_uint_from_bytes(elt.data, elt.start, 4u);\n@@ -57,7 +57,7 @@ fn lookup_hash(d: &ebmlivec::doc, eq_fn: fn(&u8[]) -> bool , hash: uint) ->\n \n fn maybe_find_item(item_id: int, items: &ebmlivec::doc) ->\n    option::t[ebmlivec::doc] {\n-    fn eq_item(bytes: &u8[], item_id: int) -> bool {\n+    fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         ret ebmlivec::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = bind eq_item(_, item_id);\n@@ -73,7 +73,7 @@ fn find_item(item_id: int, items: &ebmlivec::doc) -> ebmlivec::doc {\n \n // Looks up an item in the given metadata and returns an ebmlivec doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: &@u8[]) -> ebmlivec::doc {\n+fn lookup_item(item_id: int, data: &@[u8]) -> ebmlivec::doc {\n     let items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n     ret find_item(item_id, items);\n }\n@@ -114,11 +114,11 @@ fn item_type(item: &ebmlivec::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n                       def_parser, tcx);\n }\n \n-fn item_ty_param_kinds(item: &ebmlivec::doc) -> ast::kind[] {\n-    let ks: ast::kind[] = ~[];\n+fn item_ty_param_kinds(item: &ebmlivec::doc) -> [ast::kind] {\n+    let ks: [ast::kind] = ~[];\n     let tp = tag_items_data_item_ty_param_kinds;\n     for each p: ebmlivec::doc in ebmlivec::tagged_docs(item, tp) {\n-        let dat : u8[] = ebmlivec::doc_data(p);\n+        let dat : [u8] = ebmlivec::doc_data(p);\n         let vi = ebmlivec::vint_at(dat, 0u);\n         let i = 0u;\n         while i < vi.val {\n@@ -135,8 +135,8 @@ fn item_ty_param_kinds(item: &ebmlivec::doc) -> ast::kind[] {\n }\n \n fn tag_variant_ids(item: &ebmlivec::doc, this_cnum: ast::crate_num) ->\n-   ast::def_id[] {\n-    let ids: ast::def_id[] = ~[];\n+   [ast::def_id] {\n+    let ids: [ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n     for each p: ebmlivec::doc  in ebmlivec::tagged_docs(item, v) {\n         let ext = parse_def_id(ebmlivec::doc_data(p));\n@@ -147,15 +147,15 @@ fn tag_variant_ids(item: &ebmlivec::doc, this_cnum: ast::crate_num) ->\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(path: &ast::ident[], data: @u8[]) -> ast::def_id[] {\n-    fn eq_item(data: &u8[], s: str) -> bool {\n+fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n+    fn eq_item(data: &[u8], s: str) -> bool {\n         ret str::eq(str::unsafe_from_bytes_ivec(data), s);\n     }\n     let s = str::connect_ivec(path, \"::\");\n     let md = ebmlivec::new_doc(data);\n     let paths = ebmlivec::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n-    let result: ast::def_id[] = ~[];\n+    let result: [ast::def_id] = ~[];\n     for doc: ebmlivec::doc  in lookup_hash(paths, eqer, hash_path(s)) {\n         let did_doc = ebmlivec::get_doc(doc, tag_def_id);\n         result += ~[parse_def_id(ebmlivec::doc_data(did_doc))];\n@@ -164,14 +164,14 @@ fn resolve_path(path: &ast::ident[], data: @u8[]) -> ast::def_id[] {\n }\n \n // Crate metadata queries\n-fn lookup_defs(data: &@u8[], cnum: ast::crate_num, path: &ast::ident[]) ->\n-   ast::def[] {\n+fn lookup_defs(data: &@[u8], cnum: ast::crate_num, path: &[ast::ident]) ->\n+   [ast::def] {\n     ret ivec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n \n // FIXME doesn't yet handle re-exported externals\n-fn lookup_def(cnum: ast::crate_num, data: @u8[], did_: &ast::def_id) ->\n+fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: &ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let fam_ch = item_family(item);\n@@ -197,13 +197,13 @@ fn lookup_def(cnum: ast::crate_num, data: @u8[], did_: &ast::def_id) ->\n     ret def;\n }\n \n-fn get_type(data: @u8[], def: ast::def_id, tcx: &ty::ctxt,\n+fn get_type(data: @[u8], def: ast::def_id, tcx: &ty::ctxt,\n             extres: &external_resolver) -> ty::ty_param_kinds_and_ty {\n     let this_cnum = def.crate;\n     let node_id = def.node;\n     let item = lookup_item(node_id, data);\n     let t = item_type(item, this_cnum, tcx, extres);\n-    let tp_kinds : ast::kind[];\n+    let tp_kinds : [ast::kind];\n     let fam_ch = item_family(item);\n     let has_ty_params = family_has_type_params(fam_ch);\n     if has_ty_params {\n@@ -212,31 +212,31 @@ fn get_type(data: @u8[], def: ast::def_id, tcx: &ty::ctxt,\n     ret {kinds: tp_kinds, ty: t};\n }\n \n-fn get_type_param_count(data: @u8[], id: ast::node_id) -> uint {\n+fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n     ret ivec::len(get_type_param_kinds(data, id));\n }\n \n-fn get_type_param_kinds(data: @u8[], id: ast::node_id) -> ast::kind[] {\n+fn get_type_param_kinds(data: @[u8], id: ast::node_id) -> [ast::kind] {\n     ret item_ty_param_kinds(lookup_item(id, data));\n }\n \n-fn get_symbol(data: @u8[], id: ast::node_id) -> str {\n+fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(data: &@u8[], def: ast::def_id, tcx: &ty::ctxt,\n-                    extres: &external_resolver) -> ty::variant_info[] {\n+fn get_tag_variants(data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n+                    extres: &external_resolver) -> [ty::variant_info] {\n     let external_crate_id = def.crate;\n     let data =\n         cstore::get_crate_data(tcx.sess.get_cstore(), external_crate_id).data;\n     let items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n     let item = find_item(def.node, items);\n-    let infos: ty::variant_info[] = ~[];\n+    let infos: [ty::variant_info] = ~[];\n     let variant_ids = tag_variant_ids(item, external_crate_id);\n     for did: ast::def_id  in variant_ids {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(item, external_crate_id, tcx, extres);\n-        let arg_tys: ty::t[] = ~[];\n+        let arg_tys: [ty::t] = ~[];\n         alt ty::struct(tcx, ctor_ty) {\n           ty::ty_fn(_, args, _, _, _) {\n             for a: ty::arg  in args { arg_tys += ~[a.ty]; }\n@@ -294,8 +294,8 @@ fn item_family_to_str(fam: u8) -> str {\n     }\n }\n \n-fn get_meta_items(md: &ebmlivec::doc) -> (@ast::meta_item)[] {\n-    let items: (@ast::meta_item)[] = ~[];\n+fn get_meta_items(md: &ebmlivec::doc) -> [@ast::meta_item] {\n+    let items: [@ast::meta_item] = ~[];\n     for each meta_item_doc: ebmlivec::doc  in\n              ebmlivec::tagged_docs(md, tag_meta_item_word) {\n         let nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -322,8 +322,8 @@ fn get_meta_items(md: &ebmlivec::doc) -> (@ast::meta_item)[] {\n     ret items;\n }\n \n-fn get_attributes(md: &ebmlivec::doc) -> ast::attribute[] {\n-    let attrs: ast::attribute[] = ~[];\n+fn get_attributes(md: &ebmlivec::doc) -> [ast::attribute] {\n+    let attrs: [ast::attribute] = ~[];\n     alt ebmlivec::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n         for each attr_doc: ebmlivec::doc  in\n@@ -359,14 +359,14 @@ fn list_crate_attributes(md: &ebmlivec::doc, out: ioivec::writer) {\n     out.write_str(\"\\n\\n\");\n }\n \n-fn get_crate_attributes(data: @u8[]) -> ast::attribute[] {\n+fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n     ret get_attributes(ebmlivec::new_doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, ident: str};\n \n-fn get_crate_deps(data: @u8[]) -> crate_dep[] {\n-    let deps: crate_dep[] = ~[];\n+fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n+    let deps: [crate_dep] = ~[];\n     let cratedoc = ebmlivec::new_doc(data);\n     let depsdoc = ebmlivec::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n@@ -379,7 +379,7 @@ fn get_crate_deps(data: @u8[]) -> crate_dep[] {\n     ret deps;\n }\n \n-fn list_crate_deps(data: @u8[], out: ioivec::writer) {\n+fn list_crate_deps(data: @[u8], out: ioivec::writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     for dep: crate_dep  in get_crate_deps(data) {\n@@ -389,7 +389,7 @@ fn list_crate_deps(data: @u8[], out: ioivec::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_items(bytes: &@u8[], md: &ebmlivec::doc, out: ioivec::writer) {\n+fn list_crate_items(bytes: &@[u8], md: &ebmlivec::doc, out: ioivec::writer) {\n     out.write_str(\"=Items=\\n\");\n     let paths = ebmlivec::get_doc(md, tag_paths);\n     let items = ebmlivec::get_doc(md, tag_items);\n@@ -410,7 +410,7 @@ fn list_crate_items(bytes: &@u8[], md: &ebmlivec::doc, out: ioivec::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_metadata(bytes: &@u8[], out: ioivec::writer) {\n+fn list_crate_metadata(bytes: &@[u8], out: ioivec::writer) {\n     let md = ebmlivec::new_doc(bytes);\n     list_crate_attributes(md, out);\n     list_crate_deps(bytes, out);"}, {"sha": "c0af68174532310d5df90d26736f543487ffebfe", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -38,8 +38,8 @@ fn encode_def_id(ebml_w: &ebmlivec::writer, id: &def_id) {\n \n type entry[T] = {val: T, pos: uint};\n \n-fn encode_tag_variant_paths(ebml_w: &ebmlivec::writer, variants: &variant[],\n-                            path: &str[], index: &mutable (entry[str])[]) {\n+fn encode_tag_variant_paths(ebml_w: &ebmlivec::writer, variants: &[variant],\n+                            path: &[str], index: &mutable [entry[str]]) {\n     for variant: variant  in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n@@ -49,17 +49,17 @@ fn encode_tag_variant_paths(ebml_w: &ebmlivec::writer, variants: &variant[],\n     }\n }\n \n-fn add_to_index(ebml_w: &ebmlivec::writer, path: &str[],\n-                index: &mutable (entry[str])[], name: &str) {\n+fn add_to_index(ebml_w: &ebmlivec::writer, path: &[str],\n+                index: &mutable [entry[str]], name: &str) {\n     let full_path = path + ~[name];\n     index +=\n         ~[{val: str::connect_ivec(full_path, \"::\"),\n            pos: ebml_w.writer.tell()}];\n }\n \n fn encode_native_module_item_paths(ebml_w: &ebmlivec::writer,\n-                                   nmod: &native_mod, path: &str[],\n-                                   index: &mutable (entry[str])[]) {\n+                                   nmod: &native_mod, path: &[str],\n+                                   index: &mutable [entry[str]]) {\n     for nitem: @native_item  in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n@@ -70,7 +70,7 @@ fn encode_native_module_item_paths(ebml_w: &ebmlivec::writer,\n }\n \n fn encode_module_item_paths(ebml_w: &ebmlivec::writer, module: &_mod,\n-                            path: &str[], index: &mutable (entry[str])[]) {\n+                            path: &[str], index: &mutable [entry[str]]) {\n     for it: @item  in module.items {\n         if !is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -149,9 +149,9 @@ fn encode_module_item_paths(ebml_w: &ebmlivec::writer, module: &_mod,\n }\n \n fn encode_item_paths(ebml_w: &ebmlivec::writer, crate: &@crate) ->\n-   (entry[str])[] {\n-    let index: (entry[str])[] = ~[];\n-    let path: str[] = ~[];\n+   [entry[str]] {\n+    let index: [entry[str]] = ~[];\n+    let path: [str] = ~[];\n     ebmlivec::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebmlivec::end_tag(ebml_w);\n@@ -174,7 +174,7 @@ fn encode_inlineness(ebml_w: &ebmlivec::writer, c: u8) {\n \n fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n-fn encode_type_param_kinds(ebml_w: &ebmlivec::writer, tps: &ty_param[]) {\n+fn encode_type_param_kinds(ebml_w: &ebmlivec::writer, tps: &[ty_param]) {\n     ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n     ebmlivec::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n     for tp: ty_param in tps {\n@@ -225,9 +225,9 @@ fn encode_tag_id(ebml_w: &ebmlivec::writer, id: &def_id) {\n }\n \n fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n-                           id: node_id, variants: &variant[],\n-                           index: &mutable (entry[int])[],\n-                           ty_params: &ty_param[]) {\n+                           id: node_id, variants: &[variant],\n+                           index: &mutable [entry[int]],\n+                           ty_params: &[ty_param]) {\n     for variant: variant  in variants {\n         index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n@@ -246,7 +246,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n }\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n-                        item: @item, index: &mutable (entry[int])[]) {\n+                        item: @item, index: &mutable [entry[int]]) {\n     alt item.node {\n       item_const(_, _) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n@@ -368,8 +368,8 @@ fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n }\n \n fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer) ->\n-   (entry[int])[] {\n-    let index: (entry[int])[] = ~[];\n+   [entry[int]] {\n+    let index: [entry[int]] = ~[];\n     ebmlivec::start_tag(ebml_w, tag_items_data);\n     for each kvp: @{key: node_id, val: middle::ast_map::ast_node}  in\n              ecx.ccx.ast_map.items() {\n@@ -392,29 +392,29 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index[T](index: &(entry[T])[], hash_fn: fn(&T) -> uint ) ->\n-   (@(entry[T])[])[] {\n-    let buckets: (@mutable (entry[T])[])[] = ~[];\n+fn create_index[T](index: &[entry[T]], hash_fn: fn(&T) -> uint ) ->\n+   [@[entry[T]]] {\n+    let buckets: [@mutable [entry[T]]] = ~[];\n     for each i: uint  in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n     for elt: entry[T]  in index {\n         let h = hash_fn(elt.val);\n         *buckets.(h % 256u) += ~[elt];\n     }\n \n     let buckets_frozen = ~[];\n-    for bucket: @mutable (entry[T])[]  in buckets {\n+    for bucket: @mutable [entry[T]]  in buckets {\n         buckets_frozen += ~[@*bucket];\n     }\n     ret buckets_frozen;\n }\n \n-fn encode_index[T](ebml_w: &ebmlivec::writer, buckets: &(@(entry[T])[])[],\n+fn encode_index[T](ebml_w: &ebmlivec::writer, buckets: &[@[entry[T]]],\n                    write_fn: fn(&ioivec::writer, &T) ) {\n     let writer = ioivec::new_writer_(ebml_w.writer);\n     ebmlivec::start_tag(ebml_w, tag_index);\n-    let bucket_locs: uint[] = ~[];\n+    let bucket_locs: [uint] = ~[];\n     ebmlivec::start_tag(ebml_w, tag_index_buckets);\n-    for bucket: @(entry[T])[]  in buckets {\n+    for bucket: @[entry[T]]  in buckets {\n         bucket_locs += ~[ebml_w.writer.tell()];\n         ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket);\n         for elt: entry[T]  in *bucket {\n@@ -475,7 +475,7 @@ fn encode_meta_item(ebml_w: &ebmlivec::writer, mi: &meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: &ebmlivec::writer, attrs: &attribute[]) {\n+fn encode_attributes(ebml_w: &ebmlivec::writer, attrs: &[attribute]) {\n     ebmlivec::start_tag(ebml_w, tag_attributes);\n     for attr: attribute  in attrs {\n         ebmlivec::start_tag(ebml_w, tag_attribute);\n@@ -489,9 +489,9 @@ fn encode_attributes(ebml_w: &ebmlivec::writer, attrs: &attribute[]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> attribute[] {\n+fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n \n-    fn synthesize_link_attr(ecx: &@encode_ctxt, items: &(@meta_item)[]) ->\n+    fn synthesize_link_attr(ecx: &@encode_ctxt, items: &[@meta_item]) ->\n        attribute {\n \n         assert (ecx.ccx.link_meta.name != \"\");\n@@ -514,7 +514,7 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> attribute[] {\n         ret attr::mk_attr(link_item);\n     }\n \n-    let attrs: attribute[] = ~[];\n+    let attrs: [attribute] = ~[];\n     let found_link_attr = false;\n     for attr: attribute  in crate.node.attrs {\n         attrs +=\n@@ -538,12 +538,12 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> attribute[] {\n \n fn encode_crate_deps(ebml_w: &ebmlivec::writer, cstore: &cstore::cstore) {\n \n-    fn get_ordered_names(cstore: &cstore::cstore) -> str[] {\n+    fn get_ordered_names(cstore: &cstore::cstore) -> [str] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n         type numname = {crate: crate_num, ident: str};\n \n         // Pull the cnums and names out of cstore\n-        let pairs: numname[mutable ] = ~[mutable ];\n+        let pairs: [mutable numname] = ~[mutable];\n         for each hashkv: hashkv  in cstore::iter_crate_data(cstore) {\n             pairs += ~[mutable {crate: hashkv.key, ident: hashkv.val.name}];\n         }"}, {"sha": "1ff547c0a4dc6b01a90559bf544fae1bb7d9f6ae", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -22,7 +22,7 @@ export parse_ty_data;\n type str_def = fn(str) -> ast::def_id ;\n \n type pstate =\n-    {data: @u8[], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n+    {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n \n tag ty_or_bang { a_ty(ty::t); a_bang; }\n \n@@ -49,7 +49,7 @@ fn parse_ident_(st: @pstate, sd: str_def, is_last: fn(char) -> bool ) ->\n }\n \n \n-fn parse_ty_data(data: @u8[], crate_num: int, pos: uint, len: uint,\n+fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n                  sd: str_def, tcx: ty::ctxt) -> ty::t {\n     let st =\n         @{data: data, crate: crate_num, mutable pos: pos, len: len, tcx: tcx};\n@@ -64,8 +64,8 @@ fn parse_ty_or_bang(st: @pstate, sd: str_def) -> ty_or_bang {\n     }\n }\n \n-fn parse_constrs(st: @pstate, sd: str_def) -> (@ty::constr)[] {\n-    let rslt: (@ty::constr)[] = ~[];\n+fn parse_constrs(st: @pstate, sd: str_def) -> [@ty::constr] {\n+    let rslt: [@ty::constr] = ~[];\n     alt peek(st) as char {\n       ':' {\n         do  {\n@@ -81,8 +81,8 @@ fn parse_constrs(st: @pstate, sd: str_def) -> (@ty::constr)[] {\n }\n \n // FIXME less copy-and-paste\n-fn parse_ty_constrs(st: @pstate, sd: str_def) -> (@ty::type_constr)[] {\n-    let rslt: (@ty::type_constr)[] = ~[];\n+fn parse_ty_constrs(st: @pstate, sd: str_def) -> [@ty::type_constr] {\n+    let rslt: [@ty::type_constr] = ~[];\n     alt peek(st) as char {\n       ':' {\n         do  {\n@@ -98,7 +98,7 @@ fn parse_ty_constrs(st: @pstate, sd: str_def) -> (@ty::type_constr)[] {\n }\n \n fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n-    let idents: ast::ident[] = ~[];\n+    let idents: [ast::ident] = ~[];\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n     idents += ~[parse_ident_(st, sd, is_last)];\n     while true {\n@@ -153,7 +153,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n    @ty::constr_general[T] {\n     let sp = {lo: 0u, hi: 0u}; // FIXME: use a real span\n-    let args: (@sp_constr_arg[T])[] = ~[];\n+    let args: [@sp_constr_arg[T]] = ~[];\n     let pth: path = parse_path(st, sd);\n     let ignore: char = next(st) as char;\n     assert (ignore as char == '(');\n@@ -197,7 +197,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       't' {\n         assert (next(st) as char == '[');\n         let def = parse_def(st, sd);\n-        let params: ty::t[] = ~[];\n+        let params: [ty::t] = ~[];\n         while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tag(st.tcx, def, params);\n@@ -223,7 +223,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       'C' { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n       'R' {\n         assert (next(st) as char == '[');\n-        let fields: ty::field[] = ~[];\n+        let fields: [ty::field] = ~[];\n         while peek(st) as char != ']' {\n             let name = \"\";\n             while peek(st) as char != '=' {\n@@ -264,7 +264,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       }\n       'O' {\n         assert (next(st) as char == '[');\n-        let methods: ty::method[] = ~[];\n+        let methods: [ty::method] = ~[];\n         while peek(st) as char != ']' {\n             let proto;\n             alt next(st) as char {\n@@ -291,7 +291,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         assert (next(st) as char == '[');\n         let def = parse_def(st, sd);\n         let inner = parse_ty(st, sd);\n-        let params: ty::t[] = ~[];\n+        let params: [ty::t] = ~[];\n         while peek(st) as char != ']' { params += ~[parse_ty(st, sd)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_res(st.tcx, def, inner, params);\n@@ -369,9 +369,9 @@ fn parse_hex(st: @pstate) -> uint {\n }\n \n fn parse_ty_fn(st: @pstate, sd: str_def) ->\n-   {args: ty::arg[], ty: ty::t, cf: ast::controlflow, cs: (@ty::constr)[]} {\n+   {args: [ty::arg], ty: ty::t, cf: ast::controlflow, cs: [@ty::constr]} {\n     assert (next(st) as char == '[');\n-    let inputs: ty::arg[] = ~[];\n+    let inputs: [ty::arg] = ~[];\n     while peek(st) as char != ']' {\n         let mode = ty::mo_val;\n         if peek(st) as char == '&' {\n@@ -399,7 +399,7 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n \n \n // Rust metadata parsing\n-fn parse_def_id(buf: &u8[]) -> ast::def_id {\n+fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let colon_idx = 0u;\n     let len = ivec::len[u8](buf);\n     while colon_idx < len && buf.(colon_idx) != ':' as u8 { colon_idx += 1u; }"}, {"sha": "529c51f602ff672ab067efc04482972dbc192510", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -199,8 +199,8 @@ fn enc_proto(w: &ioivec::writer, proto: proto) {\n     }\n }\n \n-fn enc_ty_fn(w: &ioivec::writer, cx: &@ctxt, args: &ty::arg[], out: &ty::t,\n-             cf: &controlflow, constrs: &(@ty::constr)[]) {\n+fn enc_ty_fn(w: &ioivec::writer, cx: &@ctxt, args: &[ty::arg], out: &ty::t,\n+             cf: &controlflow, constrs: &[@ty::constr]) {\n     w.write_char('[');\n     for arg: ty::arg  in args {\n         alt arg.mode {"}, {"sha": "2eefe1c9f5d214100fc22d0fa7a6158a559a48b2", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -25,14 +25,14 @@ import std::option::is_none;\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n-    @{root_vars: node_id[],\n+    @{root_vars: [node_id],\n       block_defnum: node_id,\n-      bindings: node_id[],\n-      tys: ty::t[],\n-      depends_on: uint[],\n+      bindings: [node_id],\n+      tys: [ty::t],\n+      depends_on: [uint],\n       mutable ok: valid};\n \n-type scope = @restrict[];\n+type scope = @[restrict];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n@@ -51,7 +51,7 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &ast::ty_param[], sp: &span,\n+fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n             name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt[scope]) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     for arg_: ast::arg  in f.decl.inputs {\n@@ -164,14 +164,14 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt[scope]) {\n     }\n }\n \n-fn check_call(cx: &ctx, f: &@ast::expr, args: &(@ast::expr)[], sc: &scope) ->\n-   {root_vars: node_id[], unsafe_ts: ty::t[]} {\n+fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n+   {root_vars: [node_id], unsafe_ts: [ty::t]} {\n     let fty = ty::expr_ty(cx.tcx, f);\n     let arg_ts = fty_args(cx, fty);\n-    let roots: node_id[] = ~[];\n-    let mut_roots: {arg: uint, node: node_id}[] = ~[];\n-    let unsafe_ts: ty::t[] = ~[];\n-    let unsafe_t_offsets: uint[] = ~[];\n+    let roots: [node_id] = ~[];\n+    let mut_roots: [{arg: uint, node: node_id}] = ~[];\n+    let unsafe_ts: [ty::t] = ~[];\n+    let unsafe_t_offsets: [uint] = ~[];\n     let i = 0u;\n     for arg_t: ty::arg  in arg_ts {\n         if arg_t.mode != ty::mo_val {\n@@ -308,13 +308,13 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n     }\n }\n \n-fn check_alt(cx: &ctx, input: &@ast::expr, arms: &ast::arm[], sc: &scope,\n+fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n              v: &vt[scope]) {\n     visit::visit_expr(input, sc, v);\n     let root = expr_root(cx, input, true);\n     let roots =\n         alt path_def_id(cx, root.ex) { some(did) { ~[did.node] } _ { ~[] } };\n-    let forbidden_tp: ty::t[] =\n+    let forbidden_tp: [ty::t] =\n         alt inner_mut(root.ds) { some(t) { ~[t] } _ { ~[] } };\n     for a: ast::arm  in arms {\n         let dnums = arm_defnums(a);\n@@ -331,7 +331,7 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &ast::arm[], sc: &scope,\n     }\n }\n \n-fn arm_defnums(arm: &ast::arm) -> node_id[] {\n+fn arm_defnums(arm: &ast::arm) -> [node_id] {\n     ret ast::pat_binding_ids(arm.pats.(0));\n }\n \n@@ -506,7 +506,7 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n     }\n }\n \n-fn deps(sc: &scope, roots: &node_id[]) -> uint[] {\n+fn deps(sc: &scope, roots: &[node_id]) -> [uint] {\n     let i = 0u;\n     let result = ~[];\n     for r: restrict  in *sc {\n@@ -528,8 +528,8 @@ type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n // the inner derefs come in front, so foo.bar.baz becomes rec(ex=foo,\n // ds=[field(baz),field(bar)])\n fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n-   {ex: @ast::expr, ds: @deref[]} {\n-    fn maybe_auto_unbox(cx: &ctx, t: ty::t) -> {t: ty::t, ds: deref[]} {\n+   {ex: @ast::expr, ds: @[deref]} {\n+    fn maybe_auto_unbox(cx: &ctx, t: ty::t) -> {t: ty::t, ds: [deref]} {\n         let ds = ~[];\n         while true {\n             alt ty::struct(cx.tcx, t) {\n@@ -557,7 +557,7 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n         }\n         ret {t: t, ds: ds};\n     }\n-    let ds: deref[] = ~[];\n+    let ds: [deref] = ~[];\n     while true {\n         alt { ex.node } {\n           ast::expr_field(base, ident) {\n@@ -621,12 +621,12 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n     ret {ex: ex, ds: @ds};\n }\n \n-fn mut_field(ds: &@deref[]) -> bool {\n+fn mut_field(ds: &@[deref]) -> bool {\n     for d: deref  in *ds { if d.mut { ret true; } }\n     ret false;\n }\n \n-fn inner_mut(ds: &@deref[]) -> option::t[ty::t] {\n+fn inner_mut(ds: &@[deref]) -> option::t[ty::t] {\n     for d: deref  in *ds { if d.mut { ret some(d.outer_t); } }\n     ret none;\n }\n@@ -701,7 +701,7 @@ fn def_is_local(d: &ast::def, objfields_count: bool) -> bool {\n         };\n }\n \n-fn fty_args(cx: &ctx, fty: ty::t) -> ty::arg[] {\n+fn fty_args(cx: &ctx, fty: ty::t) -> [ty::arg] {\n     ret alt ty::struct(cx.tcx, ty::type_autoderef(cx.tcx, fty)) {\n           ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(_, args, _) { args }\n         };"}, {"sha": "b3feeeb3fecd8940c3ced376c6a93609c3d9bad2", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -15,7 +15,7 @@ fn check_expr(tcx: &ty::ctxt, ex: &@expr, s: &(), v: &visit::vt[()]) {\n     alt ex.node { expr_alt(_, arms) { check_arms(tcx, arms); } _ { } }\n }\n \n-fn check_arms(tcx: &ty::ctxt, arms: &arm[]) {\n+fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n     let i = 0;\n     for arm: arm  in arms {\n         for arm_pat: @pat  in arm.pats {\n@@ -38,7 +38,7 @@ fn check_arms(tcx: &ty::ctxt, arms: &arm[]) {\n }\n \n fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n-    fn patterns_supersede(tcx: &ty::ctxt, as: &(@pat)[], bs: &(@pat)[]) ->\n+    fn patterns_supersede(tcx: &ty::ctxt, as: &[@pat], bs: &[@pat]) ->\n        bool {\n         let i = 0;\n         for a: @pat  in as {\n@@ -47,8 +47,8 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n         }\n         ret true;\n     }\n-    fn field_patterns_supersede(tcx: &ty::ctxt, fas: &field_pat[],\n-                                fbs: &field_pat[]) -> bool {\n+    fn field_patterns_supersede(tcx: &ty::ctxt, fas: &[field_pat],\n+                                fbs: &[field_pat]) -> bool {\n         let wild = @{id: 0, node: pat_wild, span: {lo: 0u, hi: 0u}};\n         for fa: field_pat  in fas {\n             let pb = wild;"}, {"sha": "fa1cc2aa093469f0bbd12f597872d7c4809d0445", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -30,7 +30,7 @@ export def_lookup;\n // testing membership, the list of referencing sites is what you want for most\n // other things.\n type freevar_set = hashset[ast::node_id];\n-type freevar_info = {defs: freevar_set, refs: @ast::node_id[]};\n+type freevar_info = {defs: freevar_set, refs: @[ast::node_id]};\n type freevar_map = hashmap[ast::node_id, freevar_info];\n \n // Searches through part of the AST for all references to locals or\n@@ -40,12 +40,12 @@ type freevar_map = hashmap[ast::node_id, freevar_info];\n // in order to start the search.\n fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n                     walker: &fn(&visit::vt[()]) ,\n-                    initial_decls: ast::node_id[]) -> freevar_info {\n+                    initial_decls: [ast::node_id]) -> freevar_info {\n     let decls = new_int_hash();\n     for decl: ast::node_id  in initial_decls { set_add(decls, decl); }\n     let refs = @mutable ~[];\n \n-    let walk_fn = lambda(f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+    let walk_fn = lambda(f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n                          i: &ast::fn_ident, nid: ast::node_id) {\n         for a: ast::arg  in f.decl.inputs { set_add(decls, a.id); }\n     };\n@@ -107,7 +107,7 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n                      crate: &@ast::crate) -> freevar_map {\n     let freevars = new_int_hash();\n \n-    let walk_fn = lambda(f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+    let walk_fn = lambda(f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n                          i: &ast::fn_ident, nid: ast::node_id) {\n         let start_walk = lambda(v: &visit::vt[()]) {\n             v.visit_fn(f, tps, sp, i, nid, (), v);\n@@ -148,7 +148,7 @@ fn get_freevar_info(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n fn get_freevar_defs(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_set {\n     ret get_freevar_info(tcx, fid).defs;\n }\n-fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> @ast::node_id[] {\n+fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> @[ast::node_id] {\n     ret get_freevar_info(tcx, fid).refs;\n }\n fn has_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> bool {"}, {"sha": "d1e9236d035bf6fc68ff4862813bb41a3958e0fd", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -49,7 +49,7 @@ export def_map;\n tag scope {\n     scope_crate;\n     scope_item(@ast::item);\n-    scope_fn(ast::fn_decl, ast::proto, ast::ty_param[]);\n+    scope_fn(ast::fn_decl, ast::proto, [ast::ty_param]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n \n@@ -104,7 +104,7 @@ type glob_imp_def = {def: def, item: @ast::view_item};\n type indexed_mod =\n     {m: option::t[ast::_mod],\n      index: mod_index,\n-     mutable glob_imports: glob_imp_def[],\n+     mutable glob_imports: [glob_imp_def],\n      glob_imported_names: hashmap[str, import_state]};\n \n \n@@ -119,9 +119,9 @@ type env =\n      ast_map: ast_map::map,\n      imports: hashmap[ast::node_id, import_state],\n      mod_map: hashmap[ast::node_id, @indexed_mod],\n-     ext_map: hashmap[def_id, ident[]],\n+     ext_map: hashmap[def_id, [ident]],\n      ext_cache: ext_hash,\n-     mutable reported: {ident: str, sc: scope}[],\n+     mutable reported: [{ident: str, sc: scope}],\n      sess: session};\n \n \n@@ -139,7 +139,7 @@ fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n           ast_map: amap,\n           imports: new_int_hash[import_state](),\n           mod_map: new_int_hash[@indexed_mod](),\n-          ext_map: new_def_hash[ident[]](),\n+          ext_map: new_def_hash[[ident]](),\n           ext_cache: new_ext_hash(),\n           mutable reported: ~[],\n           sess: sess};\n@@ -327,7 +327,7 @@ fn visit_native_item_with_scope(ni: &@ast::native_item, sc: &scopes,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &ast::ty_param[],\n+fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n                        sp: &span, name: &fn_ident, id: node_id, sc: &scopes,\n                        v: &vt[scopes]) {\n     // is this a main fn declaration?\n@@ -375,7 +375,7 @@ fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n     }\n }\n \n-fn follow_import(e: &env, sc: &scopes, path: &ident[], sp: &span) ->\n+fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n    option::t[def] {\n     let path_len = ivec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n@@ -701,7 +701,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n \n }\n \n-fn lookup_in_ty_params(name: &ident, ty_params: &ast::ty_param[]) ->\n+fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n    option::t[def] {\n     let i = 0u;\n     for tp: ast::ty_param  in ty_params {\n@@ -738,7 +738,7 @@ fn lookup_in_pat(name: &ident, pat: &ast::pat) -> option::t[def_id] {\n }\n \n fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n-                ty_params: &ast::ty_param[], ns: namespace) ->\n+                ty_params: &[ast::ty_param], ns: namespace) ->\n    option::t[def] {\n     alt ns {\n       ns_value. {\n@@ -754,7 +754,7 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n     }\n }\n \n-fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &ast::ty_param[],\n+fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n                  ns: namespace) -> option::t[def] {\n     alt ns {\n       ns_value. {\n@@ -1138,7 +1138,7 @@ fn ns_for_def(d: def) -> namespace {\n         };\n }\n \n-fn lookup_external(e: &env, cnum: int, ids: &ident[], ns: namespace) ->\n+fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n    option::t[def] {\n     for d: def  in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n@@ -1211,8 +1211,8 @@ fn mie_span(mie: &mod_index_entry) -> span {\n }\n \n fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt[()]) {\n-    fn typaram_names(tps: &ast::ty_param[]) -> ident[] {\n-        let x: ast::ident[] = ~[];\n+    fn typaram_names(tps: &[ast::ty_param]) -> [ident] {\n+        let x: [ast::ident] = ~[];\n         for tp: ast::ty_param in tps { x += ~[tp.ident] }\n         ret x;\n     }\n@@ -1347,10 +1347,10 @@ fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt[()]) {\n     visit::visit_ty(ty, x, v);\n }\n \n-type checker = @{mutable seen: ident[], kind: str, sess: session};\n+type checker = @{mutable seen: [ident], kind: str, sess: session};\n \n fn checker(e: &env, kind: str) -> checker {\n-    let seen: ident[] = ~[];\n+    let seen: [ident] = ~[];\n     ret @{mutable seen: seen, kind: kind, sess: e.sess};\n }\n \n@@ -1365,7 +1365,7 @@ fn add_name(ch: &checker, sp: &span, name: &ident) {\n \n fn ident_id(i: &ident) -> ident { ret i; }\n \n-fn ensure_unique[T](e: &env, sp: &span, elts: &T[], id: fn(&T) -> ident ,\n+fn ensure_unique[T](e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident ,\n                     kind: &str) {\n     let ch = checker(e, kind);\n     for elt: T  in elts { add_name(ch, sp, id(elt)); }"}, {"sha": "459129238891e5ced5664bde2fc81ead93a479cd", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -39,7 +39,7 @@ type ctxt = {\n     mutable next_tag_id: u16,\n     pad: u16,\n     tag_id_to_index: hashmap[ast::def_id,u16],\n-    mutable tag_order: ast::def_id[],\n+    mutable tag_order: [ast::def_id],\n     resources: interner::interner[res_info],\n     llshapetablesty: TypeRef,\n     llshapetables: ValueRef\n@@ -102,7 +102,7 @@ fn mk_global(ccx : &@crate_ctxt, name : &str, llval : ValueRef) -> ValueRef {\n //\n // TODO: Use this in dynamic_size_of() as well.\n \n-fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> uint[] {\n+fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n     //\n     // TODO: We could do better here; e.g. we know that any variant that\n@@ -186,7 +186,7 @@ fn round_up(size : u16, align : u8) -> u16 {\n \n type size_align = { size: u16, align: u8 };\n \n-fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &uint[],\n+fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &[uint],\n                            did : &ast::def_id) -> size_align {\n     let max_size = 0u16; let max_align = 1u8;\n     let variants = ty::tag_variants(ccx.tcx, did);\n@@ -263,20 +263,20 @@ fn mk_ctxt(llmod : ModuleRef) -> ctxt {\n     };\n }\n \n-fn add_bool(dest : &mutable u8[], val : bool) {\n+fn add_bool(dest : &mutable [u8], val : bool) {\n     dest += ~[if val { 1u8 } else { 0u8 }];\n }\n \n-fn add_u16(dest : &mutable u8[], val : u16) {\n+fn add_u16(dest : &mutable [u8], val : u16) {\n     dest += ~[(val & 0xffu16) as u8, (val >> 8u16) as u8];\n }\n \n-fn add_substr(dest : &mutable u8[], src : &u8[]) {\n+fn add_substr(dest : &mutable [u8], src : &[u8]) {\n     add_u16(dest, ivec::len(src) as u16);\n     dest += src;\n }\n \n-fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> u8[] {\n+fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n     let s = ~[];\n \n     alt ty::struct(ccx.tcx, t) {\n@@ -395,7 +395,7 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> u8[] {\n     ret s;\n }\n \n-fn add_size_hint(ccx : &@crate_ctxt, s : &mutable u8[], typ : ty::t) {\n+fn add_size_hint(ccx : &@crate_ctxt, s : &mutable [u8], typ : ty::t) {\n     if (ty::type_has_dynamic_size(ccx.tcx, typ)) {\n         s += ~[ 0u8, 0u8, 0u8 ];\n         ret;\n@@ -407,7 +407,7 @@ fn add_size_hint(ccx : &@crate_ctxt, s : &mutable u8[], typ : ty::t) {\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx : &@crate_ctxt, v : &ty::variant_info) -> u8[] {\n+fn shape_of_variant(ccx : &@crate_ctxt, v : &ty::variant_info) -> [u8] {\n     let s = ~[];\n     for t : ty::t in v.args { s += shape_of(ccx, t); }\n     ret s;"}, {"sha": "2d003182cb2b29426aa6087445b1a89d63e075e9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 146, "deletions": 146, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -88,9 +88,9 @@ fn type_of(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n     ret type_of_inner(cx, sp, t);\n }\n \n-fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &ty::arg[]) ->\n-   TypeRef[] {\n-    let atys: TypeRef[] = ~[];\n+fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &[ty::arg]) ->\n+   [TypeRef] {\n+    let atys: [TypeRef] = ~[];\n     for arg: ty::arg  in inputs {\n         let t: TypeRef = type_of_inner(cx, sp, arg.ty);\n         t = alt arg.mode {\n@@ -111,9 +111,9 @@ fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &ty::arg[]) ->\n //  - new_fn_ctxt\n //  - trans_args\n fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n-                   is_method: bool, inputs: &ty::arg[], output: &ty::t,\n+                   is_method: bool, inputs: &[ty::arg], output: &ty::t,\n                    ty_param_count: uint) -> TypeRef {\n-    let atys: TypeRef[] = ~[];\n+    let atys: [TypeRef] = ~[];\n \n     // Arg 0: Output pointer.\n     atys += ~[T_ptr(type_of_inner(cx, sp, output))];\n@@ -148,7 +148,7 @@ fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n }\n \n fn type_of_fn(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n-              inputs: &ty::arg[], output: &ty::t, ty_param_count: uint) ->\n+              inputs: &[ty::arg], output: &ty::t, ty_param_count: uint) ->\n    TypeRef {\n     ret type_of_fn_full(cx, sp, proto, false, inputs, output, ty_param_count);\n }\n@@ -164,9 +164,9 @@ fn type_of_fn_from_ty(cx: &@crate_ctxt, sp: &span,\n }\n \n fn type_of_native_fn(cx: &@crate_ctxt, sp: &span, abi: ast::native_abi,\n-                     inputs: &ty::arg[], output: &ty::t, ty_param_count: uint)\n+                     inputs: &[ty::arg], output: &ty::t, ty_param_count: uint)\n    -> TypeRef {\n-    let atys: TypeRef[] = ~[];\n+    let atys: [TypeRef] = ~[];\n     if abi == ast::native_abi_rust {\n         atys += ~[T_taskptr(*cx)];\n         let i = 0u;\n@@ -225,7 +225,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n       ty::ty_chan(t) { llty = T_ptr(T_chan(type_of_inner(cx, sp, t))); }\n       ty::ty_task. { llty = T_taskptr(*cx); }\n       ty::ty_rec(fields) {\n-        let tys: TypeRef[] = ~[];\n+        let tys: [TypeRef] = ~[];\n         for f: ty::field  in fields {\n             tys += ~[type_of_inner(cx, sp, f.mt.ty)];\n         }\n@@ -383,10 +383,10 @@ fn get_simple_extern_fn(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n fn trans_native_call(b: &builder, glues: @glue_fns, lltaskptr: ValueRef,\n                      externs: &hashmap[str, ValueRef], tn: &type_names,\n                      llmod: ModuleRef, name: &str, pass_task: bool,\n-                     args: &ValueRef[]) -> ValueRef {\n+                     args: &[ValueRef]) -> ValueRef {\n     let n: int = std::ivec::len[ValueRef](args) as int;\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n-    let call_args: ValueRef[] = ~[];\n+    let call_args: [ValueRef] = ~[];\n     for a: ValueRef  in args { call_args += ~[b.ZExtOrBitCast(a, T_int())]; }\n     ret b.Call(llnative, call_args);\n }\n@@ -534,7 +534,7 @@ fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> uint {\n }\n \n fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n-    fn align_elements(cx: &@block_ctxt, elts: &ty::t[]) -> result {\n+    fn align_elements(cx: &@block_ctxt, elts: &[ty::t]) -> result {\n         //\n         // C padding rules:\n         //\n@@ -565,7 +565,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         ret rslt(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n       }\n       ty::ty_rec(flds) {\n-        let tys: ty::t[] = ~[];\n+        let tys: [ty::t] = ~[];\n         for f: ty::field  in flds { tys += ~[f.mt.ty]; }\n         ret align_elements(cx, tys);\n       }\n@@ -579,8 +579,8 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         for variant: ty::variant_info  in variants {\n             // Perform type substitution on the raw argument types.\n \n-            let raw_tys: ty::t[] = variant.args;\n-            let tys: ty::t[] = ~[];\n+            let raw_tys: [ty::t] = variant.args;\n+            let tys: [ty::t] = ~[];\n             for raw_ty: ty::t  in raw_tys {\n                 let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n                 tys += ~[t];\n@@ -642,8 +642,8 @@ fn dynamic_align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_int()\n-fn GEPi(cx: &@block_ctxt, base: ValueRef, ixs: &int[]) -> ValueRef {\n-    let v: ValueRef[] = ~[];\n+fn GEPi(cx: &@block_ctxt, base: ValueRef, ixs: &[int]) -> ValueRef {\n+    let v: [ValueRef] = ~[];\n     for i: int  in ixs { v += ~[C_int(i)]; }\n     ret cx.build.GEP(base, v);\n }\n@@ -666,7 +666,7 @@ fn bump_ptr(bcx: &@block_ctxt, t: &ty::t, base: ValueRef, sz: ValueRef)\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n-fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &int[]) ->\n+fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n    result {\n     assert (ty::type_is_tup_like(bcx_tcx(cx), t));\n     // It might be a static-known type. Handle this.\n@@ -689,8 +689,8 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &int[]) ->\n     // elements of the type and splitting the Xth off. Return the prefix as\n     // well as the innermost Xth type.\n \n-    fn split_type(ccx: &@crate_ctxt, t: &ty::t, ixs: &int[], n: uint) ->\n-       {prefix: ty::t[], target: ty::t} {\n+    fn split_type(ccx: &@crate_ctxt, t: &ty::t, ixs: &[int], n: uint) ->\n+       {prefix: [ty::t], target: ty::t} {\n         let len: uint = std::ivec::len[int](ixs);\n         // We don't support 0-index or 1-index GEPs: The former is nonsense\n         // and the latter would only be meaningful if we supported non-0\n@@ -707,7 +707,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &int[]) ->\n         }\n         assert (n < len);\n         let ix: int = ixs.(n);\n-        let prefix: ty::t[] = ~[];\n+        let prefix: [ty::t] = ~[];\n         let i: int = 0;\n         while i < ix {\n             prefix += ~[ty::get_element_type(ccx.tcx, t, i as uint)];\n@@ -749,7 +749,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &int[]) ->\n // appropriate. @llblobptr is the data part of a tag value; its actual type is\n // meaningless, as it will be cast away.\n fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n-           variant_id: &ast::def_id, ty_substs: &ty::t[], ix: int) -> result {\n+           variant_id: &ast::def_id, ty_substs: &[ty::t], ix: int) -> result {\n     let variant = ty::tag_variant_with_id(bcx_tcx(cx), tag_id, variant_id);\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n@@ -758,7 +758,7 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n     let elem_ty = ty::mk_nil(bcx_tcx(cx)); // typestate infelicity\n \n     let i = 0;\n-    let true_arg_tys: ty::t[] = ~[];\n+    let true_arg_tys: [ty::t] = ~[];\n     for aty: ty::t  in arg_tys {\n         let arg_ty = ty::substitute_type_params(bcx_tcx(cx), ty_substs, aty);\n         true_arg_tys += ~[arg_ty];\n@@ -869,11 +869,11 @@ fn field_of_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool, field: int) ->\n // indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n fn linearize_ty_params(cx: &@block_ctxt, t: &ty::t) ->\n-   {params: uint[], descs: ValueRef[]} {\n-    let param_vals: ValueRef[] = ~[];\n-    let param_defs: uint[] = ~[];\n+   {params: [uint], descs: [ValueRef]} {\n+    let param_vals: [ValueRef] = ~[];\n+    let param_defs: [uint] = ~[];\n     type rr =\n-        {cx: @block_ctxt, mutable vals: ValueRef[], mutable defs: uint[]};\n+        {cx: @block_ctxt, mutable vals: [ValueRef], mutable defs: [uint]};\n \n     fn linearizer(r: @rr, t: ty::t) {\n         alt ty::struct(bcx_tcx(r.cx), t) {\n@@ -1007,7 +1007,7 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n     ret rslt(cx, info.tydesc);\n }\n \n-fn get_static_tydesc(cx: &@block_ctxt, orig_t: &ty::t, ty_params: &uint[]) ->\n+fn get_static_tydesc(cx: &@block_ctxt, orig_t: &ty::t, ty_params: &[uint]) ->\n    @tydesc_info {\n     let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n \n@@ -1051,7 +1051,7 @@ fn set_glue_inlining(cx: &@local_ctxt, f: ValueRef, t: &ty::t) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: &ty::t, ty_params: &uint[])\n+fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: &ty::t, ty_params: &[uint])\n    -> @tydesc_info {\n     log \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     let ccx = cx.ccx;\n@@ -1109,7 +1109,7 @@ fn declare_generic_glue(cx: &@local_ctxt, t: &ty::t, llfnty: TypeRef,\n fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n                            llfn: ValueRef,\n                            helper: &make_generic_glue_helper_fn,\n-                           ty_params: &uint[]) -> ValueRef {\n+                           ty_params: &[uint]) -> ValueRef {\n     let fcx = new_fn_ctxt(cx, sp, llfn);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n@@ -1126,7 +1126,7 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n     let ty_param_count = std::ivec::len[uint](ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 3u);\n     let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n-    let lltydescs = ~[mutable ];\n+    let lltydescs = ~[mutable];\n     let p = 0u;\n     while p < ty_param_count {\n         let llparam = copy_args_bcx.build.GEP(lltyparams, ~[C_int(p as int)]);\n@@ -1158,7 +1158,7 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n }\n \n fn make_generic_glue(cx: &@local_ctxt, sp: &span, t: &ty::t, llfn: ValueRef,\n-                     helper: &make_generic_glue_helper_fn, ty_params: &uint[],\n+                     helper: &make_generic_glue_helper_fn, ty_params: &[uint],\n                      name: &str) -> ValueRef {\n     if !cx.ccx.sess.get_opts().stats {\n         ret make_generic_glue_inner(cx, sp, t, llfn, helper, ty_params);\n@@ -1439,7 +1439,7 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n }\n \n fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n-                  inner_t: ty::t, tps: &ty::t[]) -> result {\n+                  inner_t: ty::t, tps: &[ty::t]) -> result {\n     let ccx = bcx_ccx(cx);\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n     let tup_ty = ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx), inner_t_s]);\n@@ -1619,7 +1619,7 @@ fn make_cmp_glue(cx: &@block_ctxt, lhs0: ValueRef, rhs0: ValueRef, t: &ty::t,\n             if load_inner {\n                 // If `load_inner` is true, then the pointer type will always\n                 // be i8, because the data part of a vector always has type\n-                // i8[]. So we need to cast it to the proper type.\n+                // [i8]. So we need to cast it to the proper type.\n \n                 if !ty::type_has_dynamic_size(bcx_tcx(last_cx), t) {\n                     let llelemty =\n@@ -1820,13 +1820,13 @@ fn iter_structural_ty(cx: &@block_ctxt, v: ValueRef, t: &ty::t,\n     ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n }\n \n-fn load_inbounds(cx: &@block_ctxt, p: ValueRef, idxs: &ValueRef[]) ->\n+fn load_inbounds(cx: &@block_ctxt, p: ValueRef, idxs: &[ValueRef]) ->\n    ValueRef {\n     ret cx.build.Load(cx.build.InBoundsGEP(p, idxs));\n }\n \n fn store_inbounds(cx: &@block_ctxt, v: ValueRef, p: ValueRef,\n-                  idxs: &ValueRef[]) {\n+                  idxs: &[ValueRef]) {\n     cx.build.Store(v, cx.build.InBoundsGEP(p, idxs));\n }\n \n@@ -1920,7 +1920,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n     }\n \n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef, b_tup: ValueRef,\n-                    variant: &ty::variant_info, tps: &ty::t[],\n+                    variant: &ty::variant_info, tps: &[ty::t],\n                     tid: &ast::def_id, f: &val_pair_and_ty_fn) -> result {\n         if std::ivec::len[ty::t](variant.args) == 0u {\n             ret rslt(cx, C_nil());\n@@ -2332,7 +2332,7 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n     }\n \n     let llcmpresultptr = alloca(r.bcx, T_i1());\n-    let llargs: ValueRef[] =\n+    let llargs: [ValueRef] =\n         ~[llcmpresultptr, r.bcx.fcx.lltaskptr, lltydesc,\n           lltydescs, llrawlhsptr, llrawrhsptr, llop];\n     r.bcx.build.Call(llfn, llargs);\n@@ -3540,11 +3540,11 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n     }\n }\n \n-fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &result[]) ->\n+fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n    result {\n-    let live: result[] = ~[];\n-    let vals: ValueRef[] = ~[];\n-    let bbs: BasicBlockRef[] = ~[];\n+    let live: [result] = ~[];\n+    let vals: [ValueRef] = ~[];\n+    let bbs: [BasicBlockRef] = ~[];\n     for r: result  in ins {\n         if !is_terminated(r.bcx) {\n             live += ~[r];\n@@ -3571,7 +3571,7 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &result[]) ->\n     ret rslt(join_cx, phi);\n }\n \n-fn join_branches(parent_cx: &@block_ctxt, ins: &result[]) -> @block_ctxt {\n+fn join_branches(parent_cx: &@block_ctxt, ins: &[result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, \"join\");\n     for r: result  in ins {\n         if !is_terminated(r.bcx) { r.bcx.build.Br(out.llbb); }\n@@ -3665,8 +3665,8 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-fn build_environment(bcx: @block_ctxt, lltydescs: ValueRef[],\n-                     bound_tys: ty::t[], bound_vals: lval_result[],\n+fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n+                     bound_tys: [ty::t], bound_vals: [lval_result],\n                      copying: bool)\n     -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n     // Synthesize a closure type.\n@@ -3684,7 +3684,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: ValueRef[],\n     // (We'll need room for that many tydescs in the closure.)\n     let ty_param_count = std::ivec::len(lltydescs);\n     let tydesc_ty: ty::t = ty::mk_type(bcx_tcx(bcx));\n-    let captured_tys: ty::t[] =\n+    let captured_tys: [ty::t] =\n         std::ivec::init_elt(tydesc_ty, ty_param_count);\n \n     // Get all the types we've got (some of which we synthesized\n@@ -3693,7 +3693,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: ValueRef[],\n \n     // closure_tys = [tydesc_ty, [bound_ty1, bound_ty2, ...], [tydesc_ty,\n     // tydesc_ty, ...]]\n-    let closure_tys: ty::t[] =\n+    let closure_tys: [ty::t] =\n         ~[tydesc_ty, bindings_ty, ty::mk_imm_tup(bcx_tcx(bcx), captured_tys)];\n \n     // Finally, synthesize a type for that whole vector.\n@@ -3761,10 +3761,10 @@ fn build_environment(bcx: @block_ctxt, lltydescs: ValueRef[],\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for build_environment.\n-fn build_closure(cx: &@block_ctxt, upvars: &@ast::node_id[], copying: bool)\n+fn build_closure(cx: &@block_ctxt, upvars: &@[ast::node_id], copying: bool)\n     -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n-        let closure_vals: lval_result[] = ~[];\n-        let closure_tys: ty::t[] = ~[];\n+        let closure_vals: [lval_result] = ~[];\n+        let closure_tys: [ty::t] = ~[];\n         // If we need to, package up the iterator body to call\n         if !copying && !option::is_none(cx.fcx.lliterbody) {\n             closure_vals += ~[lval_mem(cx, option::get(cx.fcx.lliterbody))];\n@@ -3816,7 +3816,7 @@ fn find_environment_tydescs(bcx: &@block_ctxt, envty: &ty::t,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n-                    envty: &ty::t, upvars: &@ast::node_id[],\n+                    envty: &ty::t, upvars: &@[ast::node_id],\n                     copying: bool) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n@@ -3972,8 +3972,8 @@ fn trans_do_while(cx: &@block_ctxt, body: &ast::blk, cond: &@ast::expr) ->\n \n type generic_info =\n     {item_type: ty::t,\n-     static_tis: (option::t[@tydesc_info])[],\n-     tydescs: ValueRef[]};\n+     static_tis: [option::t[@tydesc_info]],\n+     tydescs: [ValueRef]};\n \n type lval_result =\n     {res: result,\n@@ -4020,8 +4020,8 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n     let tys = ty::node_id_to_type_params(bcx_tcx(cx), id);\n     if std::ivec::len[ty::t](tys) != 0u {\n         let bcx = lv.res.bcx;\n-        let tydescs: ValueRef[] = ~[];\n-        let tis: (option::t[@tydesc_info])[] = ~[];\n+        let tydescs: [ValueRef] = ~[];\n+        let tis: [option::t[@tydesc_info]] = ~[];\n         for t: ty::t  in tys {\n             // TODO: Doesn't always escape.\n \n@@ -4116,7 +4116,7 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) ->\n             ret lval_mem(cx, ccx.consts.get(did.node));\n         } else {\n             let tp = ty::node_id_to_monotype(ccx.tcx, id);\n-            let k: ast::kind[] = ~[];\n+            let k: [ast::kind] = ~[];\n             ret lval_val(cx,\n                          load_if_immediate(cx,\n                                            trans_external_path(cx, did,\n@@ -4405,8 +4405,8 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n }\n \n fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n-                    outgoing_fty: &ty::t, args: &(option::t[@ast::expr])[],\n-                    env_ty: &ty::t, bound_tys: &ty::t[],\n+                    outgoing_fty: &ty::t, args: &[option::t[@ast::expr]],\n+                    env_ty: &ty::t, bound_tys: &[ty::t],\n                     ty_param_count: uint) -> {val: ValueRef, ty: TypeRef} {\n \n     // Here we're not necessarily constructing a thunk in the sense of\n@@ -4493,7 +4493,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     }\n \n     // Set up the three implicit arguments to the thunk.\n-    let llargs: ValueRef[] = ~[llretptr, fcx.lltaskptr, lltargetclosure];\n+    let llargs: [ValueRef] = ~[llretptr, fcx.lltaskptr, lltargetclosure];\n \n     // Copy in the type parameters.\n     let i: uint = 0u;\n@@ -4512,7 +4512,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     let a: uint = 3u; // retptr, task ptr, env come first\n     let b: int = 1;\n     let outgoing_arg_index: uint = 0u;\n-    let llout_arg_tys: TypeRef[] =\n+    let llout_arg_tys: [TypeRef] =\n         type_of_explicit_args(cx.ccx, sp, outgoing_args);\n     for arg: option::t[@ast::expr]  in args {\n         let out_arg = outgoing_args.(outgoing_arg_index);\n@@ -4589,23 +4589,23 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n }\n \n fn trans_bind(cx: &@block_ctxt, f: &@ast::expr,\n-              args: &(option::t[@ast::expr])[], id: ast::node_id) -> result {\n+              args: &[option::t[@ast::expr]], id: ast::node_id) -> result {\n     let f_res = trans_lval_gen(cx, f);\n     ret trans_bind_1(cx, f, f_res, args, id);\n }\n \n fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n-                args: &(option::t[@ast::expr])[], id: ast::node_id) ->\n+                args: &[option::t[@ast::expr]], id: ast::node_id) ->\n    result {\n-    let bound: (@ast::expr)[] = ~[];\n+    let bound: [@ast::expr] = ~[];\n     for argopt: option::t[@ast::expr]  in args {\n         alt argopt { none. { } some(e) { bound += ~[e]; } }\n     }\n \n     // Figure out which tydescs we need to pass, if any.\n     let outgoing_fty: ty::t = ty::expr_ty(bcx_tcx(cx), f);\n     let outgoing_fty_real; // the type with typarams still in it\n-    let lltydescs: ValueRef[];\n+    let lltydescs: [ValueRef];\n     alt f_res.generic {\n       none. { outgoing_fty_real = outgoing_fty; lltydescs = ~[]; }\n       some(ginfo) {\n@@ -4630,8 +4630,8 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n \n     // Arrange for the bound function to live in the first binding spot.\n-    let bound_tys: ty::t[] = ~[outgoing_fty];\n-    let bound_vals: lval_result[] = ~[bound_f];\n+    let bound_tys: [ty::t] = ~[outgoing_fty];\n+    let bound_vals: [lval_result] = ~[bound_f];\n     // Translate the bound expressions.\n     for e: @ast::expr  in bound {\n         let lv = trans_lval(bcx, e);\n@@ -4726,11 +4726,11 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n //  - trans_args\n fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n               gen: &option::t[generic_info], lliterbody: &option::t[ValueRef],\n-              es: &(@ast::expr)[], fn_ty: &ty::t) ->\n-   {bcx: @block_ctxt, args: ValueRef[], retslot: ValueRef} {\n-    let args: ty::arg[] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n-    let llargs: ValueRef[] = ~[];\n-    let lltydescs: ValueRef[] = ~[];\n+              es: &[@ast::expr], fn_ty: &ty::t) ->\n+   {bcx: @block_ctxt, args: [ValueRef], retslot: ValueRef} {\n+    let args: [ty::arg] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n+    let llargs: [ValueRef] = ~[];\n+    let lltydescs: [ValueRef] = ~[];\n     let bcx: @block_ctxt = cx;\n     // Arg 0: Output pointer.\n \n@@ -4799,7 +4799,7 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n }\n \n fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n-              lliterbody: &option::t[ValueRef], args: &(@ast::expr)[],\n+              lliterbody: &option::t[ValueRef], args: &[@ast::expr],\n               id: ast::node_id) -> result {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n@@ -4882,7 +4882,7 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n     ret rslt(bcx, retval);\n }\n \n-fn trans_vec(cx: &@block_ctxt, args: &(@ast::expr)[], id: ast::node_id) ->\n+fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n    result {\n     let t = node_id_type(bcx_ccx(cx), id);\n     let unit_ty = t;\n@@ -4942,7 +4942,7 @@ fn trans_vec(cx: &@block_ctxt, args: &(@ast::expr)[], id: ast::node_id) ->\n \n \n // TODO: Move me to ivec::\n-fn trans_ivec(bcx: @block_ctxt, args: &(@ast::expr)[], id: ast::node_id) ->\n+fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n    result {\n     let typ = node_id_type(bcx_ccx(bcx), id);\n     let unit_ty;\n@@ -5035,7 +5035,7 @@ fn trans_ivec(bcx: @block_ctxt, args: &(@ast::expr)[], id: ast::node_id) ->\n     ret rslt(bcx, llvecptr);\n }\n \n-fn trans_rec(cx: &@block_ctxt, fields: &ast::field[],\n+fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n              base: &option::t[@ast::expr], id: ast::node_id) -> result {\n     let bcx = cx;\n     let t = node_id_type(bcx_ccx(bcx), id);\n@@ -5053,7 +5053,7 @@ fn trans_rec(cx: &@block_ctxt, fields: &ast::field[],\n         base_val = base_res.val;\n       }\n     }\n-    let ty_fields: ty::field[] = ~[];\n+    let ty_fields: [ty::field] = ~[];\n     alt ty::struct(bcx_tcx(cx), t) { ty::ty_rec(flds) { ty_fields = flds; } }\n     for tf: ty::field  in ty_fields {\n         let e_ty = tf.mt.ty;\n@@ -5489,7 +5489,7 @@ fn trans_put(cx: &@block_ctxt, e: &option::t[@ast::expr]) -> result {\n     }\n     let bcx = cx;\n     let dummy_retslot = alloca(bcx, T_nil());\n-    let llargs: ValueRef[] = ~[dummy_retslot, cx.fcx.lltaskptr, llenv];\n+    let llargs: [ValueRef] = ~[dummy_retslot, cx.fcx.lltaskptr, llenv];\n     alt e {\n       none. { }\n       some(x) {\n@@ -5637,9 +5637,9 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     // Fields.\n     // FIXME (part of issue #538): Where do we fill in the field *values* from\n     // the outer object?\n-    let additional_fields: ast::anon_obj_field[] = ~[];\n-    let additional_field_vals: result[] = ~[];\n-    let additional_field_tys: ty::t[] = ~[];\n+    let additional_fields: [ast::anon_obj_field] = ~[];\n+    let additional_field_vals: [result] = ~[];\n+    let additional_field_tys: [ty::t] = ~[];\n     alt anon_obj.fields {\n       none. { }\n       some(fields) {\n@@ -5894,7 +5894,7 @@ fn trans_stmt(cx: &@block_ctxt, s: &ast::stmt) -> result {\n // next three functions instead.\n fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n                   name: &str) -> @block_ctxt {\n-    let cleanups: cleanup[] = ~[];\n+    let cleanups: [cleanup] = ~[];\n     let s = str::buf(\"\");\n     let held_name; //HACK for str::buf, which doesn't keep its value alive\n     if cx.lcx.ccx.sess.get_opts().save_temps ||\n@@ -5938,7 +5938,7 @@ fn new_sub_block_ctxt(bcx: &@block_ctxt, n: &str) -> @block_ctxt {\n }\n \n fn new_raw_block_ctxt(fcx: &@fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n-    let cleanups: cleanup[] = ~[];\n+    let cleanups: [cleanup] = ~[];\n     ret @{llbb: llbb,\n           build: new_builder(llbb),\n           parent: parent_none,\n@@ -5993,7 +5993,7 @@ iter block_locals(b: &ast::blk) -> @ast::local {\n }\n \n fn llstaticallocas_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n-    let cleanups: cleanup[] = ~[];\n+    let cleanups: [cleanup] = ~[];\n     ret @{llbb: fcx.llstaticallocas,\n           build: new_builder(fcx.llstaticallocas),\n           parent: parent_none,\n@@ -6004,7 +6004,7 @@ fn llstaticallocas_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n }\n \n fn llderivedtydescs_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n-    let cleanups: cleanup[] = ~[];\n+    let cleanups: [cleanup] = ~[];\n     ret @{llbb: fcx.llderivedtydescs,\n           build: new_builder(fcx.llderivedtydescs),\n           parent: parent_none,\n@@ -6015,7 +6015,7 @@ fn llderivedtydescs_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n }\n \n fn lldynamicallocas_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n-    let cleanups: cleanup[] = ~[];\n+    let cleanups: [cleanup] = ~[];\n     ret @{llbb: fcx.lldynamicallocas,\n           build: new_builder(fcx.lldynamicallocas),\n           parent: parent_none,\n@@ -6122,7 +6122,7 @@ fn trans_block(cx: &@block_ctxt, b: &ast::blk, output: &out_method) ->\n }\n \n fn new_local_ctxt(ccx: &@crate_ctxt) -> @local_ctxt {\n-    let pth: str[] = ~[];\n+    let pth: [str] = ~[];\n     ret @{path: pth,\n           module_path: ~[ccx.link_meta.name],\n           obj_typarams: ~[],\n@@ -6207,7 +6207,7 @@ fn new_fn_ctxt(cx: @local_ctxt, sp: &span, llfndecl: ValueRef) -> @fn_ctxt {\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n                              ty_self: option::t[ty::t], ret_ty: ty::t,\n-                             args: &ast::arg[], ty_params: &ast::ty_param[]) {\n+                             args: &[ast::arg], ty_params: &[ast::ty_param]) {\n     // Skip the implicit arguments 0, 1, and 2.  TODO: Pull out 3u and define\n     // it as a constant, since we're using it in several places in trans this\n     // way.\n@@ -6247,8 +6247,8 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, args: &ast::arg[],\n-                        arg_tys: &ty::arg[]) {\n+fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg],\n+                        arg_tys: &[ty::arg]) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let arg_n: uint = 0u;\n     for aarg: ast::arg  in args {\n@@ -6270,8 +6270,8 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &ast::arg[],\n     }\n }\n \n-fn add_cleanups_for_args(bcx: &@block_ctxt, args: &ast::arg[],\n-                         arg_tys: &ty::arg[]) {\n+fn add_cleanups_for_args(bcx: &@block_ctxt, args: &[ast::arg],\n+                         arg_tys: &[ty::arg]) {\n     let arg_n: uint = 0u;\n     for aarg: ast::arg  in args {\n         if aarg.mode == ast::val {\n@@ -6294,15 +6294,15 @@ fn is_terminated(cx: &@block_ctxt) -> bool {\n     ret llvm::LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-fn arg_tys_of_fn(ccx: &@crate_ctxt, id: ast::node_id) -> ty::arg[] {\n+fn arg_tys_of_fn(ccx: &@crate_ctxt, id: ast::node_id) -> [ty::arg] {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n       ty::ty_fn(_, arg_tys, _, _, _) { ret arg_tys; }\n     }\n }\n \n fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     let bcx = llstaticallocas_block_ctxt(fcx);\n-    let field_tys: ty::t[] = ~[];\n+    let field_tys: [ty::t] = ~[];\n     for f: ast::obj_field  in bcx.fcx.lcx.obj_fields {\n         field_tys += ~[node_id_type(bcx_ccx(bcx), f.id)];\n     }\n@@ -6368,7 +6368,7 @@ fn finish_fn(fcx: &@fn_ctxt, lltop: BasicBlockRef) {\n fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n                  llfnty: &option::t[TypeRef], cx: @local_ctxt, sp: &span,\n                  f: &ast::_fn, llfndecl: ValueRef, ty_self: option::t[ty::t],\n-                 ty_params: &ast::ty_param[], id: ast::node_id)\n+                 ty_params: &[ast::ty_param], id: ast::node_id)\n     -> option::t[{fn_pair: ValueRef, bcx: @block_ctxt}] {\n     set_uwtable(llfndecl);\n \n@@ -6443,15 +6443,15 @@ fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n \n fn trans_fn_inner(cx: @local_ctxt, sp: &span, f: &ast::_fn,\n                   llfndecl: ValueRef, ty_self: option::t[ty::t],\n-                  ty_params: &ast::ty_param[], id: ast::node_id) {\n+                  ty_params: &[ast::ty_param], id: ast::node_id) {\n     trans_closure(none, none, cx, sp, f, llfndecl, ty_self, ty_params, id);\n }\n \n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n-            ty_self: option::t[ty::t], ty_params: &ast::ty_param[],\n+            ty_self: option::t[ty::t], ty_params: &[ast::ty_param],\n             id: ast::node_id) {\n     if !cx.ccx.sess.get_opts().stats {\n         trans_fn_inner(cx, sp, f, llfndecl, ty_self, ty_params, id);\n@@ -6517,8 +6517,8 @@ fn populate_self_stack(bcx: @block_ctxt,\n // the corresponding method on inner does, calls that method on outer, and\n // returns the value returned from that call.\n fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &ast::ty_param[], outer_obj_ty: ty::t,\n-                       additional_field_tys: &ty::t[]) -> ValueRef {\n+                       ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n+                       additional_field_tys: &[ty::t]) -> ValueRef {\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n@@ -6609,7 +6609,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Set up the three implicit arguments to the outer method we'll need\n     // to call.\n     let self_arg = llself_obj_ptr;\n-    let llouter_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_arg];\n+    let llouter_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_arg];\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llouter_mthd_args.\n@@ -6648,9 +6648,9 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n // from that call.  (The inner object won't exist until run-time, but we know\n // its type statically.)\n fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &ast::ty_param[], inner_obj_ty: ty::t,\n+                       ty_params: &[ast::ty_param], inner_obj_ty: ty::t,\n                        backwarding_vtbl: ValueRef,\n-                       additional_field_tys: &ty::t[]) -> ValueRef {\n+                       additional_field_tys: &[ty::t]) -> ValueRef {\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n@@ -6798,7 +6798,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n-    let llorig_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_stack];\n+    let llorig_mthd_args: [ValueRef] = ~[llretptr, fcx.lltaskptr, self_stack];\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llorig_mthd_args.\n@@ -6825,7 +6825,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n // process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n // function for create_vtbl.\n fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n-                       ty_params: &ast::ty_param[]) -> ValueRef {\n+                       ty_params: &[ast::ty_param]) -> ValueRef {\n \n     let llfnty = T_nil();\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n@@ -6911,11 +6911,11 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n-               ob: &ast::_obj, ty_params: &ast::ty_param[],\n+               ob: &ast::_obj, ty_params: &[ast::ty_param],\n                inner_obj_ty: option::t[ty::t],\n-               additional_field_tys: &ty::t[]) -> ValueRef {\n+               additional_field_tys: &[ty::t]) -> ValueRef {\n \n-    let llmethods: ValueRef[] = ~[];\n+    let llmethods: [ValueRef] = ~[];\n \n     alt inner_obj_ty {\n       none. {\n@@ -6945,7 +6945,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         // original methods onto the list of methods we need forwarding\n         // methods for.\n \n-        let meths: vtbl_mthd[] = ~[];\n+        let meths: [vtbl_mthd] = ~[];\n \n         // Gather up methods on the original object in 'meths'.\n         alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n@@ -7012,8 +7012,8 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n     // object, and it needs to forward them to the corresponding slots on the\n     // outer object.  All we know about either one are their types.\n \n-    let llmethods: ValueRef[] = ~[];\n-    let meths: ty::method[]= ~[];\n+    let llmethods: [ValueRef] = ~[];\n+    let meths: [ty::method]= ~[];\n \n     // Gather up methods on the inner object.\n     alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n@@ -7055,7 +7055,7 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n // trans_obj: creates an LLVM function that is the object constructor for the\n // object being translated.\n fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n-             ctor_id: ast::node_id, ty_params: &ast::ty_param[]) {\n+             ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n     // To make a function, we have to create a function context and, inside\n     // that, a number of block contexts for which code is generated.\n \n@@ -7072,7 +7072,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // The fields of our object will become the arguments to the function\n     // we're creating.\n \n-    let fn_args: ast::arg[] = ~[];\n+    let fn_args: [ast::arg] = ~[];\n     for f: ast::obj_field  in ob.fields {\n         fn_args +=\n             ~[{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n@@ -7083,7 +7083,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n-    let arg_tys: ty::arg[] = arg_tys_of_fn(ccx, ctor_id);\n+    let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     //  Create the first block context in the function and keep a handle on it\n@@ -7138,14 +7138,14 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     } else {\n         // Otherwise, we have to synthesize a big structural type for the\n         // object body.\n-        let obj_fields: ty::t[] = ~[];\n+        let obj_fields: [ty::t] = ~[];\n         for a: ty::arg  in arg_tys { obj_fields += ~[a.ty]; }\n \n         // Tuple type for fields: [field, ...]\n         let fields_ty: ty::t = ty::mk_imm_tup(ccx.tcx, obj_fields);\n \n         let tydesc_ty = ty::mk_type(ccx.tcx);\n-        let tps: ty::t[] = ~[];\n+        let tps: [ty::t] = ~[];\n         for tp: ast::ty_param  in ty_params { tps += ~[tydesc_ty]; }\n \n         // Tuple type for typarams: [typaram, ...]\n@@ -7237,7 +7237,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n }\n \n fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n-                  ctor_id: ast::node_id, ty_params: &ast::ty_param[]) {\n+                  ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n     // Create a function for the constructor\n     let llctor_decl;\n     alt cx.ccx.item_ids.find(ctor_id) {\n@@ -7277,14 +7277,14 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n \n fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                      variant: &ast::variant, index: int, is_degen: bool,\n-                     ty_params: &ast::ty_param[]) {\n+                     ty_params: &[ast::ty_param]) {\n     if std::ivec::len[ast::variant_arg](variant.node.args) == 0u {\n         ret; // nullary constructors are just constants\n \n     }\n     // Translate variant arguments to function arguments.\n \n-    let fn_args: ast::arg[] = ~[];\n+    let fn_args: [ast::arg] = ~[];\n     let i = 0u;\n     for varg: ast::variant_arg  in variant.node.args {\n         fn_args +=\n@@ -7306,7 +7306,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty::t],\n                               ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n                               fn_args, ty_params);\n-    let ty_param_substs: ty::t[] = ~[];\n+    let ty_param_substs: [ty::t] = ~[];\n     i = 0u;\n     for tp: ast::ty_param  in ty_params {\n         ty_param_substs += ~[ty::mk_param(cx.ccx.tcx, i, tp.kind)];\n@@ -7459,14 +7459,14 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[], flav: str,\n-                    ty_params: &ast::ty_param[], node_id: ast::node_id) {\n+fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str], flav: str,\n+                    ty_params: &[ast::ty_param], node_id: ast::node_id) {\n     decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id,\n                           node_id_type(ccx, node_id));\n }\n \n-fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &str[],\n-                         flav: str, ty_params: &ast::ty_param[],\n+fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n+                         flav: str, ty_params: &[ast::ty_param],\n                          node_id: ast::node_id, node_type: ty::t) {\n     let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n                                    std::ivec::len(ty_params));\n@@ -7573,7 +7573,7 @@ fn native_fn_wrapper_type(cx: &@crate_ctxt, sp: &span, ty_param_count: uint,\n     }\n }\n \n-fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[],\n+fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n                            name: str, id: ast::node_id) {\n     let num_ty_param = native_fn_ty_param_count(ccx, id);\n     // Declare the wrapper.\n@@ -7640,7 +7640,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[],\n         lltaskptr = vp2i(bcx, fcx.lltaskptr);\n     } else { lltaskptr = fcx.lltaskptr; }\n \n-    let call_args: ValueRef[] = ~[];\n+    let call_args: [ValueRef] = ~[];\n     if pass_task { call_args += ~[lltaskptr]; }\n     if uses_retptr { call_args += ~[bcx.fcx.llretptr]; }\n \n@@ -7674,10 +7674,10 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[],\n     }\n \n     fn trans_simple_native_abi(bcx: &@block_ctxt, name: str,\n-                               call_args: &mutable ValueRef[], fn_type: ty::t,\n+                               call_args: &mutable [ValueRef], fn_type: ty::t,\n                                first_arg_n: uint, uses_retptr: bool, cc: uint)\n        -> {val: ValueRef, rptr: ValueRef} {\n-        let call_arg_tys: TypeRef[] = ~[];\n+        let call_arg_tys: [TypeRef] = ~[];\n         for arg: ValueRef  in call_args { call_arg_tys += ~[val_ty(arg)]; }\n \n         let llnativefnty;\n@@ -7704,7 +7704,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[],\n     let args = ty::ty_fn_args(ccx.tcx, fn_type);\n     // Build up the list of arguments.\n \n-    let drop_args: {val: ValueRef, ty: ty::t}[] = ~[];\n+    let drop_args: [{val: ValueRef, ty: ty::t}] = ~[];\n     let i = arg_n;\n     for arg: ty::arg  in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n@@ -7765,10 +7765,10 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &str[],\n     finish_fn(fcx, lltop);\n }\n \n-fn item_path(item: &@ast::item) -> str[] { ret ~[item.ident]; }\n+fn item_path(item: &@ast::item) -> [str] { ret ~[item.ident]; }\n \n-fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &str[],\n-                       v: &vt[str[]]) {\n+fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[str],\n+                       v: &vt[[str]]) {\n     alt i.node {\n       ast::native_item_fn(_, _, _) {\n         if !ccx.obj_methods.contains_key(i.id) {\n@@ -7779,8 +7779,8 @@ fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &str[],\n     }\n }\n \n-fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &str[],\n-                  v: &vt[str[]]) {\n+fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n+                  v: &vt[[str]]) {\n     visit::visit_item(i, pt + item_path(i), v);\n     alt i.node {\n       ast::item_const(_, _) {\n@@ -7798,8 +7798,8 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &str[],\n     }\n }\n \n-fn collect_item_2(ccx: &@crate_ctxt, i: &@ast::item, pt: &str[],\n-                  v: &vt[str[]]) {\n+fn collect_item_2(ccx: &@crate_ctxt, i: &@ast::item, pt: &[str],\n+                  v: &vt[[str]]) {\n     let new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n@@ -7838,8 +7838,8 @@ fn collect_items(ccx: &@crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, ~[], visit::mk_vt(visitor2));\n }\n \n-fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &str[],\n-                    v: &vt[str[]]) {\n+fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n+                    v: &vt[[str]]) {\n     let new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n@@ -7864,8 +7864,8 @@ fn collect_tag_ctors(ccx: &@crate_ctxt, crate: @ast::crate) {\n \n \n // The constant translation pass.\n-fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &str[],\n-                  v: &vt[str[]]) {\n+fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n+                  v: &vt[[str]]) {\n     let new_pt = pt + item_path(it);\n     visit::visit_item(it, new_pt, v);\n     alt it.node {\n@@ -7913,15 +7913,15 @@ fn i2p(v: ValueRef, t: TypeRef) -> ValueRef {\n }\n \n fn declare_intrinsics(llmod: ModuleRef) -> hashmap[str, ValueRef] {\n-    let T_memmove32_args: TypeRef[] =\n+    let T_memmove32_args: [TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n-    let T_memmove64_args: TypeRef[] =\n+    let T_memmove64_args: [TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i64(), T_i32(), T_i1()];\n-    let T_memset32_args: TypeRef[] =\n+    let T_memset32_args: [TypeRef] =\n         ~[T_ptr(T_i8()), T_i8(), T_i32(), T_i32(), T_i1()];\n-    let T_memset64_args: TypeRef[] =\n+    let T_memset64_args: [TypeRef] =\n         ~[T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()];\n-    let T_trap_args: TypeRef[] = ~[];\n+    let T_trap_args: [TypeRef] = ~[];\n     let memmove32 =\n         decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n                       T_fn(T_memmove32_args, T_void()));\n@@ -7958,7 +7958,7 @@ fn trace_ptr(cx: &@block_ctxt, v: ValueRef) {\n }\n \n fn trap(bcx: &@block_ctxt) {\n-    let v: ValueRef[] = ~[];\n+    let v: [ValueRef] = ~[];\n     alt bcx_ccx(bcx).intrinsics.find(\"llvm.trap\") {\n       some(x) { bcx.build.Call(x, v); }\n       _ { bcx_ccx(bcx).sess.bug(\"unbound llvm.trap in trap\"); }\n@@ -8019,7 +8019,7 @@ fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(\"_rust_mod_map\"));\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    let elts: ValueRef[] = ~[];\n+    let elts: [ValueRef] = ~[];\n     for each item: @{key: str, val: ValueRef}  in ccx.module_data.items() {\n         let elt = C_struct(~[p2i(C_cstr(ccx, item.key)), p2i(item.val)]);\n         elts += ~[elt];\n@@ -8033,7 +8033,7 @@ fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n \n // FIXME use hashed metadata instead of crate names once we have that\n fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n-    let subcrates: ValueRef[] = ~[];\n+    let subcrates: [ValueRef] = ~[];\n     let i = 1;\n     let cstore = ccx.sess.get_cstore();\n     while cstore::have_crate_data(cstore, i) {"}, {"sha": "f15922a20fe2af456e4aa0e54cf70e2dee03c693", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -53,10 +53,10 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n     fail;\n }\n \n-type bind_map = {ident: ast::ident, val: ValueRef}[];\n+type bind_map = [{ident: ast::ident, val: ValueRef}];\n type match_branch =\n-    @{pats: (@ast::pat)[], body: BasicBlockRef, mutable bound: bind_map};\n-type match = match_branch[];\n+    @{pats: [@ast::pat], body: BasicBlockRef, mutable bound: bind_map};\n+type match = [match_branch];\n \n fn matches_always(p: &@ast::pat) -> bool {\n     ret alt p.node {\n@@ -75,7 +75,7 @@ fn bind_for_pat(p: &@ast::pat, br: &match_branch, val: ValueRef) {\n     }\n }\n \n-type enter_pat = fn(&@ast::pat) -> option::t[(@ast::pat)[]] ;\n+type enter_pat = fn(&@ast::pat) -> option::t[[@ast::pat]] ;\n \n fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n     let result = ~[];\n@@ -96,7 +96,7 @@ fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n }\n \n fn enter_default(m: &match, col: uint, val: ValueRef) -> match {\n-    fn e(p: &@ast::pat) -> option::t[(@ast::pat)[]] {\n+    fn e(p: &@ast::pat) -> option::t[[@ast::pat]] {\n         ret if matches_always(p) { some(~[]) } else { none };\n     }\n     ret enter_match(m, col, val, e);\n@@ -106,7 +106,7 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n              tag_size: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n     fn e(ccx: &@crate_ctxt, dummy: &@ast::pat, opt: &opt, size: uint,\n-         p: &@ast::pat) -> option::t[(@ast::pat)[]] {\n+         p: &@ast::pat) -> option::t[[@ast::pat]] {\n         alt p.node {\n           ast::pat_tag(ctor, subpats) {\n             ret if opt_eq(variant_opt(ccx, p.id), opt) {\n@@ -122,11 +122,11 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n     ret enter_match(m, col, val, bind e(ccx, dummy, opt, tag_size, _));\n }\n \n-fn enter_rec(m: &match, col: uint, fields: &ast::ident[], val: ValueRef) ->\n+fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n    match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n-    fn e(dummy: &@ast::pat, fields: &ast::ident[], p: &@ast::pat) ->\n-       option::t[(@ast::pat)[]] {\n+    fn e(dummy: &@ast::pat, fields: &[ast::ident], p: &@ast::pat) ->\n+       option::t[[@ast::pat]] {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let pats = ~[];\n@@ -147,7 +147,7 @@ fn enter_rec(m: &match, col: uint, fields: &ast::ident[], val: ValueRef) ->\n \n fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: {lo: 0u, hi: 0u}};\n-    fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t[(@ast::pat)[]] {\n+    fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t[[@ast::pat]] {\n         alt p.node {\n           ast::pat_box(sub) { ret some(~[sub]); }\n           _ { ret some(~[dummy]); }\n@@ -156,8 +156,8 @@ fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n     ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n-fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> opt[] {\n-    fn add_to_set(set: &mutable opt[], val: &opt) {\n+fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> [opt] {\n+    fn add_to_set(set: &mutable [opt], val: &opt) {\n         for l: opt  in set { if opt_eq(l, val) { ret; } }\n         set += ~[val];\n     }\n@@ -177,7 +177,7 @@ fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> opt[] {\n \n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n                         vdefs: &{tg: def_id, var: def_id}, val: ValueRef)\n-    -> {vals: ValueRef[], bcx: @block_ctxt} {\n+    -> {vals: [ValueRef], bcx: @block_ctxt} {\n     let ccx = bcx.fcx.lcx.ccx;\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n@@ -203,7 +203,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     ret {vals: args, bcx: bcx};\n }\n \n-fn collect_record_fields(m: &match, col: uint) -> ast::ident[] {\n+fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n     let fields = ~[];\n     for br: match_branch  in m {\n         alt br.pats.(col).node {\n@@ -260,8 +260,8 @@ fn pick_col(m: &match) -> uint {\n     ret best_col;\n }\n \n-fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n-                    f: &mk_fail, exits: &mutable exit_node[]) {\n+fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n+                    f: &mk_fail, exits: &mutable [exit_node]) {\n     if ivec::len(m) == 0u { bcx.build.Br(f()); ret; }\n     if ivec::len(m.(0).pats) == 0u {\n         exits += ~[{bound: m.(0).bound, from: bcx.llbb, to: m.(0).body}];\n@@ -391,7 +391,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n }\n \n // Returns false for unreachable blocks\n-fn make_phi_bindings(bcx: &@block_ctxt, map: &exit_node[],\n+fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n                      ids: &ast::pat_id_map) -> bool {\n     fn assoc(key: str, list: &bind_map) -> option::t[ValueRef] {\n         for elt: {ident: ast::ident, val: ValueRef}  in list {\n@@ -421,7 +421,7 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &exit_node[],\n     ret success;\n }\n \n-fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &ast::arm[],\n+fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n              id: ast::node_id, output: &trans::out_method) -> result {\n     let bodies = ~[];\n     let match: match = ~[];"}, {"sha": "6891b28f01003ac57f4ef0c9fc0f1c7c8942138e", "filename": "src/comp/middle/trans_comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -63,7 +63,7 @@ fn trans_chan(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n }\n \n fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n-               func: &@ast::expr, args: &(@ast::expr)[], id: ast::node_id) ->\n+               func: &@ast::expr, args: &[@ast::expr], id: ast::node_id) ->\n    result {\n     let bcx = cx;\n     // Make the task name\n@@ -107,8 +107,8 @@ fn trans_spawn(cx: &@block_ctxt, dom: &ast::spawn_dom, name: &option::t[str],\n     // Translate the arguments, remembering their types and where the values\n     // ended up.\n \n-    let arg_tys: ty::t[] = ~[];\n-    let arg_vals: ValueRef[] = ~[];\n+    let arg_tys: [ty::t] = ~[];\n+    let arg_vals: [ValueRef] = ~[];\n     for e: @ast::expr  in args {\n         let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n         let arg = trans_expr(bcx, e);\n@@ -168,7 +168,7 @@ fn mk_spawn_wrapper(cx: &@block_ctxt, func: &@ast::expr, args_ty: &ty::t) ->\n     // 3u to skip the three implicit args\n \n     let arg: ValueRef = llvm::LLVMGetParam(fcx.llfn, 3u);\n-    let child_args: ValueRef[] =\n+    let child_args: [ValueRef] =\n         ~[llvm::LLVMGetParam(fcx.llfn, 0u), llvm::LLVMGetParam(fcx.llfn, 1u),\n           llvm::LLVMGetParam(fcx.llfn, 2u)];\n     // unpack the arguments"}, {"sha": "e006802704280e0b95acf5aea648057f339d3bc1", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -79,7 +79,7 @@ type tydesc_info =\n      mutable drop_glue: option::t[ValueRef],\n      mutable free_glue: option::t[ValueRef],\n      mutable cmp_glue: option::t[ValueRef],\n-     ty_params: uint[]};\n+     ty_params: [uint]};\n \n /*\n  * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n@@ -102,7 +102,7 @@ type stats =\n      mutable n_glues_created: uint,\n      mutable n_null_glues: uint,\n      mutable n_real_glues: uint,\n-     fn_times: @mutable {ident: str, time: int}[]};\n+     fn_times: @mutable [{ident: str, time: int}]};\n \n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt = {\n@@ -146,10 +146,10 @@ type crate_ctxt = {\n };\n \n type local_ctxt =\n-    {path: str[],\n-     module_path: str[],\n-     obj_typarams: ast::ty_param[],\n-     obj_fields: ast::obj_field[],\n+    {path: [str],\n+     module_path: [str],\n+     obj_typarams: [ast::ty_param],\n+     obj_fields: [ast::obj_field],\n      ccx: @crate_ctxt};\n \n // Types used for llself.\n@@ -252,7 +252,7 @@ type fn_ctxt = {\n     // this functions type parameters, fetched via llvm::LLVMGetParam.\n     // For example, for a function foo[A, B, C](), lltydescs contains\n     // the ValueRefs for the tydescs for A, B, and C.\n-    mutable lltydescs: ValueRef[],\n+    mutable lltydescs: [ValueRef],\n \n     // Derived tydescs are tydescs created at runtime, for types that\n     // involve type parameters inside type constructors.  For example,\n@@ -386,7 +386,7 @@ type block_ctxt = {\n     // A list of functions that run at the end of translating this\n     // block, cleaning up any variables that were introduced in the\n     // block and need to go out of scope at the end of it.\n-    mutable cleanups: cleanup[],\n+    mutable cleanups: [cleanup],\n \n     // The source span where this block comes from, for error\n     // reporting.\n@@ -508,7 +508,7 @@ fn T_size_t() -> TypeRef {\n     ret T_i32();\n }\n \n-fn T_fn(inputs: &TypeRef[], output: TypeRef) -> TypeRef {\n+fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n     ret llvm::LLVMFunctionType(output, std::ivec::to_ptr(inputs),\n                                std::ivec::len[TypeRef](inputs), False);\n }\n@@ -519,7 +519,7 @@ fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n-fn T_struct(elts: &TypeRef[]) -> TypeRef {\n+fn T_struct(elts: &[TypeRef]) -> TypeRef {\n     ret llvm::LLVMStructType(std::ivec::to_ptr(elts), std::ivec::len(elts),\n                              False);\n }\n@@ -529,7 +529,7 @@ fn T_named_struct(name: &str) -> TypeRef {\n     ret llvm::LLVMStructCreateNamed(c, str::buf(name));\n }\n \n-fn set_struct_body(t: TypeRef, elts: &TypeRef[]) {\n+fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n     llvm::LLVMStructSetBody(t, std::ivec::to_ptr(elts), std::ivec::len(elts),\n                             False);\n }\n@@ -569,7 +569,7 @@ fn T_task() -> TypeRef {\n fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n-    let tydesc_elts: TypeRef[] =\n+    let tydesc_elts: [TypeRef] =\n         std::ivec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     std::ivec::to_ptr[TypeRef](tydesc_elts));\n@@ -843,33 +843,33 @@ fn C_postr(s: &str) -> ValueRef {\n \n fn C_zero_byte_arr(size: uint) -> ValueRef {\n     let i = 0u;\n-    let elts: ValueRef[] = ~[];\n+    let elts: [ValueRef] = ~[];\n     while i < size { elts += ~[C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), std::ivec::to_ptr(elts),\n                              std::ivec::len(elts));\n }\n \n-fn C_struct(elts: &ValueRef[]) -> ValueRef {\n+fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     ret llvm::LLVMConstStruct(std::ivec::to_ptr(elts), std::ivec::len(elts),\n                               False);\n }\n \n-fn C_named_struct(T: TypeRef, elts: &ValueRef[]) -> ValueRef {\n+fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     ret llvm::LLVMConstNamedStruct(T, std::ivec::to_ptr(elts),\n                                    std::ivec::len(elts));\n }\n \n-fn C_array(ty: TypeRef, elts: &ValueRef[]) -> ValueRef {\n+fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n                              std::ivec::len(elts));\n }\n \n-fn C_bytes(bytes : &u8[]) -> ValueRef {\n+fn C_bytes(bytes : &[u8]) -> ValueRef {\n     ret llvm::LLVMConstString(unsafe::reinterpret_cast(ivec::to_ptr(bytes)),\n                               ivec::len(bytes), False);\n }\n \n-fn C_shape(ccx : &@crate_ctxt, bytes : &u8[]) -> ValueRef {\n+fn C_shape(ccx : &@crate_ctxt, bytes : &[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n     let llglobal = llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape),\n                                        str::buf(ccx.names.next(\"shape\")));"}, {"sha": "4c50f5780c0fe661511e2b3bb4803ce74b7726af", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -23,11 +23,11 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(e: &@expr, rs: @mutable node_id[]) { *rs += ~[e.id]; }\n+fn collect_ids_expr(e: &@expr, rs: @mutable [node_id]) { *rs += ~[e.id]; }\n \n-fn collect_ids_block(b: &blk, rs: @mutable node_id[]) { *rs += ~[b.node.id]; }\n+fn collect_ids_block(b: &blk, rs: @mutable [node_id]) { *rs += ~[b.node.id]; }\n \n-fn collect_ids_stmt(s: &@stmt, rs: @mutable node_id[]) {\n+fn collect_ids_stmt(s: &@stmt, rs: @mutable [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) {\n         log \"node_id \" + int::str(id);\n@@ -43,12 +43,12 @@ fn collect_ids_stmt(s: &@stmt, rs: @mutable node_id[]) {\n     }\n }\n \n-fn collect_ids_local(l: &@local, rs: @mutable node_id[]) {\n+fn collect_ids_local(l: &@local, rs: @mutable [node_id]) {\n     *rs += pat_binding_ids(l.node.pat);\n }\n \n-fn node_ids_in_fn(f: &_fn, tps: &ty_param[], sp: &span, i: &fn_ident,\n-                  id: node_id, rs: @mutable node_id[]) {\n+fn node_ids_in_fn(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n+                  id: node_id, rs: @mutable [node_id]) {\n     let collect_ids =\n         visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n                                    visit_block: bind collect_ids_block(_, rs),\n@@ -58,22 +58,22 @@ fn node_ids_in_fn(f: &_fn, tps: &ty_param[], sp: &span, i: &fn_ident,\n     visit::visit_fn(f, tps, sp, i, id, (), collect_ids);\n }\n \n-fn init_vecs(ccx: &crate_ctxt, node_ids: &node_id[], len: uint) {\n+fn init_vecs(ccx: &crate_ctxt, node_ids: &[node_id], len: uint) {\n     for i: node_id  in node_ids {\n         log int::str(i) + \" |-> \" + uint::str(len);\n         add_node(ccx, i, empty_ann(len));\n     }\n }\n \n fn visit_fn(ccx: &crate_ctxt, num_constraints: uint, f: &_fn,\n-            tps: &ty_param[], sp: &span, i: &fn_ident, id: node_id) {\n-    let node_ids: @mutable node_id[] = @mutable ~[];\n+            tps: &[ty_param], sp: &span, i: &fn_ident, id: node_id) {\n+    let node_ids: @mutable [node_id] = @mutable ~[];\n     node_ids_in_fn(f, tps, sp, i, id, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(ccx: &crate_ctxt, f: &_fn, tps: &ty_param[], sp: &span,\n+fn annotate_in_fn(ccx: &crate_ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n                   i: &fn_ident, id: node_id) {\n     let f_info = get_fn_info(ccx, id);\n     visit_fn(ccx, num_constraints(f_info), f, tps, sp, i, id);"}, {"sha": "10b5f9605302345e15543c7fc973a11077482193", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -58,7 +58,7 @@ fn def_id_to_str(d: def_id) -> str {\n     ret int::str(d.crate) + \",\" + int::str(d.node);\n }\n \n-fn comma_str(args: &(@constr_arg_use)[]) -> str {\n+fn comma_str(args: &[@constr_arg_use]) -> str {\n     let rslt = \"\";\n     let comma = false;\n     for a: @constr_arg_use  in args {\n@@ -117,7 +117,7 @@ fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n \n fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(v: &uint[]) -> str {\n+fn tos(v: &[uint]) -> str {\n     let rslt = \"\";\n     for i: uint  in v {\n         if i == 0u {\n@@ -127,9 +127,9 @@ fn tos(v: &uint[]) -> str {\n     ret rslt;\n }\n \n-fn log_cond(v: &uint[]) { log tos(v); }\n+fn log_cond(v: &[uint]) { log tos(v); }\n \n-fn log_cond_err(v: &uint[]) { log_err tos(v); }\n+fn log_cond_err(v: &[uint]) { log_err tos(v); }\n \n fn log_pp(pp: &pre_and_post) {\n     let p1 = tritv::to_vec(pp.precondition);\n@@ -169,7 +169,7 @@ fn log_states_err(pp: &pre_and_post_state) {\n \n fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n \n-fn print_idents(idents: &mutable ident[]) {\n+fn print_idents(idents: &mutable [ident]) {\n     if ivec::len[ident](idents) == 0u { ret; }\n     log \"an ident: \" + ivec::pop[ident](idents);\n     print_idents(idents);\n@@ -206,7 +206,7 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n-type pred_args_ = {args: (@constr_arg_use)[], bit_num: uint};\n+type pred_args_ = {args: [@constr_arg_use], bit_num: uint};\n \n type pred_args = spanned[pred_args_];\n \n@@ -219,7 +219,7 @@ tag constraint {\n \n     // FIXME: really only want it to be mutable during collect_locals.\n     // freeze it after that.\n-    cpred(path, @mutable pred_args[]);\n+    cpred(path, @mutable [pred_args]);\n }\n \n // An ninit variant has a node_id because it refers to a local var.\n@@ -229,7 +229,7 @@ tag constraint {\n // and give ninit a constraint saying it's local.\n tag tsconstr {\n     ninit(node_id, ident);\n-    npred(path, def_id, (@constr_arg_use)[]);\n+    npred(path, def_id, [@constr_arg_use]);\n }\n \n type sp_constr = spanned[tsconstr];\n@@ -278,7 +278,7 @@ type fn_info =\n      computation, of all local variables that may be\n      used */\n // Doesn't seem to work without the @ -- bug\n-     used_vars: @mutable node_id[]};\n+     used_vars: @mutable [node_id]};\n \n fn tsconstr_to_def_id(t: &tsconstr) -> def_id {\n     alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n@@ -291,7 +291,7 @@ fn tsconstr_to_node_id(t: &tsconstr) -> node_id {\n }\n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mutable ts_ann[mutable ];\n+type node_ann_table = @mutable [mutable ts_ann];\n \n \n /* mapping from function name to fn_info map */\n@@ -507,7 +507,7 @@ fn pure_exp(ccx: &crate_ctxt, id: node_id, p: &prestate) -> bool {\n fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n-    let na: ts_ann[mutable ] = ~[mutable ];\n+    let na: [mutable ts_ann] = ~[mutable];\n     ret {tcx: cx, node_anns: @mutable na, fm: @new_int_hash[fn_info]()};\n }\n \n@@ -521,7 +521,7 @@ fn controlflow_expr(ccx: &crate_ctxt, e: @expr) -> controlflow {\n     }\n }\n \n-fn constraints_expr(cx: &ty::ctxt, e: @expr) -> (@ty::constr)[] {\n+fn constraints_expr(cx: &ty::ctxt, e: @expr) -> [@ty::constr] {\n     alt ty::struct(cx, ty::node_id_to_type(cx, e.id)) {\n       ty::ty_fn(_, _, _, _, cs) { ret cs; }\n       _ { ret ~[]; }\n@@ -554,13 +554,13 @@ fn node_id_to_def_upvar(cx: &fn_ctxt, id: node_id) -> option::t[def] {\n     ret freevars::def_lookup(cx.ccx.tcx, cx.id, id);\n }\n \n-fn norm_a_constraint(id: def_id, c: &constraint) -> norm_constraint[] {\n+fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n     alt c {\n       cinit(n, sp, i) {\n         ret ~[{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n       }\n       cpred(p, descs) {\n-        let rslt: norm_constraint[] = ~[];\n+        let rslt: [norm_constraint] = ~[];\n         for pd: pred_args  in *descs {\n             rslt +=\n                 ~[{bit_num: pd.node.bit_num,\n@@ -574,8 +574,8 @@ fn norm_a_constraint(id: def_id, c: &constraint) -> norm_constraint[] {\n \n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n-fn constraints(fcx: &fn_ctxt) -> norm_constraint[] {\n-    let rslt: norm_constraint[] = ~[];\n+fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n+    let rslt: [norm_constraint] = ~[];\n     for each p: @{key: def_id, val: constraint}  in\n              fcx.enclosing.constrs.items() {\n         rslt += norm_a_constraint(p.key, p.val);\n@@ -586,8 +586,8 @@ fn constraints(fcx: &fn_ctxt) -> norm_constraint[] {\n // FIXME\n // Would rather take an immutable vec as an argument,\n // should freeze it at some earlier point.\n-fn match_args(fcx: &fn_ctxt, occs: &@mutable pred_args[],\n-              occ: &(@constr_arg_use)[]) -> uint {\n+fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n+              occ: &[@constr_arg_use]) -> uint {\n     log \"match_args: looking at \" +\n             constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, occ);\n     for pd: pred_args  in *occs {\n@@ -638,10 +638,10 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n     }\n }\n \n-fn exprs_to_constr_args(tcx: ty::ctxt, args: &(@expr)[]) ->\n-   (@constr_arg_use)[] {\n+fn exprs_to_constr_args(tcx: ty::ctxt, args: &[@expr]) ->\n+   [@constr_arg_use] {\n     let f = bind expr_to_constr_arg(tcx, _);\n-    let rslt: (@constr_arg_use)[] = ~[];\n+    let rslt: [@constr_arg_use] = ~[];\n     for e: @expr  in args { rslt += ~[f(e)]; }\n     rslt\n }\n@@ -679,16 +679,16 @@ fn pred_args_to_str(p: &pred_args) -> str {\n         + \">\"\n }\n \n-fn substitute_constr_args(cx: &ty::ctxt, actuals: &(@expr)[], c: &@ty::constr)\n+fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n    -> tsconstr {\n-    let rslt: (@constr_arg_use)[] = ~[];\n+    let rslt: [@constr_arg_use] = ~[];\n     for a: @constr_arg  in c.node.args {\n         rslt += ~[substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, c.node.id, rslt);\n }\n \n-fn substitute_arg(cx: &ty::ctxt, actuals: &(@expr)[], a: @constr_arg) ->\n+fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n    @constr_arg_use {\n     let num_actuals = ivec::len(actuals);\n     alt a.node {\n@@ -704,7 +704,7 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &(@expr)[], a: @constr_arg) ->\n     }\n }\n \n-fn pred_args_matches(pattern: &(constr_arg_general_[inst])[],\n+fn pred_args_matches(pattern: &[constr_arg_general_[inst]],\n                      desc: &pred_args) -> bool {\n     let i = 0u;\n     for c: @constr_arg_use  in desc.node.args {\n@@ -729,19 +729,19 @@ fn pred_args_matches(pattern: &(constr_arg_general_[inst])[],\n     ret true;\n }\n \n-fn find_instance_(pattern: &(constr_arg_general_[inst])[],\n-                  descs: &pred_args[]) -> option::t[uint] {\n+fn find_instance_(pattern: &[constr_arg_general_[inst]],\n+                  descs: &[pred_args]) -> option::t[uint] {\n     for d: pred_args  in descs {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n     ret none;\n }\n \n type inst = {ident: ident, node: node_id};\n-type subst = {from: inst, to: inst}[];\n+type subst = [{from: inst, to: inst}];\n \n fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n-   {from: uint, to: uint}[] {\n+   [{from: uint, to: uint}] {\n \n     let rslt = ~[];\n     if ivec::len(subst) == 0u { ret rslt; }\n@@ -775,7 +775,7 @@ fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(stuff: &(constr_arg_general_[inst])[]) -> str {\n+fn insts_to_str(stuff: &[constr_arg_general_[inst]]) -> str {\n     let rslt = \"<\";\n     for i: constr_arg_general_[inst]  in stuff {\n         rslt +=\n@@ -790,8 +790,8 @@ fn insts_to_str(stuff: &(constr_arg_general_[inst])[]) -> str {\n     rslt\n }\n \n-fn replace(subst: subst, d: pred_args) -> (constr_arg_general_[inst])[] {\n-    let rslt: (constr_arg_general_[inst])[] = ~[];\n+fn replace(subst: subst, d: pred_args) -> [constr_arg_general_[inst]] {\n+    let rslt: [constr_arg_general_[inst]] = ~[];\n     for c: @constr_arg_use  in d.node.args {\n         alt c.node {\n           carg_ident(p) {\n@@ -991,7 +991,7 @@ fn forget_in_poststate_still_init(fcx: &fn_ctxt, p: &poststate,\n     ret changed;\n }\n \n-fn any_eq(v: &node_id[], d: node_id) -> bool {\n+fn any_eq(v: &[node_id], d: node_id) -> bool {\n     for i: node_id  in v { if i == d { ret true; } }\n     false\n }\n@@ -1012,13 +1012,13 @@ fn non_init_constraint_mentions(fcx: &fn_ctxt, c: &norm_constraint,\n         };\n }\n \n-fn args_mention[T](args: &(@constr_arg_use)[], q: fn(&T[], node_id) -> bool ,\n-                   s: &T[]) -> bool {\n+fn args_mention[T](args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n+                   s: &[T]) -> bool {\n     /*\n       FIXME\n       The following version causes an assertion in trans to fail\n       (something about type_is_tup_like)\n-    fn mentions[T](&(T)[] s, &fn(&(T)[], def_id) -> bool q,\n+    fn mentions[T](&[T] s, &fn(&[T], def_id) -> bool q,\n                             &@constr_arg_use a) -> bool {\n         alt (a.node) {\n             case (carg_ident(?p1)) {\n@@ -1041,7 +1041,7 @@ fn args_mention[T](args: &(@constr_arg_use)[], q: fn(&T[], node_id) -> bool ,\n fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += ~[v]; }\n \n // FIXME: This should be a function in std::ivec::.\n-fn vec_contains(v: &@mutable node_id[], i: &node_id) -> bool {\n+fn vec_contains(v: &@mutable [node_id], i: &node_id) -> bool {\n     for d: node_id  in *v { if d == i { ret true; } }\n     ret false;\n }\n@@ -1051,33 +1051,33 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n }\n \n // default function visitor\n-fn do_nothing[T](f: &_fn, tp: &ty_param[], sp: &span, i: &fn_ident,\n+fn do_nothing[T](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident,\n                  iid: node_id, cx: &T, v: &visit::vt[T]) {\n }\n \n \n-fn args_to_constr_args(sp: &span, args: &arg[]) -> (@constr_arg_use)[] {\n-    let actuals: (@constr_arg_use)[] = ~[];\n+fn args_to_constr_args(sp: &span, args: &[arg]) -> [@constr_arg_use] {\n+    let actuals: [@constr_arg_use] = ~[];\n     for a: arg  in args {\n         actuals += ~[@respan(sp, carg_ident({ident: a.ident, node: a.id}))];\n     }\n     ret actuals;\n }\n \n-fn ast_constr_to_ts_constr(tcx: &ty::ctxt, args: &arg[], c: &@constr) ->\n+fn ast_constr_to_ts_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n    tsconstr {\n     let tconstr = ty::ast_constr_to_constr(tcx, c);\n     ret npred(tconstr.node.path, tconstr.node.id,\n               args_to_constr_args(tconstr.span, args));\n }\n \n-fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &arg[], c: &@constr) ->\n+fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n    sp_constr {\n     let tconstr = ast_constr_to_ts_constr(tcx, args, c);\n     ret respan(c.span, tconstr);\n }\n \n-type binding = {lhs: inst[], rhs: option::t[initializer]};\n+type binding = {lhs: [inst], rhs: option::t[initializer]};\n \n fn local_to_bindings(loc : &@local) -> binding {\n     let lhs = ~[];\n@@ -1089,11 +1089,11 @@ fn local_to_bindings(loc : &@local) -> binding {\n      rhs: loc.node.init}\n }\n \n-fn locals_to_bindings(locals : &(@local)[]) -> binding[] {\n+fn locals_to_bindings(locals : &[@local]) -> [binding] {\n     ivec::map(local_to_bindings, locals)\n }\n \n-fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> ty::mode[] {\n+fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n     let ty = ty::type_autoderef(fcx.ccx.tcx,\n                                 ty::node_id_to_type(fcx.ccx.tcx, callee));\n     alt ty::struct(fcx.ccx.tcx, ty) {\n@@ -1113,7 +1113,7 @@ fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> ty::mode[] {\n    }\n }\n \n-fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> init_op[] {\n+fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> [init_op] {\n     fn mode_to_op(m: &ty::mode) -> init_op {\n         alt m {\n           ty::mo_move. { init_move }\n@@ -1123,8 +1123,8 @@ fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> init_op[] {\n     ivec::map(mode_to_op, callee_modes(fcx, callee))\n }\n \n-fn anon_bindings(ops: &init_op[], es : &(@expr)[]) -> binding[] {\n-    let bindings: binding[] = ~[];\n+fn anon_bindings(ops: &[init_op], es : &[@expr]) -> [binding] {\n+    let bindings: [binding] = ~[];\n     let i = 0;\n     for op: init_op in ops {\n         bindings += ~[{lhs: ~[],"}, {"sha": "3f4a80c01c39e88d8ffee020453cf34808666ef6", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -76,7 +76,7 @@ fn seq_tritv(p: &postcond, q: &postcond) {\n     }\n }\n \n-fn seq_postconds(fcx: &fn_ctxt, ps: &postcond[]) -> postcond {\n+fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n     let sz = ivec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps.(0));\n@@ -89,11 +89,11 @@ fn seq_postconds(fcx: &fn_ctxt, ps: &postcond[]) -> postcond {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(fcx: &fn_ctxt, pps: &pre_and_post[]) -> precond {\n+fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n     let sz: uint = ivec::len(pps);\n     let num_vars: uint = num_constraints(fcx.enclosing);\n \n-    fn seq_preconds_go(fcx: &fn_ctxt, pps: &pre_and_post[],\n+    fn seq_preconds_go(fcx: &fn_ctxt, pps: &[pre_and_post],\n                        first: &pre_and_post) -> precond {\n         let sz: uint = ivec::len(pps);\n         if sz >= 1u {"}, {"sha": "94c2d5c625f9c7724cada1f6d77343112b38d1c4", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -125,7 +125,7 @@ fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt[fn_ctxt]) {\n }\n \n fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n-                                   tps: &ast::ty_param[], id: node_id,\n+                                   tps: &[ast::ty_param], id: node_id,\n                                    sp: &span, i: &fn_ident) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n@@ -170,7 +170,7 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n     check_unused_vars(fcx);\n }\n \n-fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &ast::ty_param[], id: node_id,\n+fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &[ast::ty_param], id: node_id,\n                    sp: &span, i: &fn_ident) {\n     /* Compute the pre- and post-states for this function */\n \n@@ -183,7 +183,7 @@ fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &ast::ty_param[], id: node_id,\n     check_states_against_conditions(fcx, f, tps, id, sp, i);\n }\n \n-fn fn_states(f: &_fn, tps: &ast::ty_param[], sp: &span, i: &fn_ident,\n+fn fn_states(f: &_fn, tps: &[ast::ty_param], sp: &span, i: &fn_ident,\n              id: node_id, ccx: &crate_ctxt, v: &visit::vt[crate_ctxt]) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */"}, {"sha": "f60745d596a223d18480e6f241863cd1af8c9d76", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -11,7 +11,7 @@ import util::common::new_def_hash;\n import syntax::codemap::span;\n import syntax::ast::respan;\n \n-type ctxt = {cs: @mutable sp_constr[], tcx: ty::ctxt};\n+type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt[ctxt]) {\n     for each p: @pat in pat_bindings(loc.node.pat) {\n@@ -43,7 +43,7 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt[ctxt]) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &ty_param[], sp: &span,\n+fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n                i: &fn_ident, id: node_id) -> ctxt {\n     let cx: ctxt = {cs: @mutable ~[], tcx: tcx};\n     let visitor = visit::default_visitor[ctxt]();\n@@ -75,7 +75,7 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n             }\n           }\n           none. {\n-            let rslt: @mutable pred_args[] =\n+            let rslt: @mutable [pred_args] =\n                 @mutable ~[respan(c.span, {args: args, bit_num: next})];\n             tbl.insert(d_id, cpred(p, rslt));\n           }\n@@ -88,7 +88,7 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &ty_param[], f_sp: &span,\n+fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n               f_name: &fn_ident, id: node_id) {\n     let name = fn_ident_to_string(id, f_name);\n     let res_map = @new_def_hash[constraint]();\n@@ -122,7 +122,7 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &ty_param[], f_sp: &span,\n     add_constraint(cx.tcx, respan(f_sp, ninit(diverges_id, diverges_name)),\n                    next, res_map);\n \n-    let v: @mutable node_id[] = @mutable ~[];\n+    let v: @mutable [node_id] = @mutable ~[];\n     let rslt =\n         {constrs: res_map,\n          num_constraints:"}, {"sha": "b4b78933e897904c95f2c55e8fb0491a6b96da57", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -73,7 +73,7 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n     alt i.node {\n       item_const(_, e) {\n         // make a fake fcx\n-        let v: @mutable node_id[] = @mutable ~[];\n+        let v: @mutable [node_id] = @mutable ~[];\n         let fake_fcx =\n             {enclosing:\n                  {constrs: @new_def_hash[constraint](),\n@@ -115,7 +115,7 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(fcx: &fn_ctxt, args: &(@expr)[], id: node_id) {\n+fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n     if ivec::len[@expr](args) > 0u {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n@@ -692,7 +692,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n     let do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n \n-    let pps: pre_and_post[] = ~[];\n+    let pps: [pre_and_post] = ~[];\n     for s: @stmt  in b.node.stmts { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n     alt b.node.expr {\n       none. {/* no-op */ }\n@@ -732,7 +732,7 @@ fn find_pre_post_fn(fcx: &fn_ctxt, f: &_fn) {\n     }\n }\n \n-fn fn_pre_post(f: &_fn, tps: &ty_param[], sp: &span, i: &fn_ident,\n+fn fn_pre_post(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n                id: node_id, ccx: &crate_ctxt, v: &visit::vt[crate_ctxt]) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     assert (ccx.fm.contains_key(id));"}, {"sha": "e1ceb06252425ee908d02fbed3ba9b95ddbd28be", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -47,7 +47,7 @@ fn handle_move_or_copy(fcx: &fn_ctxt, post: &poststate, rhs_path: &path,\n     }\n }\n \n-fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &binding[])\n+fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding])\n     -> {changed: bool, post: poststate} {\n     let changed = false;\n     let post = tritv_clone(pres);\n@@ -163,7 +163,7 @@ fn find_pre_post_state_two(fcx: &fn_ctxt, pres: &prestate, lhs: &@expr,\n }\n \n fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n-                            id: node_id, ops: &init_op[], bs: &(@expr)[],\n+                            id: node_id, ops: &[init_op], bs: &[@expr],\n                             cf: controlflow) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, a);\n     if ivec::len(bs) != ivec::len(ops) {\n@@ -178,7 +178,7 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n }\n \n fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n-                             ops: &init_op[], es: &(@expr)[],\n+                             ops: &[init_op], es: &[@expr],\n                              cf: controlflow) -> bool {\n     let rs = seq_states(fcx, pres, anon_bindings(ops, es));\n     let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);"}, {"sha": "998e20e19a3c90d447c9ee25d4fce30335a5e8b6", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -239,9 +239,9 @@ fn tritv_doesntcare(v: &t) -> bool {\n     ret true;\n }\n \n-fn to_vec(v: &t) -> uint[] {\n+fn to_vec(v: &t) -> [uint] {\n     let i: uint = 0u;\n-    let rslt: uint[] = ~[];\n+    let rslt: [uint] = ~[];\n     while i < v.nbits {\n         rslt +=\n             ~[alt tritv_get(v, i) {"}, {"sha": "7a7bea34b8dac9f7d6b67bcc32331a0645bc141f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -197,12 +197,12 @@ type field = {ident: ast::ident, mt: mt};\n type method =\n     {proto: ast::proto,\n      ident: ast::ident,\n-     inputs: arg[],\n+     inputs: [arg],\n      output: t,\n      cf: controlflow,\n-     constrs: (@constr)[]};\n+     constrs: [@constr]};\n \n-type constr_table = hashmap[ast::node_id, constr[]];\n+type constr_table = hashmap[ast::node_id, [constr]];\n \n type mt = {ty: t, mut: ast::mutability};\n \n@@ -263,26 +263,26 @@ tag sty {\n     ty_char;\n     ty_str;\n     ty_istr;\n-    ty_tag(def_id, t[]);\n+    ty_tag(def_id, [t]);\n     ty_box(mt);\n     ty_vec(mt);\n     ty_ivec(mt);\n     ty_ptr(mt);\n     ty_port(t);\n     ty_chan(t);\n     ty_task;\n-    ty_rec(field[]);\n-    ty_fn(ast::proto, arg[], t, controlflow, (@constr)[]);\n-    ty_native_fn(ast::native_abi, arg[], t);\n-    ty_obj(method[]);\n-    ty_res(def_id, t, t[]);\n+    ty_rec([field]);\n+    ty_fn(ast::proto, [arg], t, controlflow, [@constr]);\n+    ty_native_fn(ast::native_abi, [arg], t);\n+    ty_obj([method]);\n+    ty_res(def_id, t, [t]);\n     ty_var(int); // type variable\n \n     ty_param(uint, ast::kind); // fn/tag type param\n \n     ty_type;\n     ty_native(def_id);\n-    ty_constr(t, (@type_constr)[]);\n+    ty_constr(t, [@type_constr]);\n     // TODO: ty_fn_arg(t), for a possibly-aliased function argument\n }\n \n@@ -309,7 +309,7 @@ tag type_err {\n     terr_constr_mismatch(@type_constr, @type_constr);\n }\n \n-type ty_param_kinds_and_ty = {kinds: ast::kind[], ty: t};\n+type ty_param_kinds_and_ty = {kinds: [ast::kind], ty: t};\n \n type type_cache = hashmap[ast::def_id, ty_param_kinds_and_ty];\n \n@@ -359,7 +359,7 @@ const idx_first_others: uint = 21u;\n \n type type_store = interner::interner[@raw_t];\n \n-type ty_param_substs_opt_and_ty = {substs: option::t[ty::t[]], ty: ty::t};\n+type ty_param_substs_opt_and_ty = {substs: option::t[[ty::t]], ty: ty::t};\n \n type node_type_table =\n     @smallintmap::smallintmap[ty::ty_param_substs_opt_and_ty];\n@@ -447,7 +447,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n         derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n     fn derive_flags_sig(cx: &ctxt, has_params: &mutable bool,\n-                        has_vars: &mutable bool, args: &arg[], tt: &t) {\n+                        has_vars: &mutable bool, args: &[arg], tt: &t) {\n         for a: arg  in args { derive_flags_arg(cx, has_params, has_vars, a); }\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n@@ -552,7 +552,7 @@ fn mk_str(cx: &ctxt) -> t { ret idx_str; }\n \n fn mk_istr(cx: &ctxt) -> t { ret idx_istr; }\n \n-fn mk_tag(cx: &ctxt, did: &ast::def_id, tys: &t[]) -> t {\n+fn mk_tag(cx: &ctxt, did: &ast::def_id, tys: &[t]) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n }\n \n@@ -582,9 +582,9 @@ fn mk_chan(cx: &ctxt, ty: &t) -> t { ret gen_ty(cx, ty_chan(ty)); }\n \n fn mk_task(cx: &ctxt) -> t { ret gen_ty(cx, ty_task); }\n \n-fn mk_rec(cx: &ctxt, fs: &field[]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n+fn mk_rec(cx: &ctxt, fs: &[field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_imm_tup(cx: &ctxt, tys: &t[]) -> t {\n+fn mk_imm_tup(cx: &ctxt, tys: &[t]) -> t {\n     let fields = ~[];\n     let i = 0u;\n     for typ: t  in tys {\n@@ -594,22 +594,22 @@ fn mk_imm_tup(cx: &ctxt, tys: &t[]) -> t {\n     ret gen_ty(cx, ty_rec(fields));\n }\n \n-fn mk_constr(cx: &ctxt, t: &t, cs: &(@type_constr)[]) -> t {\n+fn mk_constr(cx: &ctxt, t: &t, cs: &[@type_constr]) -> t {\n     ret gen_ty(cx, ty_constr(t, cs));\n }\n \n-fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &arg[], ty: &t,\n-         cf: &controlflow, constrs: &(@constr)[]) -> t {\n+fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: &t,\n+         cf: &controlflow, constrs: &[@constr]) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n-fn mk_native_fn(cx: &ctxt, abi: &ast::native_abi, args: &arg[], ty: &t) -> t {\n+fn mk_native_fn(cx: &ctxt, abi: &ast::native_abi, args: &[arg], ty: &t) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(cx: &ctxt, meths: &method[]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n+fn mk_obj(cx: &ctxt, meths: &[method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n \n-fn mk_res(cx: &ctxt, did: &ast::def_id, inner: &t, tps: &t[]) -> t {\n+fn mk_res(cx: &ctxt, did: &ast::def_id, inner: &t, tps: &[t]) -> t {\n     ret gen_ty(cx, ty_res(did, inner, tps));\n }\n \n@@ -759,12 +759,12 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = copy_cname(cx, mk_chan(cx, fold_ty(cx, fld, subty)), ty);\n       }\n       ty_tag(tid, subtys) {\n-        let new_subtys: t[] = ~[];\n+        let new_subtys: [t] = ~[];\n         for subty: t  in subtys { new_subtys += ~[fold_ty(cx, fld, subty)]; }\n         ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n       }\n       ty_rec(fields) {\n-        let new_fields: field[] = ~[];\n+        let new_fields: [field] = ~[];\n         for fl: field  in fields {\n             let new_ty = fold_ty(cx, fld, fl.mt.ty);\n             let new_mt = {ty: new_ty, mut: fl.mt.mut};\n@@ -773,7 +773,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n       }\n       ty_fn(proto, args, ret_ty, cf, constrs) {\n-        let new_args: arg[] = ~[];\n+        let new_args: [arg] = ~[];\n         for a: arg  in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += ~[{mode: a.mode, ty: new_ty}];\n@@ -784,7 +784,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n                              cf, constrs), ty);\n       }\n       ty_native_fn(abi, args, ret_ty) {\n-        let new_args: arg[] = ~[];\n+        let new_args: [arg] = ~[];\n         for a: arg  in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += ~[{mode: a.mode, ty: new_ty}];\n@@ -795,9 +795,9 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n                                     fold_ty(cx, fld, ret_ty)), ty);\n       }\n       ty_obj(methods) {\n-        let new_methods: method[] = ~[];\n+        let new_methods: [method] = ~[];\n         for m: method  in methods {\n-            let new_args: arg[] = ~[];\n+            let new_args: [arg] = ~[];\n             for a: arg  in m.inputs {\n                 new_args += ~[{mode: a.mode, ty: fold_ty(cx, fld, a.ty)}];\n             }\n@@ -1401,16 +1401,16 @@ fn type_param(cx: &ctxt, ty: &t) -> option::t[uint] {\n \n // Returns an ivec of all the type variables\n // occurring in t. It may contain duplicates.\n-fn vars_in_type(cx:&ctxt, ty: &t) -> int[] {\n-    fn collect_var(cx:&ctxt, vars: &@mutable int[], ty: t) {\n+fn vars_in_type(cx:&ctxt, ty: &t) -> [int] {\n+    fn collect_var(cx:&ctxt, vars: &@mutable [int], ty: t) {\n         alt struct(cx, ty) {\n           ty_var(v) {\n             *vars += ~[v];\n           }\n           _ {}\n         }\n     }\n-    let rslt: @mutable int[] = @mutable (~[]);\n+    let rslt: @mutable [int] = @mutable (~[]);\n     walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n     // Works because of a \"convenient\" bug that lets us\n     // return a mutable ivec as if it's immutable\n@@ -1463,7 +1463,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         h += h << 5u + hash_def(h, c.node.id);\n         ret hash_type_constr_args(h, c.node.args);\n     }\n-    fn hash_type_constr_args(id: uint, args: (@ty_constr_arg)[]) -> uint {\n+    fn hash_type_constr_args(id: uint, args: [@ty_constr_arg]) -> uint {\n         let h = id;\n         for a: @ty_constr_arg  in args {\n             alt a.node {\n@@ -1482,7 +1482,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n \n \n-    fn hash_fn(id: uint, args: &arg[], rty: &t) -> uint {\n+    fn hash_fn(id: uint, args: &[arg], rty: &t) -> uint {\n         let h = id;\n         for a: arg  in args { h += h << 5u + hash_ty(a.ty); }\n         h += h << 5u + hash_ty(rty);\n@@ -1590,8 +1590,8 @@ fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg[T],\n     }\n }\n \n-fn args_eq[T](eq: fn(&T, &T) -> bool , a: &(@sp_constr_arg[T])[],\n-              b: &(@sp_constr_arg[T])[]) -> bool {\n+fn args_eq[T](eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg[T]],\n+              b: &[@sp_constr_arg[T]]) -> bool {\n     let i: uint = 0u;\n     for arg: @sp_constr_arg[T]  in a {\n         if !arg_eq(eq, arg, b.(i)) { ret false; }\n@@ -1606,7 +1606,7 @@ fn constr_eq(c: &@constr, d: &@constr) -> bool {\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(cs: &(@constr)[], ds: &(@constr)[]) -> bool {\n+fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n     if ivec::len(cs) != ivec::len(ds) { ret false; }\n     let i = 0u;\n     for c: @constr  in cs { if !constr_eq(c, ds.(i)) { ret false; } i += 1u; }\n@@ -1617,7 +1617,7 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n     fn equal_mt(a: &mt, b: &mt) -> bool {\n         ret a.mut == b.mut && eq_ty(a.ty, b.ty);\n     }\n-    fn equal_fn(args_a: &arg[], rty_a: &t, args_b: &arg[], rty_b: &t) ->\n+    fn equal_fn(args_a: &[arg], rty_a: &t, args_b: &[arg], rty_b: &t) ->\n        bool {\n         if !eq_ty(rty_a, rty_b) { ret false; }\n         let len = ivec::len[arg](args_a);\n@@ -1832,7 +1832,7 @@ fn node_id_to_type(cx: &ctxt, id: &ast::node_id) -> t {\n     ret node_id_to_ty_param_substs_opt_and_ty(cx, id).ty;\n }\n \n-fn node_id_to_type_params(cx: &ctxt, id: &ast::node_id) -> t[] {\n+fn node_id_to_type_params(cx: &ctxt, id: &ast::node_id) -> [t] {\n     alt node_id_to_ty_param_substs_opt_and_ty(cx, id).substs {\n       none. { ret ~[]; }\n       some(tps) { ret tps; }\n@@ -1865,7 +1865,7 @@ fn node_id_to_monotype(cx: &ctxt, id: ast::node_id) -> t {\n \n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n-    fn counter(cx: &ctxt, param_indices: @mutable uint[], ty: t) {\n+    fn counter(cx: &ctxt, param_indices: @mutable [uint], ty: t) {\n         alt struct(cx, ty) {\n           ty_param(param_idx,_) {\n             let seen = false;\n@@ -1877,7 +1877,7 @@ fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n           _ {/* fall through */ }\n         }\n     }\n-    let param_indices: @mutable uint[] = @mutable ~[];\n+    let param_indices: @mutable [uint] = @mutable ~[];\n     let f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n     ret ivec::len[uint](*param_indices);\n@@ -1893,7 +1893,7 @@ fn type_contains_params(cx: &ctxt, typ: &t) -> bool {\n \n \n // Type accessors for substructures of types\n-fn ty_fn_args(cx: &ctxt, fty: &t) -> arg[] {\n+fn ty_fn_args(cx: &ctxt, fty: &t) -> [arg] {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, a, _, _, _) { ret a; }\n       ty::ty_native_fn(_, a, _) { ret a; }\n@@ -1963,7 +1963,7 @@ fn expr_ty(cx: &ctxt, expr: &@ast::expr) -> t {\n }\n \n fn expr_ty_params_and_ty(cx: &ctxt, expr: &@ast::expr) ->\n-   {params: t[], ty: t} {\n+   {params: [t], ty: t} {\n     ret {params: node_id_to_type_params(cx, expr.id),\n          ty: node_id_to_type(cx, expr.id)};\n }\n@@ -1984,20 +1984,20 @@ fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n }\n \n fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n-             fields: &field[]) -> uint {\n+             fields: &[field]) -> uint {\n     let i: uint = 0u;\n     for f: field  in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n-              meths: &method[]) -> uint {\n+              meths: &[method]) -> uint {\n     let i: uint = 0u;\n     for m: method  in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n-fn sort_methods(meths: &method[]) -> method[] {\n+fn sort_methods(meths: &[method]) -> [method] {\n     fn method_lteq(a: &method, b: &method) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n@@ -2151,8 +2151,8 @@ mod unify {\n \n     // Right now this just checks that the lists of constraints are\n     // pairwise equal.\n-    fn unify_constrs(base_t: &t, expected: (@type_constr)[],\n-                     actual: &(@type_constr)[]) -> result {\n+    fn unify_constrs(base_t: &t, expected: [@type_constr],\n+                     actual: &[@type_constr]) -> result {\n         let expected_len = ivec::len(expected);\n         let actual_len = ivec::len(actual);\n \n@@ -2212,11 +2212,11 @@ mod unify {\n     }\n     tag fn_common_res {\n         fn_common_res_err(result);\n-        fn_common_res_ok(arg[], t);\n+        fn_common_res_ok([arg], t);\n     }\n     fn unify_fn_common(cx: &@ctxt, expected: &t, actual: &t,\n-                       expected_inputs: &arg[], expected_output: &t,\n-                       actual_inputs: &arg[], actual_output: &t) ->\n+                       expected_inputs: &[arg], expected_output: &t,\n+                       actual_inputs: &[arg], actual_output: &t) ->\n        fn_common_res {\n         let expected_len = ivec::len[arg](expected_inputs);\n         let actual_len = ivec::len[arg](actual_inputs);\n@@ -2225,7 +2225,7 @@ mod unify {\n         }\n         // TODO: as above, we should have an iter2 iterator.\n \n-        let result_ins: arg[] = ~[];\n+        let result_ins: [arg] = ~[];\n         let i = 0u;\n         while i < expected_len {\n             let expected_input = expected_inputs.(i);\n@@ -2254,10 +2254,10 @@ mod unify {\n         }\n     }\n     fn unify_fn(cx: &@ctxt, e_proto: &ast::proto, a_proto: &ast::proto,\n-                expected: &t, actual: &t, expected_inputs: &arg[],\n-                expected_output: &t, actual_inputs: &arg[], actual_output: &t,\n+                expected: &t, actual: &t, expected_inputs: &[arg],\n+                expected_output: &t, actual_inputs: &[arg], actual_output: &t,\n                 expected_cf: &controlflow, actual_cf: &controlflow,\n-                expected_constrs: &(@constr)[], actual_constrs: &(@constr)[])\n+                expected_constrs: &[@constr], actual_constrs: &[@constr])\n        -> result {\n         if e_proto != a_proto { ret ures_err(terr_mismatch); }\n         alt expected_cf {\n@@ -2296,8 +2296,8 @@ mod unify {\n     }\n     fn unify_native_fn(cx: &@ctxt, e_abi: &ast::native_abi,\n                        a_abi: &ast::native_abi, expected: &t, actual: &t,\n-                       expected_inputs: &arg[], expected_output: &t,\n-                       actual_inputs: &arg[], actual_output: &t) -> result {\n+                       expected_inputs: &[arg], expected_output: &t,\n+                       actual_inputs: &[arg], actual_output: &t) -> result {\n         if e_abi != a_abi { ret ures_err(terr_mismatch); }\n         let t =\n             unify_fn_common(cx, expected, actual, expected_inputs,\n@@ -2311,9 +2311,9 @@ mod unify {\n         }\n     }\n     fn unify_obj(cx: &@ctxt, expected: &t, actual: &t,\n-                 expected_meths: &method[], actual_meths: &method[]) ->\n+                 expected_meths: &[method], actual_meths: &[method]) ->\n        result {\n-        let result_meths: method[] = ~[];\n+        let result_meths: [method] = ~[];\n         let i: uint = 0u;\n         let expected_len: uint = ivec::len[method](expected_meths);\n         let actual_len: uint = ivec::len[method](actual_meths);\n@@ -2455,7 +2455,7 @@ mod unify {\n                     ret ures_err(terr_mismatch);\n                 }\n                 // TODO: factor this cruft out\n-                let result_tps: t[] = ~[];\n+                let result_tps: [t] = ~[];\n                 let i = 0u;\n                 let expected_len = ivec::len[t](expected_tps);\n                 while i < expected_len {\n@@ -2621,7 +2621,7 @@ mod unify {\n                 // TODO: implement an iterator that can iterate over\n                 // two arrays simultaneously.\n \n-                let result_fields: field[] = ~[];\n+                let result_fields: [field] = ~[];\n                 let i = 0u;\n                 while i < expected_len {\n                     let expected_field = expected_fields.(i);\n@@ -2836,11 +2836,11 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n-                       typ: t, ty_param_count: uint) -> {ids: int[], ty: t} {\n-    let param_var_ids: @mutable int[] = @mutable ~[];\n+                       typ: t, ty_param_count: uint) -> {ids: [int], ty: t} {\n+    let param_var_ids: @mutable [int] = @mutable ~[];\n     let i = 0u;\n     while i < ty_param_count { *param_var_ids += ~[next_ty_var()]; i += 1u; }\n-    fn binder(sp: span, cx: ctxt, param_var_ids: @mutable int[],\n+    fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n               next_ty_var: fn() -> int , index: uint, kind: ast::kind) -> t {\n         if index < ivec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids.(index));\n@@ -2859,9 +2859,9 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n \n // Replaces type parameters in the given type using the given list of\n // substitions.\n-fn substitute_type_params(cx: &ctxt, substs: &ty::t[], typ: t) -> t {\n+fn substitute_type_params(cx: &ctxt, substs: &[ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n-    fn substituter(cx: ctxt, substs: @ty::t[], idx: uint,\n+    fn substituter(cx: ctxt, substs: @[ty::t], idx: uint,\n                    kind: ast::kind) -> t {\n         // FIXME: bounds check can fail\n         ret substs.(idx);\n@@ -2889,9 +2889,9 @@ fn def_has_ty_params(def: &ast::def) -> bool {\n \n \n // Tag information\n-type variant_info = {args: ty::t[], ctor_ty: ty::t, id: ast::def_id};\n+type variant_info = {args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n \n-fn tag_variants(cx: &ctxt, id: &ast::def_id) -> variant_info[] {\n+fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n     if ast::local_crate != id.crate { ret csearch::get_tag_variants(cx, id); }\n     let item =\n         alt cx.items.find(id.node) {\n@@ -2902,10 +2902,10 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> variant_info[] {\n       ast_map::node_item(item) {\n         alt item.node {\n           ast::item_tag(variants, _) {\n-            let result: variant_info[] = ~[];\n+            let result: [variant_info] = ~[];\n             for variant: ast::variant  in variants {\n                 let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n-                let arg_tys: t[] = ~[];\n+                let arg_tys: [t] = ~[];\n                 if std::ivec::len(variant.node.args) > 0u {\n                     for a: arg  in ty_fn_args(cx, ctor_ty) {\n                         arg_tys += ~[a.ty];"}, {"sha": "4ac3c866352c0fa67b7c5b1b7f16b0b312194739", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -54,13 +54,13 @@ type ty_table = hashmap[ast::def_id, ty::t];\n // Used for typechecking the methods of an object.\n tag obj_info {\n     // Regular objects have a node_id at compile time.\n-    regular_obj(ast::obj_field[], ast::node_id);\n+    regular_obj([ast::obj_field], ast::node_id);\n     // Anonymous objects only have a type at compile time.  It's optional\n     // because not all anonymous objects have a inner_obj to attach to.\n-    anon_obj(ast::obj_field[], option::t[ty::sty]);\n+    anon_obj([ast::obj_field], option::t[ty::sty]);\n }\n \n-type crate_ctxt = {mutable obj_infos: obj_info[], tcx: ty::ctxt};\n+type crate_ctxt = {mutable obj_infos: [obj_info], tcx: ty::ctxt};\n \n type fn_ctxt =\n     // var_bindings, locals, local_names, and next_var_id are shared\n@@ -73,7 +73,7 @@ type fn_ctxt =\n      locals: hashmap[ast::node_id, int],\n      local_names: hashmap[ast::node_id, ast::ident],\n      next_var_id: @mutable int,\n-     mutable fixups: ast::node_id[],\n+     mutable fixups: [ast::node_id],\n      ccx: @crate_ctxt};\n \n \n@@ -110,7 +110,7 @@ fn ident_for_local(loc: &@ast::local) -> ast::ident {\n // Returns the type parameter count and the type for the given definition.\n fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n    -> ty_param_kinds_and_ty {\n-    let no_kinds: ast::kind[] = ~[];\n+    let no_kinds: [ast::kind] = ~[];\n     alt defn {\n       ast::def_arg(id) {\n         assert (fcx.locals.contains_key(id.node));\n@@ -176,7 +176,7 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"not enough type parameters provided for this item\");\n         }\n-        let ty_substs: ty::t[] = ~[];\n+        let ty_substs: [ty::t] = ~[];\n         let i = 0u;\n         while i < ty_substs_len {\n             let ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i));\n@@ -185,21 +185,21 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n             ty_substs += ~[res_ty];\n             i += 1u;\n         }\n-        ty_substs_opt = some[ty::t[]](ty_substs);\n+        ty_substs_opt = some[[ty::t]](ty_substs);\n         if ty_param_count == 0u {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                         \"this item does not take type \\\n                                       parameters\");\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n-        let ty_substs: ty::t[] = ~[];\n+        let ty_substs: [ty::t] = ~[];\n         let i = 0u;\n         while i < ty_param_count {\n             ty_substs += ~[ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n             i += 1u;\n         }\n-        ty_substs_opt = some[ty::t[]](ty_substs);\n+        ty_substs_opt = some[[ty::t]](ty_substs);\n     }\n     ret {substs: ty_substs_opt, ty: tpt.ty};\n }\n@@ -281,7 +281,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         ret {ty: ast_ty_to_ty(tcx, getter, mt.ty), mut: mt.mut};\n     }\n     fn instantiate(tcx: &ty::ctxt, sp: &span, getter: &ty_getter,\n-                   id: &ast::def_id, args: &(@ast::ty)[]) -> ty::t {\n+                   id: &ast::def_id, args: &[@ast::ty]) -> ty::t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n \n@@ -292,7 +292,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         // The typedef is type-parametric. Do the type substitution.\n         //\n \n-        let param_bindings: ty::t[] = ~[];\n+        let param_bindings: [ty::t] = ~[];\n         for ast_ty: @ast::ty  in args {\n             param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n@@ -340,7 +340,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n       }\n       ast::ty_rec(fields) {\n-        let flds: field[] = ~[];\n+        let flds: [field] = ~[];\n         for f: ast::ty_field  in fields {\n             let tm = ast_mt_to_mt(tcx, getter, f.node.mt);\n             flds += ~[{ident: f.node.ident, mt: tm}];\n@@ -378,7 +378,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         cname = some(path_to_str(path));\n       }\n       ast::ty_obj(meths) {\n-        let tmeths: ty::method[] = ~[];\n+        let tmeths: [ty::method] = ~[];\n         for m: ast::ty_method  in meths {\n             let ins = ~[];\n             for ta: ast::ty_arg  in m.node.inputs {\n@@ -457,23 +457,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(tcx: &ty::ctxt, node_id: ast::node_id, typ: ty::t) {\n-        ty(tcx, node_id, {substs: none[ty::t[]], ty: typ});\n+        ty(tcx, node_id, {substs: none[[ty::t]], ty: typ});\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(fcx: @fn_ctxt, node_id: ast::node_id, typ: ty::t) {\n-        ret ty_fixup(fcx, node_id, {substs: none[ty::t[]], ty: typ});\n+        ret ty_fixup(fcx, node_id, {substs: none[[ty::t]], ty: typ});\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(tcx: &ty::ctxt, node_id: ast::node_id) {\n-        ret ty(tcx, node_id, {substs: none[ty::t[]], ty: ty::mk_nil(tcx)});\n+        ret ty(tcx, node_id, {substs: none[[ty::t]], ty: ty::mk_nil(tcx)});\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(tcx: &ty::ctxt, node_id: ast::node_id) {\n-        ret ty(tcx, node_id, {substs: none[ty::t[]], ty: ty::mk_bot(tcx)});\n+        ret ty(tcx, node_id, {substs: none[[ty::t]], ty: ty::mk_bot(tcx)});\n     }\n }\n \n@@ -504,7 +504,7 @@ fn proto_to_ty_proto(proto: &ast::proto) -> ast::proto {\n mod collect {\n     type ctxt = {tcx: ty::ctxt};\n \n-    fn mk_ty_params(cx: &@ctxt, atps: &ast::ty_param[]) -> ty::t[] {\n+    fn mk_ty_params(cx: &@ctxt, atps: &[ast::ty_param]) -> [ty::t] {\n         let tps = ~[];\n         let i = 0u;\n         for atp: ast::ty_param in atps {\n@@ -514,8 +514,8 @@ mod collect {\n         ret tps;\n     }\n \n-    fn ty_param_kinds(tps: &ast::ty_param[]) -> ast::kind[] {\n-        let k: ast::kind[] = ~[];\n+    fn ty_param_kinds(tps: &[ast::ty_param]) -> [ast::kind] {\n+        let k: [ast::kind] = ~[];\n         for p: ast::ty_param in tps {\n             k += ~[p.kind]\n         }\n@@ -524,7 +524,7 @@ mod collect {\n \n     fn ty_of_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n                      ty_of_arg: &fn(&ast::arg) -> arg , decl: &ast::fn_decl,\n-                     proto: ast::proto, ty_params: &ast::ty_param[],\n+                     proto: ast::proto, ty_params: &[ast::ty_param],\n                      def_id: &option::t[ast::def_id]) ->\n        ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n@@ -545,7 +545,7 @@ mod collect {\n     fn ty_of_native_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n                             ty_of_arg: &fn(&ast::arg) -> arg ,\n                             decl: &ast::fn_decl, abi: ast::native_abi,\n-                            ty_params: &ast::ty_param[], def_id: &ast::def_id)\n+                            ty_params: &[ast::ty_param], def_id: &ast::def_id)\n        -> ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n         for a: ast::arg  in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n@@ -611,18 +611,18 @@ mod collect {\n              constrs: out_constrs};\n     }\n     fn ty_of_obj(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n-                 ty_params: &ast::ty_param[]) -> ty::ty_param_kinds_and_ty {\n+                 ty_params: &[ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n         let methods = get_obj_method_types(cx, ob);\n         let t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n         ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n     }\n     fn ty_of_obj_ctor(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n-                      ctor_id: ast::node_id, ty_params: &ast::ty_param[]) ->\n+                      ctor_id: ast::node_id, ty_params: &[ast::ty_param]) ->\n        ty::ty_param_kinds_and_ty {\n         let t_obj = ty_of_obj(cx, id, ob, ty_params);\n \n-        let t_inputs: arg[] = ~[];\n+        let t_inputs: [arg] = ~[];\n         for f: ast::obj_field  in ob.fields {\n             let g = bind getter(cx, _);\n             let t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n@@ -639,7 +639,7 @@ mod collect {\n     fn ty_of_item(cx: &@ctxt, it: &@ast::item) -> ty::ty_param_kinds_and_ty {\n         let get = bind getter(cx, _);\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n-        let no_kinds: ast::kind[] = ~[];\n+        let no_kinds: [ast::kind] = ~[];\n         alt it.node {\n           ast::item_const(t, _) {\n             let typ = convert(t);\n@@ -682,7 +682,7 @@ mod collect {\n           }\n           ast::item_tag(_, tps) {\n             // Create a new generic polytype.\n-            let subtys: ty::t[] = mk_ty_params(cx, tps);\n+            let subtys: [ty::t] = mk_ty_params(cx, tps);\n             let t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n             let tpt = {kinds: ty_param_kinds(tps), ty: t};\n             cx.tcx.tcache.insert(local_def(it.id), tpt);\n@@ -694,7 +694,7 @@ mod collect {\n     }\n     fn ty_of_native_item(cx: &@ctxt, it: &@ast::native_item,\n                          abi: ast::native_abi) -> ty::ty_param_kinds_and_ty {\n-        let no_kinds: ast::kind[] = ~[];\n+        let no_kinds: [ast::kind] = ~[];\n         alt it.node {\n           ast::native_item_fn(_, fn_decl, params) {\n             let get = bind getter(cx, _);\n@@ -716,11 +716,11 @@ mod collect {\n         }\n     }\n     fn get_tag_variant_types(cx: &@ctxt, tag_id: &ast::def_id,\n-                             variants: &ast::variant[],\n-                             ty_params: &ast::ty_param[]) {\n+                             variants: &[ast::variant],\n+                             ty_params: &[ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n \n-        let ty_param_tys: ty::t[] = mk_ty_params(cx, ty_params);\n+        let ty_param_tys: [ty::t] = mk_ty_params(cx, ty_params);\n         for variant: ast::variant  in variants {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n@@ -733,7 +733,7 @@ mod collect {\n                 // should be called to resolve named types.\n \n                 let f = bind getter(cx, _);\n-                let args: arg[] = ~[];\n+                let args: [arg] = ~[];\n                 for va: ast::variant_arg  in variant.node.args {\n                     let arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n                     args += ~[{mode: ty::mo_alias(false), ty: arg_ty}];\n@@ -749,7 +749,7 @@ mod collect {\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn get_obj_method_types(cx: &@ctxt, object: &ast::_obj) -> ty::method[] {\n+    fn get_obj_method_types(cx: &@ctxt, object: &ast::_obj) -> [ty::method] {\n         let meths = ~[];\n         for m: @ast::method  in object.methods {\n             meths += ~[ty_of_method(cx, m)];\n@@ -962,7 +962,7 @@ fn resolve_type_vars_if_possible(fcx: &@fn_ctxt, typ: ty::t) -> ty::t {\n \n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n-type ty_param_substs_and_ty = {substs: ty::t[], ty: ty::t};\n+type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n \n mod demand {\n     fn simple(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t) ->\n@@ -977,7 +977,7 @@ mod demand {\n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n     fn full(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t,\n-            ty_param_substs_0: &ty::t[], adk: autoderef_kind) ->\n+            ty_param_substs_0: &[ty::t], adk: autoderef_kind) ->\n        ty_param_substs_and_ty {\n         let expected_1 = expected;\n         let actual_1 = actual;\n@@ -989,8 +989,8 @@ mod demand {\n         } else if (adk == AUTODEREF_BLOCK_COERCE) {\n             actual_1 = do_fn_block_coerce(fcx, sp, actual, expected);\n         }\n-        let ty_param_substs: ty::t[mutable ] = ~[mutable ];\n-        let ty_param_subst_var_ids: int[] = ~[];\n+        let ty_param_substs: [mutable ty::t] = ~[mutable];\n+        let ty_param_subst_var_ids: [int] = ~[];\n         for ty_param_subst: ty::t  in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n@@ -1002,9 +1002,9 @@ mod demand {\n         }\n \n         fn mk_result(fcx: &@fn_ctxt, result_ty: &ty::t,\n-                     ty_param_subst_var_ids: &int[], implicit_boxes: uint) ->\n+                     ty_param_subst_var_ids: &[int], implicit_boxes: uint) ->\n            ty_param_substs_and_ty {\n-            let result_ty_param_substs: ty::t[] = ~[];\n+            let result_ty_param_substs: [ty::t] = ~[];\n             for var_id: int  in ty_param_subst_var_ids {\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += ~[tp_subst];\n@@ -1046,8 +1046,8 @@ fn are_compatible(fcx: &@fn_ctxt, expected: &ty::t, actual: &ty::t) -> bool {\n \n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(ccx: &@crate_ctxt, sp: &span, vid: &ast::def_id,\n-                     tag_ty_params: &ty::t[]) -> ty::t[] {\n-    let result: ty::t[] = ~[];\n+                     tag_ty_params: &[ty::t]) -> [ty::t] {\n+    let result: [ty::t] = ~[];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::struct(ccx.tcx, tpt.ty) {\n       ty::ty_fn(_, ins, _, _, _) {\n@@ -1107,16 +1107,16 @@ mod writeback {\n             };\n         let new_substs_opt;\n         alt tpot.substs {\n-          none[ty::t[]]. { new_substs_opt = none[ty::t[]]; }\n-          some[ty::t[]](substs) {\n-            let new_substs: ty::t[] = ~[];\n+          none[[ty::t]]. { new_substs_opt = none[[ty::t]]; }\n+          some[[ty::t]](substs) {\n+            let new_substs: [ty::t] = ~[];\n             for subst: ty::t  in substs {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n                   some(t) { new_substs += ~[t]; }\n                   none. { wbcx.success = false; ret; }\n                 }\n             }\n-            new_substs_opt = some[ty::t[]](new_substs);\n+            new_substs_opt = some[[ty::t]](new_substs);\n           }\n         }\n         write::ty(fcx.ccx.tcx, id, {substs: new_substs_opt, ty: new_ty});\n@@ -1296,7 +1296,7 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     };\n \n     // Don't descend into fns and items\n-    fn visit_fn[E](f: &ast::_fn, tp: &ast::ty_param[], sp: &span,\n+    fn visit_fn[E](f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n                    i: &ast::fn_ident, id: ast::node_id, e: &E,\n                    v: &visit::vt[E]) { }\n     fn visit_item[E](i: &@ast::item, e: &E, v: &visit::vt[E]) { }\n@@ -1373,7 +1373,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                 demand::full(fcx, pat.span, expected, ctor_ty, expected_tps,\n                              NO_AUTODEREF);\n             path_tpot =\n-                {substs: some[ty::t[]](path_tpt.substs), ty: path_tpt.ty};\n+                {substs: some[[ty::t]](path_tpt.substs), ty: path_tpt.ty};\n             // Get the number of arguments in this tag variant.\n \n             let arg_types =\n@@ -1517,7 +1517,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                          args: &(option::t[@ast::expr])[],\n+                          args: &[option::t[@ast::expr]],\n                           call_kind: call_kind) -> bool {\n         // Check the function.\n         let bot = check_expr(fcx, f);\n@@ -1612,8 +1612,8 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n \n     // A generic function for checking call expressions\n     fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                  args: &(@ast::expr)[], call_kind: call_kind) -> bool {\n-        let args_opt_0: (option::t[@ast::expr])[] = ~[];\n+                  args: &[@ast::expr], call_kind: call_kind) -> bool {\n+        let args_opt_0: [option::t[@ast::expr]] = ~[];\n         for arg: @ast::expr  in args {\n             args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n@@ -1624,7 +1624,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                       args: &(@ast::expr)[], call_kind: call_kind,\n+                       args: &[@ast::expr], call_kind: call_kind,\n                        id: ast::node_id) -> bool {\n         /* here we're kind of hosed, as f can be any expr\n         need to restrict it to being an explicit expr_path if we're\n@@ -2083,7 +2083,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n \n         // Pull the argument and return types out.\n         let proto_1;\n-        let arg_tys_1: ty::arg[] = ~[];\n+        let arg_tys_1: [ty::arg] = ~[];\n         let rt_1;\n         let fty = expr_ty(tcx, f);\n         let t_1;\n@@ -2229,7 +2229,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n       }\n       ast::expr_rec(fields, base) {\n         alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n-        let fields_t: (spanned[field])[] = ~[];\n+        let fields_t: [spanned[field]] = ~[];\n         for f: ast::field  in fields {\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n@@ -2249,7 +2249,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n           some(bexpr) {\n             bot |= check_expr(fcx, bexpr);\n             let bexpr_t = expr_ty(tcx, bexpr);\n-            let base_fields: field[] = ~[];\n+            let base_fields: [field] = ~[];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) { base_fields = flds; }\n               _ {\n@@ -2366,7 +2366,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         }\n       }\n       ast::expr_anon_obj(ao) {\n-        let fields: ast::anon_obj_field[] = ~[];\n+        let fields: [ast::anon_obj_field] = ~[];\n         alt ao.fields { none. { } some(v) { fields = v; } }\n \n         // FIXME: These next three functions are largely ripped off from\n@@ -2399,7 +2399,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                  constrs: out_constrs};\n         }\n \n-        let method_types: ty::method[] = ~[];\n+        let method_types: [ty::method] = ~[];\n         {\n             // Outer methods.\n             for m: @ast::method  in ao.methods {\n@@ -2410,7 +2410,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n \n             // Typecheck 'inner_obj'.  If it exists, it had better have object\n             // type.\n-            let inner_obj_methods: ty::method[] = ~[];\n+            let inner_obj_methods: [ty::method] = ~[];\n             let inner_obj_ty: ty::t = ty::mk_nil(tcx);\n             let inner_obj_sty: option::t[ty::sty] = none;\n             alt ao.inner_obj {\n@@ -2448,7 +2448,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n             // any methods that share a name with an outer method.\n             fn filtering_fn(ccx: @crate_ctxt,\n                             m: &ty::method,\n-                            outer_obj_methods: (@ast::method)[]) ->\n+                            outer_obj_methods: [@ast::method]) ->\n                 option::t[ty::method] {\n \n                 for om: @ast::method in outer_obj_methods {\n@@ -2623,7 +2623,7 @@ fn check_const(ccx: &@crate_ctxt, sp: &span, e: &@ast::expr,\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n     let rty = node_id_to_type(ccx.tcx, id);\n-    let fixups: ast::node_id[] = ~[];\n+    let fixups: [ast::node_id] = ~[];\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n@@ -2642,7 +2642,7 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     let decl = f.decl;\n     let body = f.body;\n     let gather_result = gather_locals(ccx, f, id, old_fcx);\n-    let fixups: ast::node_id[] = ~[];\n+    let fixups: [ast::node_id] = ~[];\n     let fcx: @fn_ctxt =\n         @{ret_ty: ast_ty_to_ty_crate(ccx, decl.output),\n           purity: decl.purity,\n@@ -2765,7 +2765,7 @@ fn check_for_main_fn(tcx: &ty::ctxt, crate: &@ast::crate) {\n fn check_crate(tcx: &ty::ctxt, crate: &@ast::crate) {\n     collect::collect_item_types(tcx, crate);\n \n-    let obj_infos: obj_info[] = ~[];\n+    let obj_infos: [obj_info] = ~[];\n \n     let ccx = @{mutable obj_infos: obj_infos, tcx: tcx};\n     let visit = visit::mk_simple_visitor"}, {"sha": "8c5669aac8efbf0cb9a7acbbbf624f9fccc10d12", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -16,13 +16,13 @@ type fn_ident = option::t[ident];\n // FIXME: with typestate constraint, could say\n // idents and types are the same length, and are\n // non-empty\n-type path_ = {global: bool, idents: ident[], types: (@ty)[]};\n+type path_ = {global: bool, idents: [ident], types: [@ty]};\n \n type path = spanned[path_];\n \n fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n \n-fn path_name_i(idents: &ident[]) -> str { str::connect_ivec(idents, \"::\") }\n+fn path_name_i(idents: &[ident]) -> str { str::connect_ivec(idents, \"::\") }\n \n type crate_num = int;\n type node_id = int;\n@@ -85,22 +85,22 @@ fn def_id_of_def(d: def) -> def_id {\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n-type crate_cfg = (@meta_item)[];\n+type crate_cfg = [@meta_item];\n \n type crate = spanned[crate_];\n \n type crate_ =\n-    {directives: (@crate_directive)[],\n+    {directives: [@crate_directive],\n      module: _mod,\n-     attrs: attribute[],\n+     attrs: [attribute],\n      config: crate_cfg};\n \n tag crate_directive_ {\n-    cdir_src_mod(ident, option::t[filename], attribute[]);\n+    cdir_src_mod(ident, option::t[filename], [attribute]);\n     cdir_dir_mod(ident,\n                  option::t[filename],\n-                 (@crate_directive)[],\n-                 attribute[]);\n+                 [@crate_directive],\n+                 [attribute]);\n     cdir_view_item(@view_item);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n@@ -112,13 +112,13 @@ type meta_item = spanned[meta_item_];\n \n tag meta_item_ {\n     meta_word(ident);\n-    meta_list(ident, (@meta_item)[]);\n+    meta_list(ident, [@meta_item]);\n     meta_name_value(ident, lit);\n }\n \n type blk = spanned[blk_];\n \n-type blk_ = {stmts: (@stmt)[], expr: option::t[@expr], id: node_id};\n+type blk_ = {stmts: [@stmt], expr: option::t[@expr], id: node_id};\n \n type pat = {id: node_id, node: pat_, span: span};\n \n@@ -128,8 +128,8 @@ tag pat_ {\n     pat_wild;\n     pat_bind(ident);\n     pat_lit(@lit);\n-    pat_tag(path, (@pat)[]);\n-    pat_rec(field_pat[], bool);\n+    pat_tag(path, [@pat]);\n+    pat_rec([field_pat], bool);\n     pat_box(@pat);\n }\n \n@@ -174,7 +174,7 @@ iter pat_bindings(pat: &@pat) -> @pat {\n     }\n }\n \n-fn pat_binding_ids(pat: &@pat) -> node_id[] {\n+fn pat_binding_ids(pat: &@pat) -> [node_id] {\n     let found = ~[];\n     for each b in pat_bindings(pat) { found += ~[b.id]; }\n     ret found;\n@@ -275,9 +275,9 @@ type local = spanned[local_];\n \n type decl = spanned[decl_];\n \n-tag decl_ { decl_local((@local)[]); decl_item(@item); }\n+tag decl_ { decl_local([@local]); decl_item(@item); }\n \n-type arm = {pats: (@pat)[], block: blk};\n+type arm = {pats: [@pat], block: blk};\n \n type elt = {mut: mutability, expr: @expr};\n \n@@ -295,12 +295,12 @@ tag seq_kind { sk_unique; sk_rc; }\n type expr = {id: node_id, node: expr_, span: span};\n \n tag expr_ {\n-    expr_vec((@expr)[], mutability, seq_kind);\n-    expr_rec(field[], option::t[@expr]);\n-    expr_call(@expr, (@expr)[]);\n+    expr_vec([@expr], mutability, seq_kind);\n+    expr_rec([field], option::t[@expr]);\n+    expr_call(@expr, [@expr]);\n     expr_self_method(ident);\n-    expr_bind(@expr, (option::t[@expr])[]);\n-    expr_spawn(spawn_dom, option::t[str], @expr, (@expr)[]);\n+    expr_bind(@expr, [option::t[@expr]]);\n+    expr_spawn(spawn_dom, option::t[str], @expr, [@expr]);\n     expr_binary(binop, @expr, @expr);\n     expr_unary(unop, @expr);\n     expr_lit(@lit);\n@@ -311,7 +311,7 @@ tag expr_ {\n     expr_for(@local, @expr, blk);\n     expr_for_each(@local, @expr, blk);\n     expr_do_while(blk, @expr);\n-    expr_alt(@expr, arm[]);\n+    expr_alt(@expr, [arm]);\n     expr_fn(_fn);\n     expr_block(blk);\n \n@@ -392,10 +392,10 @@ type ty_arg_ = {mode: mode, ty: @ty};\n type ty_method_ =\n     {proto: proto,\n      ident: ident,\n-     inputs: ty_arg[],\n+     inputs: [ty_arg],\n      output: @ty,\n      cf: controlflow,\n-     constrs: (@constr)[]};\n+     constrs: [@constr]};\n \n type ty_field = spanned[ty_field_];\n \n@@ -465,12 +465,12 @@ tag ty_ {\n     ty_task;\n     ty_port(@ty);\n     ty_chan(@ty);\n-    ty_rec(ty_field[]);\n-    ty_fn(proto, ty_arg[], @ty, controlflow, (@constr)[]);\n-    ty_obj(ty_method[]);\n+    ty_rec([ty_field]);\n+    ty_fn(proto, [ty_arg], @ty, controlflow, [@constr]);\n+    ty_obj([ty_method]);\n     ty_path(path, node_id);\n     ty_type;\n-    ty_constr(@ty, (@ty_constr)[]);\n+    ty_constr(@ty, [@ty_constr]);\n     ty_mac(mac);\n }\n \n@@ -496,7 +496,7 @@ type constr_arg = spanned[fn_constr_arg];\n // constrained type, is * (referring to the base record)\n \n type constr_general_[ARG, ID] =\n-    {path: path, args: (@spanned[constr_arg_general_[ARG]])[], id: ID};\n+    {path: path, args: [@spanned[constr_arg_general_[ARG]]], id: ID};\n \n // In the front end, constraints have a node ID attached.\n // Typeck turns this to a def_id, using the output of resolve.\n@@ -514,12 +514,12 @@ type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n tag inlineness { il_normal; il_inline; }\n \n type fn_decl =\n-    {inputs: arg[],\n+    {inputs: [arg],\n      output: @ty,\n      purity: purity,\n      il: inlineness,\n      cf: controlflow,\n-     constraints: (@constr)[]};\n+     constraints: [@constr]};\n \n tag purity {\n     pure_fn; // declared with \"pred\"\n@@ -550,16 +550,16 @@ type obj_field = {mut: mutability, ty: @ty, ident: ident, id: node_id};\n type anon_obj_field =\n     {mut: mutability, ty: @ty, expr: @expr, ident: ident, id: node_id};\n \n-type _obj = {fields: obj_field[], methods: (@method)[]};\n+type _obj = {fields: [obj_field], methods: [@method]};\n \n type anon_obj =\n     // New fields and methods, if they exist.\n-    {fields: option::t[anon_obj_field[]],\n-     methods: (@method)[],\n+    {fields: option::t[[anon_obj_field]],\n+     methods: [@method],\n      // inner_obj: the original object being extended, if it exists.\n      inner_obj: option::t[@expr]};\n \n-type _mod = {view_items: (@view_item)[], items: (@item)[]};\n+type _mod = {view_items: [@view_item], items: [@item]};\n \n tag native_abi {\n     native_abi_rust;\n@@ -572,21 +572,21 @@ tag native_abi {\n type native_mod =\n     {native_name: str,\n      abi: native_abi,\n-     view_items: (@view_item)[],\n-     items: (@native_item)[]};\n+     view_items: [@view_item],\n+     items: [@native_item]};\n \n type variant_arg = {ty: @ty, id: node_id};\n \n-type variant_ = {name: str, args: variant_arg[], id: node_id};\n+type variant_ = {name: str, args: [variant_arg], id: node_id};\n \n type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n \n tag view_item_ {\n-    view_item_use(ident, (@meta_item)[], node_id);\n-    view_item_import(ident, ident[], node_id);\n-    view_item_import_glob(ident[], node_id);\n+    view_item_use(ident, [@meta_item], node_id);\n+    view_item_import(ident, [ident], node_id);\n+    view_item_import_glob([ident], node_id);\n     view_item_export(ident, node_id);\n }\n \n@@ -605,32 +605,32 @@ tag attr_style { attr_outer; attr_inner; }\n type attribute_ = {style: attr_style, value: meta_item};\n \n type item =  // For objs and resources, this is the type def_id\n-    {ident: ident, attrs: attribute[], id: node_id, node: item_, span: span};\n+    {ident: ident, attrs: [attribute], id: node_id, node: item_, span: span};\n \n tag item_ {\n     item_const(@ty, @expr);\n-    item_fn(_fn, ty_param[]);\n+    item_fn(_fn, [ty_param]);\n     item_mod(_mod);\n     item_native_mod(native_mod);\n-    item_ty(@ty, ty_param[]);\n-    item_tag(variant[], ty_param[]);\n-    item_obj(_obj, ty_param[], /* constructor id */node_id);\n+    item_ty(@ty, [ty_param]);\n+    item_tag([variant], [ty_param]);\n+    item_obj(_obj, [ty_param], /* constructor id */node_id);\n     item_res(_fn, /* dtor */\n              node_id, /* dtor id */\n-             ty_param[],\n+             [ty_param],\n              node_id /* ctor id */);\n }\n \n type native_item =\n     {ident: ident,\n-     attrs: attribute[],\n+     attrs: [attribute],\n      node: native_item_,\n      id: node_id,\n      span: span};\n \n tag native_item_ {\n     native_item_ty;\n-    native_item_fn(option::t[str], fn_decl, ty_param[]);\n+    native_item_fn(option::t[str], fn_decl, [ty_param]);\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {"}, {"sha": "468e94255f0b7d8e378e81e11f3c52fa242e82be", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -17,9 +17,9 @@ type file_pos = {ch: uint, byte: uint};\n  * compiler.\n  */\n type filemap =\n-    @{name: filename, start_pos: file_pos, mutable lines: file_pos[]};\n+    @{name: filename, start_pos: file_pos, mutable lines: [file_pos]};\n \n-type codemap = @{mutable files: filemap[]};\n+type codemap = @{mutable files: [filemap]};\n \n type loc = {filename: filename, line: uint, col: uint};\n \n@@ -175,7 +175,7 @@ fn emit_note(sp: &option::t[span], msg: &str, cm: &codemap) {\n     emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n }\n \n-type file_lines = {name: str, lines: uint[]};\n+type file_lines = {name: str, lines: [uint]};\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);"}, {"sha": "0106f76982bf15b69a55daabc8bfd20911beb711", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -5,7 +5,7 @@ import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      body: option::t[str]) -> @ast::expr {\n-    let args: (@ast::expr)[] = alt arg.node {\n+    let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#concat_idents requires a vector argument .\") }\n     };\n@@ -19,4 +19,4 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n               node: {global: false, idents: ~[res], types: ~[]},\n               span: sp}),\n           span: sp};\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2a897b570ddeb91524c307047ca057f3bd453c8a", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -12,7 +12,7 @@ export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      body: option::t[str]) -> @ast::expr {\n-    let args: (@ast::expr)[] = alt arg.node {\n+    let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }\n     };"}, {"sha": "3df7024054a621f877760b70cddcf185790e74f8", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -18,7 +18,7 @@ export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n                      body: option::t[str]) -> @ast::expr {\n-    let args: (@ast::expr)[] = alt arg.node {\n+    let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }\n     };\n@@ -43,7 +43,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n // be factored out in common with other code that builds expressions.\n // FIXME: Cleanup the naming of these functions\n fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: vec[piece],\n-                  args: &(@ast::expr)[]) -> @ast::expr {\n+                  args: &[@ast::expr]) -> @ast::expr {\n     fn make_new_lit(cx: &ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n         let sp_lit = @{node: lit, span: sp};\n         ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n@@ -65,28 +65,28 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: vec[piece],\n         let binexpr = ast::expr_binary(ast::add, lhs, rhs);\n         ret @{id: cx.next_id(), node: binexpr, span: sp};\n     }\n-    fn make_path_expr(cx: &ext_ctxt, sp: span, idents: &ast::ident[]) ->\n+    fn make_path_expr(cx: &ext_ctxt, sp: span, idents: &[ast::ident]) ->\n        @ast::expr {\n         let path = {global: false, idents: idents, types: ~[]};\n         let sp_path = {node: path, span: sp};\n         let pathexpr = ast::expr_path(sp_path);\n         ret @{id: cx.next_id(), node: pathexpr, span: sp};\n     }\n-    fn make_vec_expr(cx: &ext_ctxt, sp: span, exprs: &(@ast::expr)[]) ->\n+    fn make_vec_expr(cx: &ext_ctxt, sp: span, exprs: &[@ast::expr]) ->\n        @ast::expr {\n         let vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n         ret @{id: cx.next_id(), node: vecexpr, span: sp};\n     }\n-    fn make_call(cx: &ext_ctxt, sp: span, fn_path: &ast::ident[],\n-                 args: &(@ast::expr)[]) -> @ast::expr {\n+    fn make_call(cx: &ext_ctxt, sp: span, fn_path: &[ast::ident],\n+                 args: &[@ast::expr]) -> @ast::expr {\n         let pathexpr = make_path_expr(cx, sp, fn_path);\n         let callexpr = ast::expr_call(pathexpr, args);\n         ret @{id: cx.next_id(), node: callexpr, span: sp};\n     }\n     fn make_rec_expr(cx: &ext_ctxt, sp: span,\n                      fields: vec[{ident: ast::ident, ex: @ast::expr}]) ->\n        @ast::expr {\n-        let astfields: ast::field[] = ~[];\n+        let astfields: [ast::field] = ~[];\n         for field: {ident: ast::ident, ex: @ast::expr}  in fields {\n             let ident = field.ident;\n             let val = field.ex;\n@@ -97,7 +97,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: vec[piece],\n         let recexpr = ast::expr_rec(astfields, option::none[@ast::expr]);\n         ret @{id: cx.next_id(), node: recexpr, span: sp};\n     }\n-    fn make_path_vec(cx: &ext_ctxt, ident: str) -> str[] {\n+    fn make_path_vec(cx: &ext_ctxt, ident: str) -> [str] {\n         fn compiling_std(cx: &ext_ctxt) -> bool {\n             ret str::find(cx.crate_file_name_hack, \"std.rc\") >= 0;\n         }\n@@ -115,7 +115,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: vec[piece],\n     fn make_rt_conv_expr(cx: &ext_ctxt, sp: span, cnv: &conv) -> @ast::expr {\n         fn make_flags(cx: &ext_ctxt, sp: span, flags: vec[flag]) ->\n            @ast::expr {\n-            let flagexprs: (@ast::expr)[] = ~[];\n+            let flagexprs: [@ast::expr] = ~[];\n             for f: flag  in flags {\n                 let fstr;\n                 alt f {"}, {"sha": "9399f2e8fd4ddc33fc403333400598bee038a21f", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -5,7 +5,7 @@ import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      body: option::t[str]) -> @ast::expr {\n-    let args: (@ast::expr)[] = alt arg.node {\n+    let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\") }\n     };\n@@ -18,4 +18,4 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                                                 \"expected an ident\"),\n                                   ast::sk_rc));\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "e2285aafc0bf12c121aae54a8d37a6737ac3e583", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -93,8 +93,8 @@ fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n type match_result = option::t[arb_depth[matchable]];\n type selector = fn(&matchable) -> match_result ;\n \n-fn elts_to_ell(cx: &ext_ctxt, elts: &(@expr)[])\n-    -> {fixed: (@expr)[], rep: option::t[@expr]} {\n+fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n+    -> {fixed: [@expr], rep: option::t[@expr]} {\n     let idx: uint = 0u;\n     for elt: @expr  in elts {\n         alt elt.node {\n@@ -153,7 +153,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n type binders =\n     {real_binders: hashmap[ident, selector],\n-     mutable literal_ast_matchers: selector[]};\n+     mutable literal_ast_matchers: [selector]};\n type bindings = hashmap[ident, arb_depth[matchable]];\n \n fn acumm_bindings(cx: &ext_ctxt, b_dest: &bindings, b_src: &bindings) { }\n@@ -272,8 +272,8 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n-                    recur: fn(&@expr) -> @expr , exprs: (@expr)[])\n-    -> (@expr)[] {\n+                    recur: fn(&@expr) -> @expr , exprs: [@expr])\n+    -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {fixed: fixed, rep: repeat_me_maybe} {\n         let res = ivec::map(recur, fixed);\n@@ -580,7 +580,7 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n \n /* TODO: move this to vec.rs */\n \n-fn ivec_to_vec[T](v: &T[]) -> vec[T] {\n+fn ivec_to_vec[T](v: &[T]) -> vec[T] {\n     let rs: vec[T] = vec::alloc[T](ivec::len(v));\n     for ve: T  in v { rs += [ve]; }\n     ret rs;\n@@ -614,7 +614,7 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n               compose_sels(s, bind select(cx, repeat_me, offset, _)), b);\n }\n \n-fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: (@expr)[], repeat_after: bool,\n+fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n                          s: &selector, b: &binders) {\n     fn len_select(cx: &ext_ctxt, m: &matchable, repeat_after: bool, len: uint)\n         -> match_result {\n@@ -662,15 +662,15 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: (@expr)[], repeat_after: bool,\n \n fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                      body: option::t[str]) -> base::macro_def {\n-    let args: (@ast::expr)[] = alt arg.node {\n+    let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ {\n         cx.span_fatal(sp, \"#macro requires arguments of the form `[...]`.\")\n       }\n     };\n \n     let macro_name: option::t[str] = none;\n-    let clauses: clause[] = ~[];\n+    let clauses: [clause] = ~[];\n     for arg: @expr  in args {\n         alt arg.node {\n           expr_vec(elts, mut, seq_kind) {\n@@ -727,7 +727,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n          ext: normal(ext)};\n \n     fn generic_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                         body: option::t[str], clauses: clause[]) -> @expr {\n+                         body: option::t[str], clauses: [clause]) -> @expr {\n         for c: clause  in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) {"}, {"sha": "d5d9898653df20a06b940cff58122438dfc6e013", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -43,7 +43,7 @@ type ast_fold_precursor =\n      fold_ident: fn(&ident, ast_fold) -> ident ,\n      fold_path: fn(&path_, ast_fold) -> path_ ,\n      fold_local: fn(&local_, ast_fold) -> local_ ,\n-     map_exprs: fn(fn(&@expr) -> @expr , (@expr)[]) -> (@expr)[] };\n+     map_exprs: fn(fn(&@expr) -> @expr , [@expr]) -> [@expr] };\n \n type a_f =\n     {fold_crate: fn(&crate) -> crate ,\n@@ -68,7 +68,7 @@ type a_f =\n      fold_ident: fn(&ident) -> ident ,\n      fold_path: fn(&path) -> path ,\n      fold_local: fn(&@local) -> @local ,\n-     map_exprs: fn(fn(&@expr) -> @expr , (@expr)[]) -> (@expr)[] };\n+     map_exprs: fn(fn(&@expr) -> @expr , [@expr]) -> [@expr] };\n \n //fn nf_dummy[T](&T node) -> T { fail; }\n fn nf_crate_dummy(c: &crate) -> crate { fail; }\n@@ -501,7 +501,7 @@ fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n \n /* temporarily eta-expand because of a compiler bug with using `fn[T]` as a\n    value */\n-fn noop_map_exprs(f: fn(&@expr) -> @expr , es: (@expr)[]) -> (@expr)[] {\n+fn noop_map_exprs(f: fn(&@expr) -> @expr , es: [@expr]) -> [@expr] {\n     ret ivec::map(f, es);\n }\n "}, {"sha": "6dd06a97901aeccd88df019e769b8b0a5173247c", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -19,32 +19,32 @@ tag eval_mode { mode_depend; mode_parse; }\n type ctx =\n     @{p: parser,\n       mode: eval_mode,\n-      mutable deps: str[],\n+      mutable deps: [str],\n       sess: parser::parse_sess,\n       mutable chpos: uint,\n       mutable byte_pos: uint,\n       cfg: ast::crate_cfg};\n \n-fn eval_crate_directives(cx: ctx, cdirs: &(@ast::crate_directive)[],\n+fn eval_crate_directives(cx: ctx, cdirs: &[@ast::crate_directive],\n                          prefix: str,\n-                         view_items: &mutable (@ast::view_item)[],\n-                         items: &mutable (@ast::item)[]) {\n+                         view_items: &mutable [@ast::view_item],\n+                         items: &mutable [@ast::item]) {\n     for sub_cdir: @ast::crate_directive  in cdirs {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n-fn eval_crate_directives_to_mod(cx: ctx, cdirs: &(@ast::crate_directive)[],\n+fn eval_crate_directives_to_mod(cx: ctx, cdirs: &[@ast::crate_directive],\n                                 prefix: str) -> ast::_mod {\n-    let view_items: (@ast::view_item)[] = ~[];\n-    let items: (@ast::item)[] = ~[];\n+    let view_items: [@ast::view_item] = ~[];\n+    let items: [@ast::item] = ~[];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret {view_items: view_items, items: items};\n }\n \n fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n-                        view_items: &mutable (@ast::view_item)[],\n-                        items: &mutable (@ast::item)[]) {\n+                        view_items: &mutable [@ast::view_item],\n+                        items: &mutable [@ast::item]) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, file_opt, attrs) {\n         let file_path = id + \".rs\";"}, {"sha": "40c0d8b4935459669d66450d904607c0a830928a", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -37,7 +37,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n                mutable pos: uint,\n                mutable ch: char,\n                mutable chpos: uint,\n-               mutable strs: str[],\n+               mutable strs: [str],\n                fm: codemap::filemap,\n                itr: @interner::interner[str]) {\n         fn is_eof() -> bool { ret ch == -1 as char; }\n@@ -81,7 +81,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n             codemap::emit_error(some({lo: chpos, hi: chpos}), m, cm);\n         }\n     }\n-    let strs: str[] = ~[];\n+    let strs: [str] = ~[];\n     let rd =\n         reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char,\n                filemap.start_pos.ch, strs, filemap, itr);\n@@ -550,7 +550,7 @@ tag cmnt_style {\n     blank_line; // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-type cmnt = {style: cmnt_style, lines: str[], pos: uint};\n+type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n \n fn read_to_eol(rdr: &reader) -> str {\n     let val = \"\";\n@@ -578,14 +578,14 @@ fn consume_non_eol_whitespace(rdr: &reader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: &reader, comments: &mutable cmnt[]) {\n+fn push_blank_line_comment(rdr: &reader, comments: &mutable [cmnt]) {\n     log \">>> blank-line comment\";\n-    let v: str[] = ~[];\n+    let v: [str] = ~[];\n     comments += ~[{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: &reader,\n-                                           comments: &mutable cmnt[]) {\n+                                           comments: &mutable [cmnt]) {\n     while is_whitespace(rdr.curr()) && !rdr.is_eof() {\n         if rdr.get_col() == 0u && rdr.curr() == '\\n' {\n             push_blank_line_comment(rdr, comments);\n@@ -597,7 +597,7 @@ fn consume_whitespace_counting_blank_lines(rdr: &reader,\n fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> line comments\";\n     let p = rdr.get_chpos();\n-    let lines: str[] = ~[];\n+    let lines: [str] = ~[];\n     while rdr.curr() == '/' && rdr.next() == '/' {\n         let line = read_one_line_comment(rdr);\n         log line;\n@@ -619,7 +619,7 @@ fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mutable str[], s: &str,\n+fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: &str,\n                                         col: uint) {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n@@ -634,7 +634,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mutable str[], s: &str,\n fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> block comment\";\n     let p = rdr.get_chpos();\n-    let lines: str[] = ~[];\n+    let lines: [str] = ~[];\n     let col: uint = rdr.get_col();\n     rdr.bump();\n     rdr.bump();\n@@ -682,7 +682,7 @@ fn peeking_at_comment(rdr: &reader) -> bool {\n }\n \n fn consume_comment(rdr: &reader, code_to_the_left: bool,\n-                   comments: &mutable cmnt[]) {\n+                   comments: &mutable [cmnt]) {\n     log \">>> consume comment\";\n     if rdr.curr() == '/' && rdr.next() == '/' {\n         comments += ~[read_line_comments(rdr, code_to_the_left)];\n@@ -710,12 +710,12 @@ type lit = {lit: str, pos: uint};\n \n fn gather_comments_and_literals(cm: &codemap::codemap, path: str,\n                                 srdr: ioivec::reader) ->\n-   {cmnts: cmnt[], lits: lit[]} {\n+   {cmnts: [cmnt], lits: [lit]} {\n     let src = str::unsafe_from_bytes_ivec(srdr.read_whole_stream());\n     let itr = @interner::mk[str](str::hash, str::eq);\n     let rdr = new_reader(cm, src, codemap::new_filemap(path, 0u, 0u), itr);\n-    let comments: cmnt[] = ~[];\n-    let literals: lit[] = ~[];\n+    let comments: [cmnt] = ~[];\n+    let literals: [lit] = ~[];\n     let first_read: bool = true;\n     while !rdr.is_eof() {\n         while true {"}, {"sha": "9bcf6d5aa84ca45477e89d7fba4260da45601809", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 68, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -47,7 +47,7 @@ type parser =\n         fn get_hi_pos() -> uint ;\n         fn get_last_lo_pos() -> uint ;\n         fn get_last_hi_pos() -> uint ;\n-        fn get_prec_table() -> @op_spec[] ;\n+        fn get_prec_table() -> @[op_spec] ;\n         fn get_str(token::str_num) -> str ;\n         fn get_reader() -> lexer::reader ;\n         fn get_filemap() -> codemap::filemap ;\n@@ -79,10 +79,10 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n                      mutable tok: token::token,\n                      mutable tok_span: span,\n                      mutable last_tok_span: span,\n-                     mutable buffer: {tok: token::token, span: span}[],\n+                     mutable buffer: [{tok: token::token, span: span}],\n                      mutable restr: restriction,\n                      rdr: lexer::reader,\n-                     precs: @op_spec[],\n+                     precs: @[op_spec],\n                      bad_words: hashmap[str, ()]) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n@@ -121,7 +121,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         fn get_last_hi_pos() -> uint { ret last_tok_span.hi; }\n         fn get_file_type() -> file_type { ret ftype; }\n         fn get_cfg() -> ast::crate_cfg { ret cfg; }\n-        fn get_prec_table() -> @op_spec[] { ret precs; }\n+        fn get_prec_table() -> @[op_spec] { ret precs; }\n         fn get_str(i: token::str_num) -> str {\n             ret interner::get(*rdr.get_interner(), i);\n         }\n@@ -283,7 +283,7 @@ fn parse_ty_fn(proto: ast::proto, p: &parser, lo: uint) -> ast::ty_ {\n                   parse_fn_input_ty, p);\n     // FIXME: there's no syntax for this right now anyway\n     //  auto constrs = parse_constrs(~[], p);\n-    let constrs: (@ast::constr)[] = ~[];\n+    let constrs: [@ast::constr] = ~[];\n     let output: @ast::ty;\n     let cf = ast::return;\n     if p.peek() == token::RARROW {\n@@ -354,7 +354,7 @@ fn parse_ty_field(p: &parser) -> ast::ty_field {\n \n // if i is the jth ident in args, return j\n // otherwise, fail\n-fn ident_index(p: &parser, args: &ast::arg[], i: &ast::ident) -> uint {\n+fn ident_index(p: &parser, args: &[ast::arg], i: &ast::ident) -> uint {\n     let j = 0u;\n     for a: ast::arg  in args { if a.ident == i { ret j; } j += 1u; }\n     p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n@@ -374,7 +374,7 @@ fn parse_type_constr_arg(p: &parser) -> @ast::ty_constr_arg {\n     ret @{node: carg, span: sp};\n }\n \n-fn parse_constr_arg(args: &ast::arg[], p: &parser) -> @ast::constr_arg {\n+fn parse_constr_arg(args: &[ast::arg], p: &parser) -> @ast::constr_arg {\n     let sp = p.get_span();\n     let carg = ast::carg_base;\n     if p.peek() == token::BINOP(token::STAR) {\n@@ -386,11 +386,11 @@ fn parse_constr_arg(args: &ast::arg[], p: &parser) -> @ast::constr_arg {\n     ret @{node: carg, span: sp};\n }\n \n-fn parse_ty_constr(fn_args: &ast::arg[], p: &parser) -> @ast::constr {\n+fn parse_ty_constr(fn_args: &[ast::arg], p: &parser) -> @ast::constr {\n     let lo = p.get_lo_pos();\n     let path = parse_path(p);\n     let pf = bind parse_constr_arg(fn_args, _);\n-    let args: {node: (@ast::constr_arg)[], span: span} =\n+    let args: {node: [@ast::constr_arg], span: span} =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), pf, p);\n     ret @spanned(lo, args.span.hi,\n                  {path: path, args: args.node, id: p.get_id()});\n@@ -399,7 +399,7 @@ fn parse_ty_constr(fn_args: &ast::arg[], p: &parser) -> @ast::constr {\n fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n     let lo = p.get_lo_pos();\n     let path = parse_path(p);\n-    let args: (@ast::ty_constr_arg)[] =\n+    let args: [@ast::ty_constr_arg] =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_type_constr_arg, p).node;\n     let hi = p.get_lo_pos();\n@@ -409,8 +409,8 @@ fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n \n \n fn parse_constrs[T](pser: fn(&parser) -> @ast::constr_general[T] , p: &parser)\n-   -> (@ast::constr_general[T])[] {\n-    let constrs: (@ast::constr_general[T])[] = ~[];\n+   -> [@ast::constr_general[T]] {\n+    let constrs: [@ast::constr_general[T]] = ~[];\n     while true {\n         let constr = pser(p);\n         constrs += ~[constr];\n@@ -419,13 +419,14 @@ fn parse_constrs[T](pser: fn(&parser) -> @ast::constr_general[T] , p: &parser)\n     constrs\n }\n \n-fn parse_type_constraints(p: &parser) -> (@ast::ty_constr)[] {\n+fn parse_type_constraints(p: &parser) -> [@ast::ty_constr] {\n     ret parse_constrs(parse_constr_in_type, p);\n }\n \n fn parse_ty_postfix(orig_t: ast::ty_, p: &parser) -> @ast::ty {\n     let lo = p.get_lo_pos();\n     if p.peek() == token::LBRACKET {\n+        // This is explicit type parameter instantiation.\n         p.bump();\n \n         let mut;\n@@ -610,16 +611,16 @@ fn parse_arg(p: &parser) -> ast::arg {\n }\n \n fn parse_seq_to_end[T](ket: token::token, sep: option::t[token::token],\n-                       f: fn(&parser) -> T , p: &parser) -> T[] {\n+                       f: fn(&parser) -> T , p: &parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n fn parse_seq_to_before_end[T](ket: token::token, sep: option::t[token::token],\n-                              f: fn(&parser) -> T , p: &parser) -> T[] {\n+                              f: fn(&parser) -> T , p: &parser) -> [T] {\n     let first: bool = true;\n-    let v: T[] = ~[];\n+    let v: [T] = ~[];\n     while p.peek() != ket {\n         alt sep {\n           some(t) { if first { first = false; } else { expect(p, t); } }\n@@ -633,7 +634,7 @@ fn parse_seq_to_before_end[T](ket: token::token, sep: option::t[token::token],\n \n fn parse_seq[T](bra: token::token, ket: token::token,\n                 sep: option::t[token::token], f: fn(&parser) -> T ,\n-                p: &parser) -> spanned[T[]] {\n+                p: &parser) -> spanned[[T]] {\n     let lo = p.get_lo_pos();\n     expect(p, bra);\n     let result = parse_seq_to_before_end[T](ket, sep, f, p);\n@@ -701,7 +702,7 @@ fn parse_path(p: &parser) -> ast::path {\n         p.bump();\n     } else { global = false; }\n \n-    let ids: ast::ident[] = ~[];\n+    let ids: [ast::ident] = ~[];\n     while true {\n         alt p.peek() {\n           token::IDENT(i, _) {\n@@ -865,14 +866,14 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         // Anonymous object\n \n         // Only make people type () if they're actually adding new fields\n-        let fields: option::t[ast::anon_obj_field[]] = none;\n+        let fields: option::t[[ast::anon_obj_field]] = none;\n         if p.peek() == token::LPAREN {\n             p.bump();\n             fields =\n                 some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n                                       parse_anon_obj_field, p));\n         }\n-        let meths: (@ast::method)[] = ~[];\n+        let meths: [@ast::method] = ~[];\n         let inner_obj: option::t[@ast::expr] = none;\n         expect(p, token::LBRACE);\n         while p.peek() != token::RBRACE {\n@@ -1154,7 +1155,7 @@ type op_spec = {tok: token::token, op: ast::binop, prec: int};\n \n \n // FIXME make this a const, don't store it in parser state\n-fn prec_table() -> @op_spec[] {\n+fn prec_table() -> @[op_spec] {\n     ret @~[{tok: token::BINOP(token::STAR), op: ast::mul, prec: 11},\n            {tok: token::BINOP(token::SLASH), op: ast::div, prec: 11},\n            {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 11},\n@@ -1341,7 +1342,7 @@ fn parse_alt_expr(p: &parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n-    let arms: ast::arm[] = ~[];\n+    let arms: [ast::arm] = ~[];\n     while p.peek() != token::RBRACE {\n         let pats = parse_pats(p);\n         let blk = parse_block(p);\n@@ -1403,7 +1404,7 @@ fn parse_initializer(p: &parser) -> option::t[ast::initializer] {\n     }\n }\n \n-fn parse_pats(p: &parser) -> (@ast::pat)[] {\n+fn parse_pats(p: &parser) -> [@ast::pat] {\n     let pats = ~[];\n     while true {\n         pats += ~[parse_pat(p)];\n@@ -1479,7 +1480,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n         } else {\n             let tag_path = parse_path_and_ty_param_substs(p);\n             hi = tag_path.span.hi;\n-            let args: (@ast::pat)[];\n+            let args: [@ast::pat];\n             alt p.peek() {\n               token::LPAREN. {\n                 let a =\n@@ -1650,7 +1651,7 @@ fn parse_block(p: &parser) -> ast::blk {\n \n // some blocks start with \"#{\"...\n fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n-    let stmts: (@ast::stmt)[] = ~[];\n+    let stmts: [@ast::stmt] = ~[];\n     let expr: option::t[@ast::expr] = none;\n     while p.peek() != token::RBRACE {\n         alt p.peek() {\n@@ -1703,8 +1704,8 @@ fn parse_ty_param(p: &parser) -> ast::ty_param {\n     ret {ident: parse_ident(p), kind: k};\n }\n \n-fn parse_ty_params(p: &parser) -> ast::ty_param[] {\n-    let ty_params: ast::ty_param[] = ~[];\n+fn parse_ty_params(p: &parser) -> [ast::ty_param] {\n+    let ty_params: [ast::ty_param] = ~[];\n     if p.peek() == token::LBRACKET {\n         ty_params =\n             parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n@@ -1715,7 +1716,7 @@ fn parse_ty_params(p: &parser) -> ast::ty_param[] {\n \n fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness)\n         -> ast::fn_decl {\n-    let inputs: ast::spanned[ast::arg[]] =\n+    let inputs: ast::spanned[[ast::arg]] =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n                   p);\n     let rslt: ty_or_bang;\n@@ -1760,14 +1761,14 @@ fn parse_fn(p: &parser, proto: ast::proto, purity: ast::purity,\n     ret {decl: decl, proto: proto, body: body};\n }\n \n-fn parse_fn_header(p: &parser) -> {ident: ast::ident, tps: ast::ty_param[]} {\n+fn parse_fn_header(p: &parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n     let id = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n     ret {ident: id, tps: ty_params};\n }\n \n fn mk_item(p: &parser, lo: uint, hi: uint, ident: &ast::ident,\n-           node: &ast::item_, attrs: &ast::attribute[]) -> @ast::item {\n+           node: &ast::item_, attrs: &[ast::attribute]) -> @ast::item {\n     ret @{ident: ident,\n           attrs: attrs,\n           id: p.get_id(),\n@@ -1776,7 +1777,7 @@ fn mk_item(p: &parser, lo: uint, hi: uint, ident: &ast::ident,\n }\n \n fn parse_item_fn_or_iter(p: &parser, purity: ast::purity, proto: ast::proto,\n-                         attrs: &ast::attribute[], il: ast::inlineness)\n+                         attrs: &[ast::attribute], il: ast::inlineness)\n         -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n@@ -1812,15 +1813,15 @@ fn parse_method(p: &parser) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n-fn parse_item_obj(p: &parser, attrs: &ast::attribute[]) ->\n+fn parse_item_obj(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n-    let fields: ast::spanned[ast::obj_field[]] =\n+    let fields: ast::spanned[[ast::obj_field]] =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_obj_field, p);\n-    let meths: (@ast::method)[] = ~[];\n+    let meths: [@ast::method] = ~[];\n     expect(p, token::LBRACE);\n     while p.peek() != token::RBRACE {\n         meths += ~[parse_method(p)];\n@@ -1832,7 +1833,7 @@ fn parse_item_obj(p: &parser, attrs: &ast::attribute[]) ->\n                 attrs);\n }\n \n-fn parse_item_res(p: &parser, attrs: &ast::attribute[]) ->\n+fn parse_item_res(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n@@ -1860,11 +1861,11 @@ fn parse_item_res(p: &parser, attrs: &ast::attribute[]) ->\n }\n \n fn parse_mod_items(p: &parser, term: token::token,\n-                   first_item_attrs: &ast::attribute[]) -> ast::_mod {\n+                   first_item_attrs: &[ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n         if ivec::len(first_item_attrs) == 0u { parse_view(p) } else { ~[] };\n-    let items: (@ast::item)[] = ~[];\n+    let items: [@ast::item] = ~[];\n     let initial_attrs = first_item_attrs;\n     while p.peek() != term {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n@@ -1880,7 +1881,7 @@ fn parse_mod_items(p: &parser, term: token::token,\n     ret {view_items: view_items, items: items};\n }\n \n-fn parse_item_const(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n+fn parse_item_const(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_value_ident(p);\n     expect(p, token::COLON);\n@@ -1892,7 +1893,7 @@ fn parse_item_const(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n }\n \n-fn parse_item_mod(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n+fn parse_item_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n     expect(p, token::LBRACE);\n@@ -1904,7 +1905,7 @@ fn parse_item_mod(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs.inner);\n }\n \n-fn parse_item_native_type(p: &parser, attrs: &ast::attribute[]) ->\n+fn parse_item_native_type(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::native_item {\n     let t = parse_type_decl(p);\n     let hi = p.get_hi_pos();\n@@ -1916,7 +1917,7 @@ fn parse_item_native_type(p: &parser, attrs: &ast::attribute[]) ->\n           span: {lo: t.lo, hi: hi}};\n }\n \n-fn parse_item_native_fn(p: &parser, attrs: &ast::attribute[]) ->\n+fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::native_item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n@@ -1932,7 +1933,7 @@ fn parse_item_native_fn(p: &parser, attrs: &ast::attribute[]) ->\n           span: {lo: lo, hi: hi}};\n }\n \n-fn parse_native_item(p: &parser, attrs: &ast::attribute[]) ->\n+fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->\n    @ast::native_item {\n     if eat_word(p, \"type\") {\n         ret parse_item_native_type(p, attrs);\n@@ -1942,14 +1943,14 @@ fn parse_native_item(p: &parser, attrs: &ast::attribute[]) ->\n }\n \n fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n-                          first_item_attrs: &ast::attribute[])\n+                          first_item_attrs: &[ast::attribute])\n     -> ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n         if ivec::len(first_item_attrs) == 0u {\n             parse_native_view(p)\n         } else { ~[] };\n-    let items: (@ast::native_item)[] = ~[];\n+    let items: [@ast::native_item] = ~[];\n     let initial_attrs = first_item_attrs;\n     while p.peek() != token::RBRACE {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n@@ -1962,7 +1963,7 @@ fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n          items: items};\n }\n \n-fn parse_item_native_mod(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n+fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let abi = ast::native_abi_cdecl;\n     if !is_word(p, \"mod\") {\n@@ -2002,7 +2003,7 @@ fn parse_type_decl(p: &parser) -> {lo: uint, ident: ast::ident} {\n     ret {lo: lo, ident: id};\n }\n \n-fn parse_item_type(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n+fn parse_item_type(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let t = parse_type_decl(p);\n     let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n@@ -2012,11 +2013,11 @@ fn parse_item_type(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n     ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n }\n \n-fn parse_item_tag(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n+fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n     let ty_params = parse_ty_params(p);\n-    let variants: ast::variant[] = ~[];\n+    let variants: [ast::variant] = ~[];\n     // Newtype syntax\n     if p.peek() == token::EQ {\n         if p.get_bad_expr_words().contains_key(id) {\n@@ -2041,7 +2042,7 @@ fn parse_item_tag(p: &parser, attrs: &ast::attribute[]) -> @ast::item {\n             check_bad_word(p);\n             let vlo = p.get_lo_pos();\n             p.bump();\n-            let args: ast::variant_arg[] = ~[];\n+            let args: [ast::variant_arg] = ~[];\n             let vhi = p.get_hi_pos();\n             alt p.peek() {\n               token::LPAREN. {\n@@ -2078,7 +2079,7 @@ fn parse_auth(p: &parser) -> ast::_auth {\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_item(p: &parser, attrs: &ast::attribute[]) -> option::t[@ast::item] {\n+fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t[@ast::item] {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n     } else if (eat_word(p, \"inline\")) {\n@@ -2114,7 +2115,7 @@ fn parse_item(p: &parser, attrs: &ast::attribute[]) -> option::t[@ast::item] {\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option::t[either::t[ast::attribute[], @ast::expr]];\n+type attr_or_ext = option::t[either::t[[ast::attribute], @ast::expr]];\n \n fn parse_outer_attrs_or_ext(p: &parser) -> attr_or_ext {\n     if p.peek() == token::POUND {\n@@ -2130,8 +2131,8 @@ fn parse_outer_attrs_or_ext(p: &parser) -> attr_or_ext {\n }\n \n // Parse attributes that appear before an item\n-fn parse_outer_attributes(p: &parser) -> ast::attribute[] {\n-    let attrs: ast::attribute[] = ~[];\n+fn parse_outer_attributes(p: &parser) -> [ast::attribute] {\n+    let attrs: [ast::attribute] = ~[];\n     while p.peek() == token::POUND {\n         attrs += ~[parse_attribute(p, ast::attr_outer)];\n     }\n@@ -2160,9 +2161,9 @@ fn parse_attribute_naked(p: &parser, style: ast::attr_style, lo: uint) ->\n // of the containing item or an outer attribute of the first contained item\n // until we see the semi).\n fn parse_inner_attrs_and_next(p: &parser) ->\n-   {inner: ast::attribute[], next: ast::attribute[]} {\n-    let inner_attrs: ast::attribute[] = ~[];\n-    let next_outer_attrs: ast::attribute[] = ~[];\n+   {inner: [ast::attribute], next: [ast::attribute]} {\n+    let inner_attrs: [ast::attribute] = ~[];\n+    let next_outer_attrs: [ast::attribute] = ~[];\n     while p.peek() == token::POUND {\n         let attr = parse_attribute(p, ast::attr_inner);\n         if p.peek() == token::SEMI {\n@@ -2202,12 +2203,12 @@ fn parse_meta_item(p: &parser) -> @ast::meta_item {\n     }\n }\n \n-fn parse_meta_seq(p: &parser) -> (@ast::meta_item)[] {\n+fn parse_meta_seq(p: &parser) -> [@ast::meta_item] {\n     ret parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_meta_item, p).node;\n }\n \n-fn parse_optional_meta(p: &parser) -> (@ast::meta_item)[] {\n+fn parse_optional_meta(p: &parser) -> [@ast::meta_item] {\n     alt p.peek() { token::LPAREN. { ret parse_meta_seq(p); } _ { ret ~[]; } }\n }\n \n@@ -2220,7 +2221,7 @@ fn parse_use(p: &parser) -> ast::view_item_ {\n fn parse_rest_import_name(p: &parser, first: ast::ident,\n                           def_ident: option::t[ast::ident]) ->\n    ast::view_item_ {\n-    let identifiers: ast::ident[] = ~[first];\n+    let identifiers: [ast::ident] = ~[first];\n     let glob: bool = false;\n     while true {\n         alt p.peek() {\n@@ -2315,14 +2316,14 @@ fn is_view_item(p: &parser) -> bool {\n     }\n }\n \n-fn parse_view(p: &parser) -> (@ast::view_item)[] {\n-    let items: (@ast::view_item)[] = ~[];\n+fn parse_view(p: &parser) -> [@ast::view_item] {\n+    let items: [@ast::view_item] = ~[];\n     while is_view_item(p) { items += ~[parse_view_item(p)]; }\n     ret items;\n }\n \n-fn parse_native_view(p: &parser) -> (@ast::view_item)[] {\n-    let items: (@ast::view_item)[] = ~[];\n+fn parse_native_view(p: &parser) -> [@ast::view_item] {\n+    let items: [@ast::view_item] = ~[];\n     while is_view_item(p) { items += ~[parse_view_item(p)]; }\n     ret items;\n }\n@@ -2370,7 +2371,7 @@ fn parse_str(p: &parser) -> ast::ident {\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-fn parse_crate_directive(p: &parser, first_outer_attr: &ast::attribute[]) ->\n+fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n    ast::crate_directive {\n \n     // Collect the next attributes\n@@ -2425,8 +2426,8 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &ast::attribute[]) ->\n }\n \n fn parse_crate_directives(p: &parser, term: token::token,\n-                          first_outer_attr: &ast::attribute[]) ->\n-   (@ast::crate_directive)[] {\n+                          first_outer_attr: &[ast::attribute]) ->\n+   [@ast::crate_directive] {\n \n     // This is pretty ugly. If we have an outer attribute then we can't accept\n     // seeing the terminator next, so if we do see it then fail the same way\n@@ -2435,7 +2436,7 @@ fn parse_crate_directives(p: &parser, term: token::token,\n         expect_word(p, \"mod\");\n     }\n \n-    let cdirs: (@ast::crate_directive)[] = ~[];\n+    let cdirs: [@ast::crate_directive] = ~[];\n     while p.peek() != term {\n         let cdir = @parse_crate_directive(p, first_outer_attr);\n         cdirs += ~[cdir];\n@@ -2452,7 +2453,7 @@ fn parse_crate_from_crate_file(input: &str, cfg: &ast::crate_cfg,\n     let crate_attrs = leading_attrs.inner;\n     let first_cdir_attr = leading_attrs.next;\n     let cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n-    let deps: str[] = ~[];\n+    let deps: [str] = ~[];\n     let cx =\n         @{p: p,\n           mode: eval::mode_parse,"}, {"sha": "00b6c5f32bff44ccf331db4eb17e06b05082ccd2", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -74,7 +74,7 @@ fn tok_str(t: token) -> str {\n     }\n }\n \n-fn buf_str(toks: &token[mutable ], szs: &int[mutable ], left: uint,\n+fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n            right: uint, lim: uint) -> str {\n     let n = ivec::len(toks);\n     assert (n == ivec::len(szs));\n@@ -104,10 +104,10 @@ fn mk_printer(out: ioivec::writer, linewidth: uint) -> printer {\n \n     let n: uint = 3u * linewidth;\n     log #fmt(\"mk_printer %u\", linewidth);\n-    let token: token[mutable ] = ivec::init_elt_mut(EOF, n);\n-    let size: int[mutable ] = ivec::init_elt_mut(0, n);\n-    let scan_stack: uint[mutable ] = ivec::init_elt_mut(0u, n);\n-    let print_stack: print_stack_elt[] = ~[];\n+    let token: [mutable token] = ivec::init_elt_mut(EOF, n);\n+    let size: [mutable int] = ivec::init_elt_mut(0, n);\n+    let scan_stack: [mutable uint] = ivec::init_elt_mut(0u, n);\n+    let print_stack: [print_stack_elt] = ~[];\n     ret printer(out, n, linewidth as int, // margin\n                 linewidth as int, // space\n                 0u, // left\n@@ -208,10 +208,10 @@ obj printer(out: ioivec::writer,\n \n             mutable right: uint, // index of right side of input stream\n \n-            mutable token: token[mutable ],\n+            mutable token: [mutable token],\n \n             // ring-buffr stream goes through\n-            mutable size: int[mutable ], // ring-buffer of calculated sizes\n+            mutable size: [mutable int], // ring-buffer of calculated sizes\n \n             mutable left_total: int, // running size of stream \"...left\"\n \n@@ -223,15 +223,15 @@ obj printer(out: ioivec::writer,\n              // BEGIN (if there is any) on top of it. Stuff is flushed off the\n              // bottom as it becomes irrelevant due to the primary ring-buffer\n              // advancing.\n-             mutable scan_stack: uint[mutable ],\n+             mutable scan_stack: [mutable uint],\n             mutable scan_stack_empty: bool, // top==bottom disambiguator\n \n             mutable top: uint, // index of top of scan_stack\n \n             mutable bottom: uint, // index of bottom of scan_stack\n \n              // stack of blocks-in-progress being flushed by print\n-            mutable print_stack: print_stack_elt[],\n+            mutable print_stack: [print_stack_elt],\n \n \n             // buffered indentation to avoid writing trailing whitespace"}, {"sha": "c732039eaa14905bd7a66ae7d5c6b5b541e3691a", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -41,23 +41,23 @@ fn no_ann() -> pp_ann {\n type ps =\n     @{s: pp::printer,\n       cm: option::t[codemap],\n-      comments: option::t[lexer::cmnt[]],\n-      literals: option::t[lexer::lit[]],\n+      comments: option::t[[lexer::cmnt]],\n+      literals: option::t[[lexer::lit]],\n       mutable cur_cmnt: uint,\n       mutable cur_lit: uint,\n-      mutable boxes: pp::breaks[],\n+      mutable boxes: [pp::breaks],\n       ann: pp_ann};\n \n fn ibox(s: &ps, u: uint) { s.boxes += ~[pp::inconsistent]; pp::ibox(s.s, u); }\n \n fn end(s: &ps) { ivec::pop(s.boxes); pp::end(s.s); }\n \n fn rust_printer(writer: ioivec::writer) -> ps {\n-    let boxes: pp::breaks[] = ~[];\n+    let boxes: [pp::breaks] = ~[];\n     ret @{s: pp::mk_printer(writer, default_columns),\n           cm: none[codemap],\n-          comments: none[lexer::cmnt[]],\n-          literals: none[lexer::lit[]],\n+          comments: none[[lexer::cmnt]],\n+          literals: none[[lexer::lit]],\n           mutable cur_cmnt: 0u,\n           mutable cur_lit: 0u,\n           mutable boxes: boxes,\n@@ -74,7 +74,7 @@ const default_columns: uint = 78u;\n // copy forward.\n fn print_crate(cm: &codemap, crate: @ast::crate, filename: str,\n                in: ioivec::reader, out: ioivec::writer, ann: &pp_ann) {\n-    let boxes: pp::breaks[] = ~[];\n+    let boxes: [pp::breaks] = ~[];\n     let r = lexer::gather_comments_and_literals(cm, filename, in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n@@ -102,7 +102,7 @@ fn item_to_str(i: &@ast::item) -> str { be to_str(i, print_item); }\n \n fn path_to_str(p: &ast::path) -> str { be to_str(p, print_path); }\n \n-fn fun_to_str(f: &ast::_fn, name: str, params: &ast::ty_param[]) -> str {\n+fn fun_to_str(f: &ast::_fn, name: str, params: &[ast::ty_param]) -> str {\n     let writer = ioivec::string_writer();\n     let s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n@@ -216,7 +216,7 @@ fn synth_comment(s: &ps, text: str) {\n     word(s.s, \"*/\");\n }\n \n-fn commasep[IN](s: &ps, b: breaks, elts: &IN[], op: fn(&ps, &IN) ) {\n+fn commasep[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n     box(s, 0u, b);\n     let first = true;\n     for elt: IN  in elts {\n@@ -227,7 +227,7 @@ fn commasep[IN](s: &ps, b: breaks, elts: &IN[], op: fn(&ps, &IN) ) {\n }\n \n \n-fn commasep_cmnt[IN](s: &ps, b: breaks, elts: &IN[], op: fn(&ps, &IN) ,\n+fn commasep_cmnt[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n                      get_span: fn(&IN) -> codemap::span ) {\n     box(s, 0u, b);\n     let len = ivec::len[IN](elts);\n@@ -246,12 +246,12 @@ fn commasep_cmnt[IN](s: &ps, b: breaks, elts: &IN[], op: fn(&ps, &IN) ,\n     end(s);\n }\n \n-fn commasep_exprs(s: &ps, b: breaks, exprs: &(@ast::expr)[]) {\n+fn commasep_exprs(s: &ps, b: breaks, exprs: &[@ast::expr]) {\n     fn expr_span(expr: &@ast::expr) -> codemap::span { ret expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-fn print_mod(s: &ps, _mod: &ast::_mod, attrs: &ast::attribute[]) {\n+fn print_mod(s: &ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem: @ast::view_item  in _mod.view_items {\n         print_view_item(s, vitem);\n@@ -260,7 +260,7 @@ fn print_mod(s: &ps, _mod: &ast::_mod, attrs: &ast::attribute[]) {\n }\n \n fn print_native_mod(s: &ps, nmod: &ast::native_mod,\n-                    attrs: &ast::attribute[]) {\n+                    attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem: @ast::view_item  in nmod.view_items {\n         print_view_item(s, vitem);\n@@ -505,7 +505,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n         space(s.s);\n         bopen(s);\n         for meth: @ast::method  in _obj.methods {\n-            let typarams: ast::ty_param[] = ~[];\n+            let typarams: [ast::ty_param] = ~[];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n@@ -530,7 +530,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n     s.ann.post(ann_node);\n }\n \n-fn print_outer_attributes(s: &ps, attrs: &ast::attribute[]) {\n+fn print_outer_attributes(s: &ps, attrs: &[ast::attribute]) {\n     let count = 0;\n     for attr: ast::attribute  in attrs {\n         alt attr.node.style {\n@@ -541,7 +541,7 @@ fn print_outer_attributes(s: &ps, attrs: &ast::attribute[]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-fn print_inner_attributes(s: &ps, attrs: &ast::attribute[]) {\n+fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n     let count = 0;\n     for attr: ast::attribute  in attrs {\n         alt attr.node.style {\n@@ -1011,7 +1011,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n \n         // Methods\n         for meth: @ast::method in anon_obj.methods {\n-            let typarams: ast::ty_param[] = ~[];\n+            let typarams: [ast::ty_param] = ~[];\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n@@ -1145,7 +1145,7 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n }\n \n fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: str,\n-            typarams: &ast::ty_param[], constrs: (@ast::constr)[]) {\n+            typarams: &[ast::ty_param], constrs: [@ast::constr]) {\n     alt decl.purity {\n       ast::impure_fn. { head(s, proto_to_str(proto)); }\n       _ { head(s, \"pred\"); }\n@@ -1156,7 +1156,7 @@ fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: str,\n }\n \n fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n-                        constrs: (@ast::constr)[]) {\n+                        constrs: [@ast::constr]) {\n     popen(s);\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n@@ -1193,7 +1193,7 @@ fn print_kind(s: &ps, kind: ast::kind) {\n     }\n }\n \n-fn print_type_params(s: &ps, params: &ast::ty_param[]) {\n+fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n     if ivec::len(params) > 0u {\n         word(s.s, \"[\");\n         fn printParam(s: &ps, param: &ast::ty_param) {\n@@ -1308,8 +1308,8 @@ fn print_mt(s: &ps, mt: &ast::mt) {\n }\n \n fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t[str],\n-               inputs: &ast::ty_arg[], output: &@ast::ty,\n-               cf: &ast::controlflow, constrs: &(@ast::constr)[]) {\n+               inputs: &[ast::ty_arg], output: &@ast::ty,\n+               cf: &ast::controlflow, constrs: &[@ast::constr]) {\n     ibox(s, indent_unit);\n     word(s.s, proto_to_str(proto));\n     alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n@@ -1518,7 +1518,7 @@ fn next_comment(s: &ps) -> option::t[lexer::cmnt] {\n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n fn constr_args_to_str[T](f: &fn(&T) -> str ,\n-                         args: &(@ast::sp_constr_arg[T])[]) -> str {\n+                         args: &[@ast::sp_constr_arg[T]]) -> str {\n     let comma = false;\n     let s = \"(\";\n     for a: @ast::sp_constr_arg[T]  in args {\n@@ -1549,7 +1549,7 @@ fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> str {\n }\n \n // FIXME: fix repeated code\n-fn ast_ty_fn_constrs_str(constrs: &(@ast::constr)[]) -> str {\n+fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::constr  in constrs {\n@@ -1571,7 +1571,7 @@ fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {\n \n // FIXME: fix repeated code\n fn ast_fn_constrs_str(decl: &ast::fn_decl,\n-                      constrs: &(@ast::constr)[]) -> str {\n+                      constrs: &[@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::constr  in constrs {\n@@ -1596,7 +1596,7 @@ fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n }\n \n \n-fn ast_ty_constrs_str(constrs: &(@ast::ty_constr)[]) -> str {\n+fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::ty_constr  in constrs {"}, {"sha": "7f95d0ef0e7173f0ba11800da6193e838ea0ecee", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -12,7 +12,7 @@ import std::option::some;\n \n type interner[T] =\n     {map: hashmap[T, uint],\n-     mutable vect: T[],\n+     mutable vect: [T],\n      hasher: hashfn[T],\n      eqer: eqfn[T]};\n "}, {"sha": "9c639b8c5c008edc1f4386f55822e2c3febf37f9", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -33,7 +33,7 @@ type visitor[E] =\n       visit_ty: fn(&@ty, &E, &vt[E]) ,\n       visit_constr: fn(&path, &span, node_id, &E, &vt[E]) ,\n       visit_fn:\n-          fn(&_fn, &ty_param[], &span, &fn_ident, node_id, &E, &vt[E]) };\n+          fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt[E]) };\n \n fn default_visitor[E]() -> visitor[E] {\n     ret @{visit_mod: bind visit_mod[E](_, _, _, _),\n@@ -195,7 +195,7 @@ fn visit_fn_decl[E](fd: &fn_decl, e: &E, v: &vt[E]) {\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn[E](f: &_fn, tp: &ty_param[], sp: &span, i: &fn_ident, id: node_id,\n+fn visit_fn[E](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident, id: node_id,\n                e: &E, v: &vt[E]) {\n     visit_fn_decl(f.decl, e, v);\n     v.visit_block(f.body, e, v);\n@@ -227,7 +227,7 @@ fn visit_expr_opt[E](eo: option::t[@expr], e: &E, v: &vt[E]) {\n     alt eo { none. { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n-fn visit_exprs[E](exprs: &(@expr)[], e: &E, v: &vt[E]) {\n+fn visit_exprs[E](exprs: &[@expr], e: &E, v: &vt[E]) {\n     for ex: @expr  in exprs { v.visit_expr(ex, e, v); }\n }\n \n@@ -362,7 +362,7 @@ type simple_visitor =\n       visit_expr: fn(&@expr) ,\n       visit_ty: fn(&@ty) ,\n       visit_constr: fn(&path, &span, node_id) ,\n-      visit_fn: fn(&_fn, &ty_param[], &span, &fn_ident, node_id) };\n+      visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id) };\n \n fn default_simple_visitor() -> simple_visitor {\n     ret @{visit_mod: fn (m: &_mod, sp: &span) { },\n@@ -379,7 +379,7 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_ty: fn (t: &@ty) { },\n           visit_constr: fn (p: &path, sp: &span, id: node_id) { },\n           visit_fn:\n-              fn (f: &_fn, tps: &ty_param[], sp: &span, ident: &fn_ident,\n+              fn (f: &_fn, tps: &[ty_param], sp: &span, ident: &fn_ident,\n                   id: node_id) {\n               }};\n }\n@@ -439,8 +439,8 @@ fn mk_simple_visitor(v: &simple_visitor) -> vt[()] {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n-    fn v_fn(f: fn(&_fn, &ty_param[], &span, &fn_ident, node_id) , ff: &_fn,\n-            tps: &ty_param[], sp: &span, ident: &fn_ident, id: node_id,\n+    fn v_fn(f: fn(&_fn, &[ty_param], &span, &fn_ident, node_id) , ff: &_fn,\n+            tps: &[ty_param], sp: &span, ident: &fn_ident, id: node_id,\n             e: &(), v: &vt[()]) {\n         f(ff, tps, sp, ident, id);\n         visit_fn(ff, tps, sp, ident, id, e, v);"}, {"sha": "e0e9a5bfa52d431a922235f60124e1f24422a6ee", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -49,15 +49,15 @@ fn new_def_hash[@V]() -> std::map::hashmap[ast::def_id, V] {\n \n fn elt_expr(e: &ast::elt) -> @ast::expr { ret e.expr; }\n \n-fn elt_exprs(elts: &ast::elt[]) -> (@ast::expr)[] {\n+fn elt_exprs(elts: &[ast::elt]) -> [@ast::expr] {\n     let es = ~[];\n     for e: ast::elt  in elts { es += ~[e.expr]; }\n     ret es;\n }\n \n fn field_expr(f: &ast::field) -> @ast::expr { ret f.node.expr; }\n \n-fn field_exprs(fields: &ast::field[]) -> (@ast::expr)[] {\n+fn field_exprs(fields: &[ast::field]) -> [@ast::expr] {\n     let es = ~[];\n     for f: ast::field  in fields { es += ~[f.node.expr]; }\n     ret es;\n@@ -77,11 +77,11 @@ fn log_block_err(b: &ast::blk) { log_err print::pprust::block_to_str(b); }\n \n fn log_item_err(i: &@ast::item) { log_err print::pprust::item_to_str(i); }\n \n-fn log_fn(f: &ast::_fn, name: str, params: &ast::ty_param[]) {\n+fn log_fn(f: &ast::_fn, name: str, params: &[ast::ty_param]) {\n     log print::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_fn_err(f: &ast::_fn, name: str, params: &ast::ty_param[]) {\n+fn log_fn_err(f: &ast::_fn, name: str, params: &[ast::ty_param]) {\n     log_err print::pprust::fun_to_str(f, name, params);\n }\n \n@@ -161,7 +161,7 @@ fn call_kind_str(c: call_kind) -> str {\n     }\n }\n \n-fn is_main_name(path: &str[]) -> bool {\n+fn is_main_name(path: &[str]) -> bool {\n     str::eq(option::get(std::ivec::last(path)), \"main\")\n }\n "}, {"sha": "63d84d363e4f2f37cde351119fc1f5f812af4ff5", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b15045224ff1a0a051e513bc35561abee7a6f65/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=8b15045224ff1a0a051e513bc35561abee7a6f65", "patch": "@@ -42,8 +42,8 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         ret s + ty_to_str(cx, input.ty);\n     }\n     fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t[ast::ident],\n-                 inputs: &arg[], output: t, cf: ast::controlflow,\n-                 constrs: &(@constr)[]) -> str {\n+                 inputs: &[arg], output: t, cf: ast::controlflow,\n+                 constrs: &[@constr]) -> str {\n         let s = proto_to_str(proto);\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n@@ -98,7 +98,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       ty_type. { s += \"type\"; }\n       ty_task. { s += \"task\"; }\n       ty_rec(elems) {\n-        let strs: str[] = ~[];\n+        let strs: [str] = ~[];\n         for fld: field  in elems { strs += ~[field_to_str(cx, fld)]; }\n         s += \"{\" + str::connect_ivec(strs, \",\") + \"}\";\n       }\n@@ -107,7 +107,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n \n         s += \"<tag#\" + int::str(id.crate) + \":\" + int::str(id.node) + \">\";\n         if ivec::len[t](tps) > 0u {\n-            let strs: str[] = ~[];\n+            let strs: [str] = ~[];\n             for typ: t  in tps { strs += ~[ty_to_str(cx, typ)]; }\n             s += \"[\" + str::connect_ivec(strs, \",\") + \"]\";\n         }\n@@ -149,7 +149,7 @@ fn constr_to_str(c: &@constr) -> str {\n             pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n-fn constrs_str(constrs: &(@constr)[]) -> str {\n+fn constrs_str(constrs: &[@constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @constr  in constrs {"}]}